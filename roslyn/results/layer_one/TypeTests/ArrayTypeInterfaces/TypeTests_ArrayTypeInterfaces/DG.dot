digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 234440"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 234441"];
3 [label="param TypeTests(this) 234442"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 234443"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 234444"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 234445"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 234446"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 234447"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 234448"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 234449"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 234450"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 234451"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 234452"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 234453"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 234454"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 234455"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 234456"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 234457"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 234458"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 234459"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 234460"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 234461"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 234462"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 234463"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 234464"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 234465"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 234466"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 234467"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 234468"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 234469"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 234470"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 234471"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 234472"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 234473"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 234474"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 234475"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 234476"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 234477"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 234478"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 234479"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 234480"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 234481"];
43 [label="LazyThreadSafetyMode.PublicationOnly 234482"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 234483"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 234484"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 234485"];
47 [label="LazyThreadSafetyMode.PublicationOnly 234486"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 234487"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 234488"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 234489"];
51 [label="'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' 234490"];
52 [label="new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 234491"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 234492"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 234493"];
55 [label="LazyThreadSafetyMode.PublicationOnly 234494"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 234495"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 234496"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 234497"];
59 [label="LazyThreadSafetyMode.PublicationOnly 234498"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 234499"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 234500"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 234501"];
63 [label="LazyThreadSafetyMode.PublicationOnly 234502"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 234503"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 234504"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 234505"];
67 [label="LazyThreadSafetyMode.PublicationOnly 234506"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234507"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234508"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 234509"];
71 [label="LazyThreadSafetyMode.PublicationOnly 234510"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234511"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234512"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 234513"];
75 [label="LazyThreadSafetyMode.PublicationOnly 234514"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234515"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234516"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 234517"];
79 [label="LazyThreadSafetyMode.PublicationOnly 234518"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234519"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234520"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 234521"];
83 [label="LazyThreadSafetyMode.PublicationOnly 234522"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234523"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234524"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 234525"];
87 [label="LazyThreadSafetyMode.PublicationOnly 234526"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234527"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234528"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 234529"];
91 [label="LazyThreadSafetyMode.PublicationOnly 234530"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234531"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234532"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 234533"];
95 [label="LazyThreadSafetyMode.PublicationOnly 234534"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 234535"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 234536"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 234537"];
99 [label="LazyThreadSafetyMode.PublicationOnly 234538"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 234539"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 234540"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 234541"];
103 [label="LazyThreadSafetyMode.PublicationOnly 234542"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234543"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234544"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 234545"];
107 [label="LazyThreadSafetyMode.PublicationOnly 234546"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234547"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234548"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 234549"];
111 [label="LazyThreadSafetyMode.PublicationOnly 234550"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234551"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234552"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 234553"];
115 [label="LazyThreadSafetyMode.PublicationOnly 234554"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234555"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234556"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 234557"];
119 [label="LazyThreadSafetyMode.PublicationOnly 234558"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 234559"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 234560"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 234561"];
123 [label="LazyThreadSafetyMode.PublicationOnly 234562"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234563"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234564"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 234565"];
127 [label="LazyThreadSafetyMode.PublicationOnly 234566"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234567"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234568"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 234569"];
131 [label="LazyThreadSafetyMode.PublicationOnly 234570"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234571"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234572"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 234573"];
135 [label="LazyThreadSafetyMode.PublicationOnly 234574"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234575"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234576"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 234577"];
139 [label="LazyThreadSafetyMode.PublicationOnly 234578"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234579"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234580"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 234581"];
143 [label="LazyThreadSafetyMode.PublicationOnly 234582"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234583"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234584"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 234585"];
147 [label="LazyThreadSafetyMode.PublicationOnly 234586"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234587"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234588"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 234589"];
151 [label="LazyThreadSafetyMode.PublicationOnly 234590"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234591"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234592"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 234593"];
155 [label="LazyThreadSafetyMode.PublicationOnly 234594"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234595"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234596"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 234597"];
159 [label="LazyThreadSafetyMode.PublicationOnly 234598"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234599"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234600"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 234601"];
163 [label="LazyThreadSafetyMode.PublicationOnly 234602"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234603"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234604"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 234605"];
167 [label="LazyThreadSafetyMode.PublicationOnly 234606"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234607"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234608"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 234609"];
171 [label="LazyThreadSafetyMode.PublicationOnly 234610"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234611"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 234612"];
174 [label="@'R:\\Invalid.dll' 234613"];
175 [label="fullPath: @'R:\\Invalid.dll' 234614"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 234615"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 234616"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 234617"];
179 [label="MscorlibRef_v4_0_30316_17626 234618"];
180 [label="Net451.mscorlib 234619"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 234620"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 234621"];
183 [label="'/*<bind>*/' 234622"];
184 [label="StartString = '/*<bind>*/' 234623"];
185 [label="'/*</bind>*/' 234624"];
186 [label="EndString = '/*</bind>*/' 234625"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 234626"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 234627"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 234628"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 234629"];
191 [label="param CSharpTestBase(this) 234630"];
192 [label="param CommonTestBase(this) 234631"];
193 [label="param TestBase(this) 234632"];
194 [label="_temp 234633"];
195 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 234634"];
196 [label="param ArrayTypeInterfaces(this) 234635"];
197 [label="var text = @'\npublic class A {\n    static byte[][] AryField;\n    static byte[,] AryField2;\n}\n'; 234636"];
198 [label="var compilation = CreateEmptyCompilation(text, new[] { TestMetadata.Net40.mscorlib }); 234637"];
199 [label="var compilation = CreateEmptyCompilation(text, new[] { TestMetadata.Net40.mscorlib }); 234638"];
200 [label="new[] { TestMetadata.Net40.mscorlib } 234639"];
201 [label="new[] { TestMetadata.Net40.mscorlib } 234640"];
202 [label="param operator(string source) 234641"];
203 [label="source 234642"];
204 [label="new CSharpTestSource(source) 234643"];
205 [label="param CSharpTestSource(object value) 234644"];
206 [label="param CSharpTestSource(this) 234645"];
207 [label="Value 234646"];
208 [label="var compilation = CreateEmptyCompilation(text, new[] { TestMetadata.Net40.mscorlib }); 234647"];
209 [label="CreateEmptyCompilation(text, new[] { TestMetadata.Net40.mscorlib }) 234648"];
210 [label="param CreateEmptyCompilation(CSharpTestSource source) 234649"];
211 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 234650"];
212 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 234651"];
213 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 234652"];
214 [label="param CreateEmptyCompilation(string assemblyName = '') 234653"];
215 [label="param CreateEmptyCompilation(string sourceFileName = '') 234654"];
216 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 234655"];
217 [label="source 234656"];
218 [label="references 234657"];
219 [label="options 234658"];
220 [label="parseOptions 234659"];
221 [label="assemblyName 234660"];
222 [label="sourceFileName 234661"];
223 [label="skipUsesIsNullable 234662"];
224 [label="null 234663"];
225 [label="experimentalFeature: null 234664"];
226 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 234665"];
227 [label="param CreateCompilationCore(CSharpTestSource source) 234666"];
228 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 234667"];
229 [label="param CreateCompilationCore(CSharpCompilationOptions options) 234668"];
230 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 234669"];
231 [label="param CreateCompilationCore(string assemblyName) 234670"];
232 [label="param CreateCompilationCore(string sourceFileName) 234671"];
233 [label="param CreateCompilationCore(bool skipUsesIsNullable) 234672"];
234 [label="param CreateCompilationCore(MessageID? experimentalFeature) 234673"];
235 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 234674"];
236 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 234675"];
237 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 234676"];
238 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 234677"];
239 [label="param GetSyntaxTrees(string sourceFileName = '') 234678"];
240 [label="param GetSyntaxTrees(this) 234679"];
241 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 234680"];
242 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 234681"];
243 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 234682"];
244 [label="return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) }; 234683"];
245 [label="CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) 234684"];
246 [label="param Parse(string text) 234685"];
247 [label="param Parse(string filename = '') 234686"];
248 [label="param Parse(CSharpParseOptions options = null) 234687"];
249 [label="param Parse(Encoding encoding = null) 234688"];
250 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 234689"];
251 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 234690"];
252 [label="kind: SourceCodeKind.Regular 234691"];
253 [label="documentationMode: DocumentationMode.Parse 234692"];
254 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 234693"];
255 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 234694"];
256 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 234695"];
257 [label="SourceCodeKind.Script 234696"];
258 [label="Regular.WithKind(SourceCodeKind.Script) 234697"];
259 [label="Script = Regular.WithKind(SourceCodeKind.Script) 234698"];
260 [label="LanguageVersion.CSharp6 234699"];
261 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 234700"];
262 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 234701"];
263 [label="LanguageVersion.CSharp7 234702"];
264 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 234703"];
265 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 234704"];
266 [label="LanguageVersion.CSharp7_1 234705"];
267 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 234706"];
268 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 234707"];
269 [label="LanguageVersion.CSharp7_2 234708"];
270 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 234709"];
271 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 234710"];
272 [label="LanguageVersion.CSharp7_3 234711"];
273 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 234712"];
274 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 234713"];
275 [label="LanguageVersion.Default 234714"];
276 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 234715"];
277 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 234716"];
278 [label="LanguageVersion.Preview 234717"];
279 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 234718"];
280 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 234719"];
281 [label="LanguageVersion.CSharp8 234720"];
282 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 234721"];
283 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 234722"];
284 [label="LanguageVersion.CSharp9 234723"];
285 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 234724"];
286 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 234725"];
287 [label="DocumentationMode.Diagnose 234726"];
288 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 234727"];
289 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 234728"];
290 [label="Regular 234729"];
291 [label="'UseLegacyStrongNameProvider' 234730"];
292 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 234731"];
293 [label="param WithFeature(this CSharpParseOptions options) 234732"];
294 [label="param WithFeature(string feature) 234733"];
295 [label="param WithFeature(string value = 'true') 234734"];
296 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234735"];
297 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234736"];
298 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234737"];
299 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234738"];
300 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234739"];
301 [label="new[] { new KeyValuePair<string, string>(feature, value) } 234740"];
302 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 234741"];
303 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 234742"];
304 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 234743"];
305 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 234744"];
306 [label="1 234745"];
307 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 234746"];
308 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 234747"];
309 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 234748"];
310 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 234749"];
311 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 234750"];
312 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 234751"];
313 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 234752"];
314 [label="LanguageVersion.CSharp8 234753"];
315 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 234754"];
316 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 234755"];
317 [label="RegularWithExtendedPartialMethods = RegularPreview 234756"];
318 [label="new SmallDictionary<string, string> { } 234757"];
319 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 234758"];
320 [label="kind: SourceCodeKind.Regular 234759"];
321 [label="documentationMode: DocumentationMode.None 234760"];
322 [label="languageVersion: LanguageVersion.Preview 234761"];
323 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 234762"];
324 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 234763"];
325 [label="s_experimentalFeatures 234764"];
326 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 234765"];
327 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 234766"];
328 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 234767"];
329 [label="'testV7SwitchBinder' 234768"];
330 [label="'true' 234769"];
331 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 234770"];
332 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 234771"];
333 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 234772"];
334 [label="RegularWithoutRecursivePatterns = Regular7_3 234773"];
335 [label="RegularWithRecursivePatterns = Regular8 234774"];
336 [label="RegularWithoutPatternCombinators = Regular8 234775"];
337 [label="RegularWithPatternCombinators = RegularPreview 234776"];
338 [label="OutputKind.DynamicallyLinkedLibrary 234777"];
339 [label="OptimizationLevel.Release 234778"];
340 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 234779"];
341 [label="param CreateTestOptions(OutputKind outputKind) 234780"];
342 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234781"];
343 [label="param CreateTestOptions(bool allowUnsafe = false) 234782"];
344 [label="outputKind 234783"];
345 [label="optimizationLevel: optimizationLevel 234784"];
346 [label="warningLevel: Diagnostic.MaxWarningLevel 234785"];
347 [label="allowUnsafe: allowUnsafe 234786"];
348 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234787"];
349 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234788"];
350 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 234789"];
351 [label="OutputKind.ConsoleApplication 234790"];
352 [label="OptimizationLevel.Release 234791"];
353 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 234792"];
354 [label="param CreateTestOptions(OutputKind outputKind) 234793"];
355 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234794"];
356 [label="param CreateTestOptions(bool allowUnsafe = false) 234795"];
357 [label="outputKind 234796"];
358 [label="optimizationLevel: optimizationLevel 234797"];
359 [label="warningLevel: Diagnostic.MaxWarningLevel 234798"];
360 [label="allowUnsafe: allowUnsafe 234799"];
361 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234800"];
362 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234801"];
363 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 234802"];
364 [label="true 234803"];
365 [label="ReleaseDll.WithDebugPlusMode(true) 234804"];
366 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 234805"];
367 [label="true 234806"];
368 [label="ReleaseExe.WithDebugPlusMode(true) 234807"];
369 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 234808"];
370 [label="OutputKind.DynamicallyLinkedLibrary 234809"];
371 [label="OptimizationLevel.Debug 234810"];
372 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 234811"];
373 [label="param CreateTestOptions(OutputKind outputKind) 234812"];
374 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234813"];
375 [label="param CreateTestOptions(bool allowUnsafe = false) 234814"];
376 [label="outputKind 234815"];
377 [label="optimizationLevel: optimizationLevel 234816"];
378 [label="warningLevel: Diagnostic.MaxWarningLevel 234817"];
379 [label="allowUnsafe: allowUnsafe 234818"];
380 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234819"];
381 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234820"];
382 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 234821"];
383 [label="OutputKind.ConsoleApplication 234822"];
384 [label="OptimizationLevel.Debug 234823"];
385 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 234824"];
386 [label="param CreateTestOptions(OutputKind outputKind) 234825"];
387 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234826"];
388 [label="param CreateTestOptions(bool allowUnsafe = false) 234827"];
389 [label="outputKind 234828"];
390 [label="optimizationLevel: optimizationLevel 234829"];
391 [label="warningLevel: Diagnostic.MaxWarningLevel 234830"];
392 [label="allowUnsafe: allowUnsafe 234831"];
393 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234832"];
394 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234833"];
395 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 234834"];
396 [label="OutputKind.WindowsRuntimeMetadata 234835"];
397 [label="OptimizationLevel.Release 234836"];
398 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 234837"];
399 [label="param CreateTestOptions(OutputKind outputKind) 234838"];
400 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234839"];
401 [label="param CreateTestOptions(bool allowUnsafe = false) 234840"];
402 [label="outputKind 234841"];
403 [label="optimizationLevel: optimizationLevel 234842"];
404 [label="warningLevel: Diagnostic.MaxWarningLevel 234843"];
405 [label="allowUnsafe: allowUnsafe 234844"];
406 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234845"];
407 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234846"];
408 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 234847"];
409 [label="OutputKind.WindowsRuntimeMetadata 234848"];
410 [label="OptimizationLevel.Debug 234849"];
411 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 234850"];
412 [label="param CreateTestOptions(OutputKind outputKind) 234851"];
413 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234852"];
414 [label="param CreateTestOptions(bool allowUnsafe = false) 234853"];
415 [label="outputKind 234854"];
416 [label="optimizationLevel: optimizationLevel 234855"];
417 [label="warningLevel: Diagnostic.MaxWarningLevel 234856"];
418 [label="allowUnsafe: allowUnsafe 234857"];
419 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234858"];
420 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234859"];
421 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 234860"];
422 [label="OutputKind.NetModule 234861"];
423 [label="OptimizationLevel.Release 234862"];
424 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 234863"];
425 [label="param CreateTestOptions(OutputKind outputKind) 234864"];
426 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234865"];
427 [label="param CreateTestOptions(bool allowUnsafe = false) 234866"];
428 [label="outputKind 234867"];
429 [label="optimizationLevel: optimizationLevel 234868"];
430 [label="warningLevel: Diagnostic.MaxWarningLevel 234869"];
431 [label="allowUnsafe: allowUnsafe 234870"];
432 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234871"];
433 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234872"];
434 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 234873"];
435 [label="OutputKind.NetModule 234874"];
436 [label="OptimizationLevel.Debug 234875"];
437 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 234876"];
438 [label="param CreateTestOptions(OutputKind outputKind) 234877"];
439 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 234878"];
440 [label="param CreateTestOptions(bool allowUnsafe = false) 234879"];
441 [label="outputKind 234880"];
442 [label="optimizationLevel: optimizationLevel 234881"];
443 [label="warningLevel: Diagnostic.MaxWarningLevel 234882"];
444 [label="allowUnsafe: allowUnsafe 234883"];
445 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234884"];
446 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 234885"];
447 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 234886"];
448 [label="true 234887"];
449 [label="ReleaseDll.WithAllowUnsafe(true) 234888"];
450 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 234889"];
451 [label="true 234890"];
452 [label="ReleaseExe.WithAllowUnsafe(true) 234891"];
453 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 234892"];
454 [label="true 234893"];
455 [label="DebugDll.WithAllowUnsafe(true) 234894"];
456 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 234895"];
457 [label="true 234896"];
458 [label="DebugExe.WithAllowUnsafe(true) 234897"];
459 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 234898"];
460 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 234899"];
461 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234900"];
462 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234901"];
463 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 234902"];
464 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234903"];
465 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234904"];
466 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 234905"];
467 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234906"];
468 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234907"];
469 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 234908"];
470 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234909"];
471 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 234910"];
472 [label="DebugInformationFormat.Pdb 234911"];
473 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 234912"];
474 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 234913"];
475 [label="options = TestOptions.Regular; 234914"];
476 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 234915"];
477 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 234916"];
478 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 234917"];
479 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 234918"];
480 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 234919"];
481 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 234920"];
482 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 234921"];
483 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 234922"];
484 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 234923"];
485 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 234924"];
486 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 234925"];
487 [label="param CheckSerializable(SyntaxTree tree) 234926"];
488 [label="var stream = new MemoryStream(); 234927"];
489 [label="var root = tree.GetRoot(); 234928"];
490 [label="var root = tree.GetRoot(); 234929"];
491 [label="root.SerializeTo(stream); 234930"];
492 [label="root.SerializeTo(stream); 234931"];
493 [label="root.SerializeTo(stream); 234932"];
494 [label="stream.Position = 0; 234933"];
495 [label="stream.Position 234934"];
496 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 234935"];
497 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 234936"];
498 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 234937"];
499 [label="return tree; 234938"];
500 [label="new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) } 234939"];
501 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 234940"];
502 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 234941"];
503 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 234942"];
504 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 234943"];
505 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 234944"];
506 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 234945"];
507 [label="hasTopLevelStatements 234946"];
508 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 234947"];
509 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 234948"];
510 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 234949"];
511 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 234950"];
512 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 234951"];
513 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 234952"];
514 [label="param ValidateIOperations(Func<Compilation> createCompilation) 234953"];
515 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 234954"];
516 [label="return; 234955"];
517 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 234956"];
518 [label="var compilation = createCompilationLambda(); 234957"];
519 [label="var compilation = createCompilationLambda(); 234958"];
520 [label="return Guid.NewGuid().ToString('D'); 234959"];
521 [label="var compilation = createCompilationLambda(); 234960"];
522 [label="OutputKind.ConsoleApplication 234961"];
523 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 234962"];
524 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 234963"];
525 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 234964"];
526 [label="OutputKind.DynamicallyLinkedLibrary 234965"];
527 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 234966"];
528 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 234967"];
529 [label="true 234968"];
530 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 234969"];
531 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 234970"];
532 [label="param Create(string? assemblyName) 234971"];
533 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 234972"];
534 [label="param Create(IEnumerable<MetadataReference>? references = null) 234973"];
535 [label="param Create(CSharpCompilationOptions? options = null) 234974"];
536 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 234975"];
537 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 234976"];
538 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 234977"];
539 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 234978"];
540 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 234979"];
541 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 234980"];
542 [label="param Create(string? assemblyName) 234981"];
543 [label="param Create(CSharpCompilationOptions options) 234982"];
544 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 234983"];
545 [label="param Create(IEnumerable<MetadataReference>? references) 234984"];
546 [label="param Create(CSharpCompilation? previousSubmission) 234985"];
547 [label="param Create(Type? returnType) 234986"];
548 [label="param Create(Type? hostObjectType) 234987"];
549 [label="param Create(bool isSubmission) 234988"];
550 [label="RoslynDebug.Assert(options != null); 234989"];
551 [label="RoslynDebug.Assert(options != null); 234990"];
552 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 234991"];
553 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 234992"];
554 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 234993"];
555 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234994"];
556 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234995"];
557 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234996"];
558 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234997"];
559 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234998"];
560 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 234999"];
561 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 235000"];
562 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 235001"];
563 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 235002"];
564 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 235003"];
565 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 235004"];
566 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 235005"];
567 [label="param CSharpCompilation(string? assemblyName) 235006"];
568 [label="param CSharpCompilation(CSharpCompilationOptions options) 235007"];
569 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 235008"];
570 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 235009"];
571 [label="param CSharpCompilation(Type? submissionReturnType) 235010"];
572 [label="param CSharpCompilation(Type? hostObjectType) 235011"];
573 [label="param CSharpCompilation(bool isSubmission) 235012"];
574 [label="param CSharpCompilation(ReferenceManager? referenceManager) 235013"];
575 [label="param CSharpCompilation(bool reuseReferenceManager) 235014"];
576 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 235015"];
577 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 235016"];
578 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 235017"];
579 [label="param CSharpCompilation(this) 235018"];
580 [label="assemblyName 235019"];
581 [label="options 235020"];
582 [label="references 235021"];
583 [label="previousSubmission 235022"];
584 [label="submissionReturnType 235023"];
585 [label="hostObjectType 235024"];
586 [label="isSubmission 235025"];
587 [label="referenceManager 235026"];
588 [label="reuseReferenceManager 235027"];
589 [label="syntaxAndDeclarations 235028"];
590 [label="syntaxAndDeclarations.ExternalSyntaxTrees 235029"];
591 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 235030"];
592 [label="semanticModelProvider 235031"];
593 [label="eventQueue 235032"];
594 [label="param CSharpCompilation(this) 235033"];
595 [label="param CSharpCompilation(string? assemblyName) 235034"];
596 [label="param CSharpCompilation(CSharpCompilationOptions options) 235035"];
597 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 235036"];
598 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 235037"];
599 [label="param CSharpCompilation(Type? submissionReturnType) 235038"];
600 [label="param CSharpCompilation(Type? hostObjectType) 235039"];
601 [label="param CSharpCompilation(bool isSubmission) 235040"];
602 [label="param CSharpCompilation(ReferenceManager? referenceManager) 235041"];
603 [label="param CSharpCompilation(bool reuseReferenceManager) 235042"];
604 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 235043"];
605 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 235044"];
606 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 235045"];
607 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 235046"];
608 [label="param CSharpCompilation(this) 235047"];
609 [label="assemblyName 235048"];
610 [label="references 235049"];
611 [label="features 235050"];
612 [label="isSubmission 235051"];
613 [label="semanticModelProvider 235052"];
614 [label="eventQueue 235053"];
615 [label="param CSharpCompilation(this) 235054"];
616 [label="param CSharpCompilation(this) 235055"];
617 [label="_options 235056"];
618 [label="_globalImports 235057"];
619 [label="_previousSubmissionImports 235058"];
620 [label="_globalNamespaceAlias 235059"];
621 [label="_scriptClass 235060"];
622 [label="_lazyHostObjectTypeSymbol 235061"];
623 [label="_lazyImportInfos 235062"];
624 [label="_conversions 235063"];
625 [label="_anonymousTypeManager 235064"];
626 [label="_lazyGlobalNamespace 235065"];
627 [label="builtInOperators 235066"];
628 [label="_lazyAssemblySymbol 235067"];
629 [label="_referenceManager 235068"];
630 [label="_syntaxAndDeclarations 235069"];
631 [label="_lazyEntryPoint 235070"];
632 [label="_lazyEmitNullablePublicOnly 235071"];
633 [label="_lazyCompilationUnitCompletedTrees 235072"];
634 [label="NullableAnalysisData 235073"];
635 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 235074"];
636 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 235075"];
637 [label="_externAliasTargets 235076"];
638 [label="_moduleInitializerMethods 235077"];
639 [label="_binderFactories 235078"];
640 [label="_ignoreAccessibilityBinderFactories 235079"];
641 [label="_lazyDeclarationDiagnostics 235080"];
642 [label="_declarationDiagnosticsFrozen 235081"];
643 [label="new DiagnosticBag() 235082"];
644 [label="_additionalCodegenWarnings = new DiagnosticBag() 235083"];
645 [label="WellKnownMemberSignatureComparer 235084"];
646 [label="_lazyWellKnownTypes 235085"];
647 [label="_lazyWellKnownTypeMembers 235086"];
648 [label="_usesNullableAttributes 235087"];
649 [label="_needsGeneratedAttributes 235088"];
650 [label="_needsGeneratedAttributes_IsFrozen 235089"];
651 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 235090"];
652 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 235091"];
653 [label="new WellKnownMembersSignatureComparer(this) 235092"];
654 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 235093"];
655 [label="param WellKnownMembersSignatureComparer(this) 235094"];
656 [label="new SpecialMembersSignatureComparer() 235095"];
657 [label="param SpecialMembersSignatureComparer(this) 235096"];
658 [label="Instance = new SpecialMembersSignatureComparer() 235097"];
659 [label="param WellKnownMembersSignatureComparer(this) 235098"];
660 [label="param SpecialMembersSignatureComparer(this) 235099"];
661 [label="param SpecialMembersSignatureComparer(this) 235100"];
662 [label="_compilation 235101"];
663 [label="_compilation 235102"];
664 [label="WellKnownMemberSignatureComparer 235103"];
665 [label="_options 235104"];
666 [label="this.builtInOperators = new BuiltInOperators(this); 235105"];
667 [label="this.builtInOperators = new BuiltInOperators(this); 235106"];
668 [label="this.builtInOperators 235107"];
669 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 235108"];
670 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 235109"];
671 [label="_scriptClass 235110"];
672 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 235111"];
673 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 235112"];
674 [label="_globalImports 235113"];
675 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 235114"];
676 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 235115"];
677 [label="_previousSubmissionImports 235116"];
678 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 235117"];
679 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 235118"];
680 [label="_globalNamespaceAlias 235119"];
681 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 235120"];
682 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 235121"];
683 [label="new AnonymousTypeManager(this) 235122"];
684 [label="param AnonymousTypeManager(CSharpCompilation compilation) 235123"];
685 [label="param AnonymousTypeManager(this) 235124"];
686 [label="param AnonymousTypeManager(this) 235125"];
687 [label="public CSharpCompilation Compilation { get; } 235126"];
688 [label="_lazyAnonymousTypeTemplates 235127"];
689 [label="_lazySynthesizedDelegates 235128"];
690 [label="new ConcurrentDictionary<Location, bool>() 235129"];
691 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 235130"];
692 [label="Debug.Assert(compilation != null); 235131"];
693 [label="Debug.Assert(compilation != null); 235132"];
694 [label="this.Compilation 235133"];
695 [label="_anonymousTypeManager 235134"];
696 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 235135"];
697 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 235136"];
698 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 235137"];
699 [label="LanguageVersion? result = null; 235138"];
700 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 235139"];
701 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 235140"];
702 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 235141"];
703 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 235142"];
704 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 235143"];
705 [label="this.LanguageVersion 235144"];
706 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 235145"];
707 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235146"];
708 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235147"];
709 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235148"];
710 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235149"];
711 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235150"];
712 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235151"];
713 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 235152"];
714 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 235153"];
715 [label="this.Options 235154"];
716 [label="get\n            {\n                return _options;\n            } 235155"];
717 [label="return _options; 235156"];
718 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 235157"];
719 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 235158"];
720 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 235159"];
721 [label="param ReferenceManager(string simpleAssemblyName) 235160"];
722 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 235161"];
723 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 235162"];
724 [label="param ReferenceManager(this) 235163"];
725 [label="simpleAssemblyName 235164"];
726 [label="identityComparer 235165"];
727 [label="observedMetadata 235166"];
728 [label="param ReferenceManager(this) 235167"];
729 [label="param ReferenceManager(this) 235168"];
730 [label="_referenceManager 235169"];
731 [label="_syntaxAndDeclarations 235170"];
732 [label="Debug.Assert(_lazyAssemblySymbol is null); 235171"];
733 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 235172"];
734 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 235173"];
735 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 235174"];
736 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 235175"];
737 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 235176"];
738 [label="compilation.AddSyntaxTrees(syntaxTrees) 235177"];
739 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 235178"];
740 [label="param AddSyntaxTrees(this) 235179"];
741 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 235180"];
742 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 235181"];
743 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 235182"];
744 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 235183"];
745 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 235184"];
746 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 235185"];
747 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 235186"];
748 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 235187"];
749 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 235188"];
750 [label="bool reuseReferenceManager = true; 235189"];
751 [label="int i = 0; 235190"];
752 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 235191"];
753 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 235192"];
754 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 235193"];
755 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 235194"];
756 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 235195"];
757 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 235196"];
758 [label="externalSyntaxTrees.Add(tree); 235197"];
759 [label="externalSyntaxTrees.Add(tree); 235198"];
760 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 235199"];
761 [label="i++; 235200"];
762 [label="externalSyntaxTrees.Free(); 235201"];
763 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 235202"];
764 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 235203"];
765 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 235204"];
766 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 235205"];
767 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 235206"];
768 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 235207"];
769 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 235208"];
770 [label="param Update(ReferenceManager referenceManager) 235209"];
771 [label="param Update(bool reuseReferenceManager) 235210"];
772 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 235211"];
773 [label="param Update(this) 235212"];
774 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235213"];
775 [label="this.PreviousSubmission 235214"];
776 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 235215"];
777 [label="ScriptCompilationInfo 235216"];
778 [label="ScriptCompilationInfo?.PreviousScriptCompilation 235217"];
779 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235218"];
780 [label="this.SubmissionReturnType 235219"];
781 [label="=> ScriptCompilationInfo 235220"];
782 [label="ScriptCompilationInfo 235221"];
783 [label="this.HostObjectType 235222"];
784 [label="=> ScriptCompilationInfo 235223"];
785 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235224"];
786 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235225"];
787 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235226"];
788 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 235227"];
789 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 235228"];
790 [label="param CSharpCompilation(string? assemblyName) 235229"];
791 [label="param CSharpCompilation(CSharpCompilationOptions options) 235230"];
792 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 235231"];
793 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 235232"];
794 [label="param CSharpCompilation(Type? submissionReturnType) 235233"];
795 [label="param CSharpCompilation(Type? hostObjectType) 235234"];
796 [label="param CSharpCompilation(bool isSubmission) 235235"];
797 [label="param CSharpCompilation(ReferenceManager? referenceManager) 235236"];
798 [label="param CSharpCompilation(bool reuseReferenceManager) 235237"];
799 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 235238"];
800 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 235239"];
801 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 235240"];
802 [label="param CSharpCompilation(this) 235241"];
803 [label="previousSubmission 235242"];
804 [label="submissionReturnType 235243"];
805 [label="hostObjectType 235244"];
806 [label="syntaxAndDeclarations.ExternalSyntaxTrees 235245"];
807 [label="eventQueue 235246"];
808 [label="param CSharpCompilation(this) 235247"];
809 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 235248"];
810 [label="param CSharpCompilation(Type? submissionReturnType) 235249"];
811 [label="param CSharpCompilation(Type? hostObjectType) 235250"];
812 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 235251"];
813 [label="param CSharpCompilation(this) 235252"];
814 [label="eventQueue 235253"];
815 [label="param CSharpCompilation(this) 235254"];
816 [label="_options 235255"];
817 [label="_globalImports 235256"];
818 [label="_previousSubmissionImports 235257"];
819 [label="_globalNamespaceAlias 235258"];
820 [label="_scriptClass 235259"];
821 [label="_lazyHostObjectTypeSymbol 235260"];
822 [label="_lazyImportInfos 235261"];
823 [label="_conversions 235262"];
824 [label="_anonymousTypeManager 235263"];
825 [label="_lazyGlobalNamespace 235264"];
826 [label="builtInOperators 235265"];
827 [label="_lazyAssemblySymbol 235266"];
828 [label="_referenceManager 235267"];
829 [label="_syntaxAndDeclarations 235268"];
830 [label="_lazyEntryPoint 235269"];
831 [label="_lazyEmitNullablePublicOnly 235270"];
832 [label="_lazyCompilationUnitCompletedTrees 235271"];
833 [label="NullableAnalysisData 235272"];
834 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 235273"];
835 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 235274"];
836 [label="_externAliasTargets 235275"];
837 [label="_moduleInitializerMethods 235276"];
838 [label="_binderFactories 235277"];
839 [label="_ignoreAccessibilityBinderFactories 235278"];
840 [label="_lazyDeclarationDiagnostics 235279"];
841 [label="_declarationDiagnosticsFrozen 235280"];
842 [label="new DiagnosticBag() 235281"];
843 [label="_additionalCodegenWarnings = new DiagnosticBag() 235282"];
844 [label="WellKnownMemberSignatureComparer 235283"];
845 [label="_lazyWellKnownTypes 235284"];
846 [label="_lazyWellKnownTypeMembers 235285"];
847 [label="_usesNullableAttributes 235286"];
848 [label="_needsGeneratedAttributes 235287"];
849 [label="_needsGeneratedAttributes_IsFrozen 235288"];
850 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 235289"];
851 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 235290"];
852 [label="new WellKnownMembersSignatureComparer(this) 235291"];
853 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 235292"];
854 [label="param WellKnownMembersSignatureComparer(this) 235293"];
855 [label="param WellKnownMembersSignatureComparer(this) 235294"];
856 [label="param SpecialMembersSignatureComparer(this) 235295"];
857 [label="param SpecialMembersSignatureComparer(this) 235296"];
858 [label="_compilation 235297"];
859 [label="_compilation 235298"];
860 [label="WellKnownMemberSignatureComparer 235299"];
861 [label="this.builtInOperators = new BuiltInOperators(this); 235300"];
862 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 235301"];
863 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 235302"];
864 [label="new AnonymousTypeManager(this) 235303"];
865 [label="param AnonymousTypeManager(CSharpCompilation compilation) 235304"];
866 [label="param AnonymousTypeManager(this) 235305"];
867 [label="param AnonymousTypeManager(this) 235306"];
868 [label="public CSharpCompilation Compilation { get; } 235307"];
869 [label="_lazyAnonymousTypeTemplates 235308"];
870 [label="_lazySynthesizedDelegates 235309"];
871 [label="new ConcurrentDictionary<Location, bool>() 235310"];
872 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 235311"];
873 [label="Debug.Assert(compilation != null); 235312"];
874 [label="Debug.Assert(compilation != null); 235313"];
875 [label="this.Compilation 235314"];
876 [label="_anonymousTypeManager 235315"];
877 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 235316"];
878 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 235317"];
879 [label="LanguageVersion? result = null; 235318"];
880 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 235319"];
881 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 235320"];
882 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 235321"];
883 [label="result = version; 235322"];
884 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 235323"];
885 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235324"];
886 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235325"];
887 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235326"];
888 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235327"];
889 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235328"];
890 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 235329"];
891 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 235330"];
892 [label="referenceManager.AssertCanReuseForCompilation(this); 235331"];
893 [label="referenceManager.AssertCanReuseForCompilation(this); 235332"];
894 [label="_referenceManager 235333"];
895 [label="Debug.Assert(_lazyAssemblySymbol is null); 235334"];
896 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 235335"];
897 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 235336"];
898 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 235337"];
899 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 235338"];
900 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 235339"];
901 [label="return compilation; 235340"];
902 [label="var compilation = createCompilationLambda(); 235341"];
903 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 235342"];
904 [label="IsNullableEnabled(compilation) 235343"];
905 [label="param IsNullableEnabled(CSharpCompilation compilation) 235344"];
906 [label="compilation.SyntaxTrees 235345"];
907 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 235346"];
908 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 235347"];
909 [label="var trees = compilation.SyntaxTrees; 235348"];
910 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 235349"];
911 [label="var options = (CSharpParseOptions)trees[0].Options; 235350"];
912 [label="var options = (CSharpParseOptions)trees[0].Options; 235351"];
913 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 235352"];
914 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 235353"];
915 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 235354"];
916 [label="return compilation; 235355"];
917 [label="int[] ary = new int[2]; 235356"];
918 [label="compilation.SourceModule 235357"];
919 [label="get\n            {\n                return Assembly.Modules[0];\n            } 235358"];
920 [label="Assembly 235359"];
921 [label="get\n            {\n                return SourceAssembly;\n            } 235360"];
922 [label="SourceAssembly 235361"];
923 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 235362"];
924 [label="GetBoundReferenceManager() 235363"];
925 [label="param GetBoundReferenceManager(this) 235364"];
926 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 235365"];
927 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 235366"];
928 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 235367"];
929 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 235368"];
930 [label="param CreateSourceAssemblyForCompilation(this) 235369"];
931 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 235370"];
932 [label="CreateAndSetSourceAssemblyFullBind(compilation) 235371"];
933 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 235372"];
934 [label="param CreateAndSetSourceAssemblyFullBind(this) 235373"];
935 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 235374"];
936 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 235375"];
937 [label="compilation.Options 235376"];
938 [label="get\n            {\n                return _options;\n            } 235377"];
939 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 235378"];
940 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 235379"];
941 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 235380"];
942 [label="boundReferenceDirectives 235381"];
943 [label="ImmutableArray<AssemblyData> referencedAssemblies; 235382"];
944 [label="referencedAssemblies 235383"];
945 [label="ImmutableArray<PEModule> modules; 235384"];
946 [label="modules 235385"];
947 [label="ImmutableArray<MetadataReference> explicitReferences; 235386"];
948 [label="explicitReferences 235387"];
949 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235388"];
950 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235389"];
951 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235390"];
952 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235391"];
953 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235392"];
954 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235393"];
955 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235394"];
956 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235395"];
957 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235396"];
958 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235397"];
959 [label="get { return this.Declarations.ReferenceDirectives; } 235398"];
960 [label="this.Declarations 235399"];
961 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 235400"];
962 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 235401"];
963 [label="return this.Declarations.ReferenceDirectives; 235402"];
964 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 235403"];
965 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 235404"];
966 [label="SymbolDisplayCompilerInternalOptions.None 235405"];
967 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 235406"];
968 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 235407"];
969 [label="this.Declarations.ReferenceDirectives 235408"];
970 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 235409"];
971 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 235410"];
972 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 235411"];
973 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 235412"];
974 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 235413"];
975 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 235414"];
976 [label="var result = DeclarationModifiers.None; 235415"];
977 [label="bool seenNoDuplicates = true; 235416"];
978 [label="bool seenNoAccessibilityDuplicates = true; 235417"];
979 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 235418"];
980 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 235419"];
981 [label="ToDeclarationModifier(modifier.ContextualKind()) 235420"];
982 [label="param ToDeclarationModifier(SyntaxKind kind) 235421"];
983 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                    return DeclarationModifiers.Abstract;\n                case SyntaxKind.AsyncKeyword:\n                    return DeclarationModifiers.Async;\n                case SyntaxKind.SealedKeyword:\n                    return DeclarationModifiers.Sealed;\n                case SyntaxKind.StaticKeyword:\n                    return DeclarationModifiers.Static;\n                case SyntaxKind.NewKeyword:\n                    return DeclarationModifiers.New;\n                case SyntaxKind.PublicKeyword:\n                    return DeclarationModifiers.Public;\n                case SyntaxKind.ProtectedKeyword:\n                    return DeclarationModifiers.Protected;\n                case SyntaxKind.InternalKeyword:\n                    return DeclarationModifiers.Internal;\n                case SyntaxKind.PrivateKeyword:\n                    return DeclarationModifiers.Private;\n                case SyntaxKind.ExternKeyword:\n                    return DeclarationModifiers.Extern;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return DeclarationModifiers.ReadOnly;\n                case SyntaxKind.PartialKeyword:\n                    return DeclarationModifiers.Partial;\n                case SyntaxKind.UnsafeKeyword:\n                    return DeclarationModifiers.Unsafe;\n                case SyntaxKind.VirtualKeyword:\n                    return DeclarationModifiers.Virtual;\n                case SyntaxKind.OverrideKeyword:\n                    return DeclarationModifiers.Override;\n                case SyntaxKind.ConstKeyword:\n                    return DeclarationModifiers.Const;\n                case SyntaxKind.FixedKeyword:\n                    return DeclarationModifiers.Fixed;\n                case SyntaxKind.VolatileKeyword:\n                    return DeclarationModifiers.Volatile;\n                case SyntaxKind.RefKeyword:\n                    return DeclarationModifiers.Ref;\n                case SyntaxKind.DataKeyword:\n                    return DeclarationModifiers.Data;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 235422"];
984 [label="return DeclarationModifiers.Public; 235423"];
985 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235424"];
986 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235425"];
987 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235426"];
988 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235427"];
989 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235428"];
990 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 235429"];
991 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 235430"];
992 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 235431"];
993 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 235432"];
994 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 235433"];
995 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 235434"];
996 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 235435"];
997 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 235436"];
998 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 235437"];
999 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 235438"];
1000 [label="result |= one; 235439"];
1001 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 235440"];
1002 [label="return result; 235441"];
1003 [label="get { return _options; } 235442"];
1004 [label="return _options; 235443"];
1005 [label="get { return CSharp.MessageProvider.Instance; } 235444"];
1006 [label="return CSharp.MessageProvider.Instance; 235445"];
1007 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235446"];
1008 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 235447"];
1009 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 235448"];
1010 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 235449"];
1011 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 235450"];
1012 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 235451"];
1013 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 235452"];
1014 [label="param CreateAssemblyDataForFile(this) 235453"];
1015 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235454"];
1016 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235455"];
1017 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235456"];
1018 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235457"];
1019 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235458"];
1020 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235459"];
1021 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 235460"];
1022 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 235461"];
1023 [label="param AssemblyDataForFile(PEAssembly assembly) 235462"];
1024 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 235463"];
1025 [label="param AssemblyDataForFile(bool embedInteropTypes) 235464"];
1026 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 235465"];
1027 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 235466"];
1028 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 235467"];
1029 [label="param AssemblyDataForFile(this) 235468"];
1030 [label="assembly.Identity 235469"];
1031 [label="assembly.AssemblyReferences 235470"];
1032 [label="embedInteropTypes 235471"];
1033 [label="param AssemblyDataForFile(this) 235472"];
1034 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 235473"];
1035 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 235474"];
1036 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 235475"];
1037 [label="param AssemblyDataForMetadataOrCompilation(this) 235476"];
1038 [label="param AssemblyDataForMetadataOrCompilation(this) 235477"];
1039 [label="_assemblies 235478"];
1040 [label="_identity 235479"];
1041 [label="_embedInteropTypes 235480"];
1042 [label="RoslynDebug.Assert(identity != null); 235481"];
1043 [label="RoslynDebug.Assert(identity != null); 235482"];
1044 [label="Debug.Assert(!referencedAssemblies.IsDefault); 235483"];
1045 [label="_embedInteropTypes 235484"];
1046 [label="_identity 235485"];
1047 [label="_referencedAssemblies 235486"];
1048 [label="Assembly 235487"];
1049 [label="CachedSymbols 235488"];
1050 [label="DocumentationProvider 235489"];
1051 [label="_compilationImportOptions 235490"];
1052 [label="_sourceAssemblySimpleName 235491"];
1053 [label="_internalsVisibleComputed 235492"];
1054 [label="_internalsPotentiallyVisibleToCompilation 235493"];
1055 [label="RoslynDebug.Assert(documentationProvider != null); 235494"];
1056 [label="RoslynDebug.Assert(documentationProvider != null); 235495"];
1057 [label="RoslynDebug.Assert(cachedSymbols != null); 235496"];
1058 [label="RoslynDebug.Assert(cachedSymbols != null); 235497"];
1059 [label="CachedSymbols 235498"];
1060 [label="Assembly 235499"];
1061 [label="DocumentationProvider 235500"];
1062 [label="_compilationImportOptions 235501"];
1063 [label="_sourceAssemblySimpleName 235502"];
1064 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 235503"];
1065 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 235504"];
1066 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 235505"];
1067 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 235506"];
1068 [label="get\n                    {\n                        return _identity;\n                    } 235507"];
1069 [label="return _identity; 235508"];
1070 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 235509"];
1071 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 235510"];
1072 [label="bool hasCircularReference; 235511"];
1073 [label="int corLibraryIndex; 235512"];
1074 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 235513"];
1075 [label="implicitlyResolvedReferences 235514"];
1076 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 235515"];
1077 [label="implicitlyResolvedReferenceMap 235516"];
1078 [label="ImmutableArray<AssemblyData> allAssemblyData; 235517"];
1079 [label="allAssemblyData 235518"];
1080 [label="var temp1 = compilation.ScriptCompilationInfo; 235519"];
1081 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 235520"];
1082 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 235521"];
1083 [label="temp1 != null 235522"];
1084 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 235523"];
1085 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 235524"];
1086 [label="temp2 != null 235525"];
1087 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 235526"];
1088 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 235527"];
1089 [label="temp3 != null 235528"];
1090 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 235529"];
1091 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 235530"];
1092 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235531"];
1093 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235532"];
1094 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235533"];
1095 [label="compilation.Options 235534"];
1096 [label="get\n            {\n                return _options;\n            } 235535"];
1097 [label="return _options; 235536"];
1098 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235537"];
1099 [label="compilation.Options 235538"];
1100 [label="get\n            {\n                return _options;\n            } 235539"];
1101 [label="return _options; 235540"];
1102 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235541"];
1103 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235542"];
1104 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235543"];
1105 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235544"];
1106 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235545"];
1107 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235546"];
1108 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235547"];
1109 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235548"];
1110 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235549"];
1111 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235550"];
1112 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235551"];
1113 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 235552"];
1114 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 235553"];
1115 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 235554"];
1116 [label="param BindAssemblyReferences(this) 235555"];
1117 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 235556"];
1118 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 235557"];
1119 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 235558"];
1120 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 235559"];
1121 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 235560"];
1122 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 235561"];
1123 [label="return _embedInteropTypes; 235562"];
1124 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 235563"];
1125 [label="return _referencedAssemblies; 235564"];
1126 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 235565"];
1127 [label="return Assembly.ContainsNoPiaLocalTypes(); 235566"];
1128 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 235567"];
1129 [label="return Assembly.DeclaresTheObjectClass; 235568"];
1130 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 235569"];
1131 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 235570"];
1132 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 235571"];
1133 [label="_assemblies = new List<AssemblySymbol>(); 235572"];
1134 [label="_assemblies 235573"];
1135 [label="AddAvailableSymbols(_assemblies); 235574"];
1136 [label="AddAvailableSymbols(_assemblies) 235575"];
1137 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 235576"];
1138 [label="param AddAvailableSymbols(this) 235577"];
1139 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 235578"];
1140 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 235579"];
1141 [label="AddAvailableSymbols(_assemblies); 235580"];
1142 [label="return _assemblies; 235581"];
1143 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 235582"];
1144 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 235583"];
1145 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 235584"];
1146 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 235585"];
1147 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 235586"];
1148 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 235587"];
1149 [label="aliasesOfReferencedAssemblies 235588"];
1150 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235589"];
1151 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235590"];
1152 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235591"];
1153 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235592"];
1154 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235593"];
1155 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235594"];
1156 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235595"];
1157 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235596"];
1158 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235597"];
1159 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 235598"];
1160 [label="var newSymbols = new List<int>(); 235599"];
1161 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 235600"];
1162 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 235601"];
1163 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 235602"];
1164 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 235603"];
1165 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 235604"];
1166 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 235605"];
1167 [label="param CreateAssemblySymbol(this) 235606"];
1168 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 235607"];
1169 [label="this.IsLinked 235608"];
1170 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 235609"];
1171 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 235610"];
1172 [label="this.EffectiveImportOptions 235611"];
1173 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 235612"];
1174 [label="InternalsMayBeVisibleToCompilation 235613"];
1175 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 235614"];
1176 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 235615"];
1177 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 235616"];
1178 [label="_internalsPotentiallyVisibleToCompilation 235617"];
1179 [label="_internalsVisibleComputed = true; 235618"];
1180 [label="_internalsVisibleComputed 235619"];
1181 [label="return _internalsPotentiallyVisibleToCompilation; 235620"];
1182 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 235621"];
1183 [label="return _compilationImportOptions; 235622"];
1184 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 235623"];
1185 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 235624"];
1186 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 235625"];
1187 [label="param PEAssemblySymbol(PEAssembly assembly) 235626"];
1188 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 235627"];
1189 [label="param PEAssemblySymbol(bool isLinked) 235628"];
1190 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 235629"];
1191 [label="param PEAssemblySymbol(this) 235630"];
1192 [label="param PEAssemblySymbol(this) 235631"];
1193 [label="param MetadataOrSourceAssemblySymbol(this) 235632"];
1194 [label="param MetadataOrSourceAssemblySymbol(this) 235633"];
1195 [label="param NonMissingAssemblySymbol(this) 235634"];
1196 [label="new char[] { '+' } 235635"];
1197 [label="'+' 235636"];
1198 [label="new char[] { '+' } 235637"];
1199 [label="s_nestedTypeNameSeparators = new char[] { '+' } 235638"];
1200 [label="param NonMissingAssemblySymbol(this) 235639"];
1201 [label="param AssemblySymbol(this) 235640"];
1202 [label="param AssemblySymbol(this) 235641"];
1203 [label="param Symbol(this) 235642"];
1204 [label="_lazyISymbol 235643"];
1205 [label="_corLibrary 235644"];
1206 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 235645"];
1207 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 235646"];
1208 [label="_globalNamespace 235647"];
1209 [label="_lazySpecialTypes 235648"];
1210 [label="_cachedSpecialTypes 235649"];
1211 [label="_lazyNativeIntegerTypes 235650"];
1212 [label="_lazyTypeNames 235651"];
1213 [label="_lazyNamespaceNames 235652"];
1214 [label="_lazySpecialTypeMembers 235653"];
1215 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 235654"];
1216 [label="_assembly 235655"];
1217 [label="_documentationProvider 235656"];
1218 [label="_isLinked 235657"];
1219 [label="Debug.Assert(assembly != null); 235658"];
1220 [label="Debug.Assert(assembly != null); 235659"];
1221 [label="Debug.Assert(documentationProvider != null); 235660"];
1222 [label="Debug.Assert(documentationProvider != null); 235661"];
1223 [label="_assembly 235662"];
1224 [label="_documentationProvider 235663"];
1225 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 235664"];
1226 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 235665"];
1227 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 235666"];
1228 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 235667"];
1229 [label="31 235668"];
1230 [label="DefaultTypeMapCapacity = 31 235669"];
1231 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 235670"];
1232 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 235671"];
1233 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 235672"];
1234 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 235673"];
1235 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 235674"];
1236 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 235675"];
1237 [label="param PEModuleSymbol(PEModule module) 235676"];
1238 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 235677"];
1239 [label="param PEModuleSymbol(int ordinal) 235678"];
1240 [label="param PEModuleSymbol(this) 235679"];
1241 [label="assemblySymbol 235680"];
1242 [label="module 235681"];
1243 [label="importOptions 235682"];
1244 [label="ordinal 235683"];
1245 [label="param PEModuleSymbol(this) 235684"];
1246 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 235685"];
1247 [label="param PEModuleSymbol(PEModule module) 235686"];
1248 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 235687"];
1249 [label="param PEModuleSymbol(int ordinal) 235688"];
1250 [label="param PEModuleSymbol(this) 235689"];
1251 [label="param PEModuleSymbol(this) 235690"];
1252 [label="param NonMissingModuleSymbol(this) 235691"];
1253 [label="param NonMissingModuleSymbol(this) 235692"];
1254 [label="param ModuleSymbol(this) 235693"];
1255 [label="param ModuleSymbol(this) 235694"];
1256 [label="param Symbol(this) 235695"];
1257 [label="_lazyISymbol 235696"];
1258 [label="_moduleReferences 235697"];
1259 [label="_assemblySymbol 235698"];
1260 [label="_ordinal 235699"];
1261 [label="_module 235700"];
1262 [label="_globalNamespace 235701"];
1263 [label="_lazySystemTypeSymbol 235702"];
1264 [label="_lazyEventRegistrationTokenSymbol 235703"];
1265 [label="_lazyEventRegistrationTokenTableSymbol 235704"];
1266 [label="2 235705"];
1267 [label="concurrencyLevel: 2 235706"];
1268 [label="capacity: DefaultTypeMapCapacity 235707"];
1269 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 235708"];
1270 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 235709"];
1271 [label="2 235710"];
1272 [label="concurrencyLevel: 2 235711"];
1273 [label="capacity: DefaultTypeMapCapacity 235712"];
1274 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 235713"];
1275 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 235714"];
1276 [label="ImportOptions 235715"];
1277 [label="_lazyTypeNames 235716"];
1278 [label="_lazyNamespaceNames 235717"];
1279 [label="_lazyNullableMemberMetadata 235718"];
1280 [label="Debug.Assert((object)assemblySymbol != null); 235719"];
1281 [label="Debug.Assert((object)assemblySymbol != null); 235720"];
1282 [label="Debug.Assert(module != null); 235721"];
1283 [label="Debug.Assert(module != null); 235722"];
1284 [label="_assemblySymbol 235723"];
1285 [label="_ordinal 235724"];
1286 [label="_module 235725"];
1287 [label="this.ImportOptions 235726"];
1288 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 235727"];
1289 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 235728"];
1290 [label="new PEGlobalNamespaceSymbol(this) 235729"];
1291 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 235730"];
1292 [label="param PEGlobalNamespaceSymbol(this) 235731"];
1293 [label="param PEGlobalNamespaceSymbol(this) 235732"];
1294 [label="param PENamespaceSymbol(this) 235733"];
1295 [label="param PENamespaceSymbol(this) 235734"];
1296 [label="param NamespaceSymbol(this) 235735"];
1297 [label="param NamespaceSymbol(this) 235736"];
1298 [label="param NamespaceOrTypeSymbol(this) 235737"];
1299 [label="param NamespaceOrTypeSymbol(this) 235738"];
1300 [label="param Symbol(this) 235739"];
1301 [label="_lazyISymbol 235740"];
1302 [label="_lazyAdapter 235741"];
1303 [label="_lazyQualifiedName 235742"];
1304 [label="lazyNamespaces 235743"];
1305 [label="lazyTypes 235744"];
1306 [label="_lazyNoPiaLocalTypes 235745"];
1307 [label="_moduleSymbol 235746"];
1308 [label="Debug.Assert((object)moduleSymbol != null); 235747"];
1309 [label="Debug.Assert((object)moduleSymbol != null); 235748"];
1310 [label="_moduleSymbol 235749"];
1311 [label="_globalNamespace 235750"];
1312 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 235751"];
1313 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 235752"];
1314 [label="this.MetadataLocation 235753"];
1315 [label="Debug.Assert(ordinal >= 0); 235754"];
1316 [label="Debug.Assert(ordinal >= 0); 235755"];
1317 [label="modules[i] 235756"];
1318 [label="_modules = modules.AsImmutableOrNull(); 235757"];
1319 [label="_modules = modules.AsImmutableOrNull(); 235758"];
1320 [label="_modules 235759"];
1321 [label="_isLinked 235760"];
1322 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 235761"];
1323 [label="bound.AssemblySymbol 235762"];
1324 [label="newSymbols.Add(i); 235763"];
1325 [label="newSymbols.Add(i); 235764"];
1326 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 235765"];
1327 [label="allAssemblyData[i].IsLinked 235766"];
1328 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 235767"];
1329 [label="bound.AssemblySymbol.IsLinked 235768"];
1330 [label="get\n            {\n                return _isLinked;\n            } 235769"];
1331 [label="return _isLinked; 235770"];
1332 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 235771"];
1333 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 235772"];
1334 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 235773"];
1335 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 235774"];
1336 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 235775"];
1337 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 235776"];
1338 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 235777"];
1339 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 235778"];
1340 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 235779"];
1341 [label="param SourceAssemblySymbol(string assemblySimpleName) 235780"];
1342 [label="param SourceAssemblySymbol(string moduleName) 235781"];
1343 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 235782"];
1344 [label="param SourceAssemblySymbol(this) 235783"];
1345 [label="param SourceAssemblySymbol(this) 235784"];
1346 [label="param MetadataOrSourceAssemblySymbol(this) 235785"];
1347 [label="param MetadataOrSourceAssemblySymbol(this) 235786"];
1348 [label="param NonMissingAssemblySymbol(this) 235787"];
1349 [label="param NonMissingAssemblySymbol(this) 235788"];
1350 [label="param AssemblySymbol(this) 235789"];
1351 [label="param AssemblySymbol(this) 235790"];
1352 [label="param Symbol(this) 235791"];
1353 [label="_lazyISymbol 235792"];
1354 [label="_corLibrary 235793"];
1355 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 235794"];
1356 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 235795"];
1357 [label="_globalNamespace 235796"];
1358 [label="_lazySpecialTypes 235797"];
1359 [label="_cachedSpecialTypes 235798"];
1360 [label="_lazyNativeIntegerTypes 235799"];
1361 [label="_lazyTypeNames 235800"];
1362 [label="_lazyNamespaceNames 235801"];
1363 [label="_lazySpecialTypeMembers 235802"];
1364 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 235803"];
1365 [label="_compilation 235804"];
1366 [label="lazyAssemblyIdentity 235805"];
1367 [label="_assemblySimpleName 235806"];
1368 [label="_lazyStrongNameKeys 235807"];
1369 [label="_lazySourceAttributesBag 235808"];
1370 [label="_lazyNetModuleAttributesBag 235809"];
1371 [label="_lazyForwardedTypesFromSource 235810"];
1372 [label="_lazyOmittedAttributeIndices 235811"];
1373 [label="_lazyContainsExtensionMethods 235812"];
1374 [label="new ConcurrentDictionary<FieldSymbol, bool>() 235813"];
1375 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 235814"];
1376 [label="new ConcurrentSet<FieldSymbol>() 235815"];
1377 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 235816"];
1378 [label="new ConcurrentSet<TypeSymbol>() 235817"];
1379 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 235818"];
1380 [label="_optimisticallyGrantedInternalsAccess 235819"];
1381 [label="_lazyInternalsVisibleToMap 235820"];
1382 [label="Debug.Assert(compilation != null); 235821"];
1383 [label="Debug.Assert(compilation != null); 235822"];
1384 [label="Debug.Assert(assemblySimpleName != null); 235823"];
1385 [label="Debug.Assert(assemblySimpleName != null); 235824"];
1386 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 235825"];
1387 [label="Debug.Assert(!netModules.IsDefault); 235826"];
1388 [label="_compilation 235827"];
1389 [label="_assemblySimpleName 235828"];
1390 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 235829"];
1391 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 235830"];
1392 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 235831"];
1393 [label="compilation.Declarations 235832"];
1394 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 235833"];
1395 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 235834"];
1396 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 235835"];
1397 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 235836"];
1398 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 235837"];
1399 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 235838"];
1400 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 235839"];
1401 [label="param SourceModuleSymbol(DeclarationTable declarations) 235840"];
1402 [label="param SourceModuleSymbol(string moduleName) 235841"];
1403 [label="param SourceModuleSymbol(this) 235842"];
1404 [label="param SourceModuleSymbol(this) 235843"];
1405 [label="param NonMissingModuleSymbol(this) 235844"];
1406 [label="param NonMissingModuleSymbol(this) 235845"];
1407 [label="param ModuleSymbol(this) 235846"];
1408 [label="param ModuleSymbol(this) 235847"];
1409 [label="param Symbol(this) 235848"];
1410 [label="_lazyISymbol 235849"];
1411 [label="_moduleReferences 235850"];
1412 [label="_assemblySymbol 235851"];
1413 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 235852"];
1414 [label="_sources 235853"];
1415 [label="_lazyCustomAttributesBag 235854"];
1416 [label="_globalNamespace 235855"];
1417 [label="_hasBadAttributes 235856"];
1418 [label="_name 235857"];
1419 [label="Debug.Assert((object)assemblySymbol != null); 235858"];
1420 [label="Debug.Assert((object)assemblySymbol != null); 235859"];
1421 [label="_assemblySymbol 235860"];
1422 [label="_sources 235861"];
1423 [label="_name 235862"];
1424 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 235863"];
1425 [label="compilation.Options 235864"];
1426 [label="get\n            {\n                return _options;\n            } 235865"];
1427 [label="return _options; 235866"];
1428 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 235867"];
1429 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 235868"];
1430 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 235869"];
1431 [label="_modules = moduleBuilder.ToImmutableAndFree(); 235870"];
1432 [label="_modules 235871"];
1433 [label="compilation.Options 235872"];
1434 [label="get\n            {\n                return _options;\n            } 235873"];
1435 [label="return _options; 235874"];
1436 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 235875"];
1437 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 235876"];
1438 [label="AssemblySymbol? corLibrary; 235877"];
1439 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 235878"];
1440 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 235879"];
1441 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 235880"];
1442 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 235881"];
1443 [label="assemblySymbol.SetCorLibrary(corLibrary); 235882"];
1444 [label="assemblySymbol.SetCorLibrary(corLibrary) 235883"];
1445 [label="param SetCorLibrary(AssemblySymbol corLibrary) 235884"];
1446 [label="param SetCorLibrary(this) 235885"];
1447 [label="Debug.Assert((object)_corLibrary == null); 235886"];
1448 [label="Debug.Assert((object)_corLibrary == null); 235887"];
1449 [label="_corLibrary 235888"];
1450 [label="assemblySymbol.SetCorLibrary(corLibrary); 235889"];
1451 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 235890"];
1452 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 235891"];
1453 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 235892"];
1454 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 235893"];
1455 [label="moduleReferences 235894"];
1456 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235895"];
1457 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235896"];
1458 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235897"];
1459 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235898"];
1460 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235899"];
1461 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235900"];
1462 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 235901"];
1463 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 235902"];
1464 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 235903"];
1465 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 235904"];
1466 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 235905"];
1467 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 235906"];
1468 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 235907"];
1469 [label="sourceAssembly.Modules 235908"];
1470 [label="get\n            {\n                return _modules;\n            } 235909"];
1471 [label="return _modules; 235910"];
1472 [label="var moduleSymbols = sourceAssembly.Modules; 235911"];
1473 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 235912"];
1474 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 235913"];
1475 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 235914"];
1476 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 235915"];
1477 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 235916"];
1478 [label="(moduleSymbols.Length > 1) 235917"];
1479 [label="int refsUsed = 0; 235918"];
1480 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 235919"];
1481 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 235920"];
1482 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 235921"];
1483 [label="(moduleIndex == 0) 235922"];
1484 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 235923"];
1485 [label="var identities = new AssemblyIdentity[refsCount]; 235924"];
1486 [label="var symbols = new AssemblySymbol[refsCount]; 235925"];
1487 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 235926"];
1488 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 235927"];
1489 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 235928"];
1490 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 235929"];
1491 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 235930"];
1492 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 235931"];
1493 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 235932"];
1494 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 235933"];
1495 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 235934"];
1496 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 235935"];
1497 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 235936"];
1498 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 235937"];
1499 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 235938"];
1500 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 235939"];
1501 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 235940"];
1502 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 235941"];
1503 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 235942"];
1504 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 235943"];
1505 [label="Debug.Assert(referenceBinding.IsBound); 235944"];
1506 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 235945"];
1507 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 235946"];
1508 [label="Debug.Assert(assembly is object); 235947"];
1509 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 235948"];
1510 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 235949"];
1511 [label="return assembly; 235950"];
1512 [label="symbols[k] 235951"];
1513 [label="identities[k] 235952"];
1514 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235953"];
1515 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235954"];
1516 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235955"];
1517 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235956"];
1518 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235957"];
1519 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 235958"];
1520 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 235959"];
1521 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 235960"];
1522 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 235961"];
1523 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 235962"];
1524 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 235963"];
1525 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 235964"];
1526 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 235965"];
1527 [label="param SetReferences(this) 235966"];
1528 [label="Debug.Assert(moduleReferences != null); 235967"];
1529 [label="Debug.Assert(moduleReferences != null); 235968"];
1530 [label="AssertReferencesUninitialized() 235969"];
1531 [label="param AssertReferencesUninitialized(this) 235970"];
1532 [label="Debug.Assert(_moduleReferences == null); 235971"];
1533 [label="Debug.Assert(_moduleReferences == null); 235972"];
1534 [label="AssertReferencesUninitialized(); 235973"];
1535 [label="_moduleReferences 235974"];
1536 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 235975"];
1537 [label="refsUsed += refsCount; 235976"];
1538 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 235977"];
1539 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 235978"];
1540 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 235979"];
1541 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 235980"];
1542 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 235981"];
1543 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 235982"];
1544 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 235983"];
1545 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 235984"];
1546 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 235985"];
1547 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 235986"];
1548 [label="param InitializeNewSymbols(List<int> newSymbols) 235987"];
1549 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 235988"];
1550 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 235989"];
1551 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 235990"];
1552 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 235991"];
1553 [label="Debug.Assert(newSymbols.Count > 0); 235992"];
1554 [label="Debug.Assert(newSymbols.Count > 0); 235993"];
1555 [label="sourceAssembly.CorLibrary 235994"];
1556 [label="get\n            {\n                return _corLibrary;\n            } 235995"];
1557 [label="return _corLibrary; 235996"];
1558 [label="var corLibrary = sourceAssembly.CorLibrary; 235997"];
1559 [label="RoslynDebug.Assert((object)corLibrary != null); 235998"];
1560 [label="RoslynDebug.Assert((object)corLibrary != null); 235999"];
1561 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 236000"];
1562 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 236001"];
1563 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 236002"];
1564 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 236003"];
1565 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 236004"];
1566 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236005"];
1567 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236006"];
1568 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236007"];
1569 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236008"];
1570 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236009"];
1571 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 236010"];
1572 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 236011"];
1573 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 236012"];
1574 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 236013"];
1575 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 236014"];
1576 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 236015"];
1577 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 236016"];
1578 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 236017"];
1579 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 236018"];
1580 [label="portableExecutableAssemblySymbol.Modules 236019"];
1581 [label="get\n            {\n                return _modules;\n            } 236020"];
1582 [label="return _modules; 236021"];
1583 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 236022"];
1584 [label="int moduleCount = modules.Length; 236023"];
1585 [label="int refsUsed = 0; 236024"];
1586 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 236025"];
1587 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 236026"];
1588 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 236027"];
1589 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 236028"];
1590 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 236029"];
1591 [label="fileData.AssemblyReferences 236030"];
1592 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 236031"];
1593 [label="return _referencedAssemblies; 236032"];
1594 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236033"];
1595 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236034"];
1596 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236035"];
1597 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236036"];
1598 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236037"];
1599 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 236038"];
1600 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 236039"];
1601 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 236040"];
1602 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 236041"];
1603 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 236042"];
1604 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 236043"];
1605 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 236044"];
1606 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 236045"];
1607 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 236046"];
1608 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 236047"];
1609 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 236048"];
1610 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 236049"];
1611 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 236050"];
1612 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 236051"];
1613 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 236052"];
1614 [label="param SetReferences(this) 236053"];
1615 [label="Debug.Assert(moduleReferences != null); 236054"];
1616 [label="Debug.Assert(moduleReferences != null); 236055"];
1617 [label="AssertReferencesUninitialized() 236056"];
1618 [label="param AssertReferencesUninitialized(this) 236057"];
1619 [label="Debug.Assert(_moduleReferences == null); 236058"];
1620 [label="Debug.Assert(_moduleReferences == null); 236059"];
1621 [label="AssertReferencesUninitialized(); 236060"];
1622 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 236061"];
1623 [label="refsUsed += moduleReferenceCount; 236062"];
1624 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 236063"];
1625 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 236064"];
1626 [label="sourceAssembly.Modules 236065"];
1627 [label="get\n            {\n                return _modules;\n            } 236066"];
1628 [label="return _modules; 236067"];
1629 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 236068"];
1630 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 236069"];
1631 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 236070"];
1632 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 236071"];
1633 [label="param GetReferencedAssemblySymbols(this) 236072"];
1634 [label="AssertReferencesInitialized() 236073"];
1635 [label="param AssertReferencesInitialized(this) 236074"];
1636 [label="Debug.Assert(_moduleReferences != null); 236075"];
1637 [label="Debug.Assert(_moduleReferences != null); 236076"];
1638 [label="AssertReferencesInitialized(); 236077"];
1639 [label="return _moduleReferences.Symbols; 236078"];
1640 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 236079"];
1641 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 236080"];
1642 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 236081"];
1643 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 236082"];
1644 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 236083"];
1645 [label="assemblies[i].ContainsNoPiaLocalTypes 236084"];
1646 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 236085"];
1647 [label="linkedReferencedAssembliesBuilder.Clear(); 236086"];
1648 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 236087"];
1649 [label="assemblies[i].IsLinked 236088"];
1650 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 236089"];
1651 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 236090"];
1652 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 236091"];
1653 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 236092"];
1654 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 236093"];
1655 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 236094"];
1656 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 236095"];
1657 [label="param SetCorLibrary(AssemblySymbol corLibrary) 236096"];
1658 [label="param SetCorLibrary(this) 236097"];
1659 [label="Debug.Assert((object)_corLibrary == null); 236098"];
1660 [label="Debug.Assert((object)_corLibrary == null); 236099"];
1661 [label="_corLibrary 236100"];
1662 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 236101"];
1663 [label="linkedReferencedAssembliesBuilder.Free(); 236102"];
1664 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 236103"];
1665 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 236104"];
1666 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 236105"];
1667 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 236106"];
1668 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 236107"];
1669 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 236108"];
1670 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 236109"];
1671 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 236110"];
1672 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 236111"];
1673 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 236112"];
1674 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 236113"];
1675 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 236114"];
1676 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 236115"];
1677 [label="ref BoundInputAssembly current = ref bindingResult[i]; 236116"];
1678 [label="Debug.Assert(current.AssemblySymbol is object); 236117"];
1679 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 236118"];
1680 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 236119"];
1681 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 236120"];
1682 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 236121"];
1683 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 236122"];
1684 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 236123"];
1685 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 236124"];
1686 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236125"];
1687 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236126"];
1688 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236127"];
1689 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236128"];
1690 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236129"];
1691 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236130"];
1692 [label="ReferenceEquals(corLibrary, assemblySymbol) 236131"];
1693 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236132"];
1694 [label="assemblySymbol.SourceModule 236133"];
1695 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 236134"];
1696 [label="this.Modules 236135"];
1697 [label="get\n            {\n                return _modules;\n            } 236136"];
1698 [label="return _modules; 236137"];
1699 [label="return (SourceModuleSymbol)this.Modules[0]; 236138"];
1700 [label="return (SourceModuleSymbol)this.Modules[0]; 236139"];
1701 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 236140"];
1702 [label="param GetReferencedAssemblySymbols(this) 236141"];
1703 [label="AssertReferencesInitialized() 236142"];
1704 [label="param AssertReferencesInitialized(this) 236143"];
1705 [label="Debug.Assert(_moduleReferences != null); 236144"];
1706 [label="Debug.Assert(_moduleReferences != null); 236145"];
1707 [label="AssertReferencesInitialized(); 236146"];
1708 [label="return _moduleReferences.Symbols; 236147"];
1709 [label="assemblySymbol.SourceModule 236148"];
1710 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 236149"];
1711 [label="this.Modules 236150"];
1712 [label="get\n            {\n                return _modules;\n            } 236151"];
1713 [label="return _modules; 236152"];
1714 [label="return (SourceModuleSymbol)this.Modules[0]; 236153"];
1715 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 236154"];
1716 [label="param GetUnifiedAssemblies(this) 236155"];
1717 [label="AssertReferencesInitialized() 236156"];
1718 [label="param AssertReferencesInitialized(this) 236157"];
1719 [label="Debug.Assert(_moduleReferences != null); 236158"];
1720 [label="Debug.Assert(_moduleReferences != null); 236159"];
1721 [label="AssertReferencesInitialized(); 236160"];
1722 [label="return _moduleReferences.UnifiedAssemblies; 236161"];
1723 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 236162"];
1724 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 236163"];
1725 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 236164"];
1726 [label="compilation._referenceManager 236165"];
1727 [label="compilation._lazyAssemblySymbol 236166"];
1728 [label="return true; 236167"];
1729 [label="resolutionDiagnostics.Free(); 236168"];
1730 [label="assemblyReferencesBySimpleName.Free(); 236169"];
1731 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 236170"];
1732 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 236171"];
1733 [label="AssertBound(); 236172"];
1734 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 236173"];
1735 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 236174"];
1736 [label="Debug.Assert(_lazyAssemblySymbol is object); 236175"];
1737 [label="return _referenceManager; 236176"];
1738 [label="GetBoundReferenceManager(); 236177"];
1739 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 236178"];
1740 [label="return _lazyAssemblySymbol; 236179"];
1741 [label="return SourceAssembly; 236180"];
1742 [label="return Assembly.Modules[0]; 236181"];
1743 [label="Assembly.Modules 236182"];
1744 [label="get\n            {\n                return _modules;\n            } 236183"];
1745 [label="return Assembly.Modules[0]; 236184"];
1746 [label="var globalNS = compilation.SourceModule.GlobalNamespace; 236185"];
1747 [label="compilation.SourceModule.GlobalNamespace 236186"];
1748 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 236187"];
1749 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 236188"];
1750 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 236189"];
1751 [label="var diagnostics = DiagnosticBag.GetInstance(); 236190"];
1752 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 236191"];
1753 [label="DeclaringCompilation 236192"];
1754 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 236193"];
1755 [label="_assemblySymbol.DeclaringCompilation 236194"];
1756 [label="get\n            {\n                return _compilation;\n            } 236195"];
1757 [label="return _compilation; 236196"];
1758 [label="return _assemblySymbol.DeclaringCompilation; 236197"];
1759 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 236198"];
1760 [label="DeclaringCompilation.MergedRootDeclaration 236199"];
1761 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 236200"];
1762 [label="Declarations 236201"];
1763 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 236202"];
1764 [label="return Declarations.GetMergedRoot(this); 236203"];
1765 [label="return Declarations.GetMergedRoot(this); 236204"];
1766 [label="return Declarations.GetMergedRoot(this); 236205"];
1767 [label="0x1 236206"];
1768 [label="LazyAllMembersIsSorted = 0x1 236207"];
1769 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 236208"];
1770 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 236209"];
1771 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 236210"];
1772 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 236211"];
1773 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 236212"];
1774 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 236213"];
1775 [label="param SourceNamespaceSymbol(Symbol container) 236214"];
1776 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 236215"];
1777 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 236216"];
1778 [label="param SourceNamespaceSymbol(this) 236217"];
1779 [label="param SourceNamespaceSymbol(this) 236218"];
1780 [label="_module 236219"];
1781 [label="_container 236220"];
1782 [label="_mergedDeclaration 236221"];
1783 [label="_nameToMembersMap 236222"];
1784 [label="_nameToTypeMembersMap 236223"];
1785 [label="_flags 236224"];
1786 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 236225"];
1787 [label="1 236226"];
1788 [label="_treeOrdinal 236227"];
1789 [label="0 236228"];
1790 [label="_position 236229"];
1791 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 236230"];
1792 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 236231"];
1793 [label="1 236232"];
1794 [label="_treeOrdinal 236233"];
1795 [label="1 236234"];
1796 [label="_position 236235"];
1797 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 236236"];
1798 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 236237"];
1799 [label="_treeOrdinal 236238"];
1800 [label="1 236239"];
1801 [label="int.MaxValue - 1 236240"];
1802 [label="_position 236241"];
1803 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 236242"];
1804 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 236243"];
1805 [label="_treeOrdinal 236244"];
1806 [label="_position 236245"];
1807 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 236246"];
1808 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 236247"];
1809 [label="Debug.Assert(mergedDeclaration != null); 236248"];
1810 [label="Debug.Assert(mergedDeclaration != null); 236249"];
1811 [label="_module 236250"];
1812 [label="_container 236251"];
1813 [label="_mergedDeclaration 236252"];
1814 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 236253"];
1815 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 236254"];
1816 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 236255"];
1817 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 236256"];
1818 [label="diagnostics.Free(); 236257"];
1819 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 236258"];
1820 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 236259"];
1821 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 236260"];
1822 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 236261"];
1823 [label="return _globalNamespace; 236262"];
1824 [label="var classTest = globalNS.GetTypeMembers('A').Single() as NamedTypeSymbol; 236263"];
1825 [label="globalNS.GetTypeMembers('A') 236264"];
1826 [label="param GetTypeMembers(string name) 236265"];
1827 [label="param GetTypeMembers(this) 236266"];
1828 [label="ImmutableArray<NamedTypeSymbol> members; 236267"];
1829 [label="members 236268"];
1830 [label="this.GetNameToTypeMembersMap() 236269"];
1831 [label="param GetNameToTypeMembersMap(this) 236270"];
1832 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 236271"];
1833 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 236272"];
1834 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 236273"];
1835 [label="GetNameToMembersMap() 236274"];
1836 [label="param GetNameToMembersMap(this) 236275"];
1837 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 236276"];
1838 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 236277"];
1839 [label="var diagnostics = DiagnosticBag.GetInstance(); 236278"];
1840 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 236279"];
1841 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 236280"];
1842 [label="MakeNameToMembersMap(diagnostics) 236281"];
1843 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 236282"];
1844 [label="param MakeNameToMembersMap(this) 236283"];
1845 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 236284"];
1846 [label="_mergedDeclaration.Children 236285"];
1847 [label="param NameToSymbolMapBuilder(int capacity) 236286"];
1848 [label="param NameToSymbolMapBuilder(this) 236287"];
1849 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 236288"];
1850 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 236289"];
1851 [label="_dictionary 236290"];
1852 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 236291"];
1853 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 236292"];
1854 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 236293"];
1855 [label="BuildSymbol(declaration, diagnostics) 236294"];
1856 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 236295"];
1857 [label="param BuildSymbol(DiagnosticBag diagnostics) 236296"];
1858 [label="param BuildSymbol(this) 236297"];
1859 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 236298"];
1860 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 236299"];
1861 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 236300"];
1862 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 236301"];
1863 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 236302"];
1864 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 236303"];
1865 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 236304"];
1866 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 236305"];
1867 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 236306"];
1868 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 236307"];
1869 [label="param SourceNamedTypeSymbol(this) 236308"];
1870 [label="false 236309"];
1871 [label="considerName: false 236310"];
1872 [label="false 236311"];
1873 [label="considerExplicitlyImplementedInterfaces: false 236312"];
1874 [label="true 236313"];
1875 [label="considerReturnType: true 236314"];
1876 [label="false 236315"];
1877 [label="considerTypeConstraints: false 236316"];
1878 [label="true 236317"];
1879 [label="considerRefKindDifferences: true 236318"];
1880 [label="true 236319"];
1881 [label="considerCallingConvention: true 236320"];
1882 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236321"];
1883 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236322"];
1884 [label="param MemberSignatureComparer(bool considerName) 236323"];
1885 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236324"];
1886 [label="param MemberSignatureComparer(bool considerReturnType) 236325"];
1887 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236326"];
1888 [label="param MemberSignatureComparer(bool considerCallingConvention) 236327"];
1889 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236328"];
1890 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236329"];
1891 [label="param MemberSignatureComparer(this) 236330"];
1892 [label="_considerName 236331"];
1893 [label="_considerExplicitlyImplementedInterfaces 236332"];
1894 [label="_considerReturnType 236333"];
1895 [label="_considerTypeConstraints 236334"];
1896 [label="_considerCallingConvention 236335"];
1897 [label="_considerRefKindDifferences 236336"];
1898 [label="_typeComparison 236337"];
1899 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236338"];
1900 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236339"];
1901 [label="_considerName 236340"];
1902 [label="_considerExplicitlyImplementedInterfaces 236341"];
1903 [label="_considerReturnType 236342"];
1904 [label="_considerTypeConstraints 236343"];
1905 [label="_considerCallingConvention 236344"];
1906 [label="_considerRefKindDifferences 236345"];
1907 [label="_typeComparison 236346"];
1908 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236347"];
1909 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236348"];
1910 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236349"];
1911 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236350"];
1912 [label="true 236351"];
1913 [label="considerName: true 236352"];
1914 [label="true 236353"];
1915 [label="considerExplicitlyImplementedInterfaces: true 236354"];
1916 [label="true 236355"];
1917 [label="considerReturnType: true 236356"];
1918 [label="false 236357"];
1919 [label="considerTypeConstraints: false 236358"];
1920 [label="true 236359"];
1921 [label="considerCallingConvention: true 236360"];
1922 [label="true 236361"];
1923 [label="considerRefKindDifferences: true 236362"];
1924 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236363"];
1925 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236364"];
1926 [label="param MemberSignatureComparer(bool considerName) 236365"];
1927 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236366"];
1928 [label="param MemberSignatureComparer(bool considerReturnType) 236367"];
1929 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236368"];
1930 [label="param MemberSignatureComparer(bool considerCallingConvention) 236369"];
1931 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236370"];
1932 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236371"];
1933 [label="param MemberSignatureComparer(this) 236372"];
1934 [label="_considerName 236373"];
1935 [label="_considerExplicitlyImplementedInterfaces 236374"];
1936 [label="_considerReturnType 236375"];
1937 [label="_considerTypeConstraints 236376"];
1938 [label="_considerCallingConvention 236377"];
1939 [label="_considerRefKindDifferences 236378"];
1940 [label="_typeComparison 236379"];
1941 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236380"];
1942 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236381"];
1943 [label="_considerName 236382"];
1944 [label="_considerExplicitlyImplementedInterfaces 236383"];
1945 [label="_considerReturnType 236384"];
1946 [label="_considerTypeConstraints 236385"];
1947 [label="_considerCallingConvention 236386"];
1948 [label="_considerRefKindDifferences 236387"];
1949 [label="_typeComparison 236388"];
1950 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236389"];
1951 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236390"];
1952 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236391"];
1953 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236392"];
1954 [label="true 236393"];
1955 [label="considerName: true 236394"];
1956 [label="true 236395"];
1957 [label="considerExplicitlyImplementedInterfaces: true 236396"];
1958 [label="false 236397"];
1959 [label="considerReturnType: false 236398"];
1960 [label="false 236399"];
1961 [label="considerTypeConstraints: false 236400"];
1962 [label="false 236401"];
1963 [label="considerCallingConvention: false 236402"];
1964 [label="true 236403"];
1965 [label="considerRefKindDifferences: true 236404"];
1966 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236405"];
1967 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236406"];
1968 [label="param MemberSignatureComparer(bool considerName) 236407"];
1969 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236408"];
1970 [label="param MemberSignatureComparer(bool considerReturnType) 236409"];
1971 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236410"];
1972 [label="param MemberSignatureComparer(bool considerCallingConvention) 236411"];
1973 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236412"];
1974 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236413"];
1975 [label="param MemberSignatureComparer(this) 236414"];
1976 [label="_considerName 236415"];
1977 [label="_considerExplicitlyImplementedInterfaces 236416"];
1978 [label="_considerReturnType 236417"];
1979 [label="_considerTypeConstraints 236418"];
1980 [label="_considerCallingConvention 236419"];
1981 [label="_considerRefKindDifferences 236420"];
1982 [label="_typeComparison 236421"];
1983 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236422"];
1984 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236423"];
1985 [label="_considerName 236424"];
1986 [label="_considerExplicitlyImplementedInterfaces 236425"];
1987 [label="_considerReturnType 236426"];
1988 [label="_considerTypeConstraints 236427"];
1989 [label="_considerCallingConvention 236428"];
1990 [label="_considerRefKindDifferences 236429"];
1991 [label="_typeComparison 236430"];
1992 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236431"];
1993 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236432"];
1994 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236433"];
1995 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236434"];
1996 [label="true 236435"];
1997 [label="considerName: true 236436"];
1998 [label="true 236437"];
1999 [label="considerExplicitlyImplementedInterfaces: true 236438"];
2000 [label="false 236439"];
2001 [label="considerReturnType: false 236440"];
2002 [label="false 236441"];
2003 [label="considerTypeConstraints: false 236442"];
2004 [label="false 236443"];
2005 [label="considerCallingConvention: false 236444"];
2006 [label="false 236445"];
2007 [label="considerRefKindDifferences: false 236446"];
2008 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236447"];
2009 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236448"];
2010 [label="param MemberSignatureComparer(bool considerName) 236449"];
2011 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236450"];
2012 [label="param MemberSignatureComparer(bool considerReturnType) 236451"];
2013 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236452"];
2014 [label="param MemberSignatureComparer(bool considerCallingConvention) 236453"];
2015 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236454"];
2016 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236455"];
2017 [label="param MemberSignatureComparer(this) 236456"];
2018 [label="_considerName 236457"];
2019 [label="_considerExplicitlyImplementedInterfaces 236458"];
2020 [label="_considerReturnType 236459"];
2021 [label="_considerTypeConstraints 236460"];
2022 [label="_considerCallingConvention 236461"];
2023 [label="_considerRefKindDifferences 236462"];
2024 [label="_typeComparison 236463"];
2025 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236464"];
2026 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236465"];
2027 [label="_considerName 236466"];
2028 [label="_considerExplicitlyImplementedInterfaces 236467"];
2029 [label="_considerReturnType 236468"];
2030 [label="_considerTypeConstraints 236469"];
2031 [label="_considerCallingConvention 236470"];
2032 [label="_considerRefKindDifferences 236471"];
2033 [label="_typeComparison 236472"];
2034 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236473"];
2035 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236474"];
2036 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236475"];
2037 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236476"];
2038 [label="_typeComparison 236477"];
2039 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236478"];
2040 [label="true 236479"];
2041 [label="considerName: true 236480"];
2042 [label="true 236481"];
2043 [label="considerExplicitlyImplementedInterfaces: true 236482"];
2044 [label="false 236483"];
2045 [label="considerReturnType: false 236484"];
2046 [label="false 236485"];
2047 [label="considerTypeConstraints: false 236486"];
2048 [label="false 236487"];
2049 [label="considerCallingConvention: false 236488"];
2050 [label="true 236489"];
2051 [label="considerRefKindDifferences: true 236490"];
2052 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236491"];
2053 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236492"];
2054 [label="param MemberSignatureComparer(bool considerName) 236493"];
2055 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236494"];
2056 [label="param MemberSignatureComparer(bool considerReturnType) 236495"];
2057 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236496"];
2058 [label="param MemberSignatureComparer(bool considerCallingConvention) 236497"];
2059 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236498"];
2060 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236499"];
2061 [label="param MemberSignatureComparer(this) 236500"];
2062 [label="_considerName 236501"];
2063 [label="_considerExplicitlyImplementedInterfaces 236502"];
2064 [label="_considerReturnType 236503"];
2065 [label="_considerTypeConstraints 236504"];
2066 [label="_considerCallingConvention 236505"];
2067 [label="_considerRefKindDifferences 236506"];
2068 [label="_typeComparison 236507"];
2069 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236508"];
2070 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236509"];
2071 [label="_considerName 236510"];
2072 [label="_considerExplicitlyImplementedInterfaces 236511"];
2073 [label="_considerReturnType 236512"];
2074 [label="_considerTypeConstraints 236513"];
2075 [label="_considerCallingConvention 236514"];
2076 [label="_considerRefKindDifferences 236515"];
2077 [label="_typeComparison 236516"];
2078 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236517"];
2079 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236518"];
2080 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236519"];
2081 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236520"];
2082 [label="true 236521"];
2083 [label="considerName: true 236522"];
2084 [label="true 236523"];
2085 [label="considerExplicitlyImplementedInterfaces: true 236524"];
2086 [label="false 236525"];
2087 [label="considerReturnType: false 236526"];
2088 [label="false 236527"];
2089 [label="considerTypeConstraints: false 236528"];
2090 [label="false 236529"];
2091 [label="considerCallingConvention: false 236530"];
2092 [label="true 236531"];
2093 [label="considerRefKindDifferences: true 236532"];
2094 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236533"];
2095 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236534"];
2096 [label="param MemberSignatureComparer(bool considerName) 236535"];
2097 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236536"];
2098 [label="param MemberSignatureComparer(bool considerReturnType) 236537"];
2099 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236538"];
2100 [label="param MemberSignatureComparer(bool considerCallingConvention) 236539"];
2101 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236540"];
2102 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236541"];
2103 [label="param MemberSignatureComparer(this) 236542"];
2104 [label="_considerName 236543"];
2105 [label="_considerExplicitlyImplementedInterfaces 236544"];
2106 [label="_considerReturnType 236545"];
2107 [label="_considerTypeConstraints 236546"];
2108 [label="_considerCallingConvention 236547"];
2109 [label="_considerRefKindDifferences 236548"];
2110 [label="_typeComparison 236549"];
2111 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236550"];
2112 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236551"];
2113 [label="_considerName 236552"];
2114 [label="_considerExplicitlyImplementedInterfaces 236553"];
2115 [label="_considerReturnType 236554"];
2116 [label="_considerTypeConstraints 236555"];
2117 [label="_considerCallingConvention 236556"];
2118 [label="_considerRefKindDifferences 236557"];
2119 [label="_typeComparison 236558"];
2120 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236559"];
2121 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236560"];
2122 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236561"];
2123 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236562"];
2124 [label="true 236563"];
2125 [label="considerName: true 236564"];
2126 [label="false 236565"];
2127 [label="considerExplicitlyImplementedInterfaces: false 236566"];
2128 [label="false 236567"];
2129 [label="considerReturnType: false 236568"];
2130 [label="false 236569"];
2131 [label="considerTypeConstraints: false 236570"];
2132 [label="false 236571"];
2133 [label="considerCallingConvention: false 236572"];
2134 [label="true 236573"];
2135 [label="considerRefKindDifferences: true 236574"];
2136 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236575"];
2137 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236576"];
2138 [label="param MemberSignatureComparer(bool considerName) 236577"];
2139 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236578"];
2140 [label="param MemberSignatureComparer(bool considerReturnType) 236579"];
2141 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236580"];
2142 [label="param MemberSignatureComparer(bool considerCallingConvention) 236581"];
2143 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236582"];
2144 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236583"];
2145 [label="param MemberSignatureComparer(this) 236584"];
2146 [label="_considerName 236585"];
2147 [label="_considerExplicitlyImplementedInterfaces 236586"];
2148 [label="_considerReturnType 236587"];
2149 [label="_considerTypeConstraints 236588"];
2150 [label="_considerCallingConvention 236589"];
2151 [label="_considerRefKindDifferences 236590"];
2152 [label="_typeComparison 236591"];
2153 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236592"];
2154 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236593"];
2155 [label="_considerName 236594"];
2156 [label="_considerExplicitlyImplementedInterfaces 236595"];
2157 [label="_considerReturnType 236596"];
2158 [label="_considerTypeConstraints 236597"];
2159 [label="_considerCallingConvention 236598"];
2160 [label="_considerRefKindDifferences 236599"];
2161 [label="_typeComparison 236600"];
2162 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236601"];
2163 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236602"];
2164 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236603"];
2165 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236604"];
2166 [label="true 236605"];
2167 [label="considerName: true 236606"];
2168 [label="false 236607"];
2169 [label="considerExplicitlyImplementedInterfaces: false 236608"];
2170 [label="true 236609"];
2171 [label="considerReturnType: true 236610"];
2172 [label="false 236611"];
2173 [label="considerTypeConstraints: false 236612"];
2174 [label="false 236613"];
2175 [label="considerCallingConvention: false 236614"];
2176 [label="false 236615"];
2177 [label="considerRefKindDifferences: false 236616"];
2178 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 236617"];
2179 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 236618"];
2180 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 236619"];
2181 [label="param MemberSignatureComparer(bool considerName) 236620"];
2182 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236621"];
2183 [label="param MemberSignatureComparer(bool considerReturnType) 236622"];
2184 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236623"];
2185 [label="param MemberSignatureComparer(bool considerCallingConvention) 236624"];
2186 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236625"];
2187 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236626"];
2188 [label="param MemberSignatureComparer(this) 236627"];
2189 [label="_considerName 236628"];
2190 [label="_considerExplicitlyImplementedInterfaces 236629"];
2191 [label="_considerReturnType 236630"];
2192 [label="_considerTypeConstraints 236631"];
2193 [label="_considerCallingConvention 236632"];
2194 [label="_considerRefKindDifferences 236633"];
2195 [label="_typeComparison 236634"];
2196 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236635"];
2197 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236636"];
2198 [label="_considerName 236637"];
2199 [label="_considerExplicitlyImplementedInterfaces 236638"];
2200 [label="_considerReturnType 236639"];
2201 [label="_considerTypeConstraints 236640"];
2202 [label="_considerCallingConvention 236641"];
2203 [label="_considerRefKindDifferences 236642"];
2204 [label="_typeComparison 236643"];
2205 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236644"];
2206 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236645"];
2207 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236646"];
2208 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236647"];
2209 [label="_typeComparison 236648"];
2210 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 236649"];
2211 [label="true 236650"];
2212 [label="considerName: true 236651"];
2213 [label="false 236652"];
2214 [label="considerExplicitlyImplementedInterfaces: false 236653"];
2215 [label="true 236654"];
2216 [label="considerReturnType: true 236655"];
2217 [label="false 236656"];
2218 [label="considerTypeConstraints: false 236657"];
2219 [label="false 236658"];
2220 [label="considerCallingConvention: false 236659"];
2221 [label="false 236660"];
2222 [label="considerRefKindDifferences: false 236661"];
2223 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236662"];
2224 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236663"];
2225 [label="param MemberSignatureComparer(bool considerName) 236664"];
2226 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236665"];
2227 [label="param MemberSignatureComparer(bool considerReturnType) 236666"];
2228 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236667"];
2229 [label="param MemberSignatureComparer(bool considerCallingConvention) 236668"];
2230 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236669"];
2231 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236670"];
2232 [label="param MemberSignatureComparer(this) 236671"];
2233 [label="_considerName 236672"];
2234 [label="_considerExplicitlyImplementedInterfaces 236673"];
2235 [label="_considerReturnType 236674"];
2236 [label="_considerTypeConstraints 236675"];
2237 [label="_considerCallingConvention 236676"];
2238 [label="_considerRefKindDifferences 236677"];
2239 [label="_typeComparison 236678"];
2240 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236679"];
2241 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236680"];
2242 [label="_considerName 236681"];
2243 [label="_considerExplicitlyImplementedInterfaces 236682"];
2244 [label="_considerReturnType 236683"];
2245 [label="_considerTypeConstraints 236684"];
2246 [label="_considerCallingConvention 236685"];
2247 [label="_considerRefKindDifferences 236686"];
2248 [label="_typeComparison 236687"];
2249 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236688"];
2250 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236689"];
2251 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236690"];
2252 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236691"];
2253 [label="_typeComparison 236692"];
2254 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236693"];
2255 [label="false 236694"];
2256 [label="considerName: false 236695"];
2257 [label="false 236696"];
2258 [label="considerExplicitlyImplementedInterfaces: false 236697"];
2259 [label="false 236698"];
2260 [label="considerReturnType: false 236699"];
2261 [label="false 236700"];
2262 [label="considerTypeConstraints: false 236701"];
2263 [label="false 236702"];
2264 [label="considerCallingConvention: false 236703"];
2265 [label="true 236704"];
2266 [label="considerRefKindDifferences: true 236705"];
2267 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 236706"];
2268 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236707"];
2269 [label="param MemberSignatureComparer(bool considerName) 236708"];
2270 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236709"];
2271 [label="param MemberSignatureComparer(bool considerReturnType) 236710"];
2272 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236711"];
2273 [label="param MemberSignatureComparer(bool considerCallingConvention) 236712"];
2274 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236713"];
2275 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236714"];
2276 [label="param MemberSignatureComparer(this) 236715"];
2277 [label="_considerName 236716"];
2278 [label="_considerExplicitlyImplementedInterfaces 236717"];
2279 [label="_considerReturnType 236718"];
2280 [label="_considerTypeConstraints 236719"];
2281 [label="_considerCallingConvention 236720"];
2282 [label="_considerRefKindDifferences 236721"];
2283 [label="_typeComparison 236722"];
2284 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236723"];
2285 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236724"];
2286 [label="_considerName 236725"];
2287 [label="_considerExplicitlyImplementedInterfaces 236726"];
2288 [label="_considerReturnType 236727"];
2289 [label="_considerTypeConstraints 236728"];
2290 [label="_considerCallingConvention 236729"];
2291 [label="_considerRefKindDifferences 236730"];
2292 [label="_typeComparison 236731"];
2293 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236732"];
2294 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236733"];
2295 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236734"];
2296 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 236735"];
2297 [label="true 236736"];
2298 [label="considerName: true 236737"];
2299 [label="false 236738"];
2300 [label="considerExplicitlyImplementedInterfaces: false 236739"];
2301 [label="true 236740"];
2302 [label="considerReturnType: true 236741"];
2303 [label="false 236742"];
2304 [label="considerTypeConstraints: false 236743"];
2305 [label="false 236744"];
2306 [label="considerCallingConvention: false 236745"];
2307 [label="true 236746"];
2308 [label="considerRefKindDifferences: true 236747"];
2309 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236748"];
2310 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236749"];
2311 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236750"];
2312 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236751"];
2313 [label="param MemberSignatureComparer(bool considerName) 236752"];
2314 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236753"];
2315 [label="param MemberSignatureComparer(bool considerReturnType) 236754"];
2316 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236755"];
2317 [label="param MemberSignatureComparer(bool considerCallingConvention) 236756"];
2318 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236757"];
2319 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236758"];
2320 [label="param MemberSignatureComparer(this) 236759"];
2321 [label="_considerName 236760"];
2322 [label="_considerExplicitlyImplementedInterfaces 236761"];
2323 [label="_considerReturnType 236762"];
2324 [label="_considerTypeConstraints 236763"];
2325 [label="_considerCallingConvention 236764"];
2326 [label="_considerRefKindDifferences 236765"];
2327 [label="_typeComparison 236766"];
2328 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236767"];
2329 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236768"];
2330 [label="_considerName 236769"];
2331 [label="_considerExplicitlyImplementedInterfaces 236770"];
2332 [label="_considerReturnType 236771"];
2333 [label="_considerTypeConstraints 236772"];
2334 [label="_considerCallingConvention 236773"];
2335 [label="_considerRefKindDifferences 236774"];
2336 [label="_typeComparison 236775"];
2337 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236776"];
2338 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236777"];
2339 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236778"];
2340 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236779"];
2341 [label="false 236780"];
2342 [label="considerName: false 236781"];
2343 [label="false 236782"];
2344 [label="considerExplicitlyImplementedInterfaces: false 236783"];
2345 [label="false 236784"];
2346 [label="considerReturnType: false 236785"];
2347 [label="false 236786"];
2348 [label="considerTypeConstraints: false 236787"];
2349 [label="false 236788"];
2350 [label="considerCallingConvention: false 236789"];
2351 [label="false 236790"];
2352 [label="considerRefKindDifferences: false 236791"];
2353 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236792"];
2354 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 236793"];
2355 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 236794"];
2356 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 236795"];
2357 [label="param MemberSignatureComparer(bool considerName) 236796"];
2358 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236797"];
2359 [label="param MemberSignatureComparer(bool considerReturnType) 236798"];
2360 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236799"];
2361 [label="param MemberSignatureComparer(bool considerCallingConvention) 236800"];
2362 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236801"];
2363 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236802"];
2364 [label="param MemberSignatureComparer(this) 236803"];
2365 [label="_considerName 236804"];
2366 [label="_considerExplicitlyImplementedInterfaces 236805"];
2367 [label="_considerReturnType 236806"];
2368 [label="_considerTypeConstraints 236807"];
2369 [label="_considerCallingConvention 236808"];
2370 [label="_considerRefKindDifferences 236809"];
2371 [label="_typeComparison 236810"];
2372 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236811"];
2373 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236812"];
2374 [label="_considerName 236813"];
2375 [label="_considerExplicitlyImplementedInterfaces 236814"];
2376 [label="_considerReturnType 236815"];
2377 [label="_considerTypeConstraints 236816"];
2378 [label="_considerCallingConvention 236817"];
2379 [label="_considerRefKindDifferences 236818"];
2380 [label="_typeComparison 236819"];
2381 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236820"];
2382 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236821"];
2383 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236822"];
2384 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236823"];
2385 [label="_typeComparison 236824"];
2386 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 236825"];
2387 [label="true 236826"];
2388 [label="considerName: true 236827"];
2389 [label="false 236828"];
2390 [label="considerExplicitlyImplementedInterfaces: false 236829"];
2391 [label="true 236830"];
2392 [label="considerReturnType: true 236831"];
2393 [label="false 236832"];
2394 [label="considerTypeConstraints: false 236833"];
2395 [label="true 236834"];
2396 [label="considerCallingConvention: true 236835"];
2397 [label="false 236836"];
2398 [label="considerRefKindDifferences: false 236837"];
2399 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236838"];
2400 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236839"];
2401 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236840"];
2402 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236841"];
2403 [label="param MemberSignatureComparer(bool considerName) 236842"];
2404 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236843"];
2405 [label="param MemberSignatureComparer(bool considerReturnType) 236844"];
2406 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236845"];
2407 [label="param MemberSignatureComparer(bool considerCallingConvention) 236846"];
2408 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236847"];
2409 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236848"];
2410 [label="param MemberSignatureComparer(this) 236849"];
2411 [label="_considerName 236850"];
2412 [label="_considerExplicitlyImplementedInterfaces 236851"];
2413 [label="_considerReturnType 236852"];
2414 [label="_considerTypeConstraints 236853"];
2415 [label="_considerCallingConvention 236854"];
2416 [label="_considerRefKindDifferences 236855"];
2417 [label="_typeComparison 236856"];
2418 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236857"];
2419 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236858"];
2420 [label="_considerName 236859"];
2421 [label="_considerExplicitlyImplementedInterfaces 236860"];
2422 [label="_considerReturnType 236861"];
2423 [label="_considerTypeConstraints 236862"];
2424 [label="_considerCallingConvention 236863"];
2425 [label="_considerRefKindDifferences 236864"];
2426 [label="_typeComparison 236865"];
2427 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236866"];
2428 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236867"];
2429 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236868"];
2430 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236869"];
2431 [label="_typeComparison 236870"];
2432 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236871"];
2433 [label="true 236872"];
2434 [label="considerName: true 236873"];
2435 [label="false 236874"];
2436 [label="considerExplicitlyImplementedInterfaces: false 236875"];
2437 [label="true 236876"];
2438 [label="considerReturnType: true 236877"];
2439 [label="false 236878"];
2440 [label="considerTypeConstraints: false 236879"];
2441 [label="true 236880"];
2442 [label="considerCallingConvention: true 236881"];
2443 [label="true 236882"];
2444 [label="considerRefKindDifferences: true 236883"];
2445 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236884"];
2446 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236885"];
2447 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236886"];
2448 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236887"];
2449 [label="param MemberSignatureComparer(bool considerName) 236888"];
2450 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236889"];
2451 [label="param MemberSignatureComparer(bool considerReturnType) 236890"];
2452 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236891"];
2453 [label="param MemberSignatureComparer(bool considerCallingConvention) 236892"];
2454 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236893"];
2455 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236894"];
2456 [label="param MemberSignatureComparer(this) 236895"];
2457 [label="_considerName 236896"];
2458 [label="_considerExplicitlyImplementedInterfaces 236897"];
2459 [label="_considerReturnType 236898"];
2460 [label="_considerTypeConstraints 236899"];
2461 [label="_considerCallingConvention 236900"];
2462 [label="_considerRefKindDifferences 236901"];
2463 [label="_typeComparison 236902"];
2464 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236903"];
2465 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236904"];
2466 [label="_considerName 236905"];
2467 [label="_considerExplicitlyImplementedInterfaces 236906"];
2468 [label="_considerReturnType 236907"];
2469 [label="_considerTypeConstraints 236908"];
2470 [label="_considerCallingConvention 236909"];
2471 [label="_considerRefKindDifferences 236910"];
2472 [label="_typeComparison 236911"];
2473 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236912"];
2474 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236913"];
2475 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236914"];
2476 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236915"];
2477 [label="true 236916"];
2478 [label="considerName: true 236917"];
2479 [label="true 236918"];
2480 [label="considerExplicitlyImplementedInterfaces: true 236919"];
2481 [label="true 236920"];
2482 [label="considerReturnType: true 236921"];
2483 [label="false 236922"];
2484 [label="considerTypeConstraints: false 236923"];
2485 [label="true 236924"];
2486 [label="considerCallingConvention: true 236925"];
2487 [label="false 236926"];
2488 [label="considerRefKindDifferences: false 236927"];
2489 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236928"];
2490 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236929"];
2491 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236930"];
2492 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236931"];
2493 [label="param MemberSignatureComparer(bool considerName) 236932"];
2494 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236933"];
2495 [label="param MemberSignatureComparer(bool considerReturnType) 236934"];
2496 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236935"];
2497 [label="param MemberSignatureComparer(bool considerCallingConvention) 236936"];
2498 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236937"];
2499 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236938"];
2500 [label="param MemberSignatureComparer(this) 236939"];
2501 [label="_considerName 236940"];
2502 [label="_considerExplicitlyImplementedInterfaces 236941"];
2503 [label="_considerReturnType 236942"];
2504 [label="_considerTypeConstraints 236943"];
2505 [label="_considerCallingConvention 236944"];
2506 [label="_considerRefKindDifferences 236945"];
2507 [label="_typeComparison 236946"];
2508 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236947"];
2509 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236948"];
2510 [label="_considerName 236949"];
2511 [label="_considerExplicitlyImplementedInterfaces 236950"];
2512 [label="_considerReturnType 236951"];
2513 [label="_considerTypeConstraints 236952"];
2514 [label="_considerCallingConvention 236953"];
2515 [label="_considerRefKindDifferences 236954"];
2516 [label="_typeComparison 236955"];
2517 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236956"];
2518 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 236957"];
2519 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 236958"];
2520 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 236959"];
2521 [label="_typeComparison 236960"];
2522 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236961"];
2523 [label="true 236962"];
2524 [label="considerName: true 236963"];
2525 [label="true 236964"];
2526 [label="considerExplicitlyImplementedInterfaces: true 236965"];
2527 [label="true 236966"];
2528 [label="considerReturnType: true 236967"];
2529 [label="true 236968"];
2530 [label="considerTypeConstraints: true 236969"];
2531 [label="true 236970"];
2532 [label="considerCallingConvention: true 236971"];
2533 [label="true 236972"];
2534 [label="considerRefKindDifferences: true 236973"];
2535 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 236974"];
2536 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236975"];
2537 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 236976"];
2538 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 236977"];
2539 [label="param MemberSignatureComparer(bool considerName) 236978"];
2540 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 236979"];
2541 [label="param MemberSignatureComparer(bool considerReturnType) 236980"];
2542 [label="param MemberSignatureComparer(bool considerTypeConstraints) 236981"];
2543 [label="param MemberSignatureComparer(bool considerCallingConvention) 236982"];
2544 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 236983"];
2545 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 236984"];
2546 [label="param MemberSignatureComparer(this) 236985"];
2547 [label="_considerName 236986"];
2548 [label="_considerExplicitlyImplementedInterfaces 236987"];
2549 [label="_considerReturnType 236988"];
2550 [label="_considerTypeConstraints 236989"];
2551 [label="_considerCallingConvention 236990"];
2552 [label="_considerRefKindDifferences 236991"];
2553 [label="_typeComparison 236992"];
2554 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236993"];
2555 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 236994"];
2556 [label="_considerName 236995"];
2557 [label="_considerExplicitlyImplementedInterfaces 236996"];
2558 [label="_considerReturnType 236997"];
2559 [label="_considerTypeConstraints 236998"];
2560 [label="_considerCallingConvention 236999"];
2561 [label="_considerRefKindDifferences 237000"];
2562 [label="_typeComparison 237001"];
2563 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237002"];
2564 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237003"];
2565 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 237004"];
2566 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 237005"];
2567 [label="true 237006"];
2568 [label="considerName: true 237007"];
2569 [label="false 237008"];
2570 [label="considerExplicitlyImplementedInterfaces: false 237009"];
2571 [label="true 237010"];
2572 [label="considerReturnType: true 237011"];
2573 [label="false 237012"];
2574 [label="considerTypeConstraints: false 237013"];
2575 [label="true 237014"];
2576 [label="considerCallingConvention: true 237015"];
2577 [label="true 237016"];
2578 [label="considerRefKindDifferences: true 237017"];
2579 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 237018"];
2580 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 237019"];
2581 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 237020"];
2582 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 237021"];
2583 [label="param MemberSignatureComparer(bool considerName) 237022"];
2584 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 237023"];
2585 [label="param MemberSignatureComparer(bool considerReturnType) 237024"];
2586 [label="param MemberSignatureComparer(bool considerTypeConstraints) 237025"];
2587 [label="param MemberSignatureComparer(bool considerCallingConvention) 237026"];
2588 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 237027"];
2589 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 237028"];
2590 [label="param MemberSignatureComparer(this) 237029"];
2591 [label="_considerName 237030"];
2592 [label="_considerExplicitlyImplementedInterfaces 237031"];
2593 [label="_considerReturnType 237032"];
2594 [label="_considerTypeConstraints 237033"];
2595 [label="_considerCallingConvention 237034"];
2596 [label="_considerRefKindDifferences 237035"];
2597 [label="_typeComparison 237036"];
2598 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 237037"];
2599 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 237038"];
2600 [label="_considerName 237039"];
2601 [label="_considerExplicitlyImplementedInterfaces 237040"];
2602 [label="_considerReturnType 237041"];
2603 [label="_considerTypeConstraints 237042"];
2604 [label="_considerCallingConvention 237043"];
2605 [label="_considerRefKindDifferences 237044"];
2606 [label="_typeComparison 237045"];
2607 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237046"];
2608 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237047"];
2609 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 237048"];
2610 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 237049"];
2611 [label="false 237050"];
2612 [label="considerName: false 237051"];
2613 [label="false 237052"];
2614 [label="considerExplicitlyImplementedInterfaces: false 237053"];
2615 [label="false 237054"];
2616 [label="considerReturnType: false 237055"];
2617 [label="false 237056"];
2618 [label="considerTypeConstraints: false 237057"];
2619 [label="false 237058"];
2620 [label="considerCallingConvention: false 237059"];
2621 [label="true 237060"];
2622 [label="considerRefKindDifferences: true 237061"];
2623 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 237062"];
2624 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 237063"];
2625 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 237064"];
2626 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 237065"];
2627 [label="param MemberSignatureComparer(bool considerName) 237066"];
2628 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 237067"];
2629 [label="param MemberSignatureComparer(bool considerReturnType) 237068"];
2630 [label="param MemberSignatureComparer(bool considerTypeConstraints) 237069"];
2631 [label="param MemberSignatureComparer(bool considerCallingConvention) 237070"];
2632 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 237071"];
2633 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 237072"];
2634 [label="param MemberSignatureComparer(this) 237073"];
2635 [label="_considerName 237074"];
2636 [label="_considerExplicitlyImplementedInterfaces 237075"];
2637 [label="_considerReturnType 237076"];
2638 [label="_considerTypeConstraints 237077"];
2639 [label="_considerCallingConvention 237078"];
2640 [label="_considerRefKindDifferences 237079"];
2641 [label="_typeComparison 237080"];
2642 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 237081"];
2643 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 237082"];
2644 [label="_considerName 237083"];
2645 [label="_considerExplicitlyImplementedInterfaces 237084"];
2646 [label="_considerReturnType 237085"];
2647 [label="_considerTypeConstraints 237086"];
2648 [label="_considerCallingConvention 237087"];
2649 [label="_considerRefKindDifferences 237088"];
2650 [label="_typeComparison 237089"];
2651 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237090"];
2652 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 237091"];
2653 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 237092"];
2654 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 237093"];
2655 [label="MemberSignatureComparer.RecordAPISignatureComparer 237094"];
2656 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 237095"];
2657 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 237096"];
2658 [label="EmptyComparer.Instance 237097"];
2659 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 237098"];
2660 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 237099"];
2661 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 237100"];
2662 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 237101"];
2663 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 237102"];
2664 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 237103"];
2665 [label="containingSymbol 237104"];
2666 [label="declaration 237105"];
2667 [label="diagnostics 237106"];
2668 [label="tupleData 237107"];
2669 [label="param SourceNamedTypeSymbol(this) 237108"];
2670 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 237109"];
2671 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 237110"];
2672 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 237111"];
2673 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 237112"];
2674 [label="param SourceMemberContainerTypeSymbol(this) 237113"];
2675 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 237114"];
2676 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 237115"];
2677 [label="type => !type.HasType 237116"];
2678 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 237117"];
2679 [label="type => type.HasType && type.Type.IsErrorType() 237118"];
2680 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 237119"];
2681 [label="8 237120"];
2682 [label="ValueTupleRestPosition = 8 237121"];
2683 [label="1 237122"];
2684 [label="ValueTupleRestPosition - 1 237123"];
2685 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 237124"];
2686 [label="'ValueTuple' 237125"];
2687 [label="ValueTupleTypeName = 'ValueTuple' 237126"];
2688 [label="'Rest' 237127"];
2689 [label="ValueTupleRestFieldName = 'Rest' 237128"];
2690 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 237129"];
2691 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 237130"];
2692 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 237131"];
2693 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 237132"];
2694 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237133"];
2695 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 237134"];
2696 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 237135"];
2697 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 237136"];
2698 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 237137"];
2699 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 237138"];
2700 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 237139"];
2701 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 237140"];
2702 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 237141"];
2703 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237142"];
2704 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237143"];
2705 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237144"];
2706 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237145"];
2707 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237146"];
2708 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237147"];
2709 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237148"];
2710 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237149"];
2711 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 237150"];
2712 [label="tupleData 237151"];
2713 [label="param SourceMemberContainerTypeSymbol(this) 237152"];
2714 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 237153"];
2715 [label="param NamedTypeSymbol(this) 237154"];
2716 [label="'<invalid-global-code>' 237155"];
2717 [label="ImplicitTypeName = '<invalid-global-code>' 237156"];
2718 [label="0 237157"];
2719 [label="TypeCompareKind.ConsiderEverything 237158"];
2720 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 237159"];
2721 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237160"];
2722 [label="param SymbolEqualityComparer(this) 237161"];
2723 [label="_comparison 237162"];
2724 [label="_comparison 237163"];
2725 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 237164"];
2726 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 237165"];
2727 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237166"];
2728 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237167"];
2729 [label="param SymbolEqualityComparer(this) 237168"];
2730 [label="_comparison 237169"];
2731 [label="_comparison 237170"];
2732 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237171"];
2733 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 237172"];
2734 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237173"];
2735 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237174"];
2736 [label="param SymbolEqualityComparer(this) 237175"];
2737 [label="_comparison 237176"];
2738 [label="_comparison 237177"];
2739 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237178"];
2740 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 237179"];
2741 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237180"];
2742 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237181"];
2743 [label="param SymbolEqualityComparer(this) 237182"];
2744 [label="_comparison 237183"];
2745 [label="_comparison 237184"];
2746 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237185"];
2747 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 237186"];
2748 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 237187"];
2749 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237188"];
2750 [label="param SymbolEqualityComparer(this) 237189"];
2751 [label="_comparison 237190"];
2752 [label="_comparison 237191"];
2753 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 237192"];
2754 [label="TypeCompareKind.AllIgnoreOptions 237193"];
2755 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 237194"];
2756 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237195"];
2757 [label="param SymbolEqualityComparer(this) 237196"];
2758 [label="_comparison 237197"];
2759 [label="_comparison 237198"];
2760 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 237199"];
2761 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 237200"];
2762 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 237201"];
2763 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237202"];
2764 [label="param SymbolEqualityComparer(this) 237203"];
2765 [label="_comparison 237204"];
2766 [label="_comparison 237205"];
2767 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 237206"];
2768 [label="TypeCompareKind.CLRSignatureCompareOptions 237207"];
2769 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 237208"];
2770 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 237209"];
2771 [label="param SymbolEqualityComparer(this) 237210"];
2772 [label="_comparison 237211"];
2773 [label="_comparison 237212"];
2774 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 237213"];
2775 [label="SymbolEqualityComparer.CLRSignature 237214"];
2776 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 237215"];
2777 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 237216"];
2778 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 237217"];
2779 [label="new InterfaceInfo() 237218"];
2780 [label="param InterfaceInfo(this) 237219"];
2781 [label="interfacesAndTheirBaseInterfaces 237220"];
2782 [label="_implementationForInterfaceMemberMap 237221"];
2783 [label="explicitInterfaceImplementationMap 237222"];
2784 [label="s_noInterfaces = new InterfaceInfo() 237223"];
2785 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 237224"];
2786 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 237225"];
2787 [label="param NamedTypeSymbol(this) 237226"];
2788 [label="param TypeSymbol(this) 237227"];
2789 [label="param TypeSymbol(this) 237228"];
2790 [label="_lazyAbstractMembers 237229"];
2791 [label="_lazyInterfaceInfo 237230"];
2792 [label="_lazyAdapter 237231"];
2793 [label="_hasNoBaseCycles 237232"];
2794 [label="_lazyTupleData 237233"];
2795 [label="_lazyTupleData 237234"];
2796 [label="_declModifiers 237235"];
2797 [label="_containingSymbol 237236"];
2798 [label="declaration 237237"];
2799 [label="new DeclaredMembersAndInitializers() 237238"];
2800 [label="param DeclaredMembersAndInitializers(this) 237239"];
2801 [label="HaveIndexers 237240"];
2802 [label="RecordDeclarationWithParameters 237241"];
2803 [label="RecordPrimaryConstructor 237242"];
2804 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 237243"];
2805 [label="IsNullableEnabledForInstanceConstructorsAndFields 237244"];
2806 [label="IsNullableEnabledForStaticConstructorsAndFields 237245"];
2807 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 237246"];
2808 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 237247"];
2809 [label="_lazyMembersAndInitializers 237248"];
2810 [label="_lazyMembersDictionary 237249"];
2811 [label="_lazyEarlyAttributeDecodingMembersDictionary 237250"];
2812 [label="_lazyTypeMembers 237251"];
2813 [label="_lazyKnownCircularStruct 237252"];
2814 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 237253"];
2815 [label="_lazyContainsExtensionMethods 237254"];
2816 [label="_lazyAnyMemberHasAttributes 237255"];
2817 [label="_containingSymbol 237256"];
2818 [label="this.declaration 237257"];
2819 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 237258"];
2820 [label="declaration.Kind.ToTypeKind() 237259"];
2821 [label="param ToTypeKind(this DeclarationKind kind) 237260"];
2822 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 237261"];
2823 [label="return TypeKind.Class; 237262"];
2824 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 237263"];
2825 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 237264"];
2826 [label="MakeModifiers(typeKind, diagnostics) 237265"];
2827 [label="param MakeModifiers(TypeKind typeKind) 237266"];
2828 [label="param MakeModifiers(DiagnosticBag diagnostics) 237267"];
2829 [label="param MakeModifiers(this) 237268"];
2830 [label="this.ContainingSymbol 237269"];
2831 [label="get\n            {\n                return _containingSymbol;\n            } 237270"];
2832 [label="return _containingSymbol; 237271"];
2833 [label="Symbol containingSymbol = this.ContainingSymbol; 237272"];
2834 [label="DeclarationModifiers defaultAccess; 237273"];
2835 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 237274"];
2836 [label="containingSymbol.Kind 237275"];
2837 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 237276"];
2838 [label="return SymbolKind.Namespace; 237277"];
2839 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 237278"];
2840 [label="defaultAccess = DeclarationModifiers.Internal; 237279"];
2841 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 237280"];
2842 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 237281"];
2843 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 237282"];
2844 [label="this.IsRecord 237283"];
2845 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 237284"];
2846 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 237285"];
2847 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 237286"];
2848 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 237287"];
2849 [label="allowedModifiers |= DeclarationModifiers.Static; 237288"];
2850 [label="bool modifierErrors; 237289"];
2851 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 237290"];
2852 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 237291"];
2853 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 237292"];
2854 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 237293"];
2855 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 237294"];
2856 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 237295"];
2857 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 237296"];
2858 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 237297"];
2859 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 237298"];
2860 [label="param MakeAndCheckTypeModifiers(this) 237299"];
2861 [label="modifierErrors = false; 237300"];
2862 [label="var result = DeclarationModifiers.Unset; 237301"];
2863 [label="var partCount = declaration.Declarations.Length; 237302"];
2864 [label="var missingPartial = false; 237303"];
2865 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 237304"];
2866 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 237305"];
2867 [label="var decl = declaration.Declarations[i]; 237306"];
2868 [label="var mods = decl.Modifiers; 237307"];
2869 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 237308"];
2870 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 237309"];
2871 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237310"];
2872 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237311"];
2873 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237312"];
2874 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237313"];
2875 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237314"];
2876 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 237315"];
2877 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 237316"];
2878 [label="param CheckModifiers(DeclarationModifiers modifiers) 237317"];
2879 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 237318"];
2880 [label="param CheckModifiers(Location errorLocation) 237319"];
2881 [label="param CheckModifiers(DiagnosticBag diagnostics) 237320"];
2882 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 237321"];
2883 [label="param CheckModifiers(out bool modifierErrors) 237322"];
2884 [label="modifierErrors = false; 237323"];
2885 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 237324"];
2886 [label="DeclarationModifiers result = modifiers & allowedModifiers; 237325"];
2887 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 237326"];
2888 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 237327"];
2889 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 237328"];
2890 [label="return result; 237329"];
2891 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 237330"];
2892 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 237331"];
2893 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 237332"];
2894 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 237333"];
2895 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 237334"];
2896 [label="param CheckAccessibility(DeclarationModifiers modifiers) 237335"];
2897 [label="param CheckAccessibility(Symbol symbol) 237336"];
2898 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 237337"];
2899 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 237338"];
2900 [label="IsValidAccessibility(modifiers) 237339"];
2901 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 237340"];
2902 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 237341"];
2903 [label="return true; 237342"];
2904 [label="symbol.Kind 237343"];
2905 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 237344"];
2906 [label="return SymbolKind.NamedType; 237345"];
2907 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 237346"];
2908 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 237347"];
2909 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 237348"];
2910 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 237349"];
2911 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 237350"];
2912 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 237351"];
2913 [label="return null; 237352"];
2914 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 237353"];
2915 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 237354"];
2916 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 237355"];
2917 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 237356"];
2918 [label="result = mods; 237357"];
2919 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 237358"];
2920 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 237359"];
2921 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 237360"];
2922 [label="this.Name 237361"];
2923 [label="get\n            {\n                return declaration.Name;\n            } 237362"];
2924 [label="return declaration.Name; 237363"];
2925 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 237364"];
2926 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 237365"];
2927 [label="return result; 237366"];
2928 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 237367"];
2929 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 237368"];
2930 [label="this.CheckUnsafeModifier(mods, diagnostics); 237369"];
2931 [label="this.CheckUnsafeModifier(mods, diagnostics); 237370"];
2932 [label="this.CheckUnsafeModifier(mods, diagnostics); 237371"];
2933 [label="this.CheckUnsafeModifier(mods, diagnostics) 237372"];
2934 [label="param CheckUnsafeModifier(this Symbol symbol) 237373"];
2935 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 237374"];
2936 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 237375"];
2937 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 237376"];
2938 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 237377"];
2939 [label="symbol.Locations 237378"];
2940 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 237379"];
2941 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 237380"];
2942 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 237381"];
2943 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 237382"];
2944 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 237383"];
2945 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 237384"];
2946 [label="param CheckUnsafeModifier(this Symbol symbol) 237385"];
2947 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 237386"];
2948 [label="param CheckUnsafeModifier(Location errorLocation) 237387"];
2949 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 237388"];
2950 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 237389"];
2951 [label="this.CheckUnsafeModifier(mods, diagnostics); 237390"];
2952 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 237391"];
2953 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 237392"];
2954 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 237393"];
2955 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 237394"];
2956 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 237395"];
2957 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 237396"];
2958 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 237397"];
2959 [label="return mods; 237398"];
2960 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 237399"];
2961 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 237400"];
2962 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 237401"];
2963 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 237402"];
2964 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 237403"];
2965 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 237404"];
2966 [label="_declModifiers 237405"];
2967 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 237406"];
2968 [label="access == (int)DeclarationModifiers.Public 237407"];
2969 [label="MakeSpecialType() 237408"];
2970 [label="param MakeSpecialType(this) 237409"];
2971 [label="ContainingSymbol 237410"];
2972 [label="get\n            {\n                return _containingSymbol;\n            } 237411"];
2973 [label="return _containingSymbol; 237412"];
2974 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 237413"];
2975 [label="ContainingSymbol.Kind 237414"];
2976 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 237415"];
2977 [label="return SymbolKind.Namespace; 237416"];
2978 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 237417"];
2979 [label="ContainingSymbol 237418"];
2980 [label="get\n            {\n                return _containingSymbol;\n            } 237419"];
2981 [label="return _containingSymbol; 237420"];
2982 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 237421"];
2983 [label="ContainingSymbol.ContainingAssembly 237422"];
2984 [label="=> _module.ContainingAssembly 237423"];
2985 [label="_module.ContainingAssembly 237424"];
2986 [label="get\n            {\n                return _assemblySymbol;\n            } 237425"];
2987 [label="return _assemblySymbol; 237426"];
2988 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 237427"];
2989 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 237428"];
2990 [label="this.CorLibrary 237429"];
2991 [label="get\n            {\n                return _corLibrary;\n            } 237430"];
2992 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 237431"];
2993 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 237432"];
2994 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 237433"];
2995 [label="return SpecialType.None; 237434"];
2996 [label="0 237435"];
2997 [label="SpecialTypeOffset = 0 237436"];
2998 [label="6 237437"];
2999 [label="SpecialTypeSize = 6 237438"];
3000 [label="SpecialTypeOffset + SpecialTypeSize 237439"];
3001 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 237440"];
3002 [label="2 237441"];
3003 [label="ManagedKindSize = 2 237442"];
3004 [label="ManagedKindOffset + ManagedKindSize 237443"];
3005 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 237444"];
3006 [label="1 237445"];
3007 [label="FieldDefinitionsNotedSize = 1 237446"];
3008 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 237447"];
3009 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 237448"];
3010 [label="1 237449"];
3011 [label="FlattenedMembersIsSortedSize = 1 237450"];
3012 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 237451"];
3013 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 237452"];
3014 [label="4 237453"];
3015 [label="TypeKindSize = 4 237454"];
3016 [label="TypeKindOffset + TypeKindSize 237455"];
3017 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 237456"];
3018 [label="3 237457"];
3019 [label="NullableContextSize = 3 237458"];
3020 [label="1 237459"];
3021 [label="1 << SpecialTypeSize 237460"];
3022 [label="1 237461"];
3023 [label="(1 << SpecialTypeSize) - 1 237462"];
3024 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 237463"];
3025 [label="1 237464"];
3026 [label="1 << ManagedKindSize 237465"];
3027 [label="1 237466"];
3028 [label="(1 << ManagedKindSize) - 1 237467"];
3029 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 237468"];
3030 [label="1 237469"];
3031 [label="1 << TypeKindSize 237470"];
3032 [label="1 237471"];
3033 [label="(1 << TypeKindSize) - 1 237472"];
3034 [label="TypeKindMask = (1 << TypeKindSize) - 1 237473"];
3035 [label="1 237474"];
3036 [label="1 << NullableContextSize 237475"];
3037 [label="1 237476"];
3038 [label="(1 << NullableContextSize) - 1 237477"];
3039 [label="NullableContextMask = (1 << NullableContextSize) - 1 237478"];
3040 [label="1 237479"];
3041 [label="1 << FieldDefinitionsNotedOffset 237480"];
3042 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 237481"];
3043 [label="1 237482"];
3044 [label="1 << FlattenedMembersIsSortedOffset 237483"];
3045 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 237484"];
3046 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 237485"];
3047 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 237486"];
3048 [label="_flags = new Flags(specialType, typeKind); 237487"];
3049 [label="_flags = new Flags(specialType, typeKind); 237488"];
3050 [label="_flags = new Flags(specialType, typeKind); 237489"];
3051 [label="new Flags(specialType, typeKind) 237490"];
3052 [label="param Flags(SpecialType specialType) 237491"];
3053 [label="param Flags(TypeKind typeKind) 237492"];
3054 [label="param Flags(this) 237493"];
3055 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 237494"];
3056 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 237495"];
3057 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 237496"];
3058 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 237497"];
3059 [label="_flags = specialTypeInt | typeKindInt; 237498"];
3060 [label="_flags 237499"];
3061 [label="_flags 237500"];
3062 [label="this.ContainingType 237501"];
3063 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 237502"];
3064 [label="return _containingSymbol as NamedTypeSymbol; 237503"];
3065 [label="var containingType = this.ContainingType; 237504"];
3066 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 237505"];
3067 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 237506"];
3068 [label="state.NotePartComplete(CompletionPart.TypeArguments); 237507"];
3069 [label="state.NotePartComplete(CompletionPart.TypeArguments) 237508"];
3070 [label="param NotePartComplete(CompletionPart part) 237509"];
3071 [label="param NotePartComplete(this) 237510"];
3072 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237511"];
3073 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237512"];
3074 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237513"];
3075 [label="_lazyCustomAttributesBag 237514"];
3076 [label="_lazyDocComment 237515"];
3077 [label="_lazyExpandedDocComment 237516"];
3078 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 237517"];
3079 [label="_lazyDeclaredBases 237518"];
3080 [label="new UnsupportedMetadataTypeSymbol() 237519"];
3081 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 237520"];
3082 [label="param UnsupportedMetadataTypeSymbol(this) 237521"];
3083 [label="param ErrorTypeSymbol(this) 237522"];
3084 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 237523"];
3085 [label="tupleData 237524"];
3086 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 237525"];
3087 [label="param NamedTypeSymbol(this) 237526"];
3088 [label="param TypeSymbol(this) 237527"];
3089 [label="param NamespaceOrTypeSymbol(this) 237528"];
3090 [label="param Symbol(this) 237529"];
3091 [label="_lazyISymbol 237530"];
3092 [label="_lazyAbstractMembers 237531"];
3093 [label="_lazyInterfaceInfo 237532"];
3094 [label="_lazyAdapter 237533"];
3095 [label="_hasNoBaseCycles 237534"];
3096 [label="_lazyTupleData 237535"];
3097 [label="_lazyTupleData 237536"];
3098 [label="_mrEx 237537"];
3099 [label="_mrEx 237538"];
3100 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 237539"];
3101 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 237540"];
3102 [label="_lazyEnumValueField 237541"];
3103 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 237542"];
3104 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 237543"];
3105 [label="containingSymbol.Kind 237544"];
3106 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 237545"];
3107 [label="return SymbolKind.Namespace; 237546"];
3108 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 237547"];
3109 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 237548"];
3110 [label="param Add(NamespaceOrTypeSymbol symbol) 237549"];
3111 [label="param Add(this) 237550"];
3112 [label="symbol.Name 237551"];
3113 [label="get\n            {\n                return declaration.Name;\n            } 237552"];
3114 [label="return declaration.Name; 237553"];
3115 [label="string name = symbol.Name; 237554"];
3116 [label="object item; 237555"];
3117 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 237556"];
3118 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 237557"];
3119 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 237558"];
3120 [label="_dictionary 237559"];
3121 [label="builder.CreateMap() 237560"];
3122 [label="param CreateMap(this) 237561"];
3123 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 237562"];
3124 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 237563"];
3125 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 237564"];
3126 [label="object value = kvp.Value; 237565"];
3127 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 237566"];
3128 [label="members 237567"];
3129 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 237568"];
3130 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 237569"];
3131 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 237570"];
3132 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 237571"];
3133 [label="symbol.Kind 237572"];
3134 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 237573"];
3135 [label="return SymbolKind.NamedType; 237574"];
3136 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 237575"];
3137 [label="symbol.Kind == SymbolKind.Namespace 237576"];
3138 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 237577"];
3139 [label="result.Add(kvp.Key, members); 237578"];
3140 [label="result.Add(kvp.Key, members); 237579"];
3141 [label="result.Add(kvp.Key, members); 237580"];
3142 [label="return result; 237581"];
3143 [label="var result = builder.CreateMap(); 237582"];
3144 [label="CheckMembers(this, result, diagnostics); 237583"];
3145 [label="CheckMembers(this, result, diagnostics); 237584"];
3146 [label="CheckMembers(this, result, diagnostics); 237585"];
3147 [label="CheckMembers(this, result, diagnostics) 237586"];
3148 [label="param CheckMembers(NamespaceSymbol @namespace) 237587"];
3149 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 237588"];
3150 [label="param CheckMembers(DiagnosticBag diagnostics) 237589"];
3151 [label="var memberOfArity = new Symbol[10]; 237590"];
3152 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 237591"];
3153 [label="@namespace.ContainingAssembly 237592"];
3154 [label="=> _module.ContainingAssembly 237593"];
3155 [label="_module.ContainingAssembly 237594"];
3156 [label="get\n            {\n                return _assemblySymbol;\n            } 237595"];
3157 [label="return _assemblySymbol; 237596"];
3158 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 237597"];
3159 [label="@namespace.ContainingAssembly.Modules 237598"];
3160 [label="get\n            {\n                return _modules;\n            } 237599"];
3161 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 237600"];
3162 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 237601"];
3163 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 237602"];
3164 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 237603"];
3165 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 237604"];
3166 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 237605"];
3167 [label="var nts = symbol as NamedTypeSymbol; 237606"];
3168 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 237607"];
3169 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 237608"];
3170 [label="((object)nts != null) 237609"];
3171 [label="nts.Arity 237610"];
3172 [label="get\n            {\n                return declaration.Arity;\n            } 237611"];
3173 [label="return declaration.Arity; 237612"];
3174 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 237613"];
3175 [label="var other = memberOfArity[arity]; 237614"];
3176 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 237615"];
3177 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 237616"];
3178 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 237617"];
3179 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 237618"];
3180 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 237619"];
3181 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 237620"];
3182 [label="memberOfArity[arity] 237621"];
3183 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 237622"];
3184 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 237623"];
3185 [label="nts.DeclaredAccessibility 237624"];
3186 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 237625"];
3187 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 237626"];
3188 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 237627"];
3189 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 237628"];
3190 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 237629"];
3191 [label="return Accessibility.Public; 237630"];
3192 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 237631"];
3193 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 237632"];
3194 [label="CheckMembers(this, result, diagnostics); 237633"];
3195 [label="return result; 237634"];
3196 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 237635"];
3197 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 237636"];
3198 [label="this.DeclaringCompilation 237637"];
3199 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 237638"];
3200 [label="this.Kind 237639"];
3201 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 237640"];
3202 [label="return SymbolKind.Namespace; 237641"];
3203 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 237642"];
3204 [label="this.ContainingModule 237643"];
3205 [label="get\n            {\n                return _module;\n            } 237644"];
3206 [label="return _module; 237645"];
3207 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 237646"];
3208 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 237647"];
3209 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 237648"];
3210 [label="(object)sourceModuleSymbol == null 237649"];
3211 [label="sourceModuleSymbol.DeclaringCompilation 237650"];
3212 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 237651"];
3213 [label="this.DeclaringCompilation.DeclarationDiagnostics 237652"];
3214 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 237653"];
3215 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 237654"];
3216 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 237655"];
3217 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 237656"];
3218 [label="var diagnostics = new DiagnosticBag(); 237657"];
3219 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 237658"];
3220 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 237659"];
3221 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 237660"];
3222 [label="return _lazyDeclarationDiagnostics; 237661"];
3223 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 237662"];
3224 [label="RegisterDeclaredCorTypes() 237663"];
3225 [label="param RegisterDeclaredCorTypes(this) 237664"];
3226 [label="ContainingAssembly 237665"];
3227 [label="=> _module.ContainingAssembly 237666"];
3228 [label="_module.ContainingAssembly 237667"];
3229 [label="get\n            {\n                return _assemblySymbol;\n            } 237668"];
3230 [label="return _assemblySymbol; 237669"];
3231 [label="AssemblySymbol containingAssembly = ContainingAssembly; 237670"];
3232 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 237671"];
3233 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 237672"];
3234 [label="this.CorLibrary 237673"];
3235 [label="get\n            {\n                return _corLibrary;\n            } 237674"];
3236 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 237675"];
3237 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 237676"];
3238 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 237677"];
3239 [label="RegisterDeclaredCorTypes(); 237678"];
3240 [label="DeclaringCompilation 237679"];
3241 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 237680"];
3242 [label="this.Kind 237681"];
3243 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 237682"];
3244 [label="return SymbolKind.Namespace; 237683"];
3245 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 237684"];
3246 [label="this.ContainingModule 237685"];
3247 [label="get\n            {\n                return _module;\n            } 237686"];
3248 [label="return _module; 237687"];
3249 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 237688"];
3250 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 237689"];
3251 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 237690"];
3252 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 237691"];
3253 [label="param SymbolDeclaredEvent(Symbol symbol) 237692"];
3254 [label="param SymbolDeclaredEvent(this) 237693"];
3255 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 237694"];
3256 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 237695"];
3257 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 237696"];
3258 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 237697"];
3259 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 237698"];
3260 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 237699"];
3261 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 237700"];
3262 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 237701"];
3263 [label="param NotePartComplete(CompletionPart part) 237702"];
3264 [label="param NotePartComplete(this) 237703"];
3265 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237704"];
3266 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237705"];
3267 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 237706"];
3268 [label="Debug.Assert(wasSetThisThread); 237707"];
3269 [label="diagnostics.Free(); 237708"];
3270 [label="return _nameToMembersMap; 237709"];
3271 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 237710"];
3272 [label="GetTypesFromMemberMap(GetNameToMembersMap()) 237711"];
3273 [label="param GetTypesFromMemberMap(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> map) 237712"];
3274 [label="var dictionary = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(StringOrdinalComparer.Instance); 237713"];
3275 [label="foreach (var kvp in map)\n            {\n                ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value;\n\n                bool hasType = false;\n                bool hasNamespace = false;\n\n                foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                }\n            } 237714"];
3276 [label="ImmutableArray<NamespaceOrTypeSymbol> members = kvp.Value; 237715"];
3277 [label="bool hasType = false; 237716"];
3278 [label="bool hasNamespace = false; 237717"];
3279 [label="foreach (var symbol in members)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    }\n                } 237718"];
3280 [label="symbol.Kind 237719"];
3281 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 237720"];
3282 [label="if (symbol.Kind == SymbolKind.NamedType)\n                    {\n                        hasType = true;\n                        if (hasNamespace)\n                        {\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        Debug.Assert(symbol.Kind == SymbolKind.Namespace);\n                        hasNamespace = true;\n                        if (hasType)\n                        {\n                            break;\n                        }\n                    } 237721"];
3283 [label="hasType = true; 237722"];
3284 [label="if (hasNamespace)\n                        {\n                            break;\n                        } 237723"];
3285 [label="if (hasType)\n                {\n                    if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    }\n                } 237724"];
3286 [label="if (hasNamespace)\n                    {\n                        dictionary.Add(kvp.Key, members.OfType<NamedTypeSymbol>().AsImmutable());\n                    }\n                    else\n                    {\n                        dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>());\n                    } 237725"];
3287 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 237726"];
3288 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 237727"];
3289 [label="dictionary.Add(kvp.Key, members.As<NamedTypeSymbol>()); 237728"];
3290 [label="return dictionary; 237729"];
3291 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 237730"];
3292 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 237731"];
3293 [label="Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null); 237732"];
3294 [label="return _nameToTypeMembersMap; 237733"];
3295 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 237734"];
3296 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 237735"];
3297 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 237736"];
3298 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 237737"];
3299 [label="this.GetNameToTypeMembersMap().TryGetValue(name, out members) 237738"];
3300 [label="var sym1 = (classTest.GetMembers('AryField').First() as FieldSymbol).Type; 237739"];
3301 [label="classTest.GetMembers('AryField') 237740"];
3302 [label="param GetMembers(string name) 237741"];
3303 [label="param GetMembers(this) 237742"];
3304 [label="ImmutableArray<Symbol> members; 237743"];
3305 [label="members 237744"];
3306 [label="GetMembersByName() 237745"];
3307 [label="param GetMembersByName(this) 237746"];
3308 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 237747"];
3309 [label="this.state.HasComplete(CompletionPart.Members) 237748"];
3310 [label="param HasComplete(CompletionPart part) 237749"];
3311 [label="param HasComplete(this) 237750"];
3312 [label="return (_completeParts & (int)part) == (int)part; 237751"];
3313 [label="GetMembersByNameSlow() 237752"];
3314 [label="param GetMembersByNameSlow(this) 237753"];
3315 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 237754"];
3316 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 237755"];
3317 [label="var diagnostics = DiagnosticBag.GetInstance(); 237756"];
3318 [label="var membersDictionary = MakeAllMembers(diagnostics); 237757"];
3319 [label="MakeAllMembers(diagnostics) 237758"];
3320 [label="param MakeAllMembers(DiagnosticBag diagnostics) 237759"];
3321 [label="param MakeAllMembers(this) 237760"];
3322 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName; 237761"];
3323 [label="GetMembersAndInitializers() 237762"];
3324 [label="param GetMembersAndInitializers(this) 237763"];
3325 [label="var membersAndInitializers = _lazyMembersAndInitializers; 237764"];
3326 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 237765"];
3327 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 237766"];
3328 [label="var diagnostics = DiagnosticBag.GetInstance(); 237767"];
3329 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 237768"];
3330 [label="BuildMembersAndInitializers(diagnostics) 237769"];
3331 [label="param BuildMembersAndInitializers(DiagnosticBag diagnostics) 237770"];
3332 [label="param BuildMembersAndInitializers(this) 237771"];
3333 [label="getDeclaredMembersAndInitializers() 237772"];
3334 [label="DeclaredMembersAndInitializers? getDeclaredMembersAndInitializers()\n            {\n                var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers;\n                if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                }\n\n                if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics);\n\n                var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel);\n                if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                }\n\n                AddDeclarationDiagnostics(diagnostics);\n                diagnostics.Free();\n\n                return declaredMembersAndInitializers!;\n            } 237773"];
3335 [label="var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers; 237774"];
3336 [label="if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                } 237775"];
3337 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                } 237776"];
3338 [label="var diagnostics = DiagnosticBag.GetInstance(); 237777"];
3339 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 237778"];
3340 [label="buildDeclaredMembersAndInitializers(diagnostics) 237779"];
3341 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 237780"];
3342 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 237781"];
3343 [label="var builder = new DeclaredMembersAndInitializersBuilder(); 237782"];
3344 [label="new DeclaredMembersAndInitializersBuilder() 237783"];
3345 [label="param DeclaredMembersAndInitializersBuilder(this) 237784"];
3346 [label="ArrayBuilder<Symbol>.GetInstance() 237785"];
3347 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance() 237786"];
3348 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 237787"];
3349 [label="StaticInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 237788"];
3350 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 237789"];
3351 [label="InstanceInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 237790"];
3352 [label="HaveIndexers 237791"];
3353 [label="RecordDeclarationWithParameters 237792"];
3354 [label="RecordPrimaryConstructor 237793"];
3355 [label="1 237794"];
3356 [label="InstanceInitializersIndexForRecordDeclarationWithParameters = -1 237795"];
3357 [label="IsNullableEnabledForInstanceConstructorsAndFields 237796"];
3358 [label="IsNullableEnabledForStaticConstructorsAndFields 237797"];
3359 [label="AddDeclaredNontypeMembers(builder, diagnostics); 237798"];
3360 [label="AddDeclaredNontypeMembers(builder, diagnostics); 237799"];
3361 [label="AddDeclaredNontypeMembers(builder, diagnostics) 237800"];
3362 [label="param AddDeclaredNontypeMembers(DeclaredMembersAndInitializersBuilder builder) 237801"];
3363 [label="param AddDeclaredNontypeMembers(DiagnosticBag diagnostics) 237802"];
3364 [label="param AddDeclaredNontypeMembers(this) 237803"];
3365 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                }\n\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                var syntax = decl.SyntaxReference.GetSyntax();\n\n                switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                }\n            } 237804"];
3366 [label="if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                } 237805"];
3367 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 237806"];
3368 [label="var syntax = decl.SyntaxReference.GetSyntax(); 237807"];
3369 [label="switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                } 237808"];
3370 [label="var typeDecl = (TypeDeclarationSyntax)syntax; 237809"];
3371 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 237810"];
3372 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 237811"];
3373 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 237812"];
3374 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics); 237813"];
3375 [label="AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics) 237814"];
3376 [label="param AddNonTypeMembers(DeclaredMembersAndInitializersBuilder builder) 237815"];
3377 [label="param AddNonTypeMembers(ArrayBuilder<FieldOrPropertyInitializer>? instanceInitializers) 237816"];
3378 [label="param AddNonTypeMembers(SyntaxList<MemberDeclarationSyntax> members) 237817"];
3379 [label="param AddNonTypeMembers(DiagnosticBag diagnostics) 237818"];
3380 [label="param AddNonTypeMembers(this) 237819"];
3381 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 237820"];
3382 [label="if (members.Count == 0)\n            {\n                AddInitializers(builder.InstanceInitializers, instanceInitializers);\n                return;\n            } 237821"];
3383 [label="var firstMember = members[0]; 237822"];
3384 [label="var firstMember = members[0]; 237823"];
3385 [label="var bodyBinder = this.GetBinder(firstMember); 237824"];
3386 [label="this.GetBinder(firstMember) 237825"];
3387 [label="param GetBinder(CSharpSyntaxNode syntaxNode) 237826"];
3388 [label="param GetBinder(this) 237827"];
3389 [label="this.DeclaringCompilation 237828"];
3390 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 237829"];
3391 [label="this.Kind 237830"];
3392 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 237831"];
3393 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 237832"];
3394 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 237833"];
3395 [label="this.ContainingSymbol 237834"];
3396 [label="get\n            {\n                return _containingSymbol;\n            } 237835"];
3397 [label="return _containingSymbol; 237836"];
3398 [label="var container = this.ContainingSymbol; 237837"];
3399 [label="return (object)container != null ? container.ContainingModule : null; 237838"];
3400 [label="return (object)container != null ? container.ContainingModule : null; 237839"];
3401 [label="(object)container != null 237840"];
3402 [label="container.ContainingModule 237841"];
3403 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 237842"];
3404 [label="return this.DeclaringCompilation.GetBinder(syntaxNode); 237843"];
3405 [label="this.DeclaringCompilation.GetBinder(syntaxNode) 237844"];
3406 [label="param GetBinder(CSharpSyntaxNode syntax) 237845"];
3407 [label="param GetBinder(this) 237846"];
3408 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 237847"];
3409 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 237848"];
3410 [label="GetBinderFactory(syntax.SyntaxTree) 237849"];
3411 [label="param GetBinderFactory(SyntaxTree syntaxTree) 237850"];
3412 [label="param GetBinderFactory(bool ignoreAccessibility = false) 237851"];
3413 [label="param GetBinderFactory(this) 237852"];
3414 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 237853"];
3415 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 237854"];
3416 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 237855"];
3417 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 237856"];
3418 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 237857"];
3419 [label="param GetBinderFactory(SyntaxTree syntaxTree) 237858"];
3420 [label="param GetBinderFactory(bool ignoreAccessibility) 237859"];
3421 [label="param GetBinderFactory(ref WeakReference<BinderFactory>[]? cachedBinderFactories) 237860"];
3422 [label="param GetBinderFactory(this) 237861"];
3423 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 237862"];
3424 [label="ignoreAccessibility 237863"];
3425 [label="_binderFactories 237864"];
3426 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 237865"];
3427 [label="Debug.Assert(System.Runtime.CompilerServices.Unsafe.AreSame(ref cachedBinderFactories, ref ignoreAccessibility ? ref _ignoreAccessibilityBinderFactories : ref _binderFactories)); 237866"];
3428 [label="var treeNum = GetSyntaxTreeOrdinal(syntaxTree); 237867"];
3429 [label="GetSyntaxTreeOrdinal(syntaxTree) 237868"];
3430 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 237869"];
3431 [label="param GetSyntaxTreeOrdinal(this) 237870"];
3432 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 237871"];
3433 [label="this.ContainsSyntaxTree(tree) 237872"];
3434 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 237873"];
3435 [label="param ContainsSyntaxTree(this) 237874"];
3436 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 237875"];
3437 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 237876"];
3438 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 237877"];
3439 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 237878"];
3440 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 237879"];
3441 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 237880"];
3442 [label="WeakReference<BinderFactory>[]? binderFactories = cachedBinderFactories; 237881"];
3443 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 237882"];
3444 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 237883"];
3445 [label="this.SyntaxTrees 237884"];
3446 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 237885"];
3447 [label="binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length]; 237886"];
3448 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 237887"];
3449 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 237888"];
3450 [label="binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories; 237889"];
3451 [label="BinderFactory? previousFactory; 237890"];
3452 [label="var previousWeakReference = binderFactories[treeNum]; 237891"];
3453 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 237892"];
3454 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 237893"];
3455 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 237894"];
3456 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 237895"];
3457 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 237896"];
3458 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 237897"];
3459 [label="param AddNewFactory(SyntaxTree syntaxTree) 237898"];
3460 [label="param AddNewFactory(bool ignoreAccessibility) 237899"];
3461 [label="param AddNewFactory([NotNull] ref WeakReference<BinderFactory>? slot) 237900"];
3462 [label="param AddNewFactory(this) 237901"];
3463 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 237902"];
3464 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 237903"];
3465 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 237904"];
3466 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 237905"];
3467 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 237906"];
3468 [label="param BinderFactory(CSharpCompilation compilation) 237907"];
3469 [label="param BinderFactory(SyntaxTree syntaxTree) 237908"];
3470 [label="param BinderFactory(bool ignoreAccessibility) 237909"];
3471 [label="param BinderFactory(this) 237910"];
3472 [label="_binderCache 237911"];
3473 [label="_compilation 237912"];
3474 [label="_syntaxTree 237913"];
3475 [label="_buckStopsHereBinder 237914"];
3476 [label="_ignoreAccessibility 237915"];
3477 [label="_binderFactoryVisitorPool 237916"];
3478 [label="_compilation 237917"];
3479 [label="_syntaxTree 237918"];
3480 [label="_ignoreAccessibility 237919"];
3481 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 237920"];
3482 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 237921"];
3483 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 237922"];
3484 [label="_binderFactoryVisitorPool 237923"];
3485 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 237924"];
3486 [label="_binderCache 237925"];
3487 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 237926"];
3488 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 237927"];
3489 [label="new BuckStopsHereBinder(compilation) 237928"];
3490 [label="param BuckStopsHereBinder(CSharpCompilation compilation) 237929"];
3491 [label="param BuckStopsHereBinder(this) 237930"];
3492 [label="0 237931"];
3493 [label="ExternalScope = 0 237932"];
3494 [label="1 237933"];
3495 [label="TopLevelScope = 1 237934"];
3496 [label="2 237935"];
3497 [label="ValueKindInsignificantBits = 2 237936"];
3498 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 237937"];
3499 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 237938"];
3500 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 237939"];
3501 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 237940"];
3502 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 237941"];
3503 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 237942"];
3504 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 237943"];
3505 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 237944"];
3506 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 237945"];
3507 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 237946"];
3508 [label="10 237947"];
3509 [label="MaxParameterListsForErrorRecovery = 10 237948"];
3510 [label="'<>h__TransparentIdentifier' 237949"];
3511 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 237950"];
3512 [label="s => (MethodSymbol)s 237951"];
3513 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 237952"];
3514 [label="s => (PropertySymbol)s 237953"];
3515 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 237954"];
3516 [label="compilation 237955"];
3517 [label="param BuckStopsHereBinder(this) 237956"];
3518 [label="param Binder(CSharpCompilation compilation) 237957"];
3519 [label="param Binder(this) 237958"];
3520 [label="internal CSharpCompilation Compilation { get; } 237959"];
3521 [label="Flags 237960"];
3522 [label="protected internal Binder? Next { get; } 237961"];
3523 [label="_lazyConversions 237962"];
3524 [label="_lazyOverloadResolution 237963"];
3525 [label="RoslynDebug.Assert(compilation != null); 237964"];
3526 [label="RoslynDebug.Assert(compilation != null); 237965"];
3527 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 237966"];
3528 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 237967"];
3529 [label="compilation.Options 237968"];
3530 [label="get\n            {\n                return _options;\n            } 237969"];
3531 [label="return _options; 237970"];
3532 [label="this.Flags = compilation.Options.TopLevelBinderFlags; 237971"];
3533 [label="this.Flags 237972"];
3534 [label="this.Compilation 237973"];
3535 [label="_buckStopsHereBinder 237974"];
3536 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 237975"];
3537 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 237976"];
3538 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 237977"];
3539 [label="BinderFactory? previousFactory; 237978"];
3540 [label="WeakReference<BinderFactory>? previousWeakReference = slot; 237979"];
3541 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 237980"];
3542 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 237981"];
3543 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 237982"];
3544 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 237983"];
3545 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 237984"];
3546 [label="if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                } 237985"];
3547 [label="return newFactory; 237986"];
3548 [label="return GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax); 237987"];
3549 [label="GetBinderFactory(syntax.SyntaxTree).GetBinder(syntax) 237988"];
3550 [label="param GetBinder(SyntaxNode node) 237989"];
3551 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 237990"];
3552 [label="param GetBinder(Symbol memberOpt = null) 237991"];
3553 [label="param GetBinder(this) 237992"];
3554 [label="int position = node.SpanStart; 237993"];
3555 [label="InScript 237994"];
3556 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 237995"];
3557 [label="return _syntaxTree.Options.Kind == SourceCodeKind.Script; 237996"];
3558 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 237997"];
3559 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 237998"];
3560 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 237999"];
3561 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 238000"];
3562 [label="node = node.Parent; 238001"];
3563 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 238002"];
3564 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 238003"];
3565 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 238004"];
3566 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 238005"];
3567 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 238006"];
3568 [label="param GetBinder(SyntaxNode node) 238007"];
3569 [label="param GetBinder(int position) 238008"];
3570 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 238009"];
3571 [label="param GetBinder(Symbol memberOpt = null) 238010"];
3572 [label="param GetBinder(this) 238011"];
3573 [label="Debug.Assert(node != null); 238012"];
3574 [label="Debug.Assert(node != null); 238013"];
3575 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 238014"];
3576 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 238015"];
3577 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 238016"];
3578 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 238017"];
3579 [label="param BinderFactoryVisitor(BinderFactory factory) 238018"];
3580 [label="param BinderFactoryVisitor(this) 238019"];
3581 [label="param BinderFactoryVisitor(this) 238020"];
3582 [label="_position 238021"];
3583 [label="_memberDeclarationOpt 238022"];
3584 [label="_memberOpt 238023"];
3585 [label="_factory 238024"];
3586 [label="_factory 238025"];
3587 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 238026"];
3588 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 238027"];
3589 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 238028"];
3590 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 238029"];
3591 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 238030"];
3592 [label="param Initialize(int position) 238031"];
3593 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 238032"];
3594 [label="param Initialize(Symbol memberOpt) 238033"];
3595 [label="param Initialize(this) 238034"];
3596 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 238035"];
3597 [label="memberDeclarationOpt == null 238036"];
3598 [label="param ==(Symbol left) 238037"];
3599 [label="param ==(Symbol right) 238038"];
3600 [label="if (right is null)\n            {\n                return left is null;\n            } 238039"];
3601 [label="return left is null; 238040"];
3602 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 238041"];
3603 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 238042"];
3604 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 238043"];
3605 [label="_position 238044"];
3606 [label="_memberDeclarationOpt 238045"];
3607 [label="_memberOpt 238046"];
3608 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 238047"];
3609 [label="Binder result = visitor.Visit(node); 238048"];
3610 [label="visitor.Visit(node) 238049"];
3611 [label="param Visit(SyntaxNode node) 238050"];
3612 [label="param Visit(this) 238051"];
3613 [label="return VisitCore(node); 238052"];
3614 [label="VisitCore(node) 238053"];
3615 [label="param VisitCore(SyntaxNode node) 238054"];
3616 [label="param VisitCore(this) 238055"];
3617 [label="return ((CSharpSyntaxNode)node).Accept(this); 238056"];
3618 [label="return ((CSharpSyntaxNode)node).Accept(this); 238057"];
3619 [label="return ((CSharpSyntaxNode)node).Accept(this); 238058"];
3620 [label="param VisitClassDeclaration(ClassDeclarationSyntax node) 238059"];
3621 [label="param VisitClassDeclaration(this) 238060"];
3622 [label="return VisitTypeDeclarationCore(node); 238061"];
3623 [label="VisitTypeDeclarationCore(node) 238062"];
3624 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 238063"];
3625 [label="param VisitTypeDeclarationCore(this) 238064"];
3626 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 238065"];
3627 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 238066"];
3628 [label="if (!LookupPosition.IsInTypeDeclaration(_position, parent))\n                {\n                    return VisitCore(parent.Parent);\n                } 238067"];
3629 [label="NodeUsage extraInfo = NodeUsage.Normal; 238068"];
3630 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 238069"];
3631 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 238070"];
3632 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 238071"];
3633 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 238072"];
3634 [label="extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters; 238073"];
3635 [label="return VisitTypeDeclarationCore(parent, extraInfo); 238074"];
3636 [label="return VisitTypeDeclarationCore(parent, extraInfo); 238075"];
3637 [label="VisitTypeDeclarationCore(parent, extraInfo) 238076"];
3638 [label="param VisitTypeDeclarationCore(TypeDeclarationSyntax parent) 238077"];
3639 [label="param VisitTypeDeclarationCore(NodeUsage extraInfo) 238078"];
3640 [label="param VisitTypeDeclarationCore(this) 238079"];
3641 [label="var key = CreateBinderCacheKey(parent, extraInfo); 238080"];
3642 [label="var key = CreateBinderCacheKey(parent, extraInfo); 238081"];
3643 [label="CreateBinderCacheKey(parent, extraInfo) 238082"];
3644 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 238083"];
3645 [label="param CreateBinderCacheKey(NodeUsage usage) 238084"];
3646 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 238085"];
3647 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 238086"];
3648 [label="return new BinderCacheKey(node, usage); 238087"];
3649 [label="return new BinderCacheKey(node, usage); 238088"];
3650 [label="return new BinderCacheKey(node, usage); 238089"];
3651 [label="new BinderCacheKey(node, usage) 238090"];
3652 [label="param BinderCacheKey(CSharpSyntaxNode syntaxNode) 238091"];
3653 [label="param BinderCacheKey(NodeUsage usage) 238092"];
3654 [label="param BinderCacheKey(this) 238093"];
3655 [label="this.syntaxNode 238094"];
3656 [label="this.usage 238095"];
3657 [label="var key = CreateBinderCacheKey(parent, extraInfo); 238096"];
3658 [label="Binder resultBinder; 238097"];
3659 [label="binderCache 238098"];
3660 [label="get\n                {\n                    return _factory._binderCache;\n                } 238099"];
3661 [label="return _factory._binderCache; 238100"];
3662 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 238101"];
3663 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 238102"];
3664 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 238103"];
3665 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 238104"];
3666 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 238105"];
3667 [label="param GetHashCode(this) 238106"];
3668 [label="return Hash.Combine(syntaxNode.GetHashCode(), (int)usage); 238107"];
3669 [label="resultBinder = VisitCore(parent.Parent); 238108"];
3670 [label="VisitCore(parent.Parent) 238109"];
3671 [label="param VisitCore(SyntaxNode node) 238110"];
3672 [label="param VisitCompilationUnit(CompilationUnitSyntax parent) 238111"];
3673 [label="param VisitCompilationUnit(this) 238112"];
3674 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 238113"];
3675 [label="IsInUsing(parent) 238114"];
3676 [label="param IsInUsing(CSharpSyntaxNode containingNode) 238115"];
3677 [label="param IsInUsing(this) 238116"];
3678 [label="TextSpan containingSpan = containingNode.Span; 238117"];
3679 [label="SyntaxToken token; 238118"];
3680 [label="token 238119"];
3681 [label="if (containingNode.Kind() != SyntaxKind.CompilationUnit && _position == containingSpan.End)\n                {\n                    // This occurs at EOF\n                    token = containingNode.GetLastToken();\n                    Debug.Assert(token == this.syntaxTree.GetRoot().GetLastToken());\n                }\n                else if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 238120"];
3682 [label="if (_position < containingSpan.Start || _position > containingSpan.End) //NB: > not >=\n                {\n                    return false;\n                }\n                else\n                {\n                    token = containingNode.FindToken(_position);\n                } 238121"];
3683 [label="token = containingNode.FindToken(_position); 238122"];
3684 [label="token = containingNode.FindToken(_position); 238123"];
3685 [label="var node = token.Parent; 238124"];
3686 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 238125"];
3687 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 238126"];
3688 [label="while (node != null && node != containingNode)\n                {\n                    // ACASEY: the restriction that we're only interested in children\n                    // of containingNode (vs descendants) seems to be required for cases like\n                    // GetSemanticInfoTests.BindAliasQualifier, which binds an alias name\n                    // within a using directive.\n                    if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    }\n\n                    node = node.Parent;\n                } 238127"];
3689 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 238128"];
3690 [label="if (node.IsKind(SyntaxKind.UsingDirective) && node.Parent == containingNode)\n                    {\n                        return true;\n                    } 238129"];
3691 [label="node = node.Parent; 238130"];
3692 [label="return false; 238131"];
3693 [label="return VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript); 238132"];
3694 [label="InScript 238133"];
3695 [label="get\n                {\n                    return _factory.InScript;\n                } 238134"];
3696 [label="_factory.InScript 238135"];
3697 [label="get\n            {\n                return _syntaxTree.Options.Kind == SourceCodeKind.Script;\n            } 238136"];
3698 [label="return _factory.InScript; 238137"];
3699 [label="VisitCompilationUnit(\n                    parent,\n                    inUsing: IsInUsing(parent),\n                    inScript: InScript) 238138"];
3700 [label="param VisitCompilationUnit(CompilationUnitSyntax compilationUnit) 238139"];
3701 [label="param VisitCompilationUnit(bool inUsing) 238140"];
3702 [label="param VisitCompilationUnit(bool inScript) 238141"];
3703 [label="param VisitCompilationUnit(this) 238142"];
3704 [label="syntaxTree 238143"];
3705 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 238144"];
3706 [label="return _factory._syntaxTree; 238145"];
3707 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 238146"];
3708 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 238147"];
3709 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 238148"];
3710 [label="inUsing 238149"];
3711 [label="inScript 238150"];
3712 [label="var extraInfo = inUsing\n                    ? (inScript ? NodeUsage.CompilationUnitScriptUsings : NodeUsage.CompilationUnitUsings)\n                    : (inScript ? NodeUsage.CompilationUnitScript : NodeUsage.Normal); 238151"];
3713 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 238152"];
3714 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 238153"];
3715 [label="CreateBinderCacheKey(compilationUnit, extraInfo) 238154"];
3716 [label="param CreateBinderCacheKey(CSharpSyntaxNode node) 238155"];
3717 [label="param CreateBinderCacheKey(NodeUsage usage) 238156"];
3718 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 238157"];
3719 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 238158"];
3720 [label="var key = CreateBinderCacheKey(compilationUnit, extraInfo); 238159"];
3721 [label="Binder result; 238160"];
3722 [label="binderCache 238161"];
3723 [label="get\n                {\n                    return _factory._binderCache;\n                } 238162"];
3724 [label="return _factory._binderCache; 238163"];
3725 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 238164"];
3726 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 238165"];
3727 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 238166"];
3728 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 238167"];
3729 [label="if (!binderCache.TryGetValue(key, out result))\n                {\n                    result = this.buckStopsHereBinder;\n\n                    if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    }\n\n                    binderCache.TryAdd(key, result);\n                } 238168"];
3730 [label="this.buckStopsHereBinder 238169"];
3731 [label="get\n                {\n                    return _factory._buckStopsHereBinder;\n                } 238170"];
3732 [label="return _factory._buckStopsHereBinder; 238171"];
3733 [label="result = this.buckStopsHereBinder; 238172"];
3734 [label="if (inScript)\n                    {\n                        Debug.Assert((object)compilation.ScriptClass != null);\n\n                        //\n                        // Binder chain in script/interactive code:\n                        //\n                        // + global imports\n                        //   + current and previous submission imports (except using aliases)\n                        //     + global namespace\n                        //       + host object members\n                        //         + previous submissions and corresponding using aliases\n                        //           + script class members and using aliases\n                        //\n\n                        bool isSubmissionTree = compilation.IsSubmissionSyntaxTree(compilationUnit.SyntaxTree);\n                        if (!isSubmissionTree)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InLoadedSyntaxTree);\n                        }\n\n                        // This is declared here so it can be captured.  It's initialized below.\n                        InContainerBinder scriptClassBinder = null;\n\n                        if (inUsing)\n                        {\n                            result = result.WithAdditionalFlags(BinderFlags.InScriptUsing);\n                        }\n                        else\n                        {\n                            result = new InContainerBinder(container: null, next: result, imports: compilation.GlobalImports);\n\n                            // NB: This binder has a full Imports object, but only the non-alias imports are\n                            // ever consumed.  Aliases are actually checked in scriptClassBinder (below).\n                            // Note: #loaded trees don't consume previous submission imports.\n                            result = compilation.PreviousSubmission == null || !isSubmissionTree\n                                ? new InContainerBinder(result, basesBeingResolved => scriptClassBinder.GetImports(basesBeingResolved))\n                                : new InContainerBinder(result, basesBeingResolved =>\n                                    compilation.GetPreviousSubmissionImports().Concat(scriptClassBinder.GetImports(basesBeingResolved)));\n                        }\n\n                        result = new InContainerBinder(compilation.GlobalNamespace, result);\n\n                        if (compilation.HostObjectType != null)\n                        {\n                            result = new HostObjectModelBinder(result);\n                        }\n\n                        scriptClassBinder = new InContainerBinder(compilation.ScriptClass, result, compilationUnit, inUsing: inUsing);\n                        result = scriptClassBinder;\n                    }\n                    else\n                    {\n                        //\n                        // Binder chain in regular code:\n                        //\n                        // + global namespace with top-level imports\n                        // \n                        result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing);\n\n                        if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        }\n                    } 238173"];
3735 [label="compilation 238174"];
3736 [label="get\n                {\n                    return _factory._compilation;\n                } 238175"];
3737 [label="return _factory._compilation; 238176"];
3738 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 238177"];
3739 [label="compilation.GlobalNamespace 238178"];
3740 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 238179"];
3741 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 238180"];
3742 [label="var modules = ArrayBuilder<ModuleSymbol>.GetInstance(); 238181"];
3743 [label="GetAllUnaliasedModules(modules); 238182"];
3744 [label="GetAllUnaliasedModules(modules) 238183"];
3745 [label="param GetAllUnaliasedModules(ArrayBuilder<ModuleSymbol> modules) 238184"];
3746 [label="param GetAllUnaliasedModules(this) 238185"];
3747 [label="Assembly 238186"];
3748 [label="get\n            {\n                return SourceAssembly;\n            } 238187"];
3749 [label="return _referenceManager; 238188"];
3750 [label="GetBoundReferenceManager(); 238189"];
3751 [label="modules.AddRange(Assembly.Modules); 238190"];
3752 [label="Assembly.Modules 238191"];
3753 [label="get\n            {\n                return _modules;\n            } 238192"];
3754 [label="modules.AddRange(Assembly.Modules); 238193"];
3755 [label="GetBoundReferenceManager() 238194"];
3756 [label="param GetBoundReferenceManager(this) 238195"];
3757 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 238196"];
3758 [label="return _referenceManager; 238197"];
3759 [label="var referenceManager = GetBoundReferenceManager(); 238198"];
3760 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 238199"];
3761 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                }\n            } 238200"];
3762 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules);\n                } 238201"];
3763 [label="modules.AddRange(referenceManager.ReferencedAssemblies[i].Modules); 238202"];
3764 [label="referenceManager.ReferencedAssemblies[i].Modules 238203"];
3765 [label="get\n            {\n                return _modules;\n            } 238204"];
3766 [label="GetAllUnaliasedModules(modules); 238205"];
3767 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 238206"];
3768 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 238207"];
3769 [label="new NamespaceExtent(this) 238208"];
3770 [label="param NamespaceExtent(CSharpCompilation compilation) 238209"];
3771 [label="param NamespaceExtent(this) 238210"];
3772 [label="_kind 238211"];
3773 [label="_symbolOrCompilation 238212"];
3774 [label="var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)); 238213"];
3775 [label="param GetHashCode(this) 238214"];
3776 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 238215"];
3777 [label="get { return _globalNamespace; } 238216"];
3778 [label="return _globalNamespace; 238217"];
3779 [label="MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace)) 238218"];
3780 [label="param Create(NamespaceExtent extent) 238219"];
3781 [label="param Create(NamespaceSymbol containingNamespace) 238220"];
3782 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 238221"];
3783 [label="param Create(string nameOpt = null) 238222"];
3784 [label="Debug.Assert(namespacesToMerge.Length != 0); 238223"];
3785 [label="Debug.Assert(namespacesToMerge.Length != 0); 238224"];
3786 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 238225"];
3787 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 238226"];
3788 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 238227"];
3789 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 238228"];
3790 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 238229"];
3791 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 238230"];
3792 [label="new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt) 238231"];
3793 [label="param MergedNamespaceSymbol(NamespaceExtent extent) 238232"];
3794 [label="param MergedNamespaceSymbol(NamespaceSymbol containingNamespace) 238233"];
3795 [label="param MergedNamespaceSymbol(ImmutableArray<NamespaceSymbol> namespacesToMerge) 238234"];
3796 [label="param MergedNamespaceSymbol(string nameOpt) 238235"];
3797 [label="param MergedNamespaceSymbol(this) 238236"];
3798 [label="param MergedNamespaceSymbol(this) 238237"];
3799 [label="_containingNamespace 238238"];
3800 [label="_nameOpt 238239"];
3801 [label="_cachedLookup 238240"];
3802 [label="_extent 238241"];
3803 [label="_namespacesToMerge 238242"];
3804 [label="_containingNamespace 238243"];
3805 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 238244"];
3806 [label="_cachedLookup = new CachingDictionary<string, Symbol>(SlowGetChildrenOfName, SlowGetChildNames, EqualityComparer<string>.Default); 238245"];
3807 [label="_cachedLookup 238246"];
3808 [label="_nameOpt 238247"];
3809 [label="foreach (NamespaceSymbol ns in namespacesToMerge)\n            {\n                Debug.Assert(ns.ConstituentNamespaces.Length == 1);\n            } 238248"];
3810 [label="ns.ConstituentNamespaces 238249"];
3811 [label="get\n            {\n                return ImmutableArray.Create(this);\n            } 238250"];
3812 [label="return ImmutableArray.Create(this); 238251"];
3813 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 238252"];
3814 [label="Debug.Assert(ns.ConstituentNamespaces.Length == 1); 238253"];
3815 [label="modules.Free(); 238254"];
3816 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 238255"];
3817 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 238256"];
3818 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 238257"];
3819 [label="Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null); 238258"];
3820 [label="return _lazyGlobalNamespace; 238259"];
3821 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 238260"];
3822 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 238261"];
3823 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 238262"];
3824 [label="result = new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing); 238263"];
3825 [label="new InContainerBinder(compilation.GlobalNamespace, result, compilationUnit, inUsing: inUsing) 238264"];
3826 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 238265"];
3827 [label="param InContainerBinder(Binder next) 238266"];
3828 [label="param InContainerBinder(CSharpSyntaxNode declarationSyntax) 238267"];
3829 [label="param InContainerBinder(bool inUsing) 238268"];
3830 [label="param InContainerBinder(this) 238269"];
3831 [label="next 238270"];
3832 [label="param InContainerBinder(this) 238271"];
3833 [label="param Binder(Binder next) 238272"];
3834 [label="param Binder(this) 238273"];
3835 [label="param Binder(Conversions? conversions = null) 238274"];
3836 [label="RoslynDebug.Assert(next != null); 238275"];
3837 [label="RoslynDebug.Assert(next != null); 238276"];
3838 [label="Next 238277"];
3839 [label="this.Flags 238278"];
3840 [label="this.Compilation 238279"];
3841 [label="_lazyConversions 238280"];
3842 [label="_container 238281"];
3843 [label="_computeImports 238282"];
3844 [label="_lazyImports 238283"];
3845 [label="_lazyImportChain 238284"];
3846 [label="_lazyQuickAttributeChecker 238285"];
3847 [label="Debug.Assert((object)container != null); 238286"];
3848 [label="Debug.Assert((object)container != null); 238287"];
3849 [label="Debug.Assert(declarationSyntax != null); 238288"];
3850 [label="Debug.Assert(declarationSyntax != null); 238289"];
3851 [label="_container 238290"];
3852 [label="_computeImports = basesBeingResolved => Imports.FromSyntax(declarationSyntax, this, basesBeingResolved, inUsing); 238291"];
3853 [label="_computeImports 238292"];
3854 [label="if (!inUsing)\n            {\n                if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                }\n            } 238293"];
3855 [label="if (declarationSyntax.Kind() == SyntaxKind.CompilationUnit)\n                {\n                    var compilationUnit = (CompilationUnitSyntax)declarationSyntax;\n                    _usingsSyntax = compilationUnit.Usings;\n                }\n                else if (declarationSyntax.Kind() == SyntaxKind.NamespaceDeclaration)\n                {\n                    var namespaceDecl = (NamespaceDeclarationSyntax)declarationSyntax;\n                    _usingsSyntax = namespaceDecl.Usings;\n                } 238294"];
3856 [label="var compilationUnit = (CompilationUnitSyntax)declarationSyntax; 238295"];
3857 [label="_usingsSyntax 238296"];
3858 [label="compilation 238297"];
3859 [label="get\n                {\n                    return _factory._compilation;\n                } 238298"];
3860 [label="return _factory._compilation; 238299"];
3861 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 238300"];
3862 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 238301"];
3863 [label="if (!inUsing &&\n                            SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) is SynthesizedSimpleProgramEntryPointSymbol simpleProgram)\n                        {\n                            ExecutableCodeBinder bodyBinder = simpleProgram.GetBodyBinder(_factory._ignoreAccessibility);\n                            result = new SimpleProgramUnitBinder(result, (SimpleProgramBinder)bodyBinder.GetBinder(simpleProgram.SyntaxNode));\n                        } 238302"];
3864 [label="SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(compilation, compilationUnit, fallbackToMainEntryPoint: true) 238303"];
3865 [label="param GetSimpleProgramEntryPoint(CSharpCompilation compilation) 238304"];
3866 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 238305"];
3867 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 238306"];
3868 [label="var type = GetSimpleProgramNamedTypeSymbol(compilation); 238307"];
3869 [label="GetSimpleProgramNamedTypeSymbol(compilation) 238308"];
3870 [label="param GetSimpleProgramNamedTypeSymbol(CSharpCompilation compilation) 238309"];
3871 [label="compilation.SourceModule 238310"];
3872 [label="get\n            {\n                return Assembly.Modules[0];\n            } 238311"];
3873 [label="GetBoundReferenceManager(); 238312"];
3874 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 238313"];
3875 [label="compilation.SourceModule.GlobalNamespace 238314"];
3876 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 238315"];
3877 [label="return compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName).OfType<SimpleProgramNamedTypeSymbol>().SingleOrDefault(); 238316"];
3878 [label="compilation.SourceModule.GlobalNamespace.GetTypeMembers(WellKnownMemberNames.TopLevelStatementsEntryPointTypeName) 238317"];
3879 [label="param GetTypeMembers(string name) 238318"];
3880 [label="param GetTypeMembers(this) 238319"];
3881 [label="if (type is null)\n            {\n                return null;\n            } 238320"];
3882 [label="return null; 238321"];
3883 [label="binderCache 238322"];
3884 [label="return _factory._binderCache; 238323"];
3885 [label="binderCache.TryAdd(key, result); 238324"];
3886 [label="binderCache.TryAdd(key, result); 238325"];
3887 [label="binderCache.TryAdd(key, result); 238326"];
3888 [label="binderCache.TryAdd(key, result); 238327"];
3889 [label="binderCache.TryAdd(key, result); 238328"];
3890 [label="return result; 238329"];
3891 [label="return ((CSharpSyntaxNode)node).Accept(this); 238330"];
3892 [label="if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    } 238331"];
3893 [label="resultBinder.ContainingMemberOrLambda 238332"];
3894 [label="get\n            {\n                var merged = _container as MergedNamespaceSymbol;\n                return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container;\n            } 238333"];
3895 [label="var merged = _container as MergedNamespaceSymbol; 238334"];
3896 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 238335"];
3897 [label="return ((object)merged != null) ? merged.GetConstituentForCompilation(this.Compilation) : _container; 238336"];
3898 [label="((object)merged != null) 238337"];
3899 [label="merged.GetConstituentForCompilation(this.Compilation) 238338"];
3900 [label="param GetConstituentForCompilation(CSharpCompilation compilation) 238339"];
3901 [label="param GetConstituentForCompilation(this) 238340"];
3902 [label="foreach (var n in _namespacesToMerge)\n            {\n                if (n.IsFromCompilation(compilation))\n                    return n;\n            } 238341"];
3903 [label="if (n.IsFromCompilation(compilation))\n                    return n; 238342"];
3904 [label="n.IsFromCompilation(compilation) 238343"];
3905 [label="param IsFromCompilation(CSharpCompilation compilation) 238344"];
3906 [label="param IsFromCompilation(this) 238345"];
3907 [label="Debug.Assert(compilation != null); 238346"];
3908 [label="Debug.Assert(compilation != null); 238347"];
3909 [label="this.DeclaringCompilation 238348"];
3910 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 238349"];
3911 [label="this.Kind 238350"];
3912 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 238351"];
3913 [label="return SymbolKind.Namespace; 238352"];
3914 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 238353"];
3915 [label="return compilation == this.DeclaringCompilation; 238354"];
3916 [label="return compilation == this.DeclaringCompilation; 238355"];
3917 [label="return n; 238356"];
3918 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 238357"];
3919 [label="var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent); 238358"];
3920 [label="((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent) 238359"];
3921 [label="param GetSourceTypeMember(TypeDeclarationSyntax syntax) 238360"];
3922 [label="param GetSourceTypeMember(this) 238361"];
3923 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 238362"];
3924 [label="return GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax); 238363"];
3925 [label="GetSourceTypeMember(syntax.Identifier.ValueText, syntax.Arity, syntax.Kind(), syntax) 238364"];
3926 [label="param GetSourceTypeMember(string name) 238365"];
3927 [label="param GetSourceTypeMember(int arity) 238366"];
3928 [label="param GetSourceTypeMember(SyntaxKind kind) 238367"];
3929 [label="param GetSourceTypeMember(CSharpSyntaxNode syntax) 238368"];
3930 [label="param GetSourceTypeMember(this) 238369"];
3931 [label="TypeKind typeKind = kind.ToDeclarationKind().ToTypeKind(); 238370"];
3932 [label="kind.ToDeclarationKind().ToTypeKind() 238371"];
3933 [label="param ToTypeKind(this DeclarationKind kind) 238372"];
3934 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 238373"];
3935 [label="foreach (var member in GetTypeMembers(name, arity))\n            {\n                var memberT = member as SourceNamedTypeSymbol;\n                if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                }\n            } 238374"];
3936 [label="GetTypeMembers(name, arity) 238375"];
3937 [label="param GetTypeMembers(string name) 238376"];
3938 [label="param GetTypeMembers(int arity) 238377"];
3939 [label="param GetTypeMembers(this) 238378"];
3940 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 238379"];
3941 [label="GetTypeMembers(name) 238380"];
3942 [label="param GetTypeMembers(string name) 238381"];
3943 [label="param GetTypeMembers(this) 238382"];
3944 [label="if (_nameToTypeMembersMap == null)\n            {\n                // NOTE: This method depends on MakeNameToMembersMap() on creating a proper \n                // NOTE: type of the array, see comments in MakeNameToMembersMap() for details\n                Interlocked.CompareExchange(ref _nameToTypeMembersMap, GetTypesFromMemberMap(GetNameToMembersMap()), null);\n            } 238383"];
3945 [label="return _nameToTypeMembersMap; 238384"];
3946 [label="return this.GetNameToTypeMembersMap().TryGetValue(name, out members)\n                ? members\n                : ImmutableArray<NamedTypeSymbol>.Empty; 238385"];
3947 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 238386"];
3948 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 238387"];
3949 [label="return GetTypeMembers(name).WhereAsArray((s, arity) => s.Arity == arity, arity); 238388"];
3950 [label="get\n            {\n                return declaration.Arity;\n            } 238389"];
3951 [label="return declaration.Arity; 238390"];
3952 [label="var memberT = member as SourceNamedTypeSymbol; 238391"];
3953 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 238392"];
3954 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 238393"];
3955 [label="memberT.TypeKind 238394"];
3956 [label="get\n            {\n                return _flags.TypeKind;\n            } 238395"];
3957 [label="_flags.TypeKind 238396"];
3958 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 238397"];
3959 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 238398"];
3960 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 238399"];
3961 [label="return _flags.TypeKind; 238400"];
3962 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 238401"];
3963 [label="if ((object?)memberT != null && memberT.TypeKind == typeKind)\n                {\n                    if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    }\n                } 238402"];
3964 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 238403"];
3965 [label="if (syntax != null)\n                    {\n                        foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        return memberT;\n                    } 238404"];
3966 [label="memberT.Locations 238405"];
3967 [label="foreach (var loc in memberT.Locations)\n                        {\n                            if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            }\n                        } 238406"];
3968 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 238407"];
3969 [label="if (loc.IsInSource && loc.SourceTree == syntax.SyntaxTree && syntax.Span.Contains(loc.SourceSpan))\n                            {\n                                return memberT;\n                            } 238408"];
3970 [label="return memberT; 238409"];
3971 [label="if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        } 238410"];
3972 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 238411"];
3973 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 238412"];
3974 [label="resultBinder = new InContainerBinder(typeSymbol, resultBinder); 238413"];
3975 [label="new InContainerBinder(typeSymbol, resultBinder) 238414"];
3976 [label="param InContainerBinder(NamespaceOrTypeSymbol container) 238415"];
3977 [label="param InContainerBinder(Binder next) 238416"];
3978 [label="param InContainerBinder(Imports imports = null) 238417"];
3979 [label="param InContainerBinder(this) 238418"];
3980 [label="next 238419"];
3981 [label="param InContainerBinder(this) 238420"];
3982 [label="param Binder(Binder next) 238421"];
3983 [label="param Binder(this) 238422"];
3984 [label="param Binder(Conversions? conversions = null) 238423"];
3985 [label="RoslynDebug.Assert(next != null); 238424"];
3986 [label="RoslynDebug.Assert(next != null); 238425"];
3987 [label="this.Flags 238426"];
3988 [label="this.Compilation 238427"];
3989 [label="_lazyConversions 238428"];
3990 [label="_container 238429"];
3991 [label="_computeImports 238430"];
3992 [label="_lazyImports 238431"];
3993 [label="_lazyImportChain 238432"];
3994 [label="_lazyQuickAttributeChecker 238433"];
3995 [label="Debug.Assert((object)container != null || imports != null); 238434"];
3996 [label="Debug.Assert((object)container != null || imports != null); 238435"];
3997 [label="_container 238436"];
3998 [label="null 238437"];
3999 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 238438"];
4000 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 238439"];
4001 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 238440"];
4002 [label="null 238441"];
4003 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 238442"];
4004 [label="param Imports(CSharpCompilation compilation) 238443"];
4005 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 238444"];
4006 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 238445"];
4007 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 238446"];
4008 [label="param Imports(DiagnosticBag diagnostics) 238447"];
4009 [label="param Imports(this) 238448"];
4010 [label="_compilation 238449"];
4011 [label="_diagnostics 238450"];
4012 [label="UsingAliases 238451"];
4013 [label="Debug.Assert(usingAliases != null); 238452"];
4014 [label="Debug.Assert(usingAliases != null); 238453"];
4015 [label="Debug.Assert(!usings.IsDefault); 238454"];
4016 [label="Debug.Assert(!externs.IsDefault); 238455"];
4017 [label="_compilation 238456"];
4018 [label="this.UsingAliases 238457"];
4019 [label="this.Usings 238458"];
4020 [label="_diagnostics 238459"];
4021 [label="this.ExternAliases 238460"];
4022 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 238461"];
4023 [label="_lazyImports = imports ?? Imports.Empty; 238462"];
4024 [label="_lazyImports = imports ?? Imports.Empty; 238463"];
4025 [label="_lazyImports 238464"];
4026 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 238465"];
4027 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 238466"];
4028 [label="resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers); 238467"];
4029 [label="resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers) 238468"];
4030 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 238469"];
4031 [label="param WithUnsafeRegionIfNecessary(this) 238470"];
4032 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 238471"];
4033 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 238472"];
4034 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 238473"];
4035 [label="param Includes(this BinderFlags self) 238474"];
4036 [label="param Includes(BinderFlags other) 238475"];
4037 [label="return (self & other) == other; 238476"];
4038 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 238477"];
4039 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 238478"];
4040 [label="(this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword)) 238479"];
4041 [label="binderCache 238480"];
4042 [label="return _factory._binderCache; 238481"];
4043 [label="binderCache.TryAdd(key, resultBinder); 238482"];
4044 [label="binderCache.TryAdd(key, resultBinder); 238483"];
4045 [label="binderCache.TryAdd(key, resultBinder); 238484"];
4046 [label="binderCache.TryAdd(key, resultBinder); 238485"];
4047 [label="binderCache.TryAdd(key, resultBinder); 238486"];
4048 [label="return resultBinder; 238487"];
4049 [label="return ((CSharpSyntaxNode)node).Accept(this); 238488"];
4050 [label="_binderFactoryVisitorPool.Free(visitor); 238489"];
4051 [label="_binderFactoryVisitorPool.Free(visitor); 238490"];
4052 [label="return result; 238491"];
4053 [label="ArrayBuilder<FieldOrPropertyInitializer>? staticInitializers = null; 238492"];
4054 [label="DeclaringCompilation 238493"];
4055 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 238494"];
4056 [label="this.Kind 238495"];
4057 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 238496"];
4058 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 238497"];
4059 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 238498"];
4060 [label="this.ContainingSymbol 238499"];
4061 [label="get\n            {\n                return _containingSymbol;\n            } 238500"];
4062 [label="return _containingSymbol; 238501"];
4063 [label="return (object)container != null ? container.ContainingModule : null; 238502"];
4064 [label="var compilation = DeclaringCompilation; 238503"];
4065 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 238504"];
4066 [label="foreach (var m in members)\n            {\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                bool reportMisplacedGlobalCode = !m.HasErrors;\n\n                switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                }\n            } 238505"];
4067 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 238506"];
4068 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 238507"];
4069 [label="switch (m.Kind())\n                {\n                    case SyntaxKind.FieldDeclaration:\n                        {\n                            var fieldSyntax = (FieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            bool modifierErrors;\n                            var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors);\n                            foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.MethodDeclaration:\n                        {\n                            var methodSyntax = (MethodDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(methodSyntax.Identifier));\n                            }\n\n                            var method = SourceOrdinaryMethodSymbol.CreateMethodSymbol(this, bodyBinder, methodSyntax, compilation.IsNullableAnalysisEnabledIn(methodSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.ConstructorDeclaration:\n                        {\n                            var constructorSyntax = (ConstructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(constructorSyntax.Identifier));\n                            }\n\n                            bool isNullableEnabled = compilation.IsNullableAnalysisEnabledIn(constructorSyntax);\n                            var constructor = SourceConstructorSymbol.CreateConstructorSymbol(this, constructorSyntax, isNullableEnabled, diagnostics);\n                            builder.NonTypeMembers.Add(constructor);\n                            if (constructorSyntax.Initializer?.Kind() != SyntaxKind.ThisConstructorInitializer)\n                            {\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: constructor.IsStatic, isNullableEnabled);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.DestructorDeclaration:\n                        {\n                            var destructorSyntax = (DestructorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(destructorSyntax.Identifier));\n                            }\n\n                            // CONSIDER: if this doesn't (directly or indirectly) override object.Finalize, the\n                            // runtime won't consider it a finalizer and it will not be marked as a destructor\n                            // when it is loaded from metadata.  Perhaps we should just treat it as an Ordinary\n                            // method in such cases?\n                            var destructor = new SourceDestructorSymbol(this, destructorSyntax, compilation.IsNullableAnalysisEnabledIn(destructorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(destructor);\n                        }\n                        break;\n\n                    case SyntaxKind.PropertyDeclaration:\n                        {\n                            var propertySyntax = (PropertyDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(propertySyntax.Identifier));\n                            }\n\n                            var property = SourcePropertySymbol.Create(this, bodyBinder, propertySyntax, diagnostics);\n                            builder.NonTypeMembers.Add(property);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, property.SetMethod);\n                            FieldSymbol backingField = property.BackingField;\n\n                            // TODO: can we leave this out of the member list?\n                            // From the 10/12/11 design notes:\n                            //   In addition, we will change autoproperties to behavior in\n                            //   a similar manner and make the autoproperty fields private.\n                            if ((object)backingField != null)\n                            {\n                                builder.NonTypeMembers.Add(backingField);\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: backingField.IsStatic, compilation, propertySyntax);\n\n                                var initializer = propertySyntax.Initializer;\n                                if (initializer != null)\n                                {\n                                    if (IsScriptClass)\n                                    {\n                                        // also gather expression-declared variables from the initializer\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                                                      initializer,\n                                                                                      this,\n                                                                                      DeclarationModifiers.Private | (property.IsStatic ? DeclarationModifiers.Static : 0),\n                                                                                      backingField);\n                                    }\n\n                                    if (property.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, backingField, initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, backingField, initializer);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventFieldDeclaration:\n                        {\n                            var eventFieldSyntax = (EventFieldDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(\n                                    ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventFieldSyntax.Declaration.Variables.First().Identifier));\n                            }\n\n                            foreach (VariableDeclaratorSyntax declarator in eventFieldSyntax.Declaration.Variables)\n                            {\n                                SourceFieldLikeEventSymbol @event = new SourceFieldLikeEventSymbol(this, bodyBinder, eventFieldSyntax.Modifiers, declarator, diagnostics);\n                                builder.NonTypeMembers.Add(@event);\n\n                                FieldSymbol? associatedField = @event.AssociatedField;\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, declarator, this,\n                                                            DeclarationModifiers.Private | (@event.IsStatic ? DeclarationModifiers.Static : 0),\n                                                            associatedField);\n                                }\n\n                                if ((object?)associatedField != null)\n                                {\n                                    // NOTE: specifically don't add the associated field to the members list\n                                    // (regard it as an implementation detail).\n\n                                    builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: associatedField.IsStatic, compilation, declarator);\n\n                                    if (declarator.Initializer != null)\n                                    {\n                                        if (associatedField.IsStatic)\n                                        {\n                                            AddInitializer(ref staticInitializers, associatedField, declarator.Initializer);\n                                        }\n                                        else\n                                        {\n                                            AddInitializer(ref instanceInitializers, associatedField, declarator.Initializer);\n                                        }\n                                    }\n                                }\n\n                                Debug.Assert((object)@event.AddMethod != null);\n                                Debug.Assert((object)@event.RemoveMethod != null);\n\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                                AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n                            }\n                        }\n                        break;\n\n                    case SyntaxKind.EventDeclaration:\n                        {\n                            var eventSyntax = (EventDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(eventSyntax.Identifier));\n                            }\n\n                            var @event = new SourceCustomEventSymbol(this, bodyBinder, eventSyntax, diagnostics);\n\n                            builder.NonTypeMembers.Add(@event);\n\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.AddMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, @event.RemoveMethod);\n\n                            Debug.Assert(@event.AssociatedField is null);\n                        }\n                        break;\n\n                    case SyntaxKind.IndexerDeclaration:\n                        {\n                            var indexerSyntax = (IndexerDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(indexerSyntax.ThisKeyword));\n                            }\n\n                            var indexer = SourcePropertySymbol.Create(this, bodyBinder, indexerSyntax, diagnostics);\n                            builder.HaveIndexers = true;\n                            builder.NonTypeMembers.Add(indexer);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.GetMethod);\n                            AddAccessorIfAvailable(builder.NonTypeMembers, indexer.SetMethod);\n                        }\n                        break;\n\n                    case SyntaxKind.ConversionOperatorDeclaration:\n                        {\n                            var conversionOperatorSyntax = (ConversionOperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(conversionOperatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedConversionSymbol.CreateUserDefinedConversionSymbol(\n                                this, conversionOperatorSyntax, compilation.IsNullableAnalysisEnabledIn(conversionOperatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.OperatorDeclaration:\n                        {\n                            var operatorSyntax = (OperatorDeclarationSyntax)m;\n                            if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(operatorSyntax.OperatorKeyword));\n                            }\n\n                            var method = SourceUserDefinedOperatorSymbol.CreateUserDefinedOperatorSymbol(\n                                this, operatorSyntax, compilation.IsNullableAnalysisEnabledIn(operatorSyntax), diagnostics);\n                            builder.NonTypeMembers.Add(method);\n                        }\n                        break;\n\n                    case SyntaxKind.GlobalStatement:\n                        {\n                            var globalStatement = ((GlobalStatementSyntax)m).Statement;\n\n                            if (IsScriptClass)\n                            {\n                                var innerStatement = globalStatement;\n\n                                // drill into any LabeledStatements\n                                while (innerStatement.Kind() == SyntaxKind.LabeledStatement)\n                                {\n                                    innerStatement = ((LabeledStatementSyntax)innerStatement).Statement;\n                                }\n\n                                switch (innerStatement.Kind())\n                                {\n                                    case SyntaxKind.LocalDeclarationStatement:\n                                        // We shouldn't reach this place, but field declarations preceded with a label end up here.\n                                        // This is tracked by https://github.com/dotnet/roslyn/issues/13712. Let's do our best for now.\n                                        var decl = (LocalDeclarationStatementSyntax)innerStatement;\n                                        foreach (var vdecl in decl.Declaration.Variables)\n                                        {\n                                            // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                            ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, vdecl, this, DeclarationModifiers.Private,\n                                                                                          containingFieldOpt: null);\n                                        }\n                                        break;\n\n                                    case SyntaxKind.ExpressionStatement:\n                                    case SyntaxKind.IfStatement:\n                                    case SyntaxKind.YieldReturnStatement:\n                                    case SyntaxKind.ReturnStatement:\n                                    case SyntaxKind.ThrowStatement:\n                                    case SyntaxKind.SwitchStatement:\n                                    case SyntaxKind.LockStatement:\n                                        ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers,\n                                                  innerStatement,\n                                                  this,\n                                                  DeclarationModifiers.Private,\n                                                  containingFieldOpt: null);\n                                        break;\n\n                                    default:\n                                        // no other statement introduces variables into the enclosing scope\n                                        break;\n                                }\n\n                                AddInitializer(ref instanceInitializers, null, globalStatement);\n                            }\n                            else if (reportMisplacedGlobalCode && !SyntaxFacts.IsSimpleProgramTopLevelStatement((GlobalStatementSyntax)m))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_GlobalStatement, new SourceLocation(globalStatement));\n                            }\n                        }\n                        break;\n\n                    default:\n                        Debug.Assert(\n                            SyntaxFacts.IsTypeDeclaration(m.Kind()) ||\n                            m.Kind() == SyntaxKind.NamespaceDeclaration ||\n                            m.Kind() == SyntaxKind.IncompleteMember);\n                        break;\n                } 238508"];
4070 [label="var fieldSyntax = (FieldDeclarationSyntax)m; 238509"];
4071 [label="IsImplicitClass 238510"];
4072 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass;\n            } 238511"];
4073 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 238512"];
4074 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.ImplicitClass; 238513"];
4075 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 238514"];
4076 [label="bool modifierErrors; 238515"];
4077 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238516"];
4078 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238517"];
4079 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238518"];
4080 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238519"];
4081 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238520"];
4082 [label="SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors) 238521"];
4083 [label="param MakeModifiers(NamedTypeSymbol containingType) 238522"];
4084 [label="param MakeModifiers(SyntaxToken firstIdentifier) 238523"];
4085 [label="param MakeModifiers(SyntaxTokenList modifiers) 238524"];
4086 [label="param MakeModifiers(DiagnosticBag diagnostics) 238525"];
4087 [label="param MakeModifiers(out bool modifierErrors) 238526"];
4088 [label="containingType.IsInterface 238527"];
4089 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 238528"];
4090 [label="this.TypeKind 238529"];
4091 [label="get\n            {\n                return _flags.TypeKind;\n            } 238530"];
4092 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 238531"];
4093 [label="return this.TypeKind == TypeKind.Interface; 238532"];
4094 [label="DeclarationModifiers defaultAccess =\n                (containingType.IsInterface) ? DeclarationModifiers.Public : DeclarationModifiers.Private; 238533"];
4095 [label="(containingType.IsInterface) 238534"];
4096 [label="DeclarationModifiers allowedModifiers =\n                DeclarationModifiers.AccessibilityMask |\n                DeclarationModifiers.Const |\n                DeclarationModifiers.New |\n                DeclarationModifiers.ReadOnly |\n                DeclarationModifiers.Static |\n                DeclarationModifiers.Volatile |\n                DeclarationModifiers.Fixed |\n                DeclarationModifiers.Unsafe |\n                DeclarationModifiers.Abstract; 238535"];
4097 [label="var errorLocation = new SourceLocation(firstIdentifier); 238536"];
4098 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238537"];
4099 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238538"];
4100 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238539"];
4101 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238540"];
4102 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238541"];
4103 [label="DeclarationModifiers result = ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors); 238542"];
4104 [label="ModifierUtils.MakeAndCheckNontypeMemberModifiers(\n                modifiers, defaultAccess, allowedModifiers, errorLocation, diagnostics, out modifierErrors) 238543"];
4105 [label="param MakeAndCheckNontypeMemberModifiers(SyntaxTokenList modifiers) 238544"];
4106 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers defaultAccess) 238545"];
4107 [label="param MakeAndCheckNontypeMemberModifiers(DeclarationModifiers allowedModifiers) 238546"];
4108 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 238547"];
4109 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 238548"];
4110 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 238549"];
4111 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 238550"];
4112 [label="var result = modifiers.ToDeclarationModifiers(diagnostics); 238551"];
4113 [label="modifiers.ToDeclarationModifiers(diagnostics) 238552"];
4114 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 238553"];
4115 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 238554"];
4116 [label="bool seenNoDuplicates = true; 238555"];
4117 [label="bool seenNoAccessibilityDuplicates = true; 238556"];
4118 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 238557"];
4119 [label="return DeclarationModifiers.Static; 238558"];
4120 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238559"];
4121 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238560"];
4122 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238561"];
4123 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238562"];
4124 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238563"];
4125 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238564"];
4126 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 238565"];
4127 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 238566"];
4128 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 238567"];
4129 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 238568"];
4130 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 238569"];
4131 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 238570"];
4132 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 238571"];
4133 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 238572"];
4134 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 238573"];
4135 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 238574"];
4136 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238575"];
4137 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238576"];
4138 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238577"];
4139 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238578"];
4140 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238579"];
4141 [label="result = CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors); 238580"];
4142 [label="CheckModifiers(result, allowedModifiers, errorLocation, diagnostics, modifiers, out modifierErrors) 238581"];
4143 [label="param CheckModifiers(DeclarationModifiers modifiers) 238582"];
4144 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 238583"];
4145 [label="param CheckModifiers(Location errorLocation) 238584"];
4146 [label="param CheckModifiers(DiagnosticBag diagnostics) 238585"];
4147 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 238586"];
4148 [label="param CheckModifiers(out bool modifierErrors) 238587"];
4149 [label="modifierErrors = false; 238588"];
4150 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 238589"];
4151 [label="DeclarationModifiers result = modifiers & allowedModifiers; 238590"];
4152 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 238591"];
4153 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 238592"];
4154 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 238593"];
4155 [label="return result; 238594"];
4156 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 238595"];
4157 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 238596"];
4158 [label="result |= defaultAccess; 238597"];
4159 [label="return result; 238598"];
4160 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 238599"];
4161 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 238600"];
4162 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 238601"];
4163 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 238602"];
4164 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 238603"];
4165 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 238604"];
4166 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238605"];
4167 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238606"];
4168 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238607"];
4169 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238608"];
4170 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 238609"];
4171 [label="param CheckUnsafeModifier(this Symbol symbol) 238610"];
4172 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 238611"];
4173 [label="param CheckUnsafeModifier(Location errorLocation) 238612"];
4174 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 238613"];
4175 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 238614"];
4176 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238615"];
4177 [label="return result; 238616"];
4178 [label="foreach (var variable in fieldSyntax.Declaration.Variables)\n                            {\n                                var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics);\n                                builder.NonTypeMembers.Add(fieldSymbol);\n                                // All fields are included in the nullable context for constructors and initializers, even fields without\n                                // initializers, to ensure warnings are reported for uninitialized non-nullable fields in NullableWalker.\n                                builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable);\n\n                                if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                }\n\n                                if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                }\n                            } 238617"];
4179 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238618"];
4180 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238619"];
4181 [label="(modifiers & DeclarationModifiers.Fixed) == 0 238620"];
4182 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238621"];
4183 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238622"];
4184 [label="new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics) 238623"];
4185 [label="param SourceMemberFieldSymbolFromDeclarator(SourceMemberContainerTypeSymbol containingType) 238624"];
4186 [label="param SourceMemberFieldSymbolFromDeclarator(VariableDeclaratorSyntax declarator) 238625"];
4187 [label="param SourceMemberFieldSymbolFromDeclarator(DeclarationModifiers modifiers) 238626"];
4188 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 238627"];
4189 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 238628"];
4190 [label="param SourceMemberFieldSymbolFromDeclarator(this) 238629"];
4191 [label="containingType 238630"];
4192 [label="modifiers 238631"];
4193 [label="declarator.Identifier.ValueText 238632"];
4194 [label="declarator.GetReference() 238633"];
4195 [label="declarator.Identifier 238634"];
4196 [label="declarator.Identifier 238635"];
4197 [label="param SourceMemberFieldSymbol(SourceMemberContainerTypeSymbol containingType) 238636"];
4198 [label="param SourceMemberFieldSymbol(DeclarationModifiers modifiers) 238637"];
4199 [label="param SourceMemberFieldSymbol(string name) 238638"];
4200 [label="param SourceMemberFieldSymbol(SyntaxReference syntax) 238639"];
4201 [label="param SourceMemberFieldSymbol(Location location) 238640"];
4202 [label="param SourceMemberFieldSymbol(this) 238641"];
4203 [label="containingType 238642"];
4204 [label="name 238643"];
4205 [label="syntax 238644"];
4206 [label="location 238645"];
4207 [label="param SourceMemberFieldSymbol(this) 238646"];
4208 [label="param SourceFieldSymbolWithSyntaxReference(SourceMemberContainerTypeSymbol containingType) 238647"];
4209 [label="param SourceFieldSymbolWithSyntaxReference(string name) 238648"];
4210 [label="param SourceFieldSymbolWithSyntaxReference(SyntaxReference syntax) 238649"];
4211 [label="param SourceFieldSymbolWithSyntaxReference(Location location) 238650"];
4212 [label="param SourceFieldSymbolWithSyntaxReference(this) 238651"];
4213 [label="containingType 238652"];
4214 [label="param SourceFieldSymbolWithSyntaxReference(this) 238653"];
4215 [label="param SourceFieldSymbol(SourceMemberContainerTypeSymbol containingType) 238654"];
4216 [label="param SourceFieldSymbol(this) 238655"];
4217 [label="param SourceFieldSymbol(this) 238656"];
4218 [label="param FieldSymbolWithAttributesAndModifiers(this) 238657"];
4219 [label="param FieldSymbolWithAttributesAndModifiers(this) 238658"];
4220 [label="param FieldSymbol(this) 238659"];
4221 [label="param FieldSymbol(this) 238660"];
4222 [label="_lazyAdapter 238661"];
4223 [label="_lazyCustomAttributesBag 238662"];
4224 [label="containingType 238663"];
4225 [label="Debug.Assert((object)containingType != null); 238664"];
4226 [label="Debug.Assert((object)containingType != null); 238665"];
4227 [label="this.containingType 238666"];
4228 [label="_name 238667"];
4229 [label="_location 238668"];
4230 [label="_syntaxReference 238669"];
4231 [label="_lazyDocComment 238670"];
4232 [label="_lazyExpandedDocComment 238671"];
4233 [label="_lazyConstantEarlyDecodingValue = Microsoft.CodeAnalysis.ConstantValue.Unset 238672"];
4234 [label="_lazyConstantValue = Microsoft.CodeAnalysis.ConstantValue.Unset 238673"];
4235 [label="Debug.Assert(name != null); 238674"];
4236 [label="Debug.Assert(name != null); 238675"];
4237 [label="Debug.Assert(syntax != null); 238676"];
4238 [label="Debug.Assert(syntax != null); 238677"];
4239 [label="Debug.Assert(location != null); 238678"];
4240 [label="Debug.Assert(location != null); 238679"];
4241 [label="_name 238680"];
4242 [label="_syntaxReference 238681"];
4243 [label="_location 238682"];
4244 [label="_modifiers 238683"];
4245 [label="_modifiers 238684"];
4246 [label="declarator.Identifier 238685"];
4247 [label="declarator.Identifier.GetLocation() 238686"];
4248 [label="param SourceMemberFieldSymbolFromDeclarator(this) 238687"];
4249 [label="param SourceMemberFieldSymbolFromDeclarator(this) 238688"];
4250 [label="_hasInitializer 238689"];
4251 [label="_lazyType 238690"];
4252 [label="_lazyFieldTypeInferred 238691"];
4253 [label="_hasInitializer = declarator.Initializer != null; 238692"];
4254 [label="_hasInitializer = declarator.Initializer != null; 238693"];
4255 [label="_hasInitializer 238694"];
4256 [label="this.CheckAccessibility(diagnostics); 238695"];
4257 [label="this.CheckAccessibility(diagnostics) 238696"];
4258 [label="param CheckAccessibility(DiagnosticBag diagnostics) 238697"];
4259 [label="param CheckAccessibility(this) 238698"];
4260 [label="Modifiers 238699"];
4261 [label="get\n            {\n                return _modifiers;\n            } 238700"];
4262 [label="return _modifiers; 238701"];
4263 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238702"];
4264 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238703"];
4265 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238704"];
4266 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 238705"];
4267 [label="param CheckAccessibility(DeclarationModifiers modifiers) 238706"];
4268 [label="param CheckAccessibility(Symbol symbol) 238707"];
4269 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 238708"];
4270 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 238709"];
4271 [label="IsValidAccessibility(modifiers) 238710"];
4272 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 238711"];
4273 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 238712"];
4274 [label="return true; 238713"];
4275 [label="symbol.Kind 238714"];
4276 [label="get\n            {\n                return SymbolKind.Field;\n            } 238715"];
4277 [label="return SymbolKind.Field; 238716"];
4278 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238717"];
4279 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238718"];
4280 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238719"];
4281 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238720"];
4282 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238721"];
4283 [label="return null; 238722"];
4284 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238723"];
4285 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 238724"];
4286 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 238725"];
4287 [label="this.CheckAccessibility(diagnostics); 238726"];
4288 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 238727"];
4289 [label="this.ReportModifiersDiagnostics(diagnostics); 238728"];
4290 [label="this.ReportModifiersDiagnostics(diagnostics) 238729"];
4291 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 238730"];
4292 [label="param ReportModifiersDiagnostics(this) 238731"];
4293 [label="ContainingType 238732"];
4294 [label="get\n            {\n                return this.containingType;\n            } 238733"];
4295 [label="return this.containingType; 238734"];
4296 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238735"];
4297 [label="ContainingType.IsSealed 238736"];
4298 [label="=> HasFlag(DeclarationModifiers.Sealed) 238737"];
4299 [label="DeclarationModifiers.Sealed 238738"];
4300 [label="HasFlag(DeclarationModifiers.Sealed) 238739"];
4301 [label="param HasFlag(DeclarationModifiers flag) 238740"];
4302 [label="=> (_declModifiers & flag) != 0 238741"];
4303 [label="_declModifiers & flag 238742"];
4304 [label="0 238743"];
4305 [label="(_declModifiers & flag) != 0 238744"];
4306 [label="IsVolatile 238745"];
4307 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 238746"];
4308 [label="Modifiers 238747"];
4309 [label="get\n            {\n                return _modifiers;\n            } 238748"];
4310 [label="return _modifiers; 238749"];
4311 [label="Modifiers & DeclarationModifiers.Volatile 238750"];
4312 [label="0 238751"];
4313 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 238752"];
4314 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238753"];
4315 [label="containingType.IsStatic 238754"];
4316 [label="=> HasFlag(DeclarationModifiers.Static) 238755"];
4317 [label="DeclarationModifiers.Static 238756"];
4318 [label="HasFlag(DeclarationModifiers.Static) 238757"];
4319 [label="param HasFlag(DeclarationModifiers flag) 238758"];
4320 [label="=> (_declModifiers & flag) != 0 238759"];
4321 [label="_declModifiers & flag 238760"];
4322 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238761"];
4323 [label="IsStatic 238762"];
4324 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 238763"];
4325 [label="Modifiers 238764"];
4326 [label="get\n            {\n                return _modifiers;\n            } 238765"];
4327 [label="Modifiers & DeclarationModifiers.Static 238766"];
4328 [label="0 238767"];
4329 [label="(Modifiers & DeclarationModifiers.Static) != 0 238768"];
4330 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238769"];
4331 [label="this.ReportModifiersDiagnostics(diagnostics); 238770"];
4332 [label="containingType.IsInterface 238771"];
4333 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 238772"];
4334 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 238773"];
4335 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 238774"];
4336 [label="builder.NonTypeMembers.Add(fieldSymbol); 238775"];
4337 [label="builder.NonTypeMembers.Add(fieldSymbol); 238776"];
4338 [label="fieldSymbol.IsStatic 238777"];
4339 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 238778"];
4340 [label="Modifiers 238779"];
4341 [label="get\n            {\n                return _modifiers;\n            } 238780"];
4342 [label="return _modifiers; 238781"];
4343 [label="Modifiers & DeclarationModifiers.Static 238782"];
4344 [label="0 238783"];
4345 [label="(Modifiers & DeclarationModifiers.Static) != 0 238784"];
4346 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 238785"];
4347 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 238786"];
4348 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable); 238787"];
4349 [label="builder.UpdateIsNullableEnabledForConstructorsAndFields(useStatic: fieldSymbol.IsStatic, compilation, variable) 238788"];
4350 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 238789"];
4351 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpCompilation compilation) 238790"];
4352 [label="param UpdateIsNullableEnabledForConstructorsAndFields(CSharpSyntaxNode syntax) 238791"];
4353 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 238792"];
4354 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 238793"];
4355 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 238794"];
4356 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 238795"];
4357 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 238796"];
4358 [label="useStatic 238797"];
4359 [label="IsNullableEnabledForStaticConstructorsAndFields 238798"];
4360 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 238799"];
4361 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 238800"];
4362 [label="compilation.IsNullableAnalysisEnabledIn(syntax) 238801"];
4363 [label="param IsNullableAnalysisEnabledIn(SyntaxNode syntax) 238802"];
4364 [label="param IsNullableAnalysisEnabledIn(this) 238803"];
4365 [label="return IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span); 238804"];
4366 [label="IsNullableAnalysisEnabledIn((CSharpSyntaxTree)syntax.SyntaxTree, syntax.Span) 238805"];
4367 [label="param IsNullableAnalysisEnabledIn(CSharpSyntaxTree tree) 238806"];
4368 [label="param IsNullableAnalysisEnabledIn(TextSpan span) 238807"];
4369 [label="param IsNullableAnalysisEnabledIn(this) 238808"];
4370 [label="GetNullableAnalysisValue() 238809"];
4371 [label="param GetNullableAnalysisValue(this) 238810"];
4372 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 238811"];
4373 [label="return Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            }; 238812"];
4374 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 238813"];
4375 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 238814"];
4376 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 238815"];
4377 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 238816"];
4378 [label="Options 238817"];
4379 [label="get\n            {\n                return _options;\n            } 238818"];
4380 [label="return _options; 238819"];
4381 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 238820"];
4382 [label="return GetNullableAnalysisValue() ??\n                tree.IsNullableAnalysisEnabled(span) ??\n                (Options.NullableContextOptions & NullableContextOptions.Warnings) != 0; 238821"];
4383 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 238822"];
4384 [label="IsScriptClass 238823"];
4385 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 238824"];
4386 [label="var kind = this.declaration.Declarations[0].Kind; 238825"];
4387 [label="var kind = this.declaration.Declarations[0].Kind; 238826"];
4388 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 238827"];
4389 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 238828"];
4390 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 238829"];
4391 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 238830"];
4392 [label="if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                } 238831"];
4393 [label="bool reportMisplacedGlobalCode = !m.HasErrors; 238832"];
4394 [label="if (IsImplicitClass && reportMisplacedGlobalCode)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_NamespaceUnexpected,\n                                    new SourceLocation(fieldSyntax.Declaration.Variables.First().Identifier));\n                            } 238833"];
4395 [label="bool modifierErrors; 238834"];
4396 [label="var modifiers = SourceMemberFieldSymbol.MakeModifiers(this, fieldSyntax.Declaration.Variables[0].Identifier, fieldSyntax.Modifiers, diagnostics, out modifierErrors); 238835"];
4397 [label="param MakeModifiers(DiagnosticBag diagnostics) 238836"];
4398 [label="param MakeModifiers(out bool modifierErrors) 238837"];
4399 [label="param MakeAndCheckNontypeMemberModifiers(Location errorLocation) 238838"];
4400 [label="param MakeAndCheckNontypeMemberModifiers(DiagnosticBag diagnostics) 238839"];
4401 [label="param MakeAndCheckNontypeMemberModifiers(out bool modifierErrors) 238840"];
4402 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 238841"];
4403 [label="bool seenNoDuplicates = true; 238842"];
4404 [label="bool seenNoAccessibilityDuplicates = true; 238843"];
4405 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238844"];
4406 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238845"];
4407 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238846"];
4408 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 238847"];
4409 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 238848"];
4410 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 238849"];
4411 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 238850"];
4412 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 238851"];
4413 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 238852"];
4414 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 238853"];
4415 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 238854"];
4416 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 238855"];
4417 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 238856"];
4418 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 238857"];
4419 [label="param CheckModifiers(Location errorLocation) 238858"];
4420 [label="param CheckModifiers(DiagnosticBag diagnostics) 238859"];
4421 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 238860"];
4422 [label="param CheckModifiers(out bool modifierErrors) 238861"];
4423 [label="modifierErrors = false; 238862"];
4424 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 238863"];
4425 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 238864"];
4426 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 238865"];
4427 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 238866"];
4428 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 238867"];
4429 [label="if ((result & DeclarationModifiers.Abstract) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractField, errorLocation);\n                result &= ~DeclarationModifiers.Abstract;\n            } 238868"];
4430 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 238869"];
4431 [label="if ((result & DeclarationModifiers.Fixed) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The modifier 'static' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.StaticKeyword));\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Const) != 0)\n                {\n                    // The modifier 'const' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ConstKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                result &= ~(DeclarationModifiers.Static | DeclarationModifiers.ReadOnly | DeclarationModifiers.Const | DeclarationModifiers.Volatile);\n                Debug.Assert((result & ~(DeclarationModifiers.AccessibilityMask | DeclarationModifiers.Fixed | DeclarationModifiers.Unsafe | DeclarationModifiers.New)) == 0);\n            } 238870"];
4432 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 238871"];
4433 [label="if ((result & DeclarationModifiers.Const) != 0)\n            {\n                if ((result & DeclarationModifiers.Static) != 0)\n                {\n                    // The constant '{0}' cannot be marked static\n                    diagnostics.Add(ErrorCode.ERR_StaticConstant, errorLocation, firstIdentifier.ValueText);\n                }\n\n                if ((result & DeclarationModifiers.ReadOnly) != 0)\n                {\n                    // The modifier 'readonly' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.ReadOnlyKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Volatile) != 0)\n                {\n                    // The modifier 'volatile' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.VolatileKeyword));\n                }\n\n                if ((result & DeclarationModifiers.Unsafe) != 0)\n                {\n                    // The modifier 'unsafe' is not valid for this item\n                    diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, SyntaxFacts.GetText(SyntaxKind.UnsafeKeyword));\n                }\n\n                result |= DeclarationModifiers.Static; // 'constants are considered static members'\n            }\n            else\n            {\n                // NOTE: always cascading on a const, so suppress.\n                // NOTE: we're being a bit sneaky here - we're using the containingType rather than this symbol\n                // to determine whether or not unsafe is allowed.  Since this symbol and the containing type are\n                // in the same compilation, it won't make a difference.  We do, however, have to pass the error\n                // location explicitly.\n                containingType.CheckUnsafeModifier(result, errorLocation, diagnostics);\n            } 238872"];
4434 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238873"];
4435 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238874"];
4436 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238875"];
4437 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics) 238876"];
4438 [label="param CheckUnsafeModifier(this Symbol symbol) 238877"];
4439 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 238878"];
4440 [label="param CheckUnsafeModifier(Location errorLocation) 238879"];
4441 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 238880"];
4442 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 238881"];
4443 [label="containingType.CheckUnsafeModifier(result, errorLocation, diagnostics); 238882"];
4444 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238883"];
4445 [label="var fieldSymbol = (modifiers & DeclarationModifiers.Fixed) == 0\n                                    ? new SourceMemberFieldSymbolFromDeclarator(this, variable, modifiers, modifierErrors, diagnostics)\n                                    : new SourceFixedFieldSymbol(this, variable, modifiers, modifierErrors, diagnostics); 238884"];
4446 [label="param SourceMemberFieldSymbolFromDeclarator(bool modifierErrors) 238885"];
4447 [label="param SourceMemberFieldSymbolFromDeclarator(DiagnosticBag diagnostics) 238886"];
4448 [label="containingType 238887"];
4449 [label="Debug.Assert((object)containingType != null); 238888"];
4450 [label="_name 238889"];
4451 [label="_location 238890"];
4452 [label="_syntaxReference 238891"];
4453 [label="Debug.Assert(name != null); 238892"];
4454 [label="Debug.Assert(syntax != null); 238893"];
4455 [label="Debug.Assert(location != null); 238894"];
4456 [label="_modifiers 238895"];
4457 [label="this.CheckAccessibility(diagnostics); 238896"];
4458 [label="this.CheckAccessibility(diagnostics) 238897"];
4459 [label="param CheckAccessibility(DiagnosticBag diagnostics) 238898"];
4460 [label="param CheckAccessibility(this) 238899"];
4461 [label="Modifiers 238900"];
4462 [label="get\n            {\n                return _modifiers;\n            } 238901"];
4463 [label="return _modifiers; 238902"];
4464 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238903"];
4465 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238904"];
4466 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238905"];
4467 [label="ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false) 238906"];
4468 [label="param CheckAccessibility(DeclarationModifiers modifiers) 238907"];
4469 [label="param CheckAccessibility(Symbol symbol) 238908"];
4470 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 238909"];
4471 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 238910"];
4472 [label="IsValidAccessibility(modifiers) 238911"];
4473 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 238912"];
4474 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 238913"];
4475 [label="return true; 238914"];
4476 [label="symbol.Kind 238915"];
4477 [label="get\n            {\n                return SymbolKind.Field;\n            } 238916"];
4478 [label="return SymbolKind.Field; 238917"];
4479 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238918"];
4480 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238919"];
4481 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238920"];
4482 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238921"];
4483 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 238922"];
4484 [label="return null; 238923"];
4485 [label="var info = ModifierUtils.CheckAccessibility(Modifiers, this, isExplicitInterfaceImplementation: false); 238924"];
4486 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 238925"];
4487 [label="if (info != null)\n            {\n                diagnostics.Add(new CSDiagnostic(info, this.ErrorLocation));\n            } 238926"];
4488 [label="this.CheckAccessibility(diagnostics); 238927"];
4489 [label="if (!modifierErrors)\n            {\n                this.ReportModifiersDiagnostics(diagnostics);\n            } 238928"];
4490 [label="this.ReportModifiersDiagnostics(diagnostics); 238929"];
4491 [label="this.ReportModifiersDiagnostics(diagnostics) 238930"];
4492 [label="param ReportModifiersDiagnostics(DiagnosticBag diagnostics) 238931"];
4493 [label="param ReportModifiersDiagnostics(this) 238932"];
4494 [label="ContainingType 238933"];
4495 [label="get\n            {\n                return this.containingType;\n            } 238934"];
4496 [label="return this.containingType; 238935"];
4497 [label="if (ContainingType.IsSealed && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(containingType), ErrorLocation, this);\n            }\n            else if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238936"];
4498 [label="ContainingType.IsSealed 238937"];
4499 [label="=> HasFlag(DeclarationModifiers.Sealed) 238938"];
4500 [label="DeclarationModifiers.Sealed 238939"];
4501 [label="HasFlag(DeclarationModifiers.Sealed) 238940"];
4502 [label="param HasFlag(DeclarationModifiers flag) 238941"];
4503 [label="=> (_declModifiers & flag) != 0 238942"];
4504 [label="_declModifiers & flag 238943"];
4505 [label="0 238944"];
4506 [label="(_declModifiers & flag) != 0 238945"];
4507 [label="IsVolatile 238946"];
4508 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 238947"];
4509 [label="Modifiers 238948"];
4510 [label="get\n            {\n                return _modifiers;\n            } 238949"];
4511 [label="return _modifiers; 238950"];
4512 [label="Modifiers & DeclarationModifiers.Volatile 238951"];
4513 [label="0 238952"];
4514 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 238953"];
4515 [label="if (IsVolatile && IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_VolatileAndReadonly, ErrorLocation, this);\n            }\n            else if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238954"];
4516 [label="containingType.IsStatic 238955"];
4517 [label="=> HasFlag(DeclarationModifiers.Static) 238956"];
4518 [label="DeclarationModifiers.Static 238957"];
4519 [label="HasFlag(DeclarationModifiers.Static) 238958"];
4520 [label="param HasFlag(DeclarationModifiers flag) 238959"];
4521 [label="=> (_declModifiers & flag) != 0 238960"];
4522 [label="_declModifiers & flag 238961"];
4523 [label="if (containingType.IsStatic && !IsStatic)\n            {\n                diagnostics.Add(ErrorCode.ERR_InstanceMemberInStaticClass, ErrorLocation, this);\n            }\n            else if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238962"];
4524 [label="IsStatic 238963"];
4525 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 238964"];
4526 [label="Modifiers 238965"];
4527 [label="get\n            {\n                return _modifiers;\n            } 238966"];
4528 [label="Modifiers & DeclarationModifiers.Static 238967"];
4529 [label="0 238968"];
4530 [label="(Modifiers & DeclarationModifiers.Static) != 0 238969"];
4531 [label="if (!IsStatic && !IsReadOnly && containingType.IsReadOnly)\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldsInRoStruct, ErrorLocation);\n            } 238970"];
4532 [label="this.ReportModifiersDiagnostics(diagnostics); 238971"];
4533 [label="containingType.IsInterface 238972"];
4534 [label="if (containingType.IsInterface)\n            {\n                if (this.IsStatic)\n                {\n                    Binder.CheckFeatureAvailability(declarator, MessageID.IDS_DefaultInterfaceImplementation, diagnostics, ErrorLocation);\n\n                    if (!ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation, ErrorLocation);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(ErrorCode.ERR_InterfacesCantContainFields, ErrorLocation);\n                }\n            } 238973"];
4535 [label="fieldSymbol.IsStatic 238974"];
4536 [label="=> (Modifiers & DeclarationModifiers.Static) != 0 238975"];
4537 [label="Modifiers 238976"];
4538 [label="get\n            {\n                return _modifiers;\n            } 238977"];
4539 [label="return _modifiers; 238978"];
4540 [label="Modifiers & DeclarationModifiers.Static 238979"];
4541 [label="0 238980"];
4542 [label="(Modifiers & DeclarationModifiers.Static) != 0 238981"];
4543 [label="param UpdateIsNullableEnabledForConstructorsAndFields(bool useStatic) 238982"];
4544 [label="param UpdateIsNullableEnabledForConstructorsAndFields(this) 238983"];
4545 [label="ref bool isNullableEnabled = ref GetIsNullableEnabledForConstructorsAndFields(useStatic); 238984"];
4546 [label="GetIsNullableEnabledForConstructorsAndFields(useStatic) 238985"];
4547 [label="param GetIsNullableEnabledForConstructorsAndFields(bool useStatic) 238986"];
4548 [label="param GetIsNullableEnabledForConstructorsAndFields(this) 238987"];
4549 [label="useStatic 238988"];
4550 [label="IsNullableEnabledForStaticConstructorsAndFields 238989"];
4551 [label="return ref useStatic ? ref IsNullableEnabledForStaticConstructorsAndFields : ref IsNullableEnabledForInstanceConstructorsAndFields; 238990"];
4552 [label="Feature('run-nullable-analysis') switch\n            {\n                'always' => true,\n                'never' => false,\n                _ => null,\n            } 238991"];
4553 [label="Options 238992"];
4554 [label="return _options; 238993"];
4555 [label="isNullableEnabled = isNullableEnabled || compilation.IsNullableAnalysisEnabledIn(syntax); 238994"];
4556 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 238995"];
4557 [label="if (IsScriptClass)\n                                {\n                                    // also gather expression-declared variables from the bracketed argument lists and the initializers\n                                    ExpressionFieldFinder.FindExpressionVariables(builder.NonTypeMembers, variable, this,\n                                                            DeclarationModifiers.Private | (modifiers & DeclarationModifiers.Static),\n                                                            fieldSymbol);\n                                } 238996"];
4558 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 238997"];
4559 [label="if (variable.Initializer != null)\n                                {\n                                    if (fieldSymbol.IsStatic)\n                                    {\n                                        AddInitializer(ref staticInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                    else\n                                    {\n                                        AddInitializer(ref instanceInitializers, fieldSymbol, variable.Initializer);\n                                    }\n                                } 238998"];
4560 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 238999"];
4561 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 239000"];
4562 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers) 239001"];
4563 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 239002"];
4564 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 239003"];
4565 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 239004"];
4566 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 239005"];
4567 [label="AddInitializers(builder.InstanceInitializers, instanceInitializers); 239006"];
4568 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 239007"];
4569 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 239008"];
4570 [label="AddInitializers(builder.StaticInitializers, staticInitializers) 239009"];
4571 [label="param AddInitializers(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> allInitializers) 239010"];
4572 [label="param AddInitializers(ArrayBuilder<FieldOrPropertyInitializer>? siblingsOpt) 239011"];
4573 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 239012"];
4574 [label="if (siblingsOpt != null)\n            {\n                allInitializers.Add(siblingsOpt);\n            } 239013"];
4575 [label="AddInitializers(builder.StaticInitializers, staticInitializers); 239014"];
4576 [label="AddDeclaredNontypeMembers(builder, diagnostics); 239015"];
4577 [label="TypeKind 239016"];
4578 [label="get\n            {\n                return _flags.TypeKind;\n            } 239017"];
4579 [label="_flags.TypeKind 239018"];
4580 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 239019"];
4581 [label="switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                } 239020"];
4582 [label="IsTupleType 239021"];
4583 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 239022"];
4584 [label="_ 239023"];
4585 [label="tupleCardinality: out _ 239024"];
4586 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 239025"];
4587 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 239026"];
4588 [label="param IsTupleTypeOfCardinality(this) 239027"];
4589 [label="IsUnboundGenericType 239028"];
4590 [label="get\n            {\n                return false;\n            } 239029"];
4591 [label="return false; 239030"];
4592 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239031"];
4593 [label="ContainingSymbol 239032"];
4594 [label="get\n            {\n                return _containingSymbol;\n            } 239033"];
4595 [label="return _containingSymbol; 239034"];
4596 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239035"];
4597 [label=".Kind 239036"];
4598 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 239037"];
4599 [label="return SymbolKind.Namespace; 239038"];
4600 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239039"];
4601 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239040"];
4602 [label="ContainingNamespace 239041"];
4603 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 239042"];
4604 [label="this.ContainingSymbol 239043"];
4605 [label="get\n            {\n                return _containingSymbol;\n            } 239044"];
4606 [label="return _containingSymbol; 239045"];
4607 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239046"];
4608 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239047"];
4609 [label="var ns = container as NamespaceSymbol; 239048"];
4610 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 239049"];
4611 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 239050"];
4612 [label="return ns; 239051"];
4613 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239052"];
4614 [label="ContainingNamespace.ContainingNamespace 239053"];
4615 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 239054"];
4616 [label="this.ContainingSymbol 239055"];
4617 [label="=> _container 239056"];
4618 [label="_container 239057"];
4619 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239058"];
4620 [label="container.ContainingSymbol 239059"];
4621 [label="get\n            {\n                return _assemblySymbol;\n            } 239060"];
4622 [label="return _assemblySymbol; 239061"];
4623 [label="get\n            {\n                return null;\n            } 239062"];
4624 [label="return null; 239063"];
4625 [label="return null; 239064"];
4626 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239065"];
4627 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239066"];
4628 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239067"];
4629 [label="tupleCardinality = 0; 239068"];
4630 [label="return false; 239069"];
4631 [label="if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                } 239070"];
4632 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 239071"];
4633 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 239072"];
4634 [label="builder.ToReadOnlyAndFree() 239073"];
4635 [label="param ToReadOnlyAndFree(this) 239074"];
4636 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239075"];
4637 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239076"];
4638 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers) 239077"];
4639 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 239078"];
4640 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 239079"];
4641 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 239080"];
4642 [label="initializers.Free(); 239081"];
4643 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 239082"];
4644 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239083"];
4645 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers) 239084"];
4646 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 239085"];
4647 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 239086"];
4648 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 239087"];
4649 [label="initializers.Free(); 239088"];
4650 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 239089"];
4651 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239090"];
4652 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239091"];
4653 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239092"];
4654 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239093"];
4655 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239094"];
4656 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239095"];
4657 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239096"];
4658 [label="new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 239097"];
4659 [label="param DeclaredMembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 239098"];
4660 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 239099"];
4661 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 239100"];
4662 [label="param DeclaredMembersAndInitializers(bool haveIndexers) 239101"];
4663 [label="param DeclaredMembersAndInitializers(RecordDeclarationSyntax? recordDeclarationWithParameters) 239102"];
4664 [label="param DeclaredMembersAndInitializers(SynthesizedRecordConstructor? recordPrimaryConstructor) 239103"];
4665 [label="param DeclaredMembersAndInitializers(int instanceInitializersIndexForRecordDeclarationWithParameters) 239104"];
4666 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 239105"];
4667 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 239106"];
4668 [label="param DeclaredMembersAndInitializers(this) 239107"];
4669 [label="HaveIndexers 239108"];
4670 [label="RecordDeclarationWithParameters 239109"];
4671 [label="RecordPrimaryConstructor 239110"];
4672 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 239111"];
4673 [label="IsNullableEnabledForInstanceConstructorsAndFields 239112"];
4674 [label="IsNullableEnabledForStaticConstructorsAndFields 239113"];
4675 [label="Debug.Assert(!nonTypeMembers.IsDefault); 239114"];
4676 [label="Debug.Assert(!staticInitializers.IsDefault); 239115"];
4677 [label="Debug.Assert(!instanceInitializers.IsDefault); 239116"];
4678 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 239117"];
4679 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 239118"];
4680 [label="Debug.Assert(recordDeclarationWithParameters is object == recordPrimaryConstructor is object); 239119"];
4681 [label="this.NonTypeMembers 239120"];
4682 [label="this.StaticInitializers 239121"];
4683 [label="this.InstanceInitializers 239122"];
4684 [label="this.HaveIndexers 239123"];
4685 [label="this.RecordDeclarationWithParameters 239124"];
4686 [label="this.RecordPrimaryConstructor 239125"];
4687 [label="this.InstanceInitializersIndexForRecordDeclarationWithParameters 239126"];
4688 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 239127"];
4689 [label="this.IsNullableEnabledForStaticConstructorsAndFields 239128"];
4690 [label="return builder.ToReadOnlyAndFree(); 239129"];
4691 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 239130"];
4692 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 239131"];
4693 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 239132"];
4694 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 239133"];
4695 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 239134"];
4696 [label="if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                } 239135"];
4697 [label="AddDeclarationDiagnostics(diagnostics); 239136"];
4698 [label="AddDeclarationDiagnostics(diagnostics) 239137"];
4699 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 239138"];
4700 [label="param AddDeclarationDiagnostics(this) 239139"];
4701 [label="ContainingSymbol 239140"];
4702 [label="get\n            {\n                return _containingSymbol;\n            } 239141"];
4703 [label="return _containingSymbol; 239142"];
4704 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 239143"];
4705 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 239144"];
4706 [label="AddDeclarationDiagnostics(diagnostics); 239145"];
4707 [label="diagnostics.Free(); 239146"];
4708 [label="return declaredMembersAndInitializers!; 239147"];
4709 [label="var declaredMembersAndInitializers = getDeclaredMembersAndInitializers(); 239148"];
4710 [label="if (declaredMembersAndInitializers is null)\n            {\n                // Another thread completed the work before this one\n                return null;\n            } 239149"];
4711 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 239150"];
4712 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 239151"];
4713 [label="new MembersAndInitializersBuilder(declaredMembersAndInitializers) 239152"];
4714 [label="param MembersAndInitializersBuilder(DeclaredMembersAndInitializers declaredMembersAndInitializers) 239153"];
4715 [label="param MembersAndInitializersBuilder(this) 239154"];
4716 [label="NonTypeMembers 239155"];
4717 [label="InstanceInitializersForPositionalMembers 239156"];
4718 [label="IsNullableEnabledForInstanceConstructorsAndFields 239157"];
4719 [label="IsNullableEnabledForStaticConstructorsAndFields 239158"];
4720 [label="Debug.Assert(declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel); 239159"];
4721 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 239160"];
4722 [label="this.IsNullableEnabledForStaticConstructorsAndFields 239161"];
4723 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 239162"];
4724 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 239163"];
4725 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 239164"];
4726 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics) 239165"];
4727 [label="param AddSynthesizedMembers(MembersAndInitializersBuilder builder) 239166"];
4728 [label="param AddSynthesizedMembers(DeclaredMembersAndInitializers declaredMembersAndInitializers) 239167"];
4729 [label="param AddSynthesizedMembers(DiagnosticBag diagnostics) 239168"];
4730 [label="param AddSynthesizedMembers(this) 239169"];
4731 [label="TypeKind 239170"];
4732 [label="get\n            {\n                return _flags.TypeKind;\n            } 239171"];
4733 [label="_flags.TypeKind 239172"];
4734 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 239173"];
4735 [label="switch (TypeKind)\n            {\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                case TypeKind.Class:\n                case TypeKind.Interface:\n                case TypeKind.Submission:\n                    AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    break;\n\n                default:\n                    break;\n            } 239174"];
4736 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239175"];
4737 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239176"];
4738 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239177"];
4739 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 239178"];
4740 [label="param AddSynthesizedRecordMembersIfNecessary(MembersAndInitializersBuilder builder) 239179"];
4741 [label="param AddSynthesizedRecordMembersIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 239180"];
4742 [label="param AddSynthesizedRecordMembersIfNecessary(DiagnosticBag diagnostics) 239181"];
4743 [label="param AddSynthesizedRecordMembersIfNecessary(this) 239182"];
4744 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 239183"];
4745 [label="return; 239184"];
4746 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239185"];
4747 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239186"];
4748 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239187"];
4749 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239188"];
4750 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 239189"];
4751 [label="param AddSynthesizedConstructorsIfNecessary(MembersAndInitializersBuilder builder) 239190"];
4752 [label="param AddSynthesizedConstructorsIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 239191"];
4753 [label="param AddSynthesizedConstructorsIfNecessary(DiagnosticBag diagnostics) 239192"];
4754 [label="param AddSynthesizedConstructorsIfNecessary(this) 239193"];
4755 [label="var hasInstanceConstructor = false; 239194"];
4756 [label="var hasParameterlessInstanceConstructor = false; 239195"];
4757 [label="var hasStaticConstructor = false; 239196"];
4758 [label="var membersSoFar = builder.GetNonTypeMembers(declaredMembersAndInitializers); 239197"];
4759 [label="builder.GetNonTypeMembers(declaredMembersAndInitializers) 239198"];
4760 [label="param GetNonTypeMembers(DeclaredMembersAndInitializers declaredMembers) 239199"];
4761 [label="param GetNonTypeMembers(this) 239200"];
4762 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 239201"];
4763 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 239202"];
4764 [label="foreach (var member in membersSoFar)\n            {\n                if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                }\n\n                //kick out early if we've seen everything we're looking for\n                if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                }\n            } 239203"];
4765 [label="member.Kind 239204"];
4766 [label="get\n            {\n                return SymbolKind.Field;\n            } 239205"];
4767 [label="return SymbolKind.Field; 239206"];
4768 [label="if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                } 239207"];
4769 [label="if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                } 239208"];
4770 [label="'Expressions' 239209"];
4771 [label="'Linq' 239210"];
4772 [label="'' 239211"];
4773 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 239212"];
4774 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 239213"];
4775 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 239214"];
4776 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 239215"];
4777 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 239216"];
4778 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 239217"];
4779 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 239218"];
4780 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 239219"];
4781 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 239220"];
4782 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 239221"];
4783 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 239222"];
4784 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 239223"];
4785 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 239224"];
4786 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239225"];
4787 [label="this.IsStructType() 239226"];
4788 [label="param IsStructType(this TypeSymbol type) 239227"];
4789 [label="RoslynDebug.Assert((object)type != null); 239228"];
4790 [label="RoslynDebug.Assert((object)type != null); 239229"];
4791 [label="type.TypeKind 239230"];
4792 [label="get\n            {\n                return _flags.TypeKind;\n            } 239231"];
4793 [label="return type.TypeKind == TypeKind.Struct; 239232"];
4794 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239233"];
4795 [label="this.IsStatic 239234"];
4796 [label="=> HasFlag(DeclarationModifiers.Static) 239235"];
4797 [label="DeclarationModifiers.Static 239236"];
4798 [label="HasFlag(DeclarationModifiers.Static) 239237"];
4799 [label="param HasFlag(DeclarationModifiers flag) 239238"];
4800 [label="=> (_declModifiers & flag) != 0 239239"];
4801 [label="_declModifiers & flag 239240"];
4802 [label="0 239241"];
4803 [label="(_declModifiers & flag) != 0 239242"];
4804 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239243"];
4805 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239244"];
4806 [label="this.IsInterface 239245"];
4807 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 239246"];
4808 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239247"];
4809 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239248"];
4810 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 239249"];
4811 [label="this.TypeKind 239250"];
4812 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 239251"];
4813 [label="(this.TypeKind == TypeKind.Submission) 239252"];
4814 [label="new SynthesizedInstanceConstructor(this) 239253"];
4815 [label="param SynthesizedInstanceConstructor(NamedTypeSymbol containingType) 239254"];
4816 [label="param SynthesizedInstanceConstructor(this) 239255"];
4817 [label="param SynthesizedInstanceConstructor(this) 239256"];
4818 [label="param SynthesizedInstanceMethodSymbol(this) 239257"];
4819 [label="null 239258"];
4820 [label="None = null 239259"];
4821 [label="param SynthesizedInstanceMethodSymbol(this) 239260"];
4822 [label="param MethodSymbol(this) 239261"];
4823 [label="param MethodSymbol(this) 239262"];
4824 [label="_lazyAdapter 239263"];
4825 [label="_lazyParameterSignature 239264"];
4826 [label="_lazyThisParameter 239265"];
4827 [label="_containingType 239266"];
4828 [label="Debug.Assert((object)containingType != null); 239267"];
4829 [label="Debug.Assert((object)containingType != null); 239268"];
4830 [label="_containingType 239269"];
4831 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 239270"];
4832 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers) 239271"];
4833 [label="param AddNonTypeMember(Symbol member) 239272"];
4834 [label="param AddNonTypeMember(DeclaredMembersAndInitializers declaredMembers) 239273"];
4835 [label="param AddNonTypeMember(this) 239274"];
4836 [label="if (NonTypeMembers is null)\n                {\n                    NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1);\n                    NonTypeMembers.AddRange(declaredMembers.NonTypeMembers);\n                } 239275"];
4837 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 239276"];
4838 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 239277"];
4839 [label="NonTypeMembers 239278"];
4840 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 239279"];
4841 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 239280"];
4842 [label="NonTypeMembers.Add(member); 239281"];
4843 [label="NonTypeMembers.Add(member); 239282"];
4844 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 239283"];
4845 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 239284"];
4846 [label="hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers) 239285"];
4847 [label="static bool hasNonConstantInitializer(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers)\n            {\n                return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst));\n            } 239286"];
4848 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 239287"];
4849 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 239288"];
4850 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 239289"];
4851 [label="this.IsScriptClass 239290"];
4852 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 239291"];
4853 [label="var kind = this.declaration.Declarations[0].Kind; 239292"];
4854 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 239293"];
4855 [label="if (this.IsScriptClass)\n            {\n                var scriptInitializer = new SynthesizedInteractiveInitializerMethod(this, diagnostics);\n                builder.AddNonTypeMember(scriptInitializer, declaredMembersAndInitializers);\n                var scriptEntryPoint = SynthesizedEntryPointSymbol.Create(scriptInitializer, diagnostics);\n                builder.AddNonTypeMember(scriptEntryPoint, declaredMembersAndInitializers);\n            } 239294"];
4856 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 239295"];
4857 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 239296"];
4858 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 239297"];
4859 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 239298"];
4860 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 239299"];
4861 [label="membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers) 239300"];
4862 [label="param ToReadOnlyAndFree(DeclaredMembersAndInitializers declaredMembers) 239301"];
4863 [label="param ToReadOnlyAndFree(this) 239302"];
4864 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 239303"];
4865 [label="var instanceInitializers = InstanceInitializersForPositionalMembers is null\n                    ? declaredMembers.InstanceInitializers\n                    : mergeInitializers(); 239304"];
4866 [label="InstanceInitializersForPositionalMembers is null 239305"];
4867 [label="declaredMembers.InstanceInitializers 239306"];
4868 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239307"];
4869 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239308"];
4870 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239309"];
4871 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239310"];
4872 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239311"];
4873 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 239312"];
4874 [label="new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 239313"];
4875 [label="param MembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 239314"];
4876 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 239315"];
4877 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 239316"];
4878 [label="param MembersAndInitializers(bool haveIndexers) 239317"];
4879 [label="param MembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 239318"];
4880 [label="param MembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 239319"];
4881 [label="param MembersAndInitializers(this) 239320"];
4882 [label="HaveIndexers 239321"];
4883 [label="IsNullableEnabledForInstanceConstructorsAndFields 239322"];
4884 [label="IsNullableEnabledForStaticConstructorsAndFields 239323"];
4885 [label="Debug.Assert(!nonTypeMembers.IsDefault); 239324"];
4886 [label="Debug.Assert(!staticInitializers.IsDefault); 239325"];
4887 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 239326"];
4888 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 239327"];
4889 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 239328"];
4890 [label="Debug.Assert(!instanceInitializers.IsDefault); 239329"];
4891 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 239330"];
4892 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 239331"];
4893 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 239332"];
4894 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 239333"];
4895 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 239334"];
4896 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 239335"];
4897 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239336"];
4898 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239337"];
4899 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239338"];
4900 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239339"];
4901 [label="param IsIndexer(this Symbol symbol) 239340"];
4902 [label="symbol.Kind 239341"];
4903 [label="get\n            {\n                return SymbolKind.Field;\n            } 239342"];
4904 [label="return SymbolKind.Field; 239343"];
4905 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 239344"];
4906 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239345"];
4907 [label="get\n            {\n                return SymbolKind.Method;\n            } 239346"];
4908 [label="return SymbolKind.Method; 239347"];
4909 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 239348"];
4910 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239349"];
4911 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 239350"];
4912 [label="this.NonTypeMembers 239351"];
4913 [label="this.StaticInitializers 239352"];
4914 [label="this.InstanceInitializers 239353"];
4915 [label="this.HaveIndexers 239354"];
4916 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 239355"];
4917 [label="this.IsNullableEnabledForStaticConstructorsAndFields 239356"];
4918 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 239357"];
4919 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 239358"];
4920 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 239359"];
4921 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 239360"];
4922 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 239361"];
4923 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 239362"];
4924 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 239363"];
4925 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 239364"];
4926 [label="AddDeclarationDiagnostics(diagnostics); 239365"];
4927 [label="AddDeclarationDiagnostics(diagnostics) 239366"];
4928 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 239367"];
4929 [label="param AddDeclarationDiagnostics(this) 239368"];
4930 [label="ContainingSymbol 239369"];
4931 [label="get\n            {\n                return _containingSymbol;\n            } 239370"];
4932 [label="return _containingSymbol; 239371"];
4933 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 239372"];
4934 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 239373"];
4935 [label="AddDeclarationDiagnostics(diagnostics); 239374"];
4936 [label="diagnostics.Free(); 239375"];
4937 [label="_lazyDeclaredMembersAndInitializers = null; 239376"];
4938 [label="_lazyDeclaredMembersAndInitializers 239377"];
4939 [label="return membersAndInitializers!; 239378"];
4940 [label="var membersAndInitializers = GetMembersAndInitializers(); 239379"];
4941 [label="this.IsTupleType 239380"];
4942 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 239381"];
4943 [label="_ 239382"];
4944 [label="tupleCardinality: out _ 239383"];
4945 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 239384"];
4946 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 239385"];
4947 [label="param IsTupleTypeOfCardinality(this) 239386"];
4948 [label="IsUnboundGenericType 239387"];
4949 [label="get\n            {\n                return false;\n            } 239388"];
4950 [label="return false; 239389"];
4951 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239390"];
4952 [label="ContainingSymbol 239391"];
4953 [label="get\n            {\n                return _containingSymbol;\n            } 239392"];
4954 [label="return _containingSymbol; 239393"];
4955 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239394"];
4956 [label=".Kind 239395"];
4957 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 239396"];
4958 [label="return SymbolKind.Namespace; 239397"];
4959 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239398"];
4960 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239399"];
4961 [label="ContainingNamespace 239400"];
4962 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 239401"];
4963 [label="this.ContainingSymbol 239402"];
4964 [label="get\n            {\n                return _containingSymbol;\n            } 239403"];
4965 [label="return _containingSymbol; 239404"];
4966 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239405"];
4967 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239406"];
4968 [label="var ns = container as NamespaceSymbol; 239407"];
4969 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 239408"];
4970 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 239409"];
4971 [label="return ns; 239410"];
4972 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239411"];
4973 [label="ContainingNamespace.ContainingNamespace 239412"];
4974 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 239413"];
4975 [label="this.ContainingSymbol 239414"];
4976 [label="=> _container 239415"];
4977 [label="_container 239416"];
4978 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 239417"];
4979 [label="container.ContainingSymbol 239418"];
4980 [label="get\n            {\n                return _assemblySymbol;\n            } 239419"];
4981 [label="return _assemblySymbol; 239420"];
4982 [label="get\n            {\n                return null;\n            } 239421"];
4983 [label="return null; 239422"];
4984 [label="return null; 239423"];
4985 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239424"];
4986 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239425"];
4987 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 239426"];
4988 [label="tupleCardinality = 0; 239427"];
4989 [label="return false; 239428"];
4990 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 239429"];
4991 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 239430"];
4992 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 239431"];
4993 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 239432"];
4994 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 239433"];
4995 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 239434"];
4996 [label="get\n            {\n                return _name;\n            } 239435"];
4997 [label="return _name; 239436"];
4998 [label="get { return WellKnownMemberNames.InstanceConstructorName; } 239437"];
4999 [label="return WellKnownMemberNames.InstanceConstructorName; 239438"];
5000 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 239439"];
5001 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 239440"];
5002 [label="GetTypeMembersDictionary() 239441"];
5003 [label="param GetTypeMembersDictionary(this) 239442"];
5004 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 239443"];
5005 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 239444"];
5006 [label="var diagnostics = DiagnosticBag.GetInstance(); 239445"];
5007 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 239446"];
5008 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 239447"];
5009 [label="MakeTypeMembers(diagnostics) 239448"];
5010 [label="param MakeTypeMembers(DiagnosticBag diagnostics) 239449"];
5011 [label="param MakeTypeMembers(this) 239450"];
5012 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 239451"];
5013 [label="var conflictDict = new Dictionary<(string, int), SourceNamedTypeSymbol>(); 239452"];
5014 [label="foreach (var childDeclaration in declaration.Children)\n                {\n                    var t = new SourceNamedTypeSymbol(this, childDeclaration, diagnostics);\n                    this.CheckMemberNameDistinctFromType(t, diagnostics);\n\n                    var key = (t.Name, t.Arity);\n                    SourceNamedTypeSymbol? other;\n                    if (conflictDict.TryGetValue(key, out other))\n                    {\n                        if (Locations.Length == 1 || IsPartial)\n                        {\n                            if (t.IsPartial && other.IsPartial)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, t.Locations[0], t);\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, t.Locations[0], this, t.Name);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        conflictDict.Add(key, t);\n                    }\n\n                    symbols.Add(t);\n                } 239453"];
5015 [label="IsInterface 239454"];
5016 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 239455"];
5017 [label="if (IsInterface)\n                {\n                    foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    }\n                } 239456"];
5018 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 239457"];
5019 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 239458"];
5020 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 239459"];
5021 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 239460"];
5022 [label="symbols.Count > 0 239461"];
5023 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 239462"];
5024 [label="symbols.Free(); 239463"];
5025 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 239464"];
5026 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 239465"];
5027 [label="AddDeclarationDiagnostics(diagnostics); 239466"];
5028 [label="AddDeclarationDiagnostics(diagnostics) 239467"];
5029 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 239468"];
5030 [label="param AddDeclarationDiagnostics(this) 239469"];
5031 [label="ContainingSymbol 239470"];
5032 [label="get\n            {\n                return _containingSymbol;\n            } 239471"];
5033 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 239472"];
5034 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 239473"];
5035 [label="AddDeclarationDiagnostics(diagnostics); 239474"];
5036 [label="state.NotePartComplete(CompletionPart.TypeMembers); 239475"];
5037 [label="state.NotePartComplete(CompletionPart.TypeMembers) 239476"];
5038 [label="param NotePartComplete(CompletionPart part) 239477"];
5039 [label="diagnostics.Free(); 239478"];
5040 [label="return _lazyTypeMembers; 239479"];
5041 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 239480"];
5042 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()) 239481"];
5043 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<Symbol>> membersByName) 239482"];
5044 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<NamedTypeSymbol>> typesByName) 239483"];
5045 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 239484"];
5046 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 239485"];
5047 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 239486"];
5048 [label="MergePartialMembers(ref membersByName, diagnostics); 239487"];
5049 [label="MergePartialMembers(ref membersByName, diagnostics); 239488"];
5050 [label="MergePartialMembers(ref membersByName, diagnostics) 239489"];
5051 [label="param MergePartialMembers(ref Dictionary<string, ImmutableArray<Symbol>> membersByName) 239490"];
5052 [label="param MergePartialMembers(DiagnosticBag diagnostics) 239491"];
5053 [label="param MergePartialMembers(this) 239492"];
5054 [label="var memberNames = ArrayBuilder<string>.GetInstance(membersByName.Count); 239493"];
5055 [label="memberNames.AddRange(membersByName.Keys); 239494"];
5056 [label="memberNames.AddRange(membersByName.Keys); 239495"];
5057 [label="var methodsBySignature = new Dictionary<MethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.PartialMethodsComparer); 239496"];
5058 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 239497"];
5059 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 239498"];
5060 [label="methodsBySignature.Clear(); 239499"];
5061 [label="foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                } 239500"];
5062 [label="var method = symbol as SourceMemberMethodSymbol; 239501"];
5063 [label="if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    } 239502"];
5064 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 239503"];
5065 [label="methodsBySignature.Clear(); 239504"];
5066 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 239505"];
5067 [label="memberNames.Free(); 239506"];
5068 [label="MergePartialMembers(ref membersByName, diagnostics); 239507"];
5069 [label="return membersByName; 239508"];
5070 [label="var membersDictionary = MakeAllMembers(diagnostics); 239509"];
5071 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 239510"];
5072 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 239511"];
5073 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 239512"];
5074 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 239513"];
5075 [label="AddDeclarationDiagnostics(diagnostics); 239514"];
5076 [label="AddDeclarationDiagnostics(diagnostics) 239515"];
5077 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 239516"];
5078 [label="param AddDeclarationDiagnostics(this) 239517"];
5079 [label="ContainingSymbol 239518"];
5080 [label="get\n            {\n                return _containingSymbol;\n            } 239519"];
5081 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 239520"];
5082 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 239521"];
5083 [label="AddDeclarationDiagnostics(diagnostics); 239522"];
5084 [label="state.NotePartComplete(CompletionPart.Members); 239523"];
5085 [label="state.NotePartComplete(CompletionPart.Members) 239524"];
5086 [label="param NotePartComplete(CompletionPart part) 239525"];
5087 [label="diagnostics.Free(); 239526"];
5088 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 239527"];
5089 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 239528"];
5090 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)) 239529"];
5091 [label="param SpinWaitComplete(CompletionPart part) 239530"];
5092 [label="param SpinWaitComplete(CancellationToken cancellationToken) 239531"];
5093 [label="param SpinWaitComplete(this) 239532"];
5094 [label="if (HasComplete(part))\n            {\n                return;\n            } 239533"];
5095 [label="HasComplete(part) 239534"];
5096 [label="param HasComplete(CompletionPart part) 239535"];
5097 [label="param HasComplete(this) 239536"];
5098 [label="return (_completeParts & (int)part) == (int)part; 239537"];
5099 [label="return; 239538"];
5100 [label="return _lazyMembersDictionary; 239539"];
5101 [label="return GetMembersByNameSlow(); 239540"];
5102 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 239541"];
5103 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 239542"];
5104 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 239543"];
5105 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 239544"];
5106 [label="return members; 239545"];
5107 [label="(classTest.GetMembers('AryField').First() as FieldSymbol).Type 239546"];
5108 [label="=> TypeWithAnnotations.Type 239547"];
5109 [label="TypeWithAnnotations 239548"];
5110 [label="get\n            {\n                return GetFieldType(ConsList<FieldSymbol>.Empty);\n            } 239549"];
5111 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 239550"];
5112 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 239551"];
5113 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 239552"];
5114 [label="param GetFieldType(this) 239553"];
5115 [label="Debug.Assert(fieldsBeingBound != null); 239554"];
5116 [label="Debug.Assert(fieldsBeingBound != null); 239555"];
5117 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 239556"];
5118 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 239557"];
5119 [label="VariableDeclaratorNode 239558"];
5120 [label="get\n            {\n                return (VariableDeclaratorSyntax)this.SyntaxNode;\n            } 239559"];
5121 [label="this.SyntaxNode 239560"];
5122 [label="get\n            {\n                return (CSharpSyntaxNode)_syntaxReference.GetSyntax();\n            } 239561"];
5123 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 239562"];
5124 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 239563"];
5125 [label="return (VariableDeclaratorSyntax)this.SyntaxNode; 239564"];
5126 [label="var declarator = VariableDeclaratorNode; 239565"];
5127 [label="var fieldSyntax = GetFieldDeclaration(declarator); 239566"];
5128 [label="GetFieldDeclaration(declarator) 239567"];
5129 [label="param GetFieldDeclaration(CSharpSyntaxNode declarator) 239568"];
5130 [label="return (BaseFieldDeclarationSyntax)declarator.Parent.Parent; 239569"];
5131 [label="var typeSyntax = fieldSyntax.Declaration.Type; 239570"];
5132 [label="this.DeclaringCompilation 239571"];
5133 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 239572"];
5134 [label="this.Kind 239573"];
5135 [label="get\n            {\n                return SymbolKind.Field;\n            } 239574"];
5136 [label="return SymbolKind.Field; 239575"];
5137 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 239576"];
5138 [label="this.ContainingModule 239577"];
5139 [label="this.ContainingSymbol 239578"];
5140 [label="get\n            {\n                return containingType;\n            } 239579"];
5141 [label="return containingType; 239580"];
5142 [label="return (object)container != null ? container.ContainingModule : null; 239581"];
5143 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 239582"];
5144 [label="var compilation = this.DeclaringCompilation; 239583"];
5145 [label="var diagnostics = DiagnosticBag.GetInstance(); 239584"];
5146 [label="TypeWithAnnotations type; 239585"];
5147 [label="type 239586"];
5148 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 239587"];
5149 [label="this.AssociatedSymbol 239588"];
5150 [label="get\n            {\n                return null;\n            } 239589"];
5151 [label="return null; 239590"];
5152 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 239591"];
5153 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 239592"];
5154 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 239593"];
5155 [label="SyntaxTree 239594"];
5156 [label="get\n            {\n                return _syntaxReference.SyntaxTree;\n            } 239595"];
5157 [label="return _syntaxReference.SyntaxTree; 239596"];
5158 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 239597"];
5159 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 239598"];
5160 [label="compilation.GetBinderFactory(SyntaxTree) 239599"];
5161 [label="param GetBinderFactory(SyntaxTree syntaxTree) 239600"];
5162 [label="param GetBinderFactory(bool ignoreAccessibility = false) 239601"];
5163 [label="param GetBinderFactory(this) 239602"];
5164 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 239603"];
5165 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 239604"];
5166 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 239605"];
5167 [label="param GetBinderFactory(bool ignoreAccessibility) 239606"];
5168 [label="ignoreAccessibility 239607"];
5169 [label="GetSyntaxTreeOrdinal(syntaxTree) 239608"];
5170 [label="this.ContainsSyntaxTree(tree) 239609"];
5171 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 239610"];
5172 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 239611"];
5173 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 239612"];
5174 [label="BinderFactory? previousFactory; 239613"];
5175 [label="var previousWeakReference = binderFactories[treeNum]; 239614"];
5176 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 239615"];
5177 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 239616"];
5178 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 239617"];
5179 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 239618"];
5180 [label="return AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]); 239619"];
5181 [label="AddNewFactory(syntaxTree, ignoreAccessibility, ref binderFactories[treeNum]) 239620"];
5182 [label="param AddNewFactory(bool ignoreAccessibility) 239621"];
5183 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 239622"];
5184 [label="var newFactory = new BinderFactory(this, syntaxTree, ignoreAccessibility); 239623"];
5185 [label="new BinderFactory(this, syntaxTree, ignoreAccessibility) 239624"];
5186 [label="param BinderFactory(bool ignoreAccessibility) 239625"];
5187 [label="param BinderFactory(this) 239626"];
5188 [label="_binderCache 239627"];
5189 [label="_compilation 239628"];
5190 [label="_syntaxTree 239629"];
5191 [label="_buckStopsHereBinder 239630"];
5192 [label="_ignoreAccessibility 239631"];
5193 [label="_binderFactoryVisitorPool 239632"];
5194 [label="_ignoreAccessibility 239633"];
5195 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 239634"];
5196 [label="_binderFactoryVisitorPool = new ObjectPool<BinderFactoryVisitor>(() => new BinderFactoryVisitor(this), 64); 239635"];
5197 [label="_binderCache = new ConcurrentCache<BinderCacheKey, Binder>(50); 239636"];
5198 [label="_binderCache 239637"];
5199 [label="_buckStopsHereBinder = new BuckStopsHereBinder(compilation); 239638"];
5200 [label="new BuckStopsHereBinder(compilation) 239639"];
5201 [label="param BuckStopsHereBinder(this) 239640"];
5202 [label="param BuckStopsHereBinder(this) 239641"];
5203 [label="param Binder(this) 239642"];
5204 [label="internal CSharpCompilation Compilation { get; } 239643"];
5205 [label="Flags 239644"];
5206 [label="protected internal Binder? Next { get; } 239645"];
5207 [label="_lazyConversions 239646"];
5208 [label="_lazyOverloadResolution 239647"];
5209 [label="RoslynDebug.Assert(compilation != null); 239648"];
5210 [label="RoslynDebug.Assert(compilation != null); 239649"];
5211 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 239650"];
5212 [label="RoslynDebug.Assert(this is BuckStopsHereBinder); 239651"];
5213 [label="compilation.Options 239652"];
5214 [label="_buckStopsHereBinder 239653"];
5215 [label="var newWeakReference = new WeakReference<BinderFactory>(newFactory); 239654"];
5216 [label="while (true)\n            {\n                BinderFactory? previousFactory;\n                WeakReference<BinderFactory>? previousWeakReference = slot;\n                if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                }\n\n                if (Interlocked.CompareExchange(ref slot!, newWeakReference, previousWeakReference) == previousWeakReference)\n                {\n                    return newFactory;\n                }\n            } 239655"];
5217 [label="BinderFactory? previousFactory; 239656"];
5218 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 239657"];
5219 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 239658"];
5220 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 239659"];
5221 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n                {\n                    Debug.Assert(slot is object);\n                    return previousFactory;\n                } 239660"];
5222 [label="var binder = binderFactory.GetBinder(typeSyntax); 239661"];
5223 [label="var binder = binderFactory.GetBinder(typeSyntax); 239662"];
5224 [label="binderFactory.GetBinder(typeSyntax) 239663"];
5225 [label="param GetBinder(SyntaxNode node) 239664"];
5226 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 239665"];
5227 [label="param GetBinder(Symbol memberOpt = null) 239666"];
5228 [label="param GetBinder(this) 239667"];
5229 [label="int position = node.SpanStart; 239668"];
5230 [label="InScript 239669"];
5231 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 239670"];
5232 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 239671"];
5233 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 239672"];
5234 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 239673"];
5235 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 239674"];
5236 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 239675"];
5237 [label="param GetBinder(Symbol memberOpt = null) 239676"];
5238 [label="Debug.Assert(node != null); 239677"];
5239 [label="Debug.Assert(node != null); 239678"];
5240 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 239679"];
5241 [label="BinderFactoryVisitor visitor = _binderFactoryVisitorPool.Allocate(); 239680"];
5242 [label="param BinderFactoryVisitor(this) 239681"];
5243 [label="_position 239682"];
5244 [label="_memberDeclarationOpt 239683"];
5245 [label="_memberOpt 239684"];
5246 [label="_factory 239685"];
5247 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 239686"];
5248 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 239687"];
5249 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 239688"];
5250 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 239689"];
5251 [label="param Initialize(Symbol memberOpt) 239690"];
5252 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 239691"];
5253 [label="memberDeclarationOpt == null 239692"];
5254 [label="param ==(Symbol left) 239693"];
5255 [label="param ==(Symbol right) 239694"];
5256 [label="if (right is null)\n            {\n                return left is null;\n            } 239695"];
5257 [label="return left is null; 239696"];
5258 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 239697"];
5259 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 239698"];
5260 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 239699"];
5261 [label="_memberDeclarationOpt 239700"];
5262 [label="_memberOpt 239701"];
5263 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 239702"];
5264 [label="visitor.Visit(node) 239703"];
5265 [label="VisitCore(node) 239704"];
5266 [label="return ((CSharpSyntaxNode)node).Accept(this); 239705"];
5267 [label="param DefaultVisit(SyntaxNode parent) 239706"];
5268 [label="param DefaultVisit(this) 239707"];
5269 [label="return VisitCore(parent.Parent); 239708"];
5270 [label="VisitCore(parent.Parent) 239709"];
5271 [label="param VisitCore(SyntaxNode node) 239710"];
5272 [label="param VisitCore(this) 239711"];
5273 [label="return ((CSharpSyntaxNode)node).Accept(this); 239712"];
5274 [label="param VisitFieldDeclaration(FieldDeclarationSyntax parent) 239713"];
5275 [label="param VisitFieldDeclaration(this) 239714"];
5276 [label="return VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers); 239715"];
5277 [label="VisitCore(parent.Parent) 239716"];
5278 [label="param VisitCore(SyntaxNode node) 239717"];
5279 [label="param VisitCore(this) 239718"];
5280 [label="return ((CSharpSyntaxNode)node).Accept(this); 239719"];
5281 [label="VisitTypeDeclarationCore(node) 239720"];
5282 [label="NodeUsage extraInfo = NodeUsage.Normal; 239721"];
5283 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 239722"];
5284 [label="VisitTypeDeclarationCore(parent, extraInfo) 239723"];
5285 [label="CreateBinderCacheKey(parent, extraInfo) 239724"];
5286 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 239725"];
5287 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 239726"];
5288 [label="return new BinderCacheKey(node, usage); 239727"];
5289 [label="new BinderCacheKey(node, usage) 239728"];
5290 [label="param BinderCacheKey(this) 239729"];
5291 [label="var key = CreateBinderCacheKey(parent, extraInfo); 239730"];
5292 [label="Binder resultBinder; 239731"];
5293 [label="binderCache 239732"];
5294 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 239733"];
5295 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 239734"];
5296 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 239735"];
5297 [label="SyntaxToken token; 239736"];
5298 [label="token 239737"];
5299 [label="syntaxTree 239738"];
5300 [label="get\n                {\n                    return _factory._syntaxTree;\n                } 239739"];
5301 [label="return _factory._syntaxTree; 239740"];
5302 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 239741"];
5303 [label="if (compilationUnit != syntaxTree.GetRoot())\n                {\n                    throw new ArgumentOutOfRangeException(nameof(compilationUnit), 'node not part of tree');\n                } 239742"];
5304 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 239743"];
5305 [label="RoslynDebug.Assert(next != null); 239744"];
5306 [label="_container 239745"];
5307 [label="Debug.Assert((object)container != null); 239746"];
5308 [label="Debug.Assert(declarationSyntax != null); 239747"];
5309 [label="param GetSimpleProgramEntryPoint(CompilationUnitSyntax compilationUnit) 239748"];
5310 [label="param GetSimpleProgramEntryPoint(bool fallbackToMainEntryPoint) 239749"];
5311 [label="GetBoundReferenceManager(); 239750"];
5312 [label="if (type is null)\n            {\n                return null;\n            } 239751"];
5313 [label="return null; 239752"];
5314 [label="Debug.Assert(compilation != null); 239753"];
5315 [label="this.Kind 239754"];
5316 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 239755"];
5317 [label="return SymbolKind.Namespace; 239756"];
5318 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 239757"];
5319 [label="Debug.Assert((object)container != null || imports != null); 239758"];
5320 [label="if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            } 239759"];
5321 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 239760"];
5322 [label="param WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers) 239761"];
5323 [label="param WithUnsafeRegionIfNecessary(this) 239762"];
5324 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 239763"];
5325 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 239764"];
5326 [label="param Includes(BinderFlags other) 239765"];
5327 [label="return result; 239766"];
5328 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 239767"];
5329 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 239768"];
5330 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 239769"];
5331 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 239770"];
5332 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 239771"];
5333 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(this) 239772"];
5334 [label="Debug.Assert((object)containing != null); 239773"];
5335 [label="Debug.Assert((object)containing != null); 239774"];
5336 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 239775"];
5337 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 239776"];
5338 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 239777"];
5339 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 239778"];
5340 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 239779"];
5341 [label="param BinderWithContainingMemberOrLambda(Binder next) 239780"];
5342 [label="param BinderWithContainingMemberOrLambda(BinderFlags flags) 239781"];
5343 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 239782"];
5344 [label="param BinderWithContainingMemberOrLambda(this) 239783"];
5345 [label="next 239784"];
5346 [label="flags 239785"];
5347 [label="param BinderWithContainingMemberOrLambda(this) 239786"];
5348 [label="param Binder(Binder next) 239787"];
5349 [label="param Binder(BinderFlags flags) 239788"];
5350 [label="param Binder(this) 239789"];
5351 [label="internal CSharpCompilation Compilation { get; } 239790"];
5352 [label="Flags 239791"];
5353 [label="protected internal Binder? Next { get; } 239792"];
5354 [label="_lazyConversions 239793"];
5355 [label="_lazyOverloadResolution 239794"];
5356 [label="RoslynDebug.Assert(next != null); 239795"];
5357 [label="RoslynDebug.Assert(next != null); 239796"];
5358 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 239797"];
5359 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 239798"];
5360 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 239799"];
5361 [label="param Includes(this BinderFlags self) 239800"];
5362 [label="param Includes(BinderFlags other) 239801"];
5363 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 239802"];
5364 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 239803"];
5365 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 239804"];
5366 [label="param Includes(this BinderFlags self) 239805"];
5367 [label="param Includes(BinderFlags other) 239806"];
5368 [label="Next 239807"];
5369 [label="this.Flags 239808"];
5370 [label="this.Compilation 239809"];
5371 [label="_containingMemberOrLambda 239810"];
5372 [label="Debug.Assert(containingMemberOrLambda != null); 239811"];
5373 [label="containingMemberOrLambda != null 239812"];
5374 [label="param !=(Symbol left) 239813"];
5375 [label="param !=(Symbol right) 239814"];
5376 [label="if (right is null)\n            {\n                return left is object;\n            } 239815"];
5377 [label="return left is object; 239816"];
5378 [label="Debug.Assert(containingMemberOrLambda != null); 239817"];
5379 [label="_containingMemberOrLambda 239818"];
5380 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 239819"];
5381 [label="ContainingType 239820"];
5382 [label="get\n            {\n                return this.containingType;\n            } 239821"];
5383 [label="return this.containingType; 239822"];
5384 [label="if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                } 239823"];
5385 [label="ContainingType.IsScriptClass 239824"];
5386 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 239825"];
5387 [label="var kind = this.declaration.Declarations[0].Kind; 239826"];
5388 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 239827"];
5389 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 239828"];
5390 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 239829"];
5391 [label="type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator); 239830"];
5392 [label="binder.BindType(typeSyntax, diagnosticsForFirstDeclarator) 239831"];
5393 [label="param BindType(ExpressionSyntax syntax) 239832"];
5394 [label="param BindType(DiagnosticBag diagnostics) 239833"];
5395 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 239834"];
5396 [label="param BindType(bool suppressUseSiteDiagnostics = false) 239835"];
5397 [label="param BindType(this) 239836"];
5398 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 239837"];
5399 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 239838"];
5400 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 239839"];
5401 [label="var symbol = BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics); 239840"];
5402 [label="BindTypeOrAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics) 239841"];
5403 [label="param BindTypeOrAlias(ExpressionSyntax syntax) 239842"];
5404 [label="param BindTypeOrAlias(DiagnosticBag diagnostics) 239843"];
5405 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 239844"];
5406 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 239845"];
5407 [label="param BindTypeOrAlias(this) 239846"];
5408 [label="Debug.Assert(diagnostics != null); 239847"];
5409 [label="Debug.Assert(diagnostics != null); 239848"];
5410 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239849"];
5411 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239850"];
5412 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239851"];
5413 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239852"];
5414 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239853"];
5415 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239854"];
5416 [label="BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics) 239855"];
5417 [label="param BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax) 239856"];
5418 [label="param BindNamespaceOrTypeOrAliasSymbol(DiagnosticBag diagnostics) 239857"];
5419 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 239858"];
5420 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 239859"];
5421 [label="param BindNamespaceOrTypeOrAliasSymbol(this) 239860"];
5422 [label="switch (syntax.Kind())\n            {\n                case SyntaxKind.NullableType:\n                    return bindNullable(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.PredefinedType:\n                    return bindPredefined(syntax, diagnostics);\n\n                case SyntaxKind.IdentifierName:\n                    return BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol((IdentifierNameSyntax)syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics, qualifierOpt: null);\n\n                case SyntaxKind.GenericName:\n                    return BindGenericSimpleNamespaceOrTypeOrAliasSymbol((GenericNameSyntax)syntax, diagnostics, basesBeingResolved, qualifierOpt: null);\n\n                case SyntaxKind.AliasQualifiedName:\n                    return bindAlias(syntax, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n\n                case SyntaxKind.QualifiedName:\n                    {\n                        var node = (QualifiedNameSyntax)syntax;\n                        return BindQualifiedName(node.Left, node.Right, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.SimpleMemberAccessExpression:\n                    {\n                        var node = (MemberAccessExpressionSyntax)syntax;\n                        return BindQualifiedName(node.Expression, node.Name, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                case SyntaxKind.ArrayType:\n                    {\n                        return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true);\n                    }\n\n                case SyntaxKind.PointerType:\n                    return bindPointer(syntax, diagnostics, basesBeingResolved);\n\n                case SyntaxKind.FunctionPointerType:\n                    var functionPointerTypeSyntax = (FunctionPointerTypeSyntax)syntax;\n                    if (GetUnsafeDiagnosticInfo(sizeOfTypeOpt: null) is CSDiagnosticInfo info)\n                    {\n                        var @delegate = functionPointerTypeSyntax.DelegateKeyword;\n                        var asterisk = functionPointerTypeSyntax.AsteriskToken;\n                        RoslynDebug.Assert(@delegate.SyntaxTree is object);\n                        diagnostics.Add(info, Location.Create(@delegate.SyntaxTree, TextSpan.FromBounds(@delegate.SpanStart, asterisk.Span.End)));\n                    }\n\n                    return TypeWithAnnotations.Create(\n                        FunctionPointerTypeSymbol.CreateFromSource(\n                            functionPointerTypeSyntax,\n                            this,\n                            diagnostics,\n                            basesBeingResolved,\n                            suppressUseSiteDiagnostics));\n\n                case SyntaxKind.OmittedTypeArgument:\n                    {\n                        return BindTypeArgument((TypeSyntax)syntax, diagnostics, basesBeingResolved);\n                    }\n\n                case SyntaxKind.TupleType:\n                    {\n                        var tupleTypeSyntax = (TupleTypeSyntax)syntax;\n                        return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(tupleTypeSyntax.CloseParenToken), BindTupleType(tupleTypeSyntax, diagnostics, basesBeingResolved));\n                    }\n\n                case SyntaxKind.RefType:\n                    {\n                        // ref needs to be handled by the caller\n                        var refTypeSyntax = (RefTypeSyntax)syntax;\n                        var refToken = refTypeSyntax.RefKeyword;\n                        if (!syntax.HasErrors)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_UnexpectedToken, refToken.GetLocation(), refToken.ToString());\n                        }\n\n                        return BindNamespaceOrTypeOrAliasSymbol(refTypeSyntax.Type, diagnostics, basesBeingResolved, suppressUseSiteDiagnostics);\n                    }\n\n                default:\n                    {\n                        // This is invalid syntax for a type.  This arises when a constant pattern that fails to bind\n                        // is attempted to be bound as a type pattern.\n                        return createErrorType(syntax);\n                    }\n            } 239861"];
5423 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 239862"];
5424 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 239863"];
5425 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 239864"];
5426 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 239865"];
5427 [label="BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true) 239866"];
5428 [label="param BindArrayType(ArrayTypeSyntax node) 239867"];
5429 [label="param BindArrayType(DiagnosticBag diagnostics) 239868"];
5430 [label="param BindArrayType(bool permitDimensions) 239869"];
5431 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 239870"];
5432 [label="param BindArrayType(bool disallowRestrictedTypes) 239871"];
5433 [label="param BindArrayType(this) 239872"];
5434 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 239873"];
5435 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 239874"];
5436 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 239875"];
5437 [label="TypeWithAnnotations type = BindType(node.ElementType, diagnostics, basesBeingResolved); 239876"];
5438 [label="BindType(node.ElementType, diagnostics, basesBeingResolved) 239877"];
5439 [label="param BindType(ExpressionSyntax syntax) 239878"];
5440 [label="param BindType(DiagnosticBag diagnostics) 239879"];
5441 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 239880"];
5442 [label="param BindType(bool suppressUseSiteDiagnostics = false) 239881"];
5443 [label="param BindType(this) 239882"];
5444 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 239883"];
5445 [label="Debug.Assert(diagnostics != null); 239884"];
5446 [label="Debug.Assert(diagnostics != null); 239885"];
5447 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 239886"];
5448 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 239887"];
5449 [label="return bindPredefined(syntax, diagnostics); 239888"];
5450 [label="return bindPredefined(syntax, diagnostics); 239889"];
5451 [label="bindPredefined(syntax, diagnostics) 239890"];
5452 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 239891"];
5453 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 239892"];
5454 [label="NamespaceOrTypeOrAliasSymbolWithAnnotations bindPredefined(ExpressionSyntax syntax, DiagnosticBag diagnostics)\n            {\n                var predefinedType = (PredefinedTypeSyntax)syntax;\n                var type = BindPredefinedTypeSymbol(predefinedType, diagnostics);\n                return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type);\n            } 239893"];
5455 [label="var predefinedType = (PredefinedTypeSyntax)syntax; 239894"];
5456 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 239895"];
5457 [label="var type = BindPredefinedTypeSymbol(predefinedType, diagnostics); 239896"];
5458 [label="BindPredefinedTypeSymbol(predefinedType, diagnostics) 239897"];
5459 [label="param BindPredefinedTypeSymbol(PredefinedTypeSyntax node) 239898"];
5460 [label="param BindPredefinedTypeSymbol(DiagnosticBag diagnostics) 239899"];
5461 [label="param BindPredefinedTypeSymbol(this) 239900"];
5462 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 239901"];
5463 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 239902"];
5464 [label="return GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node); 239903"];
5465 [label="GetSpecialType(node.Keyword.Kind().GetSpecialType(), diagnostics, node) 239904"];
5466 [label="param GetSpecialType(SpecialType typeId) 239905"];
5467 [label="param GetSpecialType(DiagnosticBag diagnostics) 239906"];
5468 [label="param GetSpecialType(SyntaxNode node) 239907"];
5469 [label="param GetSpecialType(this) 239908"];
5470 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 239909"];
5471 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 239910"];
5472 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 239911"];
5473 [label="return GetSpecialType(this.Compilation, typeId, node, diagnostics); 239912"];
5474 [label="GetSpecialType(this.Compilation, typeId, node, diagnostics) 239913"];
5475 [label="param GetSpecialType(CSharpCompilation compilation) 239914"];
5476 [label="param GetSpecialType(SpecialType typeId) 239915"];
5477 [label="param GetSpecialType(SyntaxNode node) 239916"];
5478 [label="param GetSpecialType(DiagnosticBag diagnostics) 239917"];
5479 [label="NamedTypeSymbol typeSymbol = compilation.GetSpecialType(typeId); 239918"];
5480 [label="compilation.GetSpecialType(typeId) 239919"];
5481 [label="param GetSpecialType(SpecialType specialType) 239920"];
5482 [label="param GetSpecialType(this) 239921"];
5483 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 239922"];
5484 [label="NamedTypeSymbol result; 239923"];
5485 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 239924"];
5486 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 239925"];
5487 [label="Assembly 239926"];
5488 [label="GetBoundReferenceManager(); 239927"];
5489 [label="result = Assembly.GetSpecialType(specialType); 239928"];
5490 [label="result = Assembly.GetSpecialType(specialType); 239929"];
5491 [label="Assembly.GetSpecialType(specialType) 239930"];
5492 [label="param GetSpecialType(SpecialType type) 239931"];
5493 [label="param GetSpecialType(this) 239932"];
5494 [label="CorLibrary 239933"];
5495 [label="get\n            {\n                return _corLibrary;\n            } 239934"];
5496 [label="return CorLibrary.GetDeclaredSpecialType(type); 239935"];
5497 [label="return CorLibrary.GetDeclaredSpecialType(type); 239936"];
5498 [label="CorLibrary.GetDeclaredSpecialType(type) 239937"];
5499 [label="param GetDeclaredSpecialType(SpecialType type) 239938"];
5500 [label="param GetDeclaredSpecialType(this) 239939"];
5501 [label="this.Modules 239940"];
5502 [label="get\n            {\n                return _modules;\n            } 239941"];
5503 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 239942"];
5504 [label="module.GetReferencedAssemblies() 239943"];
5505 [label="param GetReferencedAssemblies(this) 239944"];
5506 [label="AssertReferencesInitialized() 239945"];
5507 [label="param AssertReferencesInitialized(this) 239946"];
5508 [label="Debug.Assert(_moduleReferences != null); 239947"];
5509 [label="Debug.Assert(_moduleReferences != null); 239948"];
5510 [label="AssertReferencesInitialized(); 239949"];
5511 [label="return _moduleReferences.Identities; 239950"];
5512 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 239951"];
5513 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 239952"];
5514 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 239953"];
5515 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 239954"];
5516 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 239955"];
5517 [label="MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true); 239956"];
5518 [label="this.Modules 239957"];
5519 [label="ModuleSymbol module = this.Modules[0]; 239958"];
5520 [label="ModuleSymbol module = this.Modules[0]; 239959"];
5521 [label="NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName); 239960"];
5522 [label="module.LookupTopLevelMetadataType(ref emittedName) 239961"];
5523 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 239962"];
5524 [label="param LookupTopLevelMetadataType(this) 239963"];
5525 [label="NamedTypeSymbol result; 239964"];
5526 [label="this.GlobalNamespace 239965"];
5527 [label="get { return _globalNamespace; } 239966"];
5528 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 239967"];
5529 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 239968"];
5530 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 239969"];
5531 [label="param LookupNestedNamespace(ImmutableArray<string> names) 239970"];
5532 [label="param LookupNestedNamespace(this) 239971"];
5533 [label="NamespaceSymbol scope = this; 239972"];
5534 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 239973"];
5535 [label="NamespaceSymbol nextScope = null; 239974"];
5536 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 239975"];
5537 [label="scope.GetMembers(name) 239976"];
5538 [label="param GetMembers(string name) 239977"];
5539 [label="param GetMembers(this) 239978"];
5540 [label="EnsureAllMembersLoaded() 239979"];
5541 [label="param EnsureAllMembersLoaded(this) 239980"];
5542 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 239981"];
5543 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 239982"];
5544 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 239983"];
5545 [label="_moduleSymbol.Module 239984"];
5546 [label="get\n            {\n                return _module;\n            } 239985"];
5547 [label="return _module; 239986"];
5548 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 239987"];
5549 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 239988"];
5550 [label="LoadAllMembers(groups); 239989"];
5551 [label="LoadAllMembers(groups) 239990"];
5552 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 239991"];
5553 [label="param LoadAllMembers(this) 239992"];
5554 [label="Debug.Assert(typesByNS != null); 239993"];
5555 [label="Debug.Assert(typesByNS != null); 239994"];
5556 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 239995"];
5557 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 239996"];
5558 [label="this.IsGlobalNamespace 239997"];
5559 [label="get\n            {\n                return true;\n            } 239998"];
5560 [label="return true; 239999"];
5561 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 240000"];
5562 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240001"];
5563 [label="isGlobalNamespace 240002"];
5564 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240003"];
5565 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240004"];
5566 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240005"];
5567 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240006"];
5568 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240007"];
5569 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240008"];
5570 [label="LazyInitializeNamespaces(nestedNamespaces); 240009"];
5571 [label="LazyInitializeNamespaces(nestedNamespaces) 240010"];
5572 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 240011"];
5573 [label="param LazyInitializeNamespaces(this) 240012"];
5574 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 240013"];
5575 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 240014"];
5576 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 240015"];
5577 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 240016"];
5578 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 240017"];
5579 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 240018"];
5580 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 240019"];
5581 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 240020"];
5582 [label="param PENestedNamespaceSymbol(string name) 240021"];
5583 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 240022"];
5584 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 240023"];
5585 [label="param PENestedNamespaceSymbol(this) 240024"];
5586 [label="param PENestedNamespaceSymbol(this) 240025"];
5587 [label="_containingNamespaceSymbol 240026"];
5588 [label="_name 240027"];
5589 [label="_typesByNS 240028"];
5590 [label="Debug.Assert(name != null); 240029"];
5591 [label="Debug.Assert(name != null); 240030"];
5592 [label="Debug.Assert((object)containingNamespace != null); 240031"];
5593 [label="Debug.Assert((object)containingNamespace != null); 240032"];
5594 [label="Debug.Assert(typesByNS != null); 240033"];
5595 [label="Debug.Assert(typesByNS != null); 240034"];
5596 [label="_containingNamespaceSymbol 240035"];
5597 [label="_name 240036"];
5598 [label="_typesByNS 240037"];
5599 [label="c.Name 240038"];
5600 [label="get\n            {\n                return _name;\n            } 240039"];
5601 [label="return _name; 240040"];
5602 [label="namespaces.Add(c.Name, c); 240041"];
5603 [label="namespaces.Add(c.Name, c); 240042"];
5604 [label="namespaces.Add(c.Name, c); 240043"];
5605 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 240044"];
5606 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 240045"];
5607 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 240046"];
5608 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 240047"];
5609 [label="LazyInitializeNamespaces(nestedNamespaces); 240048"];
5610 [label="LazyInitializeTypes(nestedTypes); 240049"];
5611 [label="LazyInitializeTypes(nestedTypes) 240050"];
5612 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 240051"];
5613 [label="param LazyInitializeTypes(this) 240052"];
5614 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 240053"];
5615 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 240054"];
5616 [label="ContainingPEModule 240055"];
5617 [label="get\n            {\n                return _moduleSymbol;\n            } 240056"];
5618 [label="return _moduleSymbol; 240057"];
5619 [label="var moduleSymbol = ContainingPEModule; 240058"];
5620 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 240059"];
5621 [label="moduleSymbol.Module 240060"];
5622 [label="get\n            {\n                return _module;\n            } 240061"];
5623 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 240062"];
5624 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 240063"];
5625 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 240064"];
5626 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 240065"];
5627 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 240066"];
5628 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 240067"];
5629 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240068"];
5630 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240069"];
5631 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240070"];
5632 [label="EmptyComparer.Instance 240071"];
5633 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 240072"];
5634 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 240073"];
5635 [label="new UncommonProperties() 240074"];
5636 [label="param UncommonProperties(this) 240075"];
5637 [label="lazyEnumUnderlyingType 240076"];
5638 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 240077"];
5639 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 240078"];
5640 [label="lazyContainsExtensionMethods 240079"];
5641 [label="lazyIsByRefLike 240080"];
5642 [label="lazyIsReadOnly 240081"];
5643 [label="lazyDefaultMemberName 240082"];
5644 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 240083"];
5645 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 240084"];
5646 [label="s_noUncommonProperties = new UncommonProperties() 240085"];
5647 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240086"];
5648 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 240087"];
5649 [label="param Create(PEModuleSymbol moduleSymbol) 240088"];
5650 [label="param Create(PENamespaceSymbol containingNamespace) 240089"];
5651 [label="param Create(TypeDefinitionHandle handle) 240090"];
5652 [label="param Create(string emittedNamespaceName) 240091"];
5653 [label="GenericParameterHandleCollection genericParameterHandles; 240092"];
5654 [label="genericParameterHandles 240093"];
5655 [label="ushort arity; 240094"];
5656 [label="BadImageFormatException mrEx = null; 240095"];
5657 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240096"];
5658 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240097"];
5659 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240098"];
5660 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240099"];
5661 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240100"];
5662 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 240101"];
5663 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 240102"];
5664 [label="param GetGenericInfo(TypeDefinitionHandle handle) 240103"];
5665 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240104"];
5666 [label="param GetGenericInfo(out ushort arity) 240105"];
5667 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240106"];
5668 [label="moduleSymbol.Module 240107"];
5669 [label="get\n            {\n                return _module;\n            } 240108"];
5670 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 240109"];
5671 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 240110"];
5672 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 240111"];
5673 [label="arity = (ushort)genericParameterHandles.Count; 240112"];
5674 [label="mrEx = null; 240113"];
5675 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 240114"];
5676 [label="bool mangleName; 240115"];
5677 [label="PENamedTypeSymbol result; 240116"];
5678 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 240117"];
5679 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 240118"];
5680 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240119"];
5681 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240120"];
5682 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240121"];
5683 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240122"];
5684 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240123"];
5685 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 240124"];
5686 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 240125"];
5687 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 240126"];
5688 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 240127"];
5689 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 240128"];
5690 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 240129"];
5691 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240130"];
5692 [label="param PENamedTypeSymbolNonGeneric(this) 240131"];
5693 [label="moduleSymbol 240132"];
5694 [label="container 240133"];
5695 [label="handle 240134"];
5696 [label="emittedNamespaceName 240135"];
5697 [label="0 240136"];
5698 [label="mangleName 240137"];
5699 [label="param PENamedTypeSymbolNonGeneric(this) 240138"];
5700 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 240139"];
5701 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 240140"];
5702 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 240141"];
5703 [label="param PENamedTypeSymbol(string emittedNamespaceName) 240142"];
5704 [label="param PENamedTypeSymbol(ushort arity) 240143"];
5705 [label="param PENamedTypeSymbol(out bool mangleName) 240144"];
5706 [label="param PENamedTypeSymbol(this) 240145"];
5707 [label="param PENamedTypeSymbol(this) 240146"];
5708 [label="param NamedTypeSymbol(this) 240147"];
5709 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 240148"];
5710 [label="param NamedTypeSymbol(this) 240149"];
5711 [label="param TypeSymbol(this) 240150"];
5712 [label="param TypeSymbol(this) 240151"];
5713 [label="_lazyAbstractMembers 240152"];
5714 [label="_lazyInterfaceInfo 240153"];
5715 [label="_lazyAdapter 240154"];
5716 [label="_hasNoBaseCycles 240155"];
5717 [label="_lazyTupleData 240156"];
5718 [label="_lazyTupleData 240157"];
5719 [label="_container 240158"];
5720 [label="_name 240159"];
5721 [label="_flags 240160"];
5722 [label="_corTypeId 240161"];
5723 [label="_lazyMemberNames 240162"];
5724 [label="_lazyMembersByName 240163"];
5725 [label="_lazyNestedTypes 240164"];
5726 [label="_lazyKind 240165"];
5727 [label="_lazyNullableContextValue 240166"];
5728 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 240167"];
5729 [label="default(ImmutableArray<NamedTypeSymbol>) 240168"];
5730 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 240169"];
5731 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 240170"];
5732 [label="default(ImmutableArray<NamedTypeSymbol>) 240171"];
5733 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 240172"];
5734 [label="_lazyDocComment 240173"];
5735 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 240174"];
5736 [label="_lazyUncommonProperties 240175"];
5737 [label="public IEnumerable<object> fieldDefs { get; set; } 240176"];
5738 [label="Debug.Assert(!handle.IsNil); 240177"];
5739 [label="Debug.Assert((object)container != null); 240178"];
5740 [label="Debug.Assert((object)container != null); 240179"];
5741 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240180"];
5742 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240181"];
5743 [label="string metadataName; 240182"];
5744 [label="bool makeBad = false; 240183"];
5745 [label="moduleSymbol.Module 240184"];
5746 [label="get\n            {\n                return _module;\n            } 240185"];
5747 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 240186"];
5748 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 240187"];
5749 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 240188"];
5750 [label="_handle 240189"];
5751 [label="_container 240190"];
5752 [label="moduleSymbol.Module 240191"];
5753 [label="get\n            {\n                return _module;\n            } 240192"];
5754 [label="return _module; 240193"];
5755 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 240194"];
5756 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 240195"];
5757 [label="_flags 240196"];
5758 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 240197"];
5759 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 240198"];
5760 [label="_name 240199"];
5761 [label="mangleName = false; 240200"];
5762 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240201"];
5763 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240202"];
5764 [label="moduleSymbol.ContainingAssembly 240203"];
5765 [label="get\n            {\n                return _assemblySymbol;\n            } 240204"];
5766 [label="return _assemblySymbol; 240205"];
5767 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240206"];
5768 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 240207"];
5769 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 240208"];
5770 [label="this.CorLibrary 240209"];
5771 [label="get\n            {\n                return _corLibrary;\n            } 240210"];
5772 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 240211"];
5773 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 240212"];
5774 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 240213"];
5775 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240214"];
5776 [label="this.DeclaredAccessibility 240215"];
5777 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 240216"];
5778 [label="Accessibility access = Accessibility.Private; 240217"];
5779 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 240218"];
5780 [label="access = Accessibility.Internal; 240219"];
5781 [label="return access; 240220"];
5782 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240221"];
5783 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240222"];
5784 [label="_corTypeId 240223"];
5785 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240224"];
5786 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240225"];
5787 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240226"];
5788 [label="return result; 240227"];
5789 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240228"];
5790 [label="GenericParameterHandleCollection genericParameterHandles; 240229"];
5791 [label="genericParameterHandles 240230"];
5792 [label="ushort arity; 240231"];
5793 [label="BadImageFormatException mrEx = null; 240232"];
5794 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240233"];
5795 [label="param GetGenericInfo(out ushort arity) 240234"];
5796 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240235"];
5797 [label="mrEx = null; 240236"];
5798 [label="bool mangleName; 240237"];
5799 [label="PENamedTypeSymbol result; 240238"];
5800 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240239"];
5801 [label="mangleName 240240"];
5802 [label="param PENamedTypeSymbol(out bool mangleName) 240241"];
5803 [label="_lazyTupleData 240242"];
5804 [label="_container 240243"];
5805 [label="_name 240244"];
5806 [label="_flags 240245"];
5807 [label="_corTypeId 240246"];
5808 [label="Debug.Assert(!handle.IsNil); 240247"];
5809 [label="Debug.Assert((object)container != null); 240248"];
5810 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240249"];
5811 [label="string metadataName; 240250"];
5812 [label="bool makeBad = false; 240251"];
5813 [label="mangleName = false; 240252"];
5814 [label="Accessibility access = Accessibility.Private; 240253"];
5815 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240254"];
5816 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240255"];
5817 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240256"];
5818 [label="GenericParameterHandleCollection genericParameterHandles; 240257"];
5819 [label="genericParameterHandles 240258"];
5820 [label="ushort arity; 240259"];
5821 [label="BadImageFormatException mrEx = null; 240260"];
5822 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240261"];
5823 [label="param GetGenericInfo(out ushort arity) 240262"];
5824 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240263"];
5825 [label="mrEx = null; 240264"];
5826 [label="PENamedTypeSymbol result; 240265"];
5827 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240266"];
5828 [label="mangleName 240267"];
5829 [label="param PENamedTypeSymbol(out bool mangleName) 240268"];
5830 [label="Debug.Assert(!handle.IsNil); 240269"];
5831 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240270"];
5832 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240271"];
5833 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240272"];
5834 [label="mangleName 240273"];
5835 [label="param PENamedTypeSymbol(out bool mangleName) 240274"];
5836 [label="_lazyTupleData 240275"];
5837 [label="_container 240276"];
5838 [label="_name 240277"];
5839 [label="_flags 240278"];
5840 [label="_corTypeId 240279"];
5841 [label="Debug.Assert(!handle.IsNil); 240280"];
5842 [label="Debug.Assert((object)container != null); 240281"];
5843 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240282"];
5844 [label="string metadataName; 240283"];
5845 [label="bool makeBad = false; 240284"];
5846 [label="mangleName = false; 240285"];
5847 [label="Accessibility access = Accessibility.Private; 240286"];
5848 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240287"];
5849 [label="genericParameterHandles 240288"];
5850 [label="ushort arity; 240289"];
5851 [label="BadImageFormatException mrEx = null; 240290"];
5852 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240291"];
5853 [label="param GetGenericInfo(out ushort arity) 240292"];
5854 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240293"];
5855 [label="mrEx = null; 240294"];
5856 [label="PENamedTypeSymbol result; 240295"];
5857 [label="Debug.Assert(!handle.IsNil); 240296"];
5858 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240297"];
5859 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240298"];
5860 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240299"];
5861 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240300"];
5862 [label="mangleName 240301"];
5863 [label="param PENamedTypeSymbol(out bool mangleName) 240302"];
5864 [label="_lazyTupleData 240303"];
5865 [label="_container 240304"];
5866 [label="_name 240305"];
5867 [label="_flags 240306"];
5868 [label="_corTypeId 240307"];
5869 [label="Debug.Assert(!handle.IsNil); 240308"];
5870 [label="Debug.Assert((object)container != null); 240309"];
5871 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240310"];
5872 [label="string metadataName; 240311"];
5873 [label="bool makeBad = false; 240312"];
5874 [label="mangleName = false; 240313"];
5875 [label="Accessibility access = Accessibility.Private; 240314"];
5876 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240315"];
5877 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 240316"];
5878 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 240317"];
5879 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 240318"];
5880 [label="get\n            {\n                return _name;\n            } 240319"];
5881 [label="return _name; 240320"];
5882 [label="children.Free(); 240321"];
5883 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 240322"];
5884 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 240323"];
5885 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 240324"];
5886 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 240325"];
5887 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 240326"];
5888 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 240327"];
5889 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 240328"];
5890 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 240329"];
5891 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 240330"];
5892 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 240331"];
5893 [label="param OnNewTypeDeclarationsLoaded(this) 240332"];
5894 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 240333"];
5895 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 240334"];
5896 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 240335"];
5897 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 240336"];
5898 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 240337"];
5899 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 240338"];
5900 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 240339"];
5901 [label="bool added; 240340"];
5902 [label="type.Handle 240341"];
5903 [label="get\n            {\n                return _handle;\n            } 240342"];
5904 [label="return _handle; 240343"];
5905 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 240344"];
5906 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 240345"];
5907 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 240346"];
5908 [label="Debug.Assert(added); 240347"];
5909 [label="type.SpecialType 240348"];
5910 [label="get\n            {\n                return _corTypeId;\n            } 240349"];
5911 [label="return _corTypeId; 240350"];
5912 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240351"];
5913 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240352"];
5914 [label="bool added; 240353"];
5915 [label="Debug.Assert(added); 240354"];
5916 [label="type.SpecialType 240355"];
5917 [label="get\n            {\n                return _corTypeId;\n            } 240356"];
5918 [label="return _corTypeId; 240357"];
5919 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240358"];
5920 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240359"];
5921 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 240360"];
5922 [label="LazyInitializeTypes(nestedTypes); 240361"];
5923 [label="LoadAllMembers(groups); 240362"];
5924 [label="EnsureAllMembersLoaded(); 240363"];
5925 [label="PENestedNamespaceSymbol ns = null; 240364"];
5926 [label="ImmutableArray<PENamedTypeSymbol> t; 240365"];
5927 [label="t 240366"];
5928 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 240367"];
5929 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 240368"];
5930 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 240369"];
5931 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 240370"];
5932 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 240371"];
5933 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 240372"];
5934 [label="return ImmutableArray.Create<Symbol>(ns); 240373"];
5935 [label="var ns = symbol as NamespaceSymbol; 240374"];
5936 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 240375"];
5937 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 240376"];
5938 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 240377"];
5939 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 240378"];
5940 [label="nextScope = ns; 240379"];
5941 [label="scope = nextScope; 240380"];
5942 [label="if ((object)scope == null)\n                {\n                    break;\n                } 240381"];
5943 [label="if ((object)scope == null)\n                {\n                    break;\n                } 240382"];
5944 [label="return scope; 240383"];
5945 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 240384"];
5946 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 240385"];
5947 [label="result = scope.LookupMetadataType(ref emittedName); 240386"];
5948 [label="scope.LookupMetadataType(ref emittedName) 240387"];
5949 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 240388"];
5950 [label="param LookupMetadataType(this) 240389"];
5951 [label="Debug.Assert(!emittedTypeName.IsNull); 240390"];
5952 [label="NamespaceOrTypeSymbol scope = this; 240391"];
5953 [label="scope.Kind 240392"];
5954 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240393"];
5955 [label="return SymbolKind.Namespace; 240394"];
5956 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 240395"];
5957 [label="NamedTypeSymbol? namedType = null; 240396"];
5958 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 240397"];
5959 [label="namespaceOrTypeMembers 240398"];
5960 [label="scope.IsNamespace 240399"];
5961 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 240400"];
5962 [label="Kind 240401"];
5963 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240402"];
5964 [label="return SymbolKind.Namespace; 240403"];
5965 [label="return Kind == SymbolKind.Namespace; 240404"];
5966 [label="bool isTopLevel = scope.IsNamespace; 240405"];
5967 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 240406"];
5968 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 240407"];
5969 [label="param ToDisplayString(SymbolDisplayFormat format = null) 240408"];
5970 [label="param ToDisplayString(this) 240409"];
5971 [label="ISymbol 240410"];
5972 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 240411"];
5973 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 240412"];
5974 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 240413"];
5975 [label="CreateISymbol() 240414"];
5976 [label="param CreateISymbol(this) 240415"];
5977 [label="return new PublicModel.NamespaceSymbol(this); 240416"];
5978 [label="return new PublicModel.NamespaceSymbol(this); 240417"];
5979 [label="new PublicModel.NamespaceSymbol(this) 240418"];
5980 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 240419"];
5981 [label="param NamespaceSymbol(this) 240420"];
5982 [label="param NamespaceSymbol(this) 240421"];
5983 [label="param NamespaceOrTypeSymbol(this) 240422"];
5984 [label="param NamespaceOrTypeSymbol(this) 240423"];
5985 [label="param Symbol(this) 240424"];
5986 [label="_underlying 240425"];
5987 [label="Debug.Assert(underlying is object); 240426"];
5988 [label="_underlying 240427"];
5989 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 240428"];
5990 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 240429"];
5991 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 240430"];
5992 [label="return _lazyISymbol; 240431"];
5993 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 240432"];
5994 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 240433"];
5995 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 240434"];
5996 [label="param ToDisplayString(ISymbol symbol) 240435"];
5997 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 240436"];
5998 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 240437"];
5999 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 240438"];
6000 [label="ToDisplayParts(symbol, format) 240439"];
6001 [label="param ToDisplayParts(ISymbol symbol) 240440"];
6002 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 240441"];
6003 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 240442"];
6004 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 240443"];
6005 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 240444"];
6006 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 240445"];
6007 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 240446"];
6008 [label="param ToDisplayParts(ISymbol symbol) 240447"];
6009 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 240448"];
6010 [label="param ToDisplayParts(int positionOpt) 240449"];
6011 [label="param ToDisplayParts(SymbolDisplayFormat format) 240450"];
6012 [label="param ToDisplayParts(bool minimal) 240451"];
6013 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 240452"];
6014 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 240453"];
6015 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 240454"];
6016 [label="Debug.Assert(semanticModelOpt == null); 240455"];
6017 [label="Debug.Assert(semanticModelOpt == null); 240456"];
6018 [label="Debug.Assert(positionOpt < 0); 240457"];
6019 [label="Debug.Assert(positionOpt < 0); 240458"];
6020 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 240459"];
6021 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 240460"];
6022 [label="'modopt' 240461"];
6023 [label="IL_KEYWORD_MODOPT = 'modopt' 240462"];
6024 [label="'modreq' 240463"];
6025 [label="IL_KEYWORD_MODREQ = 'modreq' 240464"];
6026 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 240465"];
6027 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 240466"];
6028 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 240467"];
6029 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 240468"];
6030 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 240469"];
6031 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 240470"];
6032 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 240471"];
6033 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 240472"];
6034 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 240473"];
6035 [label="param SymbolDisplayVisitor(int positionOpt) 240474"];
6036 [label="param SymbolDisplayVisitor(this) 240475"];
6037 [label="builder 240476"];
6038 [label="format 240477"];
6039 [label="true 240478"];
6040 [label="semanticModelOpt 240479"];
6041 [label="positionOpt 240480"];
6042 [label="param SymbolDisplayVisitor(this) 240481"];
6043 [label="param SymbolDisplayVisitor(this) 240482"];
6044 [label="_escapeKeywordIdentifiers 240483"];
6045 [label="_lazyAliasMap 240484"];
6046 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 240485"];
6047 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 240486"];
6048 [label="_escapeKeywordIdentifiers 240487"];
6049 [label="symbol.Accept(visitor); 240488"];
6050 [label="symbol.Accept(visitor) 240489"];
6051 [label="param Accept(SymbolVisitor visitor) 240490"];
6052 [label="param Accept(this) 240491"];
6053 [label="Accept(visitor); 240492"];
6054 [label="Accept(visitor) 240493"];
6055 [label="param Accept(SymbolVisitor visitor) 240494"];
6056 [label="param Accept(this) 240495"];
6057 [label="visitor.VisitNamespace(this); 240496"];
6058 [label="visitor.VisitNamespace(this) 240497"];
6059 [label="param VisitNamespace(INamespaceSymbol symbol) 240498"];
6060 [label="param VisitNamespace(this) 240499"];
6061 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 240500"];
6062 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 240501"];
6063 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 240502"];
6064 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 240503"];
6065 [label="symbol.ContainingNamespace 240504"];
6066 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 240505"];
6067 [label="UnderlyingSymbol 240506"];
6068 [label="=> _underlying 240507"];
6069 [label="_underlying 240508"];
6070 [label="UnderlyingSymbol.ContainingNamespace 240509"];
6071 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 240510"];
6072 [label="this.ContainingSymbol 240511"];
6073 [label="get { return _containingNamespaceSymbol; } 240512"];
6074 [label="return _containingNamespaceSymbol; 240513"];
6075 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 240514"];
6076 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 240515"];
6077 [label="var ns = container as NamespaceSymbol; 240516"];
6078 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 240517"];
6079 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 240518"];
6080 [label="return ns; 240519"];
6081 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 240520"];
6082 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 240521"];
6083 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 240522"];
6084 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 240523"];
6085 [label="param GetPublicSymbol(this Symbol? symbol) 240524"];
6086 [label=".ISymbol 240525"];
6087 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 240526"];
6088 [label="param NamespaceOrTypeSymbol(this) 240527"];
6089 [label="param Symbol(this) 240528"];
6090 [label="_underlying 240529"];
6091 [label="Debug.Assert(underlying is object); 240530"];
6092 [label="return (TISymbol?)symbol?.ISymbol; 240531"];
6093 [label="var containingNamespace = symbol.ContainingNamespace; 240532"];
6094 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 240533"];
6095 [label="ShouldVisitNamespace(containingNamespace) 240534"];
6096 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 240535"];
6097 [label="param ShouldVisitNamespace(this) 240536"];
6098 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 240537"];
6099 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 240538"];
6100 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 240539"];
6101 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 240540"];
6102 [label="namespaceSymbol.IsGlobalNamespace 240541"];
6103 [label="=> _underlying.IsGlobalNamespace 240542"];
6104 [label="_underlying.IsGlobalNamespace 240543"];
6105 [label="get\n            {\n                return true;\n            } 240544"];
6106 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 240545"];
6107 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 240546"];
6108 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 240547"];
6109 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 240548"];
6110 [label="symbol.IsGlobalNamespace 240549"];
6111 [label="=> _underlying.IsGlobalNamespace 240550"];
6112 [label="_underlying.IsGlobalNamespace 240551"];
6113 [label="get\n            {\n                return false;\n            } 240552"];
6114 [label="return false; 240553"];
6115 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 240554"];
6116 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 240555"];
6117 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 240556"];
6118 [label="symbol.Name 240557"];
6119 [label="=> UnderlyingSymbol.Name 240558"];
6120 [label="UnderlyingSymbol 240559"];
6121 [label="=> _underlying 240560"];
6122 [label="_underlying 240561"];
6123 [label="UnderlyingSymbol.Name 240562"];
6124 [label="get\n            {\n                return _name;\n            } 240563"];
6125 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 240564"];
6126 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 240565"];
6127 [label="param CreatePart(SymbolDisplayPartKind kind) 240566"];
6128 [label="param CreatePart(ISymbol symbol) 240567"];
6129 [label="param CreatePart(string text) 240568"];
6130 [label="param CreatePart(this) 240569"];
6131 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 240570"];
6132 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 240571"];
6133 [label="(text == null) 240572"];
6134 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 240573"];
6135 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 240574"];
6136 [label="return new SymbolDisplayPart(kind, symbol, text); 240575"];
6137 [label="return new SymbolDisplayPart(kind, symbol, text); 240576"];
6138 [label="return new SymbolDisplayPart(kind, symbol, text); 240577"];
6139 [label="return new SymbolDisplayPart(kind, symbol, text); 240578"];
6140 [label="visitor.VisitNamespace(this); 240579"];
6141 [label="Accept(visitor); 240580"];
6142 [label="symbol.Accept(visitor); 240581"];
6143 [label="return builder.ToImmutableAndFree(); 240582"];
6144 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 240583"];
6145 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 240584"];
6146 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 240585"];
6147 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 240586"];
6148 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 240587"];
6149 [label="int forcedArity = emittedTypeName.ForcedArity; 240588"];
6150 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 240589"];
6151 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 240590"];
6152 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 240591"];
6153 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 240592"];
6154 [label="forcedArity = 0; 240593"];
6155 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 240594"];
6156 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 240595"];
6157 [label="param GetTypeMembers(string name) 240596"];
6158 [label="param GetTypeMembers(this) 240597"];
6159 [label="EnsureAllMembersLoaded() 240598"];
6160 [label="param EnsureAllMembersLoaded(this) 240599"];
6161 [label="var typesByNS = _typesByNS; 240600"];
6162 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 240601"];
6163 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 240602"];
6164 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 240603"];
6165 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 240604"];
6166 [label="LoadAllMembers(typesByNS); 240605"];
6167 [label="LoadAllMembers(typesByNS) 240606"];
6168 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 240607"];
6169 [label="Debug.Assert(typesByNS != null); 240608"];
6170 [label="Debug.Assert(typesByNS != null); 240609"];
6171 [label="get\n            {\n                return false;\n            } 240610"];
6172 [label="GetQualifiedNameLength() 240611"];
6173 [label="param GetQualifiedNameLength(this) 240612"];
6174 [label="this.Name 240613"];
6175 [label="get\n            {\n                return _name;\n            } 240614"];
6176 [label="int length = this.Name.Length; 240615"];
6177 [label="ContainingNamespace 240616"];
6178 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 240617"];
6179 [label="var parent = ContainingNamespace; 240618"];
6180 [label=".IsGlobalNamespace 240619"];
6181 [label="get\n            {\n                return true;\n            } 240620"];
6182 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 240621"];
6183 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 240622"];
6184 [label="return length; 240623"];
6185 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 240624"];
6186 [label="_containingNamespaceSymbol 240625"];
6187 [label="_name 240626"];
6188 [label="_typesByNS 240627"];
6189 [label="Debug.Assert(name != null); 240628"];
6190 [label="Debug.Assert((object)containingNamespace != null); 240629"];
6191 [label="Debug.Assert(typesByNS != null); 240630"];
6192 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240631"];
6193 [label="_containingNamespaceSymbol.ContainingPEModule 240632"];
6194 [label="get\n            {\n                return _moduleSymbol;\n            } 240633"];
6195 [label="return _containingNamespaceSymbol.ContainingPEModule; 240634"];
6196 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 240635"];
6197 [label="genericParameterHandles 240636"];
6198 [label="BadImageFormatException mrEx = null; 240637"];
6199 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240638"];
6200 [label="param GetGenericInfo(out ushort arity) 240639"];
6201 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240640"];
6202 [label="mrEx = null; 240641"];
6203 [label="PENamedTypeSymbol result; 240642"];
6204 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240643"];
6205 [label="mangleName 240644"];
6206 [label="param PENamedTypeSymbol(out bool mangleName) 240645"];
6207 [label="_lazyTupleData 240646"];
6208 [label="_container 240647"];
6209 [label="_name 240648"];
6210 [label="_flags 240649"];
6211 [label="_corTypeId 240650"];
6212 [label="Debug.Assert(!handle.IsNil); 240651"];
6213 [label="Debug.Assert((object)container != null); 240652"];
6214 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240653"];
6215 [label="string metadataName; 240654"];
6216 [label="bool makeBad = false; 240655"];
6217 [label="mangleName = false; 240656"];
6218 [label="Accessibility access = Accessibility.Private; 240657"];
6219 [label="access = Accessibility.Public; 240658"];
6220 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 240659"];
6221 [label="_corTypeId 240660"];
6222 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240661"];
6223 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240662"];
6224 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240663"];
6225 [label="genericParameterHandles 240664"];
6226 [label="BadImageFormatException mrEx = null; 240665"];
6227 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240666"];
6228 [label="param GetGenericInfo(out ushort arity) 240667"];
6229 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240668"];
6230 [label="mrEx = null; 240669"];
6231 [label="PENamedTypeSymbol result; 240670"];
6232 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240671"];
6233 [label="mangleName 240672"];
6234 [label="param PENamedTypeSymbol(out bool mangleName) 240673"];
6235 [label="_lazyTupleData 240674"];
6236 [label="_container 240675"];
6237 [label="_name 240676"];
6238 [label="_flags 240677"];
6239 [label="_corTypeId 240678"];
6240 [label="Debug.Assert(!handle.IsNil); 240679"];
6241 [label="Debug.Assert((object)container != null); 240680"];
6242 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240681"];
6243 [label="string metadataName; 240682"];
6244 [label="bool makeBad = false; 240683"];
6245 [label="mangleName = false; 240684"];
6246 [label="Accessibility access = Accessibility.Private; 240685"];
6247 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240686"];
6248 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240687"];
6249 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240688"];
6250 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240689"];
6251 [label="param GetGenericInfo(out ushort arity) 240690"];
6252 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240691"];
6253 [label="mangleName 240692"];
6254 [label="param PENamedTypeSymbol(out bool mangleName) 240693"];
6255 [label="_lazyTupleData 240694"];
6256 [label="_container 240695"];
6257 [label="_name 240696"];
6258 [label="_flags 240697"];
6259 [label="_corTypeId 240698"];
6260 [label="Debug.Assert(!handle.IsNil); 240699"];
6261 [label="Debug.Assert((object)container != null); 240700"];
6262 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240701"];
6263 [label="string metadataName; 240702"];
6264 [label="bool makeBad = false; 240703"];
6265 [label="mangleName = false; 240704"];
6266 [label="Accessibility access = Accessibility.Private; 240705"];
6267 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240706"];
6268 [label="genericParameterHandles 240707"];
6269 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240708"];
6270 [label="param GetGenericInfo(out ushort arity) 240709"];
6271 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240710"];
6272 [label="mrEx = null; 240711"];
6273 [label="PENamedTypeSymbol result; 240712"];
6274 [label="Debug.Assert(!handle.IsNil); 240713"];
6275 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240714"];
6276 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240715"];
6277 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 240716"];
6278 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 240717"];
6279 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 240718"];
6280 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 240719"];
6281 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 240720"];
6282 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 240721"];
6283 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 240722"];
6284 [label="param PENamedTypeSymbolGeneric(ushort arity) 240723"];
6285 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 240724"];
6286 [label="param PENamedTypeSymbolGeneric(this) 240725"];
6287 [label="moduleSymbol 240726"];
6288 [label="container 240727"];
6289 [label="handle 240728"];
6290 [label="emittedNamespaceName 240729"];
6291 [label="arity 240730"];
6292 [label="mangleName 240731"];
6293 [label="param PENamedTypeSymbolGeneric(this) 240732"];
6294 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 240733"];
6295 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 240734"];
6296 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 240735"];
6297 [label="param PENamedTypeSymbol(string emittedNamespaceName) 240736"];
6298 [label="param PENamedTypeSymbol(ushort arity) 240737"];
6299 [label="param PENamedTypeSymbol(out bool mangleName) 240738"];
6300 [label="_lazyTupleData 240739"];
6301 [label="_container 240740"];
6302 [label="_name 240741"];
6303 [label="_flags 240742"];
6304 [label="_corTypeId 240743"];
6305 [label="Debug.Assert(!handle.IsNil); 240744"];
6306 [label="Debug.Assert((object)container != null); 240745"];
6307 [label="Debug.Assert((object)container != null); 240746"];
6308 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240747"];
6309 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240748"];
6310 [label="string metadataName; 240749"];
6311 [label="bool makeBad = false; 240750"];
6312 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 240751"];
6313 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 240752"];
6314 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 240753"];
6315 [label="_name 240754"];
6316 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 240755"];
6317 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 240756"];
6318 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 240757"];
6319 [label="mangleName = !ReferenceEquals(_name, metadataName); 240758"];
6320 [label="mangleName = !ReferenceEquals(_name, metadataName); 240759"];
6321 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 240760"];
6322 [label="Accessibility access = Accessibility.Private; 240761"];
6323 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240762"];
6324 [label="_arity 240763"];
6325 [label="_mangleName 240764"];
6326 [label="Debug.Assert(genericParameterHandles.Count > 0); 240765"];
6327 [label="Debug.Assert(genericParameterHandles.Count > 0); 240766"];
6328 [label="_arity 240767"];
6329 [label="_genericParameterHandles 240768"];
6330 [label="_mangleName 240769"];
6331 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 240770"];
6332 [label="genericParameterHandles 240771"];
6333 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 240772"];
6334 [label="param GetGenericInfo(out ushort arity) 240773"];
6335 [label="param GetGenericInfo(out BadImageFormatException mrEx) 240774"];
6336 [label="mrEx = null; 240775"];
6337 [label="PENamedTypeSymbol result; 240776"];
6338 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 240777"];
6339 [label="mangleName 240778"];
6340 [label="param PENamedTypeSymbol(out bool mangleName) 240779"];
6341 [label="_lazyTupleData 240780"];
6342 [label="_container 240781"];
6343 [label="_name 240782"];
6344 [label="_flags 240783"];
6345 [label="_corTypeId 240784"];
6346 [label="Debug.Assert(!handle.IsNil); 240785"];
6347 [label="Debug.Assert((object)container != null); 240786"];
6348 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 240787"];
6349 [label="string metadataName; 240788"];
6350 [label="bool makeBad = false; 240789"];
6351 [label="mangleName = false; 240790"];
6352 [label="Accessibility access = Accessibility.Private; 240791"];
6353 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 240792"];
6354 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240793"];
6355 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 240794"];
6356 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 240795"];
6357 [label="mangleName 240796"];
6358 [label="param PENamedTypeSymbol(out bool mangleName) 240797"];
6359 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 240798"];
6360 [label="_arity 240799"];
6361 [label="_mangleName 240800"];
6362 [label="Debug.Assert(genericParameterHandles.Count > 0); 240801"];
6363 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 240802"];
6364 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 240803"];
6365 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 240804"];
6366 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 240805"];
6367 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 240806"];
6368 [label="bool added; 240807"];
6369 [label="Debug.Assert(added); 240808"];
6370 [label="type.SpecialType 240809"];
6371 [label="get\n            {\n                return _corTypeId;\n            } 240810"];
6372 [label="return _corTypeId; 240811"];
6373 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240812"];
6374 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 240813"];
6375 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 240814"];
6376 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 240815"];
6377 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 240816"];
6378 [label="param RegisterDeclaredSpecialType(this) 240817"];
6379 [label="corType.SpecialType 240818"];
6380 [label="get\n            {\n                return _corTypeId;\n            } 240819"];
6381 [label="SpecialType typeId = corType.SpecialType; 240820"];
6382 [label="Debug.Assert(typeId != SpecialType.None); 240821"];
6383 [label="corType.ContainingAssembly 240822"];
6384 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 240823"];
6385 [label="this.ContainingSymbol 240824"];
6386 [label="get\n            {\n                return _container;\n            } 240825"];
6387 [label="return _container; 240826"];
6388 [label="var container = this.ContainingSymbol; 240827"];
6389 [label="return (object)container != null ? container.ContainingAssembly : null; 240828"];
6390 [label="return (object)container != null ? container.ContainingAssembly : null; 240829"];
6391 [label="(object)container != null 240830"];
6392 [label="container.ContainingAssembly 240831"];
6393 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 240832"];
6394 [label="ContainingPEModule 240833"];
6395 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240834"];
6396 [label="return ContainingPEModule.ContainingAssembly; 240835"];
6397 [label="ContainingPEModule.ContainingAssembly 240836"];
6398 [label="get\n            {\n                return _assemblySymbol;\n            } 240837"];
6399 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240838"];
6400 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240839"];
6401 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240840"];
6402 [label="corType.ContainingModule 240841"];
6403 [label="get\n            {\n                return ContainingPEModule;\n            } 240842"];
6404 [label="ContainingPEModule 240843"];
6405 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 240844"];
6406 [label="Symbol s = _container; 240845"];
6407 [label="s.Kind 240846"];
6408 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240847"];
6409 [label="return SymbolKind.Namespace; 240848"];
6410 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 240849"];
6411 [label="((PENamespaceSymbol)s).ContainingPEModule 240850"];
6412 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240851"];
6413 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 240852"];
6414 [label="return ContainingPEModule; 240853"];
6415 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240854"];
6416 [label="corType.ContainingModule.Ordinal 240855"];
6417 [label="get\n            {\n                return _ordinal;\n            } 240856"];
6418 [label="return _ordinal; 240857"];
6419 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240858"];
6420 [label="this.CorLibrary 240859"];
6421 [label="get\n            {\n                return _corLibrary;\n            } 240860"];
6422 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 240861"];
6423 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 240862"];
6424 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 240863"];
6425 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 240864"];
6426 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 240865"];
6427 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 240866"];
6428 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 240867"];
6429 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 240868"];
6430 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 240869"];
6431 [label="Interlocked.Increment(ref _cachedSpecialTypes); 240870"];
6432 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240871"];
6433 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240872"];
6434 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240873"];
6435 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 240874"];
6436 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 240875"];
6437 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 240876"];
6438 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 240877"];
6439 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 240878"];
6440 [label="bool added; 240879"];
6441 [label="Debug.Assert(added); 240880"];
6442 [label="Debug.Assert(typeId != SpecialType.None); 240881"];
6443 [label="corType.ContainingAssembly 240882"];
6444 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 240883"];
6445 [label="this.ContainingSymbol 240884"];
6446 [label="get\n            {\n                return _container;\n            } 240885"];
6447 [label="return _container; 240886"];
6448 [label="var container = this.ContainingSymbol; 240887"];
6449 [label="return (object)container != null ? container.ContainingAssembly : null; 240888"];
6450 [label="return (object)container != null ? container.ContainingAssembly : null; 240889"];
6451 [label="(object)container != null 240890"];
6452 [label="container.ContainingAssembly 240891"];
6453 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 240892"];
6454 [label="ContainingPEModule 240893"];
6455 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240894"];
6456 [label="return ContainingPEModule.ContainingAssembly; 240895"];
6457 [label="ContainingPEModule.ContainingAssembly 240896"];
6458 [label="get\n            {\n                return _assemblySymbol;\n            } 240897"];
6459 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240898"];
6460 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240899"];
6461 [label="corType.ContainingModule 240900"];
6462 [label="get\n            {\n                return ContainingPEModule;\n            } 240901"];
6463 [label="ContainingPEModule 240902"];
6464 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 240903"];
6465 [label="Symbol s = _container; 240904"];
6466 [label="s.Kind 240905"];
6467 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240906"];
6468 [label="return SymbolKind.Namespace; 240907"];
6469 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 240908"];
6470 [label="((PENamespaceSymbol)s).ContainingPEModule 240909"];
6471 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240910"];
6472 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 240911"];
6473 [label="return ContainingPEModule; 240912"];
6474 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240913"];
6475 [label="corType.ContainingModule.Ordinal 240914"];
6476 [label="get\n            {\n                return _ordinal;\n            } 240915"];
6477 [label="return _ordinal; 240916"];
6478 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240917"];
6479 [label="this.CorLibrary 240918"];
6480 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 240919"];
6481 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 240920"];
6482 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240921"];
6483 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240922"];
6484 [label="bool added; 240923"];
6485 [label="Debug.Assert(added); 240924"];
6486 [label="Debug.Assert(typeId != SpecialType.None); 240925"];
6487 [label="corType.ContainingAssembly 240926"];
6488 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 240927"];
6489 [label="this.ContainingSymbol 240928"];
6490 [label="get\n            {\n                return _container;\n            } 240929"];
6491 [label="return _container; 240930"];
6492 [label="var container = this.ContainingSymbol; 240931"];
6493 [label="return (object)container != null ? container.ContainingAssembly : null; 240932"];
6494 [label="return (object)container != null ? container.ContainingAssembly : null; 240933"];
6495 [label="(object)container != null 240934"];
6496 [label="container.ContainingAssembly 240935"];
6497 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 240936"];
6498 [label="ContainingPEModule 240937"];
6499 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240938"];
6500 [label="return ContainingPEModule.ContainingAssembly; 240939"];
6501 [label="ContainingPEModule.ContainingAssembly 240940"];
6502 [label="get\n            {\n                return _assemblySymbol;\n            } 240941"];
6503 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240942"];
6504 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240943"];
6505 [label="corType.ContainingModule 240944"];
6506 [label="get\n            {\n                return ContainingPEModule;\n            } 240945"];
6507 [label="ContainingPEModule 240946"];
6508 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 240947"];
6509 [label="Symbol s = _container; 240948"];
6510 [label="s.Kind 240949"];
6511 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240950"];
6512 [label="return SymbolKind.Namespace; 240951"];
6513 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 240952"];
6514 [label="((PENamespaceSymbol)s).ContainingPEModule 240953"];
6515 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240954"];
6516 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 240955"];
6517 [label="return ContainingPEModule; 240956"];
6518 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240957"];
6519 [label="corType.ContainingModule.Ordinal 240958"];
6520 [label="get\n            {\n                return _ordinal;\n            } 240959"];
6521 [label="return _ordinal; 240960"];
6522 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240961"];
6523 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 240962"];
6524 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240963"];
6525 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 240964"];
6526 [label="bool added; 240965"];
6527 [label="Debug.Assert(added); 240966"];
6528 [label="return _container; 240967"];
6529 [label="var container = this.ContainingSymbol; 240968"];
6530 [label="return (object)container != null ? container.ContainingAssembly : null; 240969"];
6531 [label="(object)container != null 240970"];
6532 [label="container.ContainingAssembly 240971"];
6533 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 240972"];
6534 [label="ContainingPEModule 240973"];
6535 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240974"];
6536 [label="return ContainingPEModule.ContainingAssembly; 240975"];
6537 [label="ContainingPEModule.ContainingAssembly 240976"];
6538 [label="get\n            {\n                return _assemblySymbol;\n            } 240977"];
6539 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 240978"];
6540 [label="Symbol s = _container; 240979"];
6541 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 240980"];
6542 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 240981"];
6543 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 240982"];
6544 [label="return ContainingPEModule; 240983"];
6545 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 240984"];
6546 [label="get\n            {\n                return _ordinal;\n            } 240985"];
6547 [label="return _ordinal; 240986"];
6548 [label="LoadAllMembers(typesByNS); 240987"];
6549 [label="Interlocked.Exchange(ref _typesByNS, null); 240988"];
6550 [label="Interlocked.Exchange(ref _typesByNS, null); 240989"];
6551 [label="EnsureAllMembersLoaded(); 240990"];
6552 [label="ImmutableArray<PENamedTypeSymbol> t; 240991"];
6553 [label="t 240992"];
6554 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 240993"];
6555 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 240994"];
6556 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 240995"];
6557 [label="lazyTypes.TryGetValue(name, out t) 240996"];
6558 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 240997"];
6559 [label="named.MangleName 240998"];
6560 [label="get\n                {\n                    return false;\n                } 240999"];
6561 [label="return false; 241000"];
6562 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241001"];
6563 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241002"];
6564 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241003"];
6565 [label="named.Arity 241004"];
6566 [label="get\n                {\n                    return 0;\n                } 241005"];
6567 [label="return 0; 241006"];
6568 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241007"];
6569 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241008"];
6570 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 241009"];
6571 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 241010"];
6572 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 241011"];
6573 [label="namedType = named; 241012"];
6574 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 241013"];
6575 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 241014"];
6576 [label="return namedType; 241015"];
6577 [label="Debug.Assert((object)result != null); 241016"];
6578 [label="Debug.Assert((object)result != null); 241017"];
6579 [label="return result; 241018"];
6580 [label="result.Kind 241019"];
6581 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241020"];
6582 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 241021"];
6583 [label="result.DeclaredAccessibility 241022"];
6584 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 241023"];
6585 [label="Accessibility access = Accessibility.Private; 241024"];
6586 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 241025"];
6587 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 241026"];
6588 [label="RegisterDeclaredSpecialType(result); 241027"];
6589 [label="RegisterDeclaredSpecialType(result) 241028"];
6590 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 241029"];
6591 [label="param RegisterDeclaredSpecialType(this) 241030"];
6592 [label="corType.SpecialType 241031"];
6593 [label="Debug.Assert(typeId != SpecialType.None); 241032"];
6594 [label="corType.ContainingAssembly 241033"];
6595 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 241034"];
6596 [label="this.ContainingSymbol 241035"];
6597 [label="get\n            {\n                return _container;\n            } 241036"];
6598 [label="return _container; 241037"];
6599 [label="var container = this.ContainingSymbol; 241038"];
6600 [label="return (object)container != null ? container.ContainingAssembly : null; 241039"];
6601 [label="return (object)container != null ? container.ContainingAssembly : null; 241040"];
6602 [label="(object)container != null 241041"];
6603 [label="container.ContainingAssembly 241042"];
6604 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 241043"];
6605 [label="ContainingPEModule 241044"];
6606 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 241045"];
6607 [label="return ContainingPEModule.ContainingAssembly; 241046"];
6608 [label="ContainingPEModule.ContainingAssembly 241047"];
6609 [label="get\n            {\n                return _assemblySymbol;\n            } 241048"];
6610 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 241049"];
6611 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 241050"];
6612 [label="corType.ContainingModule 241051"];
6613 [label="get\n            {\n                return ContainingPEModule;\n            } 241052"];
6614 [label="ContainingPEModule 241053"];
6615 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241054"];
6616 [label="Symbol s = _container; 241055"];
6617 [label="s.Kind 241056"];
6618 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241057"];
6619 [label="return SymbolKind.Namespace; 241058"];
6620 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241059"];
6621 [label="((PENamespaceSymbol)s).ContainingPEModule 241060"];
6622 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 241061"];
6623 [label="_containingNamespaceSymbol.ContainingPEModule 241062"];
6624 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 241063"];
6625 [label="return ContainingPEModule; 241064"];
6626 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 241065"];
6627 [label="corType.ContainingModule.Ordinal 241066"];
6628 [label="get\n            {\n                return _ordinal;\n            } 241067"];
6629 [label="return _ordinal; 241068"];
6630 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 241069"];
6631 [label="this.CorLibrary 241070"];
6632 [label="get\n            {\n                return _corLibrary;\n            } 241071"];
6633 [label="return _corLibrary; 241072"];
6634 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 241073"];
6635 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 241074"];
6636 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 241075"];
6637 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 241076"];
6638 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 241077"];
6639 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 241078"];
6640 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 241079"];
6641 [label="RegisterDeclaredSpecialType(result); 241080"];
6642 [label="return _lazySpecialTypes[(int)type]; 241081"];
6643 [label="result.SpecialType 241082"];
6644 [label="get\n            {\n                return _corTypeId;\n            } 241083"];
6645 [label="Debug.Assert(result.SpecialType == specialType); 241084"];
6646 [label="return result; 241085"];
6647 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 241086"];
6648 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 241087"];
6649 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 241088"];
6650 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 241089"];
6651 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node); 241090"];
6652 [label="ReportUseSiteDiagnostics(typeSymbol, diagnostics, node) 241091"];
6653 [label="param ReportUseSiteDiagnostics(Symbol symbol) 241092"];
6654 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 241093"];
6655 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 241094"];
6656 [label="symbol.GetUseSiteDiagnostic() 241095"];
6657 [label="param GetUseSiteDiagnostic(this) 241096"];
6658 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 241097"];
6659 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 241098"];
6660 [label="GetUseSiteDiagnosticImpl() 241099"];
6661 [label="param GetUseSiteDiagnosticImpl(this) 241100"];
6662 [label="DiagnosticInfo diagnostic = null; 241101"];
6663 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 241102"];
6664 [label="CalculateUseSiteDiagnostic() 241103"];
6665 [label="param CalculateUseSiteDiagnostic(this) 241104"];
6666 [label="DiagnosticInfo result = null; 241105"];
6667 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 241106"];
6668 [label="DeriveUseSiteDiagnosticFromBase() 241107"];
6669 [label="param DeriveUseSiteDiagnosticFromBase(this) 241108"];
6670 [label="this.BaseTypeNoUseSiteDiagnostics 241109"];
6671 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 241110"];
6672 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 241111"];
6673 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 241112"];
6674 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 241113"];
6675 [label="MakeAcyclicBaseType() 241114"];
6676 [label="param MakeAcyclicBaseType(this) 241115"];
6677 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 241116"];
6678 [label="GetDeclaredBaseType(null) 241117"];
6679 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 241118"];
6680 [label="param GetDeclaredBaseType(this) 241119"];
6681 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 241120"];
6682 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 241121"];
6683 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 241122"];
6684 [label="param GetDeclaredBaseType(this) 241123"];
6685 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 241124"];
6686 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 241125"];
6687 [label="MakeDeclaredBaseType() 241126"];
6688 [label="param MakeDeclaredBaseType(this) 241127"];
6689 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 241128"];
6690 [label="ContainingPEModule 241129"];
6691 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241130"];
6692 [label="Symbol s = _container; 241131"];
6693 [label="s.Kind 241132"];
6694 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241133"];
6695 [label="return SymbolKind.Namespace; 241134"];
6696 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241135"];
6697 [label="((PENamespaceSymbol)s).ContainingPEModule 241136"];
6698 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 241137"];
6699 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 241138"];
6700 [label="var moduleSymbol = ContainingPEModule; 241139"];
6701 [label="moduleSymbol.Module 241140"];
6702 [label="get\n            {\n                return _module;\n            } 241141"];
6703 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 241142"];
6704 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 241143"];
6705 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 241144"];
6706 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 241145"];
6707 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 241146"];
6708 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 241147"];
6709 [label="new MetadataDecoder(moduleSymbol, this) 241148"];
6710 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 241149"];
6711 [label="param MetadataDecoder(PENamedTypeSymbol context) 241150"];
6712 [label="param MetadataDecoder(this) 241151"];
6713 [label="moduleSymbol 241152"];
6714 [label="context 241153"];
6715 [label="null 241154"];
6716 [label="param MetadataDecoder(this) 241155"];
6717 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 241156"];
6718 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 241157"];
6719 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 241158"];
6720 [label="param MetadataDecoder(this) 241159"];
6721 [label="moduleSymbol.Module 241160"];
6722 [label="get\n            {\n                return _module;\n            } 241161"];
6723 [label="moduleSymbol.ContainingAssembly 241162"];
6724 [label="get\n            {\n                return _assemblySymbol;\n            } 241163"];
6725 [label="(moduleSymbol.ContainingAssembly is PEAssemblySymbol) 241164"];
6726 [label="moduleSymbol.ContainingAssembly 241165"];
6727 [label="moduleSymbol.ContainingAssembly.Identity 241166"];
6728 [label="get\n            {\n                return _assembly.Identity;\n            } 241167"];
6729 [label="return _assembly.Identity; 241168"];
6730 [label="new SymbolFactory() 241169"];
6731 [label="param SymbolFactory(this) 241170"];
6732 [label="Instance = new SymbolFactory() 241171"];
6733 [label="SymbolFactory.Instance 241172"];
6734 [label="moduleSymbol 241173"];
6735 [label="param MetadataDecoder(this) 241174"];
6736 [label="param MetadataDecoder(this) 241175"];
6737 [label="_typeContextOpt 241176"];
6738 [label="_methodContextOpt 241177"];
6739 [label="Debug.Assert((object)moduleSymbol != null); 241178"];
6740 [label="Debug.Assert((object)moduleSymbol != null); 241179"];
6741 [label="_typeContextOpt 241180"];
6742 [label="_methodContextOpt 241181"];
6743 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 241182"];
6744 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 241183"];
6745 [label="param GetTypeHandleToTypeMap(this) 241184"];
6746 [label="return moduleSymbol.TypeHandleToTypeMap; 241185"];
6747 [label="var baseType = MakeDeclaredBaseType(); 241186"];
6748 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 241187"];
6749 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 241188"];
6750 [label="ContainingPEModule 241189"];
6751 [label="s.Kind 241190"];
6752 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241191"];
6753 [label="return SymbolKind.Namespace; 241192"];
6754 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241193"];
6755 [label="var moduleSymbol = ContainingPEModule; 241194"];
6756 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 241195"];
6757 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 241196"];
6758 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 241197"];
6759 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 241198"];
6760 [label="DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol) 241199"];
6761 [label="param TransformType(TypeSymbol metadataType) 241200"];
6762 [label="param TransformType(int targetSymbolCustomModifierCount) 241201"];
6763 [label="param TransformType(EntityHandle targetSymbolToken) 241202"];
6764 [label="param TransformType(PEModuleSymbol containingModule) 241203"];
6765 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 241204"];
6766 [label="Debug.Assert((object)metadataType != null); 241205"];
6767 [label="Debug.Assert((object)metadataType != null); 241206"];
6768 [label="ImmutableArray<bool> dynamicTransformFlags; 241207"];
6769 [label="dynamicTransformFlags 241208"];
6770 [label="containingModule.Module 241209"];
6771 [label="get\n            {\n                return _module;\n            } 241210"];
6772 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 241211"];
6773 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 241212"];
6774 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 241213"];
6775 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 241214"];
6776 [label="return metadataType; 241215"];
6777 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 241216"];
6778 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 241217"];
6779 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 241218"];
6780 [label="NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol) 241219"];
6781 [label="param TransformType(TypeSymbol type) 241220"];
6782 [label="param TransformType(EntityHandle handle) 241221"];
6783 [label="param TransformType(PEModuleSymbol containingModule) 241222"];
6784 [label="containingModule.Module 241223"];
6785 [label="get\n            {\n                return _module;\n            } 241224"];
6786 [label="return _module; 241225"];
6787 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 241226"];
6788 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 241227"];
6789 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 241228"];
6790 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 241229"];
6791 [label="containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) 241230"];
6792 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 241231"];
6793 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 241232"];
6794 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 241233"];
6795 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 241234"];
6796 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol) 241235"];
6797 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 241236"];
6798 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 241237"];
6799 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 241238"];
6800 [label="ImmutableArray<string?> elementNames; 241239"];
6801 [label="elementNames 241240"];
6802 [label="containingModule\n                .Module 241241"];
6803 [label="get\n            {\n                return _module;\n            } 241242"];
6804 [label="return _module; 241243"];
6805 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 241244"];
6806 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 241245"];
6807 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 241246"];
6808 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 241247"];
6809 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 241248"];
6810 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 241249"];
6811 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 241250"];
6812 [label="DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute) 241251"];
6813 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 241252"];
6814 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 241253"];
6815 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 241254"];
6816 [label="RoslynDebug.AssertNotNull(metadataType); 241255"];
6817 [label="RoslynDebug.AssertNotNull(metadataType); 241256"];
6818 [label="var decoder = new TupleTypeDecoder(elementNames); 241257"];
6819 [label="var decoder = new TupleTypeDecoder(elementNames); 241258"];
6820 [label="new TupleTypeDecoder(elementNames) 241259"];
6821 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 241260"];
6822 [label="param TupleTypeDecoder(this) 241261"];
6823 [label="_elementNames 241262"];
6824 [label="elementNames.IsDefault 241263"];
6825 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 241264"];
6826 [label="_namesIndex 241265"];
6827 [label="_decodingFailed = false; 241266"];
6828 [label="_decodingFailed 241267"];
6829 [label="_foundUsableErrorType = false; 241268"];
6830 [label="_foundUsableErrorType 241269"];
6831 [label="var decoded = decoder.DecodeType(metadataType); 241270"];
6832 [label="decoder.DecodeType(metadataType) 241271"];
6833 [label="param DecodeType(TypeSymbol type) 241272"];
6834 [label="param DecodeType(this) 241273"];
6835 [label="type.Kind 241274"];
6836 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241275"];
6837 [label="switch (type.Kind)\n            {\n                case SymbolKind.ErrorType:\n                    _foundUsableErrorType = true;\n                    return type;\n\n                case SymbolKind.DynamicType:\n                case SymbolKind.TypeParameter:\n                    return type;\n\n                case SymbolKind.FunctionPointerType:\n                    return DecodeFunctionPointerType((FunctionPointerTypeSymbol)type);\n\n                case SymbolKind.PointerType:\n                    return DecodePointerType((PointerTypeSymbol)type);\n\n                case SymbolKind.NamedType:\n                    // We may have a tuple type from a substituted type symbol,\n                    // but it will be missing names from metadata, so we'll\n                    // need to re-create the type.\n                    //\n                    // Consider the declaration\n                    //\n                    //      class C : BaseType<(int x, int y)>\n                    //\n                    // The process for decoding tuples in C looks at the BaseType, calls\n                    // DecodeOrThrow, then passes the decoded type to the TupleTypeDecoder.\n                    // However, DecodeOrThrow uses the AbstractTypeMap to construct a\n                    // SubstitutedTypeSymbol, which eagerly converts tuple-compatible\n                    // types to TupleTypeSymbols. Thus, by the time we get to the Decoder\n                    // all metadata instances of System.ValueTuple will have been\n                    //  replaced with TupleTypeSymbols without names.\n                    // \n                    // Rather than fixing up after-the-fact it's possible that we could\n                    // flow up a SubstituteWith/Without tuple unification to the top level\n                    // of the type map and change DecodeOrThrow to call into the substitution\n                    // without unification instead.\n                    return DecodeNamedType((NamedTypeSymbol)type);\n\n                case SymbolKind.ArrayType:\n                    return DecodeArrayType((ArrayTypeSymbol)type);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);\n            } 241276"];
6838 [label="return DecodeNamedType((NamedTypeSymbol)type); 241277"];
6839 [label="DecodeNamedType((NamedTypeSymbol)type) 241278"];
6840 [label="param DecodeNamedType(NamedTypeSymbol type) 241279"];
6841 [label="param DecodeNamedType(this) 241280"];
6842 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 241281"];
6843 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 241282"];
6844 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 241283"];
6845 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 241284"];
6846 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 241285"];
6847 [label="DecodeTypeArguments(typeArgs) 241286"];
6848 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 241287"];
6849 [label="param DecodeTypeArguments(this) 241288"];
6850 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 241289"];
6851 [label="return typeArgs; 241290"];
6852 [label="NamedTypeSymbol decodedType = type; 241291"];
6853 [label="type.ContainingType 241292"];
6854 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 241293"];
6855 [label="return _container as NamedTypeSymbol; 241294"];
6856 [label="NamedTypeSymbol containingType = type.ContainingType; 241295"];
6857 [label="NamedTypeSymbol? decodedContainingType; 241296"];
6858 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 241297"];
6859 [label="decodedContainingType = containingType; 241298"];
6860 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 241299"];
6861 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 241300"];
6862 [label="var typeArgsChanged = typeArgs != decodedArgs; 241301"];
6863 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 241302"];
6864 [label="decodedType.IsTupleType 241303"];
6865 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 241304"];
6866 [label="_ 241305"];
6867 [label="tupleCardinality: out _ 241306"];
6868 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 241307"];
6869 [label="param IsTupleTypeOfCardinality(this) 241308"];
6870 [label="IsUnboundGenericType 241309"];
6871 [label="get\n            {\n                return false;\n            } 241310"];
6872 [label="return false; 241311"];
6873 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241312"];
6874 [label="ContainingSymbol 241313"];
6875 [label="get\n            {\n                return _container;\n            } 241314"];
6876 [label="return _container; 241315"];
6877 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241316"];
6878 [label=".Kind 241317"];
6879 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241318"];
6880 [label="return SymbolKind.Namespace; 241319"];
6881 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241320"];
6882 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241321"];
6883 [label="ContainingNamespace 241322"];
6884 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 241323"];
6885 [label="get\n            {\n                return _container;\n            } 241324"];
6886 [label="return _container; 241325"];
6887 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241326"];
6888 [label="ContainingNamespace.ContainingNamespace 241327"];
6889 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 241328"];
6890 [label=".IsGlobalNamespace 241329"];
6891 [label="get\n            {\n                return true;\n            } 241330"];
6892 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241331"];
6893 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241332"];
6894 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241333"];
6895 [label="Name 241334"];
6896 [label="get\n            {\n                return _name;\n            } 241335"];
6897 [label="return _name; 241336"];
6898 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241337"];
6899 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241338"];
6900 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241339"];
6901 [label="tupleCardinality = 0; 241340"];
6902 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 241341"];
6903 [label="return decodedType; 241342"];
6904 [label="if (!decoder._decodingFailed)\n            {\n                if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                }\n            } 241343"];
6905 [label="if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                } 241344"];
6906 [label="return decoded; 241345"];
6907 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 241346"];
6908 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 241347"];
6909 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 241348"];
6910 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 241349"];
6911 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 241350"];
6912 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 241351"];
6913 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 241352"];
6914 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 241353"];
6915 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 241354"];
6916 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 241355"];
6917 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 241356"];
6918 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 241357"];
6919 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 241358"];
6920 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 241359"];
6921 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 241360"];
6922 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241361"];
6923 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241362"];
6924 [label="TypeWithAnnotations.Create(decodedType) 241363"];
6925 [label="param Create(TypeSymbol typeSymbol) 241364"];
6926 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 241365"];
6927 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 241366"];
6928 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 241367"];
6929 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 241368"];
6930 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 241369"];
6931 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 241370"];
6932 [label="typeSymbol.IsNullableType() 241371"];
6933 [label="param IsNullableType(this TypeSymbol type) 241372"];
6934 [label="type.OriginalDefinition 241373"];
6935 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 241374"];
6936 [label="OriginalTypeSymbolDefinition 241375"];
6937 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241376"];
6938 [label="this.OriginalDefinition 241377"];
6939 [label="get\n            {\n                return this;\n            } 241378"];
6940 [label="return this; 241379"];
6941 [label="return this.OriginalDefinition; 241380"];
6942 [label="return OriginalTypeSymbolDefinition; 241381"];
6943 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 241382"];
6944 [label="type.OriginalDefinition.SpecialType 241383"];
6945 [label="get\n            {\n                return _corTypeId;\n            } 241384"];
6946 [label="return _corTypeId; 241385"];
6947 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 241386"];
6948 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 241387"];
6949 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 241388"];
6950 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 241389"];
6951 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 241390"];
6952 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 241391"];
6953 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 241392"];
6954 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 241393"];
6955 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 241394"];
6956 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 241395"];
6957 [label="param NonLazyType(this) 241396"];
6958 [label="param Extensions(this) 241397"];
6959 [label="Debug.Assert(!customModifiers.IsDefault); 241398"];
6960 [label="_customModifiers 241399"];
6961 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 241400"];
6962 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 241401"];
6963 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 241402"];
6964 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 241403"];
6965 [label="Extensions.Create(customModifiers) 241404"];
6966 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 241405"];
6967 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 241406"];
6968 [label="return Default; 241407"];
6969 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 241408"];
6970 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 241409"];
6971 [label="param TypeWithAnnotations(TypeSymbol defaultType) 241410"];
6972 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 241411"];
6973 [label="param TypeWithAnnotations(Extensions extensions) 241412"];
6974 [label="param TypeWithAnnotations(this) 241413"];
6975 [label="var a1 = defaultType is null; 241414"];
6976 [label="!a1 241415"];
6977 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 241416"];
6978 [label="defaultType.IsNullableType() 241417"];
6979 [label="param IsNullableType(this TypeSymbol type) 241418"];
6980 [label="type.OriginalDefinition 241419"];
6981 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 241420"];
6982 [label="OriginalTypeSymbolDefinition 241421"];
6983 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241422"];
6984 [label="this.OriginalDefinition 241423"];
6985 [label="get\n            {\n                return this;\n            } 241424"];
6986 [label="return this; 241425"];
6987 [label="return this.OriginalDefinition; 241426"];
6988 [label="return OriginalTypeSymbolDefinition; 241427"];
6989 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 241428"];
6990 [label="type.OriginalDefinition.SpecialType 241429"];
6991 [label="get\n            {\n                return _corTypeId;\n            } 241430"];
6992 [label="return _corTypeId; 241431"];
6993 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 241432"];
6994 [label="Debug.Assert(a1 || a2 != true || a3); 241433"];
6995 [label="Debug.Assert(a1 || a2 != true || a3); 241434"];
6996 [label="Debug.Assert(extensions != null); 241435"];
6997 [label="Debug.Assert(extensions != null); 241436"];
6998 [label="DefaultType 241437"];
6999 [label="NullableAnnotation 241438"];
7000 [label="_extensions 241439"];
7001 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 241440"];
7002 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241441"];
7003 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241442"];
7004 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241443"];
7005 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 241444"];
7006 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this) 241445"];
7007 [label="param TransformType(TypeWithAnnotations metadataType) 241446"];
7008 [label="param TransformType(EntityHandle targetSymbolToken) 241447"];
7009 [label="param TransformType(PEModuleSymbol containingModule) 241448"];
7010 [label="param TransformType(Symbol accessSymbol) 241449"];
7011 [label="param TransformType(Symbol nullableContext) 241450"];
7012 [label="metadataType.HasType 241451"];
7013 [label="=> !(DefaultType is null) 241452"];
7014 [label="DefaultType is null 241453"];
7015 [label="!(DefaultType is null) 241454"];
7016 [label="Debug.Assert(metadataType.HasType); 241455"];
7017 [label="accessSymbol.IsDefinition 241456"];
7018 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 241457"];
7019 [label="OriginalDefinition 241458"];
7020 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 241459"];
7021 [label="OriginalSymbolDefinition 241460"];
7022 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 241461"];
7023 [label="this.OriginalTypeSymbolDefinition 241462"];
7024 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241463"];
7025 [label="this.OriginalDefinition 241464"];
7026 [label="get\n            {\n                return this;\n            } 241465"];
7027 [label="return this; 241466"];
7028 [label="return this.OriginalDefinition; 241467"];
7029 [label="return this.OriginalTypeSymbolDefinition; 241468"];
7030 [label="return OriginalSymbolDefinition; 241469"];
7031 [label="return (object)this == (object)OriginalDefinition; 241470"];
7032 [label="Debug.Assert(accessSymbol.IsDefinition); 241471"];
7033 [label="accessSymbol.ContainingModule 241472"];
7034 [label="get\n            {\n                return ContainingPEModule;\n            } 241473"];
7035 [label="ContainingPEModule 241474"];
7036 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241475"];
7037 [label="Symbol s = _container; 241476"];
7038 [label="s.Kind 241477"];
7039 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241478"];
7040 [label="return SymbolKind.Namespace; 241479"];
7041 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241480"];
7042 [label="return ContainingPEModule; 241481"];
7043 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 241482"];
7044 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 241483"];
7045 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241484"];
7046 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241485"];
7047 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 241486"];
7048 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 241487"];
7049 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 241488"];
7050 [label="Debug.Assert(symbol is object); 241489"];
7051 [label="symbol.Kind 241490"];
7052 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241491"];
7053 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 241492"];
7054 [label="isInternal = false; 241493"];
7055 [label="symbol.DeclaredAccessibility 241494"];
7056 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 241495"];
7057 [label="Accessibility access = Accessibility.Private; 241496"];
7058 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 241497"];
7059 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 241498"];
7060 [label="symbol.ContainingType 241499"];
7061 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 241500"];
7062 [label="return _container as NamedTypeSymbol; 241501"];
7063 [label="symbol = symbol.ContainingType; 241502"];
7064 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 241503"];
7065 [label="return true; 241504"];
7066 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241505"];
7067 [label="byte defaultTransformFlag; 241506"];
7068 [label="ImmutableArray<byte> nullableTransformFlags; 241507"];
7069 [label="nullableTransformFlags 241508"];
7070 [label="containingModule.Module 241509"];
7071 [label="get\n            {\n                return _module;\n            } 241510"];
7072 [label="return _module; 241511"];
7073 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 241512"];
7074 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 241513"];
7075 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 241514"];
7076 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 241515"];
7077 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 241516"];
7078 [label="nullableContext.GetNullableContextValue() 241517"];
7079 [label="param GetNullableContextValue(this) 241518"];
7080 [label="byte? value; 241519"];
7081 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 241520"];
7082 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 241521"];
7083 [label="_lazyNullableContextValue.TryGetByte(out value) 241522"];
7084 [label="param TryGetByte(this NullableContextKind kind) 241523"];
7085 [label="param TryGetByte(out byte? value) 241524"];
7086 [label="switch (kind)\n            {\n                case NullableContextKind.Unknown:\n                    value = null;\n                    return false;\n                case NullableContextKind.None:\n                    value = null;\n                    return true;\n                case NullableContextKind.Oblivious:\n                    value = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    return true;\n                case NullableContextKind.NotAnnotated:\n                    value = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    return true;\n                case NullableContextKind.Annotated:\n                    value = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 241525"];
7087 [label="value = null; 241526"];
7088 [label="return false; 241527"];
7089 [label="ContainingPEModule 241528"];
7090 [label="s.Kind 241529"];
7091 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241530"];
7092 [label="return SymbolKind.Namespace; 241531"];
7093 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241532"];
7094 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 241533"];
7095 [label="ContainingPEModule.Module 241534"];
7096 [label="get\n            {\n                return _module;\n            } 241535"];
7097 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 241536"];
7098 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 241537"];
7099 [label="ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 241538"];
7100 [label="_container.GetNullableContextValue() 241539"];
7101 [label="param GetNullableContextValue(this) 241540"];
7102 [label="GetLocalNullableContextValue() 241541"];
7103 [label="param GetLocalNullableContextValue(this) 241542"];
7104 [label="return null; 241543"];
7105 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 241544"];
7106 [label="ContainingSymbol 241545"];
7107 [label="get { return _containingNamespaceSymbol; } 241546"];
7108 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 241547"];
7109 [label=".GetNullableContextValue() 241548"];
7110 [label="param GetNullableContextValue(this) 241549"];
7111 [label="GetLocalNullableContextValue() 241550"];
7112 [label="param GetLocalNullableContextValue(this) 241551"];
7113 [label="return null; 241552"];
7114 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 241553"];
7115 [label="ContainingSymbol 241554"];
7116 [label="get\n            {\n                return _moduleSymbol;\n            } 241555"];
7117 [label="return _moduleSymbol; 241556"];
7118 [label="param GetLocalNullableContextValue(this) 241557"];
7119 [label="get\n            {\n                return _assemblySymbol;\n            } 241558"];
7120 [label="return _assemblySymbol; 241559"];
7121 [label="param GetLocalNullableContextValue(this) 241560"];
7122 [label="get\n            {\n                return null;\n            } 241561"];
7123 [label="return null; 241562"];
7124 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 241563"];
7125 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 241564"];
7126 [label="_lazyNullableContextValue = value.ToNullableContextFlags(); 241565"];
7127 [label="value.ToNullableContextFlags() 241566"];
7128 [label="param ToNullableContextFlags(this byte? value) 241567"];
7129 [label="switch (value)\n            {\n                case null:\n                    return NullableContextKind.None;\n                case NullableAnnotationExtensions.ObliviousAttributeValue:\n                    return NullableContextKind.Oblivious;\n                case NullableAnnotationExtensions.NotAnnotatedAttributeValue:\n                    return NullableContextKind.NotAnnotated;\n                case NullableAnnotationExtensions.AnnotatedAttributeValue:\n                    return NullableContextKind.Annotated;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(value);\n            } 241568"];
7130 [label="return NullableContextKind.None; 241569"];
7131 [label="_lazyNullableContextValue 241570"];
7132 [label="return value; 241571"];
7133 [label="byte? value = nullableContext.GetNullableContextValue(); 241572"];
7134 [label="if (value == null)\n                {\n                    return metadataType;\n                } 241573"];
7135 [label="if (value == null)\n                {\n                    return metadataType;\n                } 241574"];
7136 [label="return metadataType; 241575"];
7137 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type 241576"];
7138 [label="=> _extensions?.GetResolvedType(DefaultType) 241577"];
7139 [label="DefaultType 241578"];
7140 [label=".GetResolvedType(DefaultType) 241579"];
7141 [label="param GetResolvedType(TypeSymbol defaultType) 241580"];
7142 [label="=> defaultType 241581"];
7143 [label="defaultType 241582"];
7144 [label="_extensions?.GetResolvedType(DefaultType) 241583"];
7145 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 241584"];
7146 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 241585"];
7147 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 241586"];
7148 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 241587"];
7149 [label="return _lazyDeclaredBaseType; 241588"];
7150 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 241589"];
7151 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 241590"];
7152 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 241591"];
7153 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 241592"];
7154 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 241593"];
7155 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 241594"];
7156 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 241595"];
7157 [label="param TypeDependsOn(NamedTypeSymbol depends) 241596"];
7158 [label="param TypeDependsOn(NamedTypeSymbol on) 241597"];
7159 [label="Debug.Assert((object)depends != null); 241598"];
7160 [label="Debug.Assert((object)depends != null); 241599"];
7161 [label="Debug.Assert((object)on != null); 241600"];
7162 [label="Debug.Assert((object)on != null); 241601"];
7163 [label="on.IsDefinition 241602"];
7164 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 241603"];
7165 [label="OriginalDefinition 241604"];
7166 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 241605"];
7167 [label="OriginalSymbolDefinition 241606"];
7168 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 241607"];
7169 [label="this.OriginalTypeSymbolDefinition 241608"];
7170 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241609"];
7171 [label="this.OriginalDefinition 241610"];
7172 [label="get\n            {\n                return this;\n            } 241611"];
7173 [label="return this; 241612"];
7174 [label="return this.OriginalDefinition; 241613"];
7175 [label="return this.OriginalTypeSymbolDefinition; 241614"];
7176 [label="return OriginalSymbolDefinition; 241615"];
7177 [label="return (object)this == (object)OriginalDefinition; 241616"];
7178 [label="Debug.Assert(on.IsDefinition); 241617"];
7179 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 241618"];
7180 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 241619"];
7181 [label="depends.DeclaringCompilation 241620"];
7182 [label="get { return null; } 241621"];
7183 [label="return null; 241622"];
7184 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 241623"];
7185 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 241624"];
7186 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 241625"];
7187 [label="param TypeDependsClosure(NamedTypeSymbol type) 241626"];
7188 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 241627"];
7189 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 241628"];
7190 [label="if ((object)type == null)\n            {\n                return;\n            } 241629"];
7191 [label="if ((object)type == null)\n            {\n                return;\n            } 241630"];
7192 [label="type.OriginalDefinition 241631"];
7193 [label="get\n            {\n                return this;\n            } 241632"];
7194 [label="return this; 241633"];
7195 [label="type = type.OriginalDefinition; 241634"];
7196 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 241635"];
7197 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 241636"];
7198 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 241637"];
7199 [label="param GetHashCode(this) 241638"];
7200 [label="this.SpecialType 241639"];
7201 [label="get\n            {\n                return _corTypeId;\n            } 241640"];
7202 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 241641"];
7203 [label="OriginalDefinition 241642"];
7204 [label="get\n            {\n                return this;\n            } 241643"];
7205 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 241644"];
7206 [label="type.IsInterface 241645"];
7207 [label="get\n            {\n                return _flags.IsInterface();\n            } 241646"];
7208 [label="return _flags.IsInterface(); 241647"];
7209 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 241648"];
7210 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 241649"];
7211 [label="type.GetDeclaredBaseType(null) 241650"];
7212 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 241651"];
7213 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 241652"];
7214 [label="s.Kind 241653"];
7215 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241654"];
7216 [label="return SymbolKind.Namespace; 241655"];
7217 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241656"];
7218 [label="Debug.Assert((object)moduleSymbol != null); 241657"];
7219 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 241658"];
7220 [label="param TransformType(int targetSymbolCustomModifierCount) 241659"];
7221 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 241660"];
7222 [label="Debug.Assert((object)metadataType != null); 241661"];
7223 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 241662"];
7224 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 241663"];
7225 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 241664"];
7226 [label="_elementNames 241665"];
7227 [label="elementNames.IsDefault 241666"];
7228 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 241667"];
7229 [label="_namesIndex 241668"];
7230 [label="_foundUsableErrorType = false; 241669"];
7231 [label="_foundUsableErrorType 241670"];
7232 [label="param DecodeType(this) 241671"];
7233 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241672"];
7234 [label="param DecodeNamedType(this) 241673"];
7235 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 241674"];
7236 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 241675"];
7237 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 241676"];
7238 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 241677"];
7239 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 241678"];
7240 [label="DecodeTypeArguments(typeArgs) 241679"];
7241 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 241680"];
7242 [label="param DecodeTypeArguments(this) 241681"];
7243 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 241682"];
7244 [label="return typeArgs; 241683"];
7245 [label="type.ContainingType 241684"];
7246 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 241685"];
7247 [label="return _container as NamedTypeSymbol; 241686"];
7248 [label="NamedTypeSymbol containingType = type.ContainingType; 241687"];
7249 [label="NamedTypeSymbol? decodedContainingType; 241688"];
7250 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 241689"];
7251 [label="decodedContainingType = containingType; 241690"];
7252 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 241691"];
7253 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 241692"];
7254 [label="var typeArgsChanged = typeArgs != decodedArgs; 241693"];
7255 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 241694"];
7256 [label="decodedType.IsTupleType 241695"];
7257 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 241696"];
7258 [label="_ 241697"];
7259 [label="tupleCardinality: out _ 241698"];
7260 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 241699"];
7261 [label="param IsTupleTypeOfCardinality(this) 241700"];
7262 [label="IsUnboundGenericType 241701"];
7263 [label="get\n            {\n                return false;\n            } 241702"];
7264 [label="return false; 241703"];
7265 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241704"];
7266 [label="ContainingSymbol 241705"];
7267 [label="get\n            {\n                return _container;\n            } 241706"];
7268 [label="return _container; 241707"];
7269 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241708"];
7270 [label=".Kind 241709"];
7271 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241710"];
7272 [label="return SymbolKind.Namespace; 241711"];
7273 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241712"];
7274 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241713"];
7275 [label="ContainingNamespace 241714"];
7276 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 241715"];
7277 [label="get\n            {\n                return _container;\n            } 241716"];
7278 [label="return _container; 241717"];
7279 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241718"];
7280 [label="ContainingNamespace.ContainingNamespace 241719"];
7281 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 241720"];
7282 [label=".IsGlobalNamespace 241721"];
7283 [label="get\n            {\n                return true;\n            } 241722"];
7284 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241723"];
7285 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241724"];
7286 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241725"];
7287 [label="Name 241726"];
7288 [label="get\n            {\n                return _name;\n            } 241727"];
7289 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241728"];
7290 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241729"];
7291 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 241730"];
7292 [label="tupleCardinality = 0; 241731"];
7293 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 241732"];
7294 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 241733"];
7295 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 241734"];
7296 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 241735"];
7297 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 241736"];
7298 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 241737"];
7299 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 241738"];
7300 [label="typeSymbol.IsNullableType() 241739"];
7301 [label="param IsNullableType(this TypeSymbol type) 241740"];
7302 [label="type.OriginalDefinition 241741"];
7303 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 241742"];
7304 [label="OriginalTypeSymbolDefinition 241743"];
7305 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241744"];
7306 [label="this.OriginalDefinition 241745"];
7307 [label="get\n            {\n                return this;\n            } 241746"];
7308 [label="return this.OriginalDefinition; 241747"];
7309 [label="return OriginalTypeSymbolDefinition; 241748"];
7310 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 241749"];
7311 [label="type.OriginalDefinition.SpecialType 241750"];
7312 [label="get\n            {\n                return _corTypeId;\n            } 241751"];
7313 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 241752"];
7314 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 241753"];
7315 [label="Extensions.Create(customModifiers) 241754"];
7316 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 241755"];
7317 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 241756"];
7318 [label="return Default; 241757"];
7319 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 241758"];
7320 [label="param TypeWithAnnotations(Extensions extensions) 241759"];
7321 [label="var a1 = defaultType is null; 241760"];
7322 [label="!a1 241761"];
7323 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 241762"];
7324 [label="defaultType.IsNullableType() 241763"];
7325 [label="param IsNullableType(this TypeSymbol type) 241764"];
7326 [label="type.OriginalDefinition 241765"];
7327 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 241766"];
7328 [label="OriginalTypeSymbolDefinition 241767"];
7329 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241768"];
7330 [label="this.OriginalDefinition 241769"];
7331 [label="get\n            {\n                return this;\n            } 241770"];
7332 [label="return this.OriginalDefinition; 241771"];
7333 [label="return OriginalTypeSymbolDefinition; 241772"];
7334 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 241773"];
7335 [label="type.OriginalDefinition.SpecialType 241774"];
7336 [label="get\n            {\n                return _corTypeId;\n            } 241775"];
7337 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 241776"];
7338 [label="Debug.Assert(a1 || a2 != true || a3); 241777"];
7339 [label="Debug.Assert(a1 || a2 != true || a3); 241778"];
7340 [label="Debug.Assert(extensions != null); 241779"];
7341 [label="Debug.Assert(extensions != null); 241780"];
7342 [label="NullableAnnotation 241781"];
7343 [label="_extensions 241782"];
7344 [label="param TransformType(Symbol accessSymbol) 241783"];
7345 [label="metadataType.HasType 241784"];
7346 [label="=> !(DefaultType is null) 241785"];
7347 [label="DefaultType is null 241786"];
7348 [label="!(DefaultType is null) 241787"];
7349 [label="Debug.Assert(metadataType.HasType); 241788"];
7350 [label="accessSymbol.IsDefinition 241789"];
7351 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 241790"];
7352 [label="OriginalDefinition 241791"];
7353 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 241792"];
7354 [label="OriginalSymbolDefinition 241793"];
7355 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 241794"];
7356 [label="this.OriginalTypeSymbolDefinition 241795"];
7357 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241796"];
7358 [label="this.OriginalDefinition 241797"];
7359 [label="get\n            {\n                return this;\n            } 241798"];
7360 [label="return this.OriginalDefinition; 241799"];
7361 [label="return this.OriginalTypeSymbolDefinition; 241800"];
7362 [label="return OriginalSymbolDefinition; 241801"];
7363 [label="return (object)this == (object)OriginalDefinition; 241802"];
7364 [label="Debug.Assert(accessSymbol.IsDefinition); 241803"];
7365 [label="accessSymbol.ContainingModule 241804"];
7366 [label="get\n            {\n                return ContainingPEModule;\n            } 241805"];
7367 [label="ContainingPEModule 241806"];
7368 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241807"];
7369 [label="s.Kind 241808"];
7370 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241809"];
7371 [label="return SymbolKind.Namespace; 241810"];
7372 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241811"];
7373 [label="return ContainingPEModule; 241812"];
7374 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 241813"];
7375 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241814"];
7376 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241815"];
7377 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 241816"];
7378 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 241817"];
7379 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 241818"];
7380 [label="Debug.Assert(symbol is object); 241819"];
7381 [label="symbol.Kind 241820"];
7382 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241821"];
7383 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 241822"];
7384 [label="isInternal = false; 241823"];
7385 [label="symbol.DeclaredAccessibility 241824"];
7386 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 241825"];
7387 [label="Accessibility access = Accessibility.Private; 241826"];
7388 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 241827"];
7389 [label="symbol.ContainingType 241828"];
7390 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 241829"];
7391 [label="return _container as NamedTypeSymbol; 241830"];
7392 [label="symbol = symbol.ContainingType; 241831"];
7393 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 241832"];
7394 [label="return true; 241833"];
7395 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 241834"];
7396 [label="byte? value; 241835"];
7397 [label="param TryGetByte(out byte? value) 241836"];
7398 [label="value = null; 241837"];
7399 [label="s.Kind 241838"];
7400 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241839"];
7401 [label="return SymbolKind.Namespace; 241840"];
7402 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241841"];
7403 [label="param GetNullableContextValue(this) 241842"];
7404 [label="param GetLocalNullableContextValue(this) 241843"];
7405 [label="get\n            {\n                return _moduleSymbol;\n            } 241844"];
7406 [label="return _moduleSymbol; 241845"];
7407 [label="param GetLocalNullableContextValue(this) 241846"];
7408 [label="get\n            {\n                return _assemblySymbol;\n            } 241847"];
7409 [label="return _assemblySymbol; 241848"];
7410 [label="param GetLocalNullableContextValue(this) 241849"];
7411 [label="get\n            {\n                return null;\n            } 241850"];
7412 [label="=> defaultType 241851"];
7413 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 241852"];
7414 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 241853"];
7415 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 241854"];
7416 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 241855"];
7417 [label="param TypeDependsClosure(NamedTypeSymbol type) 241856"];
7418 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 241857"];
7419 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 241858"];
7420 [label="if ((object)type == null)\n            {\n                return;\n            } 241859"];
7421 [label="if ((object)type == null)\n            {\n                return;\n            } 241860"];
7422 [label="this.SpecialType 241861"];
7423 [label="get\n            {\n                return _corTypeId;\n            } 241862"];
7424 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 241863"];
7425 [label="return (int)SpecialType.System_Object; 241864"];
7426 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 241865"];
7427 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 241866"];
7428 [label="s.Kind 241867"];
7429 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241868"];
7430 [label="return SymbolKind.Namespace; 241869"];
7431 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241870"];
7432 [label="return null; 241871"];
7433 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 241872"];
7434 [label="if ((object)type == null)\n            {\n                return;\n            } 241873"];
7435 [label="if ((object)type == null)\n            {\n                return;\n            } 241874"];
7436 [label="return; 241875"];
7437 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241876"];
7438 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241877"];
7439 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241878"];
7440 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241879"];
7441 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 241880"];
7442 [label="var result = hs.Contains(on); 241881"];
7443 [label="var result = hs.Contains(on); 241882"];
7444 [label="var result = hs.Contains(on); 241883"];
7445 [label="this.SpecialType 241884"];
7446 [label="OriginalDefinition 241885"];
7447 [label="hs.Free(); 241886"];
7448 [label="return result; 241887"];
7449 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 241888"];
7450 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 241889"];
7451 [label="_hasNoBaseCycles = true; 241890"];
7452 [label="_hasNoBaseCycles 241891"];
7453 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 241892"];
7454 [label="return declaredBase; 241893"];
7455 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 241894"];
7456 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 241895"];
7457 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 241896"];
7458 [label="return _lazyBaseType; 241897"];
7459 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 241898"];
7460 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 241899"];
7461 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 241900"];
7462 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 241901"];
7463 [label="@base.IsErrorType() 241902"];
7464 [label="param IsErrorType(this TypeSymbol type) 241903"];
7465 [label="RoslynDebug.Assert((object)type != null); 241904"];
7466 [label="RoslynDebug.Assert((object)type != null); 241905"];
7467 [label="type.Kind 241906"];
7468 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241907"];
7469 [label="return type.Kind == SymbolKind.ErrorType; 241908"];
7470 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 241909"];
7471 [label="@base.BaseTypeNoUseSiteDiagnostics 241910"];
7472 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 241911"];
7473 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 241912"];
7474 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 241913"];
7475 [label="Debug.Assert((object)depends != null); 241914"];
7476 [label="Debug.Assert((object)on != null); 241915"];
7477 [label="on.IsDefinition 241916"];
7478 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 241917"];
7479 [label="OriginalDefinition 241918"];
7480 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 241919"];
7481 [label="OriginalSymbolDefinition 241920"];
7482 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 241921"];
7483 [label="this.OriginalTypeSymbolDefinition 241922"];
7484 [label="get\n            {\n                return this.OriginalDefinition;\n            } 241923"];
7485 [label="this.OriginalDefinition 241924"];
7486 [label="get\n            {\n                return this;\n            } 241925"];
7487 [label="return this.OriginalDefinition; 241926"];
7488 [label="return this.OriginalTypeSymbolDefinition; 241927"];
7489 [label="return OriginalSymbolDefinition; 241928"];
7490 [label="return (object)this == (object)OriginalDefinition; 241929"];
7491 [label="Debug.Assert(on.IsDefinition); 241930"];
7492 [label="depends.DeclaringCompilation 241931"];
7493 [label="get { return null; } 241932"];
7494 [label="return null; 241933"];
7495 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 241934"];
7496 [label="if ((object)type == null)\n            {\n                return;\n            } 241935"];
7497 [label="return; 241936"];
7498 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241937"];
7499 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 241938"];
7500 [label="return result; 241939"];
7501 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 241940"];
7502 [label="@base = @base.BaseTypeNoUseSiteDiagnostics; 241941"];
7503 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 241942"];
7504 [label="@base.IsErrorType() 241943"];
7505 [label="param IsErrorType(this TypeSymbol type) 241944"];
7506 [label="RoslynDebug.Assert((object)type != null); 241945"];
7507 [label="RoslynDebug.Assert((object)type != null); 241946"];
7508 [label="type.Kind 241947"];
7509 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 241948"];
7510 [label="return type.Kind == SymbolKind.ErrorType; 241949"];
7511 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 241950"];
7512 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 241951"];
7513 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 241952"];
7514 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 241953"];
7515 [label="return null; 241954"];
7516 [label="return null; 241955"];
7517 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 241956"];
7518 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 241957"];
7519 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 241958"];
7520 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 241959"];
7521 [label="param MergeUseSiteDiagnostics(this) 241960"];
7522 [label="if (info == null)\n            {\n                return false;\n            } 241961"];
7523 [label="if (info == null)\n            {\n                return false;\n            } 241962"];
7524 [label="return false; 241963"];
7525 [label="this.ContainingModule 241964"];
7526 [label="get\n            {\n                return ContainingPEModule;\n            } 241965"];
7527 [label="ContainingPEModule 241966"];
7528 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241967"];
7529 [label="Symbol s = _container; 241968"];
7530 [label="s.Kind 241969"];
7531 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 241970"];
7532 [label="return SymbolKind.Namespace; 241971"];
7533 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 241972"];
7534 [label="((PENamespaceSymbol)s).ContainingPEModule 241973"];
7535 [label="return ContainingPEModule; 241974"];
7536 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 241975"];
7537 [label="this.ContainingModule.HasUnifiedReferences 241976"];
7538 [label="get { return GetUnifiedAssemblies().Length > 0; } 241977"];
7539 [label="GetUnifiedAssemblies() 241978"];
7540 [label="param GetUnifiedAssemblies(this) 241979"];
7541 [label="AssertReferencesInitialized() 241980"];
7542 [label="param AssertReferencesInitialized(this) 241981"];
7543 [label="Debug.Assert(_moduleReferences != null); 241982"];
7544 [label="Debug.Assert(_moduleReferences != null); 241983"];
7545 [label="AssertReferencesInitialized(); 241984"];
7546 [label="return GetUnifiedAssemblies().Length > 0; 241985"];
7547 [label="return GetUnifiedAssemblies().Length > 0; 241986"];
7548 [label="return result; 241987"];
7549 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 241988"];
7550 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 241989"];
7551 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 241990"];
7552 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 241991"];
7553 [label="param MergeUseSiteDiagnostics(this) 241992"];
7554 [label="if (info == null)\n            {\n                return false;\n            } 241993"];
7555 [label="if (info == null)\n            {\n                return false;\n            } 241994"];
7556 [label="return false; 241995"];
7557 [label="this.ContainingPEModule 241996"];
7558 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 241997"];
7559 [label="Symbol s = _container; 241998"];
7560 [label="s.Kind 241999"];
7561 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242000"];
7562 [label="return SymbolKind.Namespace; 242001"];
7563 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242002"];
7564 [label="((PENamespaceSymbol)s).ContainingPEModule 242003"];
7565 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 242004"];
7566 [label="this.ContainingPEModule.Module 242005"];
7567 [label="get\n            {\n                return _module;\n            } 242006"];
7568 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 242007"];
7569 [label="TypeKind 242008"];
7570 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 242009"];
7571 [label="TypeKind result = _lazyKind; 242010"];
7572 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 242011"];
7573 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 242012"];
7574 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 242013"];
7575 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 242014"];
7576 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 242015"];
7577 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 242016"];
7578 [label="result = TypeKind.Class; 242017"];
7579 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 242018"];
7580 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 242019"];
7581 [label="@base.SpecialType 242020"];
7582 [label="SpecialType baseCorTypeId = @base.SpecialType; 242021"];
7583 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 242022"];
7584 [label="this.SpecialType 242023"];
7585 [label="if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    } 242024"];
7586 [label="result = TypeKind.Struct; 242025"];
7587 [label="_lazyKind 242026"];
7588 [label="return result; 242027"];
7589 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 242028"];
7590 [label="return diagnostic; 242029"];
7591 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 242030"];
7592 [label="_lazyUseSiteDiagnostic 242031"];
7593 [label="return _lazyUseSiteDiagnostic; 242032"];
7594 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 242033"];
7595 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 242034"];
7596 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 242035"];
7597 [label="return typeSymbol; 242036"];
7598 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 242037"];
7599 [label="AreNullableAnnotationsEnabled(predefinedType.Keyword) 242038"];
7600 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 242039"];
7601 [label="param AreNullableAnnotationsEnabled(this) 242040"];
7602 [label="RoslynDebug.Assert(token.SyntaxTree is object); 242041"];
7603 [label="RoslynDebug.Assert(token.SyntaxTree is object); 242042"];
7604 [label="return AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart); 242043"];
7605 [label="AreNullableAnnotationsEnabled(token.SyntaxTree, token.SpanStart) 242044"];
7606 [label="param AreNullableAnnotationsEnabled(SyntaxTree syntaxTree) 242045"];
7607 [label="param AreNullableAnnotationsEnabled(int position) 242046"];
7608 [label="param AreNullableAnnotationsEnabled(this) 242047"];
7609 [label="CSharpSyntaxTree csTree = (CSharpSyntaxTree)syntaxTree; 242048"];
7610 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 242049"];
7611 [label="Syntax.NullableContextState context = csTree.GetNullableContextState(position); 242050"];
7612 [label="context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            } 242051"];
7613 [label="this.Compilation.Options 242052"];
7614 [label="get\n            {\n                return _options;\n            } 242053"];
7615 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 242054"];
7616 [label="return context.AnnotationsState switch\n            {\n                Syntax.NullableContextState.State.Enabled => true,\n                Syntax.NullableContextState.State.Disabled => false,\n                Syntax.NullableContextState.State.ExplicitlyRestored => GetGlobalAnnotationState(),\n                Syntax.NullableContextState.State.Unknown =>\n                    !csTree.IsGeneratedCode(this.Compilation.Options.SyntaxTreeOptionsProvider, CancellationToken.None)\n                    && AreNullableAnnotationsGloballyEnabled(),\n                _ => throw ExceptionUtilities.UnexpectedValue(context.AnnotationsState)\n            }; 242055"];
7617 [label="AreNullableAnnotationsGloballyEnabled() 242056"];
7618 [label="param AreNullableAnnotationsGloballyEnabled(this) 242057"];
7619 [label="RoslynDebug.Assert(Next is object); 242058"];
7620 [label="RoslynDebug.Assert(Next is object); 242059"];
7621 [label="Next.AreNullableAnnotationsGloballyEnabled() 242060"];
7622 [label="param AreNullableAnnotationsGloballyEnabled(this) 242061"];
7623 [label="RoslynDebug.Assert(Next is object); 242062"];
7624 [label="param AreNullableAnnotationsGloballyEnabled(this) 242063"];
7625 [label="GetGlobalAnnotationState() 242064"];
7626 [label="param GetGlobalAnnotationState(this) 242065"];
7627 [label="Compilation.Options 242066"];
7628 [label="get\n            {\n                return _options;\n            } 242067"];
7629 [label="switch (Compilation.Options.NullableContextOptions)\n            {\n                case NullableContextOptions.Enable:\n                case NullableContextOptions.Annotations:\n                    return true;\n\n                case NullableContextOptions.Disable:\n                case NullableContextOptions.Warnings:\n                    return false;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(Compilation.Options.NullableContextOptions);\n            } 242068"];
7630 [label="return false; 242069"];
7631 [label="return GetGlobalAnnotationState(); 242070"];
7632 [label="return Next.AreNullableAnnotationsGloballyEnabled(); 242071"];
7633 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 242072"];
7634 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 242073"];
7635 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type) 242074"];
7636 [label="param Create(bool isNullableEnabled) 242075"];
7637 [label="param Create(TypeSymbol typeSymbol) 242076"];
7638 [label="param Create(bool isAnnotated = false) 242077"];
7639 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 242078"];
7640 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 242079"];
7641 [label="isAnnotated 242080"];
7642 [label="isNullableEnabled 242081"];
7643 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 242082"];
7644 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 242083"];
7645 [label="Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious) 242084"];
7646 [label="param Create(TypeSymbol typeSymbol) 242085"];
7647 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 242086"];
7648 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 242087"];
7649 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 242088"];
7650 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 242089"];
7651 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 242090"];
7652 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 242091"];
7653 [label="typeSymbol.IsNullableType() 242092"];
7654 [label="param IsNullableType(this TypeSymbol type) 242093"];
7655 [label="type.OriginalDefinition 242094"];
7656 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 242095"];
7657 [label="OriginalTypeSymbolDefinition 242096"];
7658 [label="get\n            {\n                return this.OriginalDefinition;\n            } 242097"];
7659 [label="this.OriginalDefinition 242098"];
7660 [label="get\n            {\n                return this;\n            } 242099"];
7661 [label="return this.OriginalDefinition; 242100"];
7662 [label="return OriginalTypeSymbolDefinition; 242101"];
7663 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 242102"];
7664 [label="type.OriginalDefinition.SpecialType 242103"];
7665 [label="get\n            {\n                return _corTypeId;\n            } 242104"];
7666 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 242105"];
7667 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 242106"];
7668 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 242107"];
7669 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 242108"];
7670 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 242109"];
7671 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 242110"];
7672 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 242111"];
7673 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 242112"];
7674 [label="Extensions.Create(customModifiers) 242113"];
7675 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 242114"];
7676 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 242115"];
7677 [label="return Default; 242116"];
7678 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 242117"];
7679 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 242118"];
7680 [label="param TypeWithAnnotations(TypeSymbol defaultType) 242119"];
7681 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 242120"];
7682 [label="param TypeWithAnnotations(Extensions extensions) 242121"];
7683 [label="param TypeWithAnnotations(this) 242122"];
7684 [label="var a1 = defaultType is null; 242123"];
7685 [label="!a1 242124"];
7686 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 242125"];
7687 [label="defaultType.IsNullableType() 242126"];
7688 [label="param IsNullableType(this TypeSymbol type) 242127"];
7689 [label="type.OriginalDefinition 242128"];
7690 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 242129"];
7691 [label="OriginalTypeSymbolDefinition 242130"];
7692 [label="get\n            {\n                return this.OriginalDefinition;\n            } 242131"];
7693 [label="this.OriginalDefinition 242132"];
7694 [label="get\n            {\n                return this;\n            } 242133"];
7695 [label="return this; 242134"];
7696 [label="return this.OriginalDefinition; 242135"];
7697 [label="return OriginalTypeSymbolDefinition; 242136"];
7698 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 242137"];
7699 [label="type.OriginalDefinition.SpecialType 242138"];
7700 [label="get\n            {\n                return _corTypeId;\n            } 242139"];
7701 [label="return _corTypeId; 242140"];
7702 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 242141"];
7703 [label="Debug.Assert(a1 || a2 != true || a3); 242142"];
7704 [label="Debug.Assert(a1 || a2 != true || a3); 242143"];
7705 [label="Debug.Assert(extensions != null); 242144"];
7706 [label="Debug.Assert(extensions != null); 242145"];
7707 [label="DefaultType 242146"];
7708 [label="NullableAnnotation 242147"];
7709 [label="_extensions 242148"];
7710 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 242149"];
7711 [label="return Create(typeSymbol, nullableAnnotation: isAnnotated ? NullableAnnotation.Annotated : isNullableEnabled ? NullableAnnotation.NotAnnotated : NullableAnnotation.Oblivious); 242150"];
7712 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 242151"];
7713 [label="param operator(TypeWithAnnotations typeWithAnnotations) 242152"];
7714 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 242153"];
7715 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 242154"];
7716 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 242155"];
7717 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(TypeWithAnnotations typeWithAnnotations) 242156"];
7718 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 242157"];
7719 [label="typeWithAnnotations.HasType 242158"];
7720 [label="=> !(DefaultType is null) 242159"];
7721 [label="DefaultType is null 242160"];
7722 [label="!(DefaultType is null) 242161"];
7723 [label="Debug.Assert(typeWithAnnotations.HasType); 242162"];
7724 [label="_typeWithAnnotations 242163"];
7725 [label="_symbol = null; 242164"];
7726 [label="_symbol 242165"];
7727 [label="_isNullableEnabled = false; 242166"];
7728 [label="_isNullableEnabled 242167"];
7729 [label="return TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(predefinedType.Keyword), type); 242168"];
7730 [label="return bindPredefined(syntax, diagnostics); 242169"];
7731 [label="symbol.IsType 242170"];
7732 [label="=> !_typeWithAnnotations.IsDefault 242171"];
7733 [label="_typeWithAnnotations.IsDefault 242172"];
7734 [label="=> DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 242173"];
7735 [label="DefaultType is null 242174"];
7736 [label="DefaultType is null && this.NullableAnnotation == 0 242175"];
7737 [label="DefaultType is null && this.NullableAnnotation == 0 && (_extensions == null || _extensions == Extensions.Default) 242176"];
7738 [label="!_typeWithAnnotations.IsDefault 242177"];
7739 [label="if (symbol.IsType ||\n                (symbol.IsAlias && UnwrapAliasNoDiagnostics(symbol.Symbol, basesBeingResolved) is TypeSymbol))\n            {\n                if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                }\n\n                return symbol;\n            } 242178"];
7740 [label="symbol.IsType 242179"];
7741 [label="if (symbol.IsType)\n                {\n                    // Obsolete alias targets are reported in UnwrapAlias, but if it was a type (not an\n                    // alias to a type) we report the obsolete type here.\n                    symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics);\n                } 242180"];
7742 [label="symbol.TypeWithAnnotations 242181"];
7743 [label="=> _typeWithAnnotations 242182"];
7744 [label="_typeWithAnnotations 242183"];
7745 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 242184"];
7746 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 242185"];
7747 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 242186"];
7748 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 242187"];
7749 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics) 242188"];
7750 [label="param ReportDiagnosticsIfObsolete(Binder binder) 242189"];
7751 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 242190"];
7752 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 242191"];
7753 [label="=>\n            _extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 242192"];
7754 [label="this 242193"];
7755 [label="binder 242194"];
7756 [label="syntax 242195"];
7757 [label="diagnostics 242196"];
7758 [label="_extensions.ReportDiagnosticsIfObsolete(this, binder, syntax, diagnostics) 242197"];
7759 [label="param ReportDiagnosticsIfObsolete(TypeWithAnnotations type) 242198"];
7760 [label="param ReportDiagnosticsIfObsolete(Binder binder) 242199"];
7761 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 242200"];
7762 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 242201"];
7763 [label="param ReportDiagnosticsIfObsolete(this) 242202"];
7764 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 242203"];
7765 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 242204"];
7766 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 242205"];
7767 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics) 242206"];
7768 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 242207"];
7769 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 242208"];
7770 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 242209"];
7771 [label="param ReportDiagnosticsIfObsoleteCore(this) 242210"];
7772 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 242211"];
7773 [label="Type 242212"];
7774 [label="=> _extensions?.GetResolvedType(DefaultType) 242213"];
7775 [label="DefaultType 242214"];
7776 [label=".GetResolvedType(DefaultType) 242215"];
7777 [label="param GetResolvedType(TypeSymbol defaultType) 242216"];
7778 [label="=> defaultType 242217"];
7779 [label="defaultType 242218"];
7780 [label="_extensions?.GetResolvedType(DefaultType) 242219"];
7781 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 242220"];
7782 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 242221"];
7783 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false); 242222"];
7784 [label="binder.ReportDiagnosticsIfObsolete(diagnostics, Type, syntax, hasBaseReceiver: false) 242223"];
7785 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 242224"];
7786 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 242225"];
7787 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 242226"];
7788 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 242227"];
7789 [label="param ReportDiagnosticsIfObsolete(this) 242228"];
7790 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 242229"];
7791 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 242230"];
7792 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 242231"];
7793 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 242232"];
7794 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver) 242233"];
7795 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 242234"];
7796 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 242235"];
7797 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 242236"];
7798 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 242237"];
7799 [label="param ReportDiagnosticsIfObsolete(this) 242238"];
7800 [label="symbol.Kind 242239"];
7801 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242240"];
7802 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Event:\n                case SymbolKind.Property:\n                    ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags);\n                    break;\n            } 242241"];
7803 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242242"];
7804 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242243"];
7805 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242244"];
7806 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242245"];
7807 [label="this.ContainingMemberOrLambda 242246"];
7808 [label="get { return _containingMemberOrLambda; } 242247"];
7809 [label="return _containingMemberOrLambda; 242248"];
7810 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242249"];
7811 [label="this.ContainingType 242250"];
7812 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 242251"];
7813 [label="this.ContainingMemberOrLambda 242252"];
7814 [label="get { return _containingMemberOrLambda; } 242253"];
7815 [label="return _containingMemberOrLambda; 242254"];
7816 [label="var member = this.ContainingMemberOrLambda; 242255"];
7817 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 242256"];
7818 [label="member.Kind 242257"];
7819 [label="get\n            {\n                return SymbolKind.Field;\n            } 242258"];
7820 [label="return SymbolKind.Field; 242259"];
7821 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 242260"];
7822 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 242261"];
7823 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 242262"];
7824 [label="member.ContainingType 242263"];
7825 [label="return this.containingType; 242264"];
7826 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 242265"];
7827 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242266"];
7828 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242267"];
7829 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags) 242268"];
7830 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 242269"];
7831 [label="param ReportDiagnosticsIfObsolete(Symbol symbol) 242270"];
7832 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 242271"];
7833 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 242272"];
7834 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 242273"];
7835 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 242274"];
7836 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 242275"];
7837 [label="RoslynDebug.Assert(symbol is object); 242276"];
7838 [label="RoslynDebug.Assert(symbol is object); 242277"];
7839 [label="symbol.Kind 242278"];
7840 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242279"];
7841 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 242280"];
7842 [label="symbol.Kind 242281"];
7843 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242282"];
7844 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 242283"];
7845 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 242284"];
7846 [label="Symbol leastOverriddenSymbol = symbol.GetLeastOverriddenMember(containingType); 242285"];
7847 [label="symbol.GetLeastOverriddenMember(containingType) 242286"];
7848 [label="param GetLeastOverriddenMember(this Symbol member) 242287"];
7849 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 242288"];
7850 [label="member.Kind 242289"];
7851 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242290"];
7852 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    var method = (MethodSymbol)member;\n                    return method.GetConstructedLeastOverriddenMethod(accessingTypeOpt, requireSameReturnType: false);\n\n                case SymbolKind.Property:\n                    var property = (PropertySymbol)member;\n                    return property.GetLeastOverriddenProperty(accessingTypeOpt);\n\n                case SymbolKind.Event:\n                    var evnt = (EventSymbol)member;\n                    return evnt.GetLeastOverriddenEvent(accessingTypeOpt);\n\n                default:\n                    return member;\n            } 242291"];
7853 [label="return member; 242292"];
7854 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 242293"];
7855 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 242294"];
7856 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 242295"];
7857 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 242296"];
7858 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 242297"];
7859 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 242298"];
7860 [label="var diagnosticKind = ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location); 242299"];
7861 [label="ReportDiagnosticsIfObsoleteInternal(diagnostics, leastOverriddenSymbol, node, containingMember, location) 242300"];
7862 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 242301"];
7863 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol symbol) 242302"];
7864 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 242303"];
7865 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 242304"];
7866 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 242305"];
7867 [label="RoslynDebug.Assert(diagnostics != null); 242306"];
7868 [label="RoslynDebug.Assert(diagnostics != null); 242307"];
7869 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 242308"];
7870 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 242309"];
7871 [label="var kind = ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember); 242310"];
7872 [label="ObsoleteAttributeHelpers.GetObsoleteDiagnosticKind(symbol, containingMember) 242311"];
7873 [label="param GetObsoleteDiagnosticKind(Symbol symbol) 242312"];
7874 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 242313"];
7875 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 242314"];
7876 [label="symbol.ObsoleteKind 242315"];
7877 [label="get\n            {\n                var data = this.ObsoleteAttributeData;\n                return (data == null) ? ObsoleteAttributeKind.None : data.Kind;\n            } 242316"];
7878 [label="this.ObsoleteAttributeData 242317"];
7879 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                }\n\n                bool ignoreByRefLikeMarker = this.IsRefLikeType;\n                ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker);\n                return uncommon.lazyObsoleteAttributeData;\n            } 242318"];
7880 [label="GetUncommonProperties() 242319"];
7881 [label="param GetUncommonProperties(this) 242320"];
7882 [label="var result = _lazyUncommonProperties; 242321"];
7883 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 242322"];
7884 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 242323"];
7885 [label="this.IsUncommon() 242324"];
7886 [label="param IsUncommon(this) 242325"];
7887 [label="this.ContainingPEModule 242326"];
7888 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 242327"];
7889 [label="Symbol s = _container; 242328"];
7890 [label="s.Kind 242329"];
7891 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242330"];
7892 [label="return SymbolKind.Namespace; 242331"];
7893 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242332"];
7894 [label="((PENamespaceSymbol)s).ContainingPEModule 242333"];
7895 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 242334"];
7896 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 242335"];
7897 [label="this.ContainingPEModule.HasAnyCustomAttributes(_handle) 242336"];
7898 [label="param HasAnyCustomAttributes(EntityHandle token) 242337"];
7899 [label="param HasAnyCustomAttributes(this) 242338"];
7900 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 242339"];
7901 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 242340"];
7902 [label="return true; 242341"];
7903 [label="return true; 242342"];
7904 [label="if (this.IsUncommon())\n            {\n                result = new UncommonProperties();\n                return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result;\n            } 242343"];
7905 [label="result = new UncommonProperties(); 242344"];
7906 [label="new UncommonProperties() 242345"];
7907 [label="param UncommonProperties(this) 242346"];
7908 [label="lazyEnumUnderlyingType 242347"];
7909 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 242348"];
7910 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 242349"];
7911 [label="lazyContainsExtensionMethods 242350"];
7912 [label="lazyIsByRefLike 242351"];
7913 [label="lazyIsReadOnly 242352"];
7914 [label="lazyDefaultMemberName 242353"];
7915 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 242354"];
7916 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 242355"];
7917 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 242356"];
7918 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 242357"];
7919 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 242358"];
7920 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 242359"];
7921 [label="var uncommon = GetUncommonProperties(); 242360"];
7922 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 242361"];
7923 [label="this.IsRefLikeType 242362"];
7924 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                }\n\n                return uncommon.lazyIsByRefLike.Value();\n            } 242363"];
7925 [label="GetUncommonProperties() 242364"];
7926 [label="param GetUncommonProperties(this) 242365"];
7927 [label="var result = _lazyUncommonProperties; 242366"];
7928 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 242367"];
7929 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 242368"];
7930 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 242369"];
7931 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 242370"];
7932 [label="return result; 242371"];
7933 [label="var uncommon = GetUncommonProperties(); 242372"];
7934 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 242373"];
7935 [label="if (!uncommon.lazyIsByRefLike.HasValue())\n                {\n                    var isByRefLike = ThreeState.False;\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    }\n\n                    uncommon.lazyIsByRefLike = isByRefLike;\n                } 242374"];
7936 [label="var isByRefLike = ThreeState.False; 242375"];
7937 [label="this.TypeKind 242376"];
7938 [label="return result; 242377"];
7939 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        var moduleSymbol = this.ContainingPEModule;\n                        var module = moduleSymbol.Module;\n                        isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState();\n                    } 242378"];
7940 [label="this.ContainingPEModule 242379"];
7941 [label="s.Kind 242380"];
7942 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242381"];
7943 [label="return SymbolKind.Namespace; 242382"];
7944 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242383"];
7945 [label="var moduleSymbol = this.ContainingPEModule; 242384"];
7946 [label="moduleSymbol.Module 242385"];
7947 [label="get\n            {\n                return _module;\n            } 242386"];
7948 [label="var module = moduleSymbol.Module; 242387"];
7949 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 242388"];
7950 [label="isByRefLike = module.HasIsByRefLikeAttribute(_handle).ToThreeState(); 242389"];
7951 [label="uncommon.lazyIsByRefLike 242390"];
7952 [label="return uncommon.lazyIsByRefLike.Value(); 242391"];
7953 [label="bool ignoreByRefLikeMarker = this.IsRefLikeType; 242392"];
7954 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 242393"];
7955 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 242394"];
7956 [label="ContainingPEModule 242395"];
7957 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 242396"];
7958 [label="Symbol s = _container; 242397"];
7959 [label="s.Kind 242398"];
7960 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242399"];
7961 [label="return SymbolKind.Namespace; 242400"];
7962 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242401"];
7963 [label="((PENamespaceSymbol)s).ContainingPEModule 242402"];
7964 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 242403"];
7965 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 242404"];
7966 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker) 242405"];
7967 [label="param InitializeObsoleteDataFromMetadata(ref ObsoleteAttributeData data) 242406"];
7968 [label="param InitializeObsoleteDataFromMetadata(EntityHandle token) 242407"];
7969 [label="param InitializeObsoleteDataFromMetadata(PEModuleSymbol containingModule) 242408"];
7970 [label="param InitializeObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 242409"];
7971 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 242410"];
7972 [label="if (ReferenceEquals(data, ObsoleteAttributeData.Uninitialized))\n            {\n                ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker);\n                Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized);\n            } 242411"];
7973 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 242412"];
7974 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 242413"];
7975 [label="ObsoleteAttributeData obsoleteAttributeData = GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker); 242414"];
7976 [label="GetObsoleteDataFromMetadata(token, containingModule, ignoreByRefLikeMarker) 242415"];
7977 [label="param GetObsoleteDataFromMetadata(EntityHandle token) 242416"];
7978 [label="param GetObsoleteDataFromMetadata(PEModuleSymbol containingModule) 242417"];
7979 [label="param GetObsoleteDataFromMetadata(bool ignoreByRefLikeMarker) 242418"];
7980 [label="containingModule.Module 242419"];
7981 [label="get\n            {\n                return _module;\n            } 242420"];
7982 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242421"];
7983 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242422"];
7984 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242423"];
7985 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242424"];
7986 [label="new MetadataDecoder(containingModule) 242425"];
7987 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 242426"];
7988 [label="param MetadataDecoder(this) 242427"];
7989 [label="moduleSymbol 242428"];
7990 [label="null 242429"];
7991 [label="null 242430"];
7992 [label="param MetadataDecoder(this) 242431"];
7993 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 242432"];
7994 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 242433"];
7995 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 242434"];
7996 [label="return _assembly.Identity; 242435"];
7997 [label="Debug.Assert((object)moduleSymbol != null); 242436"];
7998 [label="Debug.Assert((object)moduleSymbol != null); 242437"];
7999 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242438"];
8000 [label="var obsoleteAttributeData = containingModule.Module.TryGetDeprecatedOrExperimentalOrObsoleteAttribute(token, new MetadataDecoder(containingModule), ignoreByRefLikeMarker); 242439"];
8001 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 242440"];
8002 [label="Debug.Assert(obsoleteAttributeData == null || !obsoleteAttributeData.IsUninitialized); 242441"];
8003 [label="return obsoleteAttributeData; 242442"];
8004 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 242443"];
8005 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 242444"];
8006 [label="Interlocked.CompareExchange(ref data, obsoleteAttributeData, ObsoleteAttributeData.Uninitialized); 242445"];
8007 [label="ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(ref uncommon.lazyObsoleteAttributeData, _handle, ContainingPEModule, ignoreByRefLikeMarker); 242446"];
8008 [label="return uncommon.lazyObsoleteAttributeData; 242447"];
8009 [label="var data = this.ObsoleteAttributeData; 242448"];
8010 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 242449"];
8011 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 242450"];
8012 [label="(data == null) 242451"];
8013 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 242452"];
8014 [label="return ObsoleteDiagnosticKind.NotObsolete; 242453"];
8015 [label="DiagnosticInfo? info = null; 242454"];
8016 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 242455"];
8017 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 242456"];
8018 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 242457"];
8019 [label="return kind; 242458"];
8020 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 242459"];
8021 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 242460"];
8022 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, node, hasBaseReceiver, this.ContainingMemberOrLambda, this.ContainingType, this.Flags); 242461"];
8023 [label="ReportDiagnosticsIfObsolete(diagnostics, symbol, (SyntaxNodeOrToken)node, hasBaseReceiver); 242462"];
8024 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 242463"];
8025 [label="symbol.TypeWithAnnotations.ReportDiagnosticsIfObsolete(this, syntax, diagnostics); 242464"];
8026 [label="return symbol; 242465"];
8027 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 242466"];
8028 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 242467"];
8029 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 242468"];
8030 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 242469"];
8031 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 242470"];
8032 [label="param UnwrapAlias(in NamespaceOrTypeOrAliasSymbolWithAnnotations symbol) 242471"];
8033 [label="param UnwrapAlias(DiagnosticBag diagnostics) 242472"];
8034 [label="param UnwrapAlias(SyntaxNode syntax) 242473"];
8035 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 242474"];
8036 [label="param UnwrapAlias(this) 242475"];
8037 [label="symbol.IsAlias 242476"];
8038 [label="=> _symbol?.Kind == SymbolKind.Alias 242477"];
8039 [label="_symbol 242478"];
8040 [label="_symbol?.Kind == SymbolKind.Alias 242479"];
8041 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 242480"];
8042 [label="return symbol; 242481"];
8043 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 242482"];
8044 [label="=> _typeWithAnnotations 242483"];
8045 [label="_typeWithAnnotations 242484"];
8046 [label="type.IsStatic 242485"];
8047 [label="=>\n            _extensions.IsStatic(DefaultType) 242486"];
8048 [label="DefaultType 242487"];
8049 [label="_extensions.IsStatic(DefaultType) 242488"];
8050 [label="param IsStatic(TypeSymbol typeSymbol) 242489"];
8051 [label="=> typeSymbol.IsStatic 242490"];
8052 [label="typeSymbol.IsStatic 242491"];
8053 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 242492"];
8054 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 242493"];
8055 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 242494"];
8056 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 242495"];
8057 [label="if (disallowRestrictedTypes)\n            {\n                // Restricted types cannot be on the heap, but they can be on the stack, so are allowed in a stackalloc\n                if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                }\n            } 242496"];
8058 [label="ShouldCheckConstraints 242497"];
8059 [label="get\n            {\n                return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks);\n            } 242498"];
8060 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 242499"];
8061 [label="return !this.Flags.Includes(BinderFlags.SuppressConstraintChecks); 242500"];
8062 [label="this.Flags.Includes(BinderFlags.SuppressConstraintChecks) 242501"];
8063 [label="param Includes(this BinderFlags self) 242502"];
8064 [label="param Includes(BinderFlags other) 242503"];
8065 [label="if (ShouldCheckConstraints)\n                {\n                    if (type.IsRestrictedType())\n                    {\n                        // CS0611: Array elements cannot be of type '{0}'\n                        Error(diagnostics, ErrorCode.ERR_ArrayElementCantBeRefAny, node.ElementType, type.Type);\n                    }\n                }\n                else\n                {\n                    diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation());\n                } 242504"];
8066 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 242505"];
8067 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 242506"];
8068 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 242507"];
8069 [label="diagnostics.Add(new LazyArrayElementCantBeRefAnyDiagnosticInfo(type), node.ElementType.GetLocation()); 242508"];
8070 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 242509"];
8071 [label="for (int i = node.RankSpecifiers.Count - 1; i >= 0; i--)\n            {\n                var rankSpecifier = node.RankSpecifiers[i];\n                var dimension = rankSpecifier.Sizes;\n                if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                }\n\n                var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank);\n                type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array);\n            } 242510"];
8072 [label="var rankSpecifier = node.RankSpecifiers[i]; 242511"];
8073 [label="var dimension = rankSpecifier.Sizes; 242512"];
8074 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 242513"];
8075 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 242514"];
8076 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 242515"];
8077 [label="this.Compilation.Assembly 242516"];
8078 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 242517"];
8079 [label="return _referenceManager; 242518"];
8080 [label="GetBoundReferenceManager(); 242519"];
8081 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 242520"];
8082 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 242521"];
8083 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 242522"];
8084 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 242523"];
8085 [label="ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank) 242524"];
8086 [label="param CreateCSharpArray(AssemblySymbol declaringAssembly) 242525"];
8087 [label="param CreateCSharpArray(TypeWithAnnotations elementTypeWithAnnotations) 242526"];
8088 [label="param CreateCSharpArray(int rank = 1) 242527"];
8089 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 242528"];
8090 [label="if (rank == 1)\n            {\n                return CreateSZArray(declaringAssembly, elementTypeWithAnnotations);\n            } 242529"];
8091 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 242530"];
8092 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 242531"];
8093 [label="CreateSZArray(declaringAssembly, elementTypeWithAnnotations) 242532"];
8094 [label="param CreateSZArray(AssemblySymbol declaringAssembly) 242533"];
8095 [label="param CreateSZArray(TypeWithAnnotations elementType) 242534"];
8096 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 242535"];
8097 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 242536"];
8098 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 242537"];
8099 [label="param GetSpecialType(SpecialType type) 242538"];
8100 [label="param GetSpecialType(this) 242539"];
8101 [label="this.Modules 242540"];
8102 [label="get\n            {\n                return _modules;\n            } 242541"];
8103 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 242542"];
8104 [label="module.GetReferencedAssemblies() 242543"];
8105 [label="param GetReferencedAssemblies(this) 242544"];
8106 [label="AssertReferencesInitialized() 242545"];
8107 [label="param AssertReferencesInitialized(this) 242546"];
8108 [label="Debug.Assert(_moduleReferences != null); 242547"];
8109 [label="Debug.Assert(_moduleReferences != null); 242548"];
8110 [label="AssertReferencesInitialized(); 242549"];
8111 [label="return _moduleReferences.Identities; 242550"];
8112 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 242551"];
8113 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 242552"];
8114 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 242553"];
8115 [label="return _lazySpecialTypes[(int)type]; 242554"];
8116 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 242555"];
8117 [label="GetSZArrayInterfaces(elementType, declaringAssembly) 242556"];
8118 [label="param GetSZArrayInterfaces(TypeWithAnnotations elementTypeWithAnnotations) 242557"];
8119 [label="param GetSZArrayInterfaces(AssemblySymbol declaringAssembly) 242558"];
8120 [label="var constructedInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 242559"];
8121 [label="var iListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T); 242560"];
8122 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IList_T) 242561"];
8123 [label="param GetSpecialType(SpecialType type) 242562"];
8124 [label="param GetSpecialType(this) 242563"];
8125 [label="this.Modules 242564"];
8126 [label="get\n            {\n                return _modules;\n            } 242565"];
8127 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 242566"];
8128 [label="module.GetReferencedAssemblies() 242567"];
8129 [label="param GetReferencedAssemblies(this) 242568"];
8130 [label="AssertReferencesInitialized() 242569"];
8131 [label="param AssertReferencesInitialized(this) 242570"];
8132 [label="Debug.Assert(_moduleReferences != null); 242571"];
8133 [label="Debug.Assert(_moduleReferences != null); 242572"];
8134 [label="AssertReferencesInitialized(); 242573"];
8135 [label="return _moduleReferences.Identities; 242574"];
8136 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 242575"];
8137 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 242576"];
8138 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 242577"];
8139 [label="NamedTypeSymbol result; 242578"];
8140 [label="NamespaceSymbol nextScope = null; 242579"];
8141 [label="EnsureAllMembersLoaded(); 242580"];
8142 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 242581"];
8143 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 242582"];
8144 [label="if ((object)scope == null)\n                {\n                    break;\n                } 242583"];
8145 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 242584"];
8146 [label="Debug.Assert(typesByNS != null); 242585"];
8147 [label="get\n            {\n                return false;\n            } 242586"];
8148 [label="ContainingNamespace 242587"];
8149 [label="var parent = ContainingNamespace; 242588"];
8150 [label=".IsGlobalNamespace 242589"];
8151 [label="get\n            {\n                return false;\n            } 242590"];
8152 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 242591"];
8153 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 242592"];
8154 [label="parent.Name 242593"];
8155 [label="get\n            {\n                return _name;\n            } 242594"];
8156 [label="length += parent.Name.Length + 1; 242595"];
8157 [label="length += parent.Name.Length + 1; 242596"];
8158 [label="parent.ContainingNamespace 242597"];
8159 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 242598"];
8160 [label="parent = parent.ContainingNamespace; 242599"];
8161 [label="get\n            {\n                return true;\n            } 242600"];
8162 [label="_containingNamespaceSymbol 242601"];
8163 [label="_name 242602"];
8164 [label="_typesByNS 242603"];
8165 [label="Debug.Assert(name != null); 242604"];
8166 [label="Debug.Assert((object)containingNamespace != null); 242605"];
8167 [label="Debug.Assert(typesByNS != null); 242606"];
8168 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 242607"];
8169 [label="genericParameterHandles 242608"];
8170 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 242609"];
8171 [label="param GetGenericInfo(out ushort arity) 242610"];
8172 [label="param GetGenericInfo(out BadImageFormatException mrEx) 242611"];
8173 [label="mrEx = null; 242612"];
8174 [label="PENamedTypeSymbol result; 242613"];
8175 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 242614"];
8176 [label="mangleName 242615"];
8177 [label="param PENamedTypeSymbol(out bool mangleName) 242616"];
8178 [label="_lazyTupleData 242617"];
8179 [label="_container 242618"];
8180 [label="_name 242619"];
8181 [label="_flags 242620"];
8182 [label="_corTypeId 242621"];
8183 [label="Debug.Assert(!handle.IsNil); 242622"];
8184 [label="Debug.Assert((object)container != null); 242623"];
8185 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 242624"];
8186 [label="string metadataName; 242625"];
8187 [label="bool makeBad = false; 242626"];
8188 [label="mangleName = false; 242627"];
8189 [label="Accessibility access = Accessibility.Private; 242628"];
8190 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 242629"];
8191 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 242630"];
8192 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 242631"];
8193 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 242632"];
8194 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 242633"];
8195 [label="bool added; 242634"];
8196 [label="Debug.Assert(added); 242635"];
8197 [label="Debug.Assert(typeId != SpecialType.None); 242636"];
8198 [label="corType.ContainingAssembly 242637"];
8199 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 242638"];
8200 [label="this.ContainingSymbol 242639"];
8201 [label="get\n            {\n                return _container;\n            } 242640"];
8202 [label="return _container; 242641"];
8203 [label="var container = this.ContainingSymbol; 242642"];
8204 [label="return (object)container != null ? container.ContainingAssembly : null; 242643"];
8205 [label="return (object)container != null ? container.ContainingAssembly : null; 242644"];
8206 [label="(object)container != null 242645"];
8207 [label="container.ContainingAssembly 242646"];
8208 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 242647"];
8209 [label="ContainingPEModule 242648"];
8210 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 242649"];
8211 [label="return ContainingPEModule.ContainingAssembly; 242650"];
8212 [label="ContainingPEModule.ContainingAssembly 242651"];
8213 [label="get\n            {\n                return _assemblySymbol;\n            } 242652"];
8214 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242653"];
8215 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242654"];
8216 [label="corType.ContainingModule 242655"];
8217 [label="get\n            {\n                return ContainingPEModule;\n            } 242656"];
8218 [label="ContainingPEModule 242657"];
8219 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 242658"];
8220 [label="s.Kind 242659"];
8221 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242660"];
8222 [label="return SymbolKind.Namespace; 242661"];
8223 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242662"];
8224 [label="return ContainingPEModule; 242663"];
8225 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242664"];
8226 [label="corType.ContainingModule.Ordinal 242665"];
8227 [label="get\n            {\n                return _ordinal;\n            } 242666"];
8228 [label="return _ordinal; 242667"];
8229 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242668"];
8230 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 242669"];
8231 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 242670"];
8232 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 242671"];
8233 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 242672"];
8234 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 242673"];
8235 [label="if ((object)scope == null)\n                {\n                    break;\n                } 242674"];
8236 [label="Debug.Assert(!emittedTypeName.IsNull); 242675"];
8237 [label="scope.Kind 242676"];
8238 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242677"];
8239 [label="return SymbolKind.Namespace; 242678"];
8240 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 242679"];
8241 [label="NamedTypeSymbol? namedType = null; 242680"];
8242 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 242681"];
8243 [label="namespaceOrTypeMembers 242682"];
8244 [label="scope.IsNamespace 242683"];
8245 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 242684"];
8246 [label="Kind 242685"];
8247 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242686"];
8248 [label="return SymbolKind.Namespace; 242687"];
8249 [label="return Kind == SymbolKind.Namespace; 242688"];
8250 [label="bool isTopLevel = scope.IsNamespace; 242689"];
8251 [label="param NamespaceOrTypeSymbol(this) 242690"];
8252 [label="param Symbol(this) 242691"];
8253 [label="_underlying 242692"];
8254 [label="Debug.Assert(underlying is object); 242693"];
8255 [label="param ToDisplayParts(bool minimal) 242694"];
8256 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 242695"];
8257 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 242696"];
8258 [label="Debug.Assert(semanticModelOpt == null); 242697"];
8259 [label="Debug.Assert(positionOpt < 0); 242698"];
8260 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 242699"];
8261 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 242700"];
8262 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 242701"];
8263 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 242702"];
8264 [label="return (TISymbol?)symbol?.ISymbol; 242703"];
8265 [label="var containingNamespace = symbol.ContainingNamespace; 242704"];
8266 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 242705"];
8267 [label="ShouldVisitNamespace(containingNamespace) 242706"];
8268 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 242707"];
8269 [label="param ShouldVisitNamespace(this) 242708"];
8270 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 242709"];
8271 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 242710"];
8272 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 242711"];
8273 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 242712"];
8274 [label="namespaceSymbol.IsGlobalNamespace 242713"];
8275 [label="=> _underlying.IsGlobalNamespace 242714"];
8276 [label="get\n            {\n                return false;\n            } 242715"];
8277 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 242716"];
8278 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 242717"];
8279 [label="containingNamespace.Accept(this.NotFirstVisitor); 242718"];
8280 [label="this.NotFirstVisitor 242719"];
8281 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 242720"];
8282 [label="param MakeNotFirstVisitor(this) 242721"];
8283 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 242722"];
8284 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 242723"];
8285 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 242724"];
8286 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 242725"];
8287 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 242726"];
8288 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 242727"];
8289 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 242728"];
8290 [label="param SymbolDisplayVisitor(int positionOpt) 242729"];
8291 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 242730"];
8292 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 242731"];
8293 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 242732"];
8294 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 242733"];
8295 [label="param SymbolDisplayVisitor(this) 242734"];
8296 [label="builder 242735"];
8297 [label="format 242736"];
8298 [label="isFirstSymbolVisited 242737"];
8299 [label="semanticModelOpt 242738"];
8300 [label="positionOpt 242739"];
8301 [label="inNamespaceOrType 242740"];
8302 [label="param SymbolDisplayVisitor(this) 242741"];
8303 [label="param SymbolDisplayVisitor(this) 242742"];
8304 [label="_escapeKeywordIdentifiers 242743"];
8305 [label="_lazyAliasMap 242744"];
8306 [label="containingNamespace.Accept(this.NotFirstVisitor); 242745"];
8307 [label="containingNamespace.Accept(this.NotFirstVisitor); 242746"];
8308 [label="containingNamespace.Accept(this.NotFirstVisitor) 242747"];
8309 [label="param Accept(SymbolVisitor visitor) 242748"];
8310 [label="param Accept(this) 242749"];
8311 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 242750"];
8312 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 242751"];
8313 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 242752"];
8314 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 242753"];
8315 [label="param ShouldVisitNamespace(this) 242754"];
8316 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 242755"];
8317 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 242756"];
8318 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 242757"];
8319 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 242758"];
8320 [label="=> _underlying.IsGlobalNamespace 242759"];
8321 [label="get\n            {\n                return false;\n            } 242760"];
8322 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 242761"];
8323 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 242762"];
8324 [label="get\n            {\n                return true;\n            } 242763"];
8325 [label="=> _underlying.IsGlobalNamespace 242764"];
8326 [label="get\n            {\n                return false;\n            } 242765"];
8327 [label="containingNamespace.IsGlobalNamespace 242766"];
8328 [label="=> _underlying.IsGlobalNamespace 242767"];
8329 [label="get\n            {\n                return false;\n            } 242768"];
8330 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 242769"];
8331 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 242770"];
8332 [label="param AddPunctuation(SyntaxKind punctuationKind) 242771"];
8333 [label="param AddPunctuation(this) 242772"];
8334 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242773"];
8335 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242774"];
8336 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242775"];
8337 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 242776"];
8338 [label="param CreatePart(SymbolDisplayPartKind kind) 242777"];
8339 [label="param CreatePart(ISymbol symbol) 242778"];
8340 [label="param CreatePart(string text) 242779"];
8341 [label="param CreatePart(this) 242780"];
8342 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 242781"];
8343 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 242782"];
8344 [label="=> _underlying.IsGlobalNamespace 242783"];
8345 [label="get\n            {\n                return false;\n            } 242784"];
8346 [label="containingNamespace.Accept(this.NotFirstVisitor); 242785"];
8347 [label="containingNamespace.IsGlobalNamespace 242786"];
8348 [label="=> _underlying.IsGlobalNamespace 242787"];
8349 [label="get\n            {\n                return false;\n            } 242788"];
8350 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 242789"];
8351 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 242790"];
8352 [label="param AddPunctuation(SyntaxKind punctuationKind) 242791"];
8353 [label="param AddPunctuation(this) 242792"];
8354 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242793"];
8355 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242794"];
8356 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 242795"];
8357 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 242796"];
8358 [label="param CreatePart(SymbolDisplayPartKind kind) 242797"];
8359 [label="param CreatePart(ISymbol symbol) 242798"];
8360 [label="param CreatePart(string text) 242799"];
8361 [label="param CreatePart(this) 242800"];
8362 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 242801"];
8363 [label="=> _underlying.IsGlobalNamespace 242802"];
8364 [label="get\n            {\n                return false;\n            } 242803"];
8365 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 242804"];
8366 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 242805"];
8367 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 242806"];
8368 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 242807"];
8369 [label="if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                } 242808"];
8370 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName); 242809"];
8371 [label="scope.GetTypeMembers(emittedTypeName.UnmangledTypeName) 242810"];
8372 [label="param GetTypeMembers(string name) 242811"];
8373 [label="var typesByNS = _typesByNS; 242812"];
8374 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 242813"];
8375 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 242814"];
8376 [label="Debug.Assert(typesByNS != null); 242815"];
8377 [label="get\n            {\n                return false;\n            } 242816"];
8378 [label="parent.ContainingNamespace 242817"];
8379 [label="parent = parent.ContainingNamespace; 242818"];
8380 [label="get\n            {\n                return false;\n            } 242819"];
8381 [label="get\n            {\n                return true;\n            } 242820"];
8382 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 242821"];
8383 [label="genericParameterHandles 242822"];
8384 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 242823"];
8385 [label="param GetGenericInfo(out ushort arity) 242824"];
8386 [label="param GetGenericInfo(out BadImageFormatException mrEx) 242825"];
8387 [label="mrEx = null; 242826"];
8388 [label="PENamedTypeSymbol result; 242827"];
8389 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 242828"];
8390 [label="mangleName 242829"];
8391 [label="param PENamedTypeSymbol(out bool mangleName) 242830"];
8392 [label="_lazyTupleData 242831"];
8393 [label="_container 242832"];
8394 [label="_name 242833"];
8395 [label="_flags 242834"];
8396 [label="_corTypeId 242835"];
8397 [label="Debug.Assert(!handle.IsNil); 242836"];
8398 [label="Debug.Assert((object)container != null); 242837"];
8399 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 242838"];
8400 [label="string metadataName; 242839"];
8401 [label="bool makeBad = false; 242840"];
8402 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 242841"];
8403 [label="Accessibility access = Accessibility.Private; 242842"];
8404 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 242843"];
8405 [label="_arity 242844"];
8406 [label="_mangleName 242845"];
8407 [label="Debug.Assert(genericParameterHandles.Count > 0); 242846"];
8408 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 242847"];
8409 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 242848"];
8410 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 242849"];
8411 [label="mangleName 242850"];
8412 [label="param PENamedTypeSymbol(out bool mangleName) 242851"];
8413 [label="mangleName = false; 242852"];
8414 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 242853"];
8415 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 242854"];
8416 [label="bool added; 242855"];
8417 [label="Debug.Assert(added); 242856"];
8418 [label="Debug.Assert(typeId != SpecialType.None); 242857"];
8419 [label="corType.ContainingAssembly 242858"];
8420 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 242859"];
8421 [label="this.ContainingSymbol 242860"];
8422 [label="get\n            {\n                return _container;\n            } 242861"];
8423 [label="return _container; 242862"];
8424 [label="var container = this.ContainingSymbol; 242863"];
8425 [label="return (object)container != null ? container.ContainingAssembly : null; 242864"];
8426 [label="return (object)container != null ? container.ContainingAssembly : null; 242865"];
8427 [label="(object)container != null 242866"];
8428 [label="container.ContainingAssembly 242867"];
8429 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 242868"];
8430 [label="ContainingPEModule 242869"];
8431 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 242870"];
8432 [label="return ContainingPEModule.ContainingAssembly; 242871"];
8433 [label="ContainingPEModule.ContainingAssembly 242872"];
8434 [label="get\n            {\n                return _assemblySymbol;\n            } 242873"];
8435 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242874"];
8436 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242875"];
8437 [label="corType.ContainingModule 242876"];
8438 [label="get\n            {\n                return ContainingPEModule;\n            } 242877"];
8439 [label="ContainingPEModule 242878"];
8440 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 242879"];
8441 [label="s.Kind 242880"];
8442 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242881"];
8443 [label="return SymbolKind.Namespace; 242882"];
8444 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242883"];
8445 [label="return ContainingPEModule; 242884"];
8446 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242885"];
8447 [label="corType.ContainingModule.Ordinal 242886"];
8448 [label="get\n            {\n                return _ordinal;\n            } 242887"];
8449 [label="return _ordinal; 242888"];
8450 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242889"];
8451 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 242890"];
8452 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 242891"];
8453 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 242892"];
8454 [label="EnsureAllMembersLoaded(); 242893"];
8455 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 242894"];
8456 [label="foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    } 242895"];
8457 [label="named.Arity 242896"];
8458 [label="get\n                {\n                    return _arity;\n                } 242897"];
8459 [label="return _arity; 242898"];
8460 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 242899"];
8461 [label="named.MangleName 242900"];
8462 [label="get\n                {\n                    return _mangleName;\n                } 242901"];
8463 [label="return _mangleName; 242902"];
8464 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 242903"];
8465 [label="if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        } 242904"];
8466 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 242905"];
8467 [label="if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            } 242906"];
8468 [label="namedType = named; 242907"];
8469 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 242908"];
8470 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 242909"];
8471 [label="Debug.Assert((object)result != null); 242910"];
8472 [label="Debug.Assert((object)result != null); 242911"];
8473 [label="result.Kind 242912"];
8474 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242913"];
8475 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 242914"];
8476 [label="result.DeclaredAccessibility 242915"];
8477 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 242916"];
8478 [label="Accessibility access = Accessibility.Private; 242917"];
8479 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 242918"];
8480 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 242919"];
8481 [label="Debug.Assert(typeId != SpecialType.None); 242920"];
8482 [label="corType.ContainingAssembly 242921"];
8483 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 242922"];
8484 [label="this.ContainingSymbol 242923"];
8485 [label="get\n            {\n                return _container;\n            } 242924"];
8486 [label="return _container; 242925"];
8487 [label="var container = this.ContainingSymbol; 242926"];
8488 [label="return (object)container != null ? container.ContainingAssembly : null; 242927"];
8489 [label="return (object)container != null ? container.ContainingAssembly : null; 242928"];
8490 [label="(object)container != null 242929"];
8491 [label="container.ContainingAssembly 242930"];
8492 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 242931"];
8493 [label="ContainingPEModule 242932"];
8494 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 242933"];
8495 [label="return ContainingPEModule.ContainingAssembly; 242934"];
8496 [label="ContainingPEModule.ContainingAssembly 242935"];
8497 [label="get\n            {\n                return _assemblySymbol;\n            } 242936"];
8498 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242937"];
8499 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 242938"];
8500 [label="corType.ContainingModule 242939"];
8501 [label="get\n            {\n                return ContainingPEModule;\n            } 242940"];
8502 [label="ContainingPEModule 242941"];
8503 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 242942"];
8504 [label="s.Kind 242943"];
8505 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242944"];
8506 [label="return SymbolKind.Namespace; 242945"];
8507 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242946"];
8508 [label="return ContainingPEModule; 242947"];
8509 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242948"];
8510 [label="corType.ContainingModule.Ordinal 242949"];
8511 [label="get\n            {\n                return _ordinal;\n            } 242950"];
8512 [label="return _ordinal; 242951"];
8513 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 242952"];
8514 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 242953"];
8515 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 242954"];
8516 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 242955"];
8517 [label="Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType)); 242956"];
8518 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 242957"];
8519 [label="iListOfT.IsErrorType() 242958"];
8520 [label="param IsErrorType(this TypeSymbol type) 242959"];
8521 [label="RoslynDebug.Assert((object)type != null); 242960"];
8522 [label="RoslynDebug.Assert((object)type != null); 242961"];
8523 [label="type.Kind 242962"];
8524 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 242963"];
8525 [label="return type.Kind == SymbolKind.ErrorType; 242964"];
8526 [label="if (!iListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 242965"];
8527 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 242966"];
8528 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 242967"];
8529 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 242968"];
8530 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 242969"];
8531 [label="new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations)) 242970"];
8532 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 242971"];
8533 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 242972"];
8534 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 242973"];
8535 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 242974"];
8536 [label="param ConstructedNamedTypeSymbol(this) 242975"];
8537 [label="constructedFrom.ContainingSymbol 242976"];
8538 [label="get\n            {\n                return _container;\n            } 242977"];
8539 [label="return _container; 242978"];
8540 [label="constructedFrom.ContainingType 242979"];
8541 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 242980"];
8542 [label="return _container as NamedTypeSymbol; 242981"];
8543 [label="constructedFrom.OriginalDefinition 242982"];
8544 [label="get\n            {\n                return this;\n            } 242983"];
8545 [label="constructedFrom.OriginalDefinition.TypeParameters 242984"];
8546 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 242985"];
8547 [label="EnsureTypeParametersAreLoaded() 242986"];
8548 [label="param EnsureTypeParametersAreLoaded(this) 242987"];
8549 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 242988"];
8550 [label="ContainingPEModule 242989"];
8551 [label="s.Kind 242990"];
8552 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 242991"];
8553 [label="return SymbolKind.Namespace; 242992"];
8554 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 242993"];
8555 [label="var moduleSymbol = ContainingPEModule; 242994"];
8556 [label="int firstIndex = _genericParameterHandles.Count - _arity; 242995"];
8557 [label="TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity]; 242996"];
8558 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 242997"];
8559 [label="for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    } 242998"];
8560 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 242999"];
8561 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 243000"];
8562 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 243001"];
8563 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 243002"];
8564 [label="ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]); 243003"];
8565 [label="new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]) 243004"];
8566 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 243005"];
8567 [label="param PETypeParameterSymbol(PENamedTypeSymbol definingNamedType) 243006"];
8568 [label="param PETypeParameterSymbol(ushort ordinal) 243007"];
8569 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 243008"];
8570 [label="param PETypeParameterSymbol(this) 243009"];
8571 [label="moduleSymbol 243010"];
8572 [label="definingNamedType 243011"];
8573 [label="ordinal 243012"];
8574 [label="handle 243013"];
8575 [label="param PETypeParameterSymbol(this) 243014"];
8576 [label="param PETypeParameterSymbol(PEModuleSymbol moduleSymbol) 243015"];
8577 [label="param PETypeParameterSymbol(Symbol definingSymbol) 243016"];
8578 [label="param PETypeParameterSymbol(ushort ordinal) 243017"];
8579 [label="param PETypeParameterSymbol(GenericParameterHandle handle) 243018"];
8580 [label="param PETypeParameterSymbol(this) 243019"];
8581 [label="param PETypeParameterSymbol(this) 243020"];
8582 [label="param TypeParameterSymbol(this) 243021"];
8583 [label="param TypeParameterSymbol(this) 243022"];
8584 [label="_lazyAdapter 243023"];
8585 [label="_containingSymbol 243024"];
8586 [label="_name 243025"];
8587 [label="_ordinal 243026"];
8588 [label="_lazyConstraintsUseSiteErrorInfo = CSDiagnosticInfo.EmptyErrorInfo 243027"];
8589 [label="_flags 243028"];
8590 [label="_lazyHasIsUnmanagedConstraint 243029"];
8591 [label="new TypeParameterBounds() 243030"];
8592 [label="param TypeParameterBounds(this) 243031"];
8593 [label="EffectiveBaseClass 243032"];
8594 [label="DeducedBaseType 243033"];
8595 [label="EffectiveBaseClass = null!; 243034"];
8596 [label="EffectiveBaseClass 243035"];
8597 [label="DeducedBaseType = null!; 243036"];
8598 [label="DeducedBaseType 243037"];
8599 [label="Unset = new TypeParameterBounds() 243038"];
8600 [label="_lazyBounds = TypeParameterBounds.Unset 243039"];
8601 [label="Debug.Assert((object)moduleSymbol != null); 243040"];
8602 [label="Debug.Assert((object)moduleSymbol != null); 243041"];
8603 [label="Debug.Assert((object)definingSymbol != null); 243042"];
8604 [label="Debug.Assert((object)definingSymbol != null); 243043"];
8605 [label="Debug.Assert(ordinal >= 0); 243044"];
8606 [label="Debug.Assert(ordinal >= 0); 243045"];
8607 [label="Debug.Assert(!handle.IsNil); 243046"];
8608 [label="_containingSymbol 243047"];
8609 [label="GenericParameterAttributes flags = 0; 243048"];
8610 [label="moduleSymbol.Module 243049"];
8611 [label="get\n            {\n                return _module;\n            } 243050"];
8612 [label="return _module; 243051"];
8613 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 243052"];
8614 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 243053"];
8615 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 243054"];
8616 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 243055"];
8617 [label="moduleSymbol.Module.GetGenericParamPropsOrThrow(handle, out _name, out flags); 243056"];
8618 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 243057"];
8619 [label="_flags = ((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) ? flags : (flags & ~GenericParameterAttributes.DefaultConstructorConstraint); 243058"];
8620 [label="((flags & GenericParameterAttributes.NotNullableValueTypeConstraint) == 0) 243059"];
8621 [label="_flags 243060"];
8622 [label="_ordinal 243061"];
8623 [label="_handle 243062"];
8624 [label="ownedParams[i] 243063"];
8625 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 243064"];
8626 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 243065"];
8627 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams)); 243066"];
8628 [label="EnsureTypeParametersAreLoaded(); 243067"];
8629 [label="return _lazyTypeParameters; 243068"];
8630 [label="t => t.Type 243069"];
8631 [label="AsTypeSymbol = t => t.Type 243070"];
8632 [label="ReferenceEqualityComparer.Instance 243071"];
8633 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 243072"];
8634 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 243073"];
8635 [label="new TypeMap() 243074"];
8636 [label="param TypeMap(this) 243075"];
8637 [label="s_emptyDictionary 243076"];
8638 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 243077"];
8639 [label="param AbstractTypeParameterMap(this) 243078"];
8640 [label="param AbstractTypeMap(this) 243079"];
8641 [label="Mapping 243080"];
8642 [label="this.Mapping 243081"];
8643 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 243082"];
8644 [label="s_emptyTypeMap = new TypeMap() 243083"];
8645 [label="typeArgumentsWithAnnotations 243084"];
8646 [label="new TypeMap(constructedFrom.ContainingType, constructedFrom.OriginalDefinition.TypeParameters, typeArgumentsWithAnnotations) 243085"];
8647 [label="param TypeMap(NamedTypeSymbol containingType) 243086"];
8648 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> typeParameters) 243087"];
8649 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> typeArguments) 243088"];
8650 [label="param TypeMap(this) 243089"];
8651 [label="containingType 243090"];
8652 [label="ForType(containingType) 243091"];
8653 [label="param ForType(NamedTypeSymbol containingType) 243092"];
8654 [label="var substituted = containingType as SubstitutedNamedTypeSymbol; 243093"];
8655 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 243094"];
8656 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 243095"];
8657 [label="(object)substituted != null 243096"];
8658 [label="return (object)substituted != null ?\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(substituted.TypeSubstitution.Mapping, ReferenceEqualityComparer.Instance) :\n                new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 243097"];
8659 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 243098"];
8660 [label="param AbstractTypeParameterMap(this) 243099"];
8661 [label="param AbstractTypeMap(this) 243100"];
8662 [label="Mapping 243101"];
8663 [label="this.Mapping 243102"];
8664 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 243103"];
8665 [label="for (int i = 0; i < typeParameters.Length; i++)\n            {\n                TypeParameterSymbol tp = typeParameters[i];\n                TypeWithAnnotations ta = typeArguments[i];\n                if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                }\n            } 243104"];
8666 [label="TypeParameterSymbol tp = typeParameters[i]; 243105"];
8667 [label="TypeWithAnnotations ta = typeArguments[i]; 243106"];
8668 [label="if (!ta.Is(tp))\n                {\n                    Mapping.Add(tp, ta);\n                } 243107"];
8669 [label="ta.Is(tp) 243108"];
8670 [label="param Is(TypeParameterSymbol other) 243109"];
8671 [label="param Is(this) 243110"];
8672 [label="1 243111"];
8673 [label="NotAnnotatedAttributeValue = 1 243112"];
8674 [label="2 243113"];
8675 [label="AnnotatedAttributeValue = 2 243114"];
8676 [label="0 243115"];
8677 [label="ObliviousAttributeValue = 0 243116"];
8678 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 243117"];
8679 [label="NullableAnnotation.IsOblivious() 243118"];
8680 [label="param IsOblivious(this NullableAnnotation annotation) 243119"];
8681 [label="annotation == NullableAnnotation.Oblivious 243120"];
8682 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 243121"];
8683 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 243122"];
8684 [label="Mapping.Add(tp, ta); 243123"];
8685 [label="Mapping.Add(tp, ta); 243124"];
8686 [label="Mapping.Add(tp, ta); 243125"];
8687 [label="constructedFrom.OriginalDefinition 243126"];
8688 [label="get\n            {\n                return this;\n            } 243127"];
8689 [label="s_symbolAsMemberFunc = SymbolExtensions.SymbolAsMember 243128"];
8690 [label="constructedFrom 243129"];
8691 [label="unbound 243130"];
8692 [label="tupleData 243131"];
8693 [label="param ConstructedNamedTypeSymbol(this) 243132"];
8694 [label="param SubstitutedNamedTypeSymbol(Symbol newContainer) 243133"];
8695 [label="param SubstitutedNamedTypeSymbol(TypeMap map) 243134"];
8696 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol originalDefinition) 243135"];
8697 [label="param SubstitutedNamedTypeSymbol(NamedTypeSymbol constructedFrom = null) 243136"];
8698 [label="param SubstitutedNamedTypeSymbol(bool unbound = false) 243137"];
8699 [label="param SubstitutedNamedTypeSymbol(TupleExtraData tupleData = null) 243138"];
8700 [label="param SubstitutedNamedTypeSymbol(this) 243139"];
8701 [label="originalDefinition 243140"];
8702 [label="tupleData 243141"];
8703 [label="param SubstitutedNamedTypeSymbol(this) 243142"];
8704 [label="param WrappedNamedTypeSymbol(NamedTypeSymbol underlyingType) 243143"];
8705 [label="param WrappedNamedTypeSymbol(TupleExtraData tupleData) 243144"];
8706 [label="param WrappedNamedTypeSymbol(this) 243145"];
8707 [label="tupleData 243146"];
8708 [label="param WrappedNamedTypeSymbol(this) 243147"];
8709 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 243148"];
8710 [label="_lazyTupleData 243149"];
8711 [label="_underlyingType 243150"];
8712 [label="Debug.Assert((object)underlyingType != null); 243151"];
8713 [label="Debug.Assert((object)underlyingType != null); 243152"];
8714 [label="_underlyingType 243153"];
8715 [label="_unbound 243154"];
8716 [label="_inputMap 243155"];
8717 [label="_newContainer 243156"];
8718 [label="_lazyMap 243157"];
8719 [label="_hashCode 243158"];
8720 [label="_lazyMembersByNameCache 243159"];
8721 [label="originalDefinition.IsDefinition 243160"];
8722 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 243161"];
8723 [label="OriginalDefinition 243162"];
8724 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 243163"];
8725 [label="OriginalSymbolDefinition 243164"];
8726 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 243165"];
8727 [label="this.OriginalTypeSymbolDefinition 243166"];
8728 [label="get\n            {\n                return this.OriginalDefinition;\n            } 243167"];
8729 [label="this.OriginalDefinition 243168"];
8730 [label="get\n            {\n                return this;\n            } 243169"];
8731 [label="return this.OriginalDefinition; 243170"];
8732 [label="return this.OriginalTypeSymbolDefinition; 243171"];
8733 [label="return OriginalSymbolDefinition; 243172"];
8734 [label="return (object)this == (object)OriginalDefinition; 243173"];
8735 [label="Debug.Assert(originalDefinition.IsDefinition); 243174"];
8736 [label="Debug.Assert(!originalDefinition.IsErrorType()); 243175"];
8737 [label="originalDefinition.IsErrorType() 243176"];
8738 [label="param IsErrorType(this TypeSymbol type) 243177"];
8739 [label="RoslynDebug.Assert((object)type != null); 243178"];
8740 [label="RoslynDebug.Assert((object)type != null); 243179"];
8741 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 243180"];
8742 [label="Debug.Assert(!originalDefinition.IsErrorType()); 243181"];
8743 [label="_newContainer 243182"];
8744 [label="_inputMap 243183"];
8745 [label="_unbound 243184"];
8746 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 243185"];
8747 [label="if ((object)constructedFrom != null)\n            {\n                Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom));\n                _lazyTypeParameters = constructedFrom.TypeParameters;\n                _lazyMap = map;\n            } 243186"];
8748 [label="constructedFrom.ConstructedFrom 243187"];
8749 [label="get\n            {\n                return this;\n            } 243188"];
8750 [label="return this; 243189"];
8751 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 243190"];
8752 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 243191"];
8753 [label="constructedFrom.TypeParameters 243192"];
8754 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 243193"];
8755 [label="EnsureTypeParametersAreLoaded() 243194"];
8756 [label="param EnsureTypeParametersAreLoaded(this) 243195"];
8757 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 243196"];
8758 [label="EnsureTypeParametersAreLoaded(); 243197"];
8759 [label="return _lazyTypeParameters; 243198"];
8760 [label="_lazyTypeParameters = constructedFrom.TypeParameters; 243199"];
8761 [label="_lazyTypeParameters 243200"];
8762 [label="_lazyMap 243201"];
8763 [label="_constructedFrom 243202"];
8764 [label="_typeArgumentsWithAnnotations 243203"];
8765 [label="_constructedFrom 243204"];
8766 [label="constructedFrom.Arity 243205"];
8767 [label="get\n                {\n                    return _arity;\n                } 243206"];
8768 [label="return _arity; 243207"];
8769 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 243208"];
8770 [label="constructedFrom.Arity 243209"];
8771 [label="get\n                {\n                    return _arity;\n                } 243210"];
8772 [label="return _arity; 243211"];
8773 [label="Debug.Assert(constructedFrom.Arity != 0); 243212"];
8774 [label="Debug.Assert(constructedFrom.Arity != 0); 243213"];
8775 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 243214"];
8776 [label="var iReadOnlyListOfT = declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T); 243215"];
8777 [label="declaringAssembly.GetSpecialType(SpecialType.System_Collections_Generic_IReadOnlyList_T) 243216"];
8778 [label="param GetSpecialType(SpecialType type) 243217"];
8779 [label="param GetSpecialType(this) 243218"];
8780 [label="return _corLibrary; 243219"];
8781 [label="this.Modules 243220"];
8782 [label="get\n            {\n                return _modules;\n            } 243221"];
8783 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 243222"];
8784 [label="module.GetReferencedAssemblies() 243223"];
8785 [label="param GetReferencedAssemblies(this) 243224"];
8786 [label="AssertReferencesInitialized() 243225"];
8787 [label="param AssertReferencesInitialized(this) 243226"];
8788 [label="Debug.Assert(_moduleReferences != null); 243227"];
8789 [label="Debug.Assert(_moduleReferences != null); 243228"];
8790 [label="AssertReferencesInitialized(); 243229"];
8791 [label="return _moduleReferences.Identities; 243230"];
8792 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243231"];
8793 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243232"];
8794 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 243233"];
8795 [label="NamedTypeSymbol result; 243234"];
8796 [label="NamespaceSymbol nextScope = null; 243235"];
8797 [label="EnsureAllMembersLoaded(); 243236"];
8798 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 243237"];
8799 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 243238"];
8800 [label="if ((object)scope == null)\n                {\n                    break;\n                } 243239"];
8801 [label="Debug.Assert(!emittedTypeName.IsNull); 243240"];
8802 [label="scope.Kind 243241"];
8803 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 243242"];
8804 [label="return SymbolKind.Namespace; 243243"];
8805 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 243244"];
8806 [label="NamedTypeSymbol? namedType = null; 243245"];
8807 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 243246"];
8808 [label="namespaceOrTypeMembers 243247"];
8809 [label="scope.IsNamespace 243248"];
8810 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 243249"];
8811 [label="Kind 243250"];
8812 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 243251"];
8813 [label="return SymbolKind.Namespace; 243252"];
8814 [label="return Kind == SymbolKind.Namespace; 243253"];
8815 [label="bool isTopLevel = scope.IsNamespace; 243254"];
8816 [label="param ToDisplayParts(bool minimal) 243255"];
8817 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 243256"];
8818 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 243257"];
8819 [label="Debug.Assert(semanticModelOpt == null); 243258"];
8820 [label="Debug.Assert(positionOpt < 0); 243259"];
8821 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 243260"];
8822 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 243261"];
8823 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 243262"];
8824 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 243263"];
8825 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 243264"];
8826 [label="param ShouldVisitNamespace(this) 243265"];
8827 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 243266"];
8828 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 243267"];
8829 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 243268"];
8830 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 243269"];
8831 [label="=> _underlying.IsGlobalNamespace 243270"];
8832 [label="get\n            {\n                return false;\n            } 243271"];
8833 [label="get\n            {\n                return true;\n            } 243272"];
8834 [label="=> _underlying.IsGlobalNamespace 243273"];
8835 [label="get\n            {\n                return false;\n            } 243274"];
8836 [label="Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0); 243275"];
8837 [label="EnsureAllMembersLoaded(); 243276"];
8838 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 243277"];
8839 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 243278"];
8840 [label="if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                } 243279"];
8841 [label="scope.ContainingModule 243280"];
8842 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 243281"];
8843 [label="_containingNamespaceSymbol.ContainingPEModule 243282"];
8844 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 243283"];
8845 [label="return _containingNamespaceSymbol.ContainingPEModule; 243284"];
8846 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 243285"];
8847 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 243286"];
8848 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 243287"];
8849 [label="new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName) 243288"];
8850 [label="param TopLevel(ModuleSymbol module) 243289"];
8851 [label="param TopLevel(ref MetadataTypeName fullName) 243290"];
8852 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 243291"];
8853 [label="param TopLevel(this) 243292"];
8854 [label="module 243293"];
8855 [label="fullName 243294"];
8856 [label="1 243295"];
8857 [label="errorInfo 243296"];
8858 [label="param TopLevel(this) 243297"];
8859 [label="param TopLevel(ModuleSymbol module) 243298"];
8860 [label="param TopLevel(ref MetadataTypeName fullName) 243299"];
8861 [label="param TopLevel(int typeId) 243300"];
8862 [label="param TopLevel(DiagnosticInfo? errorInfo) 243301"];
8863 [label="param TopLevel(this) 243302"];
8864 [label="module 243303"];
8865 [label="fullName 243304"];
8866 [label="1 243305"];
8867 [label="fullName.ForcedArity == -1 243306"];
8868 [label="fullName.ForcedArity == -1 || fullName.ForcedArity == fullName.InferredArity 243307"];
8869 [label="errorInfo 243308"];
8870 [label="typeId 243309"];
8871 [label="param TopLevel(this) 243310"];
8872 [label="param TopLevel(ModuleSymbol module) 243311"];
8873 [label="param TopLevel(ref MetadataTypeName fullName) 243312"];
8874 [label="param TopLevel(bool mangleName) 243313"];
8875 [label="param TopLevel(DiagnosticInfo? errorInfo) 243314"];
8876 [label="param TopLevel(int typeId) 243315"];
8877 [label="param TopLevel(this) 243316"];
8878 [label="module 243317"];
8879 [label="fullName.NamespaceName 243318"];
8880 [label="mangleName 243319"];
8881 [label="fullName.UnmangledTypeName 243320"];
8882 [label="mangleName 243321"];
8883 [label="fullName.InferredArity 243322"];
8884 [label="mangleName 243323"];
8885 [label="false 243324"];
8886 [label="errorInfo 243325"];
8887 [label="null 243326"];
8888 [label="typeId 243327"];
8889 [label="null 243328"];
8890 [label="param TopLevel(this) 243329"];
8891 [label="param TopLevel(ModuleSymbol module) 243330"];
8892 [label="param TopLevel(string @namespace) 243331"];
8893 [label="param TopLevel(string name) 243332"];
8894 [label="param TopLevel(int arity) 243333"];
8895 [label="param TopLevel(bool mangleName) 243334"];
8896 [label="param TopLevel(bool isNativeInt) 243335"];
8897 [label="param TopLevel(DiagnosticInfo? errorInfo) 243336"];
8898 [label="param TopLevel(NamespaceSymbol? containingNamespace) 243337"];
8899 [label="param TopLevel(int typeId) 243338"];
8900 [label="param TopLevel(TupleExtraData? tupleData) 243339"];
8901 [label="param TopLevel(this) 243340"];
8902 [label="name 243341"];
8903 [label="arity 243342"];
8904 [label="mangleName 243343"];
8905 [label="tupleData 243344"];
8906 [label="param TopLevel(this) 243345"];
8907 [label="param MissingMetadataTypeSymbol(string name) 243346"];
8908 [label="param MissingMetadataTypeSymbol(int arity) 243347"];
8909 [label="param MissingMetadataTypeSymbol(bool mangleName) 243348"];
8910 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 243349"];
8911 [label="param MissingMetadataTypeSymbol(this) 243350"];
8912 [label="tupleData 243351"];
8913 [label="param MissingMetadataTypeSymbol(this) 243352"];
8914 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 243353"];
8915 [label="_lazyTupleData 243354"];
8916 [label="_lazyTupleData 243355"];
8917 [label="name 243356"];
8918 [label="arity 243357"];
8919 [label="mangleName 243358"];
8920 [label="RoslynDebug.Assert(name != null); 243359"];
8921 [label="RoslynDebug.Assert(name != null); 243360"];
8922 [label="this.name 243361"];
8923 [label="this.arity 243362"];
8924 [label="this.mangleName = (mangleName && arity > 0); 243363"];
8925 [label="this.mangleName = (mangleName && arity > 0); 243364"];
8926 [label="this.mangleName = (mangleName && arity > 0); 243365"];
8927 [label="this.mangleName 243366"];
8928 [label="_namespaceName 243367"];
8929 [label="_containingModule 243368"];
8930 [label="_isNativeInt 243369"];
8931 [label="_lazyErrorInfo 243370"];
8932 [label="_lazyContainingNamespace 243371"];
8933 [label="_lazyTypeId 243372"];
8934 [label="RoslynDebug.Assert((object)module != null); 243373"];
8935 [label="RoslynDebug.Assert((object)module != null); 243374"];
8936 [label="RoslynDebug.Assert(@namespace != null); 243375"];
8937 [label="RoslynDebug.Assert(@namespace != null); 243376"];
8938 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 243377"];
8939 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 243378"];
8940 [label="_namespaceName 243379"];
8941 [label="_containingModule 243380"];
8942 [label="_isNativeInt 243381"];
8943 [label="_lazyErrorInfo 243382"];
8944 [label="_lazyContainingNamespace 243383"];
8945 [label="_lazyTypeId 243384"];
8946 [label="Debug.Assert((object)result != null); 243385"];
8947 [label="Debug.Assert((object)result != null); 243386"];
8948 [label="result.Kind 243387"];
8949 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 243388"];
8950 [label="return SymbolKind.ErrorType; 243389"];
8951 [label="if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                } 243390"];
8952 [label="get\n                {\n                    int typeId = TypeId;\n                    return (typeId >= (int)WellKnownType.First) ? SpecialType.None : (SpecialType)_lazyTypeId;\n                } 243391"];
8953 [label="TypeId 243392"];
8954 [label="get\n                {\n                    if (_lazyTypeId == -1)\n                    {\n                        SpecialType typeId = SpecialType.None;\n\n                        AssemblySymbol containingAssembly = _containingModule.ContainingAssembly;\n\n                        if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        }\n\n                        Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1);\n                    }\n\n                    return _lazyTypeId;\n                } 243393"];
8955 [label="if (_lazyTypeId == -1)\n                    {\n                        SpecialType typeId = SpecialType.None;\n\n                        AssemblySymbol containingAssembly = _containingModule.ContainingAssembly;\n\n                        if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        }\n\n                        Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1);\n                    } 243394"];
8956 [label="if (_lazyTypeId == -1)\n                    {\n                        SpecialType typeId = SpecialType.None;\n\n                        AssemblySymbol containingAssembly = _containingModule.ContainingAssembly;\n\n                        if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        }\n\n                        Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1);\n                    } 243395"];
8957 [label="SpecialType typeId = SpecialType.None; 243396"];
8958 [label="_containingModule.ContainingAssembly 243397"];
8959 [label="get\n            {\n                return _assemblySymbol;\n            } 243398"];
8960 [label="AssemblySymbol containingAssembly = _containingModule.ContainingAssembly; 243399"];
8961 [label="Arity 243400"];
8962 [label="get { return arity; } 243401"];
8963 [label="return arity; 243402"];
8964 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243403"];
8965 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243404"];
8966 [label="MangleName 243405"];
8967 [label="get\n            {\n                return mangleName;\n            } 243406"];
8968 [label="return mangleName; 243407"];
8969 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243408"];
8970 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243409"];
8971 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243410"];
8972 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243411"];
8973 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243412"];
8974 [label="containingAssembly.CorLibrary 243413"];
8975 [label="get\n            {\n                return _corLibrary;\n            } 243414"];
8976 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243415"];
8977 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243416"];
8978 [label="_containingModule.Ordinal 243417"];
8979 [label="get\n            {\n                return _ordinal;\n            } 243418"];
8980 [label="return _ordinal; 243419"];
8981 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243420"];
8982 [label="if ((Arity == 0 || MangleName) && (object)containingAssembly != null && ReferenceEquals(containingAssembly, containingAssembly.CorLibrary) && _containingModule.Ordinal == 0)\n                        {\n                            // Check the name \n                            string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName);\n                            typeId = SpecialTypes.GetTypeFromMetadataName(emittedName);\n                        } 243421"];
8983 [label="string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName); 243422"];
8984 [label="MetadataName 243423"];
8985 [label="get\n            {\n                return MangleName ? MetadataHelpers.ComposeAritySuffixedMetadataName(Name, Arity) : Name;\n            } 243424"];
8986 [label="MangleName 243425"];
8987 [label="get\n            {\n                return mangleName;\n            } 243426"];
8988 [label="return MangleName ? MetadataHelpers.ComposeAritySuffixedMetadataName(Name, Arity) : Name; 243427"];
8989 [label="Name 243428"];
8990 [label="get { return name; } 243429"];
8991 [label="return name; 243430"];
8992 [label="Arity 243431"];
8993 [label="return MangleName ? MetadataHelpers.ComposeAritySuffixedMetadataName(Name, Arity) : Name; 243432"];
8994 [label="string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName); 243433"];
8995 [label="string emittedName = MetadataHelpers.BuildQualifiedName(_namespaceName, MetadataName); 243434"];
8996 [label="typeId = SpecialTypes.GetTypeFromMetadataName(emittedName); 243435"];
8997 [label="Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1); 243436"];
8998 [label="Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1); 243437"];
8999 [label="Interlocked.CompareExchange(ref _lazyTypeId, (int)typeId, -1); 243438"];
9000 [label="return _lazyTypeId; 243439"];
9001 [label="int typeId = TypeId; 243440"];
9002 [label="return (typeId >= (int)WellKnownType.First) ? SpecialType.None : (SpecialType)_lazyTypeId; 243441"];
9003 [label="(typeId >= (int)WellKnownType.First) 243442"];
9004 [label="_lazyTypeId 243443"];
9005 [label="Debug.Assert(typeId != SpecialType.None); 243444"];
9006 [label="corType.ContainingAssembly 243445"];
9007 [label="get\n                {\n                    return _containingModule.ContainingAssembly;\n                } 243446"];
9008 [label="_containingModule.ContainingAssembly 243447"];
9009 [label="get\n            {\n                return _assemblySymbol;\n            } 243448"];
9010 [label="return _containingModule.ContainingAssembly; 243449"];
9011 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 243450"];
9012 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 243451"];
9013 [label="corType.ContainingModule 243452"];
9014 [label="get\n                {\n                    return _containingModule;\n                } 243453"];
9015 [label="return _containingModule; 243454"];
9016 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 243455"];
9017 [label="corType.ContainingModule.Ordinal 243456"];
9018 [label="get\n            {\n                return _ordinal;\n            } 243457"];
9019 [label="return _ordinal; 243458"];
9020 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 243459"];
9021 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 243460"];
9022 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 243461"];
9023 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 243462"];
9024 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 243463"];
9025 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 243464"];
9026 [label="iReadOnlyListOfT.IsErrorType() 243465"];
9027 [label="param IsErrorType(this TypeSymbol type) 243466"];
9028 [label="RoslynDebug.Assert((object)type != null); 243467"];
9029 [label="RoslynDebug.Assert((object)type != null); 243468"];
9030 [label="type.Kind 243469"];
9031 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 243470"];
9032 [label="return SymbolKind.ErrorType; 243471"];
9033 [label="return type.Kind == SymbolKind.ErrorType; 243472"];
9034 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 243473"];
9035 [label="return constructedInterfaces.ToImmutableAndFree(); 243474"];
9036 [label="CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)) 243475"];
9037 [label="param CreateSZArray(TypeWithAnnotations elementTypeWithAnnotations) 243476"];
9038 [label="param CreateSZArray(NamedTypeSymbol array) 243477"];
9039 [label="param CreateSZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 243478"];
9040 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243479"];
9041 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243480"];
9042 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243481"];
9043 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243482"];
9044 [label="new SZArray(elementTypeWithAnnotations, array, constructedInterfaces) 243483"];
9045 [label="param SZArray(TypeWithAnnotations elementTypeWithAnnotations) 243484"];
9046 [label="param SZArray(NamedTypeSymbol array) 243485"];
9047 [label="param SZArray(ImmutableArray<NamedTypeSymbol> constructedInterfaces) 243486"];
9048 [label="param SZArray(this) 243487"];
9049 [label="elementTypeWithAnnotations 243488"];
9050 [label="array 243489"];
9051 [label="param SZArray(this) 243490"];
9052 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 243491"];
9053 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 243492"];
9054 [label="param ArrayTypeSymbol(this) 243493"];
9055 [label="param ArrayTypeSymbol(this) 243494"];
9056 [label="_lazyAdapter 243495"];
9057 [label="_baseType 243496"];
9058 [label="elementTypeWithAnnotations.HasType 243497"];
9059 [label="=> !(DefaultType is null) 243498"];
9060 [label="DefaultType is null 243499"];
9061 [label="!(DefaultType is null) 243500"];
9062 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 243501"];
9063 [label="RoslynDebug.Assert((object)array != null); 243502"];
9064 [label="RoslynDebug.Assert((object)array != null); 243503"];
9065 [label="_elementTypeWithAnnotations 243504"];
9066 [label="_baseType 243505"];
9067 [label="Debug.Assert(constructedInterfaces.Length <= 2); 243506"];
9068 [label="Debug.Assert(constructedInterfaces.Length <= 2); 243507"];
9069 [label="_interfaces 243508"];
9070 [label="return CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)); 243509"];
9071 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 243510"];
9072 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 243511"];
9073 [label="AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken) 243512"];
9074 [label="param AreNullableAnnotationsEnabled(SyntaxToken token) 243513"];
9075 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 243514"];
9076 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 243515"];
9077 [label="TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array) 243516"];
9078 [label="param Create(bool isNullableEnabled) 243517"];
9079 [label="param Create(TypeSymbol typeSymbol) 243518"];
9080 [label="param Create(bool isAnnotated = false) 243519"];
9081 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 243520"];
9082 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 243521"];
9083 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 243522"];
9084 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 243523"];
9085 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 243524"];
9086 [label="typeSymbol.IsNullableType() 243525"];
9087 [label="param IsNullableType(this TypeSymbol type) 243526"];
9088 [label="type.OriginalDefinition 243527"];
9089 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 243528"];
9090 [label="OriginalTypeSymbolDefinition 243529"];
9091 [label="get\n            {\n                return this;\n            } 243530"];
9092 [label="return this; 243531"];
9093 [label="return OriginalTypeSymbolDefinition; 243532"];
9094 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243533"];
9095 [label="type.OriginalDefinition.SpecialType 243534"];
9096 [label="get\n            {\n                return SpecialType.None;\n            } 243535"];
9097 [label="return SpecialType.None; 243536"];
9098 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243537"];
9099 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 243538"];
9100 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 243539"];
9101 [label="var a1 = defaultType is null; 243540"];
9102 [label="!a1 243541"];
9103 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243542"];
9104 [label="defaultType.IsNullableType() 243543"];
9105 [label="param IsNullableType(this TypeSymbol type) 243544"];
9106 [label="type.OriginalDefinition 243545"];
9107 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 243546"];
9108 [label="OriginalTypeSymbolDefinition 243547"];
9109 [label="get\n            {\n                return this;\n            } 243548"];
9110 [label="return this; 243549"];
9111 [label="return OriginalTypeSymbolDefinition; 243550"];
9112 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243551"];
9113 [label="type.OriginalDefinition.SpecialType 243552"];
9114 [label="get\n            {\n                return SpecialType.None;\n            } 243553"];
9115 [label="return SpecialType.None; 243554"];
9116 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243555"];
9117 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243556"];
9118 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 243557"];
9119 [label="Debug.Assert(a1 || a2 != true || a3); 243558"];
9120 [label="Debug.Assert(a1 || a2 != true || a3); 243559"];
9121 [label="Debug.Assert(extensions != null); 243560"];
9122 [label="type = TypeWithAnnotations.Create(AreNullableAnnotationsEnabled(rankSpecifier.CloseBracketToken), array); 243561"];
9123 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 243562"];
9124 [label="GetBoundReferenceManager(); 243563"];
9125 [label="var array = ArrayTypeSymbol.CreateCSharpArray(this.Compilation.Assembly, type, rankSpecifier.Rank); 243564"];
9126 [label="param CreateCSharpArray(TypeWithAnnotations elementTypeWithAnnotations) 243565"];
9127 [label="return CreateSZArray(declaringAssembly, elementTypeWithAnnotations); 243566"];
9128 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 243567"];
9129 [label="this.Modules 243568"];
9130 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 243569"];
9131 [label="module.GetReferencedAssemblies() 243570"];
9132 [label="param GetReferencedAssemblies(this) 243571"];
9133 [label="AssertReferencesInitialized() 243572"];
9134 [label="param AssertReferencesInitialized(this) 243573"];
9135 [label="Debug.Assert(_moduleReferences != null); 243574"];
9136 [label="Debug.Assert(_moduleReferences != null); 243575"];
9137 [label="AssertReferencesInitialized(); 243576"];
9138 [label="return _moduleReferences.Identities; 243577"];
9139 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243578"];
9140 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243579"];
9141 [label="param IsErrorType(this TypeSymbol type) 243580"];
9142 [label="RoslynDebug.Assert((object)type != null); 243581"];
9143 [label="RoslynDebug.Assert((object)type != null); 243582"];
9144 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 243583"];
9145 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 243584"];
9146 [label="constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iListOfT, ImmutableArray.Create(elementTypeWithAnnotations))); 243585"];
9147 [label="EnsureTypeParametersAreLoaded(); 243586"];
9148 [label="param AbstractTypeMap(this) 243587"];
9149 [label="Mapping 243588"];
9150 [label="_lazyTupleData 243589"];
9151 [label="_underlyingType 243590"];
9152 [label="Debug.Assert((object)underlyingType != null); 243591"];
9153 [label="_unbound 243592"];
9154 [label="_inputMap 243593"];
9155 [label="_newContainer 243594"];
9156 [label="_lazyMap 243595"];
9157 [label="originalDefinition.IsDefinition 243596"];
9158 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 243597"];
9159 [label="OriginalDefinition 243598"];
9160 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 243599"];
9161 [label="OriginalSymbolDefinition 243600"];
9162 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 243601"];
9163 [label="this.OriginalTypeSymbolDefinition 243602"];
9164 [label="get\n            {\n                return this.OriginalDefinition;\n            } 243603"];
9165 [label="this.OriginalDefinition 243604"];
9166 [label="get\n            {\n                return this;\n            } 243605"];
9167 [label="return this.OriginalDefinition; 243606"];
9168 [label="return this.OriginalTypeSymbolDefinition; 243607"];
9169 [label="return OriginalSymbolDefinition; 243608"];
9170 [label="return (object)this == (object)OriginalDefinition; 243609"];
9171 [label="Debug.Assert(originalDefinition.IsDefinition); 243610"];
9172 [label="Debug.Assert(!originalDefinition.IsErrorType()); 243611"];
9173 [label="originalDefinition.IsErrorType() 243612"];
9174 [label="param IsErrorType(this TypeSymbol type) 243613"];
9175 [label="RoslynDebug.Assert((object)type != null); 243614"];
9176 [label="RoslynDebug.Assert((object)type != null); 243615"];
9177 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 243616"];
9178 [label="Debug.Assert(!originalDefinition.IsErrorType()); 243617"];
9179 [label="constructedFrom.ConstructedFrom 243618"];
9180 [label="get\n            {\n                return this;\n            } 243619"];
9181 [label="return this; 243620"];
9182 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 243621"];
9183 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 243622"];
9184 [label="_constructedFrom 243623"];
9185 [label="constructedFrom.Arity 243624"];
9186 [label="return _arity; 243625"];
9187 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 243626"];
9188 [label="constructedFrom.Arity 243627"];
9189 [label="return _arity; 243628"];
9190 [label="Debug.Assert(constructedFrom.Arity != 0); 243629"];
9191 [label="Debug.Assert(constructedFrom.Arity != 0); 243630"];
9192 [label="get\n            {\n                return _modules;\n            } 243631"];
9193 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 243632"];
9194 [label="module.GetReferencedAssemblies() 243633"];
9195 [label="param GetReferencedAssemblies(this) 243634"];
9196 [label="AssertReferencesInitialized() 243635"];
9197 [label="param AssertReferencesInitialized(this) 243636"];
9198 [label="Debug.Assert(_moduleReferences != null); 243637"];
9199 [label="Debug.Assert(_moduleReferences != null); 243638"];
9200 [label="AssertReferencesInitialized(); 243639"];
9201 [label="return _moduleReferences.Identities; 243640"];
9202 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243641"];
9203 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 243642"];
9204 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 243643"];
9205 [label="iReadOnlyListOfT.IsErrorType() 243644"];
9206 [label="param IsErrorType(this TypeSymbol type) 243645"];
9207 [label="RoslynDebug.Assert((object)type != null); 243646"];
9208 [label="RoslynDebug.Assert((object)type != null); 243647"];
9209 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 243648"];
9210 [label="return SymbolKind.ErrorType; 243649"];
9211 [label="if (!iReadOnlyListOfT.IsErrorType())\n            {\n                constructedInterfaces.Add(new ConstructedNamedTypeSymbol(iReadOnlyListOfT, ImmutableArray.Create(elementTypeWithAnnotations)));\n            } 243650"];
9212 [label="CreateSZArray(elementType, declaringAssembly.GetSpecialType(SpecialType.System_Array), GetSZArrayInterfaces(elementType, declaringAssembly)) 243651"];
9213 [label="param CreateSZArray(TypeWithAnnotations elementTypeWithAnnotations) 243652"];
9214 [label="param CreateSZArray(NamedTypeSymbol array) 243653"];
9215 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243654"];
9216 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243655"];
9217 [label="return new SZArray(elementTypeWithAnnotations, array, constructedInterfaces); 243656"];
9218 [label="new SZArray(elementTypeWithAnnotations, array, constructedInterfaces) 243657"];
9219 [label="param SZArray(TypeWithAnnotations elementTypeWithAnnotations) 243658"];
9220 [label="param SZArray(NamedTypeSymbol array) 243659"];
9221 [label="param SZArray(this) 243660"];
9222 [label="elementTypeWithAnnotations 243661"];
9223 [label="array 243662"];
9224 [label="param SZArray(this) 243663"];
9225 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 243664"];
9226 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 243665"];
9227 [label="param ArrayTypeSymbol(this) 243666"];
9228 [label="param ArrayTypeSymbol(this) 243667"];
9229 [label="_lazyAdapter 243668"];
9230 [label="_baseType 243669"];
9231 [label="elementTypeWithAnnotations.HasType 243670"];
9232 [label="=> !(DefaultType is null) 243671"];
9233 [label="DefaultType is null 243672"];
9234 [label="!(DefaultType is null) 243673"];
9235 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 243674"];
9236 [label="RoslynDebug.Assert((object)array != null); 243675"];
9237 [label="RoslynDebug.Assert((object)array != null); 243676"];
9238 [label="_elementTypeWithAnnotations 243677"];
9239 [label="_baseType 243678"];
9240 [label="Debug.Assert(constructedInterfaces.Length <= 2); 243679"];
9241 [label="Debug.Assert(constructedInterfaces.Length <= 2); 243680"];
9242 [label="param Create(TypeSymbol typeSymbol) 243681"];
9243 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 243682"];
9244 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 243683"];
9245 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 243684"];
9246 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 243685"];
9247 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 243686"];
9248 [label="typeSymbol.IsNullableType() 243687"];
9249 [label="param IsNullableType(this TypeSymbol type) 243688"];
9250 [label="type.OriginalDefinition 243689"];
9251 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 243690"];
9252 [label="OriginalTypeSymbolDefinition 243691"];
9253 [label="get\n            {\n                return this;\n            } 243692"];
9254 [label="return this; 243693"];
9255 [label="return OriginalTypeSymbolDefinition; 243694"];
9256 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243695"];
9257 [label="type.OriginalDefinition.SpecialType 243696"];
9258 [label="get\n            {\n                return SpecialType.None;\n            } 243697"];
9259 [label="return SpecialType.None; 243698"];
9260 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243699"];
9261 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 243700"];
9262 [label="var a1 = defaultType is null; 243701"];
9263 [label="!a1 243702"];
9264 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243703"];
9265 [label="defaultType.IsNullableType() 243704"];
9266 [label="param IsNullableType(this TypeSymbol type) 243705"];
9267 [label="type.OriginalDefinition 243706"];
9268 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 243707"];
9269 [label="OriginalTypeSymbolDefinition 243708"];
9270 [label="get\n            {\n                return this;\n            } 243709"];
9271 [label="return this; 243710"];
9272 [label="return OriginalTypeSymbolDefinition; 243711"];
9273 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243712"];
9274 [label="type.OriginalDefinition.SpecialType 243713"];
9275 [label="get\n            {\n                return SpecialType.None;\n            } 243714"];
9276 [label="return SpecialType.None; 243715"];
9277 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243716"];
9278 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243717"];
9279 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 243718"];
9280 [label="Debug.Assert(a1 || a2 != true || a3); 243719"];
9281 [label="return type; 243720"];
9282 [label="return new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations); 243721"];
9283 [label="new NamespaceOrTypeOrAliasSymbolWithAnnotations(typeWithAnnotations) 243722"];
9284 [label="param NamespaceOrTypeOrAliasSymbolWithAnnotations(this) 243723"];
9285 [label="typeWithAnnotations.HasType 243724"];
9286 [label="=> !(DefaultType is null) 243725"];
9287 [label="DefaultType is null 243726"];
9288 [label="!(DefaultType is null) 243727"];
9289 [label="Debug.Assert(typeWithAnnotations.HasType); 243728"];
9290 [label="_symbol = null; 243729"];
9291 [label="_symbol 243730"];
9292 [label="_isNullableEnabled = false; 243731"];
9293 [label="_isNullableEnabled 243732"];
9294 [label="return BindArrayType((ArrayTypeSyntax)syntax, diagnostics, permitDimensions: false, basesBeingResolved, disallowRestrictedTypes: true); 243733"];
9295 [label="symbol.IsType 243734"];
9296 [label="=> !_typeWithAnnotations.IsDefault 243735"];
9297 [label="_typeWithAnnotations.IsDefault 243736"];
9298 [label="DefaultType is null 243737"];
9299 [label="param ReportDiagnosticsIfObsolete(Binder binder) 243738"];
9300 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 243739"];
9301 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 243740"];
9302 [label="binder 243741"];
9303 [label="syntax 243742"];
9304 [label="diagnostics 243743"];
9305 [label="param ReportDiagnosticsIfObsolete(Binder binder) 243744"];
9306 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 243745"];
9307 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 243746"];
9308 [label="param ReportDiagnosticsIfObsolete(this) 243747"];
9309 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 243748"];
9310 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 243749"];
9311 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 243750"];
9312 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 243751"];
9313 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 243752"];
9314 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 243753"];
9315 [label="=> defaultType 243754"];
9316 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 243755"];
9317 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 243756"];
9318 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 243757"];
9319 [label="param ReportDiagnosticsIfObsolete(this) 243758"];
9320 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 243759"];
9321 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 243760"];
9322 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 243761"];
9323 [label="param ReportDiagnosticsIfObsolete(this) 243762"];
9324 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 243763"];
9325 [label="return SymbolKind.ArrayType; 243764"];
9326 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 243765"];
9327 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 243766"];
9328 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 243767"];
9329 [label="return UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations; 243768"];
9330 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved) 243769"];
9331 [label="param UnwrapAlias(DiagnosticBag diagnostics) 243770"];
9332 [label="param UnwrapAlias(SyntaxNode syntax) 243771"];
9333 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 243772"];
9334 [label="param UnwrapAlias(this) 243773"];
9335 [label="symbol.IsAlias 243774"];
9336 [label="=> _symbol?.Kind == SymbolKind.Alias 243775"];
9337 [label="_symbol 243776"];
9338 [label="_symbol?.Kind == SymbolKind.Alias 243777"];
9339 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 243778"];
9340 [label="UnwrapAlias(symbol, diagnostics, syntax, basesBeingResolved).TypeWithAnnotations 243779"];
9341 [label="IsFixedSizeBuffer 243780"];
9342 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 243781"];
9343 [label="Modifiers 243782"];
9344 [label="get\n            {\n                return _modifiers;\n            } 243783"];
9345 [label="return _modifiers; 243784"];
9346 [label="Modifiers & DeclarationModifiers.Fixed 243785"];
9347 [label="0 243786"];
9348 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 243787"];
9349 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 243788"];
9350 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 243789"];
9351 [label="this.RequiredCustomModifiers 243790"];
9352 [label="get\n            {\n                if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                }\n            } 243791"];
9353 [label="IsVolatile 243792"];
9354 [label="=> (Modifiers & DeclarationModifiers.Volatile) != 0 243793"];
9355 [label="Modifiers 243794"];
9356 [label="get\n            {\n                return _modifiers;\n            } 243795"];
9357 [label="return _modifiers; 243796"];
9358 [label="Modifiers & DeclarationModifiers.Volatile 243797"];
9359 [label="0 243798"];
9360 [label="(Modifiers & DeclarationModifiers.Volatile) != 0 243799"];
9361 [label="if (!IsVolatile)\n                {\n                    return ImmutableArray<CustomModifier>.Empty;\n                }\n                else\n                {\n                    return ImmutableArray.Create<CustomModifier>(\n                            CSharpCustomModifier.CreateRequired(this.ContainingAssembly.GetSpecialType(SpecialType.System_Runtime_CompilerServices_IsVolatile)));\n                } 243800"];
9362 [label="return ImmutableArray<CustomModifier>.Empty; 243801"];
9363 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 243802"];
9364 [label="type.WithModifiers(this.RequiredCustomModifiers) 243803"];
9365 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 243804"];
9366 [label="=>\n            _extensions.WithModifiers(this, customModifiers) 243805"];
9367 [label="this 243806"];
9368 [label="customModifiers 243807"];
9369 [label="_extensions.WithModifiers(this, customModifiers) 243808"];
9370 [label="param WithModifiers(TypeWithAnnotations type) 243809"];
9371 [label="param WithModifiers(ImmutableArray<CustomModifier> customModifiers) 243810"];
9372 [label="param WithModifiers(this) 243811"];
9373 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 243812"];
9374 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 243813"];
9375 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 243814"];
9376 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 243815"];
9377 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 243816"];
9378 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 243817"];
9379 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 243818"];
9380 [label="Extensions.Create(customModifiers) 243819"];
9381 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 243820"];
9382 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 243821"];
9383 [label="param TypeWithAnnotations(this) 243822"];
9384 [label="var a1 = defaultType is null; 243823"];
9385 [label="!a1 243824"];
9386 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243825"];
9387 [label="defaultType.IsNullableType() 243826"];
9388 [label="param IsNullableType(this TypeSymbol type) 243827"];
9389 [label="type.OriginalDefinition 243828"];
9390 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 243829"];
9391 [label="OriginalTypeSymbolDefinition 243830"];
9392 [label="get\n            {\n                return this;\n            } 243831"];
9393 [label="return this; 243832"];
9394 [label="return OriginalTypeSymbolDefinition; 243833"];
9395 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243834"];
9396 [label="type.OriginalDefinition.SpecialType 243835"];
9397 [label="get\n            {\n                return SpecialType.None;\n            } 243836"];
9398 [label="return SpecialType.None; 243837"];
9399 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 243838"];
9400 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 243839"];
9401 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 243840"];
9402 [label="Debug.Assert(a1 || a2 != true || a3); 243841"];
9403 [label="Debug.Assert(a1 || a2 != true || a3); 243842"];
9404 [label="Debug.Assert(extensions != null); 243843"];
9405 [label="Debug.Assert(extensions != null); 243844"];
9406 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 243845"];
9407 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 243846"];
9408 [label="default 243847"];
9409 [label="new Boxed(default) 243848"];
9410 [label="param Boxed(TypeWithAnnotations value) 243849"];
9411 [label="param Boxed(this) 243850"];
9412 [label="Value 243851"];
9413 [label="Sentinel = new Boxed(default) 243852"];
9414 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 243853"];
9415 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 243854"];
9416 [label="param Boxed(TypeWithAnnotations value) 243855"];
9417 [label="param Boxed(this) 243856"];
9418 [label="Value 243857"];
9419 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 243858"];
9420 [label="type.Type 243859"];
9421 [label="=> defaultType 243860"];
9422 [label="TypeChecks(type.Type, diagnostics); 243861"];
9423 [label="TypeChecks(type.Type, diagnostics); 243862"];
9424 [label="TypeChecks(type.Type, diagnostics) 243863"];
9425 [label="param TypeChecks(TypeSymbol type) 243864"];
9426 [label="param TypeChecks(DiagnosticBag diagnostics) 243865"];
9427 [label="param TypeChecks(this) 243866"];
9428 [label="type.IsStatic 243867"];
9429 [label="get\n            {\n                return false;\n            } 243868"];
9430 [label="return false; 243869"];
9431 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243870"];
9432 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243871"];
9433 [label="type.IsVoidType() 243872"];
9434 [label="param IsVoidType(this TypeSymbol type) 243873"];
9435 [label="type.SpecialType 243874"];
9436 [label="get\n            {\n                return SpecialType.None;\n            } 243875"];
9437 [label="return SpecialType.None; 243876"];
9438 [label="return type.SpecialType == SpecialType.System_Void; 243877"];
9439 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243878"];
9440 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243879"];
9441 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243880"];
9442 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 243881"];
9443 [label="param IsRestrictedType(this TypeSymbol type) 243882"];
9444 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 243883"];
9445 [label="RoslynDebug.Assert((object)type != null); 243884"];
9446 [label="RoslynDebug.Assert((object)type != null); 243885"];
9447 [label="type.SpecialType 243886"];
9448 [label="get\n            {\n                return SpecialType.None;\n            } 243887"];
9449 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 243888"];
9450 [label="ignoreSpanLikeTypes 243889"];
9451 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 243890"];
9452 [label="type.IsRefLikeType 243891"];
9453 [label="get\n            {\n                return false;\n            } 243892"];
9454 [label="return false; 243893"];
9455 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243894"];
9456 [label="IsConst 243895"];
9457 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 243896"];
9458 [label="Modifiers 243897"];
9459 [label="get\n            {\n                return _modifiers;\n            } 243898"];
9460 [label="Modifiers & DeclarationModifiers.Const 243899"];
9461 [label="0 243900"];
9462 [label="(Modifiers & DeclarationModifiers.Const) != 0 243901"];
9463 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243902"];
9464 [label="IsVolatile 243903"];
9465 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 243904"];
9466 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 243905"];
9467 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 243906"];
9468 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 243907"];
9469 [label="if (!this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics))\n            {\n                // Inconsistent accessibility: field type '{1}' is less accessible than field '{0}'\n                diagnostics.Add(ErrorCode.ERR_BadVisFieldType, this.ErrorLocation, this, type);\n            } 243908"];
9470 [label="this.IsNoMoreVisibleThan(type, ref useSiteDiagnostics) 243909"];
9471 [label="param IsNoMoreVisibleThan(this Symbol symbol) 243910"];
9472 [label="param IsNoMoreVisibleThan(TypeSymbol type) 243911"];
9473 [label="param IsNoMoreVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 243912"];
9474 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 243913"];
9475 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 243914"];
9476 [label="return type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics); 243915"];
9477 [label="type.IsAtLeastAsVisibleAs(symbol, ref useSiteDiagnostics) 243916"];
9478 [label="param IsAtLeastAsVisibleAs(this TypeSymbol type) 243917"];
9479 [label="param IsAtLeastAsVisibleAs(Symbol sym) 243918"];
9480 [label="param IsAtLeastAsVisibleAs(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 243919"];
9481 [label="HashSet<DiagnosticInfo>? localUseSiteDiagnostics = useSiteDiagnostics; 243920"];
9482 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 243921"];
9483 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 243922"];
9484 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 243923"];
9485 [label="var result = type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true); 243924"];
9486 [label="type.VisitType((type1, symbol, unused) => IsTypeLessVisibleThan(type1, symbol, ref localUseSiteDiagnostics), sym,\n                                        canDigThroughNullable: true) 243925"];
9487 [label="param VisitType(this TypeSymbol type) 243926"];
9488 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 243927"];
9489 [label="param VisitType(T arg) 243928"];
9490 [label="param VisitType(bool canDigThroughNullable = false) 243929"];
9491 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 243930"];
9492 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 243931"];
9493 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 243932"];
9494 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 243933"];
9495 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 243934"];
9496 [label="VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable) 243935"];
9497 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 243936"];
9498 [label="param VisitType(TypeSymbol? type) 243937"];
9499 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 243938"];
9500 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 243939"];
9501 [label="param VisitType(T arg) 243940"];
9502 [label="param VisitType(bool canDigThroughNullable = false) 243941"];
9503 [label="param VisitType(bool useDefaultType = false) 243942"];
9504 [label="typeWithAnnotationsOpt.HasType 243943"];
9505 [label="=> !(DefaultType is null) 243944"];
9506 [label="DefaultType is null 243945"];
9507 [label="!(DefaultType is null) 243946"];
9508 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 243947"];
9509 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 243948"];
9510 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 243949"];
9511 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 243950"];
9512 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 243951"];
9513 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 243952"];
9514 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 243953"];
9515 [label="while (true)\n            {\n                TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type);\n                bool isNestedNamedType = false;\n\n                // Visit containing types from outer-most to inner-most.\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                }\n\n                if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n\n                TypeWithAnnotations next;\n\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                }\n\n                // Let's try to avoid early resolution of nullable types\n                typeWithAnnotationsOpt = canDigThroughNullable ? default : next;\n                type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null;\n            } 243954"];
9516 [label="TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type); 243955"];
9517 [label="bool isNestedNamedType = false; 243956"];
9518 [label="current.TypeKind 243957"];
9519 [label="get\n            {\n                return TypeKind.Array;\n            } 243958"];
9520 [label="return TypeKind.Array; 243959"];
9521 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 243960"];
9522 [label="typeWithAnnotationsOpt.HasType 243961"];
9523 [label="=> !(DefaultType is null) 243962"];
9524 [label="DefaultType is null 243963"];
9525 [label="!(DefaultType is null) 243964"];
9526 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 243965"];
9527 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 243966"];
9528 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 243967"];
9529 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243968"];
9530 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243969"];
9531 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243970"];
9532 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243971"];
9533 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243972"];
9534 [label="param IsTypeLessVisibleThan(TypeSymbol type) 243973"];
9535 [label="param IsTypeLessVisibleThan(Symbol sym) 243974"];
9536 [label="param IsTypeLessVisibleThan(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 243975"];
9537 [label="type.TypeKind 243976"];
9538 [label="get\n            {\n                return TypeKind.Array;\n            } 243977"];
9539 [label="return TypeKind.Array; 243978"];
9540 [label="switch (type.TypeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                case TypeKind.Submission:\n                    return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics);\n\n                default:\n                    return false;\n            } 243979"];
9541 [label="return false; 243980"];
9542 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 243981"];
9543 [label="TypeWithAnnotations next; 243982"];
9544 [label="next 243983"];
9545 [label="current.TypeKind 243984"];
9546 [label="get\n            {\n                return TypeKind.Array;\n            } 243985"];
9547 [label="return TypeKind.Array; 243986"];
9548 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 243987"];
9549 [label="((ArrayTypeSymbol)current).ElementTypeWithAnnotations 243988"];
9550 [label="get\n            {\n                return _elementTypeWithAnnotations;\n            } 243989"];
9551 [label="return _elementTypeWithAnnotations; 243990"];
9552 [label="next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations; 243991"];
9553 [label="canDigThroughNullable 243992"];
9554 [label="typeWithAnnotationsOpt = canDigThroughNullable ? default : next; 243993"];
9555 [label="canDigThroughNullable 243994"];
9556 [label="next.NullableUnderlyingTypeOrSelf 243995"];
9557 [label="=> _extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 243996"];
9558 [label="DefaultType 243997"];
9559 [label="_extensions.GetNullableUnderlyingTypeOrSelf(DefaultType) 243998"];
9560 [label="param GetNullableUnderlyingTypeOrSelf(TypeSymbol typeSymbol) 243999"];
9561 [label="=> typeSymbol.StrippedType() 244000"];
9562 [label="typeSymbol 244001"];
9563 [label="typeSymbol.StrippedType() 244002"];
9564 [label="param StrippedType(this TypeSymbol type) 244003"];
9565 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 244004"];
9566 [label="type.IsNullableType() 244005"];
9567 [label="param IsNullableType(this TypeSymbol type) 244006"];
9568 [label="type.OriginalDefinition 244007"];
9569 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 244008"];
9570 [label="OriginalTypeSymbolDefinition 244009"];
9571 [label="get\n            {\n                return this;\n            } 244010"];
9572 [label="return this; 244011"];
9573 [label="return OriginalTypeSymbolDefinition; 244012"];
9574 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 244013"];
9575 [label="type.OriginalDefinition.SpecialType 244014"];
9576 [label="get\n            {\n                return SpecialType.None;\n            } 244015"];
9577 [label="return SpecialType.None; 244016"];
9578 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 244017"];
9579 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 244018"];
9580 [label="return type.IsNullableType() ? type.GetNullableUnderlyingType() : type; 244019"];
9581 [label="type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null; 244020"];
9582 [label="get\n            {\n                return TypeKind.Array;\n            } 244021"];
9583 [label="=> !(DefaultType is null) 244022"];
9584 [label="DefaultType is null 244023"];
9585 [label="!(DefaultType is null) 244024"];
9586 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 244025"];
9587 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 244026"];
9588 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 244027"];
9589 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 244028"];
9590 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 244029"];
9591 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 244030"];
9592 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 244031"];
9593 [label="param IsTypeLessVisibleThan(TypeSymbol type) 244032"];
9594 [label="param IsTypeLessVisibleThan(Symbol sym) 244033"];
9595 [label="type.TypeKind 244034"];
9596 [label="get\n            {\n                return TypeKind.Array;\n            } 244035"];
9597 [label="return TypeKind.Array; 244036"];
9598 [label="switch (type.TypeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                case TypeKind.Submission:\n                    return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics);\n\n                default:\n                    return false;\n            } 244037"];
9599 [label="return false; 244038"];
9600 [label="get\n            {\n                return TypeKind.Array;\n            } 244039"];
9601 [label="=> typeSymbol.StrippedType() 244040"];
9602 [label="param IsNullableType(this TypeSymbol type) 244041"];
9603 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 244042"];
9604 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244043"];
9605 [label="this.OriginalDefinition 244044"];
9606 [label="get\n            {\n                return this;\n            } 244045"];
9607 [label="return this.OriginalDefinition; 244046"];
9608 [label="return OriginalTypeSymbolDefinition; 244047"];
9609 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 244048"];
9610 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 244049"];
9611 [label="current.ContainingType 244050"];
9612 [label="var containingType = current.ContainingType; 244051"];
9613 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 244052"];
9614 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 244053"];
9615 [label="param IsTypeLessVisibleThan(TypeSymbol type) 244054"];
9616 [label="param IsTypeLessVisibleThan(Symbol sym) 244055"];
9617 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 244056"];
9618 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 244057"];
9619 [label="return !IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics); 244058"];
9620 [label="IsAsRestrictive((NamedTypeSymbol)type, sym, ref useSiteDiagnostics) 244059"];
9621 [label="param IsAsRestrictive(NamedTypeSymbol s1) 244060"];
9622 [label="param IsAsRestrictive(Symbol sym2) 244061"];
9623 [label="param IsAsRestrictive(ref HashSet<DiagnosticInfo>? useSiteDiagnostics) 244062"];
9624 [label="s1.DeclaredAccessibility 244063"];
9625 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 244064"];
9626 [label="Accessibility access = Accessibility.Private; 244065"];
9627 [label="Accessibility acc1 = s1.DeclaredAccessibility; 244066"];
9628 [label="if (acc1 == Accessibility.Public)\n            {\n                return true;\n            } 244067"];
9629 [label="return true; 244068"];
9630 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 244069"];
9631 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244070"];
9632 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 244071"];
9633 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 244072"];
9634 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 244073"];
9635 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 244074"];
9636 [label="return null; 244075"];
9637 [label="useSiteDiagnostics = localUseSiteDiagnostics; 244076"];
9638 [label="return result is null; 244077"];
9639 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 244078"];
9640 [label="this.ErrorLocation 244079"];
9641 [label="get\n            {\n                return _location;\n            } 244080"];
9642 [label="return _location; 244081"];
9643 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 244082"];
9644 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 244083"];
9645 [label="diagnostics.Add(this.ErrorLocation, useSiteDiagnostics); 244084"];
9646 [label="TypeChecks(type.Type, diagnostics); 244085"];
9647 [label="compilation.DeclarationDiagnostics 244086"];
9648 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 244087"];
9649 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 244088"];
9650 [label="return _lazyDeclarationDiagnostics; 244089"];
9651 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 244090"];
9652 [label="compilation.DeclarationDiagnostics.AddRange(diagnostics); 244091"];
9653 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 244092"];
9654 [label="bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator; 244093"];
9655 [label="if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                } 244094"];
9656 [label="compilation.DeclarationDiagnostics 244095"];
9657 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 244096"];
9658 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 244097"];
9659 [label="compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator); 244098"];
9660 [label="state.NotePartComplete(CompletionPart.Type); 244099"];
9661 [label="state.NotePartComplete(CompletionPart.Type) 244100"];
9662 [label="param NotePartComplete(CompletionPart part) 244101"];
9663 [label="param NotePartComplete(this) 244102"];
9664 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 244103"];
9665 [label="diagnostics.Free(); 244104"];
9666 [label="diagnosticsForFirstDeclarator.Free(); 244105"];
9667 [label="return _lazyType.Value; 244106"];
9668 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 244107"];
9669 [label="TypeWithAnnotations.Type 244108"];
9670 [label="=> _extensions?.GetResolvedType(DefaultType) 244109"];
9671 [label=".GetResolvedType(DefaultType) 244110"];
9672 [label="=> defaultType 244111"];
9673 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym1.Kind); 244112"];
9674 [label="sym1.Kind 244113"];
9675 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 244114"];
9676 [label="return SymbolKind.ArrayType; 244115"];
9677 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym1.Kind); 244116"];
9678 [label="CustomAssert.Equal(1, sym1.Interfaces().Length); 244117"];
9679 [label="CustomAssert.Equal(1, sym1.Interfaces().Length); 244118"];
9680 [label="sym1.Interfaces() 244119"];
9681 [label="param Interfaces(this TypeSymbol symbol) 244120"];
9682 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 244121"];
9683 [label="symbol.InterfacesNoUseSiteDiagnostics() 244122"];
9684 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol>? basesBeingResolved = null) 244123"];
9685 [label="param InterfacesNoUseSiteDiagnostics(this) 244124"];
9686 [label="return _interfaces; 244125"];
9687 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 244126"];
9688 [label="CustomAssert.Equal('IList', sym1.Interfaces().First().Name); 244127"];
9689 [label="CustomAssert.Equal('IList', sym1.Interfaces().First().Name); 244128"];
9690 [label="sym1.Interfaces() 244129"];
9691 [label="param Interfaces(this TypeSymbol symbol) 244130"];
9692 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 244131"];
9693 [label="symbol.InterfacesNoUseSiteDiagnostics() 244132"];
9694 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol>? basesBeingResolved = null) 244133"];
9695 [label="param InterfacesNoUseSiteDiagnostics(this) 244134"];
9696 [label="return _interfaces; 244135"];
9697 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 244136"];
9698 [label="sym1.Interfaces().First().Name 244137"];
9699 [label="get\n            {\n                return _underlyingType.Name;\n            } 244138"];
9700 [label="_underlyingType.Name 244139"];
9701 [label="get\n            {\n                return _name;\n            } 244140"];
9702 [label="return _underlyingType.Name; 244141"];
9703 [label="CustomAssert.Equal(9, sym1.AllInterfaces().Length); 244142"];
9704 [label="CustomAssert.Equal(9, sym1.AllInterfaces().Length); 244143"];
9705 [label="sym1.AllInterfaces() 244144"];
9706 [label="param AllInterfaces(this TypeSymbol symbol) 244145"];
9707 [label="symbol.AllInterfacesNoUseSiteDiagnostics 244146"];
9708 [label="get\n            {\n                return GetAllInterfaces();\n            } 244147"];
9709 [label="GetAllInterfaces() 244148"];
9710 [label="param GetAllInterfaces(this) 244149"];
9711 [label="this.GetInterfaceInfo() 244150"];
9712 [label="param GetInterfaceInfo(this) 244151"];
9713 [label="var info = _lazyInterfaceInfo; 244152"];
9714 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 244153"];
9715 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 244154"];
9716 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 244155"];
9717 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 244156"];
9718 [label="baseType.TypeKind 244157"];
9719 [label="get\n            {\n                return TypeKind.Array;\n            } 244158"];
9720 [label="var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); 244159"];
9721 [label="(baseType.TypeKind == TypeKind.TypeParameter) 244160"];
9722 [label="baseType.InterfacesNoUseSiteDiagnostics() 244161"];
9723 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol>? basesBeingResolved = null) 244162"];
9724 [label="param InterfacesNoUseSiteDiagnostics(this) 244163"];
9725 [label="return _interfaces; 244164"];
9726 [label="if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                } 244165"];
9727 [label="info = new InterfaceInfo(); 244166"];
9728 [label="new InterfaceInfo() 244167"];
9729 [label="param InterfaceInfo(this) 244168"];
9730 [label="interfacesAndTheirBaseInterfaces 244169"];
9731 [label="_implementationForInterfaceMemberMap 244170"];
9732 [label="explicitInterfaceImplementationMap 244171"];
9733 [label="return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info; 244172"];
9734 [label="return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info; 244173"];
9735 [label="return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info; 244174"];
9736 [label="return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info; 244175"];
9737 [label="var info = this.GetInterfaceInfo(); 244176"];
9738 [label="if (info == s_noInterfaces)\n            {\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 244177"];
9739 [label="if (info.allInterfaces.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedInitialize(ref info.allInterfaces, MakeAllInterfaces());\n            } 244178"];
9740 [label="ImmutableInterlocked.InterlockedInitialize(ref info.allInterfaces, MakeAllInterfaces()); 244179"];
9741 [label="MakeAllInterfaces() 244180"];
9742 [label="param MakeAllInterfaces(this) 244181"];
9743 [label="var result = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 244182"];
9744 [label="var visited = new HashSet<NamedTypeSymbol>(SymbolEqualityComparer.ConsiderEverything); 244183"];
9745 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                for (int i = interfaces.Length - 1; i >= 0; i--)\n                {\n                    addAllInterfaces(interfaces[i], visited, result);\n                }\n            } 244184"];
9746 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                for (int i = interfaces.Length - 1; i >= 0; i--)\n                {\n                    addAllInterfaces(interfaces[i], visited, result);\n                }\n            } 244185"];
9747 [label="baseType.TypeKind 244186"];
9748 [label="get\n            {\n                return TypeKind.Array;\n            } 244187"];
9749 [label="var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); 244188"];
9750 [label="(baseType.TypeKind == TypeKind.TypeParameter) 244189"];
9751 [label="baseType.InterfacesNoUseSiteDiagnostics() 244190"];
9752 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol>? basesBeingResolved = null) 244191"];
9753 [label="for (int i = interfaces.Length - 1; i >= 0; i--)\n                {\n                    addAllInterfaces(interfaces[i], visited, result);\n                } 244192"];
9754 [label="for (int i = interfaces.Length - 1; i >= 0; i--)\n                {\n                    addAllInterfaces(interfaces[i], visited, result);\n                } 244193"];
9755 [label="addAllInterfaces(interfaces[i], visited, result); 244194"];
9756 [label="addAllInterfaces(interfaces[i], visited, result); 244195"];
9757 [label="addAllInterfaces(interfaces[i], visited, result); 244196"];
9758 [label="addAllInterfaces(interfaces[i], visited, result) 244197"];
9759 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 244198"];
9760 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 244199"];
9761 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 244200"];
9762 [label="if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                } 244201"];
9763 [label="if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                } 244202"];
9764 [label="if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                } 244203"];
9765 [label="param GetHashCode(Symbol obj) 244204"];
9766 [label="param GetHashCode(this) 244205"];
9767 [label="return obj is null ? 0 : obj.GetHashCode(); 244206"];
9768 [label="obj is null 244207"];
9769 [label="obj.GetHashCode() 244208"];
9770 [label="param GetHashCode(this) 244209"];
9771 [label="if (_hashCode == 0)\n            {\n                _hashCode = this.ComputeHashCode();\n            } 244210"];
9772 [label="if (_hashCode == 0)\n            {\n                _hashCode = this.ComputeHashCode();\n            } 244211"];
9773 [label="_hashCode = this.ComputeHashCode(); 244212"];
9774 [label="this.ComputeHashCode() 244213"];
9775 [label="param ComputeHashCode(this NamedTypeSymbol type) 244214"];
9776 [label="type.OriginalDefinition 244215"];
9777 [label="get { return _underlyingType; } 244216"];
9778 [label="return _underlyingType; 244217"];
9779 [label="RoslynDebug.Assert(!type.Equals(type.OriginalDefinition, TypeCompareKind.AllIgnoreOptions) || wasConstructedForAnnotations(type)); 244218"];
9780 [label="RoslynDebug.Assert(!type.Equals(type.OriginalDefinition, TypeCompareKind.AllIgnoreOptions) || wasConstructedForAnnotations(type)); 244219"];
9781 [label="type.Equals(type.OriginalDefinition, TypeCompareKind.AllIgnoreOptions) 244220"];
9782 [label="param Equals(TypeSymbol t2) 244221"];
9783 [label="param Equals(TypeCompareKind comparison) 244222"];
9784 [label="param Equals(this) 244223"];
9785 [label="if ((object)t2 == this) return true; 244224"];
9786 [label="if ((object)t2 == null) return false; 244225"];
9787 [label="if ((object)t2 == null) return false; 244226"];
9788 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 244227"];
9789 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 244228"];
9790 [label="t2.TypeKind 244229"];
9791 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 244230"];
9792 [label="result = TypeKind.Interface; 244231"];
9793 [label="if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                } 244232"];
9794 [label="NamedTypeSymbol other = t2 as NamedTypeSymbol; 244233"];
9795 [label="if ((object)other == null) return false; 244234"];
9796 [label="if ((object)other == null) return false; 244235"];
9797 [label="this.OriginalDefinition 244236"];
9798 [label="get { return _underlyingType; } 244237"];
9799 [label="return _underlyingType; 244238"];
9800 [label="var thisOriginalDefinition = this.OriginalDefinition; 244239"];
9801 [label="other.OriginalDefinition 244240"];
9802 [label="get\n            {\n                return this;\n            } 244241"];
9803 [label="var otherOriginalDefinition = other.OriginalDefinition; 244242"];
9804 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 244243"];
9805 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 244244"];
9806 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 244245"];
9807 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244246"];
9808 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244247"];
9809 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244248"];
9810 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244249"];
9811 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244250"];
9812 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 244251"];
9813 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 244252"];
9814 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 244253"];
9815 [label="Equals(thisOriginalDefinition, otherOriginalDefinition, comparison) 244254"];
9816 [label="param Equals(TypeSymbol left) 244255"];
9817 [label="param Equals(TypeSymbol right) 244256"];
9818 [label="param Equals(TypeCompareKind comparison) 244257"];
9819 [label="if (left is null)\n            {\n                return right is null;\n            } 244258"];
9820 [label="return left.Equals(right, comparison); 244259"];
9821 [label="return left.Equals(right, comparison); 244260"];
9822 [label="left.Equals(right, comparison) 244261"];
9823 [label="param Equals(TypeSymbol t2) 244262"];
9824 [label="param Equals(TypeCompareKind comparison) 244263"];
9825 [label="param Equals(this) 244264"];
9826 [label="if ((object)t2 == this) return true; 244265"];
9827 [label="return true; 244266"];
9828 [label="return EqualsComplicatedCases(other, comparison); 244267"];
9829 [label="return EqualsComplicatedCases(other, comparison); 244268"];
9830 [label="EqualsComplicatedCases(other, comparison) 244269"];
9831 [label="param EqualsComplicatedCases(NamedTypeSymbol other) 244270"];
9832 [label="param EqualsComplicatedCases(TypeCompareKind comparison) 244271"];
9833 [label="param EqualsComplicatedCases(this) 244272"];
9834 [label="this.ContainingType 244273"];
9835 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 244274"];
9836 [label="return _newContainer as NamedTypeSymbol; 244275"];
9837 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 244276"];
9838 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 244277"];
9839 [label="ConstructedFrom 244278"];
9840 [label="get\n            {\n                return _constructedFrom;\n            } 244279"];
9841 [label="return _constructedFrom; 244280"];
9842 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 244281"];
9843 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 244282"];
9844 [label="other.ConstructedFrom 244283"];
9845 [label="get\n            {\n                return this;\n            } 244284"];
9846 [label="return this; 244285"];
9847 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 244286"];
9848 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 244287"];
9849 [label="if (thisIsNotConstructed && otherIsNotConstructed)\n            {\n                // Note that the arguments might appear different here due to alpha-renaming.  For example, given\n                // class A<T> { class B<U> {} }\n                // The type A<int>.B<int> is 'constructed from' A<int>.B<1>, which may be a distinct type object\n                // with a different alpha-renaming of B's type parameter every time that type expression is bound,\n                // but these should be considered the same type each time.\n                return true;\n            } 244288"];
9850 [label="this.IsUnboundGenericType 244289"];
9851 [label="get\n            {\n                return _unbound;\n            } 244290"];
9852 [label="return _unbound; 244291"];
9853 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 244292"];
9854 [label="other.IsUnboundGenericType 244293"];
9855 [label="get\n            {\n                return false;\n            } 244294"];
9856 [label="return false; 244295"];
9857 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 244296"];
9858 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 244297"];
9859 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244298"];
9860 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244299"];
9861 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244300"];
9862 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244301"];
9863 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 244302"];
9864 [label="this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244303"];
9865 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 244304"];
9866 [label="return _typeArgumentsWithAnnotations; 244305"];
9867 [label="var typeArguments = this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 244306"];
9868 [label="other.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244307"];
9869 [label="get\n                {\n                    // This is always the instance type, so the type arguments are the same as the type parameters.\n                    return GetTypeParametersAsTypeArguments();\n                } 244308"];
9870 [label="GetTypeParametersAsTypeArguments() 244309"];
9871 [label="param GetTypeParametersAsTypeArguments(this) 244310"];
9872 [label="this.TypeParameters 244311"];
9873 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244312"];
9874 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 244313"];
9875 [label="EnsureTypeParametersAreLoaded(); 244314"];
9876 [label="return TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters); 244315"];
9877 [label="TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters) 244316"];
9878 [label="param TypeParametersAsTypeSymbolsWithAnnotations(ImmutableArray<TypeParameterSymbol> typeParameters) 244317"];
9879 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 244318"];
9880 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 244319"];
9881 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 244320"];
9882 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 244321"];
9883 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 244322"];
9884 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 244323"];
9885 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244324"];
9886 [label="typeSymbol.IsNullableType() 244325"];
9887 [label="param IsNullableType(this TypeSymbol type) 244326"];
9888 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244327"];
9889 [label="this.OriginalDefinition 244328"];
9890 [label="get\n            {\n                return this;\n            } 244329"];
9891 [label="return this; 244330"];
9892 [label="return this.OriginalDefinition; 244331"];
9893 [label="get\n            {\n                return SpecialType.None;\n            } 244332"];
9894 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244333"];
9895 [label="var a1 = defaultType is null; 244334"];
9896 [label="!a1 244335"];
9897 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244336"];
9898 [label="defaultType.IsNullableType() 244337"];
9899 [label="param IsNullableType(this TypeSymbol type) 244338"];
9900 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244339"];
9901 [label="this.OriginalDefinition 244340"];
9902 [label="get\n            {\n                return this;\n            } 244341"];
9903 [label="return this; 244342"];
9904 [label="return this.OriginalDefinition; 244343"];
9905 [label="get\n            {\n                return SpecialType.None;\n            } 244344"];
9906 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244345"];
9907 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 244346"];
9908 [label="Debug.Assert(a1 || a2 != true || a3); 244347"];
9909 [label="Debug.Assert(a1 || a2 != true || a3); 244348"];
9910 [label="Debug.Assert(extensions != null); 244349"];
9911 [label="Debug.Assert(extensions != null); 244350"];
9912 [label="return GetTypeParametersAsTypeArguments(); 244351"];
9913 [label="var otherTypeArguments = other.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 244352"];
9914 [label="int count = typeArguments.Length; 244353"];
9915 [label="Debug.Assert(count == otherTypeArguments.Length); 244354"];
9916 [label="for (int i = 0; i < count; i++)\n            {\n                var typeArgument = typeArguments[i];\n                var otherTypeArgument = otherTypeArguments[i];\n                if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                }\n            } 244355"];
9917 [label="for (int i = 0; i < count; i++)\n            {\n                var typeArgument = typeArguments[i];\n                var otherTypeArgument = otherTypeArguments[i];\n                if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                }\n            } 244356"];
9918 [label="var typeArgument = typeArguments[i]; 244357"];
9919 [label="var otherTypeArgument = otherTypeArguments[i]; 244358"];
9920 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 244359"];
9921 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 244360"];
9922 [label="typeArgument.Equals(otherTypeArgument, comparison) 244361"];
9923 [label="param Equals(TypeWithAnnotations other) 244362"];
9924 [label="param Equals(TypeCompareKind comparison) 244363"];
9925 [label="param Equals(this) 244364"];
9926 [label="if (this.IsSameAs(other))\n            {\n                return true;\n            } 244365"];
9927 [label="this.IsSameAs(other) 244366"];
9928 [label="param IsSameAs(TypeWithAnnotations other) 244367"];
9929 [label="param IsSameAs(this) 244368"];
9930 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244369"];
9931 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244370"];
9932 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244371"];
9933 [label="HasType 244372"];
9934 [label="=> !(DefaultType is null) 244373"];
9935 [label="if (!HasType)\n            {\n                if (other.HasType)\n                {\n                    return false;\n                }\n            }\n            else if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 244374"];
9936 [label="other.HasType 244375"];
9937 [label="=> !(DefaultType is null) 244376"];
9938 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 244377"];
9939 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 244378"];
9940 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 244379"];
9941 [label="TypeSymbolEquals(other, comparison) 244380"];
9942 [label="param TypeSymbolEquals(TypeWithAnnotations other) 244381"];
9943 [label="param TypeSymbolEquals(TypeCompareKind comparison) 244382"];
9944 [label="=>\n            _extensions.TypeSymbolEquals(this, other, comparison) 244383"];
9945 [label="this 244384"];
9946 [label="other 244385"];
9947 [label="comparison 244386"];
9948 [label="_extensions.TypeSymbolEquals(this, other, comparison) 244387"];
9949 [label="param TypeSymbolEquals(TypeWithAnnotations type) 244388"];
9950 [label="param TypeSymbolEquals(TypeWithAnnotations other) 244389"];
9951 [label="param TypeSymbolEquals(TypeCompareKind comparison) 244390"];
9952 [label="param TypeSymbolEquals(this) 244391"];
9953 [label="return type.TypeSymbolEqualsCore(other, comparison); 244392"];
9954 [label="return type.TypeSymbolEqualsCore(other, comparison); 244393"];
9955 [label="type.TypeSymbolEqualsCore(other, comparison) 244394"];
9956 [label="param TypeSymbolEqualsCore(TypeWithAnnotations other) 244395"];
9957 [label="param TypeSymbolEqualsCore(TypeCompareKind comparison) 244396"];
9958 [label="param TypeSymbolEqualsCore(this) 244397"];
9959 [label="Type 244398"];
9960 [label="=> _extensions?.GetResolvedType(DefaultType) 244399"];
9961 [label="=> defaultType 244400"];
9962 [label="return Type.Equals(other.Type, comparison); 244401"];
9963 [label="other.Type 244402"];
9964 [label="=> _extensions?.GetResolvedType(DefaultType) 244403"];
9965 [label="=> defaultType 244404"];
9966 [label="return Type.Equals(other.Type, comparison); 244405"];
9967 [label="return Type.Equals(other.Type, comparison); 244406"];
9968 [label="Type.Equals(other.Type, comparison) 244407"];
9969 [label="param Equals(TypeSymbol? t2) 244408"];
9970 [label="param Equals(TypeCompareKind comparison) 244409"];
9971 [label="param Equals(this) 244410"];
9972 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 244411"];
9973 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 244412"];
9974 [label="this.Equals(t2 as ArrayTypeSymbol, comparison) 244413"];
9975 [label="param Equals(ArrayTypeSymbol? other) 244414"];
9976 [label="param Equals(TypeCompareKind comparison) 244415"];
9977 [label="param Equals(this) 244416"];
9978 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244417"];
9979 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244418"];
9980 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244419"];
9981 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 244420"];
9982 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 244421"];
9983 [label="return false; 244422"];
9984 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 244423"];
9985 [label="return false; 244424"];
9986 [label="return false; 244425"];
9987 [label="if (wasConstructedForAnnotations(type))\n            {\n                // A type that uses its own type parameters as type arguments was constructed only for the purpose of adding annotations.\n                // In that case we'll use the hash from the definition.\n\n                return type.OriginalDefinition.GetHashCode();\n            } 244426"];
9988 [label="wasConstructedForAnnotations(type) 244427"];
9989 [label="static bool wasConstructedForAnnotations(NamedTypeSymbol type)\n            {\n                do\n                {\n                    var typeArguments = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                    var typeParameters = type.OriginalDefinition.TypeParameters;\n\n                    for (int i = 0; i < typeArguments.Length; i++)\n                    {\n                        if (!typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything))\n                        {\n                            return false;\n                        }\n                    }\n\n                    type = type.ContainingType;\n                }\n                while (type is object && !type.IsDefinition);\n\n                return true;\n            } 244428"];
9990 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244429"];
9991 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 244430"];
9992 [label="return _typeArgumentsWithAnnotations; 244431"];
9993 [label="var typeArguments = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 244432"];
9994 [label="type.OriginalDefinition 244433"];
9995 [label="get { return _underlyingType; } 244434"];
9996 [label="return _underlyingType; 244435"];
9997 [label="var typeParameters = type.OriginalDefinition.TypeParameters; 244436"];
9998 [label="type.OriginalDefinition.TypeParameters 244437"];
9999 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244438"];
10000 [label="EnsureTypeParametersAreLoaded(); 244439"];
10001 [label="for (int i = 0; i < typeArguments.Length; i++)\n                    {\n                        if (!typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything))\n                        {\n                            return false;\n                        }\n                    } 244440"];
10002 [label="for (int i = 0; i < typeArguments.Length; i++)\n                    {\n                        if (!typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything))\n                        {\n                            return false;\n                        }\n                    } 244441"];
10003 [label="if (!typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything))\n                        {\n                            return false;\n                        } 244442"];
10004 [label="typeArguments[i].Type 244443"];
10005 [label="=> _extensions?.GetResolvedType(DefaultType) 244444"];
10006 [label="=> defaultType 244445"];
10007 [label="typeArguments[i].Type.OriginalDefinition 244446"];
10008 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 244447"];
10009 [label="get\n            {\n                return this;\n            } 244448"];
10010 [label="return this; 244449"];
10011 [label="if (!typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything))\n                        {\n                            return false;\n                        } 244450"];
10012 [label="typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything) 244451"];
10013 [label="param Equals(TypeSymbol t2) 244452"];
10014 [label="param Equals(TypeCompareKind comparison) 244453"];
10015 [label="param Equals(this) 244454"];
10016 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 244455"];
10017 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 244456"];
10018 [label="this.Equals(t2 as TypeParameterSymbol, comparison) 244457"];
10019 [label="param Equals(TypeParameterSymbol other) 244458"];
10020 [label="param Equals(TypeCompareKind comparison) 244459"];
10021 [label="param Equals(this) 244460"];
10022 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244461"];
10023 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244462"];
10024 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 244463"];
10025 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 244464"];
10026 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 244465"];
10027 [label="return false; 244466"];
10028 [label="return false; 244467"];
10029 [label="type.OriginalDefinition 244468"];
10030 [label="get { return _underlyingType; } 244469"];
10031 [label="return _underlyingType; 244470"];
10032 [label="int code = type.OriginalDefinition.GetHashCode(); 244471"];
10033 [label="type.OriginalDefinition.GetHashCode() 244472"];
10034 [label="param GetHashCode(this) 244473"];
10035 [label="type.ContainingType 244474"];
10036 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 244475"];
10037 [label="return _newContainer as NamedTypeSymbol; 244476"];
10038 [label="code = Hash.Combine(type.ContainingType, code); 244477"];
10039 [label="code = Hash.Combine(type.ContainingType, code); 244478"];
10040 [label="type.ConstructedFrom 244479"];
10041 [label="get\n            {\n                return _constructedFrom;\n            } 244480"];
10042 [label="return _constructedFrom; 244481"];
10043 [label="if ((object)type.ConstructedFrom != (object)type)\n            {\n                foreach (var arg in type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics)\n                {\n                    code = Hash.Combine(arg.Type, code);\n                }\n            } 244482"];
10044 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244483"];
10045 [label="foreach (var arg in type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics)\n                {\n                    code = Hash.Combine(arg.Type, code);\n                } 244484"];
10046 [label="arg.Type 244485"];
10047 [label="=> defaultType 244486"];
10048 [label="code = Hash.Combine(arg.Type, code); 244487"];
10049 [label="code = Hash.Combine(arg.Type, code); 244488"];
10050 [label="code = Hash.Combine(arg.Type, code); 244489"];
10051 [label="param GetHashCode(this) 244490"];
10052 [label="int hash = 0; 244491"];
10053 [label="TypeSymbol current = this; 244492"];
10054 [label="current.TypeKind 244493"];
10055 [label="get\n            {\n                return TypeKind.Array;\n            } 244494"];
10056 [label="while (current.TypeKind == TypeKind.Array)\n            {\n                var cur = (ArrayTypeSymbol)current;\n                hash = Hash.Combine(cur.Rank, hash);\n                current = cur.ElementType;\n            } 244495"];
10057 [label="var cur = (ArrayTypeSymbol)current; 244496"];
10058 [label="cur.Rank 244497"];
10059 [label="get\n                {\n                    return 1;\n                } 244498"];
10060 [label="return 1; 244499"];
10061 [label="hash = Hash.Combine(cur.Rank, hash); 244500"];
10062 [label="hash = Hash.Combine(cur.Rank, hash); 244501"];
10063 [label="hash = Hash.Combine(cur.Rank, hash); 244502"];
10064 [label="cur.ElementType 244503"];
10065 [label="get\n            {\n                return _elementTypeWithAnnotations.Type;\n            } 244504"];
10066 [label="_elementTypeWithAnnotations.Type 244505"];
10067 [label="=> _extensions?.GetResolvedType(DefaultType) 244506"];
10068 [label="=> defaultType 244507"];
10069 [label="return _elementTypeWithAnnotations.Type; 244508"];
10070 [label="current = cur.ElementType; 244509"];
10071 [label="return Hash.Combine(current, hash); 244510"];
10072 [label="return Hash.Combine(current, hash); 244511"];
10073 [label="return Hash.Combine(current, hash); 244512"];
10074 [label="return Hash.Combine(current, hash); 244513"];
10075 [label="if (code == 0)\n            {\n                code++;\n            } 244514"];
10076 [label="if (code == 0)\n            {\n                code++;\n            } 244515"];
10077 [label="return code; 244516"];
10078 [label="_hashCode 244517"];
10079 [label="return _hashCode; 244518"];
10080 [label="ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics(); 244519"];
10081 [label="@interface.InterfacesNoUseSiteDiagnostics() 244520"];
10082 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 244521"];
10083 [label="param InterfacesNoUseSiteDiagnostics(this) 244522"];
10084 [label="_unbound 244523"];
10085 [label="Map 244524"];
10086 [label="get\n            {\n                EnsureMapAndTypeParameters();\n                return _lazyMap;\n            } 244525"];
10087 [label="EnsureMapAndTypeParameters() 244526"];
10088 [label="param EnsureMapAndTypeParameters(this) 244527"];
10089 [label="if (!_lazyTypeParameters.IsDefault)\n            {\n                return;\n            } 244528"];
10090 [label="return; 244529"];
10091 [label="EnsureMapAndTypeParameters(); 244530"];
10092 [label="return _lazyMap; 244531"];
10093 [label="return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved)); 244532"];
10094 [label="OriginalDefinition 244533"];
10095 [label="return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved)); 244534"];
10096 [label="return _unbound ? ImmutableArray<NamedTypeSymbol>.Empty : Map.SubstituteNamedTypes(OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved)); 244535"];
10097 [label="OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved) 244536"];
10098 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 244537"];
10099 [label="param InterfacesNoUseSiteDiagnostics(this) 244538"];
10100 [label="if (_lazyInterfaces.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>));\n            } 244539"];
10101 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 244540"];
10102 [label="MakeAcyclicInterfaces() 244541"];
10103 [label="param MakeAcyclicInterfaces(this) 244542"];
10104 [label="var declaredInterfaces = GetDeclaredInterfaces(null); 244543"];
10105 [label="GetDeclaredInterfaces(null) 244544"];
10106 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 244545"];
10107 [label="param GetDeclaredInterfaces(this) 244546"];
10108 [label="if (_lazyDeclaredInterfaces.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>));\n            } 244547"];
10109 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 244548"];
10110 [label="MakeDeclaredInterfaces() 244549"];
10111 [label="param MakeDeclaredInterfaces(this) 244550"];
10112 [label="ContainingPEModule 244551"];
10113 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 244552"];
10114 [label="s.Kind 244553"];
10115 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 244554"];
10116 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 244555"];
10117 [label="var moduleSymbol = ContainingPEModule; 244556"];
10118 [label="moduleSymbol.Module 244557"];
10119 [label="get\n            {\n                return _module;\n            } 244558"];
10120 [label="var interfaceImpls = moduleSymbol.Module.GetInterfaceImplementationsOrThrow(_handle); 244559"];
10121 [label="var interfaceImpls = moduleSymbol.Module.GetInterfaceImplementationsOrThrow(_handle); 244560"];
10122 [label="if (interfaceImpls.Count > 0)\n                {\n                    var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(interfaceImpls.Count);\n                    var tokenDecoder = new MetadataDecoder(moduleSymbol, this);\n\n                    foreach (var interfaceImpl in interfaceImpls)\n                    {\n                        EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface;\n                        TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle);\n\n                        typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n\n                        var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); // interface list contains a bad type\n                        symbols.Add(namedTypeSymbol);\n                    }\n\n                    return symbols.ToImmutableAndFree();\n                } 244561"];
10123 [label="if (interfaceImpls.Count > 0)\n                {\n                    var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(interfaceImpls.Count);\n                    var tokenDecoder = new MetadataDecoder(moduleSymbol, this);\n\n                    foreach (var interfaceImpl in interfaceImpls)\n                    {\n                        EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface;\n                        TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle);\n\n                        typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n\n                        var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); // interface list contains a bad type\n                        symbols.Add(namedTypeSymbol);\n                    }\n\n                    return symbols.ToImmutableAndFree();\n                } 244562"];
10124 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(interfaceImpls.Count); 244563"];
10125 [label="var tokenDecoder = new MetadataDecoder(moduleSymbol, this); 244564"];
10126 [label="var tokenDecoder = new MetadataDecoder(moduleSymbol, this); 244565"];
10127 [label="var tokenDecoder = new MetadataDecoder(moduleSymbol, this); 244566"];
10128 [label="new MetadataDecoder(moduleSymbol, this) 244567"];
10129 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 244568"];
10130 [label="param MetadataDecoder(PENamedTypeSymbol context) 244569"];
10131 [label="param MetadataDecoder(this) 244570"];
10132 [label="Debug.Assert((object)moduleSymbol != null); 244571"];
10133 [label="Debug.Assert((object)moduleSymbol != null); 244572"];
10134 [label="foreach (var interfaceImpl in interfaceImpls)\n                    {\n                        EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface;\n                        TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle);\n\n                        typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n\n                        var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); // interface list contains a bad type\n                        symbols.Add(namedTypeSymbol);\n                    } 244573"];
10135 [label="moduleSymbol.Module 244574"];
10136 [label="return _module; 244575"];
10137 [label="EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface; 244576"];
10138 [label="EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface; 244577"];
10139 [label="TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle); 244578"];
10140 [label="TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle); 244579"];
10141 [label="param GetGenericTypeParamSymbol(int position) 244580"];
10142 [label="param GetGenericTypeParamSymbol(this) 244581"];
10143 [label="PENamedTypeSymbol type = _typeContextOpt; 244582"];
10144 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244583"];
10145 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244584"];
10146 [label="type.MetadataArity 244585"];
10147 [label="get\n                {\n                    return _genericParameterHandles.Count;\n                } 244586"];
10148 [label="return _genericParameterHandles.Count; 244587"];
10149 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244588"];
10150 [label="type.Arity 244589"];
10151 [label="get\n                {\n                    return _arity;\n                } 244590"];
10152 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244591"];
10153 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244592"];
10154 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 244593"];
10155 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 244594"];
10156 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 244595"];
10157 [label="type.MetadataArity 244596"];
10158 [label="get\n                {\n                    return _genericParameterHandles.Count;\n                } 244597"];
10159 [label="return _genericParameterHandles.Count; 244598"];
10160 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 244599"];
10161 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 244600"];
10162 [label="type.MetadataArity 244601"];
10163 [label="get\n                {\n                    return _genericParameterHandles.Count;\n                } 244602"];
10164 [label="return _genericParameterHandles.Count; 244603"];
10165 [label="position -= type.MetadataArity - type.Arity; 244604"];
10166 [label="type.Arity 244605"];
10167 [label="get\n                {\n                    return _arity;\n                } 244606"];
10168 [label="position -= type.MetadataArity - type.Arity; 244607"];
10169 [label="position -= type.MetadataArity - type.Arity; 244608"];
10170 [label="position -= type.MetadataArity - type.Arity; 244609"];
10171 [label="Debug.Assert(position >= 0 && position < type.Arity); 244610"];
10172 [label="Debug.Assert(position >= 0 && position < type.Arity); 244611"];
10173 [label="type.Arity 244612"];
10174 [label="get\n                {\n                    return _arity;\n                } 244613"];
10175 [label="Debug.Assert(position >= 0 && position < type.Arity); 244614"];
10176 [label="Debug.Assert(position >= 0 && position < type.Arity); 244615"];
10177 [label="type.TypeParameters 244616"];
10178 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244617"];
10179 [label="EnsureTypeParametersAreLoaded(); 244618"];
10180 [label="return type.TypeParameters[position]; 244619"];
10181 [label="return type.TypeParameters[position]; 244620"];
10182 [label="param SubstituteTypeParameters(PEModuleSymbol moduleSymbol) 244621"];
10183 [label="param SubstituteTypeParameters(TypeSymbol genericTypeDef) 244622"];
10184 [label="param SubstituteTypeParameters(ImmutableArray<KeyValuePair<TypeSymbol, ImmutableArray<ModifierInfo<TypeSymbol>>>> arguments) 244623"];
10185 [label="param SubstituteTypeParameters(ImmutableArray<bool> refersToNoPiaLocalType) 244624"];
10186 [label="param SubstituteTypeParameters(this) 244625"];
10187 [label="if (genericTypeDef is UnsupportedMetadataTypeSymbol)\n            {\n                return genericTypeDef;\n            } 244626"];
10188 [label="foreach (var arg in arguments)\n            {\n                if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                }\n            } 244627"];
10189 [label="foreach (var arg in arguments)\n            {\n                if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                }\n            } 244628"];
10190 [label="arg.Key.Kind 244629"];
10191 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 244630"];
10192 [label="return SymbolKind.TypeParameter; 244631"];
10193 [label="if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                } 244632"];
10194 [label="NamedTypeSymbol genericType = (NamedTypeSymbol)genericTypeDef; 244633"];
10195 [label="moduleSymbol.ContainingAssembly 244634"];
10196 [label="get\n            {\n                return _assemblySymbol;\n            } 244635"];
10197 [label="return _assemblySymbol; 244636"];
10198 [label="ImmutableArray<AssemblySymbol> linkedAssemblies = moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies(); 244637"];
10199 [label="moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies() 244638"];
10200 [label="param GetLinkedReferencedAssemblies(this) 244639"];
10201 [label="return _linkedReferencedAssemblies; 244640"];
10202 [label="bool noPiaIllegalGenericInstantiation = false; 244641"];
10203 [label="moduleSymbol.Module 244642"];
10204 [label="get\n            {\n                return _module;\n            } 244643"];
10205 [label="return _module; 244644"];
10206 [label="if (!linkedAssemblies.IsDefaultOrEmpty || moduleSymbol.Module.ContainsNoPiaLocalTypes())\n            {\n                NamedTypeSymbol typeToCheck = genericType;\n                int argumentIndex = refersToNoPiaLocalType.Length - 1;\n\n                do\n                {\n                    if (!typeToCheck.IsInterface)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        argumentIndex -= typeToCheck.Arity;\n                    }\n\n                    typeToCheck = typeToCheck.ContainingType;\n                }\n                while ((object)typeToCheck != null);\n\n                for (int i = argumentIndex; i >= 0; i--)\n                {\n                    if (refersToNoPiaLocalType[i] ||\n                        (!linkedAssemblies.IsDefaultOrEmpty &&\n                        MetadataDecoder.IsOrClosedOverATypeFromAssemblies(arguments[i].Key, linkedAssemblies)))\n                    {\n                        noPiaIllegalGenericInstantiation = true;\n                        break;\n                    }\n                }\n            } 244645"];
10207 [label="if (!linkedAssemblies.IsDefaultOrEmpty || moduleSymbol.Module.ContainsNoPiaLocalTypes())\n            {\n                NamedTypeSymbol typeToCheck = genericType;\n                int argumentIndex = refersToNoPiaLocalType.Length - 1;\n\n                do\n                {\n                    if (!typeToCheck.IsInterface)\n                    {\n                        break;\n                    }\n                    else\n                    {\n                        argumentIndex -= typeToCheck.Arity;\n                    }\n\n                    typeToCheck = typeToCheck.ContainingType;\n                }\n                while ((object)typeToCheck != null);\n\n                for (int i = argumentIndex; i >= 0; i--)\n                {\n                    if (refersToNoPiaLocalType[i] ||\n                        (!linkedAssemblies.IsDefaultOrEmpty &&\n                        MetadataDecoder.IsOrClosedOverATypeFromAssemblies(arguments[i].Key, linkedAssemblies)))\n                    {\n                        noPiaIllegalGenericInstantiation = true;\n                        break;\n                    }\n                }\n            } 244646"];
10208 [label="ImmutableArray<TypeParameterSymbol> typeParameters = genericType.GetAllTypeParameters(); 244647"];
10209 [label="genericType.GetAllTypeParameters() 244648"];
10210 [label="param GetAllTypeParameters(this NamedTypeSymbol type) 244649"];
10211 [label="type.ContainingType 244650"];
10212 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 244651"];
10213 [label="return _container as NamedTypeSymbol; 244652"];
10214 [label="if ((object)type.ContainingType == null)\n            {\n                return type.TypeParameters;\n            } 244653"];
10215 [label="if ((object)type.ContainingType == null)\n            {\n                return type.TypeParameters;\n            } 244654"];
10216 [label="type.TypeParameters 244655"];
10217 [label="s.Kind 244656"];
10218 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 244657"];
10219 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 244658"];
10220 [label="_containingSymbol 244659"];
10221 [label="_ordinal 244660"];
10222 [label="_flags 244661"];
10223 [label="Debug.Assert((object)moduleSymbol != null); 244662"];
10224 [label="Debug.Assert((object)definingSymbol != null); 244663"];
10225 [label="Debug.Assert(ordinal >= 0); 244664"];
10226 [label="Debug.Assert(!handle.IsNil); 244665"];
10227 [label="EnsureTypeParametersAreLoaded(); 244666"];
10228 [label="return type.TypeParameters; 244667"];
10229 [label="Debug.Assert(typeParameters.Length > 0); 244668"];
10230 [label="Debug.Assert(typeParameters.Length > 0); 244669"];
10231 [label="if (typeParameters.Length != arguments.Length)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 244670"];
10232 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244671"];
10233 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244672"];
10234 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244673"];
10235 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244674"];
10236 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244675"];
10237 [label="param CreateType(TypeSymbol type) 244676"];
10238 [label="param CreateType(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 244677"];
10239 [label="return TypeWithAnnotations.Create(type, NullableAnnotation.Oblivious, CSharpCustomModifier.Convert(customModifiers)); 244678"];
10240 [label="return TypeWithAnnotations.Create(type, NullableAnnotation.Oblivious, CSharpCustomModifier.Convert(customModifiers)); 244679"];
10241 [label="return TypeWithAnnotations.Create(type, NullableAnnotation.Oblivious, CSharpCustomModifier.Convert(customModifiers)); 244680"];
10242 [label="CSharpCustomModifier.Convert(customModifiers) 244681"];
10243 [label="param Convert(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 244682"];
10244 [label="if (customModifiers.IsDefault)\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 244683"];
10245 [label="return ImmutableArray<CustomModifier>.Empty; 244684"];
10246 [label="TypeWithAnnotations.Create(type, NullableAnnotation.Oblivious, CSharpCustomModifier.Convert(customModifiers)) 244685"];
10247 [label="param Create(TypeSymbol typeSymbol) 244686"];
10248 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 244687"];
10249 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 244688"];
10250 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 244689"];
10251 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 244690"];
10252 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 244691"];
10253 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244692"];
10254 [label="typeSymbol.IsNullableType() 244693"];
10255 [label="param IsNullableType(this TypeSymbol type) 244694"];
10256 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244695"];
10257 [label="this.OriginalDefinition 244696"];
10258 [label="get\n            {\n                return this;\n            } 244697"];
10259 [label="return this; 244698"];
10260 [label="return this.OriginalDefinition; 244699"];
10261 [label="get\n            {\n                return SpecialType.None;\n            } 244700"];
10262 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244701"];
10263 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244702"];
10264 [label="var a1 = defaultType is null; 244703"];
10265 [label="!a1 244704"];
10266 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244705"];
10267 [label="defaultType.IsNullableType() 244706"];
10268 [label="param IsNullableType(this TypeSymbol type) 244707"];
10269 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244708"];
10270 [label="this.OriginalDefinition 244709"];
10271 [label="get\n            {\n                return this;\n            } 244710"];
10272 [label="return this; 244711"];
10273 [label="return this.OriginalDefinition; 244712"];
10274 [label="get\n            {\n                return SpecialType.None;\n            } 244713"];
10275 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244714"];
10276 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 244715"];
10277 [label="Debug.Assert(a1 || a2 != true || a3); 244716"];
10278 [label="Debug.Assert(a1 || a2 != true || a3); 244717"];
10279 [label="Debug.Assert(extensions != null); 244718"];
10280 [label="Debug.Assert(extensions != null); 244719"];
10281 [label="return TypeWithAnnotations.Create(type, NullableAnnotation.Oblivious, CSharpCustomModifier.Convert(customModifiers)); 244720"];
10282 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244721"];
10283 [label="param TypeMap(ImmutableArray<TypeParameterSymbol> from) 244722"];
10284 [label="param TypeMap(ImmutableArray<TypeWithAnnotations> to) 244723"];
10285 [label="param TypeMap(bool allowAlpha = false) 244724"];
10286 [label="param TypeMap(this) 244725"];
10287 [label="from 244726"];
10288 [label="to 244727"];
10289 [label="ConstructMapping(from, to) 244728"];
10290 [label="param ConstructMapping(ImmutableArray<TypeParameterSymbol> from) 244729"];
10291 [label="param ConstructMapping(ImmutableArray<TypeWithAnnotations> to) 244730"];
10292 [label="var mapping = new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 244731"];
10293 [label="var mapping = new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance); 244732"];
10294 [label="Debug.Assert(from.Length == to.Length); 244733"];
10295 [label="for (int i = 0; i < from.Length; i++)\n            {\n                TypeParameterSymbol tp = from[i];\n                TypeWithAnnotations ta = to[i];\n                if (!ta.Is(tp))\n                {\n                    mapping.Add(tp, ta);\n                }\n            } 244734"];
10296 [label="for (int i = 0; i < from.Length; i++)\n            {\n                TypeParameterSymbol tp = from[i];\n                TypeWithAnnotations ta = to[i];\n                if (!ta.Is(tp))\n                {\n                    mapping.Add(tp, ta);\n                }\n            } 244735"];
10297 [label="TypeParameterSymbol tp = from[i]; 244736"];
10298 [label="TypeWithAnnotations ta = to[i]; 244737"];
10299 [label="if (!ta.Is(tp))\n                {\n                    mapping.Add(tp, ta);\n                } 244738"];
10300 [label="ta.Is(tp) 244739"];
10301 [label="param Is(TypeParameterSymbol other) 244740"];
10302 [label="param Is(this) 244741"];
10303 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 244742"];
10304 [label="mapping.Add(tp, ta); 244743"];
10305 [label="mapping.Add(tp, ta); 244744"];
10306 [label="return mapping; 244745"];
10307 [label="param TypeMap(this) 244746"];
10308 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 244747"];
10309 [label="param AbstractTypeMap(this) 244748"];
10310 [label="Mapping 244749"];
10311 [label="Debug.Assert(allowAlpha || !from.Any(tp => tp is SubstitutedTypeParameterSymbol)); 244750"];
10312 [label="Debug.Assert(allowAlpha || !from.Any(tp => tp is SubstitutedTypeParameterSymbol)); 244751"];
10313 [label="Debug.Assert(allowAlpha || !from.Any(tp => tp is SubstitutedTypeParameterSymbol)); 244752"];
10314 [label="Debug.Assert(allowAlpha || !from.Any(tp => tp is SubstitutedTypeParameterSymbol)); 244753"];
10315 [label="TypeMap substitution = new TypeMap(typeParameters, arguments.SelectAsArray(arg => CreateType(arg.Key, arg.Value))); 244754"];
10316 [label="NamedTypeSymbol constructedType = substitution.SubstituteNamedType(genericType); 244755"];
10317 [label="substitution.SubstituteNamedType(genericType) 244756"];
10318 [label="param SubstituteNamedType(NamedTypeSymbol previous) 244757"];
10319 [label="param SubstituteNamedType(this) 244758"];
10320 [label="if (ReferenceEquals(previous, null))\n                return null; 244759"];
10321 [label="if (ReferenceEquals(previous, null))\n                return null; 244760"];
10322 [label="previous.IsUnboundGenericType 244761"];
10323 [label="get\n            {\n                return false;\n            } 244762"];
10324 [label="return false; 244763"];
10325 [label="if (previous.IsUnboundGenericType)\n                return previous; 244764"];
10326 [label="previous.IsAnonymousType 244765"];
10327 [label="get\n            {\n                return false;\n            } 244766"];
10328 [label="return false; 244767"];
10329 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 244768"];
10330 [label="previous.ConstructedFrom 244769"];
10331 [label="get\n            {\n                return this;\n            } 244770"];
10332 [label="return this; 244771"];
10333 [label="NamedTypeSymbol oldConstructedFrom = previous.ConstructedFrom; 244772"];
10334 [label="NamedTypeSymbol newConstructedFrom = SubstituteTypeDeclaration(oldConstructedFrom); 244773"];
10335 [label="SubstituteTypeDeclaration(oldConstructedFrom) 244774"];
10336 [label="param SubstituteTypeDeclaration(NamedTypeSymbol previous) 244775"];
10337 [label="param SubstituteTypeDeclaration(this) 244776"];
10338 [label="previous.ConstructedFrom 244777"];
10339 [label="get\n            {\n                return this;\n            } 244778"];
10340 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 244779"];
10341 [label="previous.ContainingType 244780"];
10342 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 244781"];
10343 [label="return _container as NamedTypeSymbol; 244782"];
10344 [label="NamedTypeSymbol newContainingType = SubstituteNamedType(previous.ContainingType); 244783"];
10345 [label="SubstituteNamedType(previous.ContainingType) 244784"];
10346 [label="param SubstituteNamedType(NamedTypeSymbol previous) 244785"];
10347 [label="param SubstituteNamedType(this) 244786"];
10348 [label="if (ReferenceEquals(previous, null))\n                return null; 244787"];
10349 [label="if (ReferenceEquals(previous, null))\n                return null; 244788"];
10350 [label="return null; 244789"];
10351 [label="if ((object)newContainingType == null)\n            {\n                return previous;\n            } 244790"];
10352 [label="if ((object)newContainingType == null)\n            {\n                return previous;\n            } 244791"];
10353 [label="return previous; 244792"];
10354 [label="previous.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 244793"];
10355 [label="get\n                {\n                    // This is always the instance type, so the type arguments are the same as the type parameters.\n                    return GetTypeParametersAsTypeArguments();\n                } 244794"];
10356 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 244795"];
10357 [label="EnsureTypeParametersAreLoaded(); 244796"];
10358 [label="return _lazyTypeParameters; 244797"];
10359 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 244798"];
10360 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 244799"];
10361 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 244800"];
10362 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244801"];
10363 [label="typeSymbol.IsNullableType() 244802"];
10364 [label="param IsNullableType(this TypeSymbol type) 244803"];
10365 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244804"];
10366 [label="this.OriginalDefinition 244805"];
10367 [label="get\n            {\n                return this;\n            } 244806"];
10368 [label="return this; 244807"];
10369 [label="return this.OriginalDefinition; 244808"];
10370 [label="get\n            {\n                return SpecialType.None;\n            } 244809"];
10371 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 244810"];
10372 [label="var a1 = defaultType is null; 244811"];
10373 [label="!a1 244812"];
10374 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244813"];
10375 [label="defaultType.IsNullableType() 244814"];
10376 [label="param IsNullableType(this TypeSymbol type) 244815"];
10377 [label="get\n            {\n                return this.OriginalDefinition;\n            } 244816"];
10378 [label="this.OriginalDefinition 244817"];
10379 [label="get\n            {\n                return this;\n            } 244818"];
10380 [label="return this; 244819"];
10381 [label="return this.OriginalDefinition; 244820"];
10382 [label="get\n            {\n                return SpecialType.None;\n            } 244821"];
10383 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 244822"];
10384 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 244823"];
10385 [label="Debug.Assert(a1 || a2 != true || a3); 244824"];
10386 [label="Debug.Assert(a1 || a2 != true || a3); 244825"];
10387 [label="Debug.Assert(extensions != null); 244826"];
10388 [label="Debug.Assert(extensions != null); 244827"];
10389 [label="ImmutableArray<TypeWithAnnotations> oldTypeArguments = previous.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 244828"];
10390 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 244829"];
10391 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 244830"];
10392 [label="var newTypeArguments = ArrayBuilder<TypeWithAnnotations>.GetInstance(oldTypeArguments.Length); 244831"];
10393 [label="for (int i = 0; i < oldTypeArguments.Length; i++)\n            {\n                var oldArgument = oldTypeArguments[i];\n                var newArgument = oldArgument.SubstituteType(this);\n\n                if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                }\n\n                newTypeArguments.Add(newArgument);\n            } 244832"];
10394 [label="for (int i = 0; i < oldTypeArguments.Length; i++)\n            {\n                var oldArgument = oldTypeArguments[i];\n                var newArgument = oldArgument.SubstituteType(this);\n\n                if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                }\n\n                newTypeArguments.Add(newArgument);\n            } 244833"];
10395 [label="var oldArgument = oldTypeArguments[i]; 244834"];
10396 [label="var newArgument = oldArgument.SubstituteType(this); 244835"];
10397 [label="oldArgument.SubstituteType(this) 244836"];
10398 [label="param SubstituteType(AbstractTypeMap typeMap) 244837"];
10399 [label="=>\n            _extensions.SubstituteType(this, typeMap) 244838"];
10400 [label="this 244839"];
10401 [label="typeMap 244840"];
10402 [label="_extensions.SubstituteType(this, typeMap) 244841"];
10403 [label="param SubstituteType(TypeWithAnnotations type) 244842"];
10404 [label="param SubstituteType(AbstractTypeMap typeMap) 244843"];
10405 [label="param SubstituteType(this) 244844"];
10406 [label="return type.SubstituteTypeCore(typeMap); 244845"];
10407 [label="type.SubstituteTypeCore(typeMap) 244846"];
10408 [label="param SubstituteTypeCore(AbstractTypeMap typeMap) 244847"];
10409 [label="param SubstituteTypeCore(this) 244848"];
10410 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 244849"];
10411 [label="this.CustomModifiers 244850"];
10412 [label="=> _extensions.CustomModifiers 244851"];
10413 [label="_extensions.CustomModifiers 244852"];
10414 [label="=> _customModifiers 244853"];
10415 [label="_customModifiers 244854"];
10416 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 244855"];
10417 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 244856"];
10418 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 244857"];
10419 [label="param SubstituteCustomModifiers(this) 244858"];
10420 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 244859"];
10421 [label="return customModifiers; 244860"];
10422 [label="this.Type 244861"];
10423 [label="=> _extensions?.GetResolvedType(DefaultType) 244862"];
10424 [label="=> defaultType 244863"];
10425 [label="TypeSymbol typeSymbol = this.Type; 244864"];
10426 [label="var newTypeWithModifiers = typeMap.SubstituteType(typeSymbol); 244865"];
10427 [label="typeMap.SubstituteType(typeSymbol) 244866"];
10428 [label="param SubstituteType(TypeSymbol previous) 244867"];
10429 [label="param SubstituteType(this) 244868"];
10430 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 244869"];
10431 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 244870"];
10432 [label="TypeSymbol result; 244871"];
10433 [label="previous.Kind 244872"];
10434 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 244873"];
10435 [label="return SymbolKind.TypeParameter; 244874"];
10436 [label="switch (previous.Kind)\n            {\n                case SymbolKind.NamedType:\n                    result = SubstituteNamedType((NamedTypeSymbol)previous);\n                    break;\n                case SymbolKind.TypeParameter:\n                    return SubstituteTypeParameter((TypeParameterSymbol)previous);\n                case SymbolKind.ArrayType:\n                    result = SubstituteArrayType((ArrayTypeSymbol)previous);\n                    break;\n                case SymbolKind.PointerType:\n                    result = SubstitutePointerType((PointerTypeSymbol)previous);\n                    break;\n                case SymbolKind.FunctionPointerType:\n                    result = SubstituteFunctionPointerType((FunctionPointerTypeSymbol)previous);\n                    break;\n                case SymbolKind.DynamicType:\n                    result = SubstituteDynamicType();\n                    break;\n                case SymbolKind.ErrorType:\n                    return ((ErrorTypeSymbol)previous).Substitute(this);\n                default:\n                    result = previous;\n                    break;\n            } 244875"];
10437 [label="return SubstituteTypeParameter((TypeParameterSymbol)previous); 244876"];
10438 [label="SubstituteTypeParameter((TypeParameterSymbol)previous) 244877"];
10439 [label="param SubstituteTypeParameter(TypeParameterSymbol typeParameter) 244878"];
10440 [label="param SubstituteTypeParameter(this) 244879"];
10441 [label="TypeWithAnnotations result; 244880"];
10442 [label="result 244881"];
10443 [label="if (Mapping.TryGetValue(typeParameter, out result))\n            {\n                return result;\n            } 244882"];
10444 [label="if (Mapping.TryGetValue(typeParameter, out result))\n            {\n                return result;\n            } 244883"];
10445 [label="if (Mapping.TryGetValue(typeParameter, out result))\n            {\n                return result;\n            } 244884"];
10446 [label="return result; 244885"];
10447 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 244886"];
10448 [label="typeSymbol.IsTypeParameter() 244887"];
10449 [label="param IsTypeParameter(this TypeSymbol type) 244888"];
10450 [label="RoslynDebug.Assert((object)type != null); 244889"];
10451 [label="RoslynDebug.Assert((object)type != null); 244890"];
10452 [label="type.TypeKind 244891"];
10453 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 244892"];
10454 [label="return TypeKind.TypeParameter; 244893"];
10455 [label="return type.TypeKind == TypeKind.TypeParameter; 244894"];
10456 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 244895"];
10457 [label="if (newTypeWithModifiers.Is((TypeParameterSymbol)typeSymbol) &&\n                newCustomModifiers == CustomModifiers)\n            {\n                return this; // substitution had no effect on the type or modifiers\n            }\n            else if (Is((TypeParameterSymbol)typeSymbol) && newTypeWithModifiers.NullableAnnotation != NullableAnnotation.Ignored)\n            {\n                return newTypeWithModifiers;\n            } 244896"];
10458 [label="newTypeWithModifiers.Is((TypeParameterSymbol)typeSymbol) 244897"];
10459 [label="param Is(TypeParameterSymbol other) 244898"];
10460 [label="param Is(this) 244899"];
10461 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 244900"];
10462 [label="if (Is((TypeParameterSymbol)typeSymbol) && newTypeWithModifiers.NullableAnnotation != NullableAnnotation.Ignored)\n            {\n                return newTypeWithModifiers;\n            } 244901"];
10463 [label="Is((TypeParameterSymbol)typeSymbol) 244902"];
10464 [label="param Is(TypeParameterSymbol other) 244903"];
10465 [label="CustomModifiers 244904"];
10466 [label="=> _extensions.CustomModifiers 244905"];
10467 [label="_extensions.CustomModifiers 244906"];
10468 [label="=> _customModifiers 244907"];
10469 [label="_customModifiers 244908"];
10470 [label="return NullableAnnotation.IsOblivious() && ((object)DefaultType == other) &&\n                   CustomModifiers.IsEmpty; 244909"];
10471 [label="if (Is((TypeParameterSymbol)typeSymbol) && newTypeWithModifiers.NullableAnnotation != NullableAnnotation.Ignored)\n            {\n                return newTypeWithModifiers;\n            } 244910"];
10472 [label="return newTypeWithModifiers; 244911"];
10473 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 244912"];
10474 [label="oldArgument.IsSameAs(newArgument) 244913"];
10475 [label="param IsSameAs(TypeWithAnnotations other) 244914"];
10476 [label="param IsSameAs(this) 244915"];
10477 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244916"];
10478 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244917"];
10479 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 244918"];
10480 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 244919"];
10481 [label="changed = true; 244920"];
10482 [label="newTypeArguments.Add(newArgument); 244921"];
10483 [label="newTypeArguments.Add(newArgument); 244922"];
10484 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 244923"];
10485 [label="return newConstructedFrom.ConstructIfGeneric(newTypeArguments.ToImmutableAndFree()).WithTupleDataFrom(previous); 244924"];
10486 [label="return newConstructedFrom.ConstructIfGeneric(newTypeArguments.ToImmutableAndFree()).WithTupleDataFrom(previous); 244925"];
10487 [label="newConstructedFrom.ConstructIfGeneric(newTypeArguments.ToImmutableAndFree()) 244926"];
10488 [label="param ConstructIfGeneric(this NamedTypeSymbol type) 244927"];
10489 [label="param ConstructIfGeneric(ImmutableArray<TypeWithAnnotations> typeArguments) 244928"];
10490 [label="type.TypeParameters 244929"];
10491 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244930"];
10492 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 244931"];
10493 [label="EnsureTypeParametersAreLoaded(); 244932"];
10494 [label="return _lazyTypeParameters; 244933"];
10495 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 244934"];
10496 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 244935"];
10497 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 244936"];
10498 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 244937"];
10499 [label="type.TypeParameters 244938"];
10500 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244939"];
10501 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 244940"];
10502 [label="EnsureTypeParametersAreLoaded(); 244941"];
10503 [label="return _lazyTypeParameters; 244942"];
10504 [label="return type.TypeParameters.IsEmpty ? type : type.Construct(typeArguments, unbound: false); 244943"];
10505 [label="type.TypeParameters.IsEmpty 244944"];
10506 [label="return type.TypeParameters.IsEmpty ? type : type.Construct(typeArguments, unbound: false); 244945"];
10507 [label="type.Construct(typeArguments, unbound: false) 244946"];
10508 [label="param Construct(ImmutableArray<TypeWithAnnotations> typeArguments) 244947"];
10509 [label="param Construct(bool unbound) 244948"];
10510 [label="param Construct(this) 244949"];
10511 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 244950"];
10512 [label="ConstructedFrom 244951"];
10513 [label="get\n            {\n                return this;\n            } 244952"];
10514 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 244953"];
10515 [label="this.Arity 244954"];
10516 [label="get\n                {\n                    return _arity;\n                } 244955"];
10517 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 244956"];
10518 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 244957"];
10519 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 244958"];
10520 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 244959"];
10521 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 244960"];
10522 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 244961"];
10523 [label="if (typeArguments.Any(TypeWithAnnotationsIsNullFunction))\n            {\n                throw new ArgumentException(CSharpResources.TypeArgumentCannotBeNull, nameof(typeArguments));\n            } 244962"];
10524 [label="this.Arity 244963"];
10525 [label="get\n                {\n                    return _arity;\n                } 244964"];
10526 [label="return _arity; 244965"];
10527 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 244966"];
10528 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 244967"];
10529 [label="this.TypeParameters 244968"];
10530 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 244969"];
10531 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 244970"];
10532 [label="EnsureTypeParametersAreLoaded(); 244971"];
10533 [label="return _lazyTypeParameters; 244972"];
10534 [label="if (ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments))\n            {\n                return this;\n            } 244973"];
10535 [label="if (ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments))\n            {\n                return this;\n            } 244974"];
10536 [label="ConstructedNamedTypeSymbol.TypeParametersMatchTypeArguments(this.TypeParameters, typeArguments) 244975"];
10537 [label="param TypeParametersMatchTypeArguments(ImmutableArray<TypeParameterSymbol> typeParameters) 244976"];
10538 [label="param TypeParametersMatchTypeArguments(ImmutableArray<TypeWithAnnotations> typeArguments) 244977"];
10539 [label="int n = typeParameters.Length; 244978"];
10540 [label="Debug.Assert(typeArguments.Length == n); 244979"];
10541 [label="Debug.Assert(typeArguments.Length > 0); 244980"];
10542 [label="Debug.Assert(typeArguments.Length > 0); 244981"];
10543 [label="for (int i = 0; i < n; i++)\n            {\n                if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                }\n            } 244982"];
10544 [label="for (int i = 0; i < n; i++)\n            {\n                if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                }\n            } 244983"];
10545 [label="if (!typeArguments[i].Is(typeParameters[i]))\n                {\n                    return false;\n                } 244984"];
10546 [label="typeArguments[i].Is(typeParameters[i]) 244985"];
10547 [label="param Is(TypeParameterSymbol other) 244986"];
10548 [label="param Is(this) 244987"];
10549 [label="return false; 244988"];
10550 [label="return this.ConstructCore(typeArguments, unbound); 244989"];
10551 [label="return this.ConstructCore(typeArguments, unbound); 244990"];
10552 [label="this.ConstructCore(typeArguments, unbound) 244991"];
10553 [label="param ConstructCore(ImmutableArray<TypeWithAnnotations> typeArguments) 244992"];
10554 [label="param ConstructCore(bool unbound) 244993"];
10555 [label="param ConstructCore(this) 244994"];
10556 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 244995"];
10557 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 244996"];
10558 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 244997"];
10559 [label="return new ConstructedNamedTypeSymbol(this, typeArguments, unbound); 244998"];
10560 [label="new ConstructedNamedTypeSymbol(this, typeArguments, unbound) 244999"];
10561 [label="param ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom) 245000"];
10562 [label="param ConstructedNamedTypeSymbol(ImmutableArray<TypeWithAnnotations> typeArgumentsWithAnnotations) 245001"];
10563 [label="param ConstructedNamedTypeSymbol(bool unbound = false) 245002"];
10564 [label="param ConstructedNamedTypeSymbol(TupleExtraData tupleData = null) 245003"];
10565 [label="param ConstructedNamedTypeSymbol(this) 245004"];
10566 [label="return _container; 245005"];
10567 [label="return _container as NamedTypeSymbol; 245006"];
10568 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 245007"];
10569 [label="EnsureTypeParametersAreLoaded(); 245008"];
10570 [label="return _lazyTypeParameters; 245009"];
10571 [label="param AbstractTypeMap(this) 245010"];
10572 [label="Mapping 245011"];
10573 [label="TypeWithAnnotations ta = typeArguments[i]; 245012"];
10574 [label="_lazyTupleData 245013"];
10575 [label="_underlyingType 245014"];
10576 [label="Debug.Assert((object)underlyingType != null); 245015"];
10577 [label="Debug.Assert((object)underlyingType != null); 245016"];
10578 [label="_unbound 245017"];
10579 [label="_inputMap 245018"];
10580 [label="_newContainer 245019"];
10581 [label="_lazyMap 245020"];
10582 [label="originalDefinition.IsDefinition 245021"];
10583 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245022"];
10584 [label="OriginalDefinition 245023"];
10585 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245024"];
10586 [label="OriginalSymbolDefinition 245025"];
10587 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245026"];
10588 [label="this.OriginalTypeSymbolDefinition 245027"];
10589 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245028"];
10590 [label="return this.OriginalTypeSymbolDefinition; 245029"];
10591 [label="return OriginalSymbolDefinition; 245030"];
10592 [label="return (object)this == (object)OriginalDefinition; 245031"];
10593 [label="Debug.Assert(originalDefinition.IsDefinition); 245032"];
10594 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245033"];
10595 [label="originalDefinition.IsErrorType() 245034"];
10596 [label="param IsErrorType(this TypeSymbol type) 245035"];
10597 [label="RoslynDebug.Assert((object)type != null); 245036"];
10598 [label="RoslynDebug.Assert((object)type != null); 245037"];
10599 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245038"];
10600 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245039"];
10601 [label="constructedFrom.ConstructedFrom 245040"];
10602 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245041"];
10603 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245042"];
10604 [label="EnsureTypeParametersAreLoaded(); 245043"];
10605 [label="_constructedFrom 245044"];
10606 [label="constructedFrom.Arity 245045"];
10607 [label="get\n                {\n                    return _arity;\n                } 245046"];
10608 [label="return _arity; 245047"];
10609 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 245048"];
10610 [label="constructedFrom.Arity 245049"];
10611 [label="get\n                {\n                    return _arity;\n                } 245050"];
10612 [label="return _arity; 245051"];
10613 [label="Debug.Assert(constructedFrom.Arity != 0); 245052"];
10614 [label="Debug.Assert(constructedFrom.Arity != 0); 245053"];
10615 [label="return this.ConstructCore(typeArguments, unbound); 245054"];
10616 [label="return newConstructedFrom.ConstructIfGeneric(newTypeArguments.ToImmutableAndFree()).WithTupleDataFrom(previous); 245055"];
10617 [label="newConstructedFrom.ConstructIfGeneric(newTypeArguments.ToImmutableAndFree()).WithTupleDataFrom(previous) 245056"];
10618 [label="param WithTupleDataFrom(NamedTypeSymbol original) 245057"];
10619 [label="param WithTupleDataFrom(this) 245058"];
10620 [label="IsTupleType 245059"];
10621 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245060"];
10622 [label="_ 245061"];
10623 [label="tupleCardinality: out _ 245062"];
10624 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245063"];
10625 [label="param IsTupleTypeOfCardinality(this) 245064"];
10626 [label="IsUnboundGenericType 245065"];
10627 [label="get\n            {\n                return _unbound;\n            } 245066"];
10628 [label="return _unbound; 245067"];
10629 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245068"];
10630 [label="ContainingSymbol 245069"];
10631 [label="get { return _newContainer; } 245070"];
10632 [label="return _newContainer; 245071"];
10633 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245072"];
10634 [label=".Kind 245073"];
10635 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245074"];
10636 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245075"];
10637 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245076"];
10638 [label="ContainingNamespace 245077"];
10639 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245078"];
10640 [label="get { return _newContainer; } 245079"];
10641 [label="return _newContainer; 245080"];
10642 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245081"];
10643 [label="ContainingNamespace.ContainingNamespace 245082"];
10644 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245083"];
10645 [label="return _containingNamespaceSymbol; 245084"];
10646 [label=".IsGlobalNamespace 245085"];
10647 [label="get\n            {\n                return false;\n            } 245086"];
10648 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245087"];
10649 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245088"];
10650 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245089"];
10651 [label="tupleCardinality = 0; 245090"];
10652 [label="if (!IsTupleType || (original._lazyTupleData == null && this._lazyTupleData == null) || TupleData!.EqualsIgnoringTupleUnderlyingType(original.TupleData))\n            {\n                return this;\n            } 245091"];
10653 [label="return this; 245092"];
10654 [label="if (noPiaIllegalGenericInstantiation)\n            {\n                constructedType = new NoPiaIllegalGenericInstantiationSymbol(moduleSymbol, constructedType);\n            } 245093"];
10655 [label="return constructedType; 245094"];
10656 [label="TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle); 245095"];
10657 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol); 245096"];
10658 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol); 245097"];
10659 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol); 245098"];
10660 [label="NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol) 245099"];
10661 [label="param TransformType(TypeSymbol type) 245100"];
10662 [label="param TransformType(EntityHandle handle) 245101"];
10663 [label="param TransformType(PEModuleSymbol containingModule) 245102"];
10664 [label="return _module; 245103"];
10665 [label="typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol); 245104"];
10666 [label="typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol); 245105"];
10667 [label="typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol); 245106"];
10668 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol) 245107"];
10669 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 245108"];
10670 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 245109"];
10671 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 245110"];
10672 [label="return _module; 245111"];
10673 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 245112"];
10674 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 245113"];
10675 [label="_elementNames 245114"];
10676 [label="elementNames.IsDefault 245115"];
10677 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 245116"];
10678 [label="_namesIndex 245117"];
10679 [label="_foundUsableErrorType = false; 245118"];
10680 [label="_foundUsableErrorType 245119"];
10681 [label="param DecodeType(this) 245120"];
10682 [label="get { return OriginalDefinition.Kind; } 245121"];
10683 [label="OriginalDefinition 245122"];
10684 [label="get { return _underlyingType; } 245123"];
10685 [label="return OriginalDefinition.Kind; 245124"];
10686 [label="OriginalDefinition.Kind 245125"];
10687 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245126"];
10688 [label="return OriginalDefinition.Kind; 245127"];
10689 [label="return DecodeNamedType((NamedTypeSymbol)type); 245128"];
10690 [label="param DecodeNamedType(this) 245129"];
10691 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 245130"];
10692 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 245131"];
10693 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 245132"];
10694 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 245133"];
10695 [label="DecodeTypeArguments(typeArgs) 245134"];
10696 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 245135"];
10697 [label="param DecodeTypeArguments(this) 245136"];
10698 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 245137"];
10699 [label="var decodedArgs = ArrayBuilder<TypeWithAnnotations>.GetInstance(typeArgs.Length); 245138"];
10700 [label="var anyDecoded = false; 245139"];
10701 [label="for (int i = typeArgs.Length - 1; i >= 0; i--)\n            {\n                TypeWithAnnotations typeArg = typeArgs[i];\n                TypeWithAnnotations decoded = DecodeTypeInternal(typeArg);\n                anyDecoded |= !decoded.IsSameAs(typeArg);\n                decodedArgs.Add(decoded);\n            } 245140"];
10702 [label="for (int i = typeArgs.Length - 1; i >= 0; i--)\n            {\n                TypeWithAnnotations typeArg = typeArgs[i];\n                TypeWithAnnotations decoded = DecodeTypeInternal(typeArg);\n                anyDecoded |= !decoded.IsSameAs(typeArg);\n                decodedArgs.Add(decoded);\n            } 245141"];
10703 [label="TypeWithAnnotations typeArg = typeArgs[i]; 245142"];
10704 [label="TypeWithAnnotations decoded = DecodeTypeInternal(typeArg); 245143"];
10705 [label="DecodeTypeInternal(typeArg) 245144"];
10706 [label="param DecodeTypeInternal(TypeWithAnnotations typeWithAnnotations) 245145"];
10707 [label="param DecodeTypeInternal(this) 245146"];
10708 [label="typeWithAnnotations.Type 245147"];
10709 [label="=> _extensions?.GetResolvedType(DefaultType) 245148"];
10710 [label="=> defaultType 245149"];
10711 [label="TypeSymbol type = typeWithAnnotations.Type; 245150"];
10712 [label="TypeSymbol decoded = DecodeType(type); 245151"];
10713 [label="DecodeType(type) 245152"];
10714 [label="param DecodeType(TypeSymbol type) 245153"];
10715 [label="param DecodeType(this) 245154"];
10716 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245155"];
10717 [label="return type; 245156"];
10718 [label="return ReferenceEquals(decoded, type) ?\n                typeWithAnnotations :\n                TypeWithAnnotations.Create(decoded, typeWithAnnotations.NullableAnnotation, typeWithAnnotations.CustomModifiers); 245157"];
10719 [label="return ReferenceEquals(decoded, type) ?\n                typeWithAnnotations :\n                TypeWithAnnotations.Create(decoded, typeWithAnnotations.NullableAnnotation, typeWithAnnotations.CustomModifiers); 245158"];
10720 [label="ReferenceEquals(decoded, type) 245159"];
10721 [label="anyDecoded |= !decoded.IsSameAs(typeArg); 245160"];
10722 [label="decoded.IsSameAs(typeArg) 245161"];
10723 [label="param IsSameAs(TypeWithAnnotations other) 245162"];
10724 [label="param IsSameAs(this) 245163"];
10725 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 245164"];
10726 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 245165"];
10727 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 245166"];
10728 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 245167"];
10729 [label="anyDecoded |= !decoded.IsSameAs(typeArg); 245168"];
10730 [label="decodedArgs.Add(decoded); 245169"];
10731 [label="decodedArgs.Add(decoded); 245170"];
10732 [label="if (!anyDecoded)\n            {\n                decodedArgs.Free();\n                return typeArgs;\n            } 245171"];
10733 [label="decodedArgs.Free(); 245172"];
10734 [label="return typeArgs; 245173"];
10735 [label="type.ContainingType 245174"];
10736 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 245175"];
10737 [label="return _newContainer as NamedTypeSymbol; 245176"];
10738 [label="NamedTypeSymbol containingType = type.ContainingType; 245177"];
10739 [label="NamedTypeSymbol? decodedContainingType; 245178"];
10740 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 245179"];
10741 [label="decodedContainingType = containingType; 245180"];
10742 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245181"];
10743 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245182"];
10744 [label="var typeArgsChanged = typeArgs != decodedArgs; 245183"];
10745 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 245184"];
10746 [label="decodedType.IsTupleType 245185"];
10747 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245186"];
10748 [label="_ 245187"];
10749 [label="tupleCardinality: out _ 245188"];
10750 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245189"];
10751 [label="param IsTupleTypeOfCardinality(this) 245190"];
10752 [label="IsUnboundGenericType 245191"];
10753 [label="get\n            {\n                return _unbound;\n            } 245192"];
10754 [label="return _unbound; 245193"];
10755 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245194"];
10756 [label="ContainingSymbol 245195"];
10757 [label="get { return _newContainer; } 245196"];
10758 [label="return _newContainer; 245197"];
10759 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245198"];
10760 [label=".Kind 245199"];
10761 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245200"];
10762 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245201"];
10763 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245202"];
10764 [label="ContainingNamespace 245203"];
10765 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245204"];
10766 [label="get { return _newContainer; } 245205"];
10767 [label="return _newContainer; 245206"];
10768 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245207"];
10769 [label="ContainingNamespace.ContainingNamespace 245208"];
10770 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245209"];
10771 [label=".IsGlobalNamespace 245210"];
10772 [label="get\n            {\n                return false;\n            } 245211"];
10773 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245212"];
10774 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245213"];
10775 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245214"];
10776 [label="tupleCardinality = 0; 245215"];
10777 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 245216"];
10778 [label="typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 245217"];
10779 [label="typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 245218"];
10780 [label="TypeWithAnnotations.Create(typeSymbol) 245219"];
10781 [label="param Create(TypeSymbol typeSymbol) 245220"];
10782 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 245221"];
10783 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 245222"];
10784 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 245223"];
10785 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 245224"];
10786 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 245225"];
10787 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245226"];
10788 [label="typeSymbol.IsNullableType() 245227"];
10789 [label="param IsNullableType(this TypeSymbol type) 245228"];
10790 [label="return _underlyingType; 245229"];
10791 [label="var a1 = defaultType is null; 245230"];
10792 [label="!a1 245231"];
10793 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245232"];
10794 [label="defaultType.IsNullableType() 245233"];
10795 [label="param IsNullableType(this TypeSymbol type) 245234"];
10796 [label="return _underlyingType; 245235"];
10797 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 245236"];
10798 [label="Debug.Assert(a1 || a2 != true || a3); 245237"];
10799 [label="Debug.Assert(a1 || a2 != true || a3); 245238"];
10800 [label="Debug.Assert(extensions != null); 245239"];
10801 [label="Debug.Assert(extensions != null); 245240"];
10802 [label="typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 245241"];
10803 [label="typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 245242"];
10804 [label="typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 245243"];
10805 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this) 245244"];
10806 [label="param TransformType(TypeWithAnnotations metadataType) 245245"];
10807 [label="param TransformType(EntityHandle targetSymbolToken) 245246"];
10808 [label="param TransformType(PEModuleSymbol containingModule) 245247"];
10809 [label="param TransformType(Symbol accessSymbol) 245248"];
10810 [label="param TransformType(Symbol nullableContext) 245249"];
10811 [label="metadataType.HasType 245250"];
10812 [label="=> !(DefaultType is null) 245251"];
10813 [label="DefaultType is null 245252"];
10814 [label="Debug.Assert(metadataType.HasType); 245253"];
10815 [label="accessSymbol.IsDefinition 245254"];
10816 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245255"];
10817 [label="OriginalDefinition 245256"];
10818 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245257"];
10819 [label="OriginalSymbolDefinition 245258"];
10820 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245259"];
10821 [label="this.OriginalTypeSymbolDefinition 245260"];
10822 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245261"];
10823 [label="return this.OriginalTypeSymbolDefinition; 245262"];
10824 [label="return OriginalSymbolDefinition; 245263"];
10825 [label="return (object)this == (object)OriginalDefinition; 245264"];
10826 [label="Debug.Assert(accessSymbol.IsDefinition); 245265"];
10827 [label="accessSymbol.ContainingModule 245266"];
10828 [label="get\n            {\n                return ContainingPEModule;\n            } 245267"];
10829 [label="ContainingPEModule 245268"];
10830 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 245269"];
10831 [label="Symbol s = _container; 245270"];
10832 [label="s.Kind 245271"];
10833 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245272"];
10834 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245273"];
10835 [label="return ContainingPEModule; 245274"];
10836 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 245275"];
10837 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245276"];
10838 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245277"];
10839 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 245278"];
10840 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 245279"];
10841 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 245280"];
10842 [label="Debug.Assert(symbol is object); 245281"];
10843 [label="symbol.Kind 245282"];
10844 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245283"];
10845 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 245284"];
10846 [label="isInternal = false; 245285"];
10847 [label="symbol.DeclaredAccessibility 245286"];
10848 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 245287"];
10849 [label="Accessibility access = Accessibility.Private; 245288"];
10850 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 245289"];
10851 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 245290"];
10852 [label="symbol.ContainingType 245291"];
10853 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 245292"];
10854 [label="return _container as NamedTypeSymbol; 245293"];
10855 [label="symbol = symbol.ContainingType; 245294"];
10856 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 245295"];
10857 [label="return true; 245296"];
10858 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245297"];
10859 [label="return _module; 245298"];
10860 [label="param TryGetByte(out byte? value) 245299"];
10861 [label="value = null; 245300"];
10862 [label="s.Kind 245301"];
10863 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245302"];
10864 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245303"];
10865 [label="param GetNullableContextValue(this) 245304"];
10866 [label="param GetLocalNullableContextValue(this) 245305"];
10867 [label="get\n            {\n                return _moduleSymbol;\n            } 245306"];
10868 [label="return _moduleSymbol; 245307"];
10869 [label="param GetLocalNullableContextValue(this) 245308"];
10870 [label="get\n            {\n                return _assemblySymbol;\n            } 245309"];
10871 [label="return _assemblySymbol; 245310"];
10872 [label="param GetLocalNullableContextValue(this) 245311"];
10873 [label="get\n            {\n                return null;\n            } 245312"];
10874 [label="return metadataType; 245313"];
10875 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type 245314"];
10876 [label="=> _extensions?.GetResolvedType(DefaultType) 245315"];
10877 [label="=> defaultType 245316"];
10878 [label="var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); 245317"];
10879 [label="symbols.Add(namedTypeSymbol); 245318"];
10880 [label="symbols.Add(namedTypeSymbol); 245319"];
10881 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 245320"];
10882 [label="type.MetadataArity 245321"];
10883 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 245322"];
10884 [label="type.Arity 245323"];
10885 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 245324"];
10886 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 245325"];
10887 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 245326"];
10888 [label="type.MetadataArity 245327"];
10889 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 245328"];
10890 [label="position -= type.MetadataArity - type.Arity; 245329"];
10891 [label="Debug.Assert(position >= 0 && position < type.Arity); 245330"];
10892 [label="Debug.Assert(position >= 0 && position < type.Arity); 245331"];
10893 [label="type.Arity 245332"];
10894 [label="Debug.Assert(position >= 0 && position < type.Arity); 245333"];
10895 [label="Debug.Assert(position >= 0 && position < type.Arity); 245334"];
10896 [label="EnsureTypeParametersAreLoaded(); 245335"];
10897 [label="param SubstituteTypeParameters(ImmutableArray<bool> refersToNoPiaLocalType) 245336"];
10898 [label="param SubstituteTypeParameters(this) 245337"];
10899 [label="if (genericTypeDef is UnsupportedMetadataTypeSymbol)\n            {\n                return genericTypeDef;\n            } 245338"];
10900 [label="foreach (var arg in arguments)\n            {\n                if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                }\n            } 245339"];
10901 [label="foreach (var arg in arguments)\n            {\n                if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                }\n            } 245340"];
10902 [label="arg.Key.Kind 245341"];
10903 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245342"];
10904 [label="if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                } 245343"];
10905 [label="moduleSymbol.ContainingAssembly 245344"];
10906 [label="return _assemblySymbol; 245345"];
10907 [label="ImmutableArray<AssemblySymbol> linkedAssemblies = moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies(); 245346"];
10908 [label="moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies() 245347"];
10909 [label="param GetLinkedReferencedAssemblies(this) 245348"];
10910 [label="return _linkedReferencedAssemblies; 245349"];
10911 [label="bool noPiaIllegalGenericInstantiation = false; 245350"];
10912 [label="s.Kind 245351"];
10913 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245352"];
10914 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245353"];
10915 [label="_containingSymbol 245354"];
10916 [label="_ordinal 245355"];
10917 [label="_flags 245356"];
10918 [label="Debug.Assert((object)moduleSymbol != null); 245357"];
10919 [label="Debug.Assert((object)definingSymbol != null); 245358"];
10920 [label="Debug.Assert(ordinal >= 0); 245359"];
10921 [label="Debug.Assert(!handle.IsNil); 245360"];
10922 [label="EnsureTypeParametersAreLoaded(); 245361"];
10923 [label="Debug.Assert(typeParameters.Length > 0); 245362"];
10924 [label="Debug.Assert(typeParameters.Length > 0); 245363"];
10925 [label="if (typeParameters.Length != arguments.Length)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 245364"];
10926 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 245365"];
10927 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 245366"];
10928 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 245367"];
10929 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245368"];
10930 [label="typeSymbol.IsNullableType() 245369"];
10931 [label="param IsNullableType(this TypeSymbol type) 245370"];
10932 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245371"];
10933 [label="this.OriginalDefinition 245372"];
10934 [label="get\n            {\n                return this;\n            } 245373"];
10935 [label="return this; 245374"];
10936 [label="return this.OriginalDefinition; 245375"];
10937 [label="get\n            {\n                return SpecialType.None;\n            } 245376"];
10938 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245377"];
10939 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245378"];
10940 [label="var a1 = defaultType is null; 245379"];
10941 [label="!a1 245380"];
10942 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245381"];
10943 [label="defaultType.IsNullableType() 245382"];
10944 [label="param IsNullableType(this TypeSymbol type) 245383"];
10945 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245384"];
10946 [label="this.OriginalDefinition 245385"];
10947 [label="get\n            {\n                return this;\n            } 245386"];
10948 [label="return this; 245387"];
10949 [label="return this.OriginalDefinition; 245388"];
10950 [label="get\n            {\n                return SpecialType.None;\n            } 245389"];
10951 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245390"];
10952 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 245391"];
10953 [label="Debug.Assert(a1 || a2 != true || a3); 245392"];
10954 [label="Debug.Assert(a1 || a2 != true || a3); 245393"];
10955 [label="Debug.Assert(extensions != null); 245394"];
10956 [label="Debug.Assert(extensions != null); 245395"];
10957 [label="param TypeMap(bool allowAlpha = false) 245396"];
10958 [label="Debug.Assert(from.Length == to.Length); 245397"];
10959 [label="param AbstractTypeMap(this) 245398"];
10960 [label="Mapping 245399"];
10961 [label="previous.IsUnboundGenericType 245400"];
10962 [label="get\n            {\n                return false;\n            } 245401"];
10963 [label="return false; 245402"];
10964 [label="if (previous.IsUnboundGenericType)\n                return previous; 245403"];
10965 [label="previous.IsAnonymousType 245404"];
10966 [label="get\n            {\n                return false;\n            } 245405"];
10967 [label="return false; 245406"];
10968 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 245407"];
10969 [label="param SubstituteTypeDeclaration(this) 245408"];
10970 [label="previous.ConstructedFrom 245409"];
10971 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 245410"];
10972 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 245411"];
10973 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 245412"];
10974 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245413"];
10975 [label="typeSymbol.IsNullableType() 245414"];
10976 [label="param IsNullableType(this TypeSymbol type) 245415"];
10977 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245416"];
10978 [label="this.OriginalDefinition 245417"];
10979 [label="get\n            {\n                return this;\n            } 245418"];
10980 [label="return this; 245419"];
10981 [label="return this.OriginalDefinition; 245420"];
10982 [label="get\n            {\n                return SpecialType.None;\n            } 245421"];
10983 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245422"];
10984 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 245423"];
10985 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 245424"];
10986 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 245425"];
10987 [label="param SubstituteType(this) 245426"];
10988 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 245427"];
10989 [label="this.CustomModifiers 245428"];
10990 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 245429"];
10991 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 245430"];
10992 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 245431"];
10993 [label="param SubstituteCustomModifiers(this) 245432"];
10994 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 245433"];
10995 [label="return customModifiers; 245434"];
10996 [label="=> defaultType 245435"];
10997 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 245436"];
10998 [label="TypeSymbol result; 245437"];
10999 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245438"];
11000 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 245439"];
11001 [label="typeSymbol.IsTypeParameter() 245440"];
11002 [label="param IsTypeParameter(this TypeSymbol type) 245441"];
11003 [label="RoslynDebug.Assert((object)type != null); 245442"];
11004 [label="RoslynDebug.Assert((object)type != null); 245443"];
11005 [label="type.TypeKind 245444"];
11006 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 245445"];
11007 [label="return TypeKind.TypeParameter; 245446"];
11008 [label="return type.TypeKind == TypeKind.TypeParameter; 245447"];
11009 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 245448"];
11010 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 245449"];
11011 [label="oldArgument.IsSameAs(newArgument) 245450"];
11012 [label="param IsSameAs(TypeWithAnnotations other) 245451"];
11013 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 245452"];
11014 [label="changed = true; 245453"];
11015 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 245454"];
11016 [label="type.TypeParameters 245455"];
11017 [label="get\n                {\n                    EnsureTypeParametersAreLoaded();\n                    return _lazyTypeParameters;\n                } 245456"];
11018 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var moduleSymbol = ContainingPEModule;\n\n                    // If this is a nested type generic parameters in metadata include generic parameters of the outer types.\n                    int firstIndex = _genericParameterHandles.Count - _arity;\n\n                    TypeParameterSymbol[] ownedParams = new TypeParameterSymbol[_arity];\n                    for (int i = 0; i < ownedParams.Length; i++)\n                    {\n                        ownedParams[i] = new PETypeParameterSymbol(moduleSymbol, this, (ushort)i, _genericParameterHandles[firstIndex + i]);\n                    }\n\n                    ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                        ImmutableArray.Create<TypeParameterSymbol>(ownedParams));\n                } 245457"];
11019 [label="EnsureTypeParametersAreLoaded(); 245458"];
11020 [label="return _lazyTypeParameters; 245459"];
11021 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 245460"];
11022 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 245461"];
11023 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 245462"];
11024 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 245463"];
11025 [label="ConstructedFrom 245464"];
11026 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 245465"];
11027 [label="this.Arity 245466"];
11028 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 245467"];
11029 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 245468"];
11030 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 245469"];
11031 [label="this.Arity 245470"];
11032 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 245471"];
11033 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 245472"];
11034 [label="EnsureTypeParametersAreLoaded(); 245473"];
11035 [label="Debug.Assert(typeArguments.Length == n); 245474"];
11036 [label="Debug.Assert(typeArguments.Length > 0); 245475"];
11037 [label="typeArguments[i].Is(typeParameters[i]) 245476"];
11038 [label="return false; 245477"];
11039 [label="param AbstractTypeMap(this) 245478"];
11040 [label="Mapping 245479"];
11041 [label="_lazyTupleData 245480"];
11042 [label="_underlyingType 245481"];
11043 [label="Debug.Assert((object)underlyingType != null); 245482"];
11044 [label="_unbound 245483"];
11045 [label="_inputMap 245484"];
11046 [label="_newContainer 245485"];
11047 [label="_lazyMap 245486"];
11048 [label="originalDefinition.IsDefinition 245487"];
11049 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245488"];
11050 [label="OriginalDefinition 245489"];
11051 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245490"];
11052 [label="OriginalSymbolDefinition 245491"];
11053 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245492"];
11054 [label="this.OriginalTypeSymbolDefinition 245493"];
11055 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245494"];
11056 [label="return this.OriginalTypeSymbolDefinition; 245495"];
11057 [label="return OriginalSymbolDefinition; 245496"];
11058 [label="return (object)this == (object)OriginalDefinition; 245497"];
11059 [label="Debug.Assert(originalDefinition.IsDefinition); 245498"];
11060 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245499"];
11061 [label="originalDefinition.IsErrorType() 245500"];
11062 [label="param IsErrorType(this TypeSymbol type) 245501"];
11063 [label="RoslynDebug.Assert((object)type != null); 245502"];
11064 [label="RoslynDebug.Assert((object)type != null); 245503"];
11065 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245504"];
11066 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245505"];
11067 [label="constructedFrom.ConstructedFrom 245506"];
11068 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245507"];
11069 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245508"];
11070 [label="_constructedFrom 245509"];
11071 [label="constructedFrom.Arity 245510"];
11072 [label="return _arity; 245511"];
11073 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 245512"];
11074 [label="constructedFrom.Arity 245513"];
11075 [label="return _arity; 245514"];
11076 [label="Debug.Assert(constructedFrom.Arity != 0); 245515"];
11077 [label="Debug.Assert(constructedFrom.Arity != 0); 245516"];
11078 [label="param WithTupleDataFrom(NamedTypeSymbol original) 245517"];
11079 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245518"];
11080 [label="_ 245519"];
11081 [label="tupleCardinality: out _ 245520"];
11082 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245521"];
11083 [label="param IsTupleTypeOfCardinality(this) 245522"];
11084 [label="IsUnboundGenericType 245523"];
11085 [label="get\n            {\n                return _unbound;\n            } 245524"];
11086 [label="return _unbound; 245525"];
11087 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245526"];
11088 [label="ContainingSymbol 245527"];
11089 [label="get { return _newContainer; } 245528"];
11090 [label="return _newContainer; 245529"];
11091 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245530"];
11092 [label=".Kind 245531"];
11093 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245532"];
11094 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245533"];
11095 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245534"];
11096 [label="ContainingNamespace 245535"];
11097 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245536"];
11098 [label="get { return _newContainer; } 245537"];
11099 [label="return _newContainer; 245538"];
11100 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245539"];
11101 [label="ContainingNamespace.ContainingNamespace 245540"];
11102 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245541"];
11103 [label="return _containingNamespaceSymbol; 245542"];
11104 [label=".IsGlobalNamespace 245543"];
11105 [label="get\n            {\n                return false;\n            } 245544"];
11106 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245545"];
11107 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245546"];
11108 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245547"];
11109 [label="tupleCardinality = 0; 245548"];
11110 [label="if (noPiaIllegalGenericInstantiation)\n            {\n                constructedType = new NoPiaIllegalGenericInstantiationSymbol(moduleSymbol, constructedType);\n            } 245549"];
11111 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 245550"];
11112 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 245551"];
11113 [label="_elementNames 245552"];
11114 [label="elementNames.IsDefault 245553"];
11115 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 245554"];
11116 [label="_namesIndex 245555"];
11117 [label="_foundUsableErrorType = false; 245556"];
11118 [label="_foundUsableErrorType 245557"];
11119 [label="param DecodeType(this) 245558"];
11120 [label="get { return OriginalDefinition.Kind; } 245559"];
11121 [label="OriginalDefinition 245560"];
11122 [label="get { return _underlyingType; } 245561"];
11123 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245562"];
11124 [label="param DecodeNamedType(this) 245563"];
11125 [label="param DecodeTypeArguments(this) 245564"];
11126 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 245565"];
11127 [label="param DecodeTypeInternal(this) 245566"];
11128 [label="=> defaultType 245567"];
11129 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245568"];
11130 [label="return typeArgs; 245569"];
11131 [label="type.ContainingType 245570"];
11132 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 245571"];
11133 [label="NamedTypeSymbol containingType = type.ContainingType; 245572"];
11134 [label="NamedTypeSymbol? decodedContainingType; 245573"];
11135 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 245574"];
11136 [label="decodedContainingType = containingType; 245575"];
11137 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245576"];
11138 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245577"];
11139 [label="var typeArgsChanged = typeArgs != decodedArgs; 245578"];
11140 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 245579"];
11141 [label="decodedType.IsTupleType 245580"];
11142 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245581"];
11143 [label="_ 245582"];
11144 [label="tupleCardinality: out _ 245583"];
11145 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245584"];
11146 [label="param IsTupleTypeOfCardinality(this) 245585"];
11147 [label="IsUnboundGenericType 245586"];
11148 [label="get\n            {\n                return _unbound;\n            } 245587"];
11149 [label="return _unbound; 245588"];
11150 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245589"];
11151 [label="ContainingSymbol 245590"];
11152 [label="get { return _newContainer; } 245591"];
11153 [label="return _newContainer; 245592"];
11154 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245593"];
11155 [label=".Kind 245594"];
11156 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245595"];
11157 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245596"];
11158 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245597"];
11159 [label="ContainingNamespace 245598"];
11160 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245599"];
11161 [label="get { return _newContainer; } 245600"];
11162 [label="return _newContainer; 245601"];
11163 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245602"];
11164 [label="ContainingNamespace.ContainingNamespace 245603"];
11165 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245604"];
11166 [label=".IsGlobalNamespace 245605"];
11167 [label="get\n            {\n                return false;\n            } 245606"];
11168 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245607"];
11169 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245608"];
11170 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245609"];
11171 [label="tupleCardinality = 0; 245610"];
11172 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 245611"];
11173 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 245612"];
11174 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245613"];
11175 [label="param IsNullableType(this TypeSymbol type) 245614"];
11176 [label="var a1 = defaultType is null; 245615"];
11177 [label="!a1 245616"];
11178 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245617"];
11179 [label="defaultType.IsNullableType() 245618"];
11180 [label="param IsNullableType(this TypeSymbol type) 245619"];
11181 [label="Debug.Assert(a1 || a2 != true || a3); 245620"];
11182 [label="param TransformType(Symbol accessSymbol) 245621"];
11183 [label="metadataType.HasType 245622"];
11184 [label="DefaultType is null 245623"];
11185 [label="Debug.Assert(metadataType.HasType); 245624"];
11186 [label="accessSymbol.IsDefinition 245625"];
11187 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245626"];
11188 [label="OriginalDefinition 245627"];
11189 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245628"];
11190 [label="OriginalSymbolDefinition 245629"];
11191 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245630"];
11192 [label="this.OriginalTypeSymbolDefinition 245631"];
11193 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245632"];
11194 [label="return this.OriginalTypeSymbolDefinition; 245633"];
11195 [label="return OriginalSymbolDefinition; 245634"];
11196 [label="return (object)this == (object)OriginalDefinition; 245635"];
11197 [label="Debug.Assert(accessSymbol.IsDefinition); 245636"];
11198 [label="accessSymbol.ContainingModule 245637"];
11199 [label="get\n            {\n                return ContainingPEModule;\n            } 245638"];
11200 [label="ContainingPEModule 245639"];
11201 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 245640"];
11202 [label="Symbol s = _container; 245641"];
11203 [label="s.Kind 245642"];
11204 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245643"];
11205 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245644"];
11206 [label="return ContainingPEModule; 245645"];
11207 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 245646"];
11208 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245647"];
11209 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245648"];
11210 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 245649"];
11211 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 245650"];
11212 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 245651"];
11213 [label="Debug.Assert(symbol is object); 245652"];
11214 [label="symbol.Kind 245653"];
11215 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245654"];
11216 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 245655"];
11217 [label="isInternal = false; 245656"];
11218 [label="symbol.DeclaredAccessibility 245657"];
11219 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 245658"];
11220 [label="Accessibility access = Accessibility.Private; 245659"];
11221 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 245660"];
11222 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 245661"];
11223 [label="symbol.ContainingType 245662"];
11224 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 245663"];
11225 [label="return _container as NamedTypeSymbol; 245664"];
11226 [label="symbol = symbol.ContainingType; 245665"];
11227 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 245666"];
11228 [label="return true; 245667"];
11229 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245668"];
11230 [label="param TryGetByte(out byte? value) 245669"];
11231 [label="value = null; 245670"];
11232 [label="return true; 245671"];
11233 [label="=> defaultType 245672"];
11234 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 245673"];
11235 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 245674"];
11236 [label="_elementNames 245675"];
11237 [label="elementNames.IsDefault 245676"];
11238 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 245677"];
11239 [label="_namesIndex 245678"];
11240 [label="_foundUsableErrorType = false; 245679"];
11241 [label="_foundUsableErrorType 245680"];
11242 [label="param DecodeType(this) 245681"];
11243 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245682"];
11244 [label="param DecodeNamedType(this) 245683"];
11245 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 245684"];
11246 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 245685"];
11247 [label="param DecodeTypeArguments(this) 245686"];
11248 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 245687"];
11249 [label="return typeArgs; 245688"];
11250 [label="type.ContainingType 245689"];
11251 [label="NamedTypeSymbol containingType = type.ContainingType; 245690"];
11252 [label="NamedTypeSymbol? decodedContainingType; 245691"];
11253 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 245692"];
11254 [label="decodedContainingType = containingType; 245693"];
11255 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245694"];
11256 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 245695"];
11257 [label="var typeArgsChanged = typeArgs != decodedArgs; 245696"];
11258 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 245697"];
11259 [label="decodedType.IsTupleType 245698"];
11260 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245699"];
11261 [label="_ 245700"];
11262 [label="tupleCardinality: out _ 245701"];
11263 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245702"];
11264 [label="param IsTupleTypeOfCardinality(this) 245703"];
11265 [label="IsUnboundGenericType 245704"];
11266 [label="get\n            {\n                return false;\n            } 245705"];
11267 [label="return false; 245706"];
11268 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245707"];
11269 [label="ContainingSymbol 245708"];
11270 [label="get\n            {\n                return _container;\n            } 245709"];
11271 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245710"];
11272 [label=".Kind 245711"];
11273 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245712"];
11274 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245713"];
11275 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245714"];
11276 [label="ContainingNamespace 245715"];
11277 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245716"];
11278 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245717"];
11279 [label="ContainingNamespace.ContainingNamespace 245718"];
11280 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 245719"];
11281 [label=".IsGlobalNamespace 245720"];
11282 [label="get\n            {\n                return false;\n            } 245721"];
11283 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245722"];
11284 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245723"];
11285 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 245724"];
11286 [label="tupleCardinality = 0; 245725"];
11287 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 245726"];
11288 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 245727"];
11289 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 245728"];
11290 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 245729"];
11291 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245730"];
11292 [label="typeSymbol.IsNullableType() 245731"];
11293 [label="param IsNullableType(this TypeSymbol type) 245732"];
11294 [label="var a1 = defaultType is null; 245733"];
11295 [label="!a1 245734"];
11296 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245735"];
11297 [label="defaultType.IsNullableType() 245736"];
11298 [label="param IsNullableType(this TypeSymbol type) 245737"];
11299 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 245738"];
11300 [label="Debug.Assert(a1 || a2 != true || a3); 245739"];
11301 [label="Debug.Assert(a1 || a2 != true || a3); 245740"];
11302 [label="Debug.Assert(extensions != null); 245741"];
11303 [label="param TransformType(Symbol accessSymbol) 245742"];
11304 [label="metadataType.HasType 245743"];
11305 [label="Debug.Assert(metadataType.HasType); 245744"];
11306 [label="accessSymbol.IsDefinition 245745"];
11307 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245746"];
11308 [label="OriginalDefinition 245747"];
11309 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245748"];
11310 [label="OriginalSymbolDefinition 245749"];
11311 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245750"];
11312 [label="this.OriginalTypeSymbolDefinition 245751"];
11313 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245752"];
11314 [label="return this.OriginalTypeSymbolDefinition; 245753"];
11315 [label="return OriginalSymbolDefinition; 245754"];
11316 [label="return (object)this == (object)OriginalDefinition; 245755"];
11317 [label="Debug.Assert(accessSymbol.IsDefinition); 245756"];
11318 [label="accessSymbol.ContainingModule 245757"];
11319 [label="get\n            {\n                return ContainingPEModule;\n            } 245758"];
11320 [label="ContainingPEModule 245759"];
11321 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 245760"];
11322 [label="s.Kind 245761"];
11323 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245762"];
11324 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245763"];
11325 [label="return ContainingPEModule; 245764"];
11326 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 245765"];
11327 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245766"];
11328 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245767"];
11329 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 245768"];
11330 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 245769"];
11331 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 245770"];
11332 [label="Debug.Assert(symbol is object); 245771"];
11333 [label="symbol.Kind 245772"];
11334 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245773"];
11335 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 245774"];
11336 [label="isInternal = false; 245775"];
11337 [label="symbol.DeclaredAccessibility 245776"];
11338 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 245777"];
11339 [label="Accessibility access = Accessibility.Private; 245778"];
11340 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 245779"];
11341 [label="symbol.ContainingType 245780"];
11342 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 245781"];
11343 [label="symbol = symbol.ContainingType; 245782"];
11344 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 245783"];
11345 [label="return true; 245784"];
11346 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 245785"];
11347 [label="param TryGetByte(out byte? value) 245786"];
11348 [label="return true; 245787"];
11349 [label="=> defaultType 245788"];
11350 [label="return symbols.ToImmutableAndFree(); 245789"];
11351 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 245790"];
11352 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 245791"];
11353 [label="return _lazyDeclaredInterfaces; 245792"];
11354 [label="var declaredInterfaces = GetDeclaredInterfaces(null); 245793"];
11355 [label="IsInterface 245794"];
11356 [label="get\n            {\n                return _flags.IsInterface();\n            } 245795"];
11357 [label="return _flags.IsInterface(); 245796"];
11358 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 245797"];
11359 [label="return declaredInterfaces\n                .SelectAsArray(t => BaseTypeAnalysis.TypeDependsOn(t, this) ? CyclicInheritanceError(this, t) : t); 245798"];
11360 [label="return declaredInterfaces\n                .SelectAsArray(t => BaseTypeAnalysis.TypeDependsOn(t, this) ? CyclicInheritanceError(this, t) : t); 245799"];
11361 [label="return declaredInterfaces\n                .SelectAsArray(t => BaseTypeAnalysis.TypeDependsOn(t, this) ? CyclicInheritanceError(this, t) : t); 245800"];
11362 [label="Debug.Assert((object)depends != null); 245801"];
11363 [label="Debug.Assert((object)depends != null); 245802"];
11364 [label="Debug.Assert((object)on != null); 245803"];
11365 [label="Debug.Assert((object)on != null); 245804"];
11366 [label="on.IsDefinition 245805"];
11367 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245806"];
11368 [label="OriginalDefinition 245807"];
11369 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245808"];
11370 [label="OriginalSymbolDefinition 245809"];
11371 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245810"];
11372 [label="this.OriginalTypeSymbolDefinition 245811"];
11373 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245812"];
11374 [label="return this.OriginalTypeSymbolDefinition; 245813"];
11375 [label="return OriginalSymbolDefinition; 245814"];
11376 [label="return (object)this == (object)OriginalDefinition; 245815"];
11377 [label="Debug.Assert(on.IsDefinition); 245816"];
11378 [label="depends.DeclaringCompilation 245817"];
11379 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 245818"];
11380 [label="this.Kind 245819"];
11381 [label="get { return OriginalDefinition.Kind; } 245820"];
11382 [label="OriginalDefinition 245821"];
11383 [label="get { return _underlyingType; } 245822"];
11384 [label="OriginalDefinition.Kind 245823"];
11385 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245824"];
11386 [label="return OriginalDefinition.Kind; 245825"];
11387 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 245826"];
11388 [label="get { return _newContainer; } 245827"];
11389 [label="return _newContainer; 245828"];
11390 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 245829"];
11391 [label="if ((object)type == null)\n            {\n                return;\n            } 245830"];
11392 [label="if ((object)type == null)\n            {\n                return;\n            } 245831"];
11393 [label="foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    } 245832"];
11394 [label="type.GetDeclaredInterfaces(null) 245833"];
11395 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 245834"];
11396 [label="s.Kind 245835"];
11397 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 245836"];
11398 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 245837"];
11399 [label="Debug.Assert((object)moduleSymbol != null); 245838"];
11400 [label="while ((object)type != null && (type.MetadataArity - type.Arity) > position)\n            {\n                type = type.ContainingSymbol as PENamedTypeSymbol;\n            } 245839"];
11401 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 245840"];
11402 [label="type.MetadataArity 245841"];
11403 [label="if ((object)type == null || type.MetadataArity <= position)\n            {\n                return new UnsupportedMetadataTypeSymbol(); // position of type parameter too large\n            } 245842"];
11404 [label="Debug.Assert(position >= 0 && position < type.Arity); 245843"];
11405 [label="Debug.Assert(position >= 0 && position < type.Arity); 245844"];
11406 [label="type.Arity 245845"];
11407 [label="Debug.Assert(position >= 0 && position < type.Arity); 245846"];
11408 [label="Debug.Assert(position >= 0 && position < type.Arity); 245847"];
11409 [label="EnsureTypeParametersAreLoaded(); 245848"];
11410 [label="param SubstituteTypeParameters(ImmutableArray<bool> refersToNoPiaLocalType) 245849"];
11411 [label="param SubstituteTypeParameters(this) 245850"];
11412 [label="if (genericTypeDef is UnsupportedMetadataTypeSymbol)\n            {\n                return genericTypeDef;\n            } 245851"];
11413 [label="foreach (var arg in arguments)\n            {\n                if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                }\n            } 245852"];
11414 [label="arg.Key.Kind 245853"];
11415 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245854"];
11416 [label="if (arg.Key.Kind == SymbolKind.ErrorType &&\n                    arg.Key is UnsupportedMetadataTypeSymbol)\n                {\n                    return new UnsupportedMetadataTypeSymbol();\n                } 245855"];
11417 [label="moduleSymbol.ContainingAssembly 245856"];
11418 [label="ImmutableArray<AssemblySymbol> linkedAssemblies = moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies(); 245857"];
11419 [label="moduleSymbol.ContainingAssembly.GetLinkedReferencedAssemblies() 245858"];
11420 [label="param GetLinkedReferencedAssemblies(this) 245859"];
11421 [label="return _linkedReferencedAssemblies; 245860"];
11422 [label="bool noPiaIllegalGenericInstantiation = false; 245861"];
11423 [label="EnsureTypeParametersAreLoaded(); 245862"];
11424 [label="Debug.Assert(typeParameters.Length > 0); 245863"];
11425 [label="if (typeParameters.Length != arguments.Length)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 245864"];
11426 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 245865"];
11427 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 245866"];
11428 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 245867"];
11429 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245868"];
11430 [label="typeSymbol.IsNullableType() 245869"];
11431 [label="param IsNullableType(this TypeSymbol type) 245870"];
11432 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245871"];
11433 [label="this.OriginalDefinition 245872"];
11434 [label="get\n            {\n                return this;\n            } 245873"];
11435 [label="return this; 245874"];
11436 [label="return this.OriginalDefinition; 245875"];
11437 [label="get\n            {\n                return SpecialType.None;\n            } 245876"];
11438 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 245877"];
11439 [label="var a1 = defaultType is null; 245878"];
11440 [label="!a1 245879"];
11441 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245880"];
11442 [label="defaultType.IsNullableType() 245881"];
11443 [label="param IsNullableType(this TypeSymbol type) 245882"];
11444 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245883"];
11445 [label="this.OriginalDefinition 245884"];
11446 [label="get\n            {\n                return this;\n            } 245885"];
11447 [label="return this; 245886"];
11448 [label="return this.OriginalDefinition; 245887"];
11449 [label="get\n            {\n                return SpecialType.None;\n            } 245888"];
11450 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 245889"];
11451 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 245890"];
11452 [label="Debug.Assert(a1 || a2 != true || a3); 245891"];
11453 [label="Debug.Assert(a1 || a2 != true || a3); 245892"];
11454 [label="Debug.Assert(extensions != null); 245893"];
11455 [label="param TypeMap(bool allowAlpha = false) 245894"];
11456 [label="Debug.Assert(from.Length == to.Length); 245895"];
11457 [label="param AbstractTypeMap(this) 245896"];
11458 [label="Mapping 245897"];
11459 [label="previous.IsUnboundGenericType 245898"];
11460 [label="get\n            {\n                return false;\n            } 245899"];
11461 [label="return false; 245900"];
11462 [label="if (previous.IsUnboundGenericType)\n                return previous; 245901"];
11463 [label="previous.IsAnonymousType 245902"];
11464 [label="get\n            {\n                return false;\n            } 245903"];
11465 [label="return false; 245904"];
11466 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 245905"];
11467 [label="param SubstituteTypeDeclaration(this) 245906"];
11468 [label="previous.ConstructedFrom 245907"];
11469 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 245908"];
11470 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 245909"];
11471 [label="param SubstituteType(this) 245910"];
11472 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 245911"];
11473 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 245912"];
11474 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 245913"];
11475 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 245914"];
11476 [label="param SubstituteCustomModifiers(this) 245915"];
11477 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 245916"];
11478 [label="return customModifiers; 245917"];
11479 [label="=> defaultType 245918"];
11480 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 245919"];
11481 [label="TypeSymbol result; 245920"];
11482 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 245921"];
11483 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 245922"];
11484 [label="typeSymbol.IsTypeParameter() 245923"];
11485 [label="param IsTypeParameter(this TypeSymbol type) 245924"];
11486 [label="RoslynDebug.Assert((object)type != null); 245925"];
11487 [label="RoslynDebug.Assert((object)type != null); 245926"];
11488 [label="type.TypeKind 245927"];
11489 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 245928"];
11490 [label="return TypeKind.TypeParameter; 245929"];
11491 [label="return type.TypeKind == TypeKind.TypeParameter; 245930"];
11492 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 245931"];
11493 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 245932"];
11494 [label="oldArgument.IsSameAs(newArgument) 245933"];
11495 [label="param IsSameAs(TypeWithAnnotations other) 245934"];
11496 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 245935"];
11497 [label="changed = true; 245936"];
11498 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 245937"];
11499 [label="type.TypeParameters 245938"];
11500 [label="EnsureTypeParametersAreLoaded(); 245939"];
11501 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 245940"];
11502 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 245941"];
11503 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 245942"];
11504 [label="ConstructedFrom 245943"];
11505 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 245944"];
11506 [label="this.Arity 245945"];
11507 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 245946"];
11508 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 245947"];
11509 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 245948"];
11510 [label="this.Arity 245949"];
11511 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 245950"];
11512 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 245951"];
11513 [label="Debug.Assert(typeArguments.Length == n); 245952"];
11514 [label="Debug.Assert(typeArguments.Length > 0); 245953"];
11515 [label="return false; 245954"];
11516 [label="param AbstractTypeMap(this) 245955"];
11517 [label="Mapping 245956"];
11518 [label="_lazyTupleData 245957"];
11519 [label="_underlyingType 245958"];
11520 [label="Debug.Assert((object)underlyingType != null); 245959"];
11521 [label="_unbound 245960"];
11522 [label="_inputMap 245961"];
11523 [label="_newContainer 245962"];
11524 [label="_lazyMap 245963"];
11525 [label="originalDefinition.IsDefinition 245964"];
11526 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 245965"];
11527 [label="OriginalDefinition 245966"];
11528 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 245967"];
11529 [label="OriginalSymbolDefinition 245968"];
11530 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 245969"];
11531 [label="this.OriginalTypeSymbolDefinition 245970"];
11532 [label="get\n            {\n                return this.OriginalDefinition;\n            } 245971"];
11533 [label="return this.OriginalTypeSymbolDefinition; 245972"];
11534 [label="return OriginalSymbolDefinition; 245973"];
11535 [label="return (object)this == (object)OriginalDefinition; 245974"];
11536 [label="Debug.Assert(originalDefinition.IsDefinition); 245975"];
11537 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245976"];
11538 [label="originalDefinition.IsErrorType() 245977"];
11539 [label="param IsErrorType(this TypeSymbol type) 245978"];
11540 [label="RoslynDebug.Assert((object)type != null); 245979"];
11541 [label="RoslynDebug.Assert((object)type != null); 245980"];
11542 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 245981"];
11543 [label="Debug.Assert(!originalDefinition.IsErrorType()); 245982"];
11544 [label="constructedFrom.ConstructedFrom 245983"];
11545 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245984"];
11546 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 245985"];
11547 [label="_constructedFrom 245986"];
11548 [label="constructedFrom.Arity 245987"];
11549 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 245988"];
11550 [label="constructedFrom.Arity 245989"];
11551 [label="Debug.Assert(constructedFrom.Arity != 0); 245990"];
11552 [label="Debug.Assert(constructedFrom.Arity != 0); 245991"];
11553 [label="param WithTupleDataFrom(NamedTypeSymbol original) 245992"];
11554 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 245993"];
11555 [label="_ 245994"];
11556 [label="tupleCardinality: out _ 245995"];
11557 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 245996"];
11558 [label="param IsTupleTypeOfCardinality(this) 245997"];
11559 [label="IsUnboundGenericType 245998"];
11560 [label="get\n            {\n                return _unbound;\n            } 245999"];
11561 [label="return _unbound; 246000"];
11562 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246001"];
11563 [label="ContainingSymbol 246002"];
11564 [label="get { return _newContainer; } 246003"];
11565 [label="return _newContainer; 246004"];
11566 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246005"];
11567 [label=".Kind 246006"];
11568 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246007"];
11569 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246008"];
11570 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246009"];
11571 [label="ContainingNamespace 246010"];
11572 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246011"];
11573 [label="get { return _newContainer; } 246012"];
11574 [label="return _newContainer; 246013"];
11575 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246014"];
11576 [label="ContainingNamespace.ContainingNamespace 246015"];
11577 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246016"];
11578 [label=".IsGlobalNamespace 246017"];
11579 [label="get\n            {\n                return false;\n            } 246018"];
11580 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246019"];
11581 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246020"];
11582 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246021"];
11583 [label="tupleCardinality = 0; 246022"];
11584 [label="if (noPiaIllegalGenericInstantiation)\n            {\n                constructedType = new NoPiaIllegalGenericInstantiationSymbol(moduleSymbol, constructedType);\n            } 246023"];
11585 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 246024"];
11586 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 246025"];
11587 [label="_elementNames 246026"];
11588 [label="elementNames.IsDefault 246027"];
11589 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 246028"];
11590 [label="_namesIndex 246029"];
11591 [label="_foundUsableErrorType = false; 246030"];
11592 [label="_foundUsableErrorType 246031"];
11593 [label="param DecodeType(this) 246032"];
11594 [label="get { return OriginalDefinition.Kind; } 246033"];
11595 [label="OriginalDefinition 246034"];
11596 [label="get { return _underlyingType; } 246035"];
11597 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246036"];
11598 [label="param DecodeNamedType(this) 246037"];
11599 [label="param DecodeTypeArguments(this) 246038"];
11600 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 246039"];
11601 [label="param DecodeTypeInternal(this) 246040"];
11602 [label="=> defaultType 246041"];
11603 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 246042"];
11604 [label="return typeArgs; 246043"];
11605 [label="type.ContainingType 246044"];
11606 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 246045"];
11607 [label="NamedTypeSymbol containingType = type.ContainingType; 246046"];
11608 [label="NamedTypeSymbol? decodedContainingType; 246047"];
11609 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 246048"];
11610 [label="decodedContainingType = containingType; 246049"];
11611 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246050"];
11612 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246051"];
11613 [label="var typeArgsChanged = typeArgs != decodedArgs; 246052"];
11614 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 246053"];
11615 [label="decodedType.IsTupleType 246054"];
11616 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 246055"];
11617 [label="_ 246056"];
11618 [label="tupleCardinality: out _ 246057"];
11619 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 246058"];
11620 [label="param IsTupleTypeOfCardinality(this) 246059"];
11621 [label="IsUnboundGenericType 246060"];
11622 [label="get\n            {\n                return _unbound;\n            } 246061"];
11623 [label="return _unbound; 246062"];
11624 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246063"];
11625 [label="ContainingSymbol 246064"];
11626 [label="get { return _newContainer; } 246065"];
11627 [label="return _newContainer; 246066"];
11628 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246067"];
11629 [label=".Kind 246068"];
11630 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246069"];
11631 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246070"];
11632 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246071"];
11633 [label="ContainingNamespace 246072"];
11634 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246073"];
11635 [label="get { return _newContainer; } 246074"];
11636 [label="return _newContainer; 246075"];
11637 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246076"];
11638 [label="ContainingNamespace.ContainingNamespace 246077"];
11639 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246078"];
11640 [label=".IsGlobalNamespace 246079"];
11641 [label="get\n            {\n                return false;\n            } 246080"];
11642 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246081"];
11643 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246082"];
11644 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246083"];
11645 [label="tupleCardinality = 0; 246084"];
11646 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 246085"];
11647 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 246086"];
11648 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 246087"];
11649 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 246088"];
11650 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 246089"];
11651 [label="typeSymbol.IsNullableType() 246090"];
11652 [label="param IsNullableType(this TypeSymbol type) 246091"];
11653 [label="var a1 = defaultType is null; 246092"];
11654 [label="!a1 246093"];
11655 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 246094"];
11656 [label="defaultType.IsNullableType() 246095"];
11657 [label="param IsNullableType(this TypeSymbol type) 246096"];
11658 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 246097"];
11659 [label="Debug.Assert(a1 || a2 != true || a3); 246098"];
11660 [label="Debug.Assert(extensions != null); 246099"];
11661 [label="param TransformType(Symbol accessSymbol) 246100"];
11662 [label="metadataType.HasType 246101"];
11663 [label="=> !(DefaultType is null) 246102"];
11664 [label="Debug.Assert(metadataType.HasType); 246103"];
11665 [label="accessSymbol.IsDefinition 246104"];
11666 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 246105"];
11667 [label="OriginalDefinition 246106"];
11668 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 246107"];
11669 [label="OriginalSymbolDefinition 246108"];
11670 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 246109"];
11671 [label="this.OriginalTypeSymbolDefinition 246110"];
11672 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246111"];
11673 [label="return this.OriginalTypeSymbolDefinition; 246112"];
11674 [label="return OriginalSymbolDefinition; 246113"];
11675 [label="return (object)this == (object)OriginalDefinition; 246114"];
11676 [label="Debug.Assert(accessSymbol.IsDefinition); 246115"];
11677 [label="accessSymbol.ContainingModule 246116"];
11678 [label="get\n            {\n                return ContainingPEModule;\n            } 246117"];
11679 [label="ContainingPEModule 246118"];
11680 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 246119"];
11681 [label="Symbol s = _container; 246120"];
11682 [label="s.Kind 246121"];
11683 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246122"];
11684 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 246123"];
11685 [label="return ContainingPEModule; 246124"];
11686 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 246125"];
11687 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246126"];
11688 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246127"];
11689 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 246128"];
11690 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 246129"];
11691 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 246130"];
11692 [label="Debug.Assert(symbol is object); 246131"];
11693 [label="symbol.Kind 246132"];
11694 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246133"];
11695 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 246134"];
11696 [label="isInternal = false; 246135"];
11697 [label="symbol.DeclaredAccessibility 246136"];
11698 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 246137"];
11699 [label="Accessibility access = Accessibility.Private; 246138"];
11700 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 246139"];
11701 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 246140"];
11702 [label="symbol.ContainingType 246141"];
11703 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 246142"];
11704 [label="return _container as NamedTypeSymbol; 246143"];
11705 [label="symbol = symbol.ContainingType; 246144"];
11706 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 246145"];
11707 [label="return true; 246146"];
11708 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246147"];
11709 [label="param TryGetByte(out byte? value) 246148"];
11710 [label="value = null; 246149"];
11711 [label="s.Kind 246150"];
11712 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246151"];
11713 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 246152"];
11714 [label="param GetLocalNullableContextValue(this) 246153"];
11715 [label="get\n            {\n                return _moduleSymbol;\n            } 246154"];
11716 [label="return _moduleSymbol; 246155"];
11717 [label="param GetLocalNullableContextValue(this) 246156"];
11718 [label="get\n            {\n                return _assemblySymbol;\n            } 246157"];
11719 [label="return _assemblySymbol; 246158"];
11720 [label="param GetLocalNullableContextValue(this) 246159"];
11721 [label="get\n            {\n                return null;\n            } 246160"];
11722 [label="=> defaultType 246161"];
11723 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 246162"];
11724 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 246163"];
11725 [label="_elementNames 246164"];
11726 [label="elementNames.IsDefault 246165"];
11727 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 246166"];
11728 [label="_namesIndex 246167"];
11729 [label="_foundUsableErrorType = false; 246168"];
11730 [label="_foundUsableErrorType 246169"];
11731 [label="param DecodeType(this) 246170"];
11732 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246171"];
11733 [label="param DecodeNamedType(this) 246172"];
11734 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 246173"];
11735 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 246174"];
11736 [label="param DecodeTypeArguments(this) 246175"];
11737 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 246176"];
11738 [label="return typeArgs; 246177"];
11739 [label="type.ContainingType 246178"];
11740 [label="NamedTypeSymbol containingType = type.ContainingType; 246179"];
11741 [label="NamedTypeSymbol? decodedContainingType; 246180"];
11742 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 246181"];
11743 [label="decodedContainingType = containingType; 246182"];
11744 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246183"];
11745 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246184"];
11746 [label="var typeArgsChanged = typeArgs != decodedArgs; 246185"];
11747 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 246186"];
11748 [label="decodedType.IsTupleType 246187"];
11749 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 246188"];
11750 [label="_ 246189"];
11751 [label="tupleCardinality: out _ 246190"];
11752 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 246191"];
11753 [label="param IsTupleTypeOfCardinality(this) 246192"];
11754 [label="IsUnboundGenericType 246193"];
11755 [label="get\n            {\n                return false;\n            } 246194"];
11756 [label="return false; 246195"];
11757 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246196"];
11758 [label="ContainingSymbol 246197"];
11759 [label="get\n            {\n                return _container;\n            } 246198"];
11760 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246199"];
11761 [label=".Kind 246200"];
11762 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246201"];
11763 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246202"];
11764 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246203"];
11765 [label="ContainingNamespace 246204"];
11766 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246205"];
11767 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246206"];
11768 [label="ContainingNamespace.ContainingNamespace 246207"];
11769 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246208"];
11770 [label=".IsGlobalNamespace 246209"];
11771 [label="get\n            {\n                return false;\n            } 246210"];
11772 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246211"];
11773 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246212"];
11774 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246213"];
11775 [label="tupleCardinality = 0; 246214"];
11776 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 246215"];
11777 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 246216"];
11778 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 246217"];
11779 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 246218"];
11780 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 246219"];
11781 [label="typeSymbol.IsNullableType() 246220"];
11782 [label="param IsNullableType(this TypeSymbol type) 246221"];
11783 [label="var a1 = defaultType is null; 246222"];
11784 [label="!a1 246223"];
11785 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 246224"];
11786 [label="defaultType.IsNullableType() 246225"];
11787 [label="param IsNullableType(this TypeSymbol type) 246226"];
11788 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 246227"];
11789 [label="Debug.Assert(a1 || a2 != true || a3); 246228"];
11790 [label="Debug.Assert(a1 || a2 != true || a3); 246229"];
11791 [label="Debug.Assert(extensions != null); 246230"];
11792 [label="param TransformType(Symbol accessSymbol) 246231"];
11793 [label="metadataType.HasType 246232"];
11794 [label="Debug.Assert(metadataType.HasType); 246233"];
11795 [label="accessSymbol.IsDefinition 246234"];
11796 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 246235"];
11797 [label="OriginalDefinition 246236"];
11798 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 246237"];
11799 [label="OriginalSymbolDefinition 246238"];
11800 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 246239"];
11801 [label="this.OriginalTypeSymbolDefinition 246240"];
11802 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246241"];
11803 [label="return this.OriginalTypeSymbolDefinition; 246242"];
11804 [label="return OriginalSymbolDefinition; 246243"];
11805 [label="return (object)this == (object)OriginalDefinition; 246244"];
11806 [label="Debug.Assert(accessSymbol.IsDefinition); 246245"];
11807 [label="accessSymbol.ContainingModule 246246"];
11808 [label="get\n            {\n                return ContainingPEModule;\n            } 246247"];
11809 [label="ContainingPEModule 246248"];
11810 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 246249"];
11811 [label="s.Kind 246250"];
11812 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246251"];
11813 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 246252"];
11814 [label="return ContainingPEModule; 246253"];
11815 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 246254"];
11816 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246255"];
11817 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246256"];
11818 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 246257"];
11819 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 246258"];
11820 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 246259"];
11821 [label="Debug.Assert(symbol is object); 246260"];
11822 [label="symbol.Kind 246261"];
11823 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246262"];
11824 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 246263"];
11825 [label="isInternal = false; 246264"];
11826 [label="symbol.DeclaredAccessibility 246265"];
11827 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 246266"];
11828 [label="Accessibility access = Accessibility.Private; 246267"];
11829 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 246268"];
11830 [label="symbol.ContainingType 246269"];
11831 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 246270"];
11832 [label="symbol = symbol.ContainingType; 246271"];
11833 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 246272"];
11834 [label="return true; 246273"];
11835 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246274"];
11836 [label="return true; 246275"];
11837 [label="foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    } 246276"];
11838 [label="TypeDependsClosure(bt, currentCompilation, partialClosure); 246277"];
11839 [label="TypeDependsClosure(bt, currentCompilation, partialClosure); 246278"];
11840 [label="TypeDependsClosure(bt, currentCompilation, partialClosure); 246279"];
11841 [label="TypeDependsClosure(bt, currentCompilation, partialClosure) 246280"];
11842 [label="param TypeDependsClosure(NamedTypeSymbol type) 246281"];
11843 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 246282"];
11844 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 246283"];
11845 [label="if ((object)type == null)\n            {\n                return;\n            } 246284"];
11846 [label="if ((object)type == null)\n            {\n                return;\n            } 246285"];
11847 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 246286"];
11848 [label="s.Kind 246287"];
11849 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246288"];
11850 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 246289"];
11851 [label="Debug.Assert((object)moduleSymbol != null); 246290"];
11852 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 246291"];
11853 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 246292"];
11854 [label="_elementNames 246293"];
11855 [label="elementNames.IsDefault 246294"];
11856 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 246295"];
11857 [label="_namesIndex 246296"];
11858 [label="_foundUsableErrorType = false; 246297"];
11859 [label="_foundUsableErrorType 246298"];
11860 [label="param DecodeType(this) 246299"];
11861 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246300"];
11862 [label="param DecodeNamedType(this) 246301"];
11863 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 246302"];
11864 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 246303"];
11865 [label="param DecodeTypeArguments(this) 246304"];
11866 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 246305"];
11867 [label="return typeArgs; 246306"];
11868 [label="type.ContainingType 246307"];
11869 [label="NamedTypeSymbol containingType = type.ContainingType; 246308"];
11870 [label="NamedTypeSymbol? decodedContainingType; 246309"];
11871 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 246310"];
11872 [label="decodedContainingType = containingType; 246311"];
11873 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246312"];
11874 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 246313"];
11875 [label="var typeArgsChanged = typeArgs != decodedArgs; 246314"];
11876 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 246315"];
11877 [label="decodedType.IsTupleType 246316"];
11878 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 246317"];
11879 [label="_ 246318"];
11880 [label="tupleCardinality: out _ 246319"];
11881 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 246320"];
11882 [label="param IsTupleTypeOfCardinality(this) 246321"];
11883 [label="IsUnboundGenericType 246322"];
11884 [label="get\n            {\n                return false;\n            } 246323"];
11885 [label="return false; 246324"];
11886 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246325"];
11887 [label="ContainingSymbol 246326"];
11888 [label="get\n            {\n                return _container;\n            } 246327"];
11889 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246328"];
11890 [label=".Kind 246329"];
11891 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246330"];
11892 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246331"];
11893 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246332"];
11894 [label="ContainingNamespace 246333"];
11895 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246334"];
11896 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246335"];
11897 [label="ContainingNamespace.ContainingNamespace 246336"];
11898 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246337"];
11899 [label=".IsGlobalNamespace 246338"];
11900 [label="get\n            {\n                return false;\n            } 246339"];
11901 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246340"];
11902 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246341"];
11903 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246342"];
11904 [label="tupleCardinality = 0; 246343"];
11905 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 246344"];
11906 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 246345"];
11907 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 246346"];
11908 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 246347"];
11909 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 246348"];
11910 [label="typeSymbol.IsNullableType() 246349"];
11911 [label="param IsNullableType(this TypeSymbol type) 246350"];
11912 [label="var a1 = defaultType is null; 246351"];
11913 [label="!a1 246352"];
11914 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 246353"];
11915 [label="defaultType.IsNullableType() 246354"];
11916 [label="param IsNullableType(this TypeSymbol type) 246355"];
11917 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 246356"];
11918 [label="Debug.Assert(a1 || a2 != true || a3); 246357"];
11919 [label="Debug.Assert(a1 || a2 != true || a3); 246358"];
11920 [label="Debug.Assert(extensions != null); 246359"];
11921 [label="param TransformType(Symbol accessSymbol) 246360"];
11922 [label="metadataType.HasType 246361"];
11923 [label="Debug.Assert(metadataType.HasType); 246362"];
11924 [label="accessSymbol.IsDefinition 246363"];
11925 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 246364"];
11926 [label="OriginalDefinition 246365"];
11927 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 246366"];
11928 [label="OriginalSymbolDefinition 246367"];
11929 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 246368"];
11930 [label="this.OriginalTypeSymbolDefinition 246369"];
11931 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246370"];
11932 [label="return this.OriginalTypeSymbolDefinition; 246371"];
11933 [label="return OriginalSymbolDefinition; 246372"];
11934 [label="return (object)this == (object)OriginalDefinition; 246373"];
11935 [label="Debug.Assert(accessSymbol.IsDefinition); 246374"];
11936 [label="accessSymbol.ContainingModule 246375"];
11937 [label="get\n            {\n                return ContainingPEModule;\n            } 246376"];
11938 [label="ContainingPEModule 246377"];
11939 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 246378"];
11940 [label="s.Kind 246379"];
11941 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246380"];
11942 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 246381"];
11943 [label="return ContainingPEModule; 246382"];
11944 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 246383"];
11945 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246384"];
11946 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246385"];
11947 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 246386"];
11948 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 246387"];
11949 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 246388"];
11950 [label="Debug.Assert(symbol is object); 246389"];
11951 [label="symbol.Kind 246390"];
11952 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246391"];
11953 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 246392"];
11954 [label="isInternal = false; 246393"];
11955 [label="symbol.DeclaredAccessibility 246394"];
11956 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 246395"];
11957 [label="Accessibility access = Accessibility.Private; 246396"];
11958 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 246397"];
11959 [label="symbol.ContainingType 246398"];
11960 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 246399"];
11961 [label="symbol = symbol.ContainingType; 246400"];
11962 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 246401"];
11963 [label="return true; 246402"];
11964 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 246403"];
11965 [label="param TryGetByte(out byte? value) 246404"];
11966 [label="value = null; 246405"];
11967 [label="param GetLocalNullableContextValue(this) 246406"];
11968 [label="get\n            {\n                return _moduleSymbol;\n            } 246407"];
11969 [label="return _moduleSymbol; 246408"];
11970 [label="param GetLocalNullableContextValue(this) 246409"];
11971 [label="get\n            {\n                return _assemblySymbol;\n            } 246410"];
11972 [label="return _assemblySymbol; 246411"];
11973 [label="param GetLocalNullableContextValue(this) 246412"];
11974 [label="get\n            {\n                return null;\n            } 246413"];
11975 [label="=> defaultType 246414"];
11976 [label="if ((object)type == null)\n            {\n                return;\n            } 246415"];
11977 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 246416"];
11978 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246417"];
11979 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246418"];
11980 [label="TypeDependsClosure(bt, currentCompilation, partialClosure); 246419"];
11981 [label="if ((object)type == null)\n            {\n                return;\n            } 246420"];
11982 [label="param Equals(object obj) 246421"];
11983 [label="param Equals(this) 246422"];
11984 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 246423"];
11985 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 246424"];
11986 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 246425"];
11987 [label="param Equals(Symbol other) 246426"];
11988 [label="param Equals(TypeCompareKind compareKind) 246427"];
11989 [label="param Equals(this) 246428"];
11990 [label="var t2 = other as TypeSymbol; 246429"];
11991 [label="if (t2 is null)\n            {\n                return false;\n            } 246430"];
11992 [label="return this.Equals(t2, compareKind); 246431"];
11993 [label="return this.Equals(t2, compareKind); 246432"];
11994 [label="this.Equals(t2, compareKind) 246433"];
11995 [label="param Equals(TypeSymbol t2) 246434"];
11996 [label="param Equals(TypeCompareKind comparison) 246435"];
11997 [label="param Equals(this) 246436"];
11998 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 246437"];
11999 [label="t2 is NativeIntegerTypeSymbol nativeInteger 246438"];
12000 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 246439"];
12001 [label="base.Equals(t2, comparison) 246440"];
12002 [label="param Equals(TypeCompareKind comparison) 246441"];
12003 [label="param Equals(this) 246442"];
12004 [label="if ((object)t2 == this) return true; 246443"];
12005 [label="return true; 246444"];
12006 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246445"];
12007 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246446"];
12008 [label="return result; 246447"];
12009 [label="return _underlyingType; 246448"];
12010 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246449"];
12011 [label="return _newContainer; 246450"];
12012 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 246451"];
12013 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 246452"];
12014 [label="if ((object)type == null)\n            {\n                return;\n            } 246453"];
12015 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246454"];
12016 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246455"];
12017 [label="get { return null; } 246456"];
12018 [label="return null; 246457"];
12019 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 246458"];
12020 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246459"];
12021 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 246460"];
12022 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 246461"];
12023 [label="return _lazyInterfaces; 246462"];
12024 [label="Map.SubstituteNamedTypes(OriginalDefinition.InterfacesNoUseSiteDiagnostics(basesBeingResolved)) 246463"];
12025 [label="param SubstituteNamedTypes(ImmutableArray<NamedTypeSymbol> original) 246464"];
12026 [label="param SubstituteNamedTypes(this) 246465"];
12027 [label="NamedTypeSymbol[] result = null; 246466"];
12028 [label="for (int i = 0; i < original.Length; i++)\n            {\n                var t = original[i];\n                var substituted = SubstituteNamedType(t);\n                if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                }\n\n                if (result != null)\n                {\n                    result[i] = substituted;\n                }\n            } 246467"];
12029 [label="for (int i = 0; i < original.Length; i++)\n            {\n                var t = original[i];\n                var substituted = SubstituteNamedType(t);\n                if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                }\n\n                if (result != null)\n                {\n                    result[i] = substituted;\n                }\n            } 246468"];
12030 [label="var t = original[i]; 246469"];
12031 [label="var substituted = SubstituteNamedType(t); 246470"];
12032 [label="SubstituteNamedType(t) 246471"];
12033 [label="param SubstituteNamedType(NamedTypeSymbol previous) 246472"];
12034 [label="param SubstituteNamedType(this) 246473"];
12035 [label="previous.IsUnboundGenericType 246474"];
12036 [label="get\n            {\n                return _unbound;\n            } 246475"];
12037 [label="return _unbound; 246476"];
12038 [label="if (previous.IsUnboundGenericType)\n                return previous; 246477"];
12039 [label="previous.IsAnonymousType 246478"];
12040 [label="get\n            {\n                return false;\n            } 246479"];
12041 [label="return false; 246480"];
12042 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 246481"];
12043 [label="param SubstituteTypeDeclaration(this) 246482"];
12044 [label="previous.ConstructedFrom 246483"];
12045 [label="get\n            {\n                return this;\n            } 246484"];
12046 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 246485"];
12047 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 246486"];
12048 [label="var newArgument = oldArgument.SubstituteType(this); 246487"];
12049 [label="param SubstituteType(this) 246488"];
12050 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 246489"];
12051 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 246490"];
12052 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 246491"];
12053 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 246492"];
12054 [label="param SubstituteCustomModifiers(this) 246493"];
12055 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 246494"];
12056 [label="return customModifiers; 246495"];
12057 [label="=> defaultType 246496"];
12058 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 246497"];
12059 [label="TypeSymbol result; 246498"];
12060 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 246499"];
12061 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 246500"];
12062 [label="typeSymbol.IsTypeParameter() 246501"];
12063 [label="param IsTypeParameter(this TypeSymbol type) 246502"];
12064 [label="RoslynDebug.Assert((object)type != null); 246503"];
12065 [label="RoslynDebug.Assert((object)type != null); 246504"];
12066 [label="type.TypeKind 246505"];
12067 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 246506"];
12068 [label="return TypeKind.TypeParameter; 246507"];
12069 [label="return type.TypeKind == TypeKind.TypeParameter; 246508"];
12070 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 246509"];
12071 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 246510"];
12072 [label="oldArgument.IsSameAs(newArgument) 246511"];
12073 [label="param IsSameAs(TypeWithAnnotations other) 246512"];
12074 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 246513"];
12075 [label="changed = true; 246514"];
12076 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 246515"];
12077 [label="EnsureTypeParametersAreLoaded(); 246516"];
12078 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 246517"];
12079 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 246518"];
12080 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 246519"];
12081 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 246520"];
12082 [label="ConstructedFrom 246521"];
12083 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 246522"];
12084 [label="this.Arity 246523"];
12085 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 246524"];
12086 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 246525"];
12087 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 246526"];
12088 [label="this.Arity 246527"];
12089 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 246528"];
12090 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 246529"];
12091 [label="EnsureTypeParametersAreLoaded(); 246530"];
12092 [label="Debug.Assert(typeArguments.Length == n); 246531"];
12093 [label="Debug.Assert(typeArguments.Length > 0); 246532"];
12094 [label="return false; 246533"];
12095 [label="param AbstractTypeMap(this) 246534"];
12096 [label="Mapping 246535"];
12097 [label="_lazyTupleData 246536"];
12098 [label="_underlyingType 246537"];
12099 [label="Debug.Assert((object)underlyingType != null); 246538"];
12100 [label="_unbound 246539"];
12101 [label="_inputMap 246540"];
12102 [label="_newContainer 246541"];
12103 [label="_lazyMap 246542"];
12104 [label="originalDefinition.IsDefinition 246543"];
12105 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 246544"];
12106 [label="OriginalDefinition 246545"];
12107 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 246546"];
12108 [label="OriginalSymbolDefinition 246547"];
12109 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 246548"];
12110 [label="this.OriginalTypeSymbolDefinition 246549"];
12111 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246550"];
12112 [label="return this.OriginalTypeSymbolDefinition; 246551"];
12113 [label="return OriginalSymbolDefinition; 246552"];
12114 [label="return (object)this == (object)OriginalDefinition; 246553"];
12115 [label="Debug.Assert(originalDefinition.IsDefinition); 246554"];
12116 [label="Debug.Assert(!originalDefinition.IsErrorType()); 246555"];
12117 [label="originalDefinition.IsErrorType() 246556"];
12118 [label="param IsErrorType(this TypeSymbol type) 246557"];
12119 [label="RoslynDebug.Assert((object)type != null); 246558"];
12120 [label="RoslynDebug.Assert((object)type != null); 246559"];
12121 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 246560"];
12122 [label="Debug.Assert(!originalDefinition.IsErrorType()); 246561"];
12123 [label="constructedFrom.ConstructedFrom 246562"];
12124 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 246563"];
12125 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 246564"];
12126 [label="_constructedFrom 246565"];
12127 [label="constructedFrom.Arity 246566"];
12128 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 246567"];
12129 [label="constructedFrom.Arity 246568"];
12130 [label="Debug.Assert(constructedFrom.Arity != 0); 246569"];
12131 [label="Debug.Assert(constructedFrom.Arity != 0); 246570"];
12132 [label="param WithTupleDataFrom(NamedTypeSymbol original) 246571"];
12133 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 246572"];
12134 [label="_ 246573"];
12135 [label="tupleCardinality: out _ 246574"];
12136 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 246575"];
12137 [label="param IsTupleTypeOfCardinality(this) 246576"];
12138 [label="IsUnboundGenericType 246577"];
12139 [label="get\n            {\n                return _unbound;\n            } 246578"];
12140 [label="return _unbound; 246579"];
12141 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246580"];
12142 [label="ContainingSymbol 246581"];
12143 [label="get { return _newContainer; } 246582"];
12144 [label="return _newContainer; 246583"];
12145 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246584"];
12146 [label=".Kind 246585"];
12147 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246586"];
12148 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246587"];
12149 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246588"];
12150 [label="ContainingNamespace 246589"];
12151 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246590"];
12152 [label="get { return _newContainer; } 246591"];
12153 [label="return _newContainer; 246592"];
12154 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246593"];
12155 [label="ContainingNamespace.ContainingNamespace 246594"];
12156 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246595"];
12157 [label=".IsGlobalNamespace 246596"];
12158 [label="get\n            {\n                return false;\n            } 246597"];
12159 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246598"];
12160 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246599"];
12161 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246600"];
12162 [label="tupleCardinality = 0; 246601"];
12163 [label="if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                } 246602"];
12164 [label="if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                } 246603"];
12165 [label="if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    } 246604"];
12166 [label="if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    } 246605"];
12167 [label="result = new NamedTypeSymbol[original.Length]; 246606"];
12168 [label="for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        } 246607"];
12169 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246608"];
12170 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246609"];
12171 [label="result[i] 246610"];
12172 [label="previous.IsUnboundGenericType 246611"];
12173 [label="get\n            {\n                return _unbound;\n            } 246612"];
12174 [label="return _unbound; 246613"];
12175 [label="if (previous.IsUnboundGenericType)\n                return previous; 246614"];
12176 [label="previous.IsAnonymousType 246615"];
12177 [label="get\n            {\n                return false;\n            } 246616"];
12178 [label="return false; 246617"];
12179 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 246618"];
12180 [label="param SubstituteTypeDeclaration(this) 246619"];
12181 [label="previous.ConstructedFrom 246620"];
12182 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 246621"];
12183 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 246622"];
12184 [label="param SubstituteType(this) 246623"];
12185 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 246624"];
12186 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 246625"];
12187 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 246626"];
12188 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 246627"];
12189 [label="param SubstituteCustomModifiers(this) 246628"];
12190 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 246629"];
12191 [label="return customModifiers; 246630"];
12192 [label="=> defaultType 246631"];
12193 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 246632"];
12194 [label="TypeSymbol result; 246633"];
12195 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 246634"];
12196 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 246635"];
12197 [label="typeSymbol.IsTypeParameter() 246636"];
12198 [label="param IsTypeParameter(this TypeSymbol type) 246637"];
12199 [label="RoslynDebug.Assert((object)type != null); 246638"];
12200 [label="RoslynDebug.Assert((object)type != null); 246639"];
12201 [label="type.TypeKind 246640"];
12202 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 246641"];
12203 [label="return TypeKind.TypeParameter; 246642"];
12204 [label="return type.TypeKind == TypeKind.TypeParameter; 246643"];
12205 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 246644"];
12206 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 246645"];
12207 [label="oldArgument.IsSameAs(newArgument) 246646"];
12208 [label="param IsSameAs(TypeWithAnnotations other) 246647"];
12209 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 246648"];
12210 [label="changed = true; 246649"];
12211 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 246650"];
12212 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 246651"];
12213 [label="Debug.Assert(typeArguments.Length == n); 246652"];
12214 [label="Debug.Assert(typeArguments.Length > 0); 246653"];
12215 [label="return _arity; 246654"];
12216 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 246655"];
12217 [label="return _arity; 246656"];
12218 [label="Debug.Assert(constructedFrom.Arity != 0); 246657"];
12219 [label="param WithTupleDataFrom(NamedTypeSymbol original) 246658"];
12220 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 246659"];
12221 [label="_ 246660"];
12222 [label="tupleCardinality: out _ 246661"];
12223 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 246662"];
12224 [label="param IsTupleTypeOfCardinality(this) 246663"];
12225 [label="IsUnboundGenericType 246664"];
12226 [label="get\n            {\n                return _unbound;\n            } 246665"];
12227 [label="return _unbound; 246666"];
12228 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246667"];
12229 [label="ContainingSymbol 246668"];
12230 [label="get { return _newContainer; } 246669"];
12231 [label="return _newContainer; 246670"];
12232 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246671"];
12233 [label=".Kind 246672"];
12234 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 246673"];
12235 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246674"];
12236 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246675"];
12237 [label="ContainingNamespace 246676"];
12238 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246677"];
12239 [label="get { return _newContainer; } 246678"];
12240 [label="return _newContainer; 246679"];
12241 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246680"];
12242 [label="ContainingNamespace.ContainingNamespace 246681"];
12243 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 246682"];
12244 [label=".IsGlobalNamespace 246683"];
12245 [label="get\n            {\n                return false;\n            } 246684"];
12246 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246685"];
12247 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246686"];
12248 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 246687"];
12249 [label="tupleCardinality = 0; 246688"];
12250 [label="if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                } 246689"];
12251 [label="if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    } 246690"];
12252 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246691"];
12253 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246692"];
12254 [label="result[i] 246693"];
12255 [label="previous.IsUnboundGenericType 246694"];
12256 [label="get\n            {\n                return false;\n            } 246695"];
12257 [label="return false; 246696"];
12258 [label="if (previous.IsUnboundGenericType)\n                return previous; 246697"];
12259 [label="previous.IsAnonymousType 246698"];
12260 [label="get\n            {\n                return false;\n            } 246699"];
12261 [label="return false; 246700"];
12262 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 246701"];
12263 [label="param SubstituteTypeDeclaration(this) 246702"];
12264 [label="previous.ConstructedFrom 246703"];
12265 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 246704"];
12266 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 246705"];
12267 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 246706"];
12268 [label="bool changed = !ReferenceEquals(oldConstructedFrom, newConstructedFrom); 246707"];
12269 [label="if (!changed)\n            {\n                newTypeArguments.Free();\n                return previous;\n            } 246708"];
12270 [label="newTypeArguments.Free(); 246709"];
12271 [label="return previous; 246710"];
12272 [label="if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                } 246711"];
12273 [label="if (!Object.ReferenceEquals(substituted, t))\n                {\n                    if (result == null)\n                    {\n                        result = new NamedTypeSymbol[original.Length];\n                        for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        }\n                    }\n                } 246712"];
12274 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246713"];
12275 [label="if (result != null)\n                {\n                    result[i] = substituted;\n                } 246714"];
12276 [label="result[i] 246715"];
12277 [label="return result != null ? result.AsImmutableOrNull() : original; 246716"];
12278 [label="return result != null ? result.AsImmutableOrNull() : original; 246717"];
12279 [label="result != null 246718"];
12280 [label="return result != null ? result.AsImmutableOrNull() : original; 246719"];
12281 [label="ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics(); 246720"];
12282 [label="for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    } 246721"];
12283 [label="for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    } 246722"];
12284 [label="var baseInterface = baseInterfaces[i]; 246723"];
12285 [label="addAllInterfaces(baseInterface, visited, result); 246724"];
12286 [label="addAllInterfaces(baseInterface, visited, result); 246725"];
12287 [label="addAllInterfaces(baseInterface, visited, result); 246726"];
12288 [label="addAllInterfaces(baseInterface, visited, result) 246727"];
12289 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 246728"];
12290 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 246729"];
12291 [label="static void addAllInterfaces(NamedTypeSymbol @interface, HashSet<NamedTypeSymbol> visited, ArrayBuilder<NamedTypeSymbol> result)\n            {\n                if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                }\n            } 246730"];
12292 [label="param GetHashCode(this) 246731"];
12293 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 246732"];
12294 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 246733"];
12295 [label="IsInterface 246734"];
12296 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 246735"];
12297 [label="result.Add(@interface); 246736"];
12298 [label="result.Add(@interface); 246737"];
12299 [label="addAllInterfaces(baseInterface, visited, result); 246738"];
12300 [label="param GetHashCode(this) 246739"];
12301 [label="if ((object)t2 == null) return false; 246740"];
12302 [label="if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                } 246741"];
12303 [label="if ((object)other == null) return false; 246742"];
12304 [label="this.OriginalDefinition 246743"];
12305 [label="var thisOriginalDefinition = this.OriginalDefinition; 246744"];
12306 [label="other.OriginalDefinition 246745"];
12307 [label="var otherOriginalDefinition = other.OriginalDefinition; 246746"];
12308 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 246747"];
12309 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 246748"];
12310 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 246749"];
12311 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246750"];
12312 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246751"];
12313 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246752"];
12314 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246753"];
12315 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246754"];
12316 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246755"];
12317 [label="Equals(thisOriginalDefinition, otherOriginalDefinition, comparison) 246756"];
12318 [label="param Equals(TypeSymbol left) 246757"];
12319 [label="param Equals(TypeSymbol right) 246758"];
12320 [label="param Equals(TypeCompareKind comparison) 246759"];
12321 [label="if (left is null)\n            {\n                return right is null;\n            } 246760"];
12322 [label="return left.Equals(right, comparison); 246761"];
12323 [label="return left.Equals(right, comparison); 246762"];
12324 [label="left.Equals(right, comparison) 246763"];
12325 [label="param Equals(TypeSymbol t2) 246764"];
12326 [label="param Equals(TypeCompareKind comparison) 246765"];
12327 [label="param Equals(this) 246766"];
12328 [label="if ((object)t2 == this) return true; 246767"];
12329 [label="param EqualsComplicatedCases(TypeCompareKind comparison) 246768"];
12330 [label="this.ContainingType 246769"];
12331 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 246770"];
12332 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 246771"];
12333 [label="ConstructedFrom 246772"];
12334 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 246773"];
12335 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 246774"];
12336 [label="other.ConstructedFrom 246775"];
12337 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 246776"];
12338 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 246777"];
12339 [label="if (thisIsNotConstructed && otherIsNotConstructed)\n            {\n                // Note that the arguments might appear different here due to alpha-renaming.  For example, given\n                // class A<T> { class B<U> {} }\n                // The type A<int>.B<int> is 'constructed from' A<int>.B<1>, which may be a distinct type object\n                // with a different alpha-renaming of B's type parameter every time that type expression is bound,\n                // but these should be considered the same type each time.\n                return true;\n            } 246778"];
12340 [label="this.IsUnboundGenericType 246779"];
12341 [label="get\n            {\n                return _unbound;\n            } 246780"];
12342 [label="return _unbound; 246781"];
12343 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 246782"];
12344 [label="other.IsUnboundGenericType 246783"];
12345 [label="get\n            {\n                return false;\n            } 246784"];
12346 [label="return false; 246785"];
12347 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 246786"];
12348 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 246787"];
12349 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246788"];
12350 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246789"];
12351 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246790"];
12352 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246791"];
12353 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246792"];
12354 [label="EnsureTypeParametersAreLoaded(); 246793"];
12355 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 246794"];
12356 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 246795"];
12357 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 246796"];
12358 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 246797"];
12359 [label="typeSymbol.IsNullableType() 246798"];
12360 [label="param IsNullableType(this TypeSymbol type) 246799"];
12361 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246800"];
12362 [label="this.OriginalDefinition 246801"];
12363 [label="get\n            {\n                return this;\n            } 246802"];
12364 [label="return this; 246803"];
12365 [label="return this.OriginalDefinition; 246804"];
12366 [label="get\n            {\n                return SpecialType.None;\n            } 246805"];
12367 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 246806"];
12368 [label="var a1 = defaultType is null; 246807"];
12369 [label="!a1 246808"];
12370 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 246809"];
12371 [label="defaultType.IsNullableType() 246810"];
12372 [label="param IsNullableType(this TypeSymbol type) 246811"];
12373 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246812"];
12374 [label="this.OriginalDefinition 246813"];
12375 [label="get\n            {\n                return this;\n            } 246814"];
12376 [label="return this; 246815"];
12377 [label="return this.OriginalDefinition; 246816"];
12378 [label="get\n            {\n                return SpecialType.None;\n            } 246817"];
12379 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 246818"];
12380 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 246819"];
12381 [label="Debug.Assert(a1 || a2 != true || a3); 246820"];
12382 [label="Debug.Assert(a1 || a2 != true || a3); 246821"];
12383 [label="Debug.Assert(extensions != null); 246822"];
12384 [label="Debug.Assert(count == otherTypeArguments.Length); 246823"];
12385 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 246824"];
12386 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 246825"];
12387 [label="typeArgument.Equals(otherTypeArgument, comparison) 246826"];
12388 [label="param Equals(TypeWithAnnotations other) 246827"];
12389 [label="param Equals(TypeCompareKind comparison) 246828"];
12390 [label="param Equals(this) 246829"];
12391 [label="if (this.IsSameAs(other))\n            {\n                return true;\n            } 246830"];
12392 [label="this.IsSameAs(other) 246831"];
12393 [label="param IsSameAs(TypeWithAnnotations other) 246832"];
12394 [label="param IsSameAs(this) 246833"];
12395 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 246834"];
12396 [label="HasType 246835"];
12397 [label="=> !(DefaultType is null) 246836"];
12398 [label="if (!HasType)\n            {\n                if (other.HasType)\n                {\n                    return false;\n                }\n            }\n            else if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 246837"];
12399 [label="other.HasType 246838"];
12400 [label="=> !(DefaultType is null) 246839"];
12401 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 246840"];
12402 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 246841"];
12403 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 246842"];
12404 [label="TypeSymbolEquals(other, comparison) 246843"];
12405 [label="param TypeSymbolEquals(TypeWithAnnotations other) 246844"];
12406 [label="param TypeSymbolEquals(TypeCompareKind comparison) 246845"];
12407 [label="=>\n            _extensions.TypeSymbolEquals(this, other, comparison) 246846"];
12408 [label="this 246847"];
12409 [label="other 246848"];
12410 [label="comparison 246849"];
12411 [label="_extensions.TypeSymbolEquals(this, other, comparison) 246850"];
12412 [label="param TypeSymbolEquals(TypeWithAnnotations type) 246851"];
12413 [label="param TypeSymbolEquals(TypeWithAnnotations other) 246852"];
12414 [label="param TypeSymbolEquals(TypeCompareKind comparison) 246853"];
12415 [label="param TypeSymbolEquals(this) 246854"];
12416 [label="return type.TypeSymbolEqualsCore(other, comparison); 246855"];
12417 [label="return type.TypeSymbolEqualsCore(other, comparison); 246856"];
12418 [label="type.TypeSymbolEqualsCore(other, comparison) 246857"];
12419 [label="param TypeSymbolEqualsCore(TypeWithAnnotations other) 246858"];
12420 [label="param TypeSymbolEqualsCore(TypeCompareKind comparison) 246859"];
12421 [label="param TypeSymbolEqualsCore(this) 246860"];
12422 [label="Type 246861"];
12423 [label="=> _extensions?.GetResolvedType(DefaultType) 246862"];
12424 [label="=> defaultType 246863"];
12425 [label="return Type.Equals(other.Type, comparison); 246864"];
12426 [label="other.Type 246865"];
12427 [label="=> _extensions?.GetResolvedType(DefaultType) 246866"];
12428 [label="=> defaultType 246867"];
12429 [label="return Type.Equals(other.Type, comparison); 246868"];
12430 [label="return Type.Equals(other.Type, comparison); 246869"];
12431 [label="Type.Equals(other.Type, comparison) 246870"];
12432 [label="param Equals(TypeSymbol? t2) 246871"];
12433 [label="param Equals(TypeCompareKind comparison) 246872"];
12434 [label="param Equals(this) 246873"];
12435 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 246874"];
12436 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 246875"];
12437 [label="this.Equals(t2 as ArrayTypeSymbol, comparison) 246876"];
12438 [label="param Equals(ArrayTypeSymbol? other) 246877"];
12439 [label="param Equals(TypeCompareKind comparison) 246878"];
12440 [label="param Equals(this) 246879"];
12441 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246880"];
12442 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246881"];
12443 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246882"];
12444 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 246883"];
12445 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 246884"];
12446 [label="return false; 246885"];
12447 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 246886"];
12448 [label="return false; 246887"];
12449 [label="return false; 246888"];
12450 [label="typeArguments[i].Type 246889"];
12451 [label="=> _extensions?.GetResolvedType(DefaultType) 246890"];
12452 [label="=> defaultType 246891"];
12453 [label="typeArguments[i].Type.OriginalDefinition 246892"];
12454 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 246893"];
12455 [label="get\n            {\n                return this;\n            } 246894"];
12456 [label="return this; 246895"];
12457 [label="typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything) 246896"];
12458 [label="param Equals(TypeSymbol t2) 246897"];
12459 [label="param Equals(TypeCompareKind comparison) 246898"];
12460 [label="param Equals(this) 246899"];
12461 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 246900"];
12462 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 246901"];
12463 [label="this.Equals(t2 as TypeParameterSymbol, comparison) 246902"];
12464 [label="param Equals(TypeParameterSymbol other) 246903"];
12465 [label="param Equals(TypeCompareKind comparison) 246904"];
12466 [label="param Equals(this) 246905"];
12467 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246906"];
12468 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246907"];
12469 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 246908"];
12470 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 246909"];
12471 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 246910"];
12472 [label="return false; 246911"];
12473 [label="return false; 246912"];
12474 [label="return _newContainer as NamedTypeSymbol; 246913"];
12475 [label="return _constructedFrom; 246914"];
12476 [label="=> defaultType 246915"];
12477 [label="get\n            {\n                return TypeKind.Array;\n            } 246916"];
12478 [label="get\n                {\n                    return 1;\n                } 246917"];
12479 [label="=> defaultType 246918"];
12480 [label="if (code == 0)\n            {\n                code++;\n            } 246919"];
12481 [label="if (code == 0)\n            {\n                code++;\n            } 246920"];
12482 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 246921"];
12483 [label="EnsureMapAndTypeParameters() 246922"];
12484 [label="param EnsureMapAndTypeParameters(this) 246923"];
12485 [label="if (!_lazyTypeParameters.IsDefault)\n            {\n                return;\n            } 246924"];
12486 [label="return; 246925"];
12487 [label="EnsureMapAndTypeParameters(); 246926"];
12488 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 246927"];
12489 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 246928"];
12490 [label="IsInterface 246929"];
12491 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 246930"];
12492 [label="Debug.Assert((object)depends != null); 246931"];
12493 [label="Debug.Assert((object)on != null); 246932"];
12494 [label="on.IsDefinition 246933"];
12495 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 246934"];
12496 [label="OriginalDefinition 246935"];
12497 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 246936"];
12498 [label="OriginalSymbolDefinition 246937"];
12499 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 246938"];
12500 [label="this.OriginalTypeSymbolDefinition 246939"];
12501 [label="get\n            {\n                return this.OriginalDefinition;\n            } 246940"];
12502 [label="return this.OriginalTypeSymbolDefinition; 246941"];
12503 [label="return OriginalSymbolDefinition; 246942"];
12504 [label="return (object)this == (object)OriginalDefinition; 246943"];
12505 [label="Debug.Assert(on.IsDefinition); 246944"];
12506 [label="depends.DeclaringCompilation 246945"];
12507 [label="get { return null; } 246946"];
12508 [label="return null; 246947"];
12509 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 246948"];
12510 [label="if ((object)type == null)\n            {\n                return;\n            } 246949"];
12511 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 246950"];
12512 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246951"];
12513 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 246952"];
12514 [label="previous.IsUnboundGenericType 246953"];
12515 [label="get\n            {\n                return false;\n            } 246954"];
12516 [label="return false; 246955"];
12517 [label="if (previous.IsUnboundGenericType)\n                return previous; 246956"];
12518 [label="previous.IsAnonymousType 246957"];
12519 [label="get\n            {\n                return false;\n            } 246958"];
12520 [label="return false; 246959"];
12521 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 246960"];
12522 [label="param SubstituteTypeDeclaration(this) 246961"];
12523 [label="previous.ConstructedFrom 246962"];
12524 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 246963"];
12525 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 246964"];
12526 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 246965"];
12527 [label="newTypeArguments.Free(); 246966"];
12528 [label="param GetHashCode(this) 246967"];
12529 [label="param Equals(Symbol x) 246968"];
12530 [label="param Equals(Symbol y) 246969"];
12531 [label="param Equals(this) 246970"];
12532 [label="return x is null ? y is null : x.Equals(y, _comparison); 246971"];
12533 [label="x is null 246972"];
12534 [label="return x is null ? y is null : x.Equals(y, _comparison); 246973"];
12535 [label="return x is null ? y is null : x.Equals(y, _comparison); 246974"];
12536 [label="x.Equals(y, _comparison) 246975"];
12537 [label="param Equals(Symbol other) 246976"];
12538 [label="param Equals(TypeCompareKind compareKind) 246977"];
12539 [label="if (t2 is null)\n            {\n                return false;\n            } 246978"];
12540 [label="param Equals(TypeCompareKind comparison) 246979"];
12541 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 246980"];
12542 [label="param GetHashCode(this) 246981"];
12543 [label="if ((object)t2 == null) return false; 246982"];
12544 [label="if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                } 246983"];
12545 [label="if ((object)other == null) return false; 246984"];
12546 [label="var thisOriginalDefinition = this.OriginalDefinition; 246985"];
12547 [label="other.OriginalDefinition 246986"];
12548 [label="var otherOriginalDefinition = other.OriginalDefinition; 246987"];
12549 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 246988"];
12550 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 246989"];
12551 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 246990"];
12552 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246991"];
12553 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246992"];
12554 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 246993"];
12555 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246994"];
12556 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246995"];
12557 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 246996"];
12558 [label="Equals(thisOriginalDefinition, otherOriginalDefinition, comparison) 246997"];
12559 [label="param Equals(TypeSymbol left) 246998"];
12560 [label="param Equals(TypeSymbol right) 246999"];
12561 [label="param Equals(TypeCompareKind comparison) 247000"];
12562 [label="if (left is null)\n            {\n                return right is null;\n            } 247001"];
12563 [label="return left.Equals(right, comparison); 247002"];
12564 [label="return left.Equals(right, comparison); 247003"];
12565 [label="left.Equals(right, comparison) 247004"];
12566 [label="param Equals(TypeSymbol t2) 247005"];
12567 [label="param Equals(TypeCompareKind comparison) 247006"];
12568 [label="param Equals(this) 247007"];
12569 [label="if ((object)t2 == this) return true; 247008"];
12570 [label="param EqualsComplicatedCases(TypeCompareKind comparison) 247009"];
12571 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 247010"];
12572 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 247011"];
12573 [label="other.ConstructedFrom 247012"];
12574 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 247013"];
12575 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 247014"];
12576 [label="if (thisIsNotConstructed && otherIsNotConstructed)\n            {\n                // Note that the arguments might appear different here due to alpha-renaming.  For example, given\n                // class A<T> { class B<U> {} }\n                // The type A<int>.B<int> is 'constructed from' A<int>.B<1>, which may be a distinct type object\n                // with a different alpha-renaming of B's type parameter every time that type expression is bound,\n                // but these should be considered the same type each time.\n                return true;\n            } 247015"];
12577 [label="this.IsUnboundGenericType 247016"];
12578 [label="get\n            {\n                return _unbound;\n            } 247017"];
12579 [label="return _unbound; 247018"];
12580 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247019"];
12581 [label="other.IsUnboundGenericType 247020"];
12582 [label="get\n            {\n                return false;\n            } 247021"];
12583 [label="return false; 247022"];
12584 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247023"];
12585 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247024"];
12586 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247025"];
12587 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247026"];
12588 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247027"];
12589 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247028"];
12590 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247029"];
12591 [label="EnsureTypeParametersAreLoaded(); 247030"];
12592 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 247031"];
12593 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 247032"];
12594 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 247033"];
12595 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247034"];
12596 [label="typeSymbol.IsNullableType() 247035"];
12597 [label="param IsNullableType(this TypeSymbol type) 247036"];
12598 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247037"];
12599 [label="this.OriginalDefinition 247038"];
12600 [label="get\n            {\n                return this;\n            } 247039"];
12601 [label="return this; 247040"];
12602 [label="return this.OriginalDefinition; 247041"];
12603 [label="get\n            {\n                return SpecialType.None;\n            } 247042"];
12604 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247043"];
12605 [label="var a1 = defaultType is null; 247044"];
12606 [label="!a1 247045"];
12607 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247046"];
12608 [label="defaultType.IsNullableType() 247047"];
12609 [label="param IsNullableType(this TypeSymbol type) 247048"];
12610 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247049"];
12611 [label="this.OriginalDefinition 247050"];
12612 [label="get\n            {\n                return this;\n            } 247051"];
12613 [label="return this; 247052"];
12614 [label="return this.OriginalDefinition; 247053"];
12615 [label="get\n            {\n                return SpecialType.None;\n            } 247054"];
12616 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247055"];
12617 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 247056"];
12618 [label="Debug.Assert(a1 || a2 != true || a3); 247057"];
12619 [label="Debug.Assert(a1 || a2 != true || a3); 247058"];
12620 [label="Debug.Assert(extensions != null); 247059"];
12621 [label="Debug.Assert(count == otherTypeArguments.Length); 247060"];
12622 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247061"];
12623 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247062"];
12624 [label="typeArgument.Equals(otherTypeArgument, comparison) 247063"];
12625 [label="param Equals(TypeWithAnnotations other) 247064"];
12626 [label="param Equals(TypeCompareKind comparison) 247065"];
12627 [label="param Equals(this) 247066"];
12628 [label="if (this.IsSameAs(other))\n            {\n                return true;\n            } 247067"];
12629 [label="this.IsSameAs(other) 247068"];
12630 [label="param IsSameAs(TypeWithAnnotations other) 247069"];
12631 [label="param IsSameAs(this) 247070"];
12632 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 247071"];
12633 [label="HasType 247072"];
12634 [label="=> !(DefaultType is null) 247073"];
12635 [label="if (!HasType)\n            {\n                if (other.HasType)\n                {\n                    return false;\n                }\n            }\n            else if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247074"];
12636 [label="other.HasType 247075"];
12637 [label="=> !(DefaultType is null) 247076"];
12638 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247077"];
12639 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247078"];
12640 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247079"];
12641 [label="TypeSymbolEquals(other, comparison) 247080"];
12642 [label="param TypeSymbolEquals(TypeWithAnnotations other) 247081"];
12643 [label="param TypeSymbolEquals(TypeCompareKind comparison) 247082"];
12644 [label="=>\n            _extensions.TypeSymbolEquals(this, other, comparison) 247083"];
12645 [label="this 247084"];
12646 [label="other 247085"];
12647 [label="comparison 247086"];
12648 [label="_extensions.TypeSymbolEquals(this, other, comparison) 247087"];
12649 [label="param TypeSymbolEquals(TypeWithAnnotations type) 247088"];
12650 [label="param TypeSymbolEquals(TypeWithAnnotations other) 247089"];
12651 [label="param TypeSymbolEquals(TypeCompareKind comparison) 247090"];
12652 [label="param TypeSymbolEquals(this) 247091"];
12653 [label="return type.TypeSymbolEqualsCore(other, comparison); 247092"];
12654 [label="return type.TypeSymbolEqualsCore(other, comparison); 247093"];
12655 [label="type.TypeSymbolEqualsCore(other, comparison) 247094"];
12656 [label="param TypeSymbolEqualsCore(TypeWithAnnotations other) 247095"];
12657 [label="param TypeSymbolEqualsCore(TypeCompareKind comparison) 247096"];
12658 [label="param TypeSymbolEqualsCore(this) 247097"];
12659 [label="Type 247098"];
12660 [label="=> _extensions?.GetResolvedType(DefaultType) 247099"];
12661 [label="=> defaultType 247100"];
12662 [label="return Type.Equals(other.Type, comparison); 247101"];
12663 [label="other.Type 247102"];
12664 [label="=> _extensions?.GetResolvedType(DefaultType) 247103"];
12665 [label="=> defaultType 247104"];
12666 [label="return Type.Equals(other.Type, comparison); 247105"];
12667 [label="return Type.Equals(other.Type, comparison); 247106"];
12668 [label="Type.Equals(other.Type, comparison) 247107"];
12669 [label="param Equals(TypeSymbol? t2) 247108"];
12670 [label="param Equals(TypeCompareKind comparison) 247109"];
12671 [label="param Equals(this) 247110"];
12672 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 247111"];
12673 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 247112"];
12674 [label="this.Equals(t2 as ArrayTypeSymbol, comparison) 247113"];
12675 [label="param Equals(ArrayTypeSymbol? other) 247114"];
12676 [label="param Equals(TypeCompareKind comparison) 247115"];
12677 [label="param Equals(this) 247116"];
12678 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247117"];
12679 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247118"];
12680 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247119"];
12681 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 247120"];
12682 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 247121"];
12683 [label="return false; 247122"];
12684 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247123"];
12685 [label="return false; 247124"];
12686 [label="return false; 247125"];
12687 [label="typeArguments[i].Type 247126"];
12688 [label="=> defaultType 247127"];
12689 [label="typeArguments[i].Type.OriginalDefinition 247128"];
12690 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 247129"];
12691 [label="get\n            {\n                return this;\n            } 247130"];
12692 [label="return this; 247131"];
12693 [label="typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything) 247132"];
12694 [label="param Equals(TypeSymbol t2) 247133"];
12695 [label="param Equals(TypeCompareKind comparison) 247134"];
12696 [label="param Equals(this) 247135"];
12697 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 247136"];
12698 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 247137"];
12699 [label="this.Equals(t2 as TypeParameterSymbol, comparison) 247138"];
12700 [label="param Equals(TypeParameterSymbol other) 247139"];
12701 [label="param Equals(TypeCompareKind comparison) 247140"];
12702 [label="param Equals(this) 247141"];
12703 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247142"];
12704 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247143"];
12705 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247144"];
12706 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 247145"];
12707 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 247146"];
12708 [label="return false; 247147"];
12709 [label="return false; 247148"];
12710 [label="=> defaultType 247149"];
12711 [label="get\n            {\n                return TypeKind.Array;\n            } 247150"];
12712 [label="get\n                {\n                    return 1;\n                } 247151"];
12713 [label="if (code == 0)\n            {\n                code++;\n            } 247152"];
12714 [label="if (code == 0)\n            {\n                code++;\n            } 247153"];
12715 [label="EnsureMapAndTypeParameters() 247154"];
12716 [label="param EnsureMapAndTypeParameters(this) 247155"];
12717 [label="if (!_lazyTypeParameters.IsDefault)\n            {\n                return;\n            } 247156"];
12718 [label="return; 247157"];
12719 [label="EnsureMapAndTypeParameters(); 247158"];
12720 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 247159"];
12721 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 247160"];
12722 [label="IsInterface 247161"];
12723 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 247162"];
12724 [label="Debug.Assert((object)depends != null); 247163"];
12725 [label="Debug.Assert((object)on != null); 247164"];
12726 [label="on.IsDefinition 247165"];
12727 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247166"];
12728 [label="OriginalDefinition 247167"];
12729 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247168"];
12730 [label="OriginalSymbolDefinition 247169"];
12731 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247170"];
12732 [label="this.OriginalTypeSymbolDefinition 247171"];
12733 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247172"];
12734 [label="return this.OriginalTypeSymbolDefinition; 247173"];
12735 [label="return OriginalSymbolDefinition; 247174"];
12736 [label="return (object)this == (object)OriginalDefinition; 247175"];
12737 [label="Debug.Assert(on.IsDefinition); 247176"];
12738 [label="depends.DeclaringCompilation 247177"];
12739 [label="this.Kind 247178"];
12740 [label="get { return OriginalDefinition.Kind; } 247179"];
12741 [label="OriginalDefinition 247180"];
12742 [label="get { return _underlyingType; } 247181"];
12743 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247182"];
12744 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 247183"];
12745 [label="get { return _newContainer; } 247184"];
12746 [label="return _newContainer; 247185"];
12747 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 247186"];
12748 [label="if ((object)type == null)\n            {\n                return;\n            } 247187"];
12749 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 247188"];
12750 [label="TypeDependsClosure(bt, currentCompilation, partialClosure); 247189"];
12751 [label="if ((object)type == null)\n            {\n                return;\n            } 247190"];
12752 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 247191"];
12753 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 247192"];
12754 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 247193"];
12755 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 247194"];
12756 [label="Debug.Assert((object)depends != null); 247195"];
12757 [label="Debug.Assert((object)on != null); 247196"];
12758 [label="on.IsDefinition 247197"];
12759 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247198"];
12760 [label="OriginalDefinition 247199"];
12761 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247200"];
12762 [label="OriginalSymbolDefinition 247201"];
12763 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247202"];
12764 [label="this.OriginalTypeSymbolDefinition 247203"];
12765 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247204"];
12766 [label="return this.OriginalTypeSymbolDefinition; 247205"];
12767 [label="return OriginalSymbolDefinition; 247206"];
12768 [label="return (object)this == (object)OriginalDefinition; 247207"];
12769 [label="Debug.Assert(on.IsDefinition); 247208"];
12770 [label="depends.DeclaringCompilation 247209"];
12771 [label="get { return null; } 247210"];
12772 [label="return null; 247211"];
12773 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 247212"];
12774 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 247213"];
12775 [label="previous.IsUnboundGenericType 247214"];
12776 [label="get\n            {\n                return _unbound;\n            } 247215"];
12777 [label="return _unbound; 247216"];
12778 [label="if (previous.IsUnboundGenericType)\n                return previous; 247217"];
12779 [label="previous.IsAnonymousType 247218"];
12780 [label="get\n            {\n                return false;\n            } 247219"];
12781 [label="return false; 247220"];
12782 [label="if (previous.IsAnonymousType)\n            {\n                ImmutableArray<TypeWithAnnotations> oldFieldTypes = AnonymousTypeManager.GetAnonymousTypePropertyTypesWithAnnotations(previous);\n                ImmutableArray<TypeWithAnnotations> newFieldTypes = SubstituteTypes(oldFieldTypes);\n                return (oldFieldTypes == newFieldTypes) ? previous : AnonymousTypeManager.ConstructAnonymousTypeSymbol(previous, newFieldTypes);\n            } 247221"];
12783 [label="param SubstituteTypeDeclaration(this) 247222"];
12784 [label="previous.ConstructedFrom 247223"];
12785 [label="Debug.Assert((object)previous.ConstructedFrom == (object)previous); 247224"];
12786 [label="param SubstituteType(this) 247225"];
12787 [label="Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored); 247226"];
12788 [label="var newCustomModifiers = typeMap.SubstituteCustomModifiers(this.CustomModifiers); 247227"];
12789 [label="typeMap.SubstituteCustomModifiers(this.CustomModifiers) 247228"];
12790 [label="param SubstituteCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 247229"];
12791 [label="param SubstituteCustomModifiers(this) 247230"];
12792 [label="if (customModifiers.IsDefaultOrEmpty)\n            {\n                return customModifiers;\n            } 247231"];
12793 [label="return customModifiers; 247232"];
12794 [label="=> defaultType 247233"];
12795 [label="if (ReferenceEquals(previous, null))\n                return default(TypeWithAnnotations); 247234"];
12796 [label="TypeSymbol result; 247235"];
12797 [label="get\n            {\n                return SymbolKind.TypeParameter;\n            } 247236"];
12798 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 247237"];
12799 [label="typeSymbol.IsTypeParameter() 247238"];
12800 [label="param IsTypeParameter(this TypeSymbol type) 247239"];
12801 [label="RoslynDebug.Assert((object)type != null); 247240"];
12802 [label="RoslynDebug.Assert((object)type != null); 247241"];
12803 [label="type.TypeKind 247242"];
12804 [label="get\n            {\n                return TypeKind.TypeParameter;\n            } 247243"];
12805 [label="return TypeKind.TypeParameter; 247244"];
12806 [label="return type.TypeKind == TypeKind.TypeParameter; 247245"];
12807 [label="if (!typeSymbol.IsTypeParameter())\n            {\n                Debug.Assert(newTypeWithModifiers.NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && newTypeWithModifiers.NullableAnnotation.IsAnnotated()));\n                Debug.Assert(newTypeWithModifiers.CustomModifiers.IsEmpty);\n                Debug.Assert(NullableAnnotation != NullableAnnotation.Ignored);\n\n                if (typeSymbol.Equals(newTypeWithModifiers.Type, TypeCompareKind.ConsiderEverything) &&\n                    newCustomModifiers == CustomModifiers)\n                {\n                    return this; // substitution had no effect on the type or modifiers\n                }\n                else if ((NullableAnnotation.IsOblivious() || (typeSymbol.IsNullableType() && NullableAnnotation.IsAnnotated())) &&\n                    newCustomModifiers.IsEmpty)\n                {\n                    return newTypeWithModifiers;\n                }\n\n                return Create(newTypeWithModifiers.Type, NullableAnnotation, newCustomModifiers);\n            } 247246"];
12808 [label="if (!changed && !oldArgument.IsSameAs(newArgument))\n                {\n                    changed = true;\n                } 247247"];
12809 [label="oldArgument.IsSameAs(newArgument) 247248"];
12810 [label="param IsSameAs(TypeWithAnnotations other) 247249"];
12811 [label="changed = true; 247250"];
12812 [label="EnsureTypeParametersAreLoaded(); 247251"];
12813 [label="Debug.Assert(type.TypeParameters.IsEmpty == (typeArguments.Length == 0)); 247252"];
12814 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 247253"];
12815 [label="ConstructedFrom 247254"];
12816 [label="if (!ReferenceEquals(this, ConstructedFrom))\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromConstructed);\n            } 247255"];
12817 [label="this.Arity 247256"];
12818 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 247257"];
12819 [label="if (this.Arity == 0)\n            {\n                throw new InvalidOperationException(CSharpResources.CannotCreateConstructedFromNongeneric);\n            } 247258"];
12820 [label="if (typeArguments.IsDefault)\n            {\n                throw new ArgumentNullException(nameof(typeArguments));\n            } 247259"];
12821 [label="this.Arity 247260"];
12822 [label="if (typeArguments.Length != this.Arity)\n            {\n                throw new ArgumentException(CSharpResources.WrongNumberOfTypeArguments, nameof(typeArguments));\n            } 247261"];
12823 [label="Debug.Assert(!unbound || typeArguments.All(TypeWithAnnotationsIsErrorType)); 247262"];
12824 [label="Debug.Assert(typeArguments.Length == n); 247263"];
12825 [label="Debug.Assert(typeArguments.Length > 0); 247264"];
12826 [label="param AbstractTypeMap(this) 247265"];
12827 [label="Mapping 247266"];
12828 [label="_lazyTupleData 247267"];
12829 [label="_underlyingType 247268"];
12830 [label="Debug.Assert((object)underlyingType != null); 247269"];
12831 [label="_unbound 247270"];
12832 [label="_inputMap 247271"];
12833 [label="_newContainer 247272"];
12834 [label="_lazyMap 247273"];
12835 [label="originalDefinition.IsDefinition 247274"];
12836 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247275"];
12837 [label="OriginalDefinition 247276"];
12838 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247277"];
12839 [label="OriginalSymbolDefinition 247278"];
12840 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247279"];
12841 [label="this.OriginalTypeSymbolDefinition 247280"];
12842 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247281"];
12843 [label="return this.OriginalTypeSymbolDefinition; 247282"];
12844 [label="return OriginalSymbolDefinition; 247283"];
12845 [label="return (object)this == (object)OriginalDefinition; 247284"];
12846 [label="Debug.Assert(originalDefinition.IsDefinition); 247285"];
12847 [label="Debug.Assert(!originalDefinition.IsErrorType()); 247286"];
12848 [label="originalDefinition.IsErrorType() 247287"];
12849 [label="param IsErrorType(this TypeSymbol type) 247288"];
12850 [label="RoslynDebug.Assert((object)type != null); 247289"];
12851 [label="RoslynDebug.Assert((object)type != null); 247290"];
12852 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247291"];
12853 [label="Debug.Assert(!originalDefinition.IsErrorType()); 247292"];
12854 [label="constructedFrom.ConstructedFrom 247293"];
12855 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 247294"];
12856 [label="Debug.Assert(ReferenceEquals(constructedFrom.ConstructedFrom, constructedFrom)); 247295"];
12857 [label="_constructedFrom 247296"];
12858 [label="constructedFrom.Arity 247297"];
12859 [label="Debug.Assert(constructedFrom.Arity == typeArgumentsWithAnnotations.Length); 247298"];
12860 [label="constructedFrom.Arity 247299"];
12861 [label="Debug.Assert(constructedFrom.Arity != 0); 247300"];
12862 [label="Debug.Assert(constructedFrom.Arity != 0); 247301"];
12863 [label="param WithTupleDataFrom(NamedTypeSymbol original) 247302"];
12864 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 247303"];
12865 [label="_ 247304"];
12866 [label="tupleCardinality: out _ 247305"];
12867 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 247306"];
12868 [label="param IsTupleTypeOfCardinality(this) 247307"];
12869 [label="IsUnboundGenericType 247308"];
12870 [label="get\n            {\n                return _unbound;\n            } 247309"];
12871 [label="return _unbound; 247310"];
12872 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247311"];
12873 [label="ContainingSymbol 247312"];
12874 [label="get { return _newContainer; } 247313"];
12875 [label="return _newContainer; 247314"];
12876 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247315"];
12877 [label=".Kind 247316"];
12878 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247317"];
12879 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247318"];
12880 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247319"];
12881 [label="ContainingNamespace 247320"];
12882 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247321"];
12883 [label="get { return _newContainer; } 247322"];
12884 [label="return _newContainer; 247323"];
12885 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247324"];
12886 [label="ContainingNamespace.ContainingNamespace 247325"];
12887 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247326"];
12888 [label=".IsGlobalNamespace 247327"];
12889 [label="get\n            {\n                return false;\n            } 247328"];
12890 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247329"];
12891 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247330"];
12892 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247331"];
12893 [label="tupleCardinality = 0; 247332"];
12894 [label="for (int j = 0; j < i; j++)\n                        {\n                            result[j] = original[j];\n                        } 247333"];
12895 [label="get\n            {\n                return false;\n            } 247334"];
12896 [label="return false; 247335"];
12897 [label="if (previous.IsUnboundGenericType)\n                return previous; 247336"];
12898 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 247337"];
12899 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 247338"];
12900 [label="newTypeArguments.Free(); 247339"];
12901 [label="param GetHashCode(this) 247340"];
12902 [label="param Equals(this) 247341"];
12903 [label="param Equals(TypeCompareKind compareKind) 247342"];
12904 [label="if (t2 is null)\n            {\n                return false;\n            } 247343"];
12905 [label="param Equals(TypeCompareKind comparison) 247344"];
12906 [label="param GetHashCode(this) 247345"];
12907 [label="if ((object)t2 == null) return false; 247346"];
12908 [label="if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                } 247347"];
12909 [label="if ((object)other == null) return false; 247348"];
12910 [label="var thisOriginalDefinition = this.OriginalDefinition; 247349"];
12911 [label="var otherOriginalDefinition = other.OriginalDefinition; 247350"];
12912 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 247351"];
12913 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 247352"];
12914 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 247353"];
12915 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247354"];
12916 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247355"];
12917 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247356"];
12918 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247357"];
12919 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247358"];
12920 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247359"];
12921 [label="Equals(thisOriginalDefinition, otherOriginalDefinition, comparison) 247360"];
12922 [label="param Equals(TypeSymbol left) 247361"];
12923 [label="param Equals(TypeSymbol right) 247362"];
12924 [label="param Equals(TypeCompareKind comparison) 247363"];
12925 [label="if (left is null)\n            {\n                return right is null;\n            } 247364"];
12926 [label="return left.Equals(right, comparison); 247365"];
12927 [label="return left.Equals(right, comparison); 247366"];
12928 [label="left.Equals(right, comparison) 247367"];
12929 [label="param Equals(TypeSymbol t2) 247368"];
12930 [label="param Equals(TypeCompareKind comparison) 247369"];
12931 [label="param Equals(this) 247370"];
12932 [label="if ((object)t2 == this) return true; 247371"];
12933 [label="param EqualsComplicatedCases(TypeCompareKind comparison) 247372"];
12934 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 247373"];
12935 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 247374"];
12936 [label="other.ConstructedFrom 247375"];
12937 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 247376"];
12938 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 247377"];
12939 [label="if (thisIsNotConstructed && otherIsNotConstructed)\n            {\n                // Note that the arguments might appear different here due to alpha-renaming.  For example, given\n                // class A<T> { class B<U> {} }\n                // The type A<int>.B<int> is 'constructed from' A<int>.B<1>, which may be a distinct type object\n                // with a different alpha-renaming of B's type parameter every time that type expression is bound,\n                // but these should be considered the same type each time.\n                return true;\n            } 247378"];
12940 [label="this.IsUnboundGenericType 247379"];
12941 [label="get\n            {\n                return _unbound;\n            } 247380"];
12942 [label="return _unbound; 247381"];
12943 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247382"];
12944 [label="other.IsUnboundGenericType 247383"];
12945 [label="get\n            {\n                return false;\n            } 247384"];
12946 [label="return false; 247385"];
12947 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247386"];
12948 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247387"];
12949 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247388"];
12950 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247389"];
12951 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247390"];
12952 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247391"];
12953 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247392"];
12954 [label="EnsureTypeParametersAreLoaded(); 247393"];
12955 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 247394"];
12956 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 247395"];
12957 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 247396"];
12958 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247397"];
12959 [label="typeSymbol.IsNullableType() 247398"];
12960 [label="param IsNullableType(this TypeSymbol type) 247399"];
12961 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247400"];
12962 [label="this.OriginalDefinition 247401"];
12963 [label="get\n            {\n                return this;\n            } 247402"];
12964 [label="return this; 247403"];
12965 [label="return this.OriginalDefinition; 247404"];
12966 [label="get\n            {\n                return SpecialType.None;\n            } 247405"];
12967 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247406"];
12968 [label="var a1 = defaultType is null; 247407"];
12969 [label="!a1 247408"];
12970 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247409"];
12971 [label="defaultType.IsNullableType() 247410"];
12972 [label="param IsNullableType(this TypeSymbol type) 247411"];
12973 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247412"];
12974 [label="this.OriginalDefinition 247413"];
12975 [label="get\n            {\n                return this;\n            } 247414"];
12976 [label="return this; 247415"];
12977 [label="return this.OriginalDefinition; 247416"];
12978 [label="get\n            {\n                return SpecialType.None;\n            } 247417"];
12979 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247418"];
12980 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 247419"];
12981 [label="Debug.Assert(a1 || a2 != true || a3); 247420"];
12982 [label="Debug.Assert(a1 || a2 != true || a3); 247421"];
12983 [label="Debug.Assert(extensions != null); 247422"];
12984 [label="Debug.Assert(count == otherTypeArguments.Length); 247423"];
12985 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247424"];
12986 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247425"];
12987 [label="typeArgument.Equals(otherTypeArgument, comparison) 247426"];
12988 [label="param Equals(TypeWithAnnotations other) 247427"];
12989 [label="param Equals(TypeCompareKind comparison) 247428"];
12990 [label="param Equals(this) 247429"];
12991 [label="if (this.IsSameAs(other))\n            {\n                return true;\n            } 247430"];
12992 [label="this.IsSameAs(other) 247431"];
12993 [label="param IsSameAs(TypeWithAnnotations other) 247432"];
12994 [label="param IsSameAs(this) 247433"];
12995 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 247434"];
12996 [label="HasType 247435"];
12997 [label="=> !(DefaultType is null) 247436"];
12998 [label="if (!HasType)\n            {\n                if (other.HasType)\n                {\n                    return false;\n                }\n            }\n            else if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247437"];
12999 [label="other.HasType 247438"];
13000 [label="=> !(DefaultType is null) 247439"];
13001 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247440"];
13002 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247441"];
13003 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247442"];
13004 [label="TypeSymbolEquals(other, comparison) 247443"];
13005 [label="param TypeSymbolEquals(TypeWithAnnotations other) 247444"];
13006 [label="param TypeSymbolEquals(TypeCompareKind comparison) 247445"];
13007 [label="=>\n            _extensions.TypeSymbolEquals(this, other, comparison) 247446"];
13008 [label="this 247447"];
13009 [label="other 247448"];
13010 [label="comparison 247449"];
13011 [label="_extensions.TypeSymbolEquals(this, other, comparison) 247450"];
13012 [label="param TypeSymbolEquals(TypeWithAnnotations type) 247451"];
13013 [label="param TypeSymbolEquals(TypeWithAnnotations other) 247452"];
13014 [label="param TypeSymbolEquals(TypeCompareKind comparison) 247453"];
13015 [label="param TypeSymbolEquals(this) 247454"];
13016 [label="return type.TypeSymbolEqualsCore(other, comparison); 247455"];
13017 [label="return type.TypeSymbolEqualsCore(other, comparison); 247456"];
13018 [label="type.TypeSymbolEqualsCore(other, comparison) 247457"];
13019 [label="param TypeSymbolEqualsCore(TypeWithAnnotations other) 247458"];
13020 [label="param TypeSymbolEqualsCore(TypeCompareKind comparison) 247459"];
13021 [label="param TypeSymbolEqualsCore(this) 247460"];
13022 [label="Type 247461"];
13023 [label="=> _extensions?.GetResolvedType(DefaultType) 247462"];
13024 [label="=> defaultType 247463"];
13025 [label="return Type.Equals(other.Type, comparison); 247464"];
13026 [label="other.Type 247465"];
13027 [label="=> _extensions?.GetResolvedType(DefaultType) 247466"];
13028 [label="=> defaultType 247467"];
13029 [label="return Type.Equals(other.Type, comparison); 247468"];
13030 [label="return Type.Equals(other.Type, comparison); 247469"];
13031 [label="Type.Equals(other.Type, comparison) 247470"];
13032 [label="param Equals(TypeSymbol? t2) 247471"];
13033 [label="param Equals(TypeCompareKind comparison) 247472"];
13034 [label="param Equals(this) 247473"];
13035 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 247474"];
13036 [label="return this.Equals(t2 as ArrayTypeSymbol, comparison); 247475"];
13037 [label="this.Equals(t2 as ArrayTypeSymbol, comparison) 247476"];
13038 [label="param Equals(ArrayTypeSymbol? other) 247477"];
13039 [label="param Equals(TypeCompareKind comparison) 247478"];
13040 [label="param Equals(this) 247479"];
13041 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247480"];
13042 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247481"];
13043 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247482"];
13044 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 247483"];
13045 [label="if ((object?)other == null || !other.HasSameShapeAs(this) ||\n                !other.ElementTypeWithAnnotations.Equals(ElementTypeWithAnnotations, comparison))\n            {\n                return false;\n            } 247484"];
13046 [label="return false; 247485"];
13047 [label="if (!other.HasType || !TypeSymbolEquals(other, comparison))\n            {\n                return false;\n            } 247486"];
13048 [label="return false; 247487"];
13049 [label="return false; 247488"];
13050 [label="typeArguments[i].Type 247489"];
13051 [label="=> defaultType 247490"];
13052 [label="typeArguments[i].Type.OriginalDefinition 247491"];
13053 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 247492"];
13054 [label="get\n            {\n                return this;\n            } 247493"];
13055 [label="return this; 247494"];
13056 [label="typeParameters[i].Equals(\n                                 typeArguments[i].Type.OriginalDefinition,\n                                 TypeCompareKind.ConsiderEverything) 247495"];
13057 [label="param Equals(TypeSymbol t2) 247496"];
13058 [label="param Equals(TypeCompareKind comparison) 247497"];
13059 [label="param Equals(this) 247498"];
13060 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 247499"];
13061 [label="return this.Equals(t2 as TypeParameterSymbol, comparison); 247500"];
13062 [label="this.Equals(t2 as TypeParameterSymbol, comparison) 247501"];
13063 [label="param Equals(TypeParameterSymbol other) 247502"];
13064 [label="param Equals(TypeCompareKind comparison) 247503"];
13065 [label="param Equals(this) 247504"];
13066 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247505"];
13067 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247506"];
13068 [label="if (ReferenceEquals(this, other))\n            {\n                return true;\n            } 247507"];
13069 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 247508"];
13070 [label="if ((object)other == null || !ReferenceEquals(other.OriginalDefinition, this.OriginalDefinition))\n            {\n                return false;\n            } 247509"];
13071 [label="return false; 247510"];
13072 [label="return false; 247511"];
13073 [label="get\n            {\n                return TypeKind.Array;\n            } 247512"];
13074 [label="get\n                {\n                    return 1;\n                } 247513"];
13075 [label="=> defaultType 247514"];
13076 [label="if (code == 0)\n            {\n                code++;\n            } 247515"];
13077 [label="if (code == 0)\n            {\n                code++;\n            } 247516"];
13078 [label="param Equals(TypeCompareKind compareKind) 247517"];
13079 [label="if (t2 is null)\n            {\n                return false;\n            } 247518"];
13080 [label="var thisOriginalDefinition = this.OriginalDefinition; 247519"];
13081 [label="var otherOriginalDefinition = other.OriginalDefinition; 247520"];
13082 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 247521"];
13083 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 247522"];
13084 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 247523"];
13085 [label="if ((thisIsOriginalDefinition || otherIsOriginalDefinition) &&\n                (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247524"];
13086 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247525"];
13087 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247526"];
13088 [label="if (!Equals(thisOriginalDefinition, otherOriginalDefinition, comparison))\n            {\n                return false;\n            } 247527"];
13089 [label="param Equals(TypeSymbol left) 247528"];
13090 [label="param Equals(TypeSymbol right) 247529"];
13091 [label="param Equals(TypeCompareKind comparison) 247530"];
13092 [label="if (left is null)\n            {\n                return right is null;\n            } 247531"];
13093 [label="return left.Equals(right, comparison); 247532"];
13094 [label="return left.Equals(right, comparison); 247533"];
13095 [label="param Equals(TypeSymbol t2) 247534"];
13096 [label="param Equals(TypeCompareKind comparison) 247535"];
13097 [label="param Equals(this) 247536"];
13098 [label="if ((object)t2 == this) return true; 247537"];
13099 [label="param EqualsComplicatedCases(TypeCompareKind comparison) 247538"];
13100 [label="if ((object)this.ContainingType != null &&\n                !this.ContainingType.Equals(other.ContainingType, comparison))\n            {\n                return false;\n            } 247539"];
13101 [label="var thisIsNotConstructed = ReferenceEquals(ConstructedFrom, this); 247540"];
13102 [label="return _constructedFrom; 247541"];
13103 [label="var otherIsNotConstructed = ReferenceEquals(other.ConstructedFrom, other); 247542"];
13104 [label="if (thisIsNotConstructed && otherIsNotConstructed)\n            {\n                // Note that the arguments might appear different here due to alpha-renaming.  For example, given\n                // class A<T> { class B<U> {} }\n                // The type A<int>.B<int> is 'constructed from' A<int>.B<1>, which may be a distinct type object\n                // with a different alpha-renaming of B's type parameter every time that type expression is bound,\n                // but these should be considered the same type each time.\n                return true;\n            } 247543"];
13105 [label="return _unbound; 247544"];
13106 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247545"];
13107 [label="get\n            {\n                return _unbound;\n            } 247546"];
13108 [label="return _unbound; 247547"];
13109 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247548"];
13110 [label="if (this.IsUnboundGenericType != other.IsUnboundGenericType)\n            {\n                return false;\n            } 247549"];
13111 [label="if ((thisIsNotConstructed || otherIsNotConstructed) &&\n                 (comparison & (TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.AllNullableIgnoreOptions | TypeCompareKind.IgnoreTupleNames)) == 0)\n            {\n                return false;\n            } 247550"];
13112 [label="Debug.Assert(count == otherTypeArguments.Length); 247551"];
13113 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247552"];
13114 [label="if (!typeArgument.Equals(otherTypeArgument, comparison))\n                {\n                    return false;\n                } 247553"];
13115 [label="typeArgument.Equals(otherTypeArgument, comparison) 247554"];
13116 [label="param Equals(TypeWithAnnotations other) 247555"];
13117 [label="param Equals(TypeCompareKind comparison) 247556"];
13118 [label="param Equals(this) 247557"];
13119 [label="if (this.IsSameAs(other))\n            {\n                return true;\n            } 247558"];
13120 [label="this.IsSameAs(other) 247559"];
13121 [label="param IsSameAs(TypeWithAnnotations other) 247560"];
13122 [label="param IsSameAs(this) 247561"];
13123 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 247562"];
13124 [label="return ReferenceEquals(DefaultType, other.DefaultType) &&\n                NullableAnnotation == other.NullableAnnotation &&\n                ReferenceEquals(_extensions, other._extensions); 247563"];
13125 [label="return true; 247564"];
13126 [label="this.IsTupleType 247565"];
13127 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 247566"];
13128 [label="_ 247567"];
13129 [label="tupleCardinality: out _ 247568"];
13130 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 247569"];
13131 [label="param IsTupleTypeOfCardinality(this) 247570"];
13132 [label="IsUnboundGenericType 247571"];
13133 [label="get\n            {\n                return _unbound;\n            } 247572"];
13134 [label="return _unbound; 247573"];
13135 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247574"];
13136 [label="ContainingSymbol 247575"];
13137 [label="get { return _newContainer; } 247576"];
13138 [label="return _newContainer; 247577"];
13139 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247578"];
13140 [label=".Kind 247579"];
13141 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247580"];
13142 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247581"];
13143 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247582"];
13144 [label="ContainingNamespace 247583"];
13145 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247584"];
13146 [label="get { return _newContainer; } 247585"];
13147 [label="return _newContainer; 247586"];
13148 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247587"];
13149 [label="ContainingNamespace.ContainingNamespace 247588"];
13150 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247589"];
13151 [label=".IsGlobalNamespace 247590"];
13152 [label="get\n            {\n                return false;\n            } 247591"];
13153 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247592"];
13154 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247593"];
13155 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247594"];
13156 [label="tupleCardinality = 0; 247595"];
13157 [label="if (this.IsTupleType && !tupleNamesEquals(other, comparison))\n            {\n                return false;\n            } 247596"];
13158 [label="return true; 247597"];
13159 [label="if (visited.Add(@interface))\n                {\n                    ImmutableArray<NamedTypeSymbol> baseInterfaces = @interface.InterfacesNoUseSiteDiagnostics();\n                    for (int i = baseInterfaces.Length - 1; i >= 0; i--)\n                    {\n                        var baseInterface = baseInterfaces[i];\n                        addAllInterfaces(baseInterface, visited, result);\n                    }\n\n                    result.Add(@interface);\n                } 247598"];
13160 [label="result.Add(@interface); 247599"];
13161 [label="addAllInterfaces(interfaces[i], visited, result); 247600"];
13162 [label="baseType.BaseTypeNoUseSiteDiagnostics 247601"];
13163 [label="=> _baseType 247602"];
13164 [label="_baseType 247603"];
13165 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 247604"];
13166 [label="s.Kind 247605"];
13167 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247606"];
13168 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247607"];
13169 [label="Debug.Assert((object)moduleSymbol != null); 247608"];
13170 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 247609"];
13171 [label="return baseType; 247610"];
13172 [label="result = TypeKind.Class; 247611"];
13173 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 247612"];
13174 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 247613"];
13175 [label="s.Kind 247614"];
13176 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247615"];
13177 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247616"];
13178 [label="Debug.Assert((object)moduleSymbol != null); 247617"];
13179 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 247618"];
13180 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 247619"];
13181 [label="_elementNames 247620"];
13182 [label="elementNames.IsDefault 247621"];
13183 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 247622"];
13184 [label="_namesIndex 247623"];
13185 [label="_foundUsableErrorType = false; 247624"];
13186 [label="_foundUsableErrorType 247625"];
13187 [label="param DecodeType(this) 247626"];
13188 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247627"];
13189 [label="param DecodeNamedType(this) 247628"];
13190 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 247629"];
13191 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 247630"];
13192 [label="param DecodeTypeArguments(this) 247631"];
13193 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 247632"];
13194 [label="return typeArgs; 247633"];
13195 [label="type.ContainingType 247634"];
13196 [label="NamedTypeSymbol containingType = type.ContainingType; 247635"];
13197 [label="NamedTypeSymbol? decodedContainingType; 247636"];
13198 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 247637"];
13199 [label="decodedContainingType = containingType; 247638"];
13200 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247639"];
13201 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247640"];
13202 [label="var typeArgsChanged = typeArgs != decodedArgs; 247641"];
13203 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 247642"];
13204 [label="decodedType.IsTupleType 247643"];
13205 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 247644"];
13206 [label="_ 247645"];
13207 [label="tupleCardinality: out _ 247646"];
13208 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 247647"];
13209 [label="param IsTupleTypeOfCardinality(this) 247648"];
13210 [label="IsUnboundGenericType 247649"];
13211 [label="get\n            {\n                return false;\n            } 247650"];
13212 [label="return false; 247651"];
13213 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247652"];
13214 [label="ContainingSymbol 247653"];
13215 [label="get\n            {\n                return _container;\n            } 247654"];
13216 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247655"];
13217 [label=".Kind 247656"];
13218 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247657"];
13219 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247658"];
13220 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247659"];
13221 [label="ContainingNamespace 247660"];
13222 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247661"];
13223 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247662"];
13224 [label="ContainingNamespace.ContainingNamespace 247663"];
13225 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247664"];
13226 [label=".IsGlobalNamespace 247665"];
13227 [label="get\n            {\n                return true;\n            } 247666"];
13228 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247667"];
13229 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247668"];
13230 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247669"];
13231 [label="Name 247670"];
13232 [label="get\n            {\n                return _name;\n            } 247671"];
13233 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247672"];
13234 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247673"];
13235 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247674"];
13236 [label="tupleCardinality = 0; 247675"];
13237 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 247676"];
13238 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 247677"];
13239 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 247678"];
13240 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 247679"];
13241 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247680"];
13242 [label="typeSymbol.IsNullableType() 247681"];
13243 [label="param IsNullableType(this TypeSymbol type) 247682"];
13244 [label="var a1 = defaultType is null; 247683"];
13245 [label="!a1 247684"];
13246 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247685"];
13247 [label="defaultType.IsNullableType() 247686"];
13248 [label="param IsNullableType(this TypeSymbol type) 247687"];
13249 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 247688"];
13250 [label="Debug.Assert(a1 || a2 != true || a3); 247689"];
13251 [label="Debug.Assert(a1 || a2 != true || a3); 247690"];
13252 [label="Debug.Assert(extensions != null); 247691"];
13253 [label="param TransformType(Symbol accessSymbol) 247692"];
13254 [label="metadataType.HasType 247693"];
13255 [label="Debug.Assert(metadataType.HasType); 247694"];
13256 [label="accessSymbol.IsDefinition 247695"];
13257 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247696"];
13258 [label="OriginalDefinition 247697"];
13259 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247698"];
13260 [label="OriginalSymbolDefinition 247699"];
13261 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247700"];
13262 [label="this.OriginalTypeSymbolDefinition 247701"];
13263 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247702"];
13264 [label="return this.OriginalTypeSymbolDefinition; 247703"];
13265 [label="return OriginalSymbolDefinition; 247704"];
13266 [label="return (object)this == (object)OriginalDefinition; 247705"];
13267 [label="Debug.Assert(accessSymbol.IsDefinition); 247706"];
13268 [label="accessSymbol.ContainingModule 247707"];
13269 [label="get\n            {\n                return ContainingPEModule;\n            } 247708"];
13270 [label="ContainingPEModule 247709"];
13271 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 247710"];
13272 [label="s.Kind 247711"];
13273 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247712"];
13274 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247713"];
13275 [label="return ContainingPEModule; 247714"];
13276 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 247715"];
13277 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247716"];
13278 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247717"];
13279 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 247718"];
13280 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 247719"];
13281 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 247720"];
13282 [label="Debug.Assert(symbol is object); 247721"];
13283 [label="symbol.Kind 247722"];
13284 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247723"];
13285 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 247724"];
13286 [label="isInternal = false; 247725"];
13287 [label="symbol.DeclaredAccessibility 247726"];
13288 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 247727"];
13289 [label="Accessibility access = Accessibility.Private; 247728"];
13290 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 247729"];
13291 [label="symbol.ContainingType 247730"];
13292 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 247731"];
13293 [label="symbol = symbol.ContainingType; 247732"];
13294 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 247733"];
13295 [label="return true; 247734"];
13296 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247735"];
13297 [label="param TryGetByte(out byte? value) 247736"];
13298 [label="value = null; 247737"];
13299 [label="param GetLocalNullableContextValue(this) 247738"];
13300 [label="get\n            {\n                return _moduleSymbol;\n            } 247739"];
13301 [label="return _moduleSymbol; 247740"];
13302 [label="param GetLocalNullableContextValue(this) 247741"];
13303 [label="get\n            {\n                return _assemblySymbol;\n            } 247742"];
13304 [label="return _assemblySymbol; 247743"];
13305 [label="param GetLocalNullableContextValue(this) 247744"];
13306 [label="get\n            {\n                return null;\n            } 247745"];
13307 [label="=> defaultType 247746"];
13308 [label="get\n            {\n                return false;\n            } 247747"];
13309 [label="return true; 247748"];
13310 [label="param TryGetByte(out byte? value) 247749"];
13311 [label="=> defaultType 247750"];
13312 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 247751"];
13313 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 247752"];
13314 [label="_elementNames 247753"];
13315 [label="elementNames.IsDefault 247754"];
13316 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 247755"];
13317 [label="_namesIndex 247756"];
13318 [label="_foundUsableErrorType = false; 247757"];
13319 [label="_foundUsableErrorType 247758"];
13320 [label="param DecodeType(this) 247759"];
13321 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247760"];
13322 [label="param DecodeNamedType(this) 247761"];
13323 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 247762"];
13324 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 247763"];
13325 [label="param DecodeTypeArguments(this) 247764"];
13326 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 247765"];
13327 [label="return typeArgs; 247766"];
13328 [label="type.ContainingType 247767"];
13329 [label="NamedTypeSymbol containingType = type.ContainingType; 247768"];
13330 [label="NamedTypeSymbol? decodedContainingType; 247769"];
13331 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 247770"];
13332 [label="decodedContainingType = containingType; 247771"];
13333 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247772"];
13334 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247773"];
13335 [label="var typeArgsChanged = typeArgs != decodedArgs; 247774"];
13336 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 247775"];
13337 [label="decodedType.IsTupleType 247776"];
13338 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 247777"];
13339 [label="_ 247778"];
13340 [label="tupleCardinality: out _ 247779"];
13341 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 247780"];
13342 [label="param IsTupleTypeOfCardinality(this) 247781"];
13343 [label="IsUnboundGenericType 247782"];
13344 [label="get\n            {\n                return false;\n            } 247783"];
13345 [label="return false; 247784"];
13346 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247785"];
13347 [label="ContainingSymbol 247786"];
13348 [label="get\n            {\n                return _container;\n            } 247787"];
13349 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247788"];
13350 [label=".Kind 247789"];
13351 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247790"];
13352 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247791"];
13353 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247792"];
13354 [label="ContainingNamespace 247793"];
13355 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247794"];
13356 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247795"];
13357 [label="ContainingNamespace.ContainingNamespace 247796"];
13358 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247797"];
13359 [label=".IsGlobalNamespace 247798"];
13360 [label="get\n            {\n                return false;\n            } 247799"];
13361 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247800"];
13362 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247801"];
13363 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247802"];
13364 [label="tupleCardinality = 0; 247803"];
13365 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 247804"];
13366 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 247805"];
13367 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 247806"];
13368 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 247807"];
13369 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247808"];
13370 [label="typeSymbol.IsNullableType() 247809"];
13371 [label="param IsNullableType(this TypeSymbol type) 247810"];
13372 [label="var a1 = defaultType is null; 247811"];
13373 [label="!a1 247812"];
13374 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247813"];
13375 [label="defaultType.IsNullableType() 247814"];
13376 [label="param IsNullableType(this TypeSymbol type) 247815"];
13377 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 247816"];
13378 [label="Debug.Assert(a1 || a2 != true || a3); 247817"];
13379 [label="Debug.Assert(a1 || a2 != true || a3); 247818"];
13380 [label="Debug.Assert(extensions != null); 247819"];
13381 [label="param TransformType(Symbol accessSymbol) 247820"];
13382 [label="metadataType.HasType 247821"];
13383 [label="Debug.Assert(metadataType.HasType); 247822"];
13384 [label="accessSymbol.IsDefinition 247823"];
13385 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247824"];
13386 [label="OriginalDefinition 247825"];
13387 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247826"];
13388 [label="OriginalSymbolDefinition 247827"];
13389 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247828"];
13390 [label="this.OriginalTypeSymbolDefinition 247829"];
13391 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247830"];
13392 [label="return this.OriginalTypeSymbolDefinition; 247831"];
13393 [label="return OriginalSymbolDefinition; 247832"];
13394 [label="return (object)this == (object)OriginalDefinition; 247833"];
13395 [label="Debug.Assert(accessSymbol.IsDefinition); 247834"];
13396 [label="accessSymbol.ContainingModule 247835"];
13397 [label="get\n            {\n                return ContainingPEModule;\n            } 247836"];
13398 [label="ContainingPEModule 247837"];
13399 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 247838"];
13400 [label="s.Kind 247839"];
13401 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247840"];
13402 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247841"];
13403 [label="return ContainingPEModule; 247842"];
13404 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 247843"];
13405 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247844"];
13406 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247845"];
13407 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 247846"];
13408 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 247847"];
13409 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 247848"];
13410 [label="Debug.Assert(symbol is object); 247849"];
13411 [label="symbol.Kind 247850"];
13412 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247851"];
13413 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 247852"];
13414 [label="isInternal = false; 247853"];
13415 [label="symbol.DeclaredAccessibility 247854"];
13416 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 247855"];
13417 [label="Accessibility access = Accessibility.Private; 247856"];
13418 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 247857"];
13419 [label="symbol.ContainingType 247858"];
13420 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 247859"];
13421 [label="symbol = symbol.ContainingType; 247860"];
13422 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 247861"];
13423 [label="return true; 247862"];
13424 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247863"];
13425 [label="param TryGetByte(out byte? value) 247864"];
13426 [label="=> defaultType 247865"];
13427 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 247866"];
13428 [label="return declaredInterfaces; 247867"];
13429 [label="param GetHashCode(this) 247868"];
13430 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 247869"];
13431 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 247870"];
13432 [label="s.Kind 247871"];
13433 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247872"];
13434 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247873"];
13435 [label="param Equals(TypeCompareKind compareKind) 247874"];
13436 [label="if (t2 is null)\n            {\n                return false;\n            } 247875"];
13437 [label="param Equals(TypeCompareKind comparison) 247876"];
13438 [label="param GetHashCode(this) 247877"];
13439 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 247878"];
13440 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 247879"];
13441 [label="s.Kind 247880"];
13442 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247881"];
13443 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247882"];
13444 [label="Debug.Assert((object)moduleSymbol != null); 247883"];
13445 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 247884"];
13446 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 247885"];
13447 [label="_elementNames 247886"];
13448 [label="elementNames.IsDefault 247887"];
13449 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 247888"];
13450 [label="_namesIndex 247889"];
13451 [label="_foundUsableErrorType = false; 247890"];
13452 [label="_foundUsableErrorType 247891"];
13453 [label="param DecodeType(this) 247892"];
13454 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247893"];
13455 [label="param DecodeNamedType(this) 247894"];
13456 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 247895"];
13457 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 247896"];
13458 [label="param DecodeTypeArguments(this) 247897"];
13459 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 247898"];
13460 [label="return typeArgs; 247899"];
13461 [label="type.ContainingType 247900"];
13462 [label="NamedTypeSymbol containingType = type.ContainingType; 247901"];
13463 [label="NamedTypeSymbol? decodedContainingType; 247902"];
13464 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 247903"];
13465 [label="decodedContainingType = containingType; 247904"];
13466 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247905"];
13467 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 247906"];
13468 [label="var typeArgsChanged = typeArgs != decodedArgs; 247907"];
13469 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 247908"];
13470 [label="decodedType.IsTupleType 247909"];
13471 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 247910"];
13472 [label="_ 247911"];
13473 [label="tupleCardinality: out _ 247912"];
13474 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 247913"];
13475 [label="param IsTupleTypeOfCardinality(this) 247914"];
13476 [label="IsUnboundGenericType 247915"];
13477 [label="get\n            {\n                return false;\n            } 247916"];
13478 [label="return false; 247917"];
13479 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247918"];
13480 [label="ContainingSymbol 247919"];
13481 [label="get\n            {\n                return _container;\n            } 247920"];
13482 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247921"];
13483 [label=".Kind 247922"];
13484 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247923"];
13485 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247924"];
13486 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247925"];
13487 [label="ContainingNamespace 247926"];
13488 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247927"];
13489 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247928"];
13490 [label="ContainingNamespace.ContainingNamespace 247929"];
13491 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 247930"];
13492 [label=".IsGlobalNamespace 247931"];
13493 [label="get\n            {\n                return false;\n            } 247932"];
13494 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247933"];
13495 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247934"];
13496 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 247935"];
13497 [label="tupleCardinality = 0; 247936"];
13498 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 247937"];
13499 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 247938"];
13500 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 247939"];
13501 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 247940"];
13502 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 247941"];
13503 [label="typeSymbol.IsNullableType() 247942"];
13504 [label="param IsNullableType(this TypeSymbol type) 247943"];
13505 [label="var a1 = defaultType is null; 247944"];
13506 [label="!a1 247945"];
13507 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 247946"];
13508 [label="defaultType.IsNullableType() 247947"];
13509 [label="param IsNullableType(this TypeSymbol type) 247948"];
13510 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 247949"];
13511 [label="Debug.Assert(a1 || a2 != true || a3); 247950"];
13512 [label="Debug.Assert(a1 || a2 != true || a3); 247951"];
13513 [label="Debug.Assert(extensions != null); 247952"];
13514 [label="param TransformType(Symbol accessSymbol) 247953"];
13515 [label="metadataType.HasType 247954"];
13516 [label="Debug.Assert(metadataType.HasType); 247955"];
13517 [label="accessSymbol.IsDefinition 247956"];
13518 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 247957"];
13519 [label="OriginalDefinition 247958"];
13520 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 247959"];
13521 [label="OriginalSymbolDefinition 247960"];
13522 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 247961"];
13523 [label="this.OriginalTypeSymbolDefinition 247962"];
13524 [label="get\n            {\n                return this.OriginalDefinition;\n            } 247963"];
13525 [label="return this.OriginalTypeSymbolDefinition; 247964"];
13526 [label="return OriginalSymbolDefinition; 247965"];
13527 [label="return (object)this == (object)OriginalDefinition; 247966"];
13528 [label="Debug.Assert(accessSymbol.IsDefinition); 247967"];
13529 [label="accessSymbol.ContainingModule 247968"];
13530 [label="get\n            {\n                return ContainingPEModule;\n            } 247969"];
13531 [label="ContainingPEModule 247970"];
13532 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 247971"];
13533 [label="s.Kind 247972"];
13534 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 247973"];
13535 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 247974"];
13536 [label="return ContainingPEModule; 247975"];
13537 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 247976"];
13538 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247977"];
13539 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247978"];
13540 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 247979"];
13541 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 247980"];
13542 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 247981"];
13543 [label="Debug.Assert(symbol is object); 247982"];
13544 [label="symbol.Kind 247983"];
13545 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 247984"];
13546 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 247985"];
13547 [label="isInternal = false; 247986"];
13548 [label="symbol.DeclaredAccessibility 247987"];
13549 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 247988"];
13550 [label="Accessibility access = Accessibility.Private; 247989"];
13551 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 247990"];
13552 [label="symbol.ContainingType 247991"];
13553 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 247992"];
13554 [label="symbol = symbol.ContainingType; 247993"];
13555 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 247994"];
13556 [label="return true; 247995"];
13557 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 247996"];
13558 [label="param TryGetByte(out byte? value) 247997"];
13559 [label="value = null; 247998"];
13560 [label="param GetLocalNullableContextValue(this) 247999"];
13561 [label="get\n            {\n                return _moduleSymbol;\n            } 248000"];
13562 [label="return _moduleSymbol; 248001"];
13563 [label="param GetLocalNullableContextValue(this) 248002"];
13564 [label="get\n            {\n                return _assemblySymbol;\n            } 248003"];
13565 [label="return _assemblySymbol; 248004"];
13566 [label="param GetLocalNullableContextValue(this) 248005"];
13567 [label="get\n            {\n                return null;\n            } 248006"];
13568 [label="=> defaultType 248007"];
13569 [label="Debug.Assert((object)depends != null); 248008"];
13570 [label="Debug.Assert((object)on != null); 248009"];
13571 [label="on.IsDefinition 248010"];
13572 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 248011"];
13573 [label="OriginalDefinition 248012"];
13574 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 248013"];
13575 [label="OriginalSymbolDefinition 248014"];
13576 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 248015"];
13577 [label="this.OriginalTypeSymbolDefinition 248016"];
13578 [label="get\n            {\n                return this.OriginalDefinition;\n            } 248017"];
13579 [label="return this.OriginalTypeSymbolDefinition; 248018"];
13580 [label="return OriginalSymbolDefinition; 248019"];
13581 [label="return (object)this == (object)OriginalDefinition; 248020"];
13582 [label="Debug.Assert(on.IsDefinition); 248021"];
13583 [label="depends.DeclaringCompilation 248022"];
13584 [label="get { return null; } 248023"];
13585 [label="return null; 248024"];
13586 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 248025"];
13587 [label="if ((object)type == null)\n            {\n                return;\n            } 248026"];
13588 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 248027"];
13589 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 248028"];
13590 [label="if (t2 is null)\n            {\n                return false;\n            } 248029"];
13591 [label="param Equals(TypeCompareKind comparison) 248030"];
13592 [label="param GetHashCode(this) 248031"];
13593 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 248032"];
13594 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 248033"];
13595 [label="s.Kind 248034"];
13596 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248035"];
13597 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 248036"];
13598 [label="Debug.Assert((object)moduleSymbol != null); 248037"];
13599 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 248038"];
13600 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 248039"];
13601 [label="_elementNames 248040"];
13602 [label="elementNames.IsDefault 248041"];
13603 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 248042"];
13604 [label="_namesIndex 248043"];
13605 [label="_foundUsableErrorType = false; 248044"];
13606 [label="_foundUsableErrorType 248045"];
13607 [label="param DecodeType(this) 248046"];
13608 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 248047"];
13609 [label="param DecodeNamedType(this) 248048"];
13610 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 248049"];
13611 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 248050"];
13612 [label="param DecodeTypeArguments(this) 248051"];
13613 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 248052"];
13614 [label="return typeArgs; 248053"];
13615 [label="type.ContainingType 248054"];
13616 [label="NamedTypeSymbol containingType = type.ContainingType; 248055"];
13617 [label="NamedTypeSymbol? decodedContainingType; 248056"];
13618 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 248057"];
13619 [label="decodedContainingType = containingType; 248058"];
13620 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 248059"];
13621 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 248060"];
13622 [label="var typeArgsChanged = typeArgs != decodedArgs; 248061"];
13623 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 248062"];
13624 [label="decodedType.IsTupleType 248063"];
13625 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 248064"];
13626 [label="_ 248065"];
13627 [label="tupleCardinality: out _ 248066"];
13628 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 248067"];
13629 [label="param IsTupleTypeOfCardinality(this) 248068"];
13630 [label="IsUnboundGenericType 248069"];
13631 [label="get\n            {\n                return false;\n            } 248070"];
13632 [label="return false; 248071"];
13633 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248072"];
13634 [label="ContainingSymbol 248073"];
13635 [label="get\n            {\n                return _container;\n            } 248074"];
13636 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248075"];
13637 [label=".Kind 248076"];
13638 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248077"];
13639 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248078"];
13640 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248079"];
13641 [label="ContainingNamespace 248080"];
13642 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248081"];
13643 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248082"];
13644 [label="ContainingNamespace.ContainingNamespace 248083"];
13645 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248084"];
13646 [label=".IsGlobalNamespace 248085"];
13647 [label="get\n            {\n                return false;\n            } 248086"];
13648 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248087"];
13649 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248088"];
13650 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248089"];
13651 [label="tupleCardinality = 0; 248090"];
13652 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 248091"];
13653 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 248092"];
13654 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 248093"];
13655 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 248094"];
13656 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 248095"];
13657 [label="typeSymbol.IsNullableType() 248096"];
13658 [label="param IsNullableType(this TypeSymbol type) 248097"];
13659 [label="var a1 = defaultType is null; 248098"];
13660 [label="!a1 248099"];
13661 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 248100"];
13662 [label="defaultType.IsNullableType() 248101"];
13663 [label="param IsNullableType(this TypeSymbol type) 248102"];
13664 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 248103"];
13665 [label="Debug.Assert(a1 || a2 != true || a3); 248104"];
13666 [label="Debug.Assert(a1 || a2 != true || a3); 248105"];
13667 [label="Debug.Assert(extensions != null); 248106"];
13668 [label="param TransformType(Symbol accessSymbol) 248107"];
13669 [label="metadataType.HasType 248108"];
13670 [label="Debug.Assert(metadataType.HasType); 248109"];
13671 [label="accessSymbol.IsDefinition 248110"];
13672 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 248111"];
13673 [label="OriginalDefinition 248112"];
13674 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 248113"];
13675 [label="OriginalSymbolDefinition 248114"];
13676 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 248115"];
13677 [label="this.OriginalTypeSymbolDefinition 248116"];
13678 [label="get\n            {\n                return this.OriginalDefinition;\n            } 248117"];
13679 [label="return this.OriginalTypeSymbolDefinition; 248118"];
13680 [label="return OriginalSymbolDefinition; 248119"];
13681 [label="return (object)this == (object)OriginalDefinition; 248120"];
13682 [label="Debug.Assert(accessSymbol.IsDefinition); 248121"];
13683 [label="accessSymbol.ContainingModule 248122"];
13684 [label="get\n            {\n                return ContainingPEModule;\n            } 248123"];
13685 [label="ContainingPEModule 248124"];
13686 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 248125"];
13687 [label="s.Kind 248126"];
13688 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248127"];
13689 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 248128"];
13690 [label="return ContainingPEModule; 248129"];
13691 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 248130"];
13692 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 248131"];
13693 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 248132"];
13694 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 248133"];
13695 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 248134"];
13696 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 248135"];
13697 [label="Debug.Assert(symbol is object); 248136"];
13698 [label="symbol.Kind 248137"];
13699 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 248138"];
13700 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 248139"];
13701 [label="isInternal = false; 248140"];
13702 [label="symbol.DeclaredAccessibility 248141"];
13703 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 248142"];
13704 [label="Accessibility access = Accessibility.Private; 248143"];
13705 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 248144"];
13706 [label="symbol.ContainingType 248145"];
13707 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 248146"];
13708 [label="symbol = symbol.ContainingType; 248147"];
13709 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 248148"];
13710 [label="return true; 248149"];
13711 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 248150"];
13712 [label="param TryGetByte(out byte? value) 248151"];
13713 [label="value = null; 248152"];
13714 [label="param GetLocalNullableContextValue(this) 248153"];
13715 [label="get\n            {\n                return _moduleSymbol;\n            } 248154"];
13716 [label="return _moduleSymbol; 248155"];
13717 [label="param GetLocalNullableContextValue(this) 248156"];
13718 [label="get\n            {\n                return _assemblySymbol;\n            } 248157"];
13719 [label="return _assemblySymbol; 248158"];
13720 [label="param GetLocalNullableContextValue(this) 248159"];
13721 [label="get\n            {\n                return null;\n            } 248160"];
13722 [label="=> defaultType 248161"];
13723 [label="Debug.Assert((object)depends != null); 248162"];
13724 [label="Debug.Assert((object)on != null); 248163"];
13725 [label="on.IsDefinition 248164"];
13726 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 248165"];
13727 [label="OriginalDefinition 248166"];
13728 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 248167"];
13729 [label="OriginalSymbolDefinition 248168"];
13730 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 248169"];
13731 [label="this.OriginalTypeSymbolDefinition 248170"];
13732 [label="get\n            {\n                return this.OriginalDefinition;\n            } 248171"];
13733 [label="return this.OriginalTypeSymbolDefinition; 248172"];
13734 [label="return OriginalSymbolDefinition; 248173"];
13735 [label="return (object)this == (object)OriginalDefinition; 248174"];
13736 [label="Debug.Assert(on.IsDefinition); 248175"];
13737 [label="depends.DeclaringCompilation 248176"];
13738 [label="get { return null; } 248177"];
13739 [label="return null; 248178"];
13740 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 248179"];
13741 [label="if ((object)type == null)\n            {\n                return;\n            } 248180"];
13742 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 248181"];
13743 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 248182"];
13744 [label="param GetHashCode(this) 248183"];
13745 [label="if (t2 is null)\n            {\n                return false;\n            } 248184"];
13746 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 248185"];
13747 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 248186"];
13748 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 248187"];
13749 [label="param TransformType(int targetSymbolCustomModifierCount) 248188"];
13750 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 248189"];
13751 [label="Debug.Assert((object)metadataType != null); 248190"];
13752 [label="get\n            {\n                return true;\n            } 248191"];
13753 [label="Name 248192"];
13754 [label="get\n            {\n                return _name;\n            } 248193"];
13755 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248194"];
13756 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248195"];
13757 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248196"];
13758 [label="return; 248197"];
13759 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 248198"];
13760 [label="result.ReverseContents(); 248199"];
13761 [label="return result.ToImmutableAndFree(); 248200"];
13762 [label="ImmutableInterlocked.InterlockedInitialize(ref info.allInterfaces, MakeAllInterfaces()); 248201"];
13763 [label="return info.allInterfaces; 248202"];
13764 [label="return GetAllInterfaces(); 248203"];
13765 [label="return symbol.AllInterfacesNoUseSiteDiagnostics; 248204"];
13766 [label="var sorted = sym1.AllInterfaces().OrderBy(i => i.Name).ToArray(); 248205"];
13767 [label="sym1.AllInterfaces() 248206"];
13768 [label="param AllInterfaces(this TypeSymbol symbol) 248207"];
13769 [label="symbol.AllInterfacesNoUseSiteDiagnostics 248208"];
13770 [label="get\n            {\n                return GetAllInterfaces();\n            } 248209"];
13771 [label="GetAllInterfaces() 248210"];
13772 [label="param GetAllInterfaces(this) 248211"];
13773 [label="this.GetInterfaceInfo() 248212"];
13774 [label="param GetInterfaceInfo(this) 248213"];
13775 [label="var info = _lazyInterfaceInfo; 248214"];
13776 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 248215"];
13777 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 248216"];
13778 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 248217"];
13779 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 248218"];
13780 [label="return info; 248219"];
13781 [label="if (info == s_noInterfaces)\n            {\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 248220"];
13782 [label="return info.allInterfaces; 248221"];
13783 [label="return GetAllInterfaces(); 248222"];
13784 [label="return symbol.AllInterfacesNoUseSiteDiagnostics; 248223"];
13785 [label="var sorted = sym1.AllInterfaces().OrderBy(i => i.Name).ToArray(); 248224"];
13786 [label="get\n            {\n                return _underlyingType.Name;\n            } 248225"];
13787 [label="_underlyingType.Name 248226"];
13788 [label="get\n            {\n                return _name;\n            } 248227"];
13789 [label="return _underlyingType.Name; 248228"];
13790 [label="var i1 = sorted[0] as NamedTypeSymbol; 248229"];
13791 [label="var i1 = sorted[0] as NamedTypeSymbol; 248230"];
13792 [label="var i2 = sorted[1] as NamedTypeSymbol; 248231"];
13793 [label="var i2 = sorted[1] as NamedTypeSymbol; 248232"];
13794 [label="var i3 = sorted[2] as NamedTypeSymbol; 248233"];
13795 [label="var i3 = sorted[2] as NamedTypeSymbol; 248234"];
13796 [label="var i4 = sorted[3] as NamedTypeSymbol; 248235"];
13797 [label="var i4 = sorted[3] as NamedTypeSymbol; 248236"];
13798 [label="var i5 = sorted[4] as NamedTypeSymbol; 248237"];
13799 [label="var i5 = sorted[4] as NamedTypeSymbol; 248238"];
13800 [label="var i6 = sorted[5] as NamedTypeSymbol; 248239"];
13801 [label="var i6 = sorted[5] as NamedTypeSymbol; 248240"];
13802 [label="var i7 = sorted[6] as NamedTypeSymbol; 248241"];
13803 [label="var i7 = sorted[6] as NamedTypeSymbol; 248242"];
13804 [label="var i8 = sorted[7] as NamedTypeSymbol; 248243"];
13805 [label="var i8 = sorted[7] as NamedTypeSymbol; 248244"];
13806 [label="var i9 = sorted[8] as NamedTypeSymbol; 248245"];
13807 [label="var i9 = sorted[8] as NamedTypeSymbol; 248246"];
13808 [label="CustomAssert.Equal('System.ICloneable', i1.ToTestDisplayString()); 248247"];
13809 [label="CustomAssert.Equal('System.ICloneable', i1.ToTestDisplayString()); 248248"];
13810 [label="i1.ToTestDisplayString() 248249"];
13811 [label="param ToTestDisplayString(this Symbol symbol) 248250"];
13812 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 248251"];
13813 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 248252"];
13814 [label="param ToDisplayString(SymbolDisplayFormat format = null) 248253"];
13815 [label="param ToDisplayString(this) 248254"];
13816 [label="ISymbol 248255"];
13817 [label="param CreateISymbol(this) 248256"];
13818 [label="return new PublicModel.NonErrorNamedTypeSymbol(this, DefaultNullableAnnotation); 248257"];
13819 [label="DefaultNullableAnnotation 248258"];
13820 [label="=> NullableAnnotationExtensions.ToPublicAnnotation(this, NullableAnnotation.Oblivious) 248259"];
13821 [label="this 248260"];
13822 [label="NullableAnnotation.Oblivious 248261"];
13823 [label="NullableAnnotationExtensions.ToPublicAnnotation(this, NullableAnnotation.Oblivious) 248262"];
13824 [label="param ToPublicAnnotation(TypeSymbol? type) 248263"];
13825 [label="param ToPublicAnnotation(NullableAnnotation annotation) 248264"];
13826 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 248265"];
13827 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 248266"];
13828 [label=".IsValueType 248267"];
13829 [label="get\n            {\n                var kind = TypeKind;\n                return kind == TypeKind.Struct || kind == TypeKind.Enum;\n            } 248268"];
13830 [label="TypeKind 248269"];
13831 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 248270"];
13832 [label="var kind = TypeKind; 248271"];
13833 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 248272"];
13834 [label="return annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            }; 248273"];
13835 [label="return annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            }; 248274"];
13836 [label="return annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            }; 248275"];
13837 [label="return new PublicModel.NonErrorNamedTypeSymbol(this, DefaultNullableAnnotation); 248276"];
13838 [label="return new PublicModel.NonErrorNamedTypeSymbol(this, DefaultNullableAnnotation); 248277"];
13839 [label="new PublicModel.NonErrorNamedTypeSymbol(this, DefaultNullableAnnotation) 248278"];
13840 [label="param NonErrorNamedTypeSymbol(Symbols.NamedTypeSymbol underlying) 248279"];
13841 [label="param NonErrorNamedTypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation) 248280"];
13842 [label="param NonErrorNamedTypeSymbol(this) 248281"];
13843 [label="nullableAnnotation 248282"];
13844 [label="param NonErrorNamedTypeSymbol(this) 248283"];
13845 [label="param NamedTypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation = CodeAnalysis.NullableAnnotation.None) 248284"];
13846 [label="param NamedTypeSymbol(this) 248285"];
13847 [label="nullableAnnotation 248286"];
13848 [label="param NamedTypeSymbol(this) 248287"];
13849 [label="param TypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation) 248288"];
13850 [label="param TypeSymbol(this) 248289"];
13851 [label="param TypeSymbol(this) 248290"];
13852 [label="param NamespaceOrTypeSymbol(this) 248291"];
13853 [label="param NamespaceOrTypeSymbol(this) 248292"];
13854 [label="param Symbol(this) 248293"];
13855 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 248294"];
13856 [label="NullableAnnotation 248295"];
13857 [label="_underlying 248296"];
13858 [label="Debug.Assert(underlying is object); 248297"];
13859 [label="Debug.Assert(!underlying.IsErrorType()); 248298"];
13860 [label="underlying.IsErrorType() 248299"];
13861 [label="param IsErrorType(this TypeSymbol type) 248300"];
13862 [label="RoslynDebug.Assert((object)type != null); 248301"];
13863 [label="RoslynDebug.Assert((object)type != null); 248302"];
13864 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 248303"];
13865 [label="Debug.Assert(!underlying.IsErrorType()); 248304"];
13866 [label="_underlying 248305"];
13867 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 248306"];
13868 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 248307"];
13869 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 248308"];
13870 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 248309"];
13871 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 248310"];
13872 [label="ToDisplayParts(symbol, format) 248311"];
13873 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 248312"];
13874 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 248313"];
13875 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 248314"];
13876 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 248315"];
13877 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 248316"];
13878 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 248317"];
13879 [label="param ToDisplayParts(int positionOpt) 248318"];
13880 [label="param ToDisplayParts(SymbolDisplayFormat format) 248319"];
13881 [label="param ToDisplayParts(bool minimal) 248320"];
13882 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 248321"];
13883 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 248322"];
13884 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 248323"];
13885 [label="Debug.Assert(semanticModelOpt == null); 248324"];
13886 [label="Debug.Assert(semanticModelOpt == null); 248325"];
13887 [label="Debug.Assert(positionOpt < 0); 248326"];
13888 [label="Debug.Assert(positionOpt < 0); 248327"];
13889 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 248328"];
13890 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 248329"];
13891 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248330"];
13892 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248331"];
13893 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248332"];
13894 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248333"];
13895 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248334"];
13896 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 248335"];
13897 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 248336"];
13898 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 248337"];
13899 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 248338"];
13900 [label="param SymbolDisplayVisitor(int positionOpt) 248339"];
13901 [label="param SymbolDisplayVisitor(this) 248340"];
13902 [label="builder 248341"];
13903 [label="format 248342"];
13904 [label="true 248343"];
13905 [label="semanticModelOpt 248344"];
13906 [label="positionOpt 248345"];
13907 [label="param SymbolDisplayVisitor(this) 248346"];
13908 [label="param SymbolDisplayVisitor(this) 248347"];
13909 [label="_escapeKeywordIdentifiers 248348"];
13910 [label="_lazyAliasMap 248349"];
13911 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 248350"];
13912 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 248351"];
13913 [label="_escapeKeywordIdentifiers 248352"];
13914 [label="symbol.Accept(visitor); 248353"];
13915 [label="symbol.Accept(visitor) 248354"];
13916 [label="param Accept(SymbolVisitor visitor) 248355"];
13917 [label="Accept(visitor); 248356"];
13918 [label="Accept(visitor) 248357"];
13919 [label="param Accept(SymbolVisitor visitor) 248358"];
13920 [label="param Accept(this) 248359"];
13921 [label="visitor.VisitNamedType(this); 248360"];
13922 [label="visitor.VisitNamedType(this) 248361"];
13923 [label="param VisitNamedType(INamedTypeSymbol symbol) 248362"];
13924 [label="param VisitNamedType(this) 248363"];
13925 [label="VisitNamedTypeWithoutNullability(symbol); 248364"];
13926 [label="VisitNamedTypeWithoutNullability(symbol) 248365"];
13927 [label="param VisitNamedTypeWithoutNullability(INamedTypeSymbol symbol) 248366"];
13928 [label="param VisitNamedTypeWithoutNullability(this) 248367"];
13929 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 248368"];
13930 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248369"];
13931 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248370"];
13932 [label="symbol.IsNativeIntegerType 248371"];
13933 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 248372"];
13934 [label="UnderlyingTypeSymbol 248373"];
13935 [label="=> _underlying 248374"];
13936 [label="_underlying 248375"];
13937 [label="UnderlyingTypeSymbol.IsNativeIntegerType 248376"];
13938 [label="=> false 248377"];
13939 [label="false 248378"];
13940 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248379"];
13941 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248380"];
13942 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 248381"];
13943 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 248382"];
13944 [label="if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                } 248383"];
13945 [label="if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                } 248384"];
13946 [label="get\n            {\n                return UnderlyingTypeSymbol.OriginalDefinition.GetPublicSymbol();\n            } 248385"];
13947 [label="UnderlyingTypeSymbol 248386"];
13948 [label="=> _underlying 248387"];
13949 [label="_underlying 248388"];
13950 [label="return UnderlyingTypeSymbol.OriginalDefinition.GetPublicSymbol(); 248389"];
13951 [label="UnderlyingTypeSymbol.OriginalDefinition 248390"];
13952 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 248391"];
13953 [label="OriginalTypeSymbolDefinition 248392"];
13954 [label="this.OriginalDefinition 248393"];
13955 [label="UnderlyingTypeSymbol.OriginalDefinition.GetPublicSymbol() 248394"];
13956 [label="param GetPublicSymbol(this TypeSymbol? symbol) 248395"];
13957 [label="return symbol.GetPublicSymbol<ITypeSymbol>(); 248396"];
13958 [label="symbol.GetPublicSymbol<ITypeSymbol>() 248397"];
13959 [label="param GetPublicSymbol(this Symbol? symbol) 248398"];
13960 [label=".ISymbol 248399"];
13961 [label="=> UnderlyingTypeSymbol.SpecialType 248400"];
13962 [label="UnderlyingTypeSymbol 248401"];
13963 [label="=> _underlying 248402"];
13964 [label="_underlying 248403"];
13965 [label="UnderlyingTypeSymbol.SpecialType 248404"];
13966 [label="get\n            {\n                return _corTypeId;\n            } 248405"];
13967 [label="symbol.IsTupleType 248406"];
13968 [label="=> UnderlyingTypeSymbol.IsTupleType 248407"];
13969 [label="UnderlyingTypeSymbol 248408"];
13970 [label="=> _underlying 248409"];
13971 [label="_underlying 248410"];
13972 [label="UnderlyingTypeSymbol.IsTupleType 248411"];
13973 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 248412"];
13974 [label="_ 248413"];
13975 [label="tupleCardinality: out _ 248414"];
13976 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 248415"];
13977 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 248416"];
13978 [label="param IsTupleTypeOfCardinality(this) 248417"];
13979 [label="IsUnboundGenericType 248418"];
13980 [label="get\n            {\n                return false;\n            } 248419"];
13981 [label="return false; 248420"];
13982 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248421"];
13983 [label="ContainingSymbol 248422"];
13984 [label="get\n            {\n                return _container;\n            } 248423"];
13985 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248424"];
13986 [label=".Kind 248425"];
13987 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248426"];
13988 [label="return SymbolKind.Namespace; 248427"];
13989 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248428"];
13990 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248429"];
13991 [label="ContainingNamespace 248430"];
13992 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248431"];
13993 [label="this.ContainingSymbol 248432"];
13994 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248433"];
13995 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248434"];
13996 [label="ContainingNamespace.ContainingNamespace 248435"];
13997 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248436"];
13998 [label="this.ContainingSymbol 248437"];
13999 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248438"];
14000 [label=".IsGlobalNamespace 248439"];
14001 [label="get\n            {\n                return true;\n            } 248440"];
14002 [label="return true; 248441"];
14003 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248442"];
14004 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248443"];
14005 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248444"];
14006 [label="Name 248445"];
14007 [label="get\n            {\n                return _name;\n            } 248446"];
14008 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248447"];
14009 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248448"];
14010 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248449"];
14011 [label="tupleCardinality = 0; 248450"];
14012 [label="return false; 248451"];
14013 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 248452"];
14014 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 248453"];
14015 [label="AddTypeKind(symbol); 248454"];
14016 [label="AddTypeKind(symbol) 248455"];
14017 [label="param AddTypeKind(INamedTypeSymbol symbol) 248456"];
14018 [label="param AddTypeKind(this) 248457"];
14019 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 248458"];
14020 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 248459"];
14021 [label="AddTypeKind(symbol); 248460"];
14022 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 248461"];
14023 [label="CanShowDelegateSignature(symbol) 248462"];
14024 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 248463"];
14025 [label="param CanShowDelegateSignature(this) 248464"];
14026 [label="symbol.TypeKind 248465"];
14027 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 248466"];
14028 [label="UnderlyingTypeSymbol 248467"];
14029 [label="=> _underlying 248468"];
14030 [label="_underlying 248469"];
14031 [label="return UnderlyingTypeSymbol.TypeKind; 248470"];
14032 [label="UnderlyingTypeSymbol.TypeKind 248471"];
14033 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 248472"];
14034 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248473"];
14035 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248474"];
14036 [label="symbol.ContainingSymbol 248475"];
14037 [label="get\n            {\n                return UnderlyingSymbol.ContainingSymbol.GetPublicSymbol();\n            } 248476"];
14038 [label="UnderlyingSymbol 248477"];
14039 [label="=> _underlying 248478"];
14040 [label="_underlying 248479"];
14041 [label="return UnderlyingSymbol.ContainingSymbol.GetPublicSymbol(); 248480"];
14042 [label="UnderlyingSymbol.ContainingSymbol 248481"];
14043 [label="get\n            {\n                return _container;\n            } 248482"];
14044 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 248483"];
14045 [label="param GetPublicSymbol(this Symbol? symbol) 248484"];
14046 [label="return symbol.GetPublicSymbol<ISymbol>(); 248485"];
14047 [label="symbol.GetPublicSymbol<ISymbol>() 248486"];
14048 [label="param GetPublicSymbol(this Symbol? symbol) 248487"];
14049 [label=".ISymbol 248488"];
14050 [label="var containingSymbol = symbol.ContainingSymbol; 248489"];
14051 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 248490"];
14052 [label="ShouldVisitNamespace(containingSymbol) 248491"];
14053 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 248492"];
14054 [label="param ShouldVisitNamespace(this) 248493"];
14055 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 248494"];
14056 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248495"];
14057 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248496"];
14058 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 248497"];
14059 [label="namespaceSymbol.IsGlobalNamespace 248498"];
14060 [label="=> _underlying.IsGlobalNamespace 248499"];
14061 [label="_underlying.IsGlobalNamespace 248500"];
14062 [label="get\n            {\n                return false;\n            } 248501"];
14063 [label="return false; 248502"];
14064 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 248503"];
14065 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 248504"];
14066 [label="var namespaceSymbol = (INamespaceSymbol)containingSymbol; 248505"];
14067 [label="namespaceSymbol.IsGlobalNamespace 248506"];
14068 [label="=> _underlying.IsGlobalNamespace 248507"];
14069 [label="get\n            {\n                return false;\n            } 248508"];
14070 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 248509"];
14071 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 248510"];
14072 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 248511"];
14073 [label="this.NotFirstVisitor 248512"];
14074 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 248513"];
14075 [label="param MakeNotFirstVisitor(this) 248514"];
14076 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 248515"];
14077 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 248516"];
14078 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 248517"];
14079 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 248518"];
14080 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 248519"];
14081 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 248520"];
14082 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 248521"];
14083 [label="param SymbolDisplayVisitor(int positionOpt) 248522"];
14084 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 248523"];
14085 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 248524"];
14086 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 248525"];
14087 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 248526"];
14088 [label="param SymbolDisplayVisitor(this) 248527"];
14089 [label="builder 248528"];
14090 [label="format 248529"];
14091 [label="isFirstSymbolVisited 248530"];
14092 [label="semanticModelOpt 248531"];
14093 [label="positionOpt 248532"];
14094 [label="inNamespaceOrType 248533"];
14095 [label="param SymbolDisplayVisitor(this) 248534"];
14096 [label="param SymbolDisplayVisitor(this) 248535"];
14097 [label="_escapeKeywordIdentifiers 248536"];
14098 [label="_lazyAliasMap 248537"];
14099 [label="_escapeKeywordIdentifiers 248538"];
14100 [label="_lazyAliasMap 248539"];
14101 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 248540"];
14102 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 248541"];
14103 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 248542"];
14104 [label="param Accept(SymbolVisitor visitor) 248543"];
14105 [label="param Accept(this) 248544"];
14106 [label="param Accept(SymbolVisitor visitor) 248545"];
14107 [label="visitor.VisitNamespace(this) 248546"];
14108 [label="param VisitNamespace(this) 248547"];
14109 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 248548"];
14110 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 248549"];
14111 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 248550"];
14112 [label="symbol.ContainingNamespace 248551"];
14113 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 248552"];
14114 [label="UnderlyingSymbol 248553"];
14115 [label="UnderlyingSymbol.ContainingNamespace 248554"];
14116 [label="this.ContainingSymbol 248555"];
14117 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248556"];
14118 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 248557"];
14119 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 248558"];
14120 [label=".ISymbol 248559"];
14121 [label="ShouldVisitNamespace(containingNamespace) 248560"];
14122 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 248561"];
14123 [label="param ShouldVisitNamespace(this) 248562"];
14124 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 248563"];
14125 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248564"];
14126 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248565"];
14127 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 248566"];
14128 [label="=> _underlying.IsGlobalNamespace 248567"];
14129 [label="get\n            {\n                return true;\n            } 248568"];
14130 [label="return true; 248569"];
14131 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 248570"];
14132 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 248571"];
14133 [label="symbol.IsGlobalNamespace 248572"];
14134 [label="=> _underlying.IsGlobalNamespace 248573"];
14135 [label="get\n            {\n                return false;\n            } 248574"];
14136 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 248575"];
14137 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 248576"];
14138 [label="symbol.Name 248577"];
14139 [label="UnderlyingSymbol 248578"];
14140 [label="UnderlyingSymbol.Name 248579"];
14141 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 248580"];
14142 [label="param CreatePart(SymbolDisplayPartKind kind) 248581"];
14143 [label="param CreatePart(this) 248582"];
14144 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 248583"];
14145 [label="IsEscapable(kind) 248584"];
14146 [label="param IsEscapable(SymbolDisplayPartKind kind) 248585"];
14147 [label="switch (kind)\n            {\n                case SymbolDisplayPartKind.AliasName:\n                case SymbolDisplayPartKind.ClassName:\n                case SymbolDisplayPartKind.RecordClassName:\n                case SymbolDisplayPartKind.StructName:\n                case SymbolDisplayPartKind.InterfaceName:\n                case SymbolDisplayPartKind.EnumName:\n                case SymbolDisplayPartKind.DelegateName:\n                case SymbolDisplayPartKind.TypeParameterName:\n                case SymbolDisplayPartKind.MethodName:\n                case SymbolDisplayPartKind.PropertyName:\n                case SymbolDisplayPartKind.FieldName:\n                case SymbolDisplayPartKind.LocalName:\n                case SymbolDisplayPartKind.NamespaceName:\n                case SymbolDisplayPartKind.ParameterName:\n                    return true;\n                default:\n                    return false;\n            } 248586"];
14148 [label="return true; 248587"];
14149 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 248588"];
14150 [label="EscapeIdentifier(text) 248589"];
14151 [label="param EscapeIdentifier(string identifier) 248590"];
14152 [label="var kind = SyntaxFacts.GetKeywordKind(identifier); 248591"];
14153 [label="return kind == SyntaxKind.None\n                ? identifier\n                : $'@{identifier}'; 248592"];
14154 [label="kind == SyntaxKind.None 248593"];
14155 [label="return new SymbolDisplayPart(kind, symbol, text); 248594"];
14156 [label="visitor.VisitNamespace(this); 248595"];
14157 [label="Accept(visitor); 248596"];
14158 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 248597"];
14159 [label="namespaceSymbol.IsGlobalNamespace 248598"];
14160 [label="=> _underlying.IsGlobalNamespace 248599"];
14161 [label="get\n            {\n                return false;\n            } 248600"];
14162 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 248601"];
14163 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 248602"];
14164 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 248603"];
14165 [label="param AddPunctuation(SyntaxKind punctuationKind) 248604"];
14166 [label="param AddPunctuation(this) 248605"];
14167 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 248606"];
14168 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 248607"];
14169 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 248608"];
14170 [label="param CreatePart(SymbolDisplayPartKind kind) 248609"];
14171 [label="param CreatePart(ISymbol symbol) 248610"];
14172 [label="param CreatePart(this) 248611"];
14173 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 248612"];
14174 [label="IsEscapable(kind) 248613"];
14175 [label="param IsEscapable(SymbolDisplayPartKind kind) 248614"];
14176 [label="switch (kind)\n            {\n                case SymbolDisplayPartKind.AliasName:\n                case SymbolDisplayPartKind.ClassName:\n                case SymbolDisplayPartKind.RecordClassName:\n                case SymbolDisplayPartKind.StructName:\n                case SymbolDisplayPartKind.InterfaceName:\n                case SymbolDisplayPartKind.EnumName:\n                case SymbolDisplayPartKind.DelegateName:\n                case SymbolDisplayPartKind.TypeParameterName:\n                case SymbolDisplayPartKind.MethodName:\n                case SymbolDisplayPartKind.PropertyName:\n                case SymbolDisplayPartKind.FieldName:\n                case SymbolDisplayPartKind.LocalName:\n                case SymbolDisplayPartKind.NamespaceName:\n                case SymbolDisplayPartKind.ParameterName:\n                    return true;\n                default:\n                    return false;\n            } 248615"];
14177 [label="return false; 248616"];
14178 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 248617"];
14179 [label="return new SymbolDisplayPart(kind, symbol, text); 248618"];
14180 [label="return new SymbolDisplayPart(kind, symbol, text); 248619"];
14181 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 248620"];
14182 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 248621"];
14183 [label="symbol.ContainingType 248622"];
14184 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 248623"];
14185 [label="UnderlyingSymbol 248624"];
14186 [label="=> _underlying 248625"];
14187 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 248626"];
14188 [label="UnderlyingSymbol.ContainingType 248627"];
14189 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 248628"];
14190 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 248629"];
14191 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 248630"];
14192 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 248631"];
14193 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 248632"];
14194 [label="param GetPublicSymbol(this Symbol? symbol) 248633"];
14195 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 248634"];
14196 [label="IncludeNamedType(symbol.ContainingType) 248635"];
14197 [label="param IncludeNamedType(INamedTypeSymbol namedType) 248636"];
14198 [label="param IncludeNamedType(this) 248637"];
14199 [label="if (namedType is null)\n            {\n                return false;\n            } 248638"];
14200 [label="return false; 248639"];
14201 [label="AddNameAndTypeArgumentsOrParameters(symbol); 248640"];
14202 [label="AddNameAndTypeArgumentsOrParameters(symbol) 248641"];
14203 [label="param AddNameAndTypeArgumentsOrParameters(INamedTypeSymbol symbol) 248642"];
14204 [label="param AddNameAndTypeArgumentsOrParameters(this) 248643"];
14205 [label="symbol.IsAnonymousType 248644"];
14206 [label="=> UnderlyingTypeSymbol.IsAnonymousType 248645"];
14207 [label="UnderlyingTypeSymbol 248646"];
14208 [label="=> _underlying 248647"];
14209 [label="_underlying 248648"];
14210 [label="UnderlyingTypeSymbol.IsAnonymousType 248649"];
14211 [label="get\n            {\n                return false;\n            } 248650"];
14212 [label="return false; 248651"];
14213 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 248652"];
14214 [label="symbol.IsTupleType 248653"];
14215 [label="=> UnderlyingTypeSymbol.IsTupleType 248654"];
14216 [label="UnderlyingTypeSymbol 248655"];
14217 [label="=> _underlying 248656"];
14218 [label="_underlying 248657"];
14219 [label="UnderlyingTypeSymbol.IsTupleType 248658"];
14220 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 248659"];
14221 [label="_ 248660"];
14222 [label="tupleCardinality: out _ 248661"];
14223 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 248662"];
14224 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 248663"];
14225 [label="param IsTupleTypeOfCardinality(this) 248664"];
14226 [label="IsUnboundGenericType 248665"];
14227 [label="get\n            {\n                return false;\n            } 248666"];
14228 [label="return false; 248667"];
14229 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248668"];
14230 [label="ContainingSymbol 248669"];
14231 [label="get\n            {\n                return _container;\n            } 248670"];
14232 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248671"];
14233 [label=".Kind 248672"];
14234 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248673"];
14235 [label="return SymbolKind.Namespace; 248674"];
14236 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248675"];
14237 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248676"];
14238 [label="ContainingNamespace 248677"];
14239 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248678"];
14240 [label="this.ContainingSymbol 248679"];
14241 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248680"];
14242 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248681"];
14243 [label="ContainingNamespace.ContainingNamespace 248682"];
14244 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248683"];
14245 [label="this.ContainingSymbol 248684"];
14246 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248685"];
14247 [label=".IsGlobalNamespace 248686"];
14248 [label="get\n            {\n                return true;\n            } 248687"];
14249 [label="return true; 248688"];
14250 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248689"];
14251 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248690"];
14252 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248691"];
14253 [label="Name 248692"];
14254 [label="get\n            {\n                return _name;\n            } 248693"];
14255 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248694"];
14256 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248695"];
14257 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248696"];
14258 [label="tupleCardinality = 0; 248697"];
14259 [label="return false; 248698"];
14260 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 248699"];
14261 [label="string symbolName = null; 248700"];
14262 [label="(symbol is Symbols.PublicModel.NamedTypeSymbol) 248701"];
14263 [label="((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol 248702"];
14264 [label="=> _underlying 248703"];
14265 [label="_underlying 248704"];
14266 [label="NamedTypeSymbol underlyingTypeSymbol = (symbol is Symbols.PublicModel.NamedTypeSymbol) ? ((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol : null; 248705"];
14267 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 248706"];
14268 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 248707"];
14269 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 248708"];
14270 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 248709"];
14271 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 248710"];
14272 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 248711"];
14273 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 248712"];
14274 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 248713"];
14275 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 248714"];
14276 [label="var partKind = GetPartKind(symbol); 248715"];
14277 [label="GetPartKind(symbol) 248716"];
14278 [label="param GetPartKind(INamedTypeSymbol symbol) 248717"];
14279 [label="symbol.TypeKind 248718"];
14280 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 248719"];
14281 [label="UnderlyingTypeSymbol 248720"];
14282 [label="=> _underlying 248721"];
14283 [label="_underlying 248722"];
14284 [label="return UnderlyingTypeSymbol.TypeKind; 248723"];
14285 [label="UnderlyingTypeSymbol.TypeKind 248724"];
14286 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 248725"];
14287 [label="switch (symbol.TypeKind)\n            {\n                case TypeKind.Class when symbol.IsRecord:\n                    return SymbolDisplayPartKind.RecordClassName;\n                case TypeKind.Submission:\n                case TypeKind.Module:\n                case TypeKind.Class:\n                    return SymbolDisplayPartKind.ClassName;\n                case TypeKind.Delegate:\n                    return SymbolDisplayPartKind.DelegateName;\n                case TypeKind.Enum:\n                    return SymbolDisplayPartKind.EnumName;\n                case TypeKind.Error:\n                    return SymbolDisplayPartKind.ErrorTypeName;\n                case TypeKind.Interface:\n                    return SymbolDisplayPartKind.InterfaceName;\n                case TypeKind.Struct:\n                    return SymbolDisplayPartKind.StructName;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.TypeKind);\n            } 248726"];
14288 [label="return SymbolDisplayPartKind.InterfaceName; 248727"];
14289 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 248728"];
14290 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 248729"];
14291 [label="symbol.Name 248730"];
14292 [label="=> UnderlyingSymbol.Name 248731"];
14293 [label="UnderlyingSymbol 248732"];
14294 [label="=> _underlying 248733"];
14295 [label="_underlying 248734"];
14296 [label="UnderlyingSymbol.Name 248735"];
14297 [label="symbolName = symbol.Name; 248736"];
14298 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 248737"];
14299 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 248738"];
14300 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 248739"];
14301 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 248740"];
14302 [label="symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName); 248741"];
14303 [label="symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName); 248742"];
14304 [label="RemoveAttributeSufficeIfNecessary(symbol, symbolName) 248743"];
14305 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 248744"];
14306 [label="param RemoveAttributeSufficeIfNecessary(string symbolName) 248745"];
14307 [label="param RemoveAttributeSufficeIfNecessary(this) 248746"];
14308 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 248747"];
14309 [label="return symbolName; 248748"];
14310 [label="builder.Add(CreatePart(partKind, symbol, symbolName)); 248749"];
14311 [label="builder.Add(CreatePart(partKind, symbol, symbolName)); 248750"];
14312 [label="builder.Add(CreatePart(partKind, symbol, symbolName)); 248751"];
14313 [label="CreatePart(partKind, symbol, symbolName) 248752"];
14314 [label="param CreatePart(SymbolDisplayPartKind kind) 248753"];
14315 [label="param CreatePart(ISymbol symbol) 248754"];
14316 [label="param CreatePart(string text) 248755"];
14317 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 248756"];
14318 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 248757"];
14319 [label="symbol.Arity 248758"];
14320 [label="get\n            {\n                return UnderlyingNamedTypeSymbol.Arity;\n            } 248759"];
14321 [label="UnderlyingNamedTypeSymbol 248760"];
14322 [label="=> _underlying 248761"];
14323 [label="_underlying 248762"];
14324 [label="return UnderlyingNamedTypeSymbol.Arity; 248763"];
14325 [label="UnderlyingNamedTypeSymbol.Arity 248764"];
14326 [label="get\n                {\n                    return 0;\n                } 248765"];
14327 [label="return UnderlyingNamedTypeSymbol.Arity; 248766"];
14328 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 248767"];
14329 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 248768"];
14330 [label="AddDelegateParameters(symbol); 248769"];
14331 [label="AddDelegateParameters(symbol) 248770"];
14332 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 248771"];
14333 [label="param AddDelegateParameters(this) 248772"];
14334 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 248773"];
14335 [label="CanShowDelegateSignature(symbol) 248774"];
14336 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 248775"];
14337 [label="param CanShowDelegateSignature(this) 248776"];
14338 [label="symbol.TypeKind 248777"];
14339 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 248778"];
14340 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248779"];
14341 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248780"];
14342 [label="AddDelegateParameters(symbol); 248781"];
14343 [label=".OriginalDefinition 248782"];
14344 [label="get\n            {\n                return this;\n            } 248783"];
14345 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 248784"];
14346 [label="AddNameAndTypeArgumentsOrParameters(symbol); 248785"];
14347 [label="VisitNamedTypeWithoutNullability(symbol); 248786"];
14348 [label="AddNullableAnnotations(symbol); 248787"];
14349 [label="AddNullableAnnotations(symbol) 248788"];
14350 [label="param AddNullableAnnotations(ITypeSymbol type) 248789"];
14351 [label="param AddNullableAnnotations(this) 248790"];
14352 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 248791"];
14353 [label="ShouldAddNullableAnnotation(type) 248792"];
14354 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 248793"];
14355 [label="param ShouldAddNullableAnnotation(this) 248794"];
14356 [label="type.NullableAnnotation 248795"];
14357 [label="=> NullableAnnotation 248796"];
14358 [label="NullableAnnotation 248797"];
14359 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 248798"];
14360 [label="return false; 248799"];
14361 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 248800"];
14362 [label="AddNullableAnnotations(symbol); 248801"];
14363 [label="visitor.VisitNamedType(this); 248802"];
14364 [label="Accept(visitor); 248803"];
14365 [label="symbol.Accept(visitor); 248804"];
14366 [label="CustomAssert.Equal('System.Collections.ICollection', i2.ToTestDisplayString()); 248805"];
14367 [label="CustomAssert.Equal('System.Collections.ICollection', i2.ToTestDisplayString()); 248806"];
14368 [label="i2.ToTestDisplayString() 248807"];
14369 [label="param ToTestDisplayString(this Symbol symbol) 248808"];
14370 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 248809"];
14371 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 248810"];
14372 [label="param ToDisplayString(SymbolDisplayFormat format = null) 248811"];
14373 [label="param ToDisplayString(this) 248812"];
14374 [label="ISymbol 248813"];
14375 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 248814"];
14376 [label="NullableAnnotation.Oblivious 248815"];
14377 [label="param ToPublicAnnotation(NullableAnnotation annotation) 248816"];
14378 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 248817"];
14379 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 248818"];
14380 [label="var kind = TypeKind; 248819"];
14381 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 248820"];
14382 [label="param NamespaceOrTypeSymbol(this) 248821"];
14383 [label="param Symbol(this) 248822"];
14384 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 248823"];
14385 [label="_underlying 248824"];
14386 [label="Debug.Assert(underlying is object); 248825"];
14387 [label="Debug.Assert(!underlying.IsErrorType()); 248826"];
14388 [label="underlying.IsErrorType() 248827"];
14389 [label="param IsErrorType(this TypeSymbol type) 248828"];
14390 [label="RoslynDebug.Assert((object)type != null); 248829"];
14391 [label="RoslynDebug.Assert((object)type != null); 248830"];
14392 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 248831"];
14393 [label="Debug.Assert(!underlying.IsErrorType()); 248832"];
14394 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 248833"];
14395 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 248834"];
14396 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 248835"];
14397 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 248836"];
14398 [label="ToDisplayParts(symbol, format) 248837"];
14399 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 248838"];
14400 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 248839"];
14401 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 248840"];
14402 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 248841"];
14403 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 248842"];
14404 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 248843"];
14405 [label="param ToDisplayParts(int positionOpt) 248844"];
14406 [label="param ToDisplayParts(SymbolDisplayFormat format) 248845"];
14407 [label="param ToDisplayParts(bool minimal) 248846"];
14408 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 248847"];
14409 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 248848"];
14410 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 248849"];
14411 [label="Debug.Assert(semanticModelOpt == null); 248850"];
14412 [label="Debug.Assert(semanticModelOpt == null); 248851"];
14413 [label="Debug.Assert(positionOpt < 0); 248852"];
14414 [label="Debug.Assert(positionOpt < 0); 248853"];
14415 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 248854"];
14416 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 248855"];
14417 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248856"];
14418 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248857"];
14419 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248858"];
14420 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248859"];
14421 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 248860"];
14422 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 248861"];
14423 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 248862"];
14424 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 248863"];
14425 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 248864"];
14426 [label="param SymbolDisplayVisitor(int positionOpt) 248865"];
14427 [label="param SymbolDisplayVisitor(this) 248866"];
14428 [label="builder 248867"];
14429 [label="format 248868"];
14430 [label="true 248869"];
14431 [label="semanticModelOpt 248870"];
14432 [label="positionOpt 248871"];
14433 [label="param SymbolDisplayVisitor(this) 248872"];
14434 [label="_escapeKeywordIdentifiers 248873"];
14435 [label="_lazyAliasMap 248874"];
14436 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 248875"];
14437 [label="symbol.Accept(visitor); 248876"];
14438 [label="symbol.Accept(visitor) 248877"];
14439 [label="param Accept(SymbolVisitor visitor) 248878"];
14440 [label="Accept(visitor); 248879"];
14441 [label="Accept(visitor) 248880"];
14442 [label="param Accept(SymbolVisitor visitor) 248881"];
14443 [label="visitor.VisitNamedType(this) 248882"];
14444 [label="param VisitNamedType(this) 248883"];
14445 [label="VisitNamedTypeWithoutNullability(symbol) 248884"];
14446 [label="param VisitNamedTypeWithoutNullability(this) 248885"];
14447 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 248886"];
14448 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248887"];
14449 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248888"];
14450 [label="symbol.IsNativeIntegerType 248889"];
14451 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 248890"];
14452 [label="UnderlyingTypeSymbol 248891"];
14453 [label="=> _underlying 248892"];
14454 [label="UnderlyingTypeSymbol.IsNativeIntegerType 248893"];
14455 [label="=> false 248894"];
14456 [label="false 248895"];
14457 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248896"];
14458 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 248897"];
14459 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 248898"];
14460 [label="symbol.IsTupleType 248899"];
14461 [label="=> UnderlyingTypeSymbol.IsTupleType 248900"];
14462 [label="UnderlyingTypeSymbol 248901"];
14463 [label="=> _underlying 248902"];
14464 [label="UnderlyingTypeSymbol.IsTupleType 248903"];
14465 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 248904"];
14466 [label="_ 248905"];
14467 [label="tupleCardinality: out _ 248906"];
14468 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 248907"];
14469 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 248908"];
14470 [label="param IsTupleTypeOfCardinality(this) 248909"];
14471 [label="IsUnboundGenericType 248910"];
14472 [label="get\n            {\n                return false;\n            } 248911"];
14473 [label="return false; 248912"];
14474 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248913"];
14475 [label="ContainingSymbol 248914"];
14476 [label="get\n            {\n                return _container;\n            } 248915"];
14477 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248916"];
14478 [label=".Kind 248917"];
14479 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 248918"];
14480 [label="return SymbolKind.Namespace; 248919"];
14481 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248920"];
14482 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248921"];
14483 [label="ContainingNamespace 248922"];
14484 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248923"];
14485 [label="this.ContainingSymbol 248924"];
14486 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248925"];
14487 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248926"];
14488 [label="ContainingNamespace.ContainingNamespace 248927"];
14489 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 248928"];
14490 [label="this.ContainingSymbol 248929"];
14491 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 248930"];
14492 [label=".IsGlobalNamespace 248931"];
14493 [label="get\n            {\n                return false;\n            } 248932"];
14494 [label="return false; 248933"];
14495 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248934"];
14496 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248935"];
14497 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 248936"];
14498 [label="tupleCardinality = 0; 248937"];
14499 [label="return false; 248938"];
14500 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 248939"];
14501 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 248940"];
14502 [label="AddTypeKind(symbol); 248941"];
14503 [label="AddTypeKind(symbol) 248942"];
14504 [label="param AddTypeKind(INamedTypeSymbol symbol) 248943"];
14505 [label="param AddTypeKind(this) 248944"];
14506 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 248945"];
14507 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 248946"];
14508 [label="AddTypeKind(symbol); 248947"];
14509 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 248948"];
14510 [label="CanShowDelegateSignature(symbol) 248949"];
14511 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 248950"];
14512 [label="param CanShowDelegateSignature(this) 248951"];
14513 [label="symbol.TypeKind 248952"];
14514 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 248953"];
14515 [label="UnderlyingTypeSymbol 248954"];
14516 [label="UnderlyingTypeSymbol.TypeKind 248955"];
14517 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248956"];
14518 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 248957"];
14519 [label="symbol.ContainingSymbol 248958"];
14520 [label="UnderlyingSymbol 248959"];
14521 [label="UnderlyingSymbol.ContainingSymbol 248960"];
14522 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 248961"];
14523 [label="symbol.GetPublicSymbol<ISymbol>() 248962"];
14524 [label=".ISymbol 248963"];
14525 [label="ShouldVisitNamespace(containingSymbol) 248964"];
14526 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 248965"];
14527 [label="param ShouldVisitNamespace(this) 248966"];
14528 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 248967"];
14529 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248968"];
14530 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 248969"];
14531 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 248970"];
14532 [label="namespaceSymbol.IsGlobalNamespace 248971"];
14533 [label="=> _underlying.IsGlobalNamespace 248972"];
14534 [label="_underlying.IsGlobalNamespace 248973"];
14535 [label="get\n            {\n                return false;\n            } 248974"];
14536 [label="return false; 248975"];
14537 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 248976"];
14538 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 248977"];
14539 [label="namespaceSymbol.IsGlobalNamespace 248978"];
14540 [label="=> _underlying.IsGlobalNamespace 248979"];
14541 [label="get\n            {\n                return false;\n            } 248980"];
14542 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 248981"];
14543 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 248982"];
14544 [label="this.NotFirstVisitor 248983"];
14545 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 248984"];
14546 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 248985"];
14547 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 248986"];
14548 [label="param SymbolDisplayVisitor(this) 248987"];
14549 [label="isFirstSymbolVisited 248988"];
14550 [label="param SymbolDisplayVisitor(this) 248989"];
14551 [label="_escapeKeywordIdentifiers 248990"];
14552 [label="_lazyAliasMap 248991"];
14553 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 248992"];
14554 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 248993"];
14555 [label="visitor.VisitNamespace(this) 248994"];
14556 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 248995"];
14557 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 248996"];
14558 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 248997"];
14559 [label="param ShouldVisitNamespace(this) 248998"];
14560 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 248999"];
14561 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249000"];
14562 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249001"];
14563 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 249002"];
14564 [label="=> _underlying.IsGlobalNamespace 249003"];
14565 [label="get\n            {\n                return false;\n            } 249004"];
14566 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 249005"];
14567 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 249006"];
14568 [label="get\n            {\n                return true;\n            } 249007"];
14569 [label="=> _underlying.IsGlobalNamespace 249008"];
14570 [label="get\n            {\n                return false;\n            } 249009"];
14571 [label="symbol.IsGlobalNamespace 249010"];
14572 [label="=> _underlying.IsGlobalNamespace 249011"];
14573 [label="get\n            {\n                return false;\n            } 249012"];
14574 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 249013"];
14575 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 249014"];
14576 [label="symbol.Name 249015"];
14577 [label="UnderlyingSymbol 249016"];
14578 [label="UnderlyingSymbol.Name 249017"];
14579 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 249018"];
14580 [label="param CreatePart(SymbolDisplayPartKind kind) 249019"];
14581 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 249020"];
14582 [label="return new SymbolDisplayPart(kind, symbol, text); 249021"];
14583 [label="visitor.VisitNamespace(this); 249022"];
14584 [label="Accept(visitor); 249023"];
14585 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 249024"];
14586 [label="namespaceSymbol.IsGlobalNamespace 249025"];
14587 [label="=> _underlying.IsGlobalNamespace 249026"];
14588 [label="get\n            {\n                return false;\n            } 249027"];
14589 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 249028"];
14590 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 249029"];
14591 [label="param AddPunctuation(this) 249030"];
14592 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 249031"];
14593 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 249032"];
14594 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 249033"];
14595 [label="param CreatePart(SymbolDisplayPartKind kind) 249034"];
14596 [label="param CreatePart(ISymbol symbol) 249035"];
14597 [label="param CreatePart(this) 249036"];
14598 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 249037"];
14599 [label="return new SymbolDisplayPart(kind, symbol, text); 249038"];
14600 [label="return new SymbolDisplayPart(kind, symbol, text); 249039"];
14601 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 249040"];
14602 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 249041"];
14603 [label="symbol.ContainingType 249042"];
14604 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 249043"];
14605 [label="UnderlyingSymbol 249044"];
14606 [label="=> _underlying 249045"];
14607 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 249046"];
14608 [label="UnderlyingSymbol.ContainingType 249047"];
14609 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 249048"];
14610 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 249049"];
14611 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 249050"];
14612 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 249051"];
14613 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 249052"];
14614 [label="param GetPublicSymbol(this Symbol? symbol) 249053"];
14615 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 249054"];
14616 [label="IncludeNamedType(symbol.ContainingType) 249055"];
14617 [label="param IncludeNamedType(INamedTypeSymbol namedType) 249056"];
14618 [label="param IncludeNamedType(this) 249057"];
14619 [label="if (namedType is null)\n            {\n                return false;\n            } 249058"];
14620 [label="return false; 249059"];
14621 [label="AddNameAndTypeArgumentsOrParameters(symbol) 249060"];
14622 [label="param AddNameAndTypeArgumentsOrParameters(this) 249061"];
14623 [label="symbol.IsAnonymousType 249062"];
14624 [label="=> UnderlyingTypeSymbol.IsAnonymousType 249063"];
14625 [label="UnderlyingTypeSymbol 249064"];
14626 [label="=> _underlying 249065"];
14627 [label="UnderlyingTypeSymbol.IsAnonymousType 249066"];
14628 [label="get\n            {\n                return false;\n            } 249067"];
14629 [label="return false; 249068"];
14630 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249069"];
14631 [label="symbol.IsTupleType 249070"];
14632 [label="=> UnderlyingTypeSymbol.IsTupleType 249071"];
14633 [label="UnderlyingTypeSymbol 249072"];
14634 [label="=> _underlying 249073"];
14635 [label="UnderlyingTypeSymbol.IsTupleType 249074"];
14636 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 249075"];
14637 [label="_ 249076"];
14638 [label="tupleCardinality: out _ 249077"];
14639 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 249078"];
14640 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 249079"];
14641 [label="param IsTupleTypeOfCardinality(this) 249080"];
14642 [label="IsUnboundGenericType 249081"];
14643 [label="get\n            {\n                return false;\n            } 249082"];
14644 [label="return false; 249083"];
14645 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249084"];
14646 [label="ContainingSymbol 249085"];
14647 [label="get\n            {\n                return _container;\n            } 249086"];
14648 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249087"];
14649 [label=".Kind 249088"];
14650 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 249089"];
14651 [label="return SymbolKind.Namespace; 249090"];
14652 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249091"];
14653 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249092"];
14654 [label="ContainingNamespace 249093"];
14655 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249094"];
14656 [label="this.ContainingSymbol 249095"];
14657 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249096"];
14658 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249097"];
14659 [label="ContainingNamespace.ContainingNamespace 249098"];
14660 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249099"];
14661 [label="this.ContainingSymbol 249100"];
14662 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249101"];
14663 [label=".IsGlobalNamespace 249102"];
14664 [label="get\n            {\n                return false;\n            } 249103"];
14665 [label="return false; 249104"];
14666 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249105"];
14667 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249106"];
14668 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249107"];
14669 [label="tupleCardinality = 0; 249108"];
14670 [label="return false; 249109"];
14671 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249110"];
14672 [label="string symbolName = null; 249111"];
14673 [label="(symbol is Symbols.PublicModel.NamedTypeSymbol) 249112"];
14674 [label="((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol 249113"];
14675 [label="=> _underlying 249114"];
14676 [label="_underlying 249115"];
14677 [label="NamedTypeSymbol underlyingTypeSymbol = (symbol is Symbols.PublicModel.NamedTypeSymbol) ? ((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol : null; 249116"];
14678 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 249117"];
14679 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249118"];
14680 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249119"];
14681 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 249120"];
14682 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249121"];
14683 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249122"];
14684 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 249123"];
14685 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249124"];
14686 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249125"];
14687 [label="GetPartKind(symbol) 249126"];
14688 [label="symbol.TypeKind 249127"];
14689 [label="UnderlyingTypeSymbol 249128"];
14690 [label="UnderlyingTypeSymbol.TypeKind 249129"];
14691 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 249130"];
14692 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 249131"];
14693 [label="symbol.Name 249132"];
14694 [label="UnderlyingSymbol 249133"];
14695 [label="UnderlyingSymbol.Name 249134"];
14696 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 249135"];
14697 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 249136"];
14698 [label="param RemoveAttributeSufficeIfNecessary(this) 249137"];
14699 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 249138"];
14700 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249139"];
14701 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249140"];
14702 [label="symbol.Arity 249141"];
14703 [label="get\n            {\n                return UnderlyingNamedTypeSymbol.Arity;\n            } 249142"];
14704 [label="UnderlyingNamedTypeSymbol 249143"];
14705 [label="=> _underlying 249144"];
14706 [label="_underlying 249145"];
14707 [label="return UnderlyingNamedTypeSymbol.Arity; 249146"];
14708 [label="UnderlyingNamedTypeSymbol.Arity 249147"];
14709 [label="get\n                {\n                    return 0;\n                } 249148"];
14710 [label="return UnderlyingNamedTypeSymbol.Arity; 249149"];
14711 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249150"];
14712 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249151"];
14713 [label="AddDelegateParameters(symbol); 249152"];
14714 [label="AddDelegateParameters(symbol) 249153"];
14715 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 249154"];
14716 [label="param AddDelegateParameters(this) 249155"];
14717 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 249156"];
14718 [label="CanShowDelegateSignature(symbol) 249157"];
14719 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 249158"];
14720 [label="param CanShowDelegateSignature(this) 249159"];
14721 [label="symbol.TypeKind 249160"];
14722 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 249161"];
14723 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249162"];
14724 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249163"];
14725 [label="AddDelegateParameters(symbol); 249164"];
14726 [label=".OriginalDefinition 249165"];
14727 [label="get\n            {\n                return this;\n            } 249166"];
14728 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 249167"];
14729 [label="AddNameAndTypeArgumentsOrParameters(symbol); 249168"];
14730 [label="VisitNamedTypeWithoutNullability(symbol); 249169"];
14731 [label="AddNullableAnnotations(symbol); 249170"];
14732 [label="AddNullableAnnotations(symbol) 249171"];
14733 [label="param AddNullableAnnotations(ITypeSymbol type) 249172"];
14734 [label="param AddNullableAnnotations(this) 249173"];
14735 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 249174"];
14736 [label="ShouldAddNullableAnnotation(type) 249175"];
14737 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 249176"];
14738 [label="param ShouldAddNullableAnnotation(this) 249177"];
14739 [label="type.NullableAnnotation 249178"];
14740 [label="=> NullableAnnotation 249179"];
14741 [label="NullableAnnotation 249180"];
14742 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 249181"];
14743 [label="return false; 249182"];
14744 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 249183"];
14745 [label="AddNullableAnnotations(symbol); 249184"];
14746 [label="visitor.VisitNamedType(this); 249185"];
14747 [label="Accept(visitor); 249186"];
14748 [label="symbol.Accept(visitor); 249187"];
14749 [label="CustomAssert.Equal('System.Collections.Generic.ICollection<System.Byte[]>', i3.ToTestDisplayString()); 249188"];
14750 [label="CustomAssert.Equal('System.Collections.Generic.ICollection<System.Byte[]>', i3.ToTestDisplayString()); 249189"];
14751 [label="i3.ToTestDisplayString() 249190"];
14752 [label="param ToTestDisplayString(this Symbol symbol) 249191"];
14753 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 249192"];
14754 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 249193"];
14755 [label="param ToDisplayString(SymbolDisplayFormat format = null) 249194"];
14756 [label="param ToDisplayString(this) 249195"];
14757 [label="ISymbol 249196"];
14758 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 249197"];
14759 [label="NullableAnnotation.Oblivious 249198"];
14760 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249199"];
14761 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249200"];
14762 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249201"];
14763 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 249202"];
14764 [label="_underlyingType.TypeKind 249203"];
14765 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 249204"];
14766 [label="return _underlyingType.TypeKind; 249205"];
14767 [label="var kind = TypeKind; 249206"];
14768 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 249207"];
14769 [label="param NamespaceOrTypeSymbol(this) 249208"];
14770 [label="param Symbol(this) 249209"];
14771 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 249210"];
14772 [label="_underlying 249211"];
14773 [label="Debug.Assert(underlying is object); 249212"];
14774 [label="Debug.Assert(!underlying.IsErrorType()); 249213"];
14775 [label="underlying.IsErrorType() 249214"];
14776 [label="param IsErrorType(this TypeSymbol type) 249215"];
14777 [label="RoslynDebug.Assert((object)type != null); 249216"];
14778 [label="RoslynDebug.Assert((object)type != null); 249217"];
14779 [label="get { return OriginalDefinition.Kind; } 249218"];
14780 [label="OriginalDefinition 249219"];
14781 [label="get { return _underlyingType; } 249220"];
14782 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 249221"];
14783 [label="Debug.Assert(!underlying.IsErrorType()); 249222"];
14784 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 249223"];
14785 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 249224"];
14786 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 249225"];
14787 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 249226"];
14788 [label="ToDisplayParts(symbol, format) 249227"];
14789 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 249228"];
14790 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 249229"];
14791 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 249230"];
14792 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 249231"];
14793 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 249232"];
14794 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 249233"];
14795 [label="param ToDisplayParts(int positionOpt) 249234"];
14796 [label="param ToDisplayParts(SymbolDisplayFormat format) 249235"];
14797 [label="param ToDisplayParts(bool minimal) 249236"];
14798 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 249237"];
14799 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 249238"];
14800 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 249239"];
14801 [label="Debug.Assert(semanticModelOpt == null); 249240"];
14802 [label="Debug.Assert(semanticModelOpt == null); 249241"];
14803 [label="Debug.Assert(positionOpt < 0); 249242"];
14804 [label="Debug.Assert(positionOpt < 0); 249243"];
14805 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 249244"];
14806 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 249245"];
14807 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 249246"];
14808 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 249247"];
14809 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 249248"];
14810 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 249249"];
14811 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 249250"];
14812 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 249251"];
14813 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 249252"];
14814 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 249253"];
14815 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 249254"];
14816 [label="param SymbolDisplayVisitor(int positionOpt) 249255"];
14817 [label="param SymbolDisplayVisitor(this) 249256"];
14818 [label="builder 249257"];
14819 [label="format 249258"];
14820 [label="true 249259"];
14821 [label="semanticModelOpt 249260"];
14822 [label="positionOpt 249261"];
14823 [label="param SymbolDisplayVisitor(this) 249262"];
14824 [label="_escapeKeywordIdentifiers 249263"];
14825 [label="_lazyAliasMap 249264"];
14826 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 249265"];
14827 [label="symbol.Accept(visitor); 249266"];
14828 [label="symbol.Accept(visitor) 249267"];
14829 [label="param Accept(SymbolVisitor visitor) 249268"];
14830 [label="Accept(visitor); 249269"];
14831 [label="Accept(visitor) 249270"];
14832 [label="param Accept(SymbolVisitor visitor) 249271"];
14833 [label="visitor.VisitNamedType(this) 249272"];
14834 [label="param VisitNamedType(this) 249273"];
14835 [label="VisitNamedTypeWithoutNullability(symbol) 249274"];
14836 [label="param VisitNamedTypeWithoutNullability(this) 249275"];
14837 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 249276"];
14838 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249277"];
14839 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249278"];
14840 [label="symbol.IsNativeIntegerType 249279"];
14841 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 249280"];
14842 [label="UnderlyingTypeSymbol 249281"];
14843 [label="=> _underlying 249282"];
14844 [label="UnderlyingTypeSymbol.IsNativeIntegerType 249283"];
14845 [label="=> false 249284"];
14846 [label="false 249285"];
14847 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249286"];
14848 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249287"];
14849 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 249288"];
14850 [label="var kind = TypeKind; 249289"];
14851 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 249290"];
14852 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 249291"];
14853 [label="symbol.IsTupleType 249292"];
14854 [label="=> UnderlyingTypeSymbol.IsTupleType 249293"];
14855 [label="UnderlyingTypeSymbol 249294"];
14856 [label="=> _underlying 249295"];
14857 [label="UnderlyingTypeSymbol.IsTupleType 249296"];
14858 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 249297"];
14859 [label="_ 249298"];
14860 [label="tupleCardinality: out _ 249299"];
14861 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 249300"];
14862 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 249301"];
14863 [label="param IsTupleTypeOfCardinality(this) 249302"];
14864 [label="IsUnboundGenericType 249303"];
14865 [label="get\n            {\n                return _unbound;\n            } 249304"];
14866 [label="return _unbound; 249305"];
14867 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249306"];
14868 [label="ContainingSymbol 249307"];
14869 [label="get { return _newContainer; } 249308"];
14870 [label="return _newContainer; 249309"];
14871 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249310"];
14872 [label=".Kind 249311"];
14873 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 249312"];
14874 [label="return SymbolKind.Namespace; 249313"];
14875 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249314"];
14876 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249315"];
14877 [label="ContainingNamespace 249316"];
14878 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249317"];
14879 [label="this.ContainingSymbol 249318"];
14880 [label="get { return _newContainer; } 249319"];
14881 [label="return _newContainer; 249320"];
14882 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249321"];
14883 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249322"];
14884 [label="ContainingNamespace.ContainingNamespace 249323"];
14885 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249324"];
14886 [label="this.ContainingSymbol 249325"];
14887 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249326"];
14888 [label=".IsGlobalNamespace 249327"];
14889 [label="get\n            {\n                return false;\n            } 249328"];
14890 [label="return false; 249329"];
14891 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249330"];
14892 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249331"];
14893 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249332"];
14894 [label="tupleCardinality = 0; 249333"];
14895 [label="return false; 249334"];
14896 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 249335"];
14897 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 249336"];
14898 [label="AddTypeKind(symbol); 249337"];
14899 [label="AddTypeKind(symbol) 249338"];
14900 [label="param AddTypeKind(INamedTypeSymbol symbol) 249339"];
14901 [label="param AddTypeKind(this) 249340"];
14902 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 249341"];
14903 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 249342"];
14904 [label="AddTypeKind(symbol); 249343"];
14905 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 249344"];
14906 [label="CanShowDelegateSignature(symbol) 249345"];
14907 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 249346"];
14908 [label="param CanShowDelegateSignature(this) 249347"];
14909 [label="symbol.TypeKind 249348"];
14910 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 249349"];
14911 [label="UnderlyingTypeSymbol 249350"];
14912 [label="UnderlyingTypeSymbol.TypeKind 249351"];
14913 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 249352"];
14914 [label="_underlyingType.TypeKind 249353"];
14915 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 249354"];
14916 [label="return _underlyingType.TypeKind; 249355"];
14917 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249356"];
14918 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249357"];
14919 [label="symbol.ContainingSymbol 249358"];
14920 [label="UnderlyingSymbol 249359"];
14921 [label="UnderlyingSymbol.ContainingSymbol 249360"];
14922 [label="get { return _newContainer; } 249361"];
14923 [label="return _newContainer; 249362"];
14924 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 249363"];
14925 [label="symbol.GetPublicSymbol<ISymbol>() 249364"];
14926 [label=".ISymbol 249365"];
14927 [label="ShouldVisitNamespace(containingSymbol) 249366"];
14928 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 249367"];
14929 [label="param ShouldVisitNamespace(this) 249368"];
14930 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 249369"];
14931 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249370"];
14932 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249371"];
14933 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 249372"];
14934 [label="namespaceSymbol.IsGlobalNamespace 249373"];
14935 [label="=> _underlying.IsGlobalNamespace 249374"];
14936 [label="_underlying.IsGlobalNamespace 249375"];
14937 [label="get\n            {\n                return false;\n            } 249376"];
14938 [label="return false; 249377"];
14939 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 249378"];
14940 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 249379"];
14941 [label="namespaceSymbol.IsGlobalNamespace 249380"];
14942 [label="=> _underlying.IsGlobalNamespace 249381"];
14943 [label="get\n            {\n                return false;\n            } 249382"];
14944 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 249383"];
14945 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 249384"];
14946 [label="this.NotFirstVisitor 249385"];
14947 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 249386"];
14948 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 249387"];
14949 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 249388"];
14950 [label="param SymbolDisplayVisitor(this) 249389"];
14951 [label="isFirstSymbolVisited 249390"];
14952 [label="param SymbolDisplayVisitor(this) 249391"];
14953 [label="_escapeKeywordIdentifiers 249392"];
14954 [label="_lazyAliasMap 249393"];
14955 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 249394"];
14956 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 249395"];
14957 [label="visitor.VisitNamespace(this) 249396"];
14958 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 249397"];
14959 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 249398"];
14960 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 249399"];
14961 [label="param ShouldVisitNamespace(this) 249400"];
14962 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 249401"];
14963 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249402"];
14964 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249403"];
14965 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 249404"];
14966 [label="=> _underlying.IsGlobalNamespace 249405"];
14967 [label="get\n            {\n                return false;\n            } 249406"];
14968 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 249407"];
14969 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 249408"];
14970 [label="get\n            {\n                return true;\n            } 249409"];
14971 [label="=> _underlying.IsGlobalNamespace 249410"];
14972 [label="get\n            {\n                return false;\n            } 249411"];
14973 [label="get\n            {\n                return false;\n            } 249412"];
14974 [label="symbol.IsGlobalNamespace 249413"];
14975 [label="=> _underlying.IsGlobalNamespace 249414"];
14976 [label="get\n            {\n                return false;\n            } 249415"];
14977 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 249416"];
14978 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 249417"];
14979 [label="symbol.Name 249418"];
14980 [label="UnderlyingSymbol 249419"];
14981 [label="UnderlyingSymbol.Name 249420"];
14982 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 249421"];
14983 [label="param CreatePart(SymbolDisplayPartKind kind) 249422"];
14984 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 249423"];
14985 [label="return new SymbolDisplayPart(kind, symbol, text); 249424"];
14986 [label="visitor.VisitNamespace(this); 249425"];
14987 [label="Accept(visitor); 249426"];
14988 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 249427"];
14989 [label="namespaceSymbol.IsGlobalNamespace 249428"];
14990 [label="=> _underlying.IsGlobalNamespace 249429"];
14991 [label="get\n            {\n                return false;\n            } 249430"];
14992 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 249431"];
14993 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 249432"];
14994 [label="param AddPunctuation(this) 249433"];
14995 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 249434"];
14996 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 249435"];
14997 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 249436"];
14998 [label="param CreatePart(SymbolDisplayPartKind kind) 249437"];
14999 [label="param CreatePart(ISymbol symbol) 249438"];
15000 [label="param CreatePart(this) 249439"];
15001 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 249440"];
15002 [label="return new SymbolDisplayPart(kind, symbol, text); 249441"];
15003 [label="return new SymbolDisplayPart(kind, symbol, text); 249442"];
15004 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 249443"];
15005 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 249444"];
15006 [label="symbol.ContainingType 249445"];
15007 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 249446"];
15008 [label="UnderlyingSymbol 249447"];
15009 [label="=> _underlying 249448"];
15010 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 249449"];
15011 [label="UnderlyingSymbol.ContainingType 249450"];
15012 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 249451"];
15013 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 249452"];
15014 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 249453"];
15015 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 249454"];
15016 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 249455"];
15017 [label="param GetPublicSymbol(this Symbol? symbol) 249456"];
15018 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 249457"];
15019 [label="IncludeNamedType(symbol.ContainingType) 249458"];
15020 [label="param IncludeNamedType(INamedTypeSymbol namedType) 249459"];
15021 [label="param IncludeNamedType(this) 249460"];
15022 [label="if (namedType is null)\n            {\n                return false;\n            } 249461"];
15023 [label="return false; 249462"];
15024 [label="AddNameAndTypeArgumentsOrParameters(symbol) 249463"];
15025 [label="param AddNameAndTypeArgumentsOrParameters(this) 249464"];
15026 [label="symbol.IsAnonymousType 249465"];
15027 [label="=> UnderlyingTypeSymbol.IsAnonymousType 249466"];
15028 [label="UnderlyingTypeSymbol 249467"];
15029 [label="=> _underlying 249468"];
15030 [label="_underlying 249469"];
15031 [label="UnderlyingTypeSymbol.IsAnonymousType 249470"];
15032 [label="get\n            {\n                return false;\n            } 249471"];
15033 [label="return false; 249472"];
15034 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249473"];
15035 [label="symbol.IsTupleType 249474"];
15036 [label="=> UnderlyingTypeSymbol.IsTupleType 249475"];
15037 [label="UnderlyingTypeSymbol 249476"];
15038 [label="=> _underlying 249477"];
15039 [label="_underlying 249478"];
15040 [label="UnderlyingTypeSymbol.IsTupleType 249479"];
15041 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 249480"];
15042 [label="_ 249481"];
15043 [label="tupleCardinality: out _ 249482"];
15044 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 249483"];
15045 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 249484"];
15046 [label="param IsTupleTypeOfCardinality(this) 249485"];
15047 [label="IsUnboundGenericType 249486"];
15048 [label="get\n            {\n                return _unbound;\n            } 249487"];
15049 [label="return _unbound; 249488"];
15050 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249489"];
15051 [label="ContainingSymbol 249490"];
15052 [label="get { return _newContainer; } 249491"];
15053 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249492"];
15054 [label=".Kind 249493"];
15055 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 249494"];
15056 [label="return SymbolKind.Namespace; 249495"];
15057 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249496"];
15058 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249497"];
15059 [label="ContainingNamespace 249498"];
15060 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249499"];
15061 [label="this.ContainingSymbol 249500"];
15062 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249501"];
15063 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249502"];
15064 [label="ContainingNamespace.ContainingNamespace 249503"];
15065 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249504"];
15066 [label="this.ContainingSymbol 249505"];
15067 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 249506"];
15068 [label=".IsGlobalNamespace 249507"];
15069 [label="get\n            {\n                return false;\n            } 249508"];
15070 [label="return false; 249509"];
15071 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249510"];
15072 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249511"];
15073 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249512"];
15074 [label="tupleCardinality = 0; 249513"];
15075 [label="return false; 249514"];
15076 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249515"];
15077 [label="string symbolName = null; 249516"];
15078 [label="(symbol is Symbols.PublicModel.NamedTypeSymbol) 249517"];
15079 [label="((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol 249518"];
15080 [label="=> _underlying 249519"];
15081 [label="_underlying 249520"];
15082 [label="NamedTypeSymbol underlyingTypeSymbol = (symbol is Symbols.PublicModel.NamedTypeSymbol) ? ((Symbols.PublicModel.NamedTypeSymbol)symbol).UnderlyingNamedTypeSymbol : null; 249521"];
15083 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 249522"];
15084 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249523"];
15085 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249524"];
15086 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 249525"];
15087 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249526"];
15088 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249527"];
15089 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 249528"];
15090 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249529"];
15091 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249530"];
15092 [label="GetPartKind(symbol) 249531"];
15093 [label="symbol.TypeKind 249532"];
15094 [label="UnderlyingTypeSymbol 249533"];
15095 [label="UnderlyingTypeSymbol.TypeKind 249534"];
15096 [label="get\n            {\n                return _underlyingType.TypeKind;\n            } 249535"];
15097 [label="_underlyingType.TypeKind 249536"];
15098 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 249537"];
15099 [label="return _underlyingType.TypeKind; 249538"];
15100 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 249539"];
15101 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 249540"];
15102 [label="symbol.Name 249541"];
15103 [label="UnderlyingSymbol 249542"];
15104 [label="UnderlyingSymbol.Name 249543"];
15105 [label="_underlyingType.Name 249544"];
15106 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 249545"];
15107 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 249546"];
15108 [label="param RemoveAttributeSufficeIfNecessary(this) 249547"];
15109 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 249548"];
15110 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249549"];
15111 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249550"];
15112 [label="symbol.Arity 249551"];
15113 [label="get\n            {\n                return UnderlyingNamedTypeSymbol.Arity;\n            } 249552"];
15114 [label="UnderlyingNamedTypeSymbol 249553"];
15115 [label="=> _underlying 249554"];
15116 [label="_underlying 249555"];
15117 [label="return UnderlyingNamedTypeSymbol.Arity; 249556"];
15118 [label="UnderlyingNamedTypeSymbol.Arity 249557"];
15119 [label="get\n            {\n                return _underlyingType.Arity;\n            } 249558"];
15120 [label="_underlyingType.Arity 249559"];
15121 [label="get\n                {\n                    return _arity;\n                } 249560"];
15122 [label="return _underlyingType.Arity; 249561"];
15123 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249562"];
15124 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249563"];
15125 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249564"];
15126 [label="if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 249565"];
15127 [label="if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                } 249566"];
15128 [label="symbol.IsUnboundGenericType 249567"];
15129 [label="=> UnderlyingNamedTypeSymbol.IsUnboundGenericType 249568"];
15130 [label="UnderlyingNamedTypeSymbol 249569"];
15131 [label="=> _underlying 249570"];
15132 [label="UnderlyingNamedTypeSymbol.IsUnboundGenericType 249571"];
15133 [label="get\n            {\n                return _unbound;\n            } 249572"];
15134 [label="return _unbound; 249573"];
15135 [label="if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                } 249574"];
15136 [label="if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                } 249575"];
15137 [label="ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol); 249576"];
15138 [label="GetTypeArgumentsModifiers(underlyingTypeSymbol) 249577"];
15139 [label="param GetTypeArgumentsModifiers(NamedTypeSymbol underlyingTypeSymbol) 249578"];
15140 [label="param GetTypeArgumentsModifiers(this) 249579"];
15141 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers))\n            {\n                if ((object)underlyingTypeSymbol != null)\n                {\n                    return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers);\n                }\n            } 249580"];
15142 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers))\n            {\n                if ((object)underlyingTypeSymbol != null)\n                {\n                    return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers);\n                }\n            } 249581"];
15143 [label="if ((object)underlyingTypeSymbol != null)\n                {\n                    return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers);\n                } 249582"];
15144 [label="if ((object)underlyingTypeSymbol != null)\n                {\n                    return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers);\n                } 249583"];
15145 [label="underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 249584"];
15146 [label="return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers); 249585"];
15147 [label="return underlyingTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.SelectAsArray(a => a.CustomModifiers); 249586"];
15148 [label="AddTypeArguments(symbol, modifiers); 249587"];
15149 [label="AddTypeArguments(symbol, modifiers); 249588"];
15150 [label="AddTypeArguments(symbol, modifiers) 249589"];
15151 [label="param AddTypeArguments(ISymbol owner) 249590"];
15152 [label="param AddTypeArguments(ImmutableArray<ImmutableArray<CustomModifier>> modifiers) 249591"];
15153 [label="param AddTypeArguments(this) 249592"];
15154 [label="ImmutableArray<ITypeSymbol> typeArguments; 249593"];
15155 [label="typeArguments 249594"];
15156 [label="owner.Kind 249595"];
15157 [label="=> UnderlyingSymbol.Kind 249596"];
15158 [label="UnderlyingSymbol 249597"];
15159 [label="=> _underlying 249598"];
15160 [label="_underlying 249599"];
15161 [label="UnderlyingSymbol.Kind 249600"];
15162 [label="get { return OriginalDefinition.Kind; } 249601"];
15163 [label="OriginalDefinition 249602"];
15164 [label="get { return _underlyingType; } 249603"];
15165 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 249604"];
15166 [label="if (owner.Kind == SymbolKind.Method)\n            {\n                typeArguments = ((IMethodSymbol)owner).TypeArguments;\n            }\n            else\n            {\n                typeArguments = ((INamedTypeSymbol)owner).TypeArguments;\n            } 249605"];
15167 [label="((INamedTypeSymbol)owner).TypeArguments 249606"];
15168 [label="get\n            {\n                if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                }\n\n                return _lazyTypeArguments;\n            } 249607"];
15169 [label="if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                } 249608"];
15170 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default); 249609"];
15171 [label="UnderlyingNamedTypeSymbol 249610"];
15172 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default); 249611"];
15173 [label="UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 249612"];
15174 [label="get\n            {\n                return _typeArgumentsWithAnnotations;\n            } 249613"];
15175 [label="UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols() 249614"];
15176 [label="param GetPublicSymbols(this ImmutableArray<TypeWithAnnotations> types) 249615"];
15177 [label="return types.SelectAsArray(t => t.GetPublicSymbol()); 249616"];
15178 [label="return types.SelectAsArray(t => t.GetPublicSymbol()); 249617"];
15179 [label="param GetPublicSymbol(this TypeWithAnnotations type) 249618"];
15180 [label="type.Type 249619"];
15181 [label="=> _extensions?.GetResolvedType(DefaultType) 249620"];
15182 [label="=> defaultType 249621"];
15183 [label="return type.Type?.GetITypeSymbol(type.ToPublicAnnotation()); 249622"];
15184 [label="return type.Type?.GetITypeSymbol(type.ToPublicAnnotation()); 249623"];
15185 [label="type.ToPublicAnnotation() 249624"];
15186 [label="param ToPublicAnnotation(this TypeWithAnnotations type) 249625"];
15187 [label="type.Type 249626"];
15188 [label="=> _extensions?.GetResolvedType(DefaultType) 249627"];
15189 [label="=> defaultType 249628"];
15190 [label="type.NullableAnnotation 249629"];
15191 [label="ToPublicAnnotation(type.Type, type.NullableAnnotation) 249630"];
15192 [label="param ToPublicAnnotation(TypeSymbol? type) 249631"];
15193 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249632"];
15194 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249633"];
15195 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249634"];
15196 [label="get\n            {\n                return false;\n            } 249635"];
15197 [label="return false; 249636"];
15198 [label="return type.Type?.GetITypeSymbol(type.ToPublicAnnotation()); 249637"];
15199 [label=".GetITypeSymbol(type.ToPublicAnnotation()) 249638"];
15200 [label="param GetITypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation) 249639"];
15201 [label="param GetITypeSymbol(this) 249640"];
15202 [label="DefaultNullableAnnotation 249641"];
15203 [label="=> NullableAnnotationExtensions.ToPublicAnnotation(this, NullableAnnotation.Oblivious) 249642"];
15204 [label="NullableAnnotation.Oblivious 249643"];
15205 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249644"];
15206 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249645"];
15207 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249646"];
15208 [label="get\n            {\n                return false;\n            } 249647"];
15209 [label="return false; 249648"];
15210 [label="if (nullableAnnotation == DefaultNullableAnnotation)\n            {\n                return (ITypeSymbol)this.ISymbol;\n            } 249649"];
15211 [label="if (nullableAnnotation == DefaultNullableAnnotation)\n            {\n                return (ITypeSymbol)this.ISymbol;\n            } 249650"];
15212 [label="this.ISymbol 249651"];
15213 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 249652"];
15214 [label="param CreateISymbol(this) 249653"];
15215 [label="return new PublicModel.ArrayTypeSymbol(this, DefaultNullableAnnotation); 249654"];
15216 [label="DefaultNullableAnnotation 249655"];
15217 [label="=> NullableAnnotationExtensions.ToPublicAnnotation(this, NullableAnnotation.Oblivious) 249656"];
15218 [label="NullableAnnotation.Oblivious 249657"];
15219 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249658"];
15220 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249659"];
15221 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249660"];
15222 [label="get\n            {\n                return false;\n            } 249661"];
15223 [label="return false; 249662"];
15224 [label="return new PublicModel.ArrayTypeSymbol(this, DefaultNullableAnnotation); 249663"];
15225 [label="return new PublicModel.ArrayTypeSymbol(this, DefaultNullableAnnotation); 249664"];
15226 [label="new PublicModel.ArrayTypeSymbol(this, DefaultNullableAnnotation) 249665"];
15227 [label="param ArrayTypeSymbol(Symbols.ArrayTypeSymbol underlying) 249666"];
15228 [label="param ArrayTypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation) 249667"];
15229 [label="param ArrayTypeSymbol(this) 249668"];
15230 [label="nullableAnnotation 249669"];
15231 [label="param ArrayTypeSymbol(this) 249670"];
15232 [label="param TypeSymbol(CodeAnalysis.NullableAnnotation nullableAnnotation) 249671"];
15233 [label="param NamespaceOrTypeSymbol(this) 249672"];
15234 [label="param NamespaceOrTypeSymbol(this) 249673"];
15235 [label="param Symbol(this) 249674"];
15236 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 249675"];
15237 [label="_underlying 249676"];
15238 [label="_lazyElementType 249677"];
15239 [label="RoslynDebug.Assert(underlying is object); 249678"];
15240 [label="_underlying 249679"];
15241 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 249680"];
15242 [label="return (ITypeSymbol)this.ISymbol; 249681"];
15243 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default); 249682"];
15244 [label="return _lazyTypeArguments; 249683"];
15245 [label="typeArguments = ((INamedTypeSymbol)owner).TypeArguments; 249684"];
15246 [label="if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                AddPunctuation(SyntaxKind.LessThanToken);\n\n                var first = true;\n                for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                }\n\n                AddPunctuation(SyntaxKind.GreaterThanToken);\n            } 249685"];
15247 [label="if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                AddPunctuation(SyntaxKind.LessThanToken);\n\n                var first = true;\n                for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                }\n\n                AddPunctuation(SyntaxKind.GreaterThanToken);\n            } 249686"];
15248 [label="if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                AddPunctuation(SyntaxKind.LessThanToken);\n\n                var first = true;\n                for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                }\n\n                AddPunctuation(SyntaxKind.GreaterThanToken);\n            } 249687"];
15249 [label="if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                AddPunctuation(SyntaxKind.LessThanToken);\n\n                var first = true;\n                for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                }\n\n                AddPunctuation(SyntaxKind.GreaterThanToken);\n            } 249688"];
15250 [label="if (typeArguments.Length > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                AddPunctuation(SyntaxKind.LessThanToken);\n\n                var first = true;\n                for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                }\n\n                AddPunctuation(SyntaxKind.GreaterThanToken);\n            } 249689"];
15251 [label="AddPunctuation(SyntaxKind.LessThanToken); 249690"];
15252 [label="AddPunctuation(SyntaxKind.LessThanToken) 249691"];
15253 [label="param AddPunctuation(SyntaxKind punctuationKind) 249692"];
15254 [label="AddPunctuation(SyntaxKind.LessThanToken); 249693"];
15255 [label="var first = true; 249694"];
15256 [label="for (int i = 0; i < typeArguments.Length; i++)\n                {\n                    var typeArg = typeArguments[i];\n\n                    if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    }\n                    first = false;\n\n                    AbstractSymbolDisplayVisitor visitor;\n\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    }\n\n                    typeArg.Accept(visitor);\n\n                    if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    }\n                } 249695"];
15257 [label="var typeArg = typeArguments[i]; 249696"];
15258 [label="if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    } 249697"];
15259 [label="first = false; 249698"];
15260 [label="AbstractSymbolDisplayVisitor visitor; 249699"];
15261 [label="typeArg.Kind 249700"];
15262 [label="=> UnderlyingSymbol.Kind 249701"];
15263 [label="UnderlyingSymbol 249702"];
15264 [label="=> _underlying 249703"];
15265 [label="_underlying 249704"];
15266 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 249705"];
15267 [label="return SymbolKind.ArrayType; 249706"];
15268 [label="if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        AddTypeParameterVarianceIfRequired(typeParam);\n\n                        visitor = this.NotFirstVisitor;\n                    }\n                    else\n                    {\n                        visitor = this.NotFirstVisitorNamespaceOrType;\n                    } 249707"];
15269 [label="visitor = this.NotFirstVisitorNamespaceOrType; 249708"];
15270 [label="this.NotFirstVisitorNamespaceOrType 249709"];
15271 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 249710"];
15272 [label="param MakeNotFirstVisitor(this) 249711"];
15273 [label="visitor = this.NotFirstVisitorNamespaceOrType; 249712"];
15274 [label="typeArg.Accept(visitor); 249713"];
15275 [label="typeArg.Accept(visitor) 249714"];
15276 [label="param Accept(SymbolVisitor visitor) 249715"];
15277 [label="param Accept(this) 249716"];
15278 [label="param Accept(SymbolVisitor visitor) 249717"];
15279 [label="param Accept(this) 249718"];
15280 [label="visitor.VisitArrayType(this); 249719"];
15281 [label="visitor.VisitArrayType(this) 249720"];
15282 [label="param VisitArrayType(IArrayTypeSymbol symbol) 249721"];
15283 [label="param VisitArrayType(this) 249722"];
15284 [label="VisitArrayTypeWithoutNullability(symbol); 249723"];
15285 [label="VisitArrayTypeWithoutNullability(symbol) 249724"];
15286 [label="param VisitArrayTypeWithoutNullability(IArrayTypeSymbol symbol) 249725"];
15287 [label="param VisitArrayTypeWithoutNullability(this) 249726"];
15288 [label="if (TryAddAlias(symbol, builder))\n            {\n                return;\n            } 249727"];
15289 [label="if (TryAddAlias(symbol, builder))\n            {\n                return;\n            } 249728"];
15290 [label="TryAddAlias(symbol, builder) 249729"];
15291 [label="param TryAddAlias(INamespaceOrTypeSymbol symbol) 249730"];
15292 [label="param TryAddAlias(ArrayBuilder<SymbolDisplayPart> builder) 249731"];
15293 [label="param TryAddAlias(this) 249732"];
15294 [label="var alias = GetAliasSymbol(symbol); 249733"];
15295 [label="GetAliasSymbol(symbol) 249734"];
15296 [label="param GetAliasSymbol(INamespaceOrTypeSymbol symbol) 249735"];
15297 [label="param GetAliasSymbol(this) 249736"];
15298 [label="IAliasSymbol result; 249737"];
15299 [label="AliasMap 249738"];
15300 [label="get\n            {\n                var map = _lazyAliasMap;\n                if (map != null)\n                {\n                    return map;\n                }\n\n                map = CreateAliasMap();\n                return Interlocked.CompareExchange(ref _lazyAliasMap, map, null) ?? map;\n            } 249739"];
15301 [label="var map = _lazyAliasMap; 249740"];
15302 [label="if (map != null)\n                {\n                    return map;\n                } 249741"];
15303 [label="if (map != null)\n                {\n                    return map;\n                } 249742"];
15304 [label="CreateAliasMap() 249743"];
15305 [label="param CreateAliasMap(this) 249744"];
15306 [label="if (!this.IsMinimizing)\n            {\n                return SpecializedCollections.EmptyDictionary<INamespaceOrTypeSymbol, IAliasSymbol>();\n            } 249745"];
15307 [label="return SpecializedCollections.EmptyDictionary<INamespaceOrTypeSymbol, IAliasSymbol>(); 249746"];
15308 [label="map = CreateAliasMap(); 249747"];
15309 [label="return Interlocked.CompareExchange(ref _lazyAliasMap, map, null) ?? map; 249748"];
15310 [label="return Interlocked.CompareExchange(ref _lazyAliasMap, map, null) ?? map; 249749"];
15311 [label="return Interlocked.CompareExchange(ref _lazyAliasMap, map, null) ?? map; 249750"];
15312 [label="return AliasMap.TryGetValue(symbol, out result) ? result : null; 249751"];
15313 [label="return AliasMap.TryGetValue(symbol, out result) ? result : null; 249752"];
15314 [label="return AliasMap.TryGetValue(symbol, out result) ? result : null; 249753"];
15315 [label="return AliasMap.TryGetValue(symbol, out result) ? result : null; 249754"];
15316 [label="AliasMap.TryGetValue(symbol, out result) 249755"];
15317 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 249756"];
15318 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 249757"];
15319 [label="return false; 249758"];
15320 [label="if (TryAddAlias(symbol, builder))\n            {\n                return;\n            } 249759"];
15321 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 249760"];
15322 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 249761"];
15323 [label="ITypeSymbol underlyingType = symbol; 249762"];
15324 [label="((IArrayTypeSymbol)underlyingType).ElementType 249763"];
15325 [label="get\n            {\n                if (_lazyElementType is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null);\n                }\n\n                return _lazyElementType;\n            } 249764"];
15326 [label="if (_lazyElementType is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null);\n                } 249765"];
15327 [label="Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null); 249766"];
15328 [label="_underlying.ElementTypeWithAnnotations 249767"];
15329 [label="Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null); 249768"];
15330 [label="_underlying.ElementTypeWithAnnotations.GetPublicSymbol() 249769"];
15331 [label="param GetPublicSymbol(this TypeWithAnnotations type) 249770"];
15332 [label="=> defaultType 249771"];
15333 [label="param ToPublicAnnotation(this TypeWithAnnotations type) 249772"];
15334 [label="type.Type 249773"];
15335 [label="=> _extensions?.GetResolvedType(DefaultType) 249774"];
15336 [label="=> defaultType 249775"];
15337 [label="type.NullableAnnotation 249776"];
15338 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249777"];
15339 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249778"];
15340 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249779"];
15341 [label="var kind = TypeKind; 249780"];
15342 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 249781"];
15343 [label="when type?.IsValueType == true 249782"];
15344 [label="NullableAnnotation.Oblivious 249783"];
15345 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249784"];
15346 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249785"];
15347 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249786"];
15348 [label="var kind = TypeKind; 249787"];
15349 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 249788"];
15350 [label="when type?.IsValueType == true 249789"];
15351 [label="NullableAnnotation.Oblivious 249790"];
15352 [label="param ToPublicAnnotation(NullableAnnotation annotation) 249791"];
15353 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 249792"];
15354 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 249793"];
15355 [label="var kind = TypeKind; 249794"];
15356 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 249795"];
15357 [label="when type?.IsValueType == true 249796"];
15358 [label="param NamespaceOrTypeSymbol(this) 249797"];
15359 [label="param Symbol(this) 249798"];
15360 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 249799"];
15361 [label="_underlying 249800"];
15362 [label="Debug.Assert(underlying is object); 249801"];
15363 [label="Debug.Assert(!underlying.IsErrorType()); 249802"];
15364 [label="underlying.IsErrorType() 249803"];
15365 [label="param IsErrorType(this TypeSymbol type) 249804"];
15366 [label="RoslynDebug.Assert((object)type != null); 249805"];
15367 [label="RoslynDebug.Assert((object)type != null); 249806"];
15368 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 249807"];
15369 [label="Debug.Assert(!underlying.IsErrorType()); 249808"];
15370 [label="Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null); 249809"];
15371 [label="return _lazyElementType; 249810"];
15372 [label="underlyingType = ((IArrayTypeSymbol)underlyingType).ElementType; 249811"];
15373 [label="underlyingType.Kind 249812"];
15374 [label="=> UnderlyingSymbol.Kind 249813"];
15375 [label="UnderlyingSymbol 249814"];
15376 [label="=> _underlying 249815"];
15377 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 249816"];
15378 [label="do\n            {\n                underlyingType = ((IArrayTypeSymbol)underlyingType).ElementType;\n            }\n            while (underlyingType.Kind == SymbolKind.ArrayType && !ShouldAddNullableAnnotation(underlyingType)); 249817"];
15379 [label="underlyingType.Accept(this.NotFirstVisitor); 249818"];
15380 [label="underlyingType.Accept(this.NotFirstVisitor) 249819"];
15381 [label="param Accept(SymbolVisitor visitor) 249820"];
15382 [label="param Accept(this) 249821"];
15383 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 249822"];
15384 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249823"];
15385 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249824"];
15386 [label="symbol.IsNativeIntegerType 249825"];
15387 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 249826"];
15388 [label="UnderlyingTypeSymbol 249827"];
15389 [label="=> _underlying 249828"];
15390 [label="UnderlyingTypeSymbol.IsNativeIntegerType 249829"];
15391 [label="=> false 249830"];
15392 [label="false 249831"];
15393 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249832"];
15394 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 249833"];
15395 [label="if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                } 249834"];
15396 [label="symbol.IsTupleType 249835"];
15397 [label="=> UnderlyingTypeSymbol.IsTupleType 249836"];
15398 [label="UnderlyingTypeSymbol 249837"];
15399 [label="=> _underlying 249838"];
15400 [label="_underlying 249839"];
15401 [label="UnderlyingTypeSymbol.IsTupleType 249840"];
15402 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 249841"];
15403 [label="_ 249842"];
15404 [label="tupleCardinality: out _ 249843"];
15405 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 249844"];
15406 [label="param IsTupleTypeOfCardinality(this) 249845"];
15407 [label="IsUnboundGenericType 249846"];
15408 [label="get\n            {\n                return false;\n            } 249847"];
15409 [label="return false; 249848"];
15410 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249849"];
15411 [label="ContainingSymbol 249850"];
15412 [label="get\n            {\n                return _container;\n            } 249851"];
15413 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249852"];
15414 [label=".Kind 249853"];
15415 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 249854"];
15416 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249855"];
15417 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249856"];
15418 [label="ContainingNamespace 249857"];
15419 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249858"];
15420 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249859"];
15421 [label="ContainingNamespace.ContainingNamespace 249860"];
15422 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249861"];
15423 [label=".IsGlobalNamespace 249862"];
15424 [label="get\n            {\n                return true;\n            } 249863"];
15425 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249864"];
15426 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249865"];
15427 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249866"];
15428 [label="Name 249867"];
15429 [label="get\n            {\n                return _name;\n            } 249868"];
15430 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249869"];
15431 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249870"];
15432 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249871"];
15433 [label="tupleCardinality = 0; 249872"];
15434 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 249873"];
15435 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 249874"];
15436 [label="AddTypeKind(symbol); 249875"];
15437 [label="AddTypeKind(symbol) 249876"];
15438 [label="param AddTypeKind(INamedTypeSymbol symbol) 249877"];
15439 [label="param AddTypeKind(this) 249878"];
15440 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 249879"];
15441 [label="AddTypeKind(symbol); 249880"];
15442 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 249881"];
15443 [label="CanShowDelegateSignature(symbol) 249882"];
15444 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 249883"];
15445 [label="param CanShowDelegateSignature(this) 249884"];
15446 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249885"];
15447 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 249886"];
15448 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 249887"];
15449 [label="param ShouldVisitNamespace(this) 249888"];
15450 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 249889"];
15451 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249890"];
15452 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249891"];
15453 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 249892"];
15454 [label="=> _underlying.IsGlobalNamespace 249893"];
15455 [label="get\n            {\n                return false;\n            } 249894"];
15456 [label="=> _underlying.IsGlobalNamespace 249895"];
15457 [label="get\n            {\n                return false;\n            } 249896"];
15458 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 249897"];
15459 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 249898"];
15460 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 249899"];
15461 [label="param ShouldVisitNamespace(this) 249900"];
15462 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 249901"];
15463 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249902"];
15464 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 249903"];
15465 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 249904"];
15466 [label="=> _underlying.IsGlobalNamespace 249905"];
15467 [label="get\n            {\n                return true;\n            } 249906"];
15468 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 249907"];
15469 [label="symbol.ContainingType 249908"];
15470 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 249909"];
15471 [label="UnderlyingSymbol 249910"];
15472 [label="=> _underlying 249911"];
15473 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 249912"];
15474 [label="UnderlyingSymbol.ContainingType 249913"];
15475 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 249914"];
15476 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 249915"];
15477 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 249916"];
15478 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 249917"];
15479 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 249918"];
15480 [label="param GetPublicSymbol(this Symbol? symbol) 249919"];
15481 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 249920"];
15482 [label="IncludeNamedType(symbol.ContainingType) 249921"];
15483 [label="param IncludeNamedType(INamedTypeSymbol namedType) 249922"];
15484 [label="param IncludeNamedType(this) 249923"];
15485 [label="if (namedType is null)\n            {\n                return false;\n            } 249924"];
15486 [label="return false; 249925"];
15487 [label="symbol.IsAnonymousType 249926"];
15488 [label="=> UnderlyingTypeSymbol.IsAnonymousType 249927"];
15489 [label="UnderlyingTypeSymbol 249928"];
15490 [label="=> _underlying 249929"];
15491 [label="_underlying 249930"];
15492 [label="UnderlyingTypeSymbol.IsAnonymousType 249931"];
15493 [label="get\n            {\n                return false;\n            } 249932"];
15494 [label="return false; 249933"];
15495 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249934"];
15496 [label="symbol.IsTupleType 249935"];
15497 [label="=> UnderlyingTypeSymbol.IsTupleType 249936"];
15498 [label="UnderlyingTypeSymbol 249937"];
15499 [label="=> _underlying 249938"];
15500 [label="_underlying 249939"];
15501 [label="UnderlyingTypeSymbol.IsTupleType 249940"];
15502 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 249941"];
15503 [label="_ 249942"];
15504 [label="tupleCardinality: out _ 249943"];
15505 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 249944"];
15506 [label="param IsTupleTypeOfCardinality(this) 249945"];
15507 [label="IsUnboundGenericType 249946"];
15508 [label="get\n            {\n                return false;\n            } 249947"];
15509 [label="return false; 249948"];
15510 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249949"];
15511 [label="ContainingSymbol 249950"];
15512 [label="get\n            {\n                return _container;\n            } 249951"];
15513 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249952"];
15514 [label=".Kind 249953"];
15515 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 249954"];
15516 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249955"];
15517 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249956"];
15518 [label="ContainingNamespace 249957"];
15519 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249958"];
15520 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249959"];
15521 [label="ContainingNamespace.ContainingNamespace 249960"];
15522 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 249961"];
15523 [label=".IsGlobalNamespace 249962"];
15524 [label="get\n            {\n                return true;\n            } 249963"];
15525 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249964"];
15526 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249965"];
15527 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249966"];
15528 [label="Name 249967"];
15529 [label="get\n            {\n                return _name;\n            } 249968"];
15530 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249969"];
15531 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249970"];
15532 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 249971"];
15533 [label="tupleCardinality = 0; 249972"];
15534 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 249973"];
15535 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 249974"];
15536 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249975"];
15537 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 249976"];
15538 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 249977"];
15539 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249978"];
15540 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 249979"];
15541 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 249980"];
15542 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249981"];
15543 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 249982"];
15544 [label="return SymbolDisplayPartKind.StructName; 249983"];
15545 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 249984"];
15546 [label="param RemoveAttributeSufficeIfNecessary(this) 249985"];
15547 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 249986"];
15548 [label="get\n                {\n                    return 0;\n                } 249987"];
15549 [label="AddDelegateParameters(symbol); 249988"];
15550 [label="AddDelegateParameters(symbol) 249989"];
15551 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 249990"];
15552 [label="param AddDelegateParameters(this) 249991"];
15553 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 249992"];
15554 [label="CanShowDelegateSignature(symbol) 249993"];
15555 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 249994"];
15556 [label="param CanShowDelegateSignature(this) 249995"];
15557 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 249996"];
15558 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 249997"];
15559 [label="AddDelegateParameters(symbol); 249998"];
15560 [label=".OriginalDefinition 249999"];
15561 [label="get\n            {\n                return this;\n            } 250000"];
15562 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 250001"];
15563 [label="AddNullableAnnotations(symbol); 250002"];
15564 [label="AddNullableAnnotations(symbol) 250003"];
15565 [label="param AddNullableAnnotations(ITypeSymbol type) 250004"];
15566 [label="param AddNullableAnnotations(this) 250005"];
15567 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250006"];
15568 [label="ShouldAddNullableAnnotation(type) 250007"];
15569 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250008"];
15570 [label="param ShouldAddNullableAnnotation(this) 250009"];
15571 [label="type.NullableAnnotation 250010"];
15572 [label="=> NullableAnnotation 250011"];
15573 [label="NullableAnnotation 250012"];
15574 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250013"];
15575 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 250014"];
15576 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 250015"];
15577 [label="return false; 250016"];
15578 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250017"];
15579 [label="AddNullableAnnotations(symbol); 250018"];
15580 [label="underlyingType.Accept(this.NotFirstVisitor); 250019"];
15581 [label="var arrayType = symbol; 250020"];
15582 [label="while (arrayType != null && arrayType != underlyingType)\n            {\n                if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                }\n\n                AddArrayRank(arrayType);\n                arrayType = arrayType.ElementType as IArrayTypeSymbol;\n            } 250021"];
15583 [label="while (arrayType != null && arrayType != underlyingType)\n            {\n                if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                }\n\n                AddArrayRank(arrayType);\n                arrayType = arrayType.ElementType as IArrayTypeSymbol;\n            } 250022"];
15584 [label="while (arrayType != null && arrayType != underlyingType)\n            {\n                if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                }\n\n                AddArrayRank(arrayType);\n                arrayType = arrayType.ElementType as IArrayTypeSymbol;\n            } 250023"];
15585 [label="if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                } 250024"];
15586 [label="arrayType.CustomModifiers 250025"];
15587 [label="=> _underlying.ElementTypeWithAnnotations.CustomModifiers 250026"];
15588 [label="_underlying.ElementTypeWithAnnotations 250027"];
15589 [label="get\n            {\n                return _elementTypeWithAnnotations;\n            } 250028"];
15590 [label="_underlying.ElementTypeWithAnnotations.CustomModifiers 250029"];
15591 [label="=> _extensions.CustomModifiers 250030"];
15592 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 250031"];
15593 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 250032"];
15594 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true) 250033"];
15595 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 250034"];
15596 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 250035"];
15597 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 250036"];
15598 [label="param AddCustomModifiersIfRequired(this) 250037"];
15599 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250038"];
15600 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250039"];
15601 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250040"];
15602 [label="AddArrayRank(arrayType); 250041"];
15603 [label="AddArrayRank(arrayType) 250042"];
15604 [label="param AddArrayRank(IArrayTypeSymbol symbol) 250043"];
15605 [label="param AddArrayRank(this) 250044"];
15606 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 250045"];
15607 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 250046"];
15608 [label="AddPunctuation(SyntaxKind.OpenBracketToken); 250047"];
15609 [label="AddPunctuation(SyntaxKind.OpenBracketToken) 250048"];
15610 [label="param AddPunctuation(SyntaxKind punctuationKind) 250049"];
15611 [label="param AddPunctuation(this) 250050"];
15612 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 250051"];
15613 [label="AddPunctuation(SyntaxKind.OpenBracketToken); 250052"];
15614 [label="symbol.Rank 250053"];
15615 [label="=> _underlying.Rank 250054"];
15616 [label="_underlying.Rank 250055"];
15617 [label="get\n                {\n                    return 1;\n                } 250056"];
15618 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250057"];
15619 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250058"];
15620 [label="symbol.IsSZArray 250059"];
15621 [label="=> _underlying.IsSZArray 250060"];
15622 [label="_underlying.IsSZArray 250061"];
15623 [label="get\n                {\n                    return true;\n                } 250062"];
15624 [label="return true; 250063"];
15625 [label="if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                } 250064"];
15626 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250065"];
15627 [label="symbol.Rank 250066"];
15628 [label="=> _underlying.Rank 250067"];
15629 [label="_underlying.Rank 250068"];
15630 [label="get\n                {\n                    return 1;\n                } 250069"];
15631 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250070"];
15632 [label="AddPunctuation(SyntaxKind.CloseBracketToken); 250071"];
15633 [label="AddPunctuation(SyntaxKind.CloseBracketToken) 250072"];
15634 [label="param AddPunctuation(SyntaxKind punctuationKind) 250073"];
15635 [label="param AddPunctuation(this) 250074"];
15636 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 250075"];
15637 [label="AddPunctuation(SyntaxKind.CloseBracketToken); 250076"];
15638 [label="AddArrayRank(arrayType); 250077"];
15639 [label="arrayType.ElementType 250078"];
15640 [label="if (_lazyElementType is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null);\n                } 250079"];
15641 [label="return _lazyElementType; 250080"];
15642 [label="arrayType = arrayType.ElementType as IArrayTypeSymbol; 250081"];
15643 [label="VisitArrayTypeWithoutNullability(symbol); 250082"];
15644 [label="AddNullableAnnotations(symbol); 250083"];
15645 [label="AddNullableAnnotations(symbol) 250084"];
15646 [label="param AddNullableAnnotations(ITypeSymbol type) 250085"];
15647 [label="param AddNullableAnnotations(this) 250086"];
15648 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250087"];
15649 [label="ShouldAddNullableAnnotation(type) 250088"];
15650 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250089"];
15651 [label="param ShouldAddNullableAnnotation(this) 250090"];
15652 [label="type.NullableAnnotation 250091"];
15653 [label="=> NullableAnnotation 250092"];
15654 [label="NullableAnnotation 250093"];
15655 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250094"];
15656 [label="return false; 250095"];
15657 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250096"];
15658 [label="AddNullableAnnotations(symbol); 250097"];
15659 [label="visitor.VisitArrayType(this); 250098"];
15660 [label="typeArg.Accept(visitor); 250099"];
15661 [label="if (!modifiers.IsDefault)\n                    {\n                        AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false);\n                    } 250100"];
15662 [label="AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false); 250101"];
15663 [label="AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false); 250102"];
15664 [label="AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false) 250103"];
15665 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 250104"];
15666 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 250105"];
15667 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 250106"];
15668 [label="param AddCustomModifiersIfRequired(this) 250107"];
15669 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250108"];
15670 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250109"];
15671 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250110"];
15672 [label="AddPunctuation(SyntaxKind.GreaterThanToken); 250111"];
15673 [label="AddPunctuation(SyntaxKind.GreaterThanToken) 250112"];
15674 [label="param AddPunctuation(SyntaxKind punctuationKind) 250113"];
15675 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 250114"];
15676 [label="AddPunctuation(SyntaxKind.GreaterThanToken); 250115"];
15677 [label="AddTypeArguments(symbol, modifiers); 250116"];
15678 [label="AddDelegateParameters(symbol); 250117"];
15679 [label="AddDelegateParameters(symbol) 250118"];
15680 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 250119"];
15681 [label="param AddDelegateParameters(this) 250120"];
15682 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 250121"];
15683 [label="CanShowDelegateSignature(symbol) 250122"];
15684 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250123"];
15685 [label="param CanShowDelegateSignature(this) 250124"];
15686 [label="symbol.TypeKind 250125"];
15687 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 250126"];
15688 [label="_underlying 250127"];
15689 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250128"];
15690 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250129"];
15691 [label="AddDelegateParameters(symbol); 250130"];
15692 [label="symbol.TypeArguments 250131"];
15693 [label="get\n            {\n                if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                }\n\n                return _lazyTypeArguments;\n            } 250132"];
15694 [label="if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                } 250133"];
15695 [label="return _lazyTypeArguments; 250134"];
15696 [label="AddTypeParameterConstraints(symbol.TypeArguments); 250135"];
15697 [label="AddTypeParameterConstraints(symbol.TypeArguments) 250136"];
15698 [label="param AddTypeParameterConstraints(ImmutableArray<ITypeSymbol> typeArguments) 250137"];
15699 [label="param AddTypeParameterConstraints(this) 250138"];
15700 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 250139"];
15701 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 250140"];
15702 [label="AddTypeParameterConstraints(symbol.TypeArguments); 250141"];
15703 [label=".OriginalDefinition 250142"];
15704 [label="get { return _underlyingType; } 250143"];
15705 [label="return _underlyingType; 250144"];
15706 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 250145"];
15707 [label="AddNameAndTypeArgumentsOrParameters(symbol); 250146"];
15708 [label="VisitNamedTypeWithoutNullability(symbol); 250147"];
15709 [label="AddNullableAnnotations(symbol); 250148"];
15710 [label="AddNullableAnnotations(symbol) 250149"];
15711 [label="param AddNullableAnnotations(ITypeSymbol type) 250150"];
15712 [label="param AddNullableAnnotations(this) 250151"];
15713 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250152"];
15714 [label="ShouldAddNullableAnnotation(type) 250153"];
15715 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250154"];
15716 [label="param ShouldAddNullableAnnotation(this) 250155"];
15717 [label="type.NullableAnnotation 250156"];
15718 [label="=> NullableAnnotation 250157"];
15719 [label="NullableAnnotation 250158"];
15720 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250159"];
15721 [label="return false; 250160"];
15722 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250161"];
15723 [label="AddNullableAnnotations(symbol); 250162"];
15724 [label="visitor.VisitNamedType(this); 250163"];
15725 [label="Accept(visitor); 250164"];
15726 [label="symbol.Accept(visitor); 250165"];
15727 [label="CustomAssert.Equal('System.Collections.Generic.IEnumerable<System.Byte[]>', i4.ToTestDisplayString()); 250166"];
15728 [label="CustomAssert.Equal('System.Collections.Generic.IEnumerable<System.Byte[]>', i4.ToTestDisplayString()); 250167"];
15729 [label="i4.ToTestDisplayString() 250168"];
15730 [label="param ToTestDisplayString(this Symbol symbol) 250169"];
15731 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 250170"];
15732 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 250171"];
15733 [label="param ToDisplayString(SymbolDisplayFormat format = null) 250172"];
15734 [label="param ToDisplayString(this) 250173"];
15735 [label="ISymbol 250174"];
15736 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 250175"];
15737 [label="NullableAnnotation.Oblivious 250176"];
15738 [label="param ToPublicAnnotation(NullableAnnotation annotation) 250177"];
15739 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 250178"];
15740 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 250179"];
15741 [label="var kind = TypeKind; 250180"];
15742 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 250181"];
15743 [label="param NamespaceOrTypeSymbol(this) 250182"];
15744 [label="param Symbol(this) 250183"];
15745 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 250184"];
15746 [label="_underlying 250185"];
15747 [label="Debug.Assert(underlying is object); 250186"];
15748 [label="Debug.Assert(!underlying.IsErrorType()); 250187"];
15749 [label="underlying.IsErrorType() 250188"];
15750 [label="param IsErrorType(this TypeSymbol type) 250189"];
15751 [label="RoslynDebug.Assert((object)type != null); 250190"];
15752 [label="RoslynDebug.Assert((object)type != null); 250191"];
15753 [label="get { return OriginalDefinition.Kind; } 250192"];
15754 [label="OriginalDefinition 250193"];
15755 [label="get { return _underlyingType; } 250194"];
15756 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 250195"];
15757 [label="Debug.Assert(!underlying.IsErrorType()); 250196"];
15758 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 250197"];
15759 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 250198"];
15760 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 250199"];
15761 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 250200"];
15762 [label="ToDisplayParts(symbol, format) 250201"];
15763 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 250202"];
15764 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 250203"];
15765 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 250204"];
15766 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 250205"];
15767 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 250206"];
15768 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 250207"];
15769 [label="param ToDisplayParts(int positionOpt) 250208"];
15770 [label="param ToDisplayParts(SymbolDisplayFormat format) 250209"];
15771 [label="param ToDisplayParts(bool minimal) 250210"];
15772 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 250211"];
15773 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 250212"];
15774 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 250213"];
15775 [label="Debug.Assert(semanticModelOpt == null); 250214"];
15776 [label="Debug.Assert(semanticModelOpt == null); 250215"];
15777 [label="Debug.Assert(positionOpt < 0); 250216"];
15778 [label="Debug.Assert(positionOpt < 0); 250217"];
15779 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 250218"];
15780 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 250219"];
15781 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250220"];
15782 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250221"];
15783 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250222"];
15784 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250223"];
15785 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250224"];
15786 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 250225"];
15787 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 250226"];
15788 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 250227"];
15789 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 250228"];
15790 [label="param SymbolDisplayVisitor(int positionOpt) 250229"];
15791 [label="param SymbolDisplayVisitor(this) 250230"];
15792 [label="builder 250231"];
15793 [label="format 250232"];
15794 [label="true 250233"];
15795 [label="semanticModelOpt 250234"];
15796 [label="positionOpt 250235"];
15797 [label="param SymbolDisplayVisitor(this) 250236"];
15798 [label="_escapeKeywordIdentifiers 250237"];
15799 [label="_lazyAliasMap 250238"];
15800 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 250239"];
15801 [label="symbol.Accept(visitor); 250240"];
15802 [label="symbol.Accept(visitor) 250241"];
15803 [label="param Accept(SymbolVisitor visitor) 250242"];
15804 [label="Accept(visitor); 250243"];
15805 [label="Accept(visitor) 250244"];
15806 [label="param Accept(SymbolVisitor visitor) 250245"];
15807 [label="visitor.VisitNamedType(this) 250246"];
15808 [label="param VisitNamedType(this) 250247"];
15809 [label="VisitNamedTypeWithoutNullability(symbol) 250248"];
15810 [label="param VisitNamedTypeWithoutNullability(this) 250249"];
15811 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 250250"];
15812 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250251"];
15813 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250252"];
15814 [label="symbol.IsNativeIntegerType 250253"];
15815 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 250254"];
15816 [label="UnderlyingTypeSymbol 250255"];
15817 [label="=> _underlying 250256"];
15818 [label="UnderlyingTypeSymbol.IsNativeIntegerType 250257"];
15819 [label="=> false 250258"];
15820 [label="false 250259"];
15821 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250260"];
15822 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250261"];
15823 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 250262"];
15824 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 250263"];
15825 [label="symbol.IsTupleType 250264"];
15826 [label="=> UnderlyingTypeSymbol.IsTupleType 250265"];
15827 [label="UnderlyingTypeSymbol 250266"];
15828 [label="=> _underlying 250267"];
15829 [label="UnderlyingTypeSymbol.IsTupleType 250268"];
15830 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 250269"];
15831 [label="_ 250270"];
15832 [label="tupleCardinality: out _ 250271"];
15833 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 250272"];
15834 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 250273"];
15835 [label="param IsTupleTypeOfCardinality(this) 250274"];
15836 [label="IsUnboundGenericType 250275"];
15837 [label="get\n            {\n                return _unbound;\n            } 250276"];
15838 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250277"];
15839 [label="ContainingSymbol 250278"];
15840 [label="get { return _newContainer; } 250279"];
15841 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250280"];
15842 [label=".Kind 250281"];
15843 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 250282"];
15844 [label="return SymbolKind.Namespace; 250283"];
15845 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250284"];
15846 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250285"];
15847 [label="ContainingNamespace 250286"];
15848 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250287"];
15849 [label="this.ContainingSymbol 250288"];
15850 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250289"];
15851 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250290"];
15852 [label="ContainingNamespace.ContainingNamespace 250291"];
15853 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250292"];
15854 [label="this.ContainingSymbol 250293"];
15855 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250294"];
15856 [label=".IsGlobalNamespace 250295"];
15857 [label="get\n            {\n                return false;\n            } 250296"];
15858 [label="return false; 250297"];
15859 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250298"];
15860 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250299"];
15861 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250300"];
15862 [label="tupleCardinality = 0; 250301"];
15863 [label="return false; 250302"];
15864 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 250303"];
15865 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 250304"];
15866 [label="AddTypeKind(symbol); 250305"];
15867 [label="AddTypeKind(symbol) 250306"];
15868 [label="param AddTypeKind(INamedTypeSymbol symbol) 250307"];
15869 [label="param AddTypeKind(this) 250308"];
15870 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 250309"];
15871 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 250310"];
15872 [label="AddTypeKind(symbol); 250311"];
15873 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 250312"];
15874 [label="CanShowDelegateSignature(symbol) 250313"];
15875 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250314"];
15876 [label="param CanShowDelegateSignature(this) 250315"];
15877 [label="symbol.TypeKind 250316"];
15878 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 250317"];
15879 [label="UnderlyingTypeSymbol 250318"];
15880 [label="UnderlyingTypeSymbol.TypeKind 250319"];
15881 [label="_underlyingType.TypeKind 250320"];
15882 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250321"];
15883 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250322"];
15884 [label="symbol.ContainingSymbol 250323"];
15885 [label="UnderlyingSymbol 250324"];
15886 [label="UnderlyingSymbol.ContainingSymbol 250325"];
15887 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 250326"];
15888 [label="symbol.GetPublicSymbol<ISymbol>() 250327"];
15889 [label=".ISymbol 250328"];
15890 [label="ShouldVisitNamespace(containingSymbol) 250329"];
15891 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 250330"];
15892 [label="param ShouldVisitNamespace(this) 250331"];
15893 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 250332"];
15894 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250333"];
15895 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250334"];
15896 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 250335"];
15897 [label="namespaceSymbol.IsGlobalNamespace 250336"];
15898 [label="=> _underlying.IsGlobalNamespace 250337"];
15899 [label="_underlying.IsGlobalNamespace 250338"];
15900 [label="get\n            {\n                return false;\n            } 250339"];
15901 [label="return false; 250340"];
15902 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 250341"];
15903 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 250342"];
15904 [label="namespaceSymbol.IsGlobalNamespace 250343"];
15905 [label="=> _underlying.IsGlobalNamespace 250344"];
15906 [label="get\n            {\n                return false;\n            } 250345"];
15907 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 250346"];
15908 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 250347"];
15909 [label="this.NotFirstVisitor 250348"];
15910 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 250349"];
15911 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 250350"];
15912 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 250351"];
15913 [label="param SymbolDisplayVisitor(this) 250352"];
15914 [label="isFirstSymbolVisited 250353"];
15915 [label="param SymbolDisplayVisitor(this) 250354"];
15916 [label="_escapeKeywordIdentifiers 250355"];
15917 [label="_lazyAliasMap 250356"];
15918 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 250357"];
15919 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 250358"];
15920 [label="visitor.VisitNamespace(this) 250359"];
15921 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 250360"];
15922 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 250361"];
15923 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 250362"];
15924 [label="param ShouldVisitNamespace(this) 250363"];
15925 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 250364"];
15926 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250365"];
15927 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250366"];
15928 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 250367"];
15929 [label="=> _underlying.IsGlobalNamespace 250368"];
15930 [label="get\n            {\n                return false;\n            } 250369"];
15931 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 250370"];
15932 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 250371"];
15933 [label="get\n            {\n                return true;\n            } 250372"];
15934 [label="=> _underlying.IsGlobalNamespace 250373"];
15935 [label="get\n            {\n                return false;\n            } 250374"];
15936 [label="symbol.IsGlobalNamespace 250375"];
15937 [label="=> _underlying.IsGlobalNamespace 250376"];
15938 [label="get\n            {\n                return false;\n            } 250377"];
15939 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 250378"];
15940 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 250379"];
15941 [label="symbol.Name 250380"];
15942 [label="UnderlyingSymbol 250381"];
15943 [label="UnderlyingSymbol.Name 250382"];
15944 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 250383"];
15945 [label="param CreatePart(SymbolDisplayPartKind kind) 250384"];
15946 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 250385"];
15947 [label="return new SymbolDisplayPart(kind, symbol, text); 250386"];
15948 [label="visitor.VisitNamespace(this); 250387"];
15949 [label="Accept(visitor); 250388"];
15950 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 250389"];
15951 [label="namespaceSymbol.IsGlobalNamespace 250390"];
15952 [label="=> _underlying.IsGlobalNamespace 250391"];
15953 [label="get\n            {\n                return false;\n            } 250392"];
15954 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 250393"];
15955 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 250394"];
15956 [label="param AddPunctuation(this) 250395"];
15957 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 250396"];
15958 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 250397"];
15959 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 250398"];
15960 [label="param CreatePart(SymbolDisplayPartKind kind) 250399"];
15961 [label="param CreatePart(ISymbol symbol) 250400"];
15962 [label="param CreatePart(this) 250401"];
15963 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 250402"];
15964 [label="return new SymbolDisplayPart(kind, symbol, text); 250403"];
15965 [label="return new SymbolDisplayPart(kind, symbol, text); 250404"];
15966 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 250405"];
15967 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 250406"];
15968 [label="symbol.ContainingType 250407"];
15969 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 250408"];
15970 [label="UnderlyingSymbol 250409"];
15971 [label="=> _underlying 250410"];
15972 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 250411"];
15973 [label="UnderlyingSymbol.ContainingType 250412"];
15974 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 250413"];
15975 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 250414"];
15976 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 250415"];
15977 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 250416"];
15978 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 250417"];
15979 [label="param GetPublicSymbol(this Symbol? symbol) 250418"];
15980 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 250419"];
15981 [label="IncludeNamedType(symbol.ContainingType) 250420"];
15982 [label="param IncludeNamedType(INamedTypeSymbol namedType) 250421"];
15983 [label="param IncludeNamedType(this) 250422"];
15984 [label="if (namedType is null)\n            {\n                return false;\n            } 250423"];
15985 [label="return false; 250424"];
15986 [label="AddNameAndTypeArgumentsOrParameters(symbol) 250425"];
15987 [label="param AddNameAndTypeArgumentsOrParameters(this) 250426"];
15988 [label="symbol.IsAnonymousType 250427"];
15989 [label="=> UnderlyingTypeSymbol.IsAnonymousType 250428"];
15990 [label="UnderlyingTypeSymbol 250429"];
15991 [label="=> _underlying 250430"];
15992 [label="UnderlyingTypeSymbol.IsAnonymousType 250431"];
15993 [label="get\n            {\n                return false;\n            } 250432"];
15994 [label="return false; 250433"];
15995 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 250434"];
15996 [label="symbol.IsTupleType 250435"];
15997 [label="=> UnderlyingTypeSymbol.IsTupleType 250436"];
15998 [label="UnderlyingTypeSymbol 250437"];
15999 [label="=> _underlying 250438"];
16000 [label="UnderlyingTypeSymbol.IsTupleType 250439"];
16001 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 250440"];
16002 [label="_ 250441"];
16003 [label="tupleCardinality: out _ 250442"];
16004 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 250443"];
16005 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 250444"];
16006 [label="param IsTupleTypeOfCardinality(this) 250445"];
16007 [label="IsUnboundGenericType 250446"];
16008 [label="get\n            {\n                return _unbound;\n            } 250447"];
16009 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250448"];
16010 [label="ContainingSymbol 250449"];
16011 [label="get { return _newContainer; } 250450"];
16012 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250451"];
16013 [label=".Kind 250452"];
16014 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 250453"];
16015 [label="return SymbolKind.Namespace; 250454"];
16016 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250455"];
16017 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250456"];
16018 [label="ContainingNamespace 250457"];
16019 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250458"];
16020 [label="this.ContainingSymbol 250459"];
16021 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250460"];
16022 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250461"];
16023 [label="ContainingNamespace.ContainingNamespace 250462"];
16024 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250463"];
16025 [label="this.ContainingSymbol 250464"];
16026 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250465"];
16027 [label=".IsGlobalNamespace 250466"];
16028 [label="get\n            {\n                return false;\n            } 250467"];
16029 [label="return false; 250468"];
16030 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250469"];
16031 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250470"];
16032 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250471"];
16033 [label="tupleCardinality = 0; 250472"];
16034 [label="return false; 250473"];
16035 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 250474"];
16036 [label="string symbolName = null; 250475"];
16037 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 250476"];
16038 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 250477"];
16039 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 250478"];
16040 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 250479"];
16041 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 250480"];
16042 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 250481"];
16043 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 250482"];
16044 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 250483"];
16045 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 250484"];
16046 [label="GetPartKind(symbol) 250485"];
16047 [label="symbol.TypeKind 250486"];
16048 [label="UnderlyingTypeSymbol 250487"];
16049 [label="UnderlyingTypeSymbol.TypeKind 250488"];
16050 [label="_underlyingType.TypeKind 250489"];
16051 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 250490"];
16052 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 250491"];
16053 [label="symbol.Name 250492"];
16054 [label="UnderlyingSymbol 250493"];
16055 [label="UnderlyingSymbol.Name 250494"];
16056 [label="_underlyingType.Name 250495"];
16057 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 250496"];
16058 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 250497"];
16059 [label="param RemoveAttributeSufficeIfNecessary(this) 250498"];
16060 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 250499"];
16061 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 250500"];
16062 [label="ImmutableArray<ITypeSymbol> typeArguments; 250501"];
16063 [label="typeArguments 250502"];
16064 [label="=> UnderlyingSymbol.Kind 250503"];
16065 [label="UnderlyingSymbol 250504"];
16066 [label="=> _underlying 250505"];
16067 [label="get { return OriginalDefinition.Kind; } 250506"];
16068 [label="OriginalDefinition 250507"];
16069 [label="get { return _underlyingType; } 250508"];
16070 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 250509"];
16071 [label="=> defaultType 250510"];
16072 [label="param ToPublicAnnotation(this TypeWithAnnotations type) 250511"];
16073 [label="type.Type 250512"];
16074 [label="=> _extensions?.GetResolvedType(DefaultType) 250513"];
16075 [label="=> defaultType 250514"];
16076 [label="type.NullableAnnotation 250515"];
16077 [label="param ToPublicAnnotation(NullableAnnotation annotation) 250516"];
16078 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 250517"];
16079 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 250518"];
16080 [label="get\n            {\n                return false;\n            } 250519"];
16081 [label="return false; 250520"];
16082 [label="NullableAnnotation.Oblivious 250521"];
16083 [label="param ToPublicAnnotation(NullableAnnotation annotation) 250522"];
16084 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 250523"];
16085 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 250524"];
16086 [label="get\n            {\n                return false;\n            } 250525"];
16087 [label="var first = true; 250526"];
16088 [label="if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    } 250527"];
16089 [label="first = false; 250528"];
16090 [label="AbstractSymbolDisplayVisitor visitor; 250529"];
16091 [label="=> UnderlyingSymbol.Kind 250530"];
16092 [label="UnderlyingSymbol 250531"];
16093 [label="=> _underlying 250532"];
16094 [label="_underlying 250533"];
16095 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 250534"];
16096 [label="param TryAddAlias(ArrayBuilder<SymbolDisplayPart> builder) 250535"];
16097 [label="var map = _lazyAliasMap; 250536"];
16098 [label="if (map != null)\n                {\n                    return map;\n                } 250537"];
16099 [label="if (map != null)\n                {\n                    return map;\n                } 250538"];
16100 [label="AliasMap.TryGetValue(symbol, out result) 250539"];
16101 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 250540"];
16102 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 250541"];
16103 [label="return false; 250542"];
16104 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 250543"];
16105 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 250544"];
16106 [label="underlyingType.Kind 250545"];
16107 [label="=> UnderlyingSymbol.Kind 250546"];
16108 [label="UnderlyingSymbol 250547"];
16109 [label="=> _underlying 250548"];
16110 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 250549"];
16111 [label="do\n            {\n                underlyingType = ((IArrayTypeSymbol)underlyingType).ElementType;\n            }\n            while (underlyingType.Kind == SymbolKind.ArrayType && !ShouldAddNullableAnnotation(underlyingType)); 250550"];
16112 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 250551"];
16113 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250552"];
16114 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250553"];
16115 [label="symbol.IsNativeIntegerType 250554"];
16116 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 250555"];
16117 [label="UnderlyingTypeSymbol 250556"];
16118 [label="=> _underlying 250557"];
16119 [label="UnderlyingTypeSymbol.IsNativeIntegerType 250558"];
16120 [label="=> false 250559"];
16121 [label="false 250560"];
16122 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250561"];
16123 [label="symbol.IsTupleType 250562"];
16124 [label="=> UnderlyingTypeSymbol.IsTupleType 250563"];
16125 [label="UnderlyingTypeSymbol 250564"];
16126 [label="=> _underlying 250565"];
16127 [label="UnderlyingTypeSymbol.IsTupleType 250566"];
16128 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 250567"];
16129 [label="_ 250568"];
16130 [label="tupleCardinality: out _ 250569"];
16131 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 250570"];
16132 [label="param IsTupleTypeOfCardinality(this) 250571"];
16133 [label="IsUnboundGenericType 250572"];
16134 [label="get\n            {\n                return false;\n            } 250573"];
16135 [label="return false; 250574"];
16136 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250575"];
16137 [label="ContainingSymbol 250576"];
16138 [label="get\n            {\n                return _container;\n            } 250577"];
16139 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250578"];
16140 [label=".Kind 250579"];
16141 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 250580"];
16142 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250581"];
16143 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250582"];
16144 [label="ContainingNamespace 250583"];
16145 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250584"];
16146 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250585"];
16147 [label="ContainingNamespace.ContainingNamespace 250586"];
16148 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250587"];
16149 [label=".IsGlobalNamespace 250588"];
16150 [label="get\n            {\n                return true;\n            } 250589"];
16151 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250590"];
16152 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250591"];
16153 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250592"];
16154 [label="Name 250593"];
16155 [label="get\n            {\n                return _name;\n            } 250594"];
16156 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250595"];
16157 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250596"];
16158 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250597"];
16159 [label="tupleCardinality = 0; 250598"];
16160 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 250599"];
16161 [label="AddTypeKind(symbol); 250600"];
16162 [label="AddTypeKind(symbol) 250601"];
16163 [label="param AddTypeKind(INamedTypeSymbol symbol) 250602"];
16164 [label="param AddTypeKind(this) 250603"];
16165 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 250604"];
16166 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 250605"];
16167 [label="CanShowDelegateSignature(symbol) 250606"];
16168 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250607"];
16169 [label="param CanShowDelegateSignature(this) 250608"];
16170 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250609"];
16171 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 250610"];
16172 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 250611"];
16173 [label="param ShouldVisitNamespace(this) 250612"];
16174 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 250613"];
16175 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250614"];
16176 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 250615"];
16177 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 250616"];
16178 [label="=> _underlying.IsGlobalNamespace 250617"];
16179 [label="get\n            {\n                return false;\n            } 250618"];
16180 [label="=> _underlying.IsGlobalNamespace 250619"];
16181 [label="get\n            {\n                return false;\n            } 250620"];
16182 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 250621"];
16183 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 250622"];
16184 [label="get\n            {\n                return true;\n            } 250623"];
16185 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 250624"];
16186 [label="symbol.ContainingType 250625"];
16187 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 250626"];
16188 [label="UnderlyingSymbol 250627"];
16189 [label="=> _underlying 250628"];
16190 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 250629"];
16191 [label="UnderlyingSymbol.ContainingType 250630"];
16192 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 250631"];
16193 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 250632"];
16194 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 250633"];
16195 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 250634"];
16196 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 250635"];
16197 [label="param GetPublicSymbol(this Symbol? symbol) 250636"];
16198 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 250637"];
16199 [label="IncludeNamedType(symbol.ContainingType) 250638"];
16200 [label="param IncludeNamedType(INamedTypeSymbol namedType) 250639"];
16201 [label="param IncludeNamedType(this) 250640"];
16202 [label="if (namedType is null)\n            {\n                return false;\n            } 250641"];
16203 [label="return false; 250642"];
16204 [label="symbol.IsAnonymousType 250643"];
16205 [label="=> UnderlyingTypeSymbol.IsAnonymousType 250644"];
16206 [label="UnderlyingTypeSymbol 250645"];
16207 [label="=> _underlying 250646"];
16208 [label="UnderlyingTypeSymbol.IsAnonymousType 250647"];
16209 [label="get\n            {\n                return false;\n            } 250648"];
16210 [label="return false; 250649"];
16211 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 250650"];
16212 [label="symbol.IsTupleType 250651"];
16213 [label="=> UnderlyingTypeSymbol.IsTupleType 250652"];
16214 [label="UnderlyingTypeSymbol 250653"];
16215 [label="=> _underlying 250654"];
16216 [label="UnderlyingTypeSymbol.IsTupleType 250655"];
16217 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 250656"];
16218 [label="_ 250657"];
16219 [label="tupleCardinality: out _ 250658"];
16220 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 250659"];
16221 [label="param IsTupleTypeOfCardinality(this) 250660"];
16222 [label="IsUnboundGenericType 250661"];
16223 [label="get\n            {\n                return false;\n            } 250662"];
16224 [label="return false; 250663"];
16225 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250664"];
16226 [label="ContainingSymbol 250665"];
16227 [label="get\n            {\n                return _container;\n            } 250666"];
16228 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250667"];
16229 [label=".Kind 250668"];
16230 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 250669"];
16231 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250670"];
16232 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250671"];
16233 [label="ContainingNamespace 250672"];
16234 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250673"];
16235 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250674"];
16236 [label="ContainingNamespace.ContainingNamespace 250675"];
16237 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250676"];
16238 [label=".IsGlobalNamespace 250677"];
16239 [label="get\n            {\n                return true;\n            } 250678"];
16240 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250679"];
16241 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250680"];
16242 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250681"];
16243 [label="Name 250682"];
16244 [label="get\n            {\n                return _name;\n            } 250683"];
16245 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250684"];
16246 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250685"];
16247 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250686"];
16248 [label="tupleCardinality = 0; 250687"];
16249 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 250688"];
16250 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 250689"];
16251 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 250690"];
16252 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 250691"];
16253 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 250692"];
16254 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 250693"];
16255 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 250694"];
16256 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 250695"];
16257 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 250696"];
16258 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 250697"];
16259 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 250698"];
16260 [label="param RemoveAttributeSufficeIfNecessary(this) 250699"];
16261 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 250700"];
16262 [label="get\n                {\n                    return 0;\n                } 250701"];
16263 [label="AddDelegateParameters(symbol); 250702"];
16264 [label="AddDelegateParameters(symbol) 250703"];
16265 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 250704"];
16266 [label="param AddDelegateParameters(this) 250705"];
16267 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 250706"];
16268 [label="CanShowDelegateSignature(symbol) 250707"];
16269 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250708"];
16270 [label="param CanShowDelegateSignature(this) 250709"];
16271 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250710"];
16272 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 250711"];
16273 [label=".OriginalDefinition 250712"];
16274 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 250713"];
16275 [label="AddNullableAnnotations(symbol); 250714"];
16276 [label="AddNullableAnnotations(symbol) 250715"];
16277 [label="param AddNullableAnnotations(ITypeSymbol type) 250716"];
16278 [label="param AddNullableAnnotations(this) 250717"];
16279 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250718"];
16280 [label="ShouldAddNullableAnnotation(type) 250719"];
16281 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250720"];
16282 [label="param ShouldAddNullableAnnotation(this) 250721"];
16283 [label="type.NullableAnnotation 250722"];
16284 [label="=> NullableAnnotation 250723"];
16285 [label="NullableAnnotation 250724"];
16286 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250725"];
16287 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 250726"];
16288 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 250727"];
16289 [label="return false; 250728"];
16290 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250729"];
16291 [label="if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                } 250730"];
16292 [label="arrayType.CustomModifiers 250731"];
16293 [label="=> _underlying.ElementTypeWithAnnotations.CustomModifiers 250732"];
16294 [label="_underlying.ElementTypeWithAnnotations 250733"];
16295 [label="get\n            {\n                return _elementTypeWithAnnotations;\n            } 250734"];
16296 [label="_underlying.ElementTypeWithAnnotations.CustomModifiers 250735"];
16297 [label="=> _extensions.CustomModifiers 250736"];
16298 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 250737"];
16299 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 250738"];
16300 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true) 250739"];
16301 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 250740"];
16302 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 250741"];
16303 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 250742"];
16304 [label="param AddCustomModifiersIfRequired(this) 250743"];
16305 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250744"];
16306 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250745"];
16307 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250746"];
16308 [label="AddArrayRank(arrayType); 250747"];
16309 [label="param AddArrayRank(IArrayTypeSymbol symbol) 250748"];
16310 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 250749"];
16311 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 250750"];
16312 [label="symbol.Rank 250751"];
16313 [label="=> _underlying.Rank 250752"];
16314 [label="_underlying.Rank 250753"];
16315 [label="get\n                {\n                    return 1;\n                } 250754"];
16316 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250755"];
16317 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250756"];
16318 [label="symbol.IsSZArray 250757"];
16319 [label="=> _underlying.IsSZArray 250758"];
16320 [label="_underlying.IsSZArray 250759"];
16321 [label="get\n                {\n                    return true;\n                } 250760"];
16322 [label="return true; 250761"];
16323 [label="if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                } 250762"];
16324 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250763"];
16325 [label="symbol.Rank 250764"];
16326 [label="=> _underlying.Rank 250765"];
16327 [label="_underlying.Rank 250766"];
16328 [label="get\n                {\n                    return 1;\n                } 250767"];
16329 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 250768"];
16330 [label="arrayType.ElementType 250769"];
16331 [label="arrayType = arrayType.ElementType as IArrayTypeSymbol; 250770"];
16332 [label="AddNullableAnnotations(symbol); 250771"];
16333 [label="AddNullableAnnotations(symbol) 250772"];
16334 [label="param AddNullableAnnotations(ITypeSymbol type) 250773"];
16335 [label="param AddNullableAnnotations(this) 250774"];
16336 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250775"];
16337 [label="ShouldAddNullableAnnotation(type) 250776"];
16338 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250777"];
16339 [label="param ShouldAddNullableAnnotation(this) 250778"];
16340 [label="type.NullableAnnotation 250779"];
16341 [label="=> NullableAnnotation 250780"];
16342 [label="NullableAnnotation 250781"];
16343 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250782"];
16344 [label="return false; 250783"];
16345 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250784"];
16346 [label="AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false) 250785"];
16347 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 250786"];
16348 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 250787"];
16349 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 250788"];
16350 [label="param AddCustomModifiersIfRequired(this) 250789"];
16351 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250790"];
16352 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250791"];
16353 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 250792"];
16354 [label="AddDelegateParameters(symbol); 250793"];
16355 [label="AddDelegateParameters(symbol) 250794"];
16356 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 250795"];
16357 [label="param AddDelegateParameters(this) 250796"];
16358 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 250797"];
16359 [label="CanShowDelegateSignature(symbol) 250798"];
16360 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250799"];
16361 [label="param CanShowDelegateSignature(this) 250800"];
16362 [label="symbol.TypeKind 250801"];
16363 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 250802"];
16364 [label="_underlying 250803"];
16365 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250804"];
16366 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250805"];
16367 [label="symbol.TypeArguments 250806"];
16368 [label="if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                } 250807"];
16369 [label="return _lazyTypeArguments; 250808"];
16370 [label="AddTypeParameterConstraints(symbol.TypeArguments); 250809"];
16371 [label="AddTypeParameterConstraints(symbol.TypeArguments) 250810"];
16372 [label="param AddTypeParameterConstraints(ImmutableArray<ITypeSymbol> typeArguments) 250811"];
16373 [label="param AddTypeParameterConstraints(this) 250812"];
16374 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 250813"];
16375 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 250814"];
16376 [label="AddTypeParameterConstraints(symbol.TypeArguments); 250815"];
16377 [label=".OriginalDefinition 250816"];
16378 [label="get { return _underlyingType; } 250817"];
16379 [label="return _underlyingType; 250818"];
16380 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 250819"];
16381 [label="AddNameAndTypeArgumentsOrParameters(symbol); 250820"];
16382 [label="VisitNamedTypeWithoutNullability(symbol); 250821"];
16383 [label="AddNullableAnnotations(symbol); 250822"];
16384 [label="AddNullableAnnotations(symbol) 250823"];
16385 [label="param AddNullableAnnotations(ITypeSymbol type) 250824"];
16386 [label="param AddNullableAnnotations(this) 250825"];
16387 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250826"];
16388 [label="ShouldAddNullableAnnotation(type) 250827"];
16389 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 250828"];
16390 [label="param ShouldAddNullableAnnotation(this) 250829"];
16391 [label="type.NullableAnnotation 250830"];
16392 [label="=> NullableAnnotation 250831"];
16393 [label="NullableAnnotation 250832"];
16394 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 250833"];
16395 [label="return false; 250834"];
16396 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 250835"];
16397 [label="AddNullableAnnotations(symbol); 250836"];
16398 [label="visitor.VisitNamedType(this); 250837"];
16399 [label="Accept(visitor); 250838"];
16400 [label="symbol.Accept(visitor); 250839"];
16401 [label="CustomAssert.Equal('System.Collections.IEnumerable', i5.ToTestDisplayString()); 250840"];
16402 [label="CustomAssert.Equal('System.Collections.IEnumerable', i5.ToTestDisplayString()); 250841"];
16403 [label="i5.ToTestDisplayString() 250842"];
16404 [label="param ToTestDisplayString(this Symbol symbol) 250843"];
16405 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 250844"];
16406 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 250845"];
16407 [label="param ToDisplayString(SymbolDisplayFormat format = null) 250846"];
16408 [label="param ToDisplayString(this) 250847"];
16409 [label="ISymbol 250848"];
16410 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 250849"];
16411 [label="NullableAnnotation.Oblivious 250850"];
16412 [label="param ToPublicAnnotation(NullableAnnotation annotation) 250851"];
16413 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 250852"];
16414 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 250853"];
16415 [label="var kind = TypeKind; 250854"];
16416 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 250855"];
16417 [label="param NamespaceOrTypeSymbol(this) 250856"];
16418 [label="param Symbol(this) 250857"];
16419 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 250858"];
16420 [label="_underlying 250859"];
16421 [label="Debug.Assert(underlying is object); 250860"];
16422 [label="Debug.Assert(!underlying.IsErrorType()); 250861"];
16423 [label="param IsErrorType(this TypeSymbol type) 250862"];
16424 [label="RoslynDebug.Assert((object)type != null); 250863"];
16425 [label="RoslynDebug.Assert((object)type != null); 250864"];
16426 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 250865"];
16427 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 250866"];
16428 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 250867"];
16429 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 250868"];
16430 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 250869"];
16431 [label="ToDisplayParts(symbol, format) 250870"];
16432 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 250871"];
16433 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 250872"];
16434 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 250873"];
16435 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 250874"];
16436 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 250875"];
16437 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 250876"];
16438 [label="param ToDisplayParts(int positionOpt) 250877"];
16439 [label="param ToDisplayParts(SymbolDisplayFormat format) 250878"];
16440 [label="param ToDisplayParts(bool minimal) 250879"];
16441 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 250880"];
16442 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 250881"];
16443 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 250882"];
16444 [label="Debug.Assert(semanticModelOpt == null); 250883"];
16445 [label="Debug.Assert(semanticModelOpt == null); 250884"];
16446 [label="Debug.Assert(positionOpt < 0); 250885"];
16447 [label="Debug.Assert(positionOpt < 0); 250886"];
16448 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 250887"];
16449 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 250888"];
16450 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250889"];
16451 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250890"];
16452 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250891"];
16453 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250892"];
16454 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 250893"];
16455 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 250894"];
16456 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 250895"];
16457 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 250896"];
16458 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 250897"];
16459 [label="param SymbolDisplayVisitor(int positionOpt) 250898"];
16460 [label="param SymbolDisplayVisitor(this) 250899"];
16461 [label="builder 250900"];
16462 [label="format 250901"];
16463 [label="true 250902"];
16464 [label="semanticModelOpt 250903"];
16465 [label="positionOpt 250904"];
16466 [label="param SymbolDisplayVisitor(this) 250905"];
16467 [label="_escapeKeywordIdentifiers 250906"];
16468 [label="_lazyAliasMap 250907"];
16469 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 250908"];
16470 [label="symbol.Accept(visitor); 250909"];
16471 [label="symbol.Accept(visitor) 250910"];
16472 [label="param Accept(SymbolVisitor visitor) 250911"];
16473 [label="Accept(visitor); 250912"];
16474 [label="Accept(visitor) 250913"];
16475 [label="param Accept(SymbolVisitor visitor) 250914"];
16476 [label="visitor.VisitNamedType(this) 250915"];
16477 [label="param VisitNamedType(this) 250916"];
16478 [label="VisitNamedTypeWithoutNullability(symbol) 250917"];
16479 [label="param VisitNamedTypeWithoutNullability(this) 250918"];
16480 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 250919"];
16481 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250920"];
16482 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250921"];
16483 [label="symbol.IsNativeIntegerType 250922"];
16484 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 250923"];
16485 [label="UnderlyingTypeSymbol 250924"];
16486 [label="=> _underlying 250925"];
16487 [label="UnderlyingTypeSymbol.IsNativeIntegerType 250926"];
16488 [label="=> false 250927"];
16489 [label="false 250928"];
16490 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250929"];
16491 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 250930"];
16492 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 250931"];
16493 [label="symbol.IsTupleType 250932"];
16494 [label="=> UnderlyingTypeSymbol.IsTupleType 250933"];
16495 [label="UnderlyingTypeSymbol 250934"];
16496 [label="=> _underlying 250935"];
16497 [label="UnderlyingTypeSymbol.IsTupleType 250936"];
16498 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 250937"];
16499 [label="_ 250938"];
16500 [label="tupleCardinality: out _ 250939"];
16501 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 250940"];
16502 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 250941"];
16503 [label="param IsTupleTypeOfCardinality(this) 250942"];
16504 [label="IsUnboundGenericType 250943"];
16505 [label="get\n            {\n                return false;\n            } 250944"];
16506 [label="return false; 250945"];
16507 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250946"];
16508 [label="ContainingSymbol 250947"];
16509 [label="get\n            {\n                return _container;\n            } 250948"];
16510 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250949"];
16511 [label=".Kind 250950"];
16512 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 250951"];
16513 [label="return SymbolKind.Namespace; 250952"];
16514 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250953"];
16515 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250954"];
16516 [label="ContainingNamespace 250955"];
16517 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250956"];
16518 [label="this.ContainingSymbol 250957"];
16519 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250958"];
16520 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250959"];
16521 [label="ContainingNamespace.ContainingNamespace 250960"];
16522 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 250961"];
16523 [label="this.ContainingSymbol 250962"];
16524 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 250963"];
16525 [label=".IsGlobalNamespace 250964"];
16526 [label="get\n            {\n                return false;\n            } 250965"];
16527 [label="return false; 250966"];
16528 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250967"];
16529 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250968"];
16530 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 250969"];
16531 [label="tupleCardinality = 0; 250970"];
16532 [label="return false; 250971"];
16533 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 250972"];
16534 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 250973"];
16535 [label="AddTypeKind(symbol); 250974"];
16536 [label="AddTypeKind(symbol) 250975"];
16537 [label="param AddTypeKind(INamedTypeSymbol symbol) 250976"];
16538 [label="param AddTypeKind(this) 250977"];
16539 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 250978"];
16540 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 250979"];
16541 [label="AddTypeKind(symbol); 250980"];
16542 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 250981"];
16543 [label="CanShowDelegateSignature(symbol) 250982"];
16544 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 250983"];
16545 [label="param CanShowDelegateSignature(this) 250984"];
16546 [label="symbol.TypeKind 250985"];
16547 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 250986"];
16548 [label="UnderlyingTypeSymbol 250987"];
16549 [label="UnderlyingTypeSymbol.TypeKind 250988"];
16550 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250989"];
16551 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 250990"];
16552 [label="symbol.ContainingSymbol 250991"];
16553 [label="UnderlyingSymbol 250992"];
16554 [label="UnderlyingSymbol.ContainingSymbol 250993"];
16555 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 250994"];
16556 [label="symbol.GetPublicSymbol<ISymbol>() 250995"];
16557 [label=".ISymbol 250996"];
16558 [label="ShouldVisitNamespace(containingSymbol) 250997"];
16559 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 250998"];
16560 [label="param ShouldVisitNamespace(this) 250999"];
16561 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251000"];
16562 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251001"];
16563 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251002"];
16564 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251003"];
16565 [label="namespaceSymbol.IsGlobalNamespace 251004"];
16566 [label="=> _underlying.IsGlobalNamespace 251005"];
16567 [label="_underlying.IsGlobalNamespace 251006"];
16568 [label="get\n            {\n                return false;\n            } 251007"];
16569 [label="return false; 251008"];
16570 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 251009"];
16571 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 251010"];
16572 [label="namespaceSymbol.IsGlobalNamespace 251011"];
16573 [label="=> _underlying.IsGlobalNamespace 251012"];
16574 [label="get\n            {\n                return false;\n            } 251013"];
16575 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 251014"];
16576 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 251015"];
16577 [label="this.NotFirstVisitor 251016"];
16578 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 251017"];
16579 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 251018"];
16580 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 251019"];
16581 [label="param SymbolDisplayVisitor(this) 251020"];
16582 [label="isFirstSymbolVisited 251021"];
16583 [label="param SymbolDisplayVisitor(this) 251022"];
16584 [label="_escapeKeywordIdentifiers 251023"];
16585 [label="_lazyAliasMap 251024"];
16586 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251025"];
16587 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 251026"];
16588 [label="visitor.VisitNamespace(this) 251027"];
16589 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251028"];
16590 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251029"];
16591 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 251030"];
16592 [label="param ShouldVisitNamespace(this) 251031"];
16593 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251032"];
16594 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251033"];
16595 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251034"];
16596 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251035"];
16597 [label="=> _underlying.IsGlobalNamespace 251036"];
16598 [label="get\n            {\n                return false;\n            } 251037"];
16599 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251038"];
16600 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251039"];
16601 [label="get\n            {\n                return true;\n            } 251040"];
16602 [label="=> _underlying.IsGlobalNamespace 251041"];
16603 [label="get\n            {\n                return false;\n            } 251042"];
16604 [label="symbol.IsGlobalNamespace 251043"];
16605 [label="=> _underlying.IsGlobalNamespace 251044"];
16606 [label="get\n            {\n                return false;\n            } 251045"];
16607 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 251046"];
16608 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 251047"];
16609 [label="symbol.Name 251048"];
16610 [label="UnderlyingSymbol 251049"];
16611 [label="UnderlyingSymbol.Name 251050"];
16612 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 251051"];
16613 [label="param CreatePart(SymbolDisplayPartKind kind) 251052"];
16614 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251053"];
16615 [label="return new SymbolDisplayPart(kind, symbol, text); 251054"];
16616 [label="visitor.VisitNamespace(this); 251055"];
16617 [label="Accept(visitor); 251056"];
16618 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251057"];
16619 [label="namespaceSymbol.IsGlobalNamespace 251058"];
16620 [label="=> _underlying.IsGlobalNamespace 251059"];
16621 [label="get\n            {\n                return false;\n            } 251060"];
16622 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251061"];
16623 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 251062"];
16624 [label="param AddPunctuation(this) 251063"];
16625 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251064"];
16626 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251065"];
16627 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 251066"];
16628 [label="param CreatePart(SymbolDisplayPartKind kind) 251067"];
16629 [label="param CreatePart(ISymbol symbol) 251068"];
16630 [label="param CreatePart(this) 251069"];
16631 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251070"];
16632 [label="return new SymbolDisplayPart(kind, symbol, text); 251071"];
16633 [label="return new SymbolDisplayPart(kind, symbol, text); 251072"];
16634 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251073"];
16635 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 251074"];
16636 [label="symbol.ContainingType 251075"];
16637 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 251076"];
16638 [label="UnderlyingSymbol 251077"];
16639 [label="=> _underlying 251078"];
16640 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 251079"];
16641 [label="UnderlyingSymbol.ContainingType 251080"];
16642 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 251081"];
16643 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 251082"];
16644 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 251083"];
16645 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 251084"];
16646 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 251085"];
16647 [label="param GetPublicSymbol(this Symbol? symbol) 251086"];
16648 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 251087"];
16649 [label="IncludeNamedType(symbol.ContainingType) 251088"];
16650 [label="param IncludeNamedType(INamedTypeSymbol namedType) 251089"];
16651 [label="param IncludeNamedType(this) 251090"];
16652 [label="if (namedType is null)\n            {\n                return false;\n            } 251091"];
16653 [label="return false; 251092"];
16654 [label="AddNameAndTypeArgumentsOrParameters(symbol) 251093"];
16655 [label="param AddNameAndTypeArgumentsOrParameters(this) 251094"];
16656 [label="symbol.IsAnonymousType 251095"];
16657 [label="=> UnderlyingTypeSymbol.IsAnonymousType 251096"];
16658 [label="UnderlyingTypeSymbol 251097"];
16659 [label="=> _underlying 251098"];
16660 [label="UnderlyingTypeSymbol.IsAnonymousType 251099"];
16661 [label="get\n            {\n                return false;\n            } 251100"];
16662 [label="return false; 251101"];
16663 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251102"];
16664 [label="symbol.IsTupleType 251103"];
16665 [label="=> UnderlyingTypeSymbol.IsTupleType 251104"];
16666 [label="UnderlyingTypeSymbol 251105"];
16667 [label="=> _underlying 251106"];
16668 [label="UnderlyingTypeSymbol.IsTupleType 251107"];
16669 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251108"];
16670 [label="_ 251109"];
16671 [label="tupleCardinality: out _ 251110"];
16672 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 251111"];
16673 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251112"];
16674 [label="param IsTupleTypeOfCardinality(this) 251113"];
16675 [label="IsUnboundGenericType 251114"];
16676 [label="get\n            {\n                return false;\n            } 251115"];
16677 [label="return false; 251116"];
16678 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251117"];
16679 [label="ContainingSymbol 251118"];
16680 [label="get\n            {\n                return _container;\n            } 251119"];
16681 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251120"];
16682 [label=".Kind 251121"];
16683 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251122"];
16684 [label="return SymbolKind.Namespace; 251123"];
16685 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251124"];
16686 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251125"];
16687 [label="ContainingNamespace 251126"];
16688 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251127"];
16689 [label="this.ContainingSymbol 251128"];
16690 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251129"];
16691 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251130"];
16692 [label="ContainingNamespace.ContainingNamespace 251131"];
16693 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251132"];
16694 [label="this.ContainingSymbol 251133"];
16695 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251134"];
16696 [label=".IsGlobalNamespace 251135"];
16697 [label="get\n            {\n                return false;\n            } 251136"];
16698 [label="return false; 251137"];
16699 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251138"];
16700 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251139"];
16701 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251140"];
16702 [label="tupleCardinality = 0; 251141"];
16703 [label="return false; 251142"];
16704 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251143"];
16705 [label="string symbolName = null; 251144"];
16706 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 251145"];
16707 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251146"];
16708 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251147"];
16709 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 251148"];
16710 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251149"];
16711 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251150"];
16712 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 251151"];
16713 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251152"];
16714 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251153"];
16715 [label="GetPartKind(symbol) 251154"];
16716 [label="symbol.TypeKind 251155"];
16717 [label="UnderlyingTypeSymbol 251156"];
16718 [label="UnderlyingTypeSymbol.TypeKind 251157"];
16719 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251158"];
16720 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251159"];
16721 [label="symbol.Name 251160"];
16722 [label="UnderlyingSymbol 251161"];
16723 [label="UnderlyingSymbol.Name 251162"];
16724 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 251163"];
16725 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 251164"];
16726 [label="param RemoveAttributeSufficeIfNecessary(this) 251165"];
16727 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 251166"];
16728 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 251167"];
16729 [label="get\n                {\n                    return 0;\n                } 251168"];
16730 [label="AddDelegateParameters(symbol); 251169"];
16731 [label="AddDelegateParameters(symbol) 251170"];
16732 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 251171"];
16733 [label="param AddDelegateParameters(this) 251172"];
16734 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 251173"];
16735 [label="CanShowDelegateSignature(symbol) 251174"];
16736 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 251175"];
16737 [label="param CanShowDelegateSignature(this) 251176"];
16738 [label="symbol.TypeKind 251177"];
16739 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 251178"];
16740 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251179"];
16741 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251180"];
16742 [label=".OriginalDefinition 251181"];
16743 [label="get\n            {\n                return this;\n            } 251182"];
16744 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 251183"];
16745 [label="AddNameAndTypeArgumentsOrParameters(symbol); 251184"];
16746 [label="VisitNamedTypeWithoutNullability(symbol); 251185"];
16747 [label="AddNullableAnnotations(symbol); 251186"];
16748 [label="AddNullableAnnotations(symbol) 251187"];
16749 [label="param AddNullableAnnotations(ITypeSymbol type) 251188"];
16750 [label="param AddNullableAnnotations(this) 251189"];
16751 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 251190"];
16752 [label="ShouldAddNullableAnnotation(type) 251191"];
16753 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 251192"];
16754 [label="param ShouldAddNullableAnnotation(this) 251193"];
16755 [label="type.NullableAnnotation 251194"];
16756 [label="=> NullableAnnotation 251195"];
16757 [label="NullableAnnotation 251196"];
16758 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 251197"];
16759 [label="return false; 251198"];
16760 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 251199"];
16761 [label="AddNullableAnnotations(symbol); 251200"];
16762 [label="visitor.VisitNamedType(this); 251201"];
16763 [label="Accept(visitor); 251202"];
16764 [label="symbol.Accept(visitor); 251203"];
16765 [label="CustomAssert.Equal('System.Collections.IList', i6.ToTestDisplayString()); 251204"];
16766 [label="CustomAssert.Equal('System.Collections.IList', i6.ToTestDisplayString()); 251205"];
16767 [label="i6.ToTestDisplayString() 251206"];
16768 [label="param ToTestDisplayString(this Symbol symbol) 251207"];
16769 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 251208"];
16770 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 251209"];
16771 [label="param ToDisplayString(SymbolDisplayFormat format = null) 251210"];
16772 [label="param ToDisplayString(this) 251211"];
16773 [label="ISymbol 251212"];
16774 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 251213"];
16775 [label="NullableAnnotation.Oblivious 251214"];
16776 [label="param ToPublicAnnotation(NullableAnnotation annotation) 251215"];
16777 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 251216"];
16778 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 251217"];
16779 [label="var kind = TypeKind; 251218"];
16780 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 251219"];
16781 [label="param NamespaceOrTypeSymbol(this) 251220"];
16782 [label="param Symbol(this) 251221"];
16783 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 251222"];
16784 [label="_underlying 251223"];
16785 [label="Debug.Assert(underlying is object); 251224"];
16786 [label="Debug.Assert(!underlying.IsErrorType()); 251225"];
16787 [label="param IsErrorType(this TypeSymbol type) 251226"];
16788 [label="RoslynDebug.Assert((object)type != null); 251227"];
16789 [label="RoslynDebug.Assert((object)type != null); 251228"];
16790 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 251229"];
16791 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 251230"];
16792 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 251231"];
16793 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 251232"];
16794 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 251233"];
16795 [label="ToDisplayParts(symbol, format) 251234"];
16796 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 251235"];
16797 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 251236"];
16798 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 251237"];
16799 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 251238"];
16800 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 251239"];
16801 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 251240"];
16802 [label="param ToDisplayParts(int positionOpt) 251241"];
16803 [label="param ToDisplayParts(SymbolDisplayFormat format) 251242"];
16804 [label="param ToDisplayParts(bool minimal) 251243"];
16805 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 251244"];
16806 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 251245"];
16807 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 251246"];
16808 [label="Debug.Assert(semanticModelOpt == null); 251247"];
16809 [label="Debug.Assert(semanticModelOpt == null); 251248"];
16810 [label="Debug.Assert(positionOpt < 0); 251249"];
16811 [label="Debug.Assert(positionOpt < 0); 251250"];
16812 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 251251"];
16813 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 251252"];
16814 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251253"];
16815 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251254"];
16816 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251255"];
16817 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251256"];
16818 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251257"];
16819 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 251258"];
16820 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 251259"];
16821 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 251260"];
16822 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 251261"];
16823 [label="param SymbolDisplayVisitor(int positionOpt) 251262"];
16824 [label="param SymbolDisplayVisitor(this) 251263"];
16825 [label="builder 251264"];
16826 [label="format 251265"];
16827 [label="true 251266"];
16828 [label="semanticModelOpt 251267"];
16829 [label="positionOpt 251268"];
16830 [label="param SymbolDisplayVisitor(this) 251269"];
16831 [label="_escapeKeywordIdentifiers 251270"];
16832 [label="_lazyAliasMap 251271"];
16833 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 251272"];
16834 [label="symbol.Accept(visitor); 251273"];
16835 [label="symbol.Accept(visitor) 251274"];
16836 [label="param Accept(SymbolVisitor visitor) 251275"];
16837 [label="Accept(visitor); 251276"];
16838 [label="Accept(visitor) 251277"];
16839 [label="param Accept(SymbolVisitor visitor) 251278"];
16840 [label="visitor.VisitNamedType(this) 251279"];
16841 [label="param VisitNamedType(this) 251280"];
16842 [label="VisitNamedTypeWithoutNullability(symbol) 251281"];
16843 [label="param VisitNamedTypeWithoutNullability(this) 251282"];
16844 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 251283"];
16845 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251284"];
16846 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251285"];
16847 [label="symbol.IsNativeIntegerType 251286"];
16848 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 251287"];
16849 [label="UnderlyingTypeSymbol 251288"];
16850 [label="=> _underlying 251289"];
16851 [label="UnderlyingTypeSymbol.IsNativeIntegerType 251290"];
16852 [label="=> false 251291"];
16853 [label="false 251292"];
16854 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251293"];
16855 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251294"];
16856 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 251295"];
16857 [label="symbol.IsTupleType 251296"];
16858 [label="=> UnderlyingTypeSymbol.IsTupleType 251297"];
16859 [label="UnderlyingTypeSymbol 251298"];
16860 [label="=> _underlying 251299"];
16861 [label="UnderlyingTypeSymbol.IsTupleType 251300"];
16862 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251301"];
16863 [label="_ 251302"];
16864 [label="tupleCardinality: out _ 251303"];
16865 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 251304"];
16866 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251305"];
16867 [label="param IsTupleTypeOfCardinality(this) 251306"];
16868 [label="IsUnboundGenericType 251307"];
16869 [label="get\n            {\n                return false;\n            } 251308"];
16870 [label="return false; 251309"];
16871 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251310"];
16872 [label="ContainingSymbol 251311"];
16873 [label="get\n            {\n                return _container;\n            } 251312"];
16874 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251313"];
16875 [label=".Kind 251314"];
16876 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251315"];
16877 [label="return SymbolKind.Namespace; 251316"];
16878 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251317"];
16879 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251318"];
16880 [label="ContainingNamespace 251319"];
16881 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251320"];
16882 [label="this.ContainingSymbol 251321"];
16883 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251322"];
16884 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251323"];
16885 [label="ContainingNamespace.ContainingNamespace 251324"];
16886 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251325"];
16887 [label="this.ContainingSymbol 251326"];
16888 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251327"];
16889 [label=".IsGlobalNamespace 251328"];
16890 [label="get\n            {\n                return false;\n            } 251329"];
16891 [label="return false; 251330"];
16892 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251331"];
16893 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251332"];
16894 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251333"];
16895 [label="tupleCardinality = 0; 251334"];
16896 [label="return false; 251335"];
16897 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 251336"];
16898 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 251337"];
16899 [label="AddTypeKind(symbol); 251338"];
16900 [label="AddTypeKind(symbol) 251339"];
16901 [label="param AddTypeKind(INamedTypeSymbol symbol) 251340"];
16902 [label="param AddTypeKind(this) 251341"];
16903 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 251342"];
16904 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 251343"];
16905 [label="AddTypeKind(symbol); 251344"];
16906 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 251345"];
16907 [label="CanShowDelegateSignature(symbol) 251346"];
16908 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 251347"];
16909 [label="param CanShowDelegateSignature(this) 251348"];
16910 [label="symbol.TypeKind 251349"];
16911 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 251350"];
16912 [label="UnderlyingTypeSymbol 251351"];
16913 [label="UnderlyingTypeSymbol.TypeKind 251352"];
16914 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251353"];
16915 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251354"];
16916 [label="symbol.ContainingSymbol 251355"];
16917 [label="UnderlyingSymbol 251356"];
16918 [label="UnderlyingSymbol.ContainingSymbol 251357"];
16919 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 251358"];
16920 [label="symbol.GetPublicSymbol<ISymbol>() 251359"];
16921 [label=".ISymbol 251360"];
16922 [label="ShouldVisitNamespace(containingSymbol) 251361"];
16923 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 251362"];
16924 [label="param ShouldVisitNamespace(this) 251363"];
16925 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251364"];
16926 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251365"];
16927 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251366"];
16928 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251367"];
16929 [label="namespaceSymbol.IsGlobalNamespace 251368"];
16930 [label="=> _underlying.IsGlobalNamespace 251369"];
16931 [label="_underlying.IsGlobalNamespace 251370"];
16932 [label="get\n            {\n                return false;\n            } 251371"];
16933 [label="return false; 251372"];
16934 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 251373"];
16935 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 251374"];
16936 [label="namespaceSymbol.IsGlobalNamespace 251375"];
16937 [label="=> _underlying.IsGlobalNamespace 251376"];
16938 [label="get\n            {\n                return false;\n            } 251377"];
16939 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 251378"];
16940 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 251379"];
16941 [label="this.NotFirstVisitor 251380"];
16942 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 251381"];
16943 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 251382"];
16944 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 251383"];
16945 [label="param SymbolDisplayVisitor(this) 251384"];
16946 [label="isFirstSymbolVisited 251385"];
16947 [label="param SymbolDisplayVisitor(this) 251386"];
16948 [label="_escapeKeywordIdentifiers 251387"];
16949 [label="_lazyAliasMap 251388"];
16950 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251389"];
16951 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 251390"];
16952 [label="visitor.VisitNamespace(this) 251391"];
16953 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251392"];
16954 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251393"];
16955 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 251394"];
16956 [label="param ShouldVisitNamespace(this) 251395"];
16957 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251396"];
16958 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251397"];
16959 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251398"];
16960 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251399"];
16961 [label="=> _underlying.IsGlobalNamespace 251400"];
16962 [label="get\n            {\n                return false;\n            } 251401"];
16963 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251402"];
16964 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251403"];
16965 [label="get\n            {\n                return true;\n            } 251404"];
16966 [label="=> _underlying.IsGlobalNamespace 251405"];
16967 [label="get\n            {\n                return false;\n            } 251406"];
16968 [label="symbol.IsGlobalNamespace 251407"];
16969 [label="=> _underlying.IsGlobalNamespace 251408"];
16970 [label="get\n            {\n                return false;\n            } 251409"];
16971 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 251410"];
16972 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 251411"];
16973 [label="symbol.Name 251412"];
16974 [label="UnderlyingSymbol 251413"];
16975 [label="UnderlyingSymbol.Name 251414"];
16976 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 251415"];
16977 [label="param CreatePart(SymbolDisplayPartKind kind) 251416"];
16978 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251417"];
16979 [label="return new SymbolDisplayPart(kind, symbol, text); 251418"];
16980 [label="visitor.VisitNamespace(this); 251419"];
16981 [label="Accept(visitor); 251420"];
16982 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251421"];
16983 [label="namespaceSymbol.IsGlobalNamespace 251422"];
16984 [label="=> _underlying.IsGlobalNamespace 251423"];
16985 [label="get\n            {\n                return false;\n            } 251424"];
16986 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251425"];
16987 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 251426"];
16988 [label="param AddPunctuation(this) 251427"];
16989 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251428"];
16990 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251429"];
16991 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 251430"];
16992 [label="param CreatePart(SymbolDisplayPartKind kind) 251431"];
16993 [label="param CreatePart(ISymbol symbol) 251432"];
16994 [label="param CreatePart(this) 251433"];
16995 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251434"];
16996 [label="return new SymbolDisplayPart(kind, symbol, text); 251435"];
16997 [label="return new SymbolDisplayPart(kind, symbol, text); 251436"];
16998 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251437"];
16999 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 251438"];
17000 [label="symbol.ContainingType 251439"];
17001 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 251440"];
17002 [label="UnderlyingSymbol 251441"];
17003 [label="=> _underlying 251442"];
17004 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 251443"];
17005 [label="UnderlyingSymbol.ContainingType 251444"];
17006 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 251445"];
17007 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 251446"];
17008 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 251447"];
17009 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 251448"];
17010 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 251449"];
17011 [label="param GetPublicSymbol(this Symbol? symbol) 251450"];
17012 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 251451"];
17013 [label="IncludeNamedType(symbol.ContainingType) 251452"];
17014 [label="param IncludeNamedType(INamedTypeSymbol namedType) 251453"];
17015 [label="param IncludeNamedType(this) 251454"];
17016 [label="if (namedType is null)\n            {\n                return false;\n            } 251455"];
17017 [label="return false; 251456"];
17018 [label="AddNameAndTypeArgumentsOrParameters(symbol) 251457"];
17019 [label="param AddNameAndTypeArgumentsOrParameters(this) 251458"];
17020 [label="symbol.IsAnonymousType 251459"];
17021 [label="=> UnderlyingTypeSymbol.IsAnonymousType 251460"];
17022 [label="UnderlyingTypeSymbol 251461"];
17023 [label="=> _underlying 251462"];
17024 [label="UnderlyingTypeSymbol.IsAnonymousType 251463"];
17025 [label="get\n            {\n                return false;\n            } 251464"];
17026 [label="return false; 251465"];
17027 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251466"];
17028 [label="symbol.IsTupleType 251467"];
17029 [label="=> UnderlyingTypeSymbol.IsTupleType 251468"];
17030 [label="UnderlyingTypeSymbol 251469"];
17031 [label="=> _underlying 251470"];
17032 [label="UnderlyingTypeSymbol.IsTupleType 251471"];
17033 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251472"];
17034 [label="_ 251473"];
17035 [label="tupleCardinality: out _ 251474"];
17036 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 251475"];
17037 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251476"];
17038 [label="param IsTupleTypeOfCardinality(this) 251477"];
17039 [label="IsUnboundGenericType 251478"];
17040 [label="get\n            {\n                return false;\n            } 251479"];
17041 [label="return false; 251480"];
17042 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251481"];
17043 [label="ContainingSymbol 251482"];
17044 [label="get\n            {\n                return _container;\n            } 251483"];
17045 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251484"];
17046 [label=".Kind 251485"];
17047 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251486"];
17048 [label="return SymbolKind.Namespace; 251487"];
17049 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251488"];
17050 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251489"];
17051 [label="ContainingNamespace 251490"];
17052 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251491"];
17053 [label="this.ContainingSymbol 251492"];
17054 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251493"];
17055 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251494"];
17056 [label="ContainingNamespace.ContainingNamespace 251495"];
17057 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251496"];
17058 [label="this.ContainingSymbol 251497"];
17059 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251498"];
17060 [label=".IsGlobalNamespace 251499"];
17061 [label="get\n            {\n                return false;\n            } 251500"];
17062 [label="return false; 251501"];
17063 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251502"];
17064 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251503"];
17065 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251504"];
17066 [label="tupleCardinality = 0; 251505"];
17067 [label="return false; 251506"];
17068 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251507"];
17069 [label="string symbolName = null; 251508"];
17070 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 251509"];
17071 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251510"];
17072 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251511"];
17073 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 251512"];
17074 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251513"];
17075 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251514"];
17076 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 251515"];
17077 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251516"];
17078 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251517"];
17079 [label="GetPartKind(symbol) 251518"];
17080 [label="symbol.TypeKind 251519"];
17081 [label="UnderlyingTypeSymbol 251520"];
17082 [label="UnderlyingTypeSymbol.TypeKind 251521"];
17083 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251522"];
17084 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251523"];
17085 [label="symbol.Name 251524"];
17086 [label="UnderlyingSymbol 251525"];
17087 [label="UnderlyingSymbol.Name 251526"];
17088 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 251527"];
17089 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 251528"];
17090 [label="param RemoveAttributeSufficeIfNecessary(this) 251529"];
17091 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 251530"];
17092 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 251531"];
17093 [label="get\n                {\n                    return 0;\n                } 251532"];
17094 [label="AddDelegateParameters(symbol); 251533"];
17095 [label="AddDelegateParameters(symbol) 251534"];
17096 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 251535"];
17097 [label="param AddDelegateParameters(this) 251536"];
17098 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 251537"];
17099 [label="CanShowDelegateSignature(symbol) 251538"];
17100 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 251539"];
17101 [label="param CanShowDelegateSignature(this) 251540"];
17102 [label="symbol.TypeKind 251541"];
17103 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 251542"];
17104 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251543"];
17105 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251544"];
17106 [label=".OriginalDefinition 251545"];
17107 [label="get\n            {\n                return this;\n            } 251546"];
17108 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 251547"];
17109 [label="AddNameAndTypeArgumentsOrParameters(symbol); 251548"];
17110 [label="VisitNamedTypeWithoutNullability(symbol); 251549"];
17111 [label="AddNullableAnnotations(symbol); 251550"];
17112 [label="AddNullableAnnotations(symbol) 251551"];
17113 [label="param AddNullableAnnotations(ITypeSymbol type) 251552"];
17114 [label="param AddNullableAnnotations(this) 251553"];
17115 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 251554"];
17116 [label="ShouldAddNullableAnnotation(type) 251555"];
17117 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 251556"];
17118 [label="param ShouldAddNullableAnnotation(this) 251557"];
17119 [label="type.NullableAnnotation 251558"];
17120 [label="=> NullableAnnotation 251559"];
17121 [label="NullableAnnotation 251560"];
17122 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 251561"];
17123 [label="return false; 251562"];
17124 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 251563"];
17125 [label="AddNullableAnnotations(symbol); 251564"];
17126 [label="visitor.VisitNamedType(this); 251565"];
17127 [label="Accept(visitor); 251566"];
17128 [label="symbol.Accept(visitor); 251567"];
17129 [label="CustomAssert.Equal('System.Collections.Generic.IList<System.Byte[]>', i7.ToTestDisplayString()); 251568"];
17130 [label="CustomAssert.Equal('System.Collections.Generic.IList<System.Byte[]>', i7.ToTestDisplayString()); 251569"];
17131 [label="i7.ToTestDisplayString() 251570"];
17132 [label="param ToTestDisplayString(this Symbol symbol) 251571"];
17133 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 251572"];
17134 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 251573"];
17135 [label="param ToDisplayString(SymbolDisplayFormat format = null) 251574"];
17136 [label="param ToDisplayString(this) 251575"];
17137 [label="ISymbol 251576"];
17138 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 251577"];
17139 [label="NullableAnnotation.Oblivious 251578"];
17140 [label="param ToPublicAnnotation(NullableAnnotation annotation) 251579"];
17141 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 251580"];
17142 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 251581"];
17143 [label="var kind = TypeKind; 251582"];
17144 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 251583"];
17145 [label="param NamespaceOrTypeSymbol(this) 251584"];
17146 [label="param Symbol(this) 251585"];
17147 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 251586"];
17148 [label="_underlying 251587"];
17149 [label="Debug.Assert(underlying is object); 251588"];
17150 [label="Debug.Assert(!underlying.IsErrorType()); 251589"];
17151 [label="param IsErrorType(this TypeSymbol type) 251590"];
17152 [label="RoslynDebug.Assert((object)type != null); 251591"];
17153 [label="RoslynDebug.Assert((object)type != null); 251592"];
17154 [label="get { return OriginalDefinition.Kind; } 251593"];
17155 [label="OriginalDefinition 251594"];
17156 [label="get { return _underlyingType; } 251595"];
17157 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 251596"];
17158 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 251597"];
17159 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 251598"];
17160 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 251599"];
17161 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 251600"];
17162 [label="ToDisplayParts(symbol, format) 251601"];
17163 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 251602"];
17164 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 251603"];
17165 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 251604"];
17166 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 251605"];
17167 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 251606"];
17168 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 251607"];
17169 [label="param ToDisplayParts(int positionOpt) 251608"];
17170 [label="param ToDisplayParts(SymbolDisplayFormat format) 251609"];
17171 [label="param ToDisplayParts(bool minimal) 251610"];
17172 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 251611"];
17173 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 251612"];
17174 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 251613"];
17175 [label="Debug.Assert(semanticModelOpt == null); 251614"];
17176 [label="Debug.Assert(semanticModelOpt == null); 251615"];
17177 [label="Debug.Assert(positionOpt < 0); 251616"];
17178 [label="Debug.Assert(positionOpt < 0); 251617"];
17179 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 251618"];
17180 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 251619"];
17181 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251620"];
17182 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251621"];
17183 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251622"];
17184 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251623"];
17185 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 251624"];
17186 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 251625"];
17187 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 251626"];
17188 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 251627"];
17189 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 251628"];
17190 [label="param SymbolDisplayVisitor(int positionOpt) 251629"];
17191 [label="param SymbolDisplayVisitor(this) 251630"];
17192 [label="builder 251631"];
17193 [label="format 251632"];
17194 [label="true 251633"];
17195 [label="semanticModelOpt 251634"];
17196 [label="positionOpt 251635"];
17197 [label="param SymbolDisplayVisitor(this) 251636"];
17198 [label="_escapeKeywordIdentifiers 251637"];
17199 [label="_lazyAliasMap 251638"];
17200 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 251639"];
17201 [label="symbol.Accept(visitor); 251640"];
17202 [label="symbol.Accept(visitor) 251641"];
17203 [label="param Accept(SymbolVisitor visitor) 251642"];
17204 [label="Accept(visitor); 251643"];
17205 [label="Accept(visitor) 251644"];
17206 [label="param Accept(SymbolVisitor visitor) 251645"];
17207 [label="visitor.VisitNamedType(this) 251646"];
17208 [label="param VisitNamedType(this) 251647"];
17209 [label="VisitNamedTypeWithoutNullability(symbol) 251648"];
17210 [label="param VisitNamedTypeWithoutNullability(this) 251649"];
17211 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 251650"];
17212 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251651"];
17213 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251652"];
17214 [label="symbol.IsNativeIntegerType 251653"];
17215 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 251654"];
17216 [label="UnderlyingTypeSymbol 251655"];
17217 [label="=> _underlying 251656"];
17218 [label="UnderlyingTypeSymbol.IsNativeIntegerType 251657"];
17219 [label="=> false 251658"];
17220 [label="false 251659"];
17221 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251660"];
17222 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251661"];
17223 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 251662"];
17224 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 251663"];
17225 [label="symbol.IsTupleType 251664"];
17226 [label="=> UnderlyingTypeSymbol.IsTupleType 251665"];
17227 [label="UnderlyingTypeSymbol 251666"];
17228 [label="=> _underlying 251667"];
17229 [label="UnderlyingTypeSymbol.IsTupleType 251668"];
17230 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251669"];
17231 [label="_ 251670"];
17232 [label="tupleCardinality: out _ 251671"];
17233 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 251672"];
17234 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251673"];
17235 [label="param IsTupleTypeOfCardinality(this) 251674"];
17236 [label="IsUnboundGenericType 251675"];
17237 [label="get\n            {\n                return _unbound;\n            } 251676"];
17238 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251677"];
17239 [label="ContainingSymbol 251678"];
17240 [label="get { return _newContainer; } 251679"];
17241 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251680"];
17242 [label=".Kind 251681"];
17243 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251682"];
17244 [label="return SymbolKind.Namespace; 251683"];
17245 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251684"];
17246 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251685"];
17247 [label="ContainingNamespace 251686"];
17248 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251687"];
17249 [label="this.ContainingSymbol 251688"];
17250 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251689"];
17251 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251690"];
17252 [label="ContainingNamespace.ContainingNamespace 251691"];
17253 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251692"];
17254 [label="this.ContainingSymbol 251693"];
17255 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251694"];
17256 [label=".IsGlobalNamespace 251695"];
17257 [label="get\n            {\n                return false;\n            } 251696"];
17258 [label="return false; 251697"];
17259 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251698"];
17260 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251699"];
17261 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251700"];
17262 [label="tupleCardinality = 0; 251701"];
17263 [label="return false; 251702"];
17264 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 251703"];
17265 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 251704"];
17266 [label="AddTypeKind(symbol); 251705"];
17267 [label="AddTypeKind(symbol) 251706"];
17268 [label="param AddTypeKind(INamedTypeSymbol symbol) 251707"];
17269 [label="param AddTypeKind(this) 251708"];
17270 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 251709"];
17271 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 251710"];
17272 [label="AddTypeKind(symbol); 251711"];
17273 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 251712"];
17274 [label="CanShowDelegateSignature(symbol) 251713"];
17275 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 251714"];
17276 [label="param CanShowDelegateSignature(this) 251715"];
17277 [label="symbol.TypeKind 251716"];
17278 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 251717"];
17279 [label="UnderlyingTypeSymbol 251718"];
17280 [label="UnderlyingTypeSymbol.TypeKind 251719"];
17281 [label="_underlyingType.TypeKind 251720"];
17282 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251721"];
17283 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 251722"];
17284 [label="symbol.ContainingSymbol 251723"];
17285 [label="UnderlyingSymbol 251724"];
17286 [label="UnderlyingSymbol.ContainingSymbol 251725"];
17287 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 251726"];
17288 [label="symbol.GetPublicSymbol<ISymbol>() 251727"];
17289 [label=".ISymbol 251728"];
17290 [label="ShouldVisitNamespace(containingSymbol) 251729"];
17291 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 251730"];
17292 [label="param ShouldVisitNamespace(this) 251731"];
17293 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251732"];
17294 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251733"];
17295 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251734"];
17296 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251735"];
17297 [label="namespaceSymbol.IsGlobalNamespace 251736"];
17298 [label="=> _underlying.IsGlobalNamespace 251737"];
17299 [label="_underlying.IsGlobalNamespace 251738"];
17300 [label="get\n            {\n                return false;\n            } 251739"];
17301 [label="return false; 251740"];
17302 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 251741"];
17303 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 251742"];
17304 [label="namespaceSymbol.IsGlobalNamespace 251743"];
17305 [label="=> _underlying.IsGlobalNamespace 251744"];
17306 [label="get\n            {\n                return false;\n            } 251745"];
17307 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 251746"];
17308 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 251747"];
17309 [label="this.NotFirstVisitor 251748"];
17310 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 251749"];
17311 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 251750"];
17312 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 251751"];
17313 [label="param SymbolDisplayVisitor(this) 251752"];
17314 [label="isFirstSymbolVisited 251753"];
17315 [label="param SymbolDisplayVisitor(this) 251754"];
17316 [label="_escapeKeywordIdentifiers 251755"];
17317 [label="_lazyAliasMap 251756"];
17318 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251757"];
17319 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 251758"];
17320 [label="visitor.VisitNamespace(this) 251759"];
17321 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251760"];
17322 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251761"];
17323 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 251762"];
17324 [label="param ShouldVisitNamespace(this) 251763"];
17325 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 251764"];
17326 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251765"];
17327 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 251766"];
17328 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 251767"];
17329 [label="=> _underlying.IsGlobalNamespace 251768"];
17330 [label="get\n            {\n                return false;\n            } 251769"];
17331 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 251770"];
17332 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 251771"];
17333 [label="get\n            {\n                return true;\n            } 251772"];
17334 [label="=> _underlying.IsGlobalNamespace 251773"];
17335 [label="get\n            {\n                return false;\n            } 251774"];
17336 [label="symbol.IsGlobalNamespace 251775"];
17337 [label="=> _underlying.IsGlobalNamespace 251776"];
17338 [label="get\n            {\n                return false;\n            } 251777"];
17339 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 251778"];
17340 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 251779"];
17341 [label="symbol.Name 251780"];
17342 [label="UnderlyingSymbol 251781"];
17343 [label="UnderlyingSymbol.Name 251782"];
17344 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 251783"];
17345 [label="param CreatePart(SymbolDisplayPartKind kind) 251784"];
17346 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251785"];
17347 [label="return new SymbolDisplayPart(kind, symbol, text); 251786"];
17348 [label="visitor.VisitNamespace(this); 251787"];
17349 [label="Accept(visitor); 251788"];
17350 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 251789"];
17351 [label="namespaceSymbol.IsGlobalNamespace 251790"];
17352 [label="=> _underlying.IsGlobalNamespace 251791"];
17353 [label="get\n            {\n                return false;\n            } 251792"];
17354 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251793"];
17355 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 251794"];
17356 [label="param AddPunctuation(this) 251795"];
17357 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251796"];
17358 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 251797"];
17359 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 251798"];
17360 [label="param CreatePart(SymbolDisplayPartKind kind) 251799"];
17361 [label="param CreatePart(ISymbol symbol) 251800"];
17362 [label="param CreatePart(this) 251801"];
17363 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 251802"];
17364 [label="return new SymbolDisplayPart(kind, symbol, text); 251803"];
17365 [label="return new SymbolDisplayPart(kind, symbol, text); 251804"];
17366 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 251805"];
17367 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 251806"];
17368 [label="symbol.ContainingType 251807"];
17369 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 251808"];
17370 [label="UnderlyingSymbol 251809"];
17371 [label="=> _underlying 251810"];
17372 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 251811"];
17373 [label="UnderlyingSymbol.ContainingType 251812"];
17374 [label="get\n            {\n                return _newContainer as NamedTypeSymbol;\n            } 251813"];
17375 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 251814"];
17376 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 251815"];
17377 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 251816"];
17378 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 251817"];
17379 [label="param GetPublicSymbol(this Symbol? symbol) 251818"];
17380 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 251819"];
17381 [label="IncludeNamedType(symbol.ContainingType) 251820"];
17382 [label="param IncludeNamedType(INamedTypeSymbol namedType) 251821"];
17383 [label="param IncludeNamedType(this) 251822"];
17384 [label="if (namedType is null)\n            {\n                return false;\n            } 251823"];
17385 [label="return false; 251824"];
17386 [label="AddNameAndTypeArgumentsOrParameters(symbol) 251825"];
17387 [label="param AddNameAndTypeArgumentsOrParameters(this) 251826"];
17388 [label="symbol.IsAnonymousType 251827"];
17389 [label="=> UnderlyingTypeSymbol.IsAnonymousType 251828"];
17390 [label="UnderlyingTypeSymbol 251829"];
17391 [label="=> _underlying 251830"];
17392 [label="UnderlyingTypeSymbol.IsAnonymousType 251831"];
17393 [label="get\n            {\n                return false;\n            } 251832"];
17394 [label="return false; 251833"];
17395 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251834"];
17396 [label="symbol.IsTupleType 251835"];
17397 [label="=> UnderlyingTypeSymbol.IsTupleType 251836"];
17398 [label="UnderlyingTypeSymbol 251837"];
17399 [label="=> _underlying 251838"];
17400 [label="UnderlyingTypeSymbol.IsTupleType 251839"];
17401 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251840"];
17402 [label="_ 251841"];
17403 [label="tupleCardinality: out _ 251842"];
17404 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 251843"];
17405 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251844"];
17406 [label="param IsTupleTypeOfCardinality(this) 251845"];
17407 [label="IsUnboundGenericType 251846"];
17408 [label="get\n            {\n                return _unbound;\n            } 251847"];
17409 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251848"];
17410 [label="ContainingSymbol 251849"];
17411 [label="get { return _newContainer; } 251850"];
17412 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251851"];
17413 [label=".Kind 251852"];
17414 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251853"];
17415 [label="return SymbolKind.Namespace; 251854"];
17416 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251855"];
17417 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251856"];
17418 [label="ContainingNamespace 251857"];
17419 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251858"];
17420 [label="this.ContainingSymbol 251859"];
17421 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251860"];
17422 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251861"];
17423 [label="ContainingNamespace.ContainingNamespace 251862"];
17424 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251863"];
17425 [label="this.ContainingSymbol 251864"];
17426 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 251865"];
17427 [label=".IsGlobalNamespace 251866"];
17428 [label="get\n            {\n                return false;\n            } 251867"];
17429 [label="return false; 251868"];
17430 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251869"];
17431 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251870"];
17432 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251871"];
17433 [label="tupleCardinality = 0; 251872"];
17434 [label="return false; 251873"];
17435 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 251874"];
17436 [label="string symbolName = null; 251875"];
17437 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 251876"];
17438 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251877"];
17439 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 251878"];
17440 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 251879"];
17441 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251880"];
17442 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 251881"];
17443 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 251882"];
17444 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251883"];
17445 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 251884"];
17446 [label="GetPartKind(symbol) 251885"];
17447 [label="symbol.TypeKind 251886"];
17448 [label="UnderlyingTypeSymbol 251887"];
17449 [label="UnderlyingTypeSymbol.TypeKind 251888"];
17450 [label="_underlyingType.TypeKind 251889"];
17451 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251890"];
17452 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 251891"];
17453 [label="symbol.Name 251892"];
17454 [label="UnderlyingSymbol 251893"];
17455 [label="UnderlyingSymbol.Name 251894"];
17456 [label="_underlyingType.Name 251895"];
17457 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 251896"];
17458 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 251897"];
17459 [label="param RemoveAttributeSufficeIfNecessary(this) 251898"];
17460 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 251899"];
17461 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 251900"];
17462 [label="ImmutableArray<ITypeSymbol> typeArguments; 251901"];
17463 [label="typeArguments 251902"];
17464 [label="=> UnderlyingSymbol.Kind 251903"];
17465 [label="UnderlyingSymbol 251904"];
17466 [label="=> _underlying 251905"];
17467 [label="get { return OriginalDefinition.Kind; } 251906"];
17468 [label="get { return _underlyingType; } 251907"];
17469 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 251908"];
17470 [label="=> defaultType 251909"];
17471 [label="param ToPublicAnnotation(this TypeWithAnnotations type) 251910"];
17472 [label="type.Type 251911"];
17473 [label="=> _extensions?.GetResolvedType(DefaultType) 251912"];
17474 [label="=> defaultType 251913"];
17475 [label="type.NullableAnnotation 251914"];
17476 [label="param ToPublicAnnotation(NullableAnnotation annotation) 251915"];
17477 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 251916"];
17478 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 251917"];
17479 [label="get\n            {\n                return false;\n            } 251918"];
17480 [label="return false; 251919"];
17481 [label="get\n            {\n                return false;\n            } 251920"];
17482 [label="var first = true; 251921"];
17483 [label="if (!first)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                        AddSpace();\n                    } 251922"];
17484 [label="first = false; 251923"];
17485 [label="AbstractSymbolDisplayVisitor visitor; 251924"];
17486 [label="=> _underlying 251925"];
17487 [label="_underlying 251926"];
17488 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 251927"];
17489 [label="param TryAddAlias(ArrayBuilder<SymbolDisplayPart> builder) 251928"];
17490 [label="var map = _lazyAliasMap; 251929"];
17491 [label="if (map != null)\n                {\n                    return map;\n                } 251930"];
17492 [label="if (map != null)\n                {\n                    return map;\n                } 251931"];
17493 [label="AliasMap.TryGetValue(symbol, out result) 251932"];
17494 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 251933"];
17495 [label="if (alias != null)\n            {\n                // We must verify that the alias actually binds back to the thing it's aliasing.\n                // It's possible there's another symbol with the same name as the alias that binds\n                // first\n                var aliasName = alias.Name;\n\n                var boundSymbols = semanticModelOpt.LookupNamespacesAndTypes(positionOpt, name: aliasName);\n\n                if (boundSymbols.Length == 1)\n                {\n                    var boundAlias = boundSymbols[0] as IAliasSymbol;\n                    if ((object)boundAlias != null && alias.Target.Equals(symbol))\n                    {\n                        builder.Add(CreatePart(SymbolDisplayPartKind.AliasName, alias, aliasName));\n                        return true;\n                    }\n                }\n            } 251934"];
17496 [label="return false; 251935"];
17497 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 251936"];
17498 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers))\n            {\n                // Ironically, reverse order is simpler - we just have to recurse on the element type and then add a rank specifier.\n                symbol.ElementType.Accept(this);\n                AddArrayRank(symbol);\n                return;\n            } 251937"];
17499 [label="underlyingType.Kind 251938"];
17500 [label="=> UnderlyingSymbol.Kind 251939"];
17501 [label="UnderlyingSymbol 251940"];
17502 [label="=> _underlying 251941"];
17503 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 251942"];
17504 [label="do\n            {\n                underlyingType = ((IArrayTypeSymbol)underlyingType).ElementType;\n            }\n            while (underlyingType.Kind == SymbolKind.ArrayType && !ShouldAddNullableAnnotation(underlyingType)); 251943"];
17505 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 251944"];
17506 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251945"];
17507 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251946"];
17508 [label="symbol.IsNativeIntegerType 251947"];
17509 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 251948"];
17510 [label="UnderlyingTypeSymbol 251949"];
17511 [label="=> _underlying 251950"];
17512 [label="UnderlyingTypeSymbol.IsNativeIntegerType 251951"];
17513 [label="=> false 251952"];
17514 [label="false 251953"];
17515 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 251954"];
17516 [label="symbol.IsTupleType 251955"];
17517 [label="=> UnderlyingTypeSymbol.IsTupleType 251956"];
17518 [label="UnderlyingTypeSymbol 251957"];
17519 [label="=> _underlying 251958"];
17520 [label="UnderlyingTypeSymbol.IsTupleType 251959"];
17521 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 251960"];
17522 [label="_ 251961"];
17523 [label="tupleCardinality: out _ 251962"];
17524 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 251963"];
17525 [label="param IsTupleTypeOfCardinality(this) 251964"];
17526 [label="IsUnboundGenericType 251965"];
17527 [label="get\n            {\n                return false;\n            } 251966"];
17528 [label="return false; 251967"];
17529 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251968"];
17530 [label="ContainingSymbol 251969"];
17531 [label="get\n            {\n                return _container;\n            } 251970"];
17532 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251971"];
17533 [label=".Kind 251972"];
17534 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 251973"];
17535 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251974"];
17536 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251975"];
17537 [label="ContainingNamespace 251976"];
17538 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251977"];
17539 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251978"];
17540 [label="ContainingNamespace.ContainingNamespace 251979"];
17541 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 251980"];
17542 [label=".IsGlobalNamespace 251981"];
17543 [label="get\n            {\n                return true;\n            } 251982"];
17544 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251983"];
17545 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251984"];
17546 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251985"];
17547 [label="Name 251986"];
17548 [label="get\n            {\n                return _name;\n            } 251987"];
17549 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251988"];
17550 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251989"];
17551 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 251990"];
17552 [label="tupleCardinality = 0; 251991"];
17553 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 251992"];
17554 [label="AddTypeKind(symbol); 251993"];
17555 [label="AddTypeKind(symbol) 251994"];
17556 [label="param AddTypeKind(INamedTypeSymbol symbol) 251995"];
17557 [label="param AddTypeKind(this) 251996"];
17558 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 251997"];
17559 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 251998"];
17560 [label="CanShowDelegateSignature(symbol) 251999"];
17561 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252000"];
17562 [label="param CanShowDelegateSignature(this) 252001"];
17563 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252002"];
17564 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 252003"];
17565 [label="=> _underlying.IsGlobalNamespace 252004"];
17566 [label="get\n            {\n                return false;\n            } 252005"];
17567 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 252006"];
17568 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 252007"];
17569 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 252008"];
17570 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 252009"];
17571 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252010"];
17572 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252011"];
17573 [label="=> _underlying.IsGlobalNamespace 252012"];
17574 [label="get\n            {\n                return true;\n            } 252013"];
17575 [label="get\n            {\n                return false;\n            } 252014"];
17576 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 252015"];
17577 [label="symbol.ContainingType 252016"];
17578 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 252017"];
17579 [label="UnderlyingSymbol 252018"];
17580 [label="=> _underlying 252019"];
17581 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 252020"];
17582 [label="UnderlyingSymbol.ContainingType 252021"];
17583 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 252022"];
17584 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 252023"];
17585 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 252024"];
17586 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 252025"];
17587 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 252026"];
17588 [label="param GetPublicSymbol(this Symbol? symbol) 252027"];
17589 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 252028"];
17590 [label="IncludeNamedType(symbol.ContainingType) 252029"];
17591 [label="param IncludeNamedType(INamedTypeSymbol namedType) 252030"];
17592 [label="param IncludeNamedType(this) 252031"];
17593 [label="if (namedType is null)\n            {\n                return false;\n            } 252032"];
17594 [label="return false; 252033"];
17595 [label="symbol.IsAnonymousType 252034"];
17596 [label="=> UnderlyingTypeSymbol.IsAnonymousType 252035"];
17597 [label="UnderlyingTypeSymbol 252036"];
17598 [label="=> _underlying 252037"];
17599 [label="_underlying 252038"];
17600 [label="UnderlyingTypeSymbol.IsAnonymousType 252039"];
17601 [label="get\n            {\n                return false;\n            } 252040"];
17602 [label="return false; 252041"];
17603 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252042"];
17604 [label="symbol.IsTupleType 252043"];
17605 [label="=> UnderlyingTypeSymbol.IsTupleType 252044"];
17606 [label="UnderlyingTypeSymbol 252045"];
17607 [label="=> _underlying 252046"];
17608 [label="_underlying 252047"];
17609 [label="UnderlyingTypeSymbol.IsTupleType 252048"];
17610 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 252049"];
17611 [label="_ 252050"];
17612 [label="tupleCardinality: out _ 252051"];
17613 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 252052"];
17614 [label="param IsTupleTypeOfCardinality(this) 252053"];
17615 [label="IsUnboundGenericType 252054"];
17616 [label="get\n            {\n                return false;\n            } 252055"];
17617 [label="return false; 252056"];
17618 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252057"];
17619 [label="ContainingSymbol 252058"];
17620 [label="get\n            {\n                return _container;\n            } 252059"];
17621 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252060"];
17622 [label=".Kind 252061"];
17623 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 252062"];
17624 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252063"];
17625 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252064"];
17626 [label="ContainingNamespace 252065"];
17627 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252066"];
17628 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252067"];
17629 [label="ContainingNamespace.ContainingNamespace 252068"];
17630 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252069"];
17631 [label=".IsGlobalNamespace 252070"];
17632 [label="get\n            {\n                return true;\n            } 252071"];
17633 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252072"];
17634 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252073"];
17635 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252074"];
17636 [label="Name 252075"];
17637 [label="get\n            {\n                return _name;\n            } 252076"];
17638 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252077"];
17639 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252078"];
17640 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252079"];
17641 [label="tupleCardinality = 0; 252080"];
17642 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252081"];
17643 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 252082"];
17644 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252083"];
17645 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252084"];
17646 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 252085"];
17647 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252086"];
17648 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252087"];
17649 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 252088"];
17650 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252089"];
17651 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252090"];
17652 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 252091"];
17653 [label="param RemoveAttributeSufficeIfNecessary(this) 252092"];
17654 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 252093"];
17655 [label="get\n                {\n                    return 0;\n                } 252094"];
17656 [label="AddDelegateParameters(symbol); 252095"];
17657 [label="AddDelegateParameters(symbol) 252096"];
17658 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 252097"];
17659 [label="param AddDelegateParameters(this) 252098"];
17660 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 252099"];
17661 [label="CanShowDelegateSignature(symbol) 252100"];
17662 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252101"];
17663 [label="param CanShowDelegateSignature(this) 252102"];
17664 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252103"];
17665 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 252104"];
17666 [label="AddDelegateParameters(symbol); 252105"];
17667 [label=".OriginalDefinition 252106"];
17668 [label="get\n            {\n                return this;\n            } 252107"];
17669 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 252108"];
17670 [label="AddNullableAnnotations(symbol); 252109"];
17671 [label="AddNullableAnnotations(symbol) 252110"];
17672 [label="param AddNullableAnnotations(ITypeSymbol type) 252111"];
17673 [label="param AddNullableAnnotations(this) 252112"];
17674 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252113"];
17675 [label="ShouldAddNullableAnnotation(type) 252114"];
17676 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 252115"];
17677 [label="param ShouldAddNullableAnnotation(this) 252116"];
17678 [label="type.NullableAnnotation 252117"];
17679 [label="=> NullableAnnotation 252118"];
17680 [label="NullableAnnotation 252119"];
17681 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 252120"];
17682 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 252121"];
17683 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    } 252122"];
17684 [label="return false; 252123"];
17685 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252124"];
17686 [label="if (!this.isFirstSymbolVisited)\n                {\n                    AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true);\n                } 252125"];
17687 [label="arrayType.CustomModifiers 252126"];
17688 [label="=> _underlying.ElementTypeWithAnnotations.CustomModifiers 252127"];
17689 [label="_underlying.ElementTypeWithAnnotations 252128"];
17690 [label="get\n            {\n                return _elementTypeWithAnnotations;\n            } 252129"];
17691 [label="_underlying.ElementTypeWithAnnotations.CustomModifiers 252130"];
17692 [label="=> _extensions.CustomModifiers 252131"];
17693 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 252132"];
17694 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true); 252133"];
17695 [label="AddCustomModifiersIfRequired(arrayType.CustomModifiers, leadingSpace: true) 252134"];
17696 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 252135"];
17697 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 252136"];
17698 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 252137"];
17699 [label="param AddCustomModifiersIfRequired(this) 252138"];
17700 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252139"];
17701 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252140"];
17702 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252141"];
17703 [label="AddArrayRank(arrayType); 252142"];
17704 [label="param AddArrayRank(IArrayTypeSymbol symbol) 252143"];
17705 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 252144"];
17706 [label="bool insertStars = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays); 252145"];
17707 [label="symbol.Rank 252146"];
17708 [label="=> _underlying.Rank 252147"];
17709 [label="_underlying.Rank 252148"];
17710 [label="get\n                {\n                    return 1;\n                } 252149"];
17711 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 252150"];
17712 [label="if (symbol.Rank > 1)\n            {\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            }\n            else\n            {\n                if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 252151"];
17713 [label="symbol.IsSZArray 252152"];
17714 [label="=> _underlying.IsSZArray 252153"];
17715 [label="_underlying.IsSZArray 252154"];
17716 [label="get\n                {\n                    return true;\n                } 252155"];
17717 [label="return true; 252156"];
17718 [label="if (!symbol.IsSZArray)\n                {\n                    // Always add an asterisk in this case in order to distinguish between SZArray and MDArray.\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                } 252157"];
17719 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 252158"];
17720 [label="symbol.Rank 252159"];
17721 [label="=> _underlying.Rank 252160"];
17722 [label="_underlying.Rank 252161"];
17723 [label="get\n                {\n                    return 1;\n                } 252162"];
17724 [label="for (int i = 0; i < symbol.Rank - 1; i++)\n            {\n                AddPunctuation(SyntaxKind.CommaToken);\n\n                if (insertStars)\n                {\n                    AddPunctuation(SyntaxKind.AsteriskToken);\n                }\n            } 252163"];
17725 [label="arrayType.ElementType 252164"];
17726 [label="if (_lazyElementType is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyElementType, _underlying.ElementTypeWithAnnotations.GetPublicSymbol(), null);\n                } 252165"];
17727 [label="return _lazyElementType; 252166"];
17728 [label="arrayType = arrayType.ElementType as IArrayTypeSymbol; 252167"];
17729 [label="AddNullableAnnotations(symbol); 252168"];
17730 [label="AddNullableAnnotations(symbol) 252169"];
17731 [label="param AddNullableAnnotations(ITypeSymbol type) 252170"];
17732 [label="param AddNullableAnnotations(this) 252171"];
17733 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252172"];
17734 [label="ShouldAddNullableAnnotation(type) 252173"];
17735 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 252174"];
17736 [label="param ShouldAddNullableAnnotation(this) 252175"];
17737 [label="type.NullableAnnotation 252176"];
17738 [label="=> NullableAnnotation 252177"];
17739 [label="NullableAnnotation 252178"];
17740 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 252179"];
17741 [label="return false; 252180"];
17742 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252181"];
17743 [label="AddCustomModifiersIfRequired(modifiers[i], leadingSpace: true, trailingSpace: false) 252182"];
17744 [label="param AddCustomModifiersIfRequired(ImmutableArray<CustomModifier> customModifiers) 252183"];
17745 [label="param AddCustomModifiersIfRequired(bool leadingSpace = false) 252184"];
17746 [label="param AddCustomModifiersIfRequired(bool trailingSpace = true) 252185"];
17747 [label="param AddCustomModifiersIfRequired(this) 252186"];
17748 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252187"];
17749 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252188"];
17750 [label="if (this.format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers) && !customModifiers.IsEmpty)\n            {\n                bool first = true;\n                foreach (CustomModifier customModifier in customModifiers)\n                {\n                    if (!first || leadingSpace)\n                    {\n                        AddSpace();\n                    }\n                    first = false;\n\n                    this.builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, null, customModifier.IsOptional ? IL_KEYWORD_MODOPT : IL_KEYWORD_MODREQ));\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    customModifier.Modifier.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n                if (trailingSpace)\n                {\n                    AddSpace();\n                }\n            } 252189"];
17751 [label="AddDelegateParameters(symbol); 252190"];
17752 [label="AddDelegateParameters(symbol) 252191"];
17753 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 252192"];
17754 [label="param AddDelegateParameters(this) 252193"];
17755 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 252194"];
17756 [label="CanShowDelegateSignature(symbol) 252195"];
17757 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252196"];
17758 [label="param CanShowDelegateSignature(this) 252197"];
17759 [label="symbol.TypeKind 252198"];
17760 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 252199"];
17761 [label="_underlying 252200"];
17762 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252201"];
17763 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252202"];
17764 [label="symbol.TypeArguments 252203"];
17765 [label="if (_lazyTypeArguments.IsDefault)\n                {\n\n                    ImmutableInterlocked.InterlockedCompareExchange(ref _lazyTypeArguments, UnderlyingNamedTypeSymbol.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.GetPublicSymbols(), default);\n                } 252204"];
17766 [label="return _lazyTypeArguments; 252205"];
17767 [label="AddTypeParameterConstraints(symbol.TypeArguments); 252206"];
17768 [label="AddTypeParameterConstraints(symbol.TypeArguments) 252207"];
17769 [label="param AddTypeParameterConstraints(ImmutableArray<ITypeSymbol> typeArguments) 252208"];
17770 [label="param AddTypeParameterConstraints(this) 252209"];
17771 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 252210"];
17772 [label="if (this.isFirstSymbolVisited && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeConstraints))\n            {\n                foreach (var typeArg in typeArguments)\n                {\n                    if (typeArg.Kind == SymbolKind.TypeParameter)\n                    {\n                        var typeParam = (ITypeParameterSymbol)typeArg;\n\n                        if (TypeParameterHasConstraints(typeParam))\n                        {\n                            AddSpace();\n                            AddKeyword(SyntaxKind.WhereKeyword);\n                            AddSpace();\n\n                            typeParam.Accept(this.NotFirstVisitor);\n\n                            AddSpace();\n                            AddPunctuation(SyntaxKind.ColonToken);\n                            AddSpace();\n\n                            bool needComma = false;\n\n                            //class/struct constraint must be first\n                            if (typeParam.HasReferenceTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.ClassKeyword);\n\n                                switch (typeParam.ReferenceTypeConstraintNullableAnnotation)\n                                {\n                                    case CodeAnalysis.NullableAnnotation.Annotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.QuestionToken);\n                                        }\n                                        break;\n\n                                    case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                                        if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier))\n                                        {\n                                            AddPunctuation(SyntaxKind.ExclamationToken);\n                                        }\n                                        break;\n                                }\n\n                                needComma = true;\n                            }\n                            else if (typeParam.HasUnmanagedTypeConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'unmanaged'));\n                                needComma = true;\n                            }\n                            else if (typeParam.HasValueTypeConstraint)\n                            {\n                                AddKeyword(SyntaxKind.StructKeyword);\n                                needComma = true;\n                            }\n                            else if (typeParam.HasNotNullConstraint)\n                            {\n                                builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.Keyword, null, 'notnull'));\n                                needComma = true;\n                            }\n\n                            for (int i = 0; i < typeParam.ConstraintTypes.Length; i++)\n                            {\n                                ITypeSymbol baseType = typeParam.ConstraintTypes[i];\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                baseType.Accept(this.NotFirstVisitor);\n                                needComma = true;\n                            }\n\n                            //ctor constraint must be last\n                            if (typeParam.HasConstructorConstraint)\n                            {\n                                if (needComma)\n                                {\n                                    AddPunctuation(SyntaxKind.CommaToken);\n                                    AddSpace();\n                                }\n\n                                AddKeyword(SyntaxKind.NewKeyword);\n                                AddPunctuation(SyntaxKind.OpenParenToken);\n                                AddPunctuation(SyntaxKind.CloseParenToken);\n                            }\n                        }\n                    }\n                }\n            } 252211"];
17773 [label="AddTypeParameterConstraints(symbol.TypeArguments); 252212"];
17774 [label=".OriginalDefinition 252213"];
17775 [label="get { return _underlyingType; } 252214"];
17776 [label="return _underlyingType; 252215"];
17777 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 252216"];
17778 [label="AddNameAndTypeArgumentsOrParameters(symbol); 252217"];
17779 [label="VisitNamedTypeWithoutNullability(symbol); 252218"];
17780 [label="AddNullableAnnotations(symbol); 252219"];
17781 [label="AddNullableAnnotations(symbol) 252220"];
17782 [label="param AddNullableAnnotations(ITypeSymbol type) 252221"];
17783 [label="param AddNullableAnnotations(this) 252222"];
17784 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252223"];
17785 [label="ShouldAddNullableAnnotation(type) 252224"];
17786 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 252225"];
17787 [label="param ShouldAddNullableAnnotation(this) 252226"];
17788 [label="type.NullableAnnotation 252227"];
17789 [label="=> NullableAnnotation 252228"];
17790 [label="NullableAnnotation 252229"];
17791 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 252230"];
17792 [label="return false; 252231"];
17793 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252232"];
17794 [label="AddNullableAnnotations(symbol); 252233"];
17795 [label="visitor.VisitNamedType(this); 252234"];
17796 [label="Accept(visitor); 252235"];
17797 [label="symbol.Accept(visitor); 252236"];
17798 [label="CustomAssert.Equal('System.Collections.IStructuralComparable', i8.ToTestDisplayString()); 252237"];
17799 [label="CustomAssert.Equal('System.Collections.IStructuralComparable', i8.ToTestDisplayString()); 252238"];
17800 [label="i8.ToTestDisplayString() 252239"];
17801 [label="param ToTestDisplayString(this Symbol symbol) 252240"];
17802 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 252241"];
17803 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 252242"];
17804 [label="param ToDisplayString(SymbolDisplayFormat format = null) 252243"];
17805 [label="param ToDisplayString(this) 252244"];
17806 [label="ISymbol 252245"];
17807 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 252246"];
17808 [label="NullableAnnotation.Oblivious 252247"];
17809 [label="param ToPublicAnnotation(NullableAnnotation annotation) 252248"];
17810 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 252249"];
17811 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 252250"];
17812 [label="var kind = TypeKind; 252251"];
17813 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 252252"];
17814 [label="param NamespaceOrTypeSymbol(this) 252253"];
17815 [label="param Symbol(this) 252254"];
17816 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 252255"];
17817 [label="_underlying 252256"];
17818 [label="Debug.Assert(underlying is object); 252257"];
17819 [label="Debug.Assert(!underlying.IsErrorType()); 252258"];
17820 [label="param IsErrorType(this TypeSymbol type) 252259"];
17821 [label="RoslynDebug.Assert((object)type != null); 252260"];
17822 [label="RoslynDebug.Assert((object)type != null); 252261"];
17823 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 252262"];
17824 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 252263"];
17825 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 252264"];
17826 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 252265"];
17827 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 252266"];
17828 [label="ToDisplayParts(symbol, format) 252267"];
17829 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 252268"];
17830 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 252269"];
17831 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 252270"];
17832 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 252271"];
17833 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 252272"];
17834 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 252273"];
17835 [label="param ToDisplayParts(int positionOpt) 252274"];
17836 [label="param ToDisplayParts(SymbolDisplayFormat format) 252275"];
17837 [label="param ToDisplayParts(bool minimal) 252276"];
17838 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 252277"];
17839 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 252278"];
17840 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 252279"];
17841 [label="Debug.Assert(semanticModelOpt == null); 252280"];
17842 [label="Debug.Assert(semanticModelOpt == null); 252281"];
17843 [label="Debug.Assert(positionOpt < 0); 252282"];
17844 [label="Debug.Assert(positionOpt < 0); 252283"];
17845 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 252284"];
17846 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 252285"];
17847 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252286"];
17848 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252287"];
17849 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252288"];
17850 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252289"];
17851 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252290"];
17852 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 252291"];
17853 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 252292"];
17854 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 252293"];
17855 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 252294"];
17856 [label="param SymbolDisplayVisitor(int positionOpt) 252295"];
17857 [label="param SymbolDisplayVisitor(this) 252296"];
17858 [label="builder 252297"];
17859 [label="format 252298"];
17860 [label="true 252299"];
17861 [label="semanticModelOpt 252300"];
17862 [label="positionOpt 252301"];
17863 [label="param SymbolDisplayVisitor(this) 252302"];
17864 [label="_escapeKeywordIdentifiers 252303"];
17865 [label="_lazyAliasMap 252304"];
17866 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 252305"];
17867 [label="symbol.Accept(visitor); 252306"];
17868 [label="symbol.Accept(visitor) 252307"];
17869 [label="param Accept(SymbolVisitor visitor) 252308"];
17870 [label="Accept(visitor); 252309"];
17871 [label="Accept(visitor) 252310"];
17872 [label="param Accept(SymbolVisitor visitor) 252311"];
17873 [label="visitor.VisitNamedType(this) 252312"];
17874 [label="param VisitNamedType(this) 252313"];
17875 [label="VisitNamedTypeWithoutNullability(symbol) 252314"];
17876 [label="param VisitNamedTypeWithoutNullability(this) 252315"];
17877 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 252316"];
17878 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252317"];
17879 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252318"];
17880 [label="symbol.IsNativeIntegerType 252319"];
17881 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 252320"];
17882 [label="UnderlyingTypeSymbol 252321"];
17883 [label="=> _underlying 252322"];
17884 [label="UnderlyingTypeSymbol.IsNativeIntegerType 252323"];
17885 [label="=> false 252324"];
17886 [label="false 252325"];
17887 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252326"];
17888 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252327"];
17889 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 252328"];
17890 [label="symbol.IsTupleType 252329"];
17891 [label="=> UnderlyingTypeSymbol.IsTupleType 252330"];
17892 [label="UnderlyingTypeSymbol 252331"];
17893 [label="=> _underlying 252332"];
17894 [label="UnderlyingTypeSymbol.IsTupleType 252333"];
17895 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 252334"];
17896 [label="_ 252335"];
17897 [label="tupleCardinality: out _ 252336"];
17898 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 252337"];
17899 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 252338"];
17900 [label="param IsTupleTypeOfCardinality(this) 252339"];
17901 [label="IsUnboundGenericType 252340"];
17902 [label="get\n            {\n                return false;\n            } 252341"];
17903 [label="return false; 252342"];
17904 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252343"];
17905 [label="ContainingSymbol 252344"];
17906 [label="get\n            {\n                return _container;\n            } 252345"];
17907 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252346"];
17908 [label=".Kind 252347"];
17909 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 252348"];
17910 [label="return SymbolKind.Namespace; 252349"];
17911 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252350"];
17912 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252351"];
17913 [label="ContainingNamespace 252352"];
17914 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252353"];
17915 [label="this.ContainingSymbol 252354"];
17916 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252355"];
17917 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252356"];
17918 [label="ContainingNamespace.ContainingNamespace 252357"];
17919 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252358"];
17920 [label="this.ContainingSymbol 252359"];
17921 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252360"];
17922 [label=".IsGlobalNamespace 252361"];
17923 [label="get\n            {\n                return false;\n            } 252362"];
17924 [label="return false; 252363"];
17925 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252364"];
17926 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252365"];
17927 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252366"];
17928 [label="tupleCardinality = 0; 252367"];
17929 [label="return false; 252368"];
17930 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 252369"];
17931 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 252370"];
17932 [label="AddTypeKind(symbol); 252371"];
17933 [label="AddTypeKind(symbol) 252372"];
17934 [label="param AddTypeKind(INamedTypeSymbol symbol) 252373"];
17935 [label="param AddTypeKind(this) 252374"];
17936 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 252375"];
17937 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 252376"];
17938 [label="AddTypeKind(symbol); 252377"];
17939 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 252378"];
17940 [label="CanShowDelegateSignature(symbol) 252379"];
17941 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252380"];
17942 [label="param CanShowDelegateSignature(this) 252381"];
17943 [label="symbol.TypeKind 252382"];
17944 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 252383"];
17945 [label="UnderlyingTypeSymbol 252384"];
17946 [label="UnderlyingTypeSymbol.TypeKind 252385"];
17947 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252386"];
17948 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252387"];
17949 [label="symbol.ContainingSymbol 252388"];
17950 [label="UnderlyingSymbol 252389"];
17951 [label="UnderlyingSymbol.ContainingSymbol 252390"];
17952 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 252391"];
17953 [label="symbol.GetPublicSymbol<ISymbol>() 252392"];
17954 [label=".ISymbol 252393"];
17955 [label="ShouldVisitNamespace(containingSymbol) 252394"];
17956 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 252395"];
17957 [label="param ShouldVisitNamespace(this) 252396"];
17958 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 252397"];
17959 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252398"];
17960 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252399"];
17961 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 252400"];
17962 [label="namespaceSymbol.IsGlobalNamespace 252401"];
17963 [label="=> _underlying.IsGlobalNamespace 252402"];
17964 [label="_underlying.IsGlobalNamespace 252403"];
17965 [label="get\n            {\n                return false;\n            } 252404"];
17966 [label="return false; 252405"];
17967 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 252406"];
17968 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 252407"];
17969 [label="namespaceSymbol.IsGlobalNamespace 252408"];
17970 [label="=> _underlying.IsGlobalNamespace 252409"];
17971 [label="get\n            {\n                return false;\n            } 252410"];
17972 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 252411"];
17973 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 252412"];
17974 [label="this.NotFirstVisitor 252413"];
17975 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 252414"];
17976 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 252415"];
17977 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 252416"];
17978 [label="param SymbolDisplayVisitor(this) 252417"];
17979 [label="isFirstSymbolVisited 252418"];
17980 [label="param SymbolDisplayVisitor(this) 252419"];
17981 [label="_escapeKeywordIdentifiers 252420"];
17982 [label="_lazyAliasMap 252421"];
17983 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 252422"];
17984 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 252423"];
17985 [label="visitor.VisitNamespace(this) 252424"];
17986 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 252425"];
17987 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 252426"];
17988 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 252427"];
17989 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 252428"];
17990 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252429"];
17991 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252430"];
17992 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 252431"];
17993 [label="=> _underlying.IsGlobalNamespace 252432"];
17994 [label="get\n            {\n                return false;\n            } 252433"];
17995 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 252434"];
17996 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 252435"];
17997 [label="get\n            {\n                return true;\n            } 252436"];
17998 [label="=> _underlying.IsGlobalNamespace 252437"];
17999 [label="get\n            {\n                return false;\n            } 252438"];
18000 [label="symbol.IsGlobalNamespace 252439"];
18001 [label="=> _underlying.IsGlobalNamespace 252440"];
18002 [label="get\n            {\n                return false;\n            } 252441"];
18003 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 252442"];
18004 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 252443"];
18005 [label="symbol.Name 252444"];
18006 [label="UnderlyingSymbol 252445"];
18007 [label="UnderlyingSymbol.Name 252446"];
18008 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 252447"];
18009 [label="param CreatePart(SymbolDisplayPartKind kind) 252448"];
18010 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 252449"];
18011 [label="return new SymbolDisplayPart(kind, symbol, text); 252450"];
18012 [label="visitor.VisitNamespace(this); 252451"];
18013 [label="Accept(visitor); 252452"];
18014 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 252453"];
18015 [label="namespaceSymbol.IsGlobalNamespace 252454"];
18016 [label="=> _underlying.IsGlobalNamespace 252455"];
18017 [label="get\n            {\n                return false;\n            } 252456"];
18018 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 252457"];
18019 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 252458"];
18020 [label="param AddPunctuation(this) 252459"];
18021 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 252460"];
18022 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 252461"];
18023 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 252462"];
18024 [label="param CreatePart(SymbolDisplayPartKind kind) 252463"];
18025 [label="param CreatePart(ISymbol symbol) 252464"];
18026 [label="param CreatePart(this) 252465"];
18027 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 252466"];
18028 [label="return new SymbolDisplayPart(kind, symbol, text); 252467"];
18029 [label="return new SymbolDisplayPart(kind, symbol, text); 252468"];
18030 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 252469"];
18031 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 252470"];
18032 [label="symbol.ContainingType 252471"];
18033 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 252472"];
18034 [label="UnderlyingSymbol 252473"];
18035 [label="=> _underlying 252474"];
18036 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 252475"];
18037 [label="UnderlyingSymbol.ContainingType 252476"];
18038 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 252477"];
18039 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 252478"];
18040 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 252479"];
18041 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 252480"];
18042 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 252481"];
18043 [label="param GetPublicSymbol(this Symbol? symbol) 252482"];
18044 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 252483"];
18045 [label="IncludeNamedType(symbol.ContainingType) 252484"];
18046 [label="param IncludeNamedType(INamedTypeSymbol namedType) 252485"];
18047 [label="param IncludeNamedType(this) 252486"];
18048 [label="if (namedType is null)\n            {\n                return false;\n            } 252487"];
18049 [label="return false; 252488"];
18050 [label="AddNameAndTypeArgumentsOrParameters(symbol) 252489"];
18051 [label="param AddNameAndTypeArgumentsOrParameters(this) 252490"];
18052 [label="symbol.IsAnonymousType 252491"];
18053 [label="=> UnderlyingTypeSymbol.IsAnonymousType 252492"];
18054 [label="UnderlyingTypeSymbol 252493"];
18055 [label="=> _underlying 252494"];
18056 [label="UnderlyingTypeSymbol.IsAnonymousType 252495"];
18057 [label="get\n            {\n                return false;\n            } 252496"];
18058 [label="return false; 252497"];
18059 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252498"];
18060 [label="symbol.IsTupleType 252499"];
18061 [label="=> UnderlyingTypeSymbol.IsTupleType 252500"];
18062 [label="UnderlyingTypeSymbol 252501"];
18063 [label="=> _underlying 252502"];
18064 [label="UnderlyingTypeSymbol.IsTupleType 252503"];
18065 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 252504"];
18066 [label="_ 252505"];
18067 [label="tupleCardinality: out _ 252506"];
18068 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 252507"];
18069 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 252508"];
18070 [label="param IsTupleTypeOfCardinality(this) 252509"];
18071 [label="IsUnboundGenericType 252510"];
18072 [label="get\n            {\n                return false;\n            } 252511"];
18073 [label="return false; 252512"];
18074 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252513"];
18075 [label="ContainingSymbol 252514"];
18076 [label="get\n            {\n                return _container;\n            } 252515"];
18077 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252516"];
18078 [label=".Kind 252517"];
18079 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 252518"];
18080 [label="return SymbolKind.Namespace; 252519"];
18081 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252520"];
18082 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252521"];
18083 [label="ContainingNamespace 252522"];
18084 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252523"];
18085 [label="this.ContainingSymbol 252524"];
18086 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252525"];
18087 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252526"];
18088 [label="ContainingNamespace.ContainingNamespace 252527"];
18089 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252528"];
18090 [label="this.ContainingSymbol 252529"];
18091 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252530"];
18092 [label=".IsGlobalNamespace 252531"];
18093 [label="get\n            {\n                return false;\n            } 252532"];
18094 [label="return false; 252533"];
18095 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252534"];
18096 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252535"];
18097 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252536"];
18098 [label="tupleCardinality = 0; 252537"];
18099 [label="return false; 252538"];
18100 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252539"];
18101 [label="string symbolName = null; 252540"];
18102 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 252541"];
18103 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252542"];
18104 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252543"];
18105 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 252544"];
18106 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252545"];
18107 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252546"];
18108 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 252547"];
18109 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252548"];
18110 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252549"];
18111 [label="GetPartKind(symbol) 252550"];
18112 [label="symbol.TypeKind 252551"];
18113 [label="UnderlyingTypeSymbol 252552"];
18114 [label="UnderlyingTypeSymbol.TypeKind 252553"];
18115 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 252554"];
18116 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 252555"];
18117 [label="symbol.Name 252556"];
18118 [label="UnderlyingSymbol 252557"];
18119 [label="UnderlyingSymbol.Name 252558"];
18120 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 252559"];
18121 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 252560"];
18122 [label="param RemoveAttributeSufficeIfNecessary(this) 252561"];
18123 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 252562"];
18124 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 252563"];
18125 [label="get\n                {\n                    return 0;\n                } 252564"];
18126 [label="AddDelegateParameters(symbol); 252565"];
18127 [label="AddDelegateParameters(symbol) 252566"];
18128 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 252567"];
18129 [label="param AddDelegateParameters(this) 252568"];
18130 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 252569"];
18131 [label="CanShowDelegateSignature(symbol) 252570"];
18132 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252571"];
18133 [label="param CanShowDelegateSignature(this) 252572"];
18134 [label="symbol.TypeKind 252573"];
18135 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 252574"];
18136 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252575"];
18137 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252576"];
18138 [label=".OriginalDefinition 252577"];
18139 [label="get\n            {\n                return this;\n            } 252578"];
18140 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 252579"];
18141 [label="AddNameAndTypeArgumentsOrParameters(symbol); 252580"];
18142 [label="VisitNamedTypeWithoutNullability(symbol); 252581"];
18143 [label="AddNullableAnnotations(symbol); 252582"];
18144 [label="AddNullableAnnotations(symbol) 252583"];
18145 [label="param AddNullableAnnotations(ITypeSymbol type) 252584"];
18146 [label="param AddNullableAnnotations(this) 252585"];
18147 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252586"];
18148 [label="ShouldAddNullableAnnotation(type) 252587"];
18149 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 252588"];
18150 [label="param ShouldAddNullableAnnotation(this) 252589"];
18151 [label="type.NullableAnnotation 252590"];
18152 [label="=> NullableAnnotation 252591"];
18153 [label="NullableAnnotation 252592"];
18154 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 252593"];
18155 [label="return false; 252594"];
18156 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252595"];
18157 [label="AddNullableAnnotations(symbol); 252596"];
18158 [label="visitor.VisitNamedType(this); 252597"];
18159 [label="Accept(visitor); 252598"];
18160 [label="symbol.Accept(visitor); 252599"];
18161 [label="CustomAssert.Equal('System.Collections.IStructuralEquatable', i9.ToTestDisplayString()); 252600"];
18162 [label="CustomAssert.Equal('System.Collections.IStructuralEquatable', i9.ToTestDisplayString()); 252601"];
18163 [label="i9.ToTestDisplayString() 252602"];
18164 [label="param ToTestDisplayString(this Symbol symbol) 252603"];
18165 [label="return symbol.ToDisplayString(SymbolDisplayFormat.TestFormat); 252604"];
18166 [label="symbol.ToDisplayString(SymbolDisplayFormat.TestFormat) 252605"];
18167 [label="param ToDisplayString(SymbolDisplayFormat format = null) 252606"];
18168 [label="param ToDisplayString(this) 252607"];
18169 [label="ISymbol 252608"];
18170 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 252609"];
18171 [label="NullableAnnotation.Oblivious 252610"];
18172 [label="param ToPublicAnnotation(NullableAnnotation annotation) 252611"];
18173 [label="Debug.Assert(annotation != NullableAnnotation.Ignored); 252612"];
18174 [label="annotation switch\n            {\n                NullableAnnotation.Annotated => CodeAnalysis.NullableAnnotation.Annotated,\n                NullableAnnotation.NotAnnotated => CodeAnalysis.NullableAnnotation.NotAnnotated,\n\n                // A value type may be oblivious or not annotated depending on whether the type reference\n                // is from source or metadata. (Binding using the #nullable context only when setting the annotation\n                // to avoid checking IsValueType early.) The annotation is normalized here in the public API.\n                NullableAnnotation.Oblivious when type?.IsValueType == true => CodeAnalysis.NullableAnnotation.NotAnnotated,\n                NullableAnnotation.Oblivious => CodeAnalysis.NullableAnnotation.None,\n\n                NullableAnnotation.Ignored => CodeAnalysis.NullableAnnotation.None,\n\n                _ => throw ExceptionUtilities.UnexpectedValue(annotation)\n            } 252613"];
18175 [label="var kind = TypeKind; 252614"];
18176 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 252615"];
18177 [label="param NamespaceOrTypeSymbol(this) 252616"];
18178 [label="param Symbol(this) 252617"];
18179 [label="protected CodeAnalysis.NullableAnnotation NullableAnnotation { get; } 252618"];
18180 [label="_underlying 252619"];
18181 [label="Debug.Assert(underlying is object); 252620"];
18182 [label="Debug.Assert(!underlying.IsErrorType()); 252621"];
18183 [label="param IsErrorType(this TypeSymbol type) 252622"];
18184 [label="RoslynDebug.Assert((object)type != null); 252623"];
18185 [label="RoslynDebug.Assert((object)type != null); 252624"];
18186 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 252625"];
18187 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 252626"];
18188 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 252627"];
18189 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 252628"];
18190 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 252629"];
18191 [label="ToDisplayParts(symbol, format) 252630"];
18192 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 252631"];
18193 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 252632"];
18194 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 252633"];
18195 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 252634"];
18196 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 252635"];
18197 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 252636"];
18198 [label="param ToDisplayParts(int positionOpt) 252637"];
18199 [label="param ToDisplayParts(SymbolDisplayFormat format) 252638"];
18200 [label="param ToDisplayParts(bool minimal) 252639"];
18201 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 252640"];
18202 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 252641"];
18203 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 252642"];
18204 [label="Debug.Assert(semanticModelOpt == null); 252643"];
18205 [label="Debug.Assert(semanticModelOpt == null); 252644"];
18206 [label="Debug.Assert(positionOpt < 0); 252645"];
18207 [label="Debug.Assert(positionOpt < 0); 252646"];
18208 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 252647"];
18209 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 252648"];
18210 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252649"];
18211 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252650"];
18212 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252651"];
18213 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252652"];
18214 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 252653"];
18215 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 252654"];
18216 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 252655"];
18217 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 252656"];
18218 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 252657"];
18219 [label="param SymbolDisplayVisitor(int positionOpt) 252658"];
18220 [label="param SymbolDisplayVisitor(this) 252659"];
18221 [label="builder 252660"];
18222 [label="format 252661"];
18223 [label="true 252662"];
18224 [label="semanticModelOpt 252663"];
18225 [label="positionOpt 252664"];
18226 [label="param SymbolDisplayVisitor(this) 252665"];
18227 [label="_escapeKeywordIdentifiers 252666"];
18228 [label="_lazyAliasMap 252667"];
18229 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 252668"];
18230 [label="symbol.Accept(visitor); 252669"];
18231 [label="symbol.Accept(visitor) 252670"];
18232 [label="param Accept(SymbolVisitor visitor) 252671"];
18233 [label="Accept(visitor); 252672"];
18234 [label="Accept(visitor) 252673"];
18235 [label="param Accept(SymbolVisitor visitor) 252674"];
18236 [label="visitor.VisitNamedType(this) 252675"];
18237 [label="param VisitNamedType(this) 252676"];
18238 [label="VisitNamedTypeWithoutNullability(symbol) 252677"];
18239 [label="param VisitNamedTypeWithoutNullability(this) 252678"];
18240 [label="if (this.IsMinimizing && TryAddAlias(symbol, builder))\n            {\n                return;\n            } 252679"];
18241 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252680"];
18242 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252681"];
18243 [label="symbol.IsNativeIntegerType 252682"];
18244 [label="=> UnderlyingTypeSymbol.IsNativeIntegerType 252683"];
18245 [label="UnderlyingTypeSymbol 252684"];
18246 [label="=> _underlying 252685"];
18247 [label="UnderlyingTypeSymbol.IsNativeIntegerType 252686"];
18248 [label="=> false 252687"];
18249 [label="false 252688"];
18250 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252689"];
18251 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseSpecialTypes) ||\n                (symbol.IsNativeIntegerType && !format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseNativeIntegerUnderlyingType)))\n            {\n                if (AddSpecialTypeKeyword(symbol))\n                {\n                    //if we're using special type keywords and this is a special type, then no other work is required\n                    return;\n                }\n            } 252690"];
18252 [label="if (!format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.ExpandNullable))\n            {\n                //if we're expanding nullable, we just visit nullable types normally\n                if (ITypeSymbolHelpers.IsNullableType(symbol) && !symbol.IsDefinition)\n                {\n                    // Can't have a type called 'int*?'.\n                    var typeArg = symbol.TypeArguments[0];\n                    if (typeArg.TypeKind != TypeKind.Pointer)\n                    {\n                        typeArg.Accept(this.NotFirstVisitor);\n                        AddCustomModifiersIfRequired(symbol.GetTypeArgumentCustomModifiers(0), leadingSpace: true, trailingSpace: false);\n\n                        AddPunctuation(SyntaxKind.QuestionToken);\n\n                        //visiting the underlying type did all of the work for us\n                        return;\n                    }\n                }\n            } 252691"];
18253 [label="symbol.IsTupleType 252692"];
18254 [label="=> UnderlyingTypeSymbol.IsTupleType 252693"];
18255 [label="UnderlyingTypeSymbol 252694"];
18256 [label="=> _underlying 252695"];
18257 [label="UnderlyingTypeSymbol.IsTupleType 252696"];
18258 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 252697"];
18259 [label="_ 252698"];
18260 [label="tupleCardinality: out _ 252699"];
18261 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 252700"];
18262 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 252701"];
18263 [label="param IsTupleTypeOfCardinality(this) 252702"];
18264 [label="IsUnboundGenericType 252703"];
18265 [label="get\n            {\n                return false;\n            } 252704"];
18266 [label="return false; 252705"];
18267 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252706"];
18268 [label="ContainingSymbol 252707"];
18269 [label="get\n            {\n                return _container;\n            } 252708"];
18270 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252709"];
18271 [label=".Kind 252710"];
18272 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 252711"];
18273 [label="return SymbolKind.Namespace; 252712"];
18274 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252713"];
18275 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252714"];
18276 [label="ContainingNamespace 252715"];
18277 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252716"];
18278 [label="this.ContainingSymbol 252717"];
18279 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252718"];
18280 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252719"];
18281 [label="ContainingNamespace.ContainingNamespace 252720"];
18282 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252721"];
18283 [label="this.ContainingSymbol 252722"];
18284 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252723"];
18285 [label=".IsGlobalNamespace 252724"];
18286 [label="get\n            {\n                return false;\n            } 252725"];
18287 [label="return false; 252726"];
18288 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252727"];
18289 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252728"];
18290 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252729"];
18291 [label="tupleCardinality = 0; 252730"];
18292 [label="return false; 252731"];
18293 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 252732"];
18294 [label="if (this.IsMinimizing || (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol)))\n            {\n                MinimallyQualify(symbol);\n                return;\n            } 252733"];
18295 [label="AddTypeKind(symbol); 252734"];
18296 [label="AddTypeKind(symbol) 252735"];
18297 [label="param AddTypeKind(INamedTypeSymbol symbol) 252736"];
18298 [label="param AddTypeKind(this) 252737"];
18299 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 252738"];
18300 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeTypeKeyword))\n            {\n                if (symbol.IsAnonymousType)\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'AnonymousType'));\n                    AddSpace();\n                }\n                else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n                {\n                    builder.Add(new SymbolDisplayPart(SymbolDisplayPartKind.AnonymousTypeIndicator, null, 'Tuple'));\n                    AddSpace();\n                }\n                else\n                {\n                    switch (symbol.TypeKind)\n                    {\n                        case TypeKind.Class when symbol.IsRecord:\n                            AddKeyword(SyntaxKind.RecordKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Module:\n                        case TypeKind.Class:\n                            AddKeyword(SyntaxKind.ClassKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Enum:\n                            AddKeyword(SyntaxKind.EnumKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Delegate:\n                            AddKeyword(SyntaxKind.DelegateKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Interface:\n                            AddKeyword(SyntaxKind.InterfaceKeyword);\n                            AddSpace();\n                            break;\n\n                        case TypeKind.Struct:\n                            if (symbol.IsReadOnly)\n                            {\n                                AddKeyword(SyntaxKind.ReadOnlyKeyword);\n                                AddSpace();\n                            }\n\n                            if (symbol.IsRefLikeType)\n                            {\n                                AddKeyword(SyntaxKind.RefKeyword);\n                                AddSpace();\n                            }\n\n                            AddKeyword(SyntaxKind.StructKeyword);\n                            AddSpace();\n                            break;\n                    }\n                }\n            } 252739"];
18301 [label="AddTypeKind(symbol); 252740"];
18302 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var invokeMethod = symbol.DelegateInvokeMethod;\n                    if (invokeMethod.ReturnsByRef)\n                    {\n                        AddRefIfRequired();\n                    }\n                    else if (invokeMethod.ReturnsByRefReadonly)\n                    {\n                        AddRefReadonlyIfRequired();\n                    }\n\n                    if (invokeMethod.ReturnsVoid)\n                    {\n                        AddKeyword(SyntaxKind.VoidKeyword);\n                    }\n                    else\n                    {\n                        AddReturnType(symbol.DelegateInvokeMethod);\n                    }\n\n                    AddSpace();\n                }\n            } 252741"];
18303 [label="CanShowDelegateSignature(symbol) 252742"];
18304 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252743"];
18305 [label="param CanShowDelegateSignature(this) 252744"];
18306 [label="symbol.TypeKind 252745"];
18307 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 252746"];
18308 [label="UnderlyingTypeSymbol 252747"];
18309 [label="UnderlyingTypeSymbol.TypeKind 252748"];
18310 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252749"];
18311 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252750"];
18312 [label="symbol.ContainingSymbol 252751"];
18313 [label="UnderlyingSymbol 252752"];
18314 [label="UnderlyingSymbol.ContainingSymbol 252753"];
18315 [label="UnderlyingSymbol.ContainingSymbol.GetPublicSymbol() 252754"];
18316 [label="symbol.GetPublicSymbol<ISymbol>() 252755"];
18317 [label=".ISymbol 252756"];
18318 [label="ShouldVisitNamespace(containingSymbol) 252757"];
18319 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 252758"];
18320 [label="param ShouldVisitNamespace(this) 252759"];
18321 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 252760"];
18322 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252761"];
18323 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252762"];
18324 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 252763"];
18325 [label="namespaceSymbol.IsGlobalNamespace 252764"];
18326 [label="=> _underlying.IsGlobalNamespace 252765"];
18327 [label="_underlying.IsGlobalNamespace 252766"];
18328 [label="get\n            {\n                return false;\n            } 252767"];
18329 [label="return false; 252768"];
18330 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 252769"];
18331 [label="if (ShouldVisitNamespace(containingSymbol))\n            {\n                var namespaceSymbol = (INamespaceSymbol)containingSymbol;\n                var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error;\n\n                if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 252770"];
18332 [label="namespaceSymbol.IsGlobalNamespace 252771"];
18333 [label="=> _underlying.IsGlobalNamespace 252772"];
18334 [label="get\n            {\n                return false;\n            } 252773"];
18335 [label="var shouldSkip = namespaceSymbol.IsGlobalNamespace && symbol.TypeKind == TypeKind.Error; 252774"];
18336 [label="if (!shouldSkip)\n                {\n                    namespaceSymbol.Accept(this.NotFirstVisitor);\n                    AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 252775"];
18337 [label="this.NotFirstVisitor 252776"];
18338 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 252777"];
18339 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 252778"];
18340 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 252779"];
18341 [label="param SymbolDisplayVisitor(this) 252780"];
18342 [label="isFirstSymbolVisited 252781"];
18343 [label="param SymbolDisplayVisitor(this) 252782"];
18344 [label="_escapeKeywordIdentifiers 252783"];
18345 [label="_lazyAliasMap 252784"];
18346 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 252785"];
18347 [label="namespaceSymbol.Accept(this.NotFirstVisitor) 252786"];
18348 [label="visitor.VisitNamespace(this) 252787"];
18349 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 252788"];
18350 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 252789"];
18351 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 252790"];
18352 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 252791"];
18353 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252792"];
18354 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 252793"];
18355 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 252794"];
18356 [label="=> _underlying.IsGlobalNamespace 252795"];
18357 [label="get\n            {\n                return false;\n            } 252796"];
18358 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 252797"];
18359 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 252798"];
18360 [label="get\n            {\n                return true;\n            } 252799"];
18361 [label="=> _underlying.IsGlobalNamespace 252800"];
18362 [label="get\n            {\n                return false;\n            } 252801"];
18363 [label="symbol.IsGlobalNamespace 252802"];
18364 [label="=> _underlying.IsGlobalNamespace 252803"];
18365 [label="get\n            {\n                return false;\n            } 252804"];
18366 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 252805"];
18367 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 252806"];
18368 [label="symbol.Name 252807"];
18369 [label="UnderlyingSymbol 252808"];
18370 [label="UnderlyingSymbol.Name 252809"];
18371 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 252810"];
18372 [label="param CreatePart(SymbolDisplayPartKind kind) 252811"];
18373 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 252812"];
18374 [label="return new SymbolDisplayPart(kind, symbol, text); 252813"];
18375 [label="visitor.VisitNamespace(this); 252814"];
18376 [label="Accept(visitor); 252815"];
18377 [label="namespaceSymbol.Accept(this.NotFirstVisitor); 252816"];
18378 [label="namespaceSymbol.IsGlobalNamespace 252817"];
18379 [label="=> _underlying.IsGlobalNamespace 252818"];
18380 [label="get\n            {\n                return false;\n            } 252819"];
18381 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 252820"];
18382 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 252821"];
18383 [label="param AddPunctuation(this) 252822"];
18384 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 252823"];
18385 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 252824"];
18386 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 252825"];
18387 [label="param CreatePart(SymbolDisplayPartKind kind) 252826"];
18388 [label="param CreatePart(ISymbol symbol) 252827"];
18389 [label="param CreatePart(this) 252828"];
18390 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 252829"];
18391 [label="return new SymbolDisplayPart(kind, symbol, text); 252830"];
18392 [label="return new SymbolDisplayPart(kind, symbol, text); 252831"];
18393 [label="AddPunctuation(namespaceSymbol.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 252832"];
18394 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypes ||\n                format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                }\n            } 252833"];
18395 [label="symbol.ContainingType 252834"];
18396 [label="get\n            {\n                return UnderlyingSymbol.ContainingType.GetPublicSymbol();\n            } 252835"];
18397 [label="UnderlyingSymbol 252836"];
18398 [label="=> _underlying 252837"];
18399 [label="return UnderlyingSymbol.ContainingType.GetPublicSymbol(); 252838"];
18400 [label="UnderlyingSymbol.ContainingType 252839"];
18401 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 252840"];
18402 [label="UnderlyingSymbol.ContainingType.GetPublicSymbol() 252841"];
18403 [label="param GetPublicSymbol(this NamedTypeSymbol? symbol) 252842"];
18404 [label="return symbol.GetPublicSymbol<INamedTypeSymbol>(); 252843"];
18405 [label="symbol.GetPublicSymbol<INamedTypeSymbol>() 252844"];
18406 [label="param GetPublicSymbol(this Symbol? symbol) 252845"];
18407 [label="if (IncludeNamedType(symbol.ContainingType))\n                {\n                    symbol.ContainingType.Accept(this.NotFirstVisitor);\n                    AddPunctuation(SyntaxKind.DotToken);\n                } 252846"];
18408 [label="IncludeNamedType(symbol.ContainingType) 252847"];
18409 [label="param IncludeNamedType(INamedTypeSymbol namedType) 252848"];
18410 [label="param IncludeNamedType(this) 252849"];
18411 [label="if (namedType is null)\n            {\n                return false;\n            } 252850"];
18412 [label="return false; 252851"];
18413 [label="AddNameAndTypeArgumentsOrParameters(symbol) 252852"];
18414 [label="param AddNameAndTypeArgumentsOrParameters(this) 252853"];
18415 [label="symbol.IsAnonymousType 252854"];
18416 [label="=> UnderlyingTypeSymbol.IsAnonymousType 252855"];
18417 [label="UnderlyingTypeSymbol 252856"];
18418 [label="=> _underlying 252857"];
18419 [label="UnderlyingTypeSymbol.IsAnonymousType 252858"];
18420 [label="get\n            {\n                return false;\n            } 252859"];
18421 [label="return false; 252860"];
18422 [label="if (symbol.IsAnonymousType)\n            {\n                AddAnonymousTypeName(symbol);\n                return;\n            }\n            else if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252861"];
18423 [label="symbol.IsTupleType 252862"];
18424 [label="=> UnderlyingTypeSymbol.IsTupleType 252863"];
18425 [label="UnderlyingTypeSymbol 252864"];
18426 [label="=> _underlying 252865"];
18427 [label="UnderlyingTypeSymbol.IsTupleType 252866"];
18428 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 252867"];
18429 [label="_ 252868"];
18430 [label="tupleCardinality: out _ 252869"];
18431 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 252870"];
18432 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 252871"];
18433 [label="param IsTupleTypeOfCardinality(this) 252872"];
18434 [label="IsUnboundGenericType 252873"];
18435 [label="get\n            {\n                return false;\n            } 252874"];
18436 [label="return false; 252875"];
18437 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252876"];
18438 [label="ContainingSymbol 252877"];
18439 [label="get\n            {\n                return _container;\n            } 252878"];
18440 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252879"];
18441 [label=".Kind 252880"];
18442 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 252881"];
18443 [label="return SymbolKind.Namespace; 252882"];
18444 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252883"];
18445 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252884"];
18446 [label="ContainingNamespace 252885"];
18447 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252886"];
18448 [label="this.ContainingSymbol 252887"];
18449 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252888"];
18450 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252889"];
18451 [label="ContainingNamespace.ContainingNamespace 252890"];
18452 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 252891"];
18453 [label="this.ContainingSymbol 252892"];
18454 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 252893"];
18455 [label=".IsGlobalNamespace 252894"];
18456 [label="get\n            {\n                return false;\n            } 252895"];
18457 [label="return false; 252896"];
18458 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252897"];
18459 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252898"];
18460 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 252899"];
18461 [label="tupleCardinality = 0; 252900"];
18462 [label="return false; 252901"];
18463 [label="if (symbol.IsTupleType && !ShouldDisplayAsValueTuple(symbol))\n            {\n                AddTupleTypeName(symbol);\n                return;\n            } 252902"];
18464 [label="string symbolName = null; 252903"];
18465 [label="var illegalGenericInstantiationSymbol = underlyingTypeSymbol as NoPiaIllegalGenericInstantiationSymbol; 252904"];
18466 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252905"];
18467 [label="if ((object)illegalGenericInstantiationSymbol != null)\n            {\n                symbol = illegalGenericInstantiationSymbol.UnderlyingSymbol.GetPublicSymbol();\n            }\n            else\n            {\n                var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol;\n\n                if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                }\n            } 252906"];
18468 [label="var ambiguousCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaAmbiguousCanonicalTypeSymbol; 252907"];
18469 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252908"];
18470 [label="if ((object)ambiguousCanonicalTypeSymbol != null)\n                {\n                    symbol = ambiguousCanonicalTypeSymbol.FirstCandidate.GetPublicSymbol();\n                }\n                else\n                {\n                    var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol;\n\n                    if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    }\n                } 252909"];
18471 [label="var missingCanonicalTypeSymbol = underlyingTypeSymbol as NoPiaMissingCanonicalTypeSymbol; 252910"];
18472 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252911"];
18473 [label="if ((object)missingCanonicalTypeSymbol != null)\n                    {\n                        symbolName = missingCanonicalTypeSymbol.FullTypeName;\n                    } 252912"];
18474 [label="GetPartKind(symbol) 252913"];
18475 [label="symbol.TypeKind 252914"];
18476 [label="UnderlyingTypeSymbol 252915"];
18477 [label="UnderlyingTypeSymbol.TypeKind 252916"];
18478 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 252917"];
18479 [label="if (symbolName == null)\n            {\n                symbolName = symbol.Name;\n            } 252918"];
18480 [label="symbol.Name 252919"];
18481 [label="UnderlyingSymbol 252920"];
18482 [label="UnderlyingSymbol.Name 252921"];
18483 [label="if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName) &&\n                partKind == SymbolDisplayPartKind.ErrorTypeName &&\n                string.IsNullOrEmpty(symbolName))\n            {\n                builder.Add(CreatePart(partKind, symbol, '?'));\n            }\n            else\n            {\n                symbolName = RemoveAttributeSufficeIfNecessary(symbol, symbolName);\n                builder.Add(CreatePart(partKind, symbol, symbolName));\n            } 252922"];
18484 [label="param RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol) 252923"];
18485 [label="param RemoveAttributeSufficeIfNecessary(this) 252924"];
18486 [label="if (this.IsMinimizing &&\n                format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix) &&\n                semanticModelOpt.Compilation.IsAttributeType(symbol))\n            {\n                string nameWithoutAttributeSuffix;\n                if (symbolName.TryGetWithoutAttributeSuffix(out nameWithoutAttributeSuffix))\n                {\n                    var token = SyntaxFactory.ParseToken(nameWithoutAttributeSuffix);\n                    if (token.IsKind(SyntaxKind.IdentifierToken))\n                    {\n                        symbolName = nameWithoutAttributeSuffix;\n                    }\n                }\n            } 252925"];
18487 [label="if (format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes))\n            {\n                // Only the compiler can set the internal option and the compiler doesn't use other implementations of INamedTypeSymbol.\n                if (underlyingTypeSymbol?.MangleName == true)\n                {\n                    Debug.Assert(symbol.Arity > 0);\n                    builder.Add(CreatePart(InternalSymbolDisplayPartKind.Arity, null,\n                        MetadataHelpers.GetAritySuffix(symbol.Arity)));\n                }\n            }\n            else if (symbol.Arity > 0 && format.GenericsOptions.IncludesOption(SymbolDisplayGenericsOptions.IncludeTypeParameters))\n            {\n                // It would be nice to handle VB symbols too, but it's not worth the effort.\n                if (underlyingTypeSymbol is UnsupportedMetadataTypeSymbol || underlyingTypeSymbol is MissingMetadataTypeSymbol || symbol.IsUnboundGenericType)\n                {\n                    AddPunctuation(SyntaxKind.LessThanToken);\n                    for (int i = 0; i < symbol.Arity - 1; i++)\n                    {\n                        AddPunctuation(SyntaxKind.CommaToken);\n                    }\n\n                    AddPunctuation(SyntaxKind.GreaterThanToken);\n                }\n                else\n                {\n                    ImmutableArray<ImmutableArray<CustomModifier>> modifiers = GetTypeArgumentsModifiers(underlyingTypeSymbol);\n                    AddTypeArguments(symbol, modifiers);\n\n                    AddDelegateParameters(symbol);\n\n                    // TODO: do we want to skip these if we're being visited as a containing type?\n                    AddTypeParameterConstraints(symbol.TypeArguments);\n                }\n            }\n            else\n            {\n                AddDelegateParameters(symbol);\n            } 252926"];
18488 [label="get\n                {\n                    return 0;\n                } 252927"];
18489 [label="AddDelegateParameters(symbol); 252928"];
18490 [label="AddDelegateParameters(symbol) 252929"];
18491 [label="param AddDelegateParameters(INamedTypeSymbol symbol) 252930"];
18492 [label="param AddDelegateParameters(this) 252931"];
18493 [label="if (CanShowDelegateSignature(symbol))\n            {\n                if (format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndParameters ||\n                    format.DelegateStyle == SymbolDisplayDelegateStyle.NameAndSignature)\n                {\n                    var method = symbol.DelegateInvokeMethod;\n                    AddPunctuation(SyntaxKind.OpenParenToken);\n                    AddParametersIfRequired(hasThisParameter: false, isVarargs: method.IsVararg, parameters: method.Parameters);\n                    AddPunctuation(SyntaxKind.CloseParenToken);\n                }\n            } 252932"];
18494 [label="CanShowDelegateSignature(symbol) 252933"];
18495 [label="param CanShowDelegateSignature(INamedTypeSymbol symbol) 252934"];
18496 [label="param CanShowDelegateSignature(this) 252935"];
18497 [label="symbol.TypeKind 252936"];
18498 [label="get\n            {\n                return UnderlyingTypeSymbol.TypeKind;\n            } 252937"];
18499 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252938"];
18500 [label="return\n                isFirstSymbolVisited &&\n                symbol.TypeKind == TypeKind.Delegate &&\n                format.DelegateStyle != SymbolDisplayDelegateStyle.NameOnly &&\n                symbol.DelegateInvokeMethod != null; 252939"];
18501 [label=".OriginalDefinition 252940"];
18502 [label="get\n            {\n                return this;\n            } 252941"];
18503 [label="if (underlyingTypeSymbol?.OriginalDefinition is MissingMetadataTypeSymbol &&\n                format.CompilerInternalOptions.IncludesOption(SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes))\n            {\n                //add it as punctuation - it's just for testing\n                AddPunctuation(SyntaxKind.OpenBracketToken);\n                builder.Add(CreatePart(InternalSymbolDisplayPartKind.Other, symbol, 'missing'));\n                AddPunctuation(SyntaxKind.CloseBracketToken);\n            } 252942"];
18504 [label="AddNameAndTypeArgumentsOrParameters(symbol); 252943"];
18505 [label="VisitNamedTypeWithoutNullability(symbol); 252944"];
18506 [label="AddNullableAnnotations(symbol); 252945"];
18507 [label="AddNullableAnnotations(symbol) 252946"];
18508 [label="param AddNullableAnnotations(ITypeSymbol type) 252947"];
18509 [label="param AddNullableAnnotations(this) 252948"];
18510 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252949"];
18511 [label="ShouldAddNullableAnnotation(type) 252950"];
18512 [label="param ShouldAddNullableAnnotation(ITypeSymbol type) 252951"];
18513 [label="param ShouldAddNullableAnnotation(this) 252952"];
18514 [label="type.NullableAnnotation 252953"];
18515 [label="=> NullableAnnotation 252954"];
18516 [label="NullableAnnotation 252955"];
18517 [label="switch (type.NullableAnnotation)\n            {\n                case CodeAnalysis.NullableAnnotation.Annotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) &&\n                        !ITypeSymbolHelpers.IsNullableType(type) && !type.IsValueType)\n                    {\n                        return true;\n                    }\n                    break;\n\n                // LAFHIS\n                case CodeAnalysis.NullableAnnotation.NotAnnotated:\n                    if (format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) &&\n                        !type.IsValueType &&\n                        ((type is not Symbols.PublicModel.TypeSymbol) ||\n                        ((Symbols.PublicModel.TypeSymbol)type).UnderlyingTypeSymbol.IsTypeParameterDisallowingAnnotationInCSharp8() != true))\n                    {\n                        return true;\n                    }\n                    break;\n            } 252956"];
18518 [label="return false; 252957"];
18519 [label="if (ShouldAddNullableAnnotation(type))\n            {\n                AddPunctuation(type.NullableAnnotation == CodeAnalysis.NullableAnnotation.Annotated ? SyntaxKind.QuestionToken : SyntaxKind.ExclamationToken);\n            } 252958"];
18520 [label="AddNullableAnnotations(symbol); 252959"];
18521 [label="visitor.VisitNamedType(this); 252960"];
18522 [label="Accept(visitor); 252961"];
18523 [label="symbol.Accept(visitor); 252962"];
18524 [label="var sym2 = (classTest.GetMembers('AryField2').First() as FieldSymbol).Type; 252963"];
18525 [label="classTest.GetMembers('AryField2') 252964"];
18526 [label="param GetMembers(string name) 252965"];
18527 [label="param GetMembers(this) 252966"];
18528 [label="ImmutableArray<Symbol> members; 252967"];
18529 [label="members 252968"];
18530 [label="GetMembersByName() 252969"];
18531 [label="param GetMembersByName(this) 252970"];
18532 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 252971"];
18533 [label="this.state.HasComplete(CompletionPart.Members) 252972"];
18534 [label="param HasComplete(CompletionPart part) 252973"];
18535 [label="param HasComplete(this) 252974"];
18536 [label="return (_completeParts & (int)part) == (int)part; 252975"];
18537 [label="return _lazyMembersDictionary!; 252976"];
18538 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 252977"];
18539 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 252978"];
18540 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 252979"];
18541 [label="(classTest.GetMembers('AryField2').First() as FieldSymbol).Type 252980"];
18542 [label="=> TypeWithAnnotations.Type 252981"];
18543 [label="TypeWithAnnotations 252982"];
18544 [label="return GetFieldType(ConsList<FieldSymbol>.Empty); 252983"];
18545 [label="GetFieldType(ConsList<FieldSymbol>.Empty) 252984"];
18546 [label="param GetFieldType(ConsList<FieldSymbol> fieldsBeingBound) 252985"];
18547 [label="Debug.Assert(fieldsBeingBound != null); 252986"];
18548 [label="Debug.Assert(fieldsBeingBound != null); 252987"];
18549 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 252988"];
18550 [label="if (_lazyType != null)\n            {\n                return _lazyType.Value;\n            } 252989"];
18551 [label="VariableDeclaratorNode 252990"];
18552 [label="this.SyntaxNode 252991"];
18553 [label="return (CSharpSyntaxNode)_syntaxReference.GetSyntax(); 252992"];
18554 [label="GetFieldDeclaration(declarator) 252993"];
18555 [label="this.DeclaringCompilation 252994"];
18556 [label="this.Kind 252995"];
18557 [label="get\n            {\n                return SymbolKind.Field;\n            } 252996"];
18558 [label="return SymbolKind.Field; 252997"];
18559 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 252998"];
18560 [label="this.ContainingModule 252999"];
18561 [label="this.ContainingSymbol 253000"];
18562 [label="return (object)container != null ? container.ContainingModule : null; 253001"];
18563 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 253002"];
18564 [label="var diagnostics = DiagnosticBag.GetInstance(); 253003"];
18565 [label="TypeWithAnnotations type; 253004"];
18566 [label="type 253005"];
18567 [label="DiagnosticBag diagnosticsForFirstDeclarator = DiagnosticBag.GetInstance(); 253006"];
18568 [label="this.AssociatedSymbol 253007"];
18569 [label="get\n            {\n                return null;\n            } 253008"];
18570 [label="return null; 253009"];
18571 [label="Symbol associatedPropertyOrEvent = this.AssociatedSymbol; 253010"];
18572 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 253011"];
18573 [label="if ((object)associatedPropertyOrEvent != null && associatedPropertyOrEvent.Kind == SymbolKind.Event)\n            {\n                EventSymbol @event = (EventSymbol)associatedPropertyOrEvent;\n                if (@event.IsWindowsRuntimeEvent)\n                {\n                    NamedTypeSymbol tokenTableType = this.DeclaringCompilation.GetWellKnownType(WellKnownType.System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T);\n                    Binder.ReportUseSiteDiagnostics(tokenTableType, diagnosticsForFirstDeclarator, this.ErrorLocation);\n\n                    // CONSIDER: Do we want to guard against the possibility that someone has created their own EventRegistrationTokenTable<T>\n                    // type that has additional generic constraints?\n                    type = TypeWithAnnotations.Create(tokenTableType.Construct(ImmutableArray.Create(@event.TypeWithAnnotations)));\n                }\n                else\n                {\n                    type = @event.TypeWithAnnotations;\n                }\n            }\n            else\n            {\n                var binderFactory = compilation.GetBinderFactory(SyntaxTree);\n                var binder = binderFactory.GetBinder(typeSyntax);\n\n                binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n                if (!ContainingType.IsScriptClass)\n                {\n                    type = binder.BindType(typeSyntax, diagnosticsForFirstDeclarator);\n                }\n                else\n                {\n                    bool isVar;\n                    type = binder.BindTypeOrVarKeyword(typeSyntax, diagnostics, out isVar);\n\n                    Debug.Assert(type.HasType || isVar);\n\n                    if (isVar)\n                    {\n                        if (this.IsConst)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableCannotBeConst, typeSyntax.Location);\n                        }\n\n                        if (fieldsBeingBound.ContainsReference(this))\n                        {\n                            diagnostics.Add(ErrorCode.ERR_RecursivelyTypedVariable, this.ErrorLocation, this);\n                            type = default;\n                        }\n                        else if (fieldSyntax.Declaration.Variables.Count > 1)\n                        {\n                            diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_ImplicitlyTypedVariableMultipleDeclarator, typeSyntax.Location);\n                        }\n                        else if (this.IsConst && this.ContainingType.IsScriptClass)\n                        {\n                            // For const var in script, we won't try to bind the initializer (case below), as it can lead to an unbound recursion\n                            type = default;\n                        }\n                        else\n                        {\n                            fieldsBeingBound = new ConsList<FieldSymbol>(this, fieldsBeingBound);\n\n                            var initializerBinder = new ImplicitlyTypedFieldBinder(binder, fieldsBeingBound);\n                            var initializerOpt = initializerBinder.BindInferredVariableInitializer(diagnostics, RefKind.None, (EqualsValueClauseSyntax)declarator.Initializer, declarator);\n\n                            if (initializerOpt != null)\n                            {\n                                if ((object)initializerOpt.Type != null && !initializerOpt.Type.IsErrorType())\n                                {\n                                    type = TypeWithAnnotations.Create(initializerOpt.Type);\n                                }\n\n                                _lazyFieldTypeInferred = 1;\n                            }\n                        }\n\n                        if (!type.HasType)\n                        {\n                            type = TypeWithAnnotations.Create(binder.CreateErrorType('var'));\n                        }\n                    }\n                }\n\n                if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                }\n            } 253012"];
18574 [label="SyntaxTree 253013"];
18575 [label="var binderFactory = compilation.GetBinderFactory(SyntaxTree); 253014"];
18576 [label="compilation.GetBinderFactory(SyntaxTree) 253015"];
18577 [label="param GetBinderFactory(bool ignoreAccessibility = false) 253016"];
18578 [label="if (ignoreAccessibility && SimpleProgramNamedTypeSymbol.GetSimpleProgramEntryPoint(this) is object)\n            {\n                return GetBinderFactory(syntaxTree, ignoreAccessibility: true, ref _ignoreAccessibilityBinderFactories);\n            } 253017"];
18579 [label="return GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories); 253018"];
18580 [label="GetBinderFactory(syntaxTree, ignoreAccessibility: false, ref _binderFactories) 253019"];
18581 [label="param GetBinderFactory(bool ignoreAccessibility) 253020"];
18582 [label="ignoreAccessibility 253021"];
18583 [label="GetSyntaxTreeOrdinal(syntaxTree) 253022"];
18584 [label="this.ContainsSyntaxTree(tree) 253023"];
18585 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 253024"];
18586 [label="if (binderFactories == null)\n            {\n                binderFactories = new WeakReference<BinderFactory>[this.SyntaxTrees.Length];\n                binderFactories = Interlocked.CompareExchange(ref cachedBinderFactories, binderFactories, null) ?? binderFactories;\n            } 253025"];
18587 [label="BinderFactory? previousFactory; 253026"];
18588 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 253027"];
18589 [label="if (previousWeakReference != null && previousWeakReference.TryGetTarget(out previousFactory))\n            {\n                return previousFactory;\n            } 253028"];
18590 [label="return previousFactory; 253029"];
18591 [label="var binder = binderFactory.GetBinder(typeSyntax); 253030"];
18592 [label="binderFactory.GetBinder(typeSyntax) 253031"];
18593 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 253032"];
18594 [label="param GetBinder(Symbol memberOpt = null) 253033"];
18595 [label="InScript 253034"];
18596 [label="if ((!InScript || node.Kind() != SyntaxKind.CompilationUnit) && node.Parent != null)\n            {\n                node = node.Parent;\n            } 253035"];
18597 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 253036"];
18598 [label="return GetBinder(node, position, memberDeclarationOpt, memberOpt); 253037"];
18599 [label="GetBinder(node, position, memberDeclarationOpt, memberOpt) 253038"];
18600 [label="param GetBinder(CSharpSyntaxNode memberDeclarationOpt = null) 253039"];
18601 [label="param GetBinder(Symbol memberOpt = null) 253040"];
18602 [label="Debug.Assert(node != null); 253041"];
18603 [label="Debug.Assert(node != null); 253042"];
18604 [label="if (memberOpt is { ContainingSymbol: SourceMemberContainerTypeSymbol container })\n            {\n                container.AssertMemberExposure(memberOpt);\n            } 253043"];
18605 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 253044"];
18606 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 253045"];
18607 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt) 253046"];
18608 [label="param Initialize(CSharpSyntaxNode memberDeclarationOpt) 253047"];
18609 [label="param Initialize(Symbol memberOpt) 253048"];
18610 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 253049"];
18611 [label="memberDeclarationOpt == null 253050"];
18612 [label="param ==(Symbol left) 253051"];
18613 [label="param ==(Symbol right) 253052"];
18614 [label="if (right is null)\n            {\n                return left is null;\n            } 253053"];
18615 [label="return left is null; 253054"];
18616 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 253055"];
18617 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 253056"];
18618 [label="Debug.Assert((memberDeclarationOpt == null) == (memberOpt == null)); 253057"];
18619 [label="visitor.Initialize(position, memberDeclarationOpt, memberOpt); 253058"];
18620 [label="visitor.Visit(node) 253059"];
18621 [label="VisitCore(node) 253060"];
18622 [label="return ((CSharpSyntaxNode)node).Accept(this); 253061"];
18623 [label="VisitCore(parent.Parent) 253062"];
18624 [label="VisitCore(parent.Parent) 253063"];
18625 [label="VisitTypeDeclarationCore(node) 253064"];
18626 [label="NodeUsage extraInfo = NodeUsage.Normal; 253065"];
18627 [label="if (parent.OpenBraceToken != default &&\n                    parent.CloseBraceToken != default &&\n                    (LookupPosition.IsBetweenTokens(_position, parent.OpenBraceToken, parent.CloseBraceToken) ||\n                     LookupPosition.IsInAttributeSpecification(_position, parent.AttributeLists)))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsInTypeParameterList(_position, parent))\n                {\n                    extraInfo = NodeUsage.NamedTypeBodyOrTypeParameters;\n                }\n                else if (LookupPosition.IsBetweenTokens(_position, parent.Keyword, parent.OpenBraceToken))\n                {\n                    extraInfo = NodeUsage.NamedTypeBaseListOrParameterList;\n                } 253066"];
18628 [label="VisitTypeDeclarationCore(parent, extraInfo) 253067"];
18629 [label="CreateBinderCacheKey(parent, extraInfo) 253068"];
18630 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 253069"];
18631 [label="Debug.Assert(BitArithmeticUtilities.CountBits((uint)usage) <= 1, 'Not a flags enum.'); 253070"];
18632 [label="return new BinderCacheKey(node, usage); 253071"];
18633 [label="new BinderCacheKey(node, usage) 253072"];
18634 [label="param BinderCacheKey(this) 253073"];
18635 [label="var key = CreateBinderCacheKey(parent, extraInfo); 253074"];
18636 [label="Binder resultBinder; 253075"];
18637 [label="binderCache 253076"];
18638 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 253077"];
18639 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 253078"];
18640 [label="if (!binderCache.TryGetValue(key, out resultBinder))\n                {\n                    // if node is in the optional type parameter list, then members and type parameters are in scope \n                    //     (needed when binding attributes applied to type parameters).\n                    // if node is in the base clause, type parameters are in scope.\n                    // if node is in the body, then members and type parameters are in scope.\n\n                    // a binder for the body of the type enclosing this type\n                    resultBinder = VisitCore(parent.Parent);\n\n                    if (extraInfo != NodeUsage.Normal)\n                    {\n                        var typeSymbol = ((NamespaceOrTypeSymbol)resultBinder.ContainingMemberOrLambda).GetSourceTypeMember(parent);\n\n                        if (extraInfo == NodeUsage.NamedTypeBaseListOrParameterList)\n                        {\n                            // even though there could be no type parameter, we need this binder \n                            // for its 'IsAccessible'\n                            resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                        }\n                        else\n                        {\n                            resultBinder = new InContainerBinder(typeSymbol, resultBinder);\n\n                            if (parent.TypeParameterList != null)\n                            {\n                                resultBinder = new WithClassTypeParametersBinder(typeSymbol, resultBinder);\n                            }\n                        }\n                    }\n\n                    resultBinder = resultBinder.WithUnsafeRegionIfNecessary(parent.Modifiers);\n\n                    binderCache.TryAdd(key, resultBinder);\n                } 253079"];
18641 [label="param Equals(BinderCacheKey other) 253080"];
18642 [label="param Equals(this) 253081"];
18643 [label="return syntaxNode == other.syntaxNode && this.usage == other.usage; 253082"];
18644 [label="VisitCore(parent.Parent).WithUnsafeRegionIfNecessary(parent.Modifiers) 253083"];
18645 [label="return (this.Flags.Includes(BinderFlags.UnsafeRegion) || !modifiers.Any(SyntaxKind.UnsafeKeyword))\n                ? this\n                : new Binder(this, this.Flags | BinderFlags.UnsafeRegion); 253084"];
18646 [label="this.Flags.Includes(BinderFlags.UnsafeRegion) 253085"];
18647 [label="param Includes(BinderFlags other) 253086"];
18648 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 253087"];
18649 [label="binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this) 253088"];
18650 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags) 253089"];
18651 [label="param WithAdditionalFlagsAndContainingMemberOrLambda(Symbol containing) 253090"];
18652 [label="Debug.Assert((object)containing != null); 253091"];
18653 [label="Debug.Assert((object)containing != null); 253092"];
18654 [label="return new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing); 253093"];
18655 [label="new BinderWithContainingMemberOrLambda(this, this.Flags | flags, containing) 253094"];
18656 [label="param BinderWithContainingMemberOrLambda(Symbol containingMemberOrLambda) 253095"];
18657 [label="param BinderWithContainingMemberOrLambda(this) 253096"];
18658 [label="param BinderWithContainingMemberOrLambda(this) 253097"];
18659 [label="param Binder(this) 253098"];
18660 [label="internal CSharpCompilation Compilation { get; } 253099"];
18661 [label="Flags 253100"];
18662 [label="protected internal Binder? Next { get; } 253101"];
18663 [label="_lazyConversions 253102"];
18664 [label="_lazyOverloadResolution 253103"];
18665 [label="RoslynDebug.Assert(next != null); 253104"];
18666 [label="RoslynDebug.Assert(next != null); 253105"];
18667 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 253106"];
18668 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion)); 253107"];
18669 [label="flags.Includes(BinderFlags.UncheckedRegion | BinderFlags.CheckedRegion) 253108"];
18670 [label="param Includes(this BinderFlags self) 253109"];
18671 [label="param Includes(BinderFlags other) 253110"];
18672 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 253111"];
18673 [label="RoslynDebug.Assert(!flags.Includes(BinderFlags.InNestedFinallyBlock) || flags.Includes(BinderFlags.InFinallyBlock | BinderFlags.InCatchBlock)); 253112"];
18674 [label="flags.Includes(BinderFlags.InNestedFinallyBlock) 253113"];
18675 [label="param Includes(this BinderFlags self) 253114"];
18676 [label="param Includes(BinderFlags other) 253115"];
18677 [label="_containingMemberOrLambda 253116"];
18678 [label="Debug.Assert(containingMemberOrLambda != null); 253117"];
18679 [label="containingMemberOrLambda != null 253118"];
18680 [label="param !=(Symbol left) 253119"];
18681 [label="param !=(Symbol right) 253120"];
18682 [label="if (right is null)\n            {\n                return left is object;\n            } 253121"];
18683 [label="return left is object; 253122"];
18684 [label="Debug.Assert(containingMemberOrLambda != null); 253123"];
18685 [label="_containingMemberOrLambda 253124"];
18686 [label="binder = binder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this); 253125"];
18687 [label="ContainingType 253126"];
18688 [label="ContainingType.IsScriptClass 253127"];
18689 [label="var kind = this.declaration.Declarations[0].Kind; 253128"];
18690 [label="param BindType(ConsList<TypeSymbol> basesBeingResolved = null) 253129"];
18691 [label="param BindType(bool suppressUseSiteDiagnostics = false) 253130"];
18692 [label="param BindTypeOrAlias(ConsList<TypeSymbol> basesBeingResolved = null) 253131"];
18693 [label="param BindTypeOrAlias(bool suppressUseSiteDiagnostics = false) 253132"];
18694 [label="Debug.Assert(diagnostics != null); 253133"];
18695 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 253134"];
18696 [label="param BindNamespaceOrTypeOrAliasSymbol(ConsList<TypeSymbol> basesBeingResolved) 253135"];
18697 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 253136"];
18698 [label="param BindArrayType(bool permitDimensions) 253137"];
18699 [label="param BindArrayType(ConsList<TypeSymbol> basesBeingResolved) 253138"];
18700 [label="Debug.Assert(diagnostics != null); 253139"];
18701 [label="var symbol = BindNamespaceOrTypeOrAliasSymbol(syntax, diagnostics, basesBeingResolved, basesBeingResolved != null || suppressUseSiteDiagnostics); 253140"];
18702 [label="param BindNamespaceOrTypeOrAliasSymbol(bool suppressUseSiteDiagnostics) 253141"];
18703 [label="param BindPredefinedTypeSymbol(DiagnosticBag diagnostics) 253142"];
18704 [label="param GetSpecialType(DiagnosticBag diagnostics) 253143"];
18705 [label="param GetSpecialType(SyntaxNode node) 253144"];
18706 [label="param GetSpecialType(SyntaxNode node) 253145"];
18707 [label="param GetSpecialType(DiagnosticBag diagnostics) 253146"];
18708 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 253147"];
18709 [label="NamedTypeSymbol result; 253148"];
18710 [label="GetBoundReferenceManager(); 253149"];
18711 [label="this.Modules 253150"];
18712 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 253151"];
18713 [label="module.GetReferencedAssemblies() 253152"];
18714 [label="param GetReferencedAssemblies(this) 253153"];
18715 [label="AssertReferencesInitialized() 253154"];
18716 [label="param AssertReferencesInitialized(this) 253155"];
18717 [label="Debug.Assert(_moduleReferences != null); 253156"];
18718 [label="Debug.Assert(_moduleReferences != null); 253157"];
18719 [label="AssertReferencesInitialized(); 253158"];
18720 [label="return _moduleReferences.Identities; 253159"];
18721 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 253160"];
18722 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 253161"];
18723 [label="result.SpecialType 253162"];
18724 [label="Debug.Assert(result.SpecialType == specialType); 253163"];
18725 [label="Debug.Assert((object)typeSymbol != null, 'Expect an error type if special type isn't found'); 253164"];
18726 [label="param ReportUseSiteDiagnostics(DiagnosticBag diagnostics) 253165"];
18727 [label="param ReportUseSiteDiagnostics(SyntaxNode node) 253166"];
18728 [label="return _lazyUseSiteDiagnostic; 253167"];
18729 [label="DiagnosticInfo info = symbol.GetUseSiteDiagnostic(); 253168"];
18730 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 253169"];
18731 [label="return info != null && Symbol.ReportUseSiteDiagnostic(info, diagnostics, node.Location); 253170"];
18732 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 253171"];
18733 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 253172"];
18734 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 253173"];
18735 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 253174"];
18736 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 253175"];
18737 [label="typeSymbol.IsNullableType() 253176"];
18738 [label="param IsNullableType(this TypeSymbol type) 253177"];
18739 [label="var a1 = defaultType is null; 253178"];
18740 [label="!a1 253179"];
18741 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 253180"];
18742 [label="defaultType.IsNullableType() 253181"];
18743 [label="param IsNullableType(this TypeSymbol type) 253182"];
18744 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 253183"];
18745 [label="Debug.Assert(a1 || a2 != true || a3); 253184"];
18746 [label="Debug.Assert(a1 || a2 != true || a3); 253185"];
18747 [label="Debug.Assert(extensions != null); 253186"];
18748 [label="Debug.Assert(extensions != null); 253187"];
18749 [label="typeWithAnnotations.HasType 253188"];
18750 [label="=> !(DefaultType is null) 253189"];
18751 [label="Debug.Assert(typeWithAnnotations.HasType); 253190"];
18752 [label="_symbol = null; 253191"];
18753 [label="_symbol 253192"];
18754 [label="_isNullableEnabled = false; 253193"];
18755 [label="_isNullableEnabled 253194"];
18756 [label="param ReportDiagnosticsIfObsolete(Binder binder) 253195"];
18757 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 253196"];
18758 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253197"];
18759 [label="binder 253198"];
18760 [label="syntax 253199"];
18761 [label="diagnostics 253200"];
18762 [label="param ReportDiagnosticsIfObsolete(Binder binder) 253201"];
18763 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 253202"];
18764 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253203"];
18765 [label="param ReportDiagnosticsIfObsolete(this) 253204"];
18766 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253205"];
18767 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253206"];
18768 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253207"];
18769 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 253208"];
18770 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 253209"];
18771 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 253210"];
18772 [label="=> defaultType 253211"];
18773 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253212"];
18774 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 253213"];
18775 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 253214"];
18776 [label="param ReportDiagnosticsIfObsolete(this) 253215"];
18777 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253216"];
18778 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 253217"];
18779 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 253218"];
18780 [label="param ReportDiagnosticsIfObsolete(this) 253219"];
18781 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 253220"];
18782 [label="this.ContainingMemberOrLambda 253221"];
18783 [label="get { return _containingMemberOrLambda; } 253222"];
18784 [label="return _containingMemberOrLambda; 253223"];
18785 [label="this.ContainingType 253224"];
18786 [label="get\n            {\n                var member = this.ContainingMemberOrLambda;\n                RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType);\n                return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                };\n            } 253225"];
18787 [label="this.ContainingMemberOrLambda 253226"];
18788 [label="get { return _containingMemberOrLambda; } 253227"];
18789 [label="return _containingMemberOrLambda; 253228"];
18790 [label="var member = this.ContainingMemberOrLambda; 253229"];
18791 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 253230"];
18792 [label="member.Kind 253231"];
18793 [label="get\n            {\n                return SymbolKind.Field;\n            } 253232"];
18794 [label="return SymbolKind.Field; 253233"];
18795 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 253234"];
18796 [label="RoslynDebug.Assert(member is null || member.Kind != SymbolKind.ErrorType); 253235"];
18797 [label="member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                } 253236"];
18798 [label="member.ContainingType 253237"];
18799 [label="return member switch\n                {\n                    null => null,\n                    NamedTypeSymbol namedType => namedType,\n                    _ => member.ContainingType\n                }; 253238"];
18800 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253239"];
18801 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 253240"];
18802 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 253241"];
18803 [label="param ReportDiagnosticsIfObsolete(Symbol? containingMember) 253242"];
18804 [label="param ReportDiagnosticsIfObsolete(NamedTypeSymbol? containingType) 253243"];
18805 [label="param ReportDiagnosticsIfObsolete(BinderFlags location) 253244"];
18806 [label="symbol.Kind 253245"];
18807 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 253246"];
18808 [label="RoslynDebug.Assert(symbol.Kind == SymbolKind.NamedType ||\n                         symbol.Kind == SymbolKind.Field ||\n                         symbol.Kind == SymbolKind.Method ||\n                         symbol.Kind == SymbolKind.Event ||\n                         symbol.Kind == SymbolKind.Property); 253247"];
18809 [label="symbol.Kind 253248"];
18810 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 253249"];
18811 [label="if (symbol.Kind == SymbolKind.Method)\n            {\n                symbol = ((MethodSymbol)symbol).ConstructedFrom;\n            } 253250"];
18812 [label="param GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt) 253251"];
18813 [label="bool checkOverridingSymbol = hasBaseReceiver && !ReferenceEquals(symbol, leastOverriddenSymbol); 253252"];
18814 [label="if (checkOverridingSymbol)\n            {\n                // If we have a base receiver, we must be done with declaration binding, so it should\n                // be safe to decode diagnostics.  We want to do this since reporting for the overriding\n                // member is conditional on reporting for the overridden member (i.e. we need a definite\n                // answer so we don't double-report).  You might think that double reporting just results\n                // in cascading diagnostics, but it's possible that the second diagnostic is an error\n                // while the first is merely a warning.\n                leastOverriddenSymbol.GetAttributes();\n            } 253253"];
18815 [label="param ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics) 253254"];
18816 [label="param ReportDiagnosticsIfObsoleteInternal(SyntaxNodeOrToken node) 253255"];
18817 [label="param ReportDiagnosticsIfObsoleteInternal(Symbol? containingMember) 253256"];
18818 [label="param ReportDiagnosticsIfObsoleteInternal(BinderFlags location) 253257"];
18819 [label="RoslynDebug.Assert(diagnostics != null); 253258"];
18820 [label="RoslynDebug.Assert(diagnostics != null); 253259"];
18821 [label="param GetObsoleteDiagnosticKind(Symbol containingMember) 253260"];
18822 [label="param GetObsoleteDiagnosticKind(bool forceComplete = false) 253261"];
18823 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 253262"];
18824 [label="Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified'); 253263"];
18825 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return null;\n                } 253264"];
18826 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 253265"];
18827 [label="s.Kind 253266"];
18828 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 253267"];
18829 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 253268"];
18830 [label="return uncommon.lazyObsoleteAttributeData; 253269"];
18831 [label="var data = this.ObsoleteAttributeData; 253270"];
18832 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 253271"];
18833 [label="return (data == null) ? ObsoleteAttributeKind.None : data.Kind; 253272"];
18834 [label="(data == null) 253273"];
18835 [label="switch (symbol.ObsoleteKind)\n            {\n                case ObsoleteAttributeKind.None:\n                    return ObsoleteDiagnosticKind.NotObsolete;\n                case ObsoleteAttributeKind.Experimental:\n                    return ObsoleteDiagnosticKind.Diagnostic;\n                case ObsoleteAttributeKind.Uninitialized:\n                    // If we haven't cracked attributes on the symbol at all or we haven't\n                    // cracked attribute arguments enough to be able to report diagnostics for\n                    // ObsoleteAttribute, store the symbol so that we can report diagnostics at a \n                    // later stage.\n                    return ObsoleteDiagnosticKind.Lazy;\n            } 253274"];
18836 [label="return ObsoleteDiagnosticKind.NotObsolete; 253275"];
18837 [label="DiagnosticInfo? info = null; 253276"];
18838 [label="switch (kind)\n            {\n                case ObsoleteDiagnosticKind.Diagnostic:\n                    info = ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(symbol, location);\n                    break;\n                case ObsoleteDiagnosticKind.Lazy:\n                case ObsoleteDiagnosticKind.LazyPotentiallySuppressed:\n                    info = new LazyObsoleteDiagnosticInfo(symbol, containingMember, location);\n                    break;\n            } 253277"];
18839 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 253278"];
18840 [label="if (info != null)\n            {\n                diagnostics.Add(info, node.GetLocation());\n            } 253279"];
18841 [label="return kind; 253280"];
18842 [label="switch (diagnosticKind)\n            {\n                case ObsoleteDiagnosticKind.NotObsolete:\n                case ObsoleteDiagnosticKind.Lazy:\n                    if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    }\n                    break;\n            } 253281"];
18843 [label="if (checkOverridingSymbol)\n                    {\n                        RoslynDebug.Assert(diagnosticKind != ObsoleteDiagnosticKind.Lazy, 'We forced attribute binding above.');\n                        ReportDiagnosticsIfObsoleteInternal(diagnostics, symbol, node, containingMember, location);\n                    } 253282"];
18844 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253283"];
18845 [label="param UnwrapAlias(DiagnosticBag diagnostics) 253284"];
18846 [label="param UnwrapAlias(SyntaxNode syntax) 253285"];
18847 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 253286"];
18848 [label="param UnwrapAlias(this) 253287"];
18849 [label="symbol.IsAlias 253288"];
18850 [label="=> _symbol?.Kind == SymbolKind.Alias 253289"];
18851 [label="_symbol 253290"];
18852 [label="_symbol?.Kind == SymbolKind.Alias 253291"];
18853 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 253292"];
18854 [label="type.IsStatic 253293"];
18855 [label="=>\n            _extensions.IsStatic(DefaultType) 253294"];
18856 [label="DefaultType 253295"];
18857 [label="_extensions.IsStatic(DefaultType) 253296"];
18858 [label="param IsStatic(TypeSymbol typeSymbol) 253297"];
18859 [label="=> typeSymbol.IsStatic 253298"];
18860 [label="typeSymbol.IsStatic 253299"];
18861 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0;\n            } 253300"];
18862 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 253301"];
18863 [label="return\n                    (_flags & TypeAttributes.Sealed) != 0 &&\n                    (_flags & TypeAttributes.Abstract) != 0; 253302"];
18864 [label="if (type.IsStatic)\n            {\n                // CS0719: '{0}': array elements cannot be of static type\n                Error(diagnostics, ErrorCode.ERR_ArrayOfStaticClass, node.ElementType, type.Type);\n            } 253303"];
18865 [label="if (!permitDimensions && dimension.Count != 0 && dimension[0].Kind() != SyntaxKind.OmittedArraySizeExpression)\n                {\n                    // https://github.com/dotnet/roslyn/issues/32464\n                    // Should capture invalid dimensions for use in `SemanticModel` and `IOperation`.\n                    Error(diagnostics, ErrorCode.ERR_ArraySizeInDeclaration, rankSpecifier);\n                } 253304"];
18866 [label="GetBoundReferenceManager(); 253305"];
18867 [label="return CreateMDArray(declaringAssembly, elementTypeWithAnnotations, rank, default(ImmutableArray<int>), default(ImmutableArray<int>)); 253306"];
18868 [label="CreateMDArray(declaringAssembly, elementTypeWithAnnotations, rank, default(ImmutableArray<int>), default(ImmutableArray<int>)) 253307"];
18869 [label="param CreateMDArray(AssemblySymbol declaringAssembly) 253308"];
18870 [label="param CreateMDArray(TypeWithAnnotations elementType) 253309"];
18871 [label="param CreateMDArray(int rank) 253310"];
18872 [label="param CreateMDArray(ImmutableArray<int> sizes) 253311"];
18873 [label="param CreateMDArray(ImmutableArray<int> lowerBounds) 253312"];
18874 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 253313"];
18875 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 253314"];
18876 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 253315"];
18877 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 253316"];
18878 [label="return CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)); 253317"];
18879 [label="declaringAssembly.GetSpecialType(SpecialType.System_Array) 253318"];
18880 [label="param GetSpecialType(SpecialType type) 253319"];
18881 [label="param GetSpecialType(this) 253320"];
18882 [label="this.Modules 253321"];
18883 [label="get\n            {\n                return _modules;\n            } 253322"];
18884 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 253323"];
18885 [label="module.GetReferencedAssemblies() 253324"];
18886 [label="param GetReferencedAssemblies(this) 253325"];
18887 [label="AssertReferencesInitialized() 253326"];
18888 [label="param AssertReferencesInitialized(this) 253327"];
18889 [label="Debug.Assert(_moduleReferences != null); 253328"];
18890 [label="Debug.Assert(_moduleReferences != null); 253329"];
18891 [label="AssertReferencesInitialized(); 253330"];
18892 [label="return _moduleReferences.Identities; 253331"];
18893 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 253332"];
18894 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 253333"];
18895 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 253334"];
18896 [label="return _lazySpecialTypes[(int)type]; 253335"];
18897 [label="CreateMDArray(elementType, rank, sizes, lowerBounds, declaringAssembly.GetSpecialType(SpecialType.System_Array)) 253336"];
18898 [label="param CreateMDArray(TypeWithAnnotations elementTypeWithAnnotations) 253337"];
18899 [label="param CreateMDArray(int rank) 253338"];
18900 [label="param CreateMDArray(ImmutableArray<int> sizes) 253339"];
18901 [label="param CreateMDArray(ImmutableArray<int> lowerBounds) 253340"];
18902 [label="param CreateMDArray(NamedTypeSymbol array) 253341"];
18903 [label="if (sizes.IsDefaultOrEmpty && lowerBounds.IsDefault)\n            {\n                return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array);\n            } 253342"];
18904 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 253343"];
18905 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 253344"];
18906 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 253345"];
18907 [label="return new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array); 253346"];
18908 [label="new MDArrayNoSizesOrBounds(elementTypeWithAnnotations, rank, array) 253347"];
18909 [label="param MDArrayNoSizesOrBounds(TypeWithAnnotations elementTypeWithAnnotations) 253348"];
18910 [label="param MDArrayNoSizesOrBounds(int rank) 253349"];
18911 [label="param MDArrayNoSizesOrBounds(NamedTypeSymbol array) 253350"];
18912 [label="param MDArrayNoSizesOrBounds(this) 253351"];
18913 [label="elementTypeWithAnnotations 253352"];
18914 [label="rank 253353"];
18915 [label="array 253354"];
18916 [label="param MDArrayNoSizesOrBounds(this) 253355"];
18917 [label="param MDArray(TypeWithAnnotations elementTypeWithAnnotations) 253356"];
18918 [label="param MDArray(int rank) 253357"];
18919 [label="param MDArray(NamedTypeSymbol array) 253358"];
18920 [label="param MDArray(this) 253359"];
18921 [label="elementTypeWithAnnotations 253360"];
18922 [label="array 253361"];
18923 [label="param MDArray(this) 253362"];
18924 [label="param ArrayTypeSymbol(TypeWithAnnotations elementTypeWithAnnotations) 253363"];
18925 [label="param ArrayTypeSymbol(NamedTypeSymbol array) 253364"];
18926 [label="_baseType 253365"];
18927 [label="elementTypeWithAnnotations.HasType 253366"];
18928 [label="=> !(DefaultType is null) 253367"];
18929 [label="Debug.Assert(elementTypeWithAnnotations.HasType); 253368"];
18930 [label="RoslynDebug.Assert((object)array != null); 253369"];
18931 [label="RoslynDebug.Assert((object)array != null); 253370"];
18932 [label="_rank 253371"];
18933 [label="Debug.Assert(rank >= 1); 253372"];
18934 [label="Debug.Assert(rank >= 1); 253373"];
18935 [label="_rank 253374"];
18936 [label="if (typeSymbol is null)\n            {\n                return default;\n            } 253375"];
18937 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 253376"];
18938 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 253377"];
18939 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 253378"];
18940 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 253379"];
18941 [label="typeSymbol.IsNullableType() 253380"];
18942 [label="param IsNullableType(this TypeSymbol type) 253381"];
18943 [label="get\n            {\n                return this;\n            } 253382"];
18944 [label="return this; 253383"];
18945 [label="get\n            {\n                return SpecialType.None;\n            } 253384"];
18946 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 253385"];
18947 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 253386"];
18948 [label="var a1 = defaultType is null; 253387"];
18949 [label="!a1 253388"];
18950 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 253389"];
18951 [label="defaultType.IsNullableType() 253390"];
18952 [label="param IsNullableType(this TypeSymbol type) 253391"];
18953 [label="get\n            {\n                return this;\n            } 253392"];
18954 [label="return this; 253393"];
18955 [label="get\n            {\n                return SpecialType.None;\n            } 253394"];
18956 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 253395"];
18957 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 253396"];
18958 [label="Debug.Assert(a1 || a2 != true || a3); 253397"];
18959 [label="Debug.Assert(a1 || a2 != true || a3); 253398"];
18960 [label="Debug.Assert(extensions != null); 253399"];
18961 [label="typeWithAnnotations.HasType 253400"];
18962 [label="=> !(DefaultType is null) 253401"];
18963 [label="DefaultType is null 253402"];
18964 [label="Debug.Assert(typeWithAnnotations.HasType); 253403"];
18965 [label="_symbol = null; 253404"];
18966 [label="_symbol 253405"];
18967 [label="_isNullableEnabled = false; 253406"];
18968 [label="_isNullableEnabled 253407"];
18969 [label="param ReportDiagnosticsIfObsolete(Binder binder) 253408"];
18970 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 253409"];
18971 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253410"];
18972 [label="binder 253411"];
18973 [label="syntax 253412"];
18974 [label="diagnostics 253413"];
18975 [label="param ReportDiagnosticsIfObsolete(Binder binder) 253414"];
18976 [label="param ReportDiagnosticsIfObsolete(SyntaxNode syntax) 253415"];
18977 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253416"];
18978 [label="param ReportDiagnosticsIfObsolete(this) 253417"];
18979 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253418"];
18980 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253419"];
18981 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253420"];
18982 [label="param ReportDiagnosticsIfObsoleteCore(Binder binder) 253421"];
18983 [label="param ReportDiagnosticsIfObsoleteCore(SyntaxNode syntax) 253422"];
18984 [label="param ReportDiagnosticsIfObsoleteCore(DiagnosticBag diagnostics) 253423"];
18985 [label="=> defaultType 253424"];
18986 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253425"];
18987 [label="param ReportDiagnosticsIfObsolete(SyntaxNode node) 253426"];
18988 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 253427"];
18989 [label="param ReportDiagnosticsIfObsolete(this) 253428"];
18990 [label="param ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics) 253429"];
18991 [label="param ReportDiagnosticsIfObsolete(SyntaxNodeOrToken node) 253430"];
18992 [label="param ReportDiagnosticsIfObsolete(bool hasBaseReceiver) 253431"];
18993 [label="param ReportDiagnosticsIfObsolete(this) 253432"];
18994 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 253433"];
18995 [label="type.ReportDiagnosticsIfObsoleteCore(binder, syntax, diagnostics); 253434"];
18996 [label="param UnwrapAlias(ConsList<TypeSymbol> basesBeingResolved = null) 253435"];
18997 [label="=> _symbol?.Kind == SymbolKind.Alias 253436"];
18998 [label="_symbol 253437"];
18999 [label="_symbol?.Kind == SymbolKind.Alias 253438"];
19000 [label="if (symbol.IsAlias)\n            {\n                AliasSymbol discarded;\n                return NamespaceOrTypeOrAliasSymbolWithAnnotations.CreateUnannotated(symbol.IsNullableEnabled, (NamespaceOrTypeSymbol)UnwrapAlias(symbol.Symbol, out discarded, diagnostics, syntax, basesBeingResolved));\n            } 253439"];
19001 [label="IsFixedSizeBuffer 253440"];
19002 [label="=> (Modifiers & DeclarationModifiers.Fixed) != 0 253441"];
19003 [label="Modifiers 253442"];
19004 [label="get\n            {\n                return _modifiers;\n            } 253443"];
19005 [label="return _modifiers; 253444"];
19006 [label="Modifiers & DeclarationModifiers.Fixed 253445"];
19007 [label="0 253446"];
19008 [label="(Modifiers & DeclarationModifiers.Fixed) != 0 253447"];
19009 [label="if (IsFixedSizeBuffer)\n                {\n                    type = TypeWithAnnotations.Create(new PointerTypeSymbol(type));\n\n                    if (ContainingType.TypeKind != TypeKind.Struct)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_FixedNotInStruct, ErrorLocation);\n                    }\n\n                    var elementType = ((PointerTypeSymbol)type.Type).PointedAtType;\n                    int elementSize = elementType.FixedBufferElementSizeInBytes();\n                    if (elementSize == 0)\n                    {\n                        var loc = typeSyntax.Location;\n                        diagnostics.Add(ErrorCode.ERR_IllegalFixedType, loc);\n                    }\n\n                    if (!binder.InUnsafeRegion)\n                    {\n                        diagnosticsForFirstDeclarator.Add(ErrorCode.ERR_UnsafeNeeded, declarator.Location);\n                    }\n                } 253448"];
19010 [label="this.RequiredCustomModifiers 253449"];
19011 [label="IsVolatile 253450"];
19012 [label="Modifiers 253451"];
19013 [label="0 253452"];
19014 [label="type.WithModifiers(this.RequiredCustomModifiers) 253453"];
19015 [label="_extensions.WithModifiers(this, customModifiers) 253454"];
19016 [label="param WithModifiers(this) 253455"];
19017 [label="CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers) 253456"];
19018 [label="Extensions.Create(customModifiers) 253457"];
19019 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 253458"];
19020 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 253459"];
19021 [label="param TypeWithAnnotations(this) 253460"];
19022 [label="var a1 = defaultType is null; 253461"];
19023 [label="!a1 253462"];
19024 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 253463"];
19025 [label="defaultType.IsNullableType() 253464"];
19026 [label="param IsNullableType(this TypeSymbol type) 253465"];
19027 [label="get\n            {\n                return this;\n            } 253466"];
19028 [label="return this; 253467"];
19029 [label="get\n            {\n                return SpecialType.None;\n            } 253468"];
19030 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 253469"];
19031 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 253470"];
19032 [label="Debug.Assert(a1 || a2 != true || a3); 253471"];
19033 [label="Debug.Assert(a1 || a2 != true || a3); 253472"];
19034 [label="Debug.Assert(extensions != null); 253473"];
19035 [label="Debug.Assert(extensions != null); 253474"];
19036 [label="return CreateNonLazyType(type.DefaultType, type.NullableAnnotation, customModifiers); 253475"];
19037 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 253476"];
19038 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 253477"];
19039 [label="new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)) 253478"];
19040 [label="param Boxed(TypeWithAnnotations value) 253479"];
19041 [label="param Boxed(this) 253480"];
19042 [label="Value 253481"];
19043 [label="if (Interlocked.CompareExchange(ref _lazyType, new TypeWithAnnotations.Boxed(type.WithModifiers(this.RequiredCustomModifiers)), null) == null)\n            {\n                TypeChecks(type.Type, diagnostics);\n\n                // CONSIDER: SourceEventFieldSymbol would like to suppress these diagnostics.\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n\n                bool isFirstDeclarator = fieldSyntax.Declaration.Variables[0] == declarator;\n                if (isFirstDeclarator)\n                {\n                    compilation.DeclarationDiagnostics.AddRange(diagnosticsForFirstDeclarator);\n                }\n\n                state.NotePartComplete(CompletionPart.Type);\n            } 253482"];
19044 [label="=> defaultType 253483"];
19045 [label="type.IsStatic 253484"];
19046 [label="get\n            {\n                return false;\n            } 253485"];
19047 [label="return false; 253486"];
19048 [label="if (type.IsStatic)\n            {\n                // Cannot declare a variable of static type '{0}'\n                diagnostics.Add(ErrorCode.ERR_VarDeclIsStaticClass, this.ErrorLocation, type);\n            }\n            else if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253487"];
19049 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253488"];
19050 [label="type.IsVoidType() 253489"];
19051 [label="param IsVoidType(this TypeSymbol type) 253490"];
19052 [label="type.SpecialType 253491"];
19053 [label="get\n            {\n                return SpecialType.None;\n            } 253492"];
19054 [label="return type.SpecialType == SpecialType.System_Void; 253493"];
19055 [label="if (type.IsVoidType())\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantHaveVoidType, TypeSyntax?.Location ?? this.Locations[0]);\n            }\n            else if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253494"];
19056 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253495"];
19057 [label="if (type.IsRestrictedType(ignoreSpanLikeTypes: true))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldCantBeRefAny, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253496"];
19058 [label="type.IsRestrictedType(ignoreSpanLikeTypes: true) 253497"];
19059 [label="param IsRestrictedType(this TypeSymbol type) 253498"];
19060 [label="param IsRestrictedType(bool ignoreSpanLikeTypes = false) 253499"];
19061 [label="RoslynDebug.Assert((object)type != null); 253500"];
19062 [label="RoslynDebug.Assert((object)type != null); 253501"];
19063 [label="type.SpecialType 253502"];
19064 [label="get\n            {\n                return SpecialType.None;\n            } 253503"];
19065 [label="switch (type.SpecialType)\n            {\n                case SpecialType.System_TypedReference:\n                case SpecialType.System_ArgIterator:\n                case SpecialType.System_RuntimeArgumentHandle:\n                    return true;\n            } 253504"];
19066 [label="ignoreSpanLikeTypes 253505"];
19067 [label="return ignoreSpanLikeTypes ?\n                        false :\n                        type.IsRefLikeType; 253506"];
19068 [label="type.IsRefLikeType 253507"];
19069 [label="get\n            {\n                return false;\n            } 253508"];
19070 [label="return false; 253509"];
19071 [label="if (type.IsRefLikeType && (this.IsStatic || !containingType.IsRefLikeType))\n            {\n                diagnostics.Add(ErrorCode.ERR_FieldAutoPropCantBeByRefLike, TypeSyntax?.Location ?? this.Locations[0], type);\n            }\n            else if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253510"];
19072 [label="IsConst 253511"];
19073 [label="=> (Modifiers & DeclarationModifiers.Const) != 0 253512"];
19074 [label="Modifiers 253513"];
19075 [label="get\n            {\n                return _modifiers;\n            } 253514"];
19076 [label="Modifiers & DeclarationModifiers.Const 253515"];
19077 [label="0 253516"];
19078 [label="(Modifiers & DeclarationModifiers.Const) != 0 253517"];
19079 [label="if (IsConst && !type.CanBeConst())\n            {\n                SyntaxToken constToken = default(SyntaxToken);\n                foreach (var modifier in ModifiersTokenList)\n                {\n                    if (modifier.Kind() == SyntaxKind.ConstKeyword)\n                    {\n                        constToken = modifier;\n                        break;\n                    }\n                }\n                Debug.Assert(constToken.Kind() == SyntaxKind.ConstKeyword);\n\n                diagnostics.Add(ErrorCode.ERR_BadConstType, constToken.GetLocation(), type);\n            }\n            else if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253518"];
19080 [label="IsVolatile 253519"];
19081 [label="if (IsVolatile && !type.IsValidVolatileFieldType())\n            {\n                // '{0}': a volatile field cannot be of the type '{1}'\n                diagnostics.Add(ErrorCode.ERR_VolatileStruct, this.ErrorLocation, this, type);\n            } 253520"];
19082 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 253521"];
19083 [label="param VisitType(bool useDefaultType = false) 253522"];
19084 [label="typeWithAnnotationsOpt.HasType 253523"];
19085 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 253524"];
19086 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 253525"];
19087 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 253526"];
19088 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 253527"];
19089 [label="current.TypeKind 253528"];
19090 [label="get\n            {\n                return TypeKind.Array;\n            } 253529"];
19091 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 253530"];
19092 [label="param IsTypeLessVisibleThan(Symbol sym) 253531"];
19093 [label="get\n            {\n                return TypeKind.Array;\n            } 253532"];
19094 [label="TypeWithAnnotations next; 253533"];
19095 [label="next 253534"];
19096 [label="get\n            {\n                return TypeKind.Array;\n            } 253535"];
19097 [label="=> typeSymbol.StrippedType() 253536"];
19098 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 253537"];
19099 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 253538"];
19100 [label="current.ContainingType 253539"];
19101 [label="var containingType = current.ContainingType; 253540"];
19102 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 253541"];
19103 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 253542"];
19104 [label="param IsAsRestrictive(Symbol sym2) 253543"];
19105 [label="Accessibility access = Accessibility.Private; 253544"];
19106 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 253545"];
19107 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 253546"];
19108 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 253547"];
19109 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 253548"];
19110 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 253549"];
19111 [label="return null; 253550"];
19112 [label="return result is null; 253551"];
19113 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 253552"];
19114 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 253553"];
19115 [label="TypeWithAnnotations.Type 253554"];
19116 [label=".GetResolvedType(DefaultType) 253555"];
19117 [label="=> defaultType 253556"];
19118 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym2.Kind); 253557"];
19119 [label="sym2.Kind 253558"];
19120 [label="get\n            {\n                return SymbolKind.ArrayType;\n            } 253559"];
19121 [label="return SymbolKind.ArrayType; 253560"];
19122 [label="CustomAssert.Equal(SymbolKind.ArrayType, sym2.Kind); 253561"];
19123 [label="CustomAssert.Equal(0, sym2.Interfaces().Length); 253562"];
19124 [label="CustomAssert.Equal(0, sym2.Interfaces().Length); 253563"];
19125 [label="sym2.Interfaces() 253564"];
19126 [label="param Interfaces(this TypeSymbol symbol) 253565"];
19127 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 253566"];
19128 [label="symbol.InterfacesNoUseSiteDiagnostics() 253567"];
19129 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol>? basesBeingResolved = null) 253568"];
19130 [label="param InterfacesNoUseSiteDiagnostics(this) 253569"];
19131 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 253570"];
19132 [label="return symbol.InterfacesNoUseSiteDiagnostics(); 253571"];
19133 [label="CustomAssert.Equal(0, sym2.Interfaces().Length); 253572"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
195 -> 2;
195 -> 194;
196 -> 1;
197 -> 1;
198 -> 197;
198 -> 1;
199 -> 1;
200 -> 0;
200 -> 199;
200 -> 1;
201 -> 1;
202 -> 199;
202 -> 201;
203 -> 202;
203 -> 201;
204 -> 201;
205 -> 203;
205 -> 204;
206 -> 204;
207 -> 205;
207 -> 206;
207 -> 204;
208 -> 204;
208 -> 1;
209 -> 1;
210 -> 198;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 199;
212 -> 209;
213 -> 199;
213 -> 209;
214 -> 199;
214 -> 209;
215 -> 199;
215 -> 209;
216 -> 199;
216 -> 209;
217 -> 210;
217 -> 209;
218 -> 211;
218 -> 209;
219 -> 212;
219 -> 209;
220 -> 213;
220 -> 209;
221 -> 214;
221 -> 209;
222 -> 215;
222 -> 209;
223 -> 216;
223 -> 209;
224 -> 209;
225 -> 224;
225 -> 209;
226 -> 209;
227 -> 217;
227 -> 226;
228 -> 218;
228 -> 226;
229 -> 219;
229 -> 226;
230 -> 220;
230 -> 226;
231 -> 221;
231 -> 226;
232 -> 222;
232 -> 226;
233 -> 223;
233 -> 226;
234 -> 225;
234 -> 226;
235 -> 230;
235 -> 226;
236 -> 232;
236 -> 226;
237 -> 226;
238 -> 235;
238 -> 237;
239 -> 236;
239 -> 237;
240 -> 227;
240 -> 237;
241 -> 240;
241 -> 198;
241 -> 237;
242 -> 241;
243 -> 239;
243 -> 241;
244 -> 238;
244 -> 241;
245 -> 241;
246 -> 242;
246 -> 245;
247 -> 243;
247 -> 245;
248 -> 244;
248 -> 245;
249 -> 242;
249 -> 245;
250 -> 245;
251 -> 248;
251 -> 250;
251 -> 245;
252 -> 0;
253 -> 0;
255 -> 252;
255 -> 253;
255 -> 254;
256 -> 255;
257 -> 0;
258 -> 256;
258 -> 255;
258 -> 257;
259 -> 258;
260 -> 0;
261 -> 256;
261 -> 255;
261 -> 260;
262 -> 261;
263 -> 0;
264 -> 256;
264 -> 255;
264 -> 263;
265 -> 264;
266 -> 0;
267 -> 256;
267 -> 255;
267 -> 266;
268 -> 267;
269 -> 0;
270 -> 256;
270 -> 255;
270 -> 269;
271 -> 270;
272 -> 0;
273 -> 256;
273 -> 255;
273 -> 272;
274 -> 273;
275 -> 0;
276 -> 256;
276 -> 255;
276 -> 275;
277 -> 276;
278 -> 0;
279 -> 256;
279 -> 255;
279 -> 278;
280 -> 279;
281 -> 0;
282 -> 256;
282 -> 255;
282 -> 281;
283 -> 282;
284 -> 0;
285 -> 256;
285 -> 255;
285 -> 284;
286 -> 285;
287 -> 0;
288 -> 256;
288 -> 255;
288 -> 287;
289 -> 288;
290 -> 256;
293 -> 290;
293 -> 292;
294 -> 291;
294 -> 292;
295 -> 292;
296 -> 293;
296 -> 255;
296 -> 292;
297 -> 292;
298 -> 294;
298 -> 292;
299 -> 295;
299 -> 292;
300 -> 298;
300 -> 299;
300 -> 292;
301 -> 300;
301 -> 297;
301 -> 292;
302 -> 296;
302 -> 297;
302 -> 255;
302 -> 301;
302 -> 300;
302 -> 292;
303 -> 302;
304 -> 0;
305 -> 304;
307 -> 305;
307 -> 306;
308 -> 256;
308 -> 255;
308 -> 307;
309 -> 308;
310 -> 0;
311 -> 310;
312 -> 256;
312 -> 255;
312 -> 311;
313 -> 312;
314 -> 0;
315 -> 256;
315 -> 255;
315 -> 314;
316 -> 315;
317 -> 280;
319 -> 318;
320 -> 0;
321 -> 0;
322 -> 0;
324 -> 320;
324 -> 321;
324 -> 322;
324 -> 323;
325 -> 319;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 326;
331 -> 328;
331 -> 329;
331 -> 330;
332 -> 262;
332 -> 255;
332 -> 261;
332 -> 328;
332 -> 331;
333 -> 332;
334 -> 274;
335 -> 283;
336 -> 283;
337 -> 280;
338 -> 0;
339 -> 0;
341 -> 338;
341 -> 340;
342 -> 339;
342 -> 340;
343 -> 340;
344 -> 341;
344 -> 340;
345 -> 342;
345 -> 340;
346 -> 0;
346 -> 340;
347 -> 343;
347 -> 340;
348 -> 340;
349 -> 344;
349 -> 345;
349 -> 346;
349 -> 347;
349 -> 348;
349 -> 340;
350 -> 349;
351 -> 0;
352 -> 0;
354 -> 351;
354 -> 353;
355 -> 352;
355 -> 353;
356 -> 353;
357 -> 354;
357 -> 353;
358 -> 355;
358 -> 353;
359 -> 0;
359 -> 353;
360 -> 356;
360 -> 353;
361 -> 353;
362 -> 357;
362 -> 358;
362 -> 359;
362 -> 360;
362 -> 361;
362 -> 353;
363 -> 362;
365 -> 350;
365 -> 349;
365 -> 364;
366 -> 365;
368 -> 363;
368 -> 362;
368 -> 367;
369 -> 368;
370 -> 0;
371 -> 0;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 372;
376 -> 373;
376 -> 372;
377 -> 374;
377 -> 372;
378 -> 0;
378 -> 372;
379 -> 375;
379 -> 372;
380 -> 372;
381 -> 376;
381 -> 377;
381 -> 378;
381 -> 379;
381 -> 380;
381 -> 372;
382 -> 381;
383 -> 0;
384 -> 0;
386 -> 383;
386 -> 385;
387 -> 384;
387 -> 385;
388 -> 385;
389 -> 386;
389 -> 385;
390 -> 387;
390 -> 385;
391 -> 0;
391 -> 385;
392 -> 388;
392 -> 385;
393 -> 385;
394 -> 389;
394 -> 390;
394 -> 391;
394 -> 392;
394 -> 393;
394 -> 385;
395 -> 394;
396 -> 0;
397 -> 0;
399 -> 396;
399 -> 398;
400 -> 397;
400 -> 398;
401 -> 398;
402 -> 399;
402 -> 398;
403 -> 400;
403 -> 398;
404 -> 0;
404 -> 398;
405 -> 401;
405 -> 398;
406 -> 398;
407 -> 402;
407 -> 403;
407 -> 404;
407 -> 405;
407 -> 406;
407 -> 398;
408 -> 407;
409 -> 0;
410 -> 0;
412 -> 409;
412 -> 411;
413 -> 410;
413 -> 411;
414 -> 411;
415 -> 412;
415 -> 411;
416 -> 413;
416 -> 411;
417 -> 0;
417 -> 411;
418 -> 414;
418 -> 411;
419 -> 411;
420 -> 415;
420 -> 416;
420 -> 417;
420 -> 418;
420 -> 419;
420 -> 411;
421 -> 420;
422 -> 0;
423 -> 0;
425 -> 422;
425 -> 424;
426 -> 423;
426 -> 424;
427 -> 424;
428 -> 425;
428 -> 424;
429 -> 426;
429 -> 424;
430 -> 0;
430 -> 424;
431 -> 427;
431 -> 424;
432 -> 424;
433 -> 428;
433 -> 429;
433 -> 430;
433 -> 431;
433 -> 432;
433 -> 424;
434 -> 433;
435 -> 0;
436 -> 0;
438 -> 435;
438 -> 437;
439 -> 436;
439 -> 437;
440 -> 437;
441 -> 438;
441 -> 437;
442 -> 439;
442 -> 437;
443 -> 0;
443 -> 437;
444 -> 440;
444 -> 437;
445 -> 437;
446 -> 441;
446 -> 442;
446 -> 443;
446 -> 444;
446 -> 445;
446 -> 437;
447 -> 446;
449 -> 350;
449 -> 349;
449 -> 448;
450 -> 449;
452 -> 363;
452 -> 362;
452 -> 451;
453 -> 452;
455 -> 382;
455 -> 381;
455 -> 454;
456 -> 455;
458 -> 395;
458 -> 394;
458 -> 457;
459 -> 458;
460 -> 0;
461 -> 350;
461 -> 349;
461 -> 460;
461 -> 0;
462 -> 461;
463 -> 0;
464 -> 363;
464 -> 362;
464 -> 463;
464 -> 0;
465 -> 464;
466 -> 0;
467 -> 434;
467 -> 433;
467 -> 466;
467 -> 0;
468 -> 467;
469 -> 0;
470 -> 382;
470 -> 381;
470 -> 469;
470 -> 0;
471 -> 470;
472 -> 0;
473 -> 0;
473 -> 472;
474 -> 473;
475 -> 256;
475 -> 251;
476 -> 246;
476 -> 245;
477 -> 0;
477 -> 245;
478 -> 477;
478 -> 249;
478 -> 245;
479 -> 245;
480 -> 476;
480 -> 478;
480 -> 479;
480 -> 0;
480 -> 245;
481 -> 480;
481 -> 245;
482 -> 475;
482 -> 245;
483 -> 247;
483 -> 245;
484 -> 245;
485 -> 481;
485 -> 482;
485 -> 483;
485 -> 484;
485 -> 480;
485 -> 255;
485 -> 245;
486 -> 245;
487 -> 485;
487 -> 486;
488 -> 486;
489 -> 486;
490 -> 487;
490 -> 485;
490 -> 489;
490 -> 486;
491 -> 488;
491 -> 486;
492 -> 486;
493 -> 490;
493 -> 485;
493 -> 489;
493 -> 491;
493 -> 492;
493 -> 488;
493 -> 486;
494 -> 486;
495 -> 494;
495 -> 488;
495 -> 486;
496 -> 488;
496 -> 486;
497 -> 486;
498 -> 496;
498 -> 497;
498 -> 488;
498 -> 495;
498 -> 486;
499 -> 487;
499 -> 486;
500 -> 499;
500 -> 242;
500 -> 241;
501 -> 242;
501 -> 226;
502 -> 226;
503 -> 229;
503 -> 502;
503 -> 226;
504 -> 501;
504 -> 503;
505 -> 503;
506 -> 504;
506 -> 505;
506 -> 242;
506 -> 500;
506 -> 485;
506 -> 503;
507 -> 506;
507 -> 503;
508 -> 350;
508 -> 507;
509 -> 0;
509 -> 226;
510 -> 234;
510 -> 226;
511 -> 231;
511 -> 501;
511 -> 228;
511 -> 508;
511 -> 226;
512 -> 511;
512 -> 226;
513 -> 226;
514 -> 512;
514 -> 513;
515 -> 0;
515 -> 513;
516 -> 515;
517 -> 226;
518 -> 511;
518 -> 242;
518 -> 500;
518 -> 485;
518 -> 207;
518 -> 349;
518 -> 226;
519 -> 226;
520 -> 519;
521 -> 518;
521 -> 520;
521 -> 226;
522 -> 0;
524 -> 522;
524 -> 523;
525 -> 524;
526 -> 0;
528 -> 526;
528 -> 527;
530 -> 528;
530 -> 529;
531 -> 530;
532 -> 518;
532 -> 519;
533 -> 518;
533 -> 519;
534 -> 518;
534 -> 519;
535 -> 518;
535 -> 519;
536 -> 532;
536 -> 519;
537 -> 535;
537 -> 519;
538 -> 533;
538 -> 519;
539 -> 534;
539 -> 519;
540 -> 519;
541 -> 519;
542 -> 536;
542 -> 541;
543 -> 537;
543 -> 541;
544 -> 538;
544 -> 541;
545 -> 539;
545 -> 541;
546 -> 540;
546 -> 541;
547 -> 540;
547 -> 541;
548 -> 540;
548 -> 541;
549 -> 540;
549 -> 541;
550 -> 541;
551 -> 543;
551 -> 550;
551 -> 541;
552 -> 549;
552 -> 541;
553 -> 545;
553 -> 541;
554 -> 553;
554 -> 521;
554 -> 541;
555 -> 542;
555 -> 541;
556 -> 543;
556 -> 541;
557 -> 554;
557 -> 541;
558 -> 546;
558 -> 541;
559 -> 547;
559 -> 541;
560 -> 548;
560 -> 541;
561 -> 549;
561 -> 541;
562 -> 541;
563 -> 0;
563 -> 541;
564 -> 543;
564 -> 554;
564 -> 541;
565 -> 563;
565 -> 564;
565 -> 561;
565 -> 562;
565 -> 0;
565 -> 554;
565 -> 541;
566 -> 541;
567 -> 555;
567 -> 566;
568 -> 556;
568 -> 566;
569 -> 557;
569 -> 566;
570 -> 558;
570 -> 566;
571 -> 559;
571 -> 566;
572 -> 560;
572 -> 566;
573 -> 561;
573 -> 566;
574 -> 562;
574 -> 566;
575 -> 562;
575 -> 566;
576 -> 565;
576 -> 566;
577 -> 562;
577 -> 566;
578 -> 562;
578 -> 566;
579 -> 562;
579 -> 566;
580 -> 567;
580 -> 566;
581 -> 568;
581 -> 566;
582 -> 569;
582 -> 566;
583 -> 570;
583 -> 566;
584 -> 571;
584 -> 566;
585 -> 572;
585 -> 566;
586 -> 573;
586 -> 566;
587 -> 574;
587 -> 566;
588 -> 575;
588 -> 566;
589 -> 576;
589 -> 566;
590 -> 576;
590 -> 565;
590 -> 566;
591 -> 590;
591 -> 565;
591 -> 566;
592 -> 577;
592 -> 566;
593 -> 578;
593 -> 566;
594 -> 566;
595 -> 580;
595 -> 594;
596 -> 581;
596 -> 594;
597 -> 582;
597 -> 594;
598 -> 583;
598 -> 594;
599 -> 584;
599 -> 594;
600 -> 585;
600 -> 594;
601 -> 586;
601 -> 594;
602 -> 587;
602 -> 594;
603 -> 588;
603 -> 594;
604 -> 589;
604 -> 594;
605 -> 591;
605 -> 594;
606 -> 592;
606 -> 594;
607 -> 593;
607 -> 594;
608 -> 579;
608 -> 594;
609 -> 595;
609 -> 594;
610 -> 597;
610 -> 594;
611 -> 605;
611 -> 594;
612 -> 601;
612 -> 594;
613 -> 606;
613 -> 594;
614 -> 607;
614 -> 594;
615 -> 594;
616 -> 615;
616 -> 609;
616 -> 610;
616 -> 611;
616 -> 612;
616 -> 613;
616 -> 614;
616 -> 554;
616 -> 591;
616 -> 594;
617 -> 615;
617 -> 594;
618 -> 615;
618 -> 594;
619 -> 615;
619 -> 594;
620 -> 615;
620 -> 594;
621 -> 615;
621 -> 594;
622 -> 615;
622 -> 594;
623 -> 615;
623 -> 594;
624 -> 615;
624 -> 594;
625 -> 615;
625 -> 594;
626 -> 615;
626 -> 594;
627 -> 615;
627 -> 594;
628 -> 615;
628 -> 594;
629 -> 615;
629 -> 594;
630 -> 615;
630 -> 594;
631 -> 615;
631 -> 594;
632 -> 615;
632 -> 594;
633 -> 615;
633 -> 594;
634 -> 615;
634 -> 594;
635 -> 615;
635 -> 594;
636 -> 615;
636 -> 594;
637 -> 615;
637 -> 594;
638 -> 615;
638 -> 594;
639 -> 615;
639 -> 594;
640 -> 615;
640 -> 594;
641 -> 615;
641 -> 594;
642 -> 615;
642 -> 594;
643 -> 594;
644 -> 643;
644 -> 615;
644 -> 594;
645 -> 615;
645 -> 594;
646 -> 615;
646 -> 594;
647 -> 615;
647 -> 594;
648 -> 615;
648 -> 594;
649 -> 615;
649 -> 594;
650 -> 615;
650 -> 594;
651 -> 615;
651 -> 594;
652 -> 594;
653 -> 594;
654 -> 651;
654 -> 653;
655 -> 652;
655 -> 653;
657 -> 656;
658 -> 656;
659 -> 653;
660 -> 655;
660 -> 659;
661 -> 659;
662 -> 655;
662 -> 653;
663 -> 654;
663 -> 655;
663 -> 653;
664 -> 652;
664 -> 615;
664 -> 594;
665 -> 596;
665 -> 615;
665 -> 594;
666 -> 615;
666 -> 594;
667 -> 666;
667 -> 616;
667 -> 617;
667 -> 665;
667 -> 618;
667 -> 619;
667 -> 620;
667 -> 621;
667 -> 622;
667 -> 623;
667 -> 624;
667 -> 625;
667 -> 626;
667 -> 627;
667 -> 628;
667 -> 629;
667 -> 630;
667 -> 631;
667 -> 632;
667 -> 633;
667 -> 634;
667 -> 635;
667 -> 636;
667 -> 637;
667 -> 638;
667 -> 639;
667 -> 640;
667 -> 641;
667 -> 642;
667 -> 644;
667 -> 645;
667 -> 664;
667 -> 646;
667 -> 647;
667 -> 648;
667 -> 649;
667 -> 650;
667 -> 643;
667 -> 661;
667 -> 662;
667 -> 663;
667 -> 594;
668 -> 667;
668 -> 615;
668 -> 594;
669 -> 615;
669 -> 667;
669 -> 594;
670 -> 669;
670 -> 667;
670 -> 668;
670 -> 594;
671 -> 670;
671 -> 615;
671 -> 594;
672 -> 615;
672 -> 670;
672 -> 594;
673 -> 672;
673 -> 670;
673 -> 671;
673 -> 594;
674 -> 673;
674 -> 615;
674 -> 594;
675 -> 615;
675 -> 673;
675 -> 594;
676 -> 675;
676 -> 673;
676 -> 674;
676 -> 594;
677 -> 676;
677 -> 615;
677 -> 594;
678 -> 615;
678 -> 676;
678 -> 594;
679 -> 678;
679 -> 676;
679 -> 677;
679 -> 594;
680 -> 679;
680 -> 615;
680 -> 594;
681 -> 615;
681 -> 594;
682 -> 594;
683 -> 594;
684 -> 681;
684 -> 683;
685 -> 682;
685 -> 683;
686 -> 683;
687 -> 686;
687 -> 683;
688 -> 686;
688 -> 683;
689 -> 686;
689 -> 683;
690 -> 683;
691 -> 690;
691 -> 686;
691 -> 683;
692 -> 683;
693 -> 684;
693 -> 692;
693 -> 683;
694 -> 684;
694 -> 686;
694 -> 683;
695 -> 682;
695 -> 615;
695 -> 594;
696 -> 604;
696 -> 679;
696 -> 594;
697 -> 594;
698 -> 696;
698 -> 697;
699 -> 697;
700 -> 698;
700 -> 697;
701 -> 700;
701 -> 679;
701 -> 680;
701 -> 695;
701 -> 697;
702 -> 0;
702 -> 697;
703 -> 702;
703 -> 699;
703 -> 697;
704 -> 703;
704 -> 594;
705 -> 704;
705 -> 615;
705 -> 594;
706 -> 601;
706 -> 594;
707 -> 706;
708 -> 598;
708 -> 707;
708 -> 706;
709 -> 599;
709 -> 707;
709 -> 706;
710 -> 708;
710 -> 709;
710 -> 706;
711 -> 600;
711 -> 707;
711 -> 706;
712 -> 710;
712 -> 711;
712 -> 706;
713 -> 603;
713 -> 594;
714 -> 615;
714 -> 679;
714 -> 680;
714 -> 695;
714 -> 705;
714 -> 686;
714 -> 687;
714 -> 694;
714 -> 688;
714 -> 689;
714 -> 691;
714 -> 690;
714 -> 713;
715 -> 713;
716 -> 615;
716 -> 715;
717 -> 716;
717 -> 714;
717 -> 715;
718 -> 602;
718 -> 713;
719 -> 713;
720 -> 713;
721 -> 714;
721 -> 720;
722 -> 717;
722 -> 720;
723 -> 718;
723 -> 720;
724 -> 719;
724 -> 720;
725 -> 721;
725 -> 720;
726 -> 722;
726 -> 720;
727 -> 723;
727 -> 720;
728 -> 720;
729 -> 728;
729 -> 725;
729 -> 726;
729 -> 727;
729 -> 714;
729 -> 720;
730 -> 719;
730 -> 615;
730 -> 713;
731 -> 604;
731 -> 615;
731 -> 594;
732 -> 615;
732 -> 729;
732 -> 594;
733 -> 594;
734 -> 615;
734 -> 729;
734 -> 733;
734 -> 594;
735 -> 541;
736 -> 544;
736 -> 735;
736 -> 541;
737 -> 544;
737 -> 736;
738 -> 736;
739 -> 737;
739 -> 738;
740 -> 562;
740 -> 738;
741 -> 738;
742 -> 739;
742 -> 741;
742 -> 738;
743 -> 739;
743 -> 738;
744 -> 743;
744 -> 729;
744 -> 730;
744 -> 731;
744 -> 738;
745 -> 738;
746 -> 740;
746 -> 744;
746 -> 738;
747 -> 745;
747 -> 738;
748 -> 746;
748 -> 744;
748 -> 738;
749 -> 747;
749 -> 748;
749 -> 745;
749 -> 744;
749 -> 738;
750 -> 738;
751 -> 738;
752 -> 739;
752 -> 738;
753 -> 752;
753 -> 749;
753 -> 738;
754 -> 753;
755 -> 753;
756 -> 753;
757 -> 740;
757 -> 756;
757 -> 753;
758 -> 753;
759 -> 745;
759 -> 758;
759 -> 756;
759 -> 753;
760 -> 750;
760 -> 753;
760 -> 759;
761 -> 751;
761 -> 753;
762 -> 745;
762 -> 759;
762 -> 738;
763 -> 740;
763 -> 762;
763 -> 738;
764 -> 739;
764 -> 738;
765 -> 746;
765 -> 764;
765 -> 762;
765 -> 738;
766 -> 740;
766 -> 765;
766 -> 738;
767 -> 760;
767 -> 738;
768 -> 765;
768 -> 738;
769 -> 738;
770 -> 766;
770 -> 769;
771 -> 767;
771 -> 769;
772 -> 768;
772 -> 769;
773 -> 740;
773 -> 769;
774 -> 773;
774 -> 765;
774 -> 769;
775 -> 769;
776 -> 773;
776 -> 775;
777 -> 776;
777 -> 765;
777 -> 775;
778 -> 777;
778 -> 775;
779 -> 778;
779 -> 769;
780 -> 769;
781 -> 774;
781 -> 780;
782 -> 781;
782 -> 774;
782 -> 780;
783 -> 769;
784 -> 782;
784 -> 783;
785 -> 770;
785 -> 769;
786 -> 771;
786 -> 769;
787 -> 772;
787 -> 769;
788 -> 769;
789 -> 769;
790 -> 774;
790 -> 789;
791 -> 774;
791 -> 789;
792 -> 774;
792 -> 789;
793 -> 779;
793 -> 789;
794 -> 782;
794 -> 789;
795 -> 784;
795 -> 789;
796 -> 784;
796 -> 789;
797 -> 785;
797 -> 789;
798 -> 786;
798 -> 789;
799 -> 787;
799 -> 789;
800 -> 784;
800 -> 789;
801 -> 788;
801 -> 789;
802 -> 788;
802 -> 789;
803 -> 793;
803 -> 789;
804 -> 794;
804 -> 789;
805 -> 795;
805 -> 789;
806 -> 799;
806 -> 784;
806 -> 789;
807 -> 801;
807 -> 789;
808 -> 789;
809 -> 803;
809 -> 808;
810 -> 804;
810 -> 808;
811 -> 805;
811 -> 808;
812 -> 807;
812 -> 808;
813 -> 802;
813 -> 808;
814 -> 812;
814 -> 808;
815 -> 808;
816 -> 815;
816 -> 808;
817 -> 815;
817 -> 808;
818 -> 815;
818 -> 808;
819 -> 815;
819 -> 808;
820 -> 815;
820 -> 808;
821 -> 815;
821 -> 808;
822 -> 815;
822 -> 808;
823 -> 815;
823 -> 808;
824 -> 815;
824 -> 808;
825 -> 815;
825 -> 808;
826 -> 815;
826 -> 808;
827 -> 815;
827 -> 808;
828 -> 815;
828 -> 808;
829 -> 815;
829 -> 808;
830 -> 815;
830 -> 808;
831 -> 815;
831 -> 808;
832 -> 815;
832 -> 808;
833 -> 815;
833 -> 808;
834 -> 815;
834 -> 808;
835 -> 815;
835 -> 808;
836 -> 815;
836 -> 808;
837 -> 815;
837 -> 808;
838 -> 815;
838 -> 808;
839 -> 815;
839 -> 808;
840 -> 815;
840 -> 808;
841 -> 815;
841 -> 808;
842 -> 808;
843 -> 842;
843 -> 815;
843 -> 808;
844 -> 815;
844 -> 808;
845 -> 815;
845 -> 808;
846 -> 815;
846 -> 808;
847 -> 815;
847 -> 808;
848 -> 815;
848 -> 808;
849 -> 815;
849 -> 808;
850 -> 815;
850 -> 808;
851 -> 808;
852 -> 808;
853 -> 850;
853 -> 852;
854 -> 851;
854 -> 852;
855 -> 852;
856 -> 854;
856 -> 855;
857 -> 855;
858 -> 854;
858 -> 852;
859 -> 853;
859 -> 854;
859 -> 852;
860 -> 851;
860 -> 815;
860 -> 808;
861 -> 815;
861 -> 808;
862 -> 815;
862 -> 808;
863 -> 808;
864 -> 808;
865 -> 862;
865 -> 864;
866 -> 863;
866 -> 864;
867 -> 864;
868 -> 867;
868 -> 864;
869 -> 867;
869 -> 864;
870 -> 867;
870 -> 864;
871 -> 864;
872 -> 871;
872 -> 867;
872 -> 864;
873 -> 864;
874 -> 865;
874 -> 873;
874 -> 864;
875 -> 865;
875 -> 867;
875 -> 864;
876 -> 863;
876 -> 815;
876 -> 808;
877 -> 808;
878 -> 806;
878 -> 877;
879 -> 877;
880 -> 878;
880 -> 877;
881 -> 880;
881 -> 806;
881 -> 876;
881 -> 867;
881 -> 868;
881 -> 875;
881 -> 869;
881 -> 870;
881 -> 872;
881 -> 871;
882 -> 880;
883 -> 881;
883 -> 882;
884 -> 796;
884 -> 808;
885 -> 884;
886 -> 809;
886 -> 885;
886 -> 884;
887 -> 810;
887 -> 885;
887 -> 884;
888 -> 886;
888 -> 887;
888 -> 884;
889 -> 811;
889 -> 885;
889 -> 884;
890 -> 888;
890 -> 889;
890 -> 884;
891 -> 797;
891 -> 798;
892 -> 815;
892 -> 798;
893 -> 797;
893 -> 892;
893 -> 806;
893 -> 876;
893 -> 883;
893 -> 867;
893 -> 868;
893 -> 875;
893 -> 869;
893 -> 870;
893 -> 872;
893 -> 871;
893 -> 798;
894 -> 797;
894 -> 815;
894 -> 798;
895 -> 815;
895 -> 893;
895 -> 808;
896 -> 808;
897 -> 815;
897 -> 893;
897 -> 896;
897 -> 808;
898 -> 788;
898 -> 738;
899 -> 898;
899 -> 736;
900 -> 899;
900 -> 893;
900 -> 541;
901 -> 899;
901 -> 541;
902 -> 518;
902 -> 901;
902 -> 893;
902 -> 894;
902 -> 799;
902 -> 226;
903 -> 902;
903 -> 226;
904 -> 226;
905 -> 903;
905 -> 904;
906 -> 904;
907 -> 905;
907 -> 906;
908 -> 907;
908 -> 902;
908 -> 906;
909 -> 908;
909 -> 904;
910 -> 909;
910 -> 908;
910 -> 904;
911 -> 904;
912 -> 909;
912 -> 911;
912 -> 908;
912 -> 904;
913 -> 0;
913 -> 904;
914 -> 912;
914 -> 913;
914 -> 904;
915 -> 233;
915 -> 914;
915 -> 226;
916 -> 902;
916 -> 226;
917 -> 1;
918 -> 1;
919 -> 916;
919 -> 918;
920 -> 918;
921 -> 919;
921 -> 920;
922 -> 920;
923 -> 921;
923 -> 922;
924 -> 922;
925 -> 923;
925 -> 924;
926 -> 925;
926 -> 914;
926 -> 924;
927 -> 925;
927 -> 926;
928 -> 926;
929 -> 927;
929 -> 928;
930 -> 925;
930 -> 914;
930 -> 928;
931 -> 929;
931 -> 928;
932 -> 928;
933 -> 931;
933 -> 932;
934 -> 930;
934 -> 932;
935 -> 932;
936 -> 932;
937 -> 932;
938 -> 933;
938 -> 937;
939 -> 938;
939 -> 932;
940 -> 932;
941 -> 932;
942 -> 941;
942 -> 932;
943 -> 932;
944 -> 943;
944 -> 932;
945 -> 932;
946 -> 945;
946 -> 932;
947 -> 932;
948 -> 947;
948 -> 932;
949 -> 933;
949 -> 932;
950 -> 936;
950 -> 932;
951 -> 947;
951 -> 932;
952 -> 940;
952 -> 932;
953 -> 941;
953 -> 932;
954 -> 943;
954 -> 932;
955 -> 945;
955 -> 932;
956 -> 935;
956 -> 932;
957 -> 949;
957 -> 950;
957 -> 951;
957 -> 952;
957 -> 953;
957 -> 954;
957 -> 955;
957 -> 956;
957 -> 934;
957 -> 914;
957 -> 936;
957 -> 935;
957 -> 948;
957 -> 942;
957 -> 944;
957 -> 946;
957 -> 932;
958 -> 932;
959 -> 957;
959 -> 958;
960 -> 958;
961 -> 959;
961 -> 960;
962 -> 961;
962 -> 957;
962 -> 960;
963 -> 962;
963 -> 958;
964 -> 0;
965 -> 0;
965 -> 964;
966 -> 0;
967 -> 965;
967 -> 0;
967 -> 966;
968 -> 967;
969 -> 958;
970 -> 963;
970 -> 969;
971 -> 963;
971 -> 969;
972 -> 969;
973 -> 970;
973 -> 963;
973 -> 972;
973 -> 969;
974 -> 963;
974 -> 969;
975 -> 963;
975 -> 969;
976 -> 0;
976 -> 969;
977 -> 969;
978 -> 969;
979 -> 974;
979 -> 969;
980 -> 979;
981 -> 979;
982 -> 980;
982 -> 981;
983 -> 982;
983 -> 981;
984 -> 0;
984 -> 983;
985 -> 979;
986 -> 984;
986 -> 979;
987 -> 976;
987 -> 979;
988 -> 977;
988 -> 979;
989 -> 978;
989 -> 979;
990 -> 975;
990 -> 979;
991 -> 979;
992 -> 985;
992 -> 991;
993 -> 986;
993 -> 991;
994 -> 987;
994 -> 991;
995 -> 988;
995 -> 991;
996 -> 989;
996 -> 991;
997 -> 990;
997 -> 991;
998 -> 994;
998 -> 993;
998 -> 991;
999 -> 991;
1000 -> 976;
1000 -> 984;
1000 -> 979;
1001 -> 1000;
1001 -> 0;
1001 -> 969;
1002 -> 1000;
1002 -> 969;
1003 -> 957;
1003 -> 958;
1004 -> 1003;
1004 -> 1002;
1004 -> 958;
1005 -> 957;
1005 -> 958;
1006 -> 0;
1006 -> 958;
1007 -> 957;
1007 -> 1006;
1007 -> 1004;
1007 -> 932;
1008 -> 957;
1008 -> 958;
1009 -> 957;
1009 -> 958;
1010 -> 957;
1010 -> 958;
1011 -> 957;
1011 -> 958;
1012 -> 957;
1012 -> 958;
1013 -> 957;
1013 -> 958;
1014 -> 957;
1014 -> 958;
1015 -> 1008;
1015 -> 958;
1016 -> 1009;
1016 -> 958;
1017 -> 1013;
1017 -> 958;
1018 -> 1010;
1018 -> 958;
1019 -> 1011;
1019 -> 958;
1020 -> 1012;
1020 -> 958;
1021 -> 958;
1022 -> 958;
1023 -> 1015;
1023 -> 1022;
1024 -> 1016;
1024 -> 1022;
1025 -> 1017;
1025 -> 1022;
1026 -> 1018;
1026 -> 1022;
1027 -> 1019;
1027 -> 1022;
1028 -> 1020;
1028 -> 1022;
1029 -> 1021;
1029 -> 1022;
1030 -> 1023;
1030 -> 1007;
1030 -> 1022;
1031 -> 1023;
1031 -> 1007;
1031 -> 1022;
1032 -> 1025;
1032 -> 1022;
1033 -> 1022;
1034 -> 1030;
1034 -> 1033;
1035 -> 1031;
1035 -> 1033;
1036 -> 1032;
1036 -> 1033;
1037 -> 1029;
1037 -> 1033;
1038 -> 1033;
1039 -> 1038;
1039 -> 1033;
1040 -> 1038;
1040 -> 1033;
1041 -> 1038;
1041 -> 1033;
1042 -> 1033;
1043 -> 1034;
1043 -> 1042;
1043 -> 1033;
1044 -> 1035;
1044 -> 1007;
1044 -> 1033;
1045 -> 1036;
1045 -> 1038;
1045 -> 1033;
1046 -> 1034;
1046 -> 1038;
1046 -> 1033;
1047 -> 1035;
1047 -> 1038;
1047 -> 1033;
1048 -> 1029;
1048 -> 1022;
1049 -> 1029;
1049 -> 1022;
1050 -> 1029;
1050 -> 1022;
1051 -> 1029;
1051 -> 1022;
1052 -> 1029;
1052 -> 1022;
1053 -> 1029;
1053 -> 1022;
1054 -> 1029;
1054 -> 1022;
1055 -> 1022;
1056 -> 1026;
1056 -> 1055;
1056 -> 1022;
1057 -> 1022;
1058 -> 1024;
1058 -> 1057;
1058 -> 1022;
1059 -> 1024;
1059 -> 1029;
1059 -> 1022;
1060 -> 1023;
1060 -> 1029;
1060 -> 1022;
1061 -> 1026;
1061 -> 1029;
1061 -> 1022;
1062 -> 1028;
1062 -> 1029;
1062 -> 1022;
1063 -> 1027;
1063 -> 1029;
1063 -> 1022;
1064 -> 957;
1064 -> 1021;
1064 -> 1007;
1064 -> 1038;
1064 -> 1039;
1064 -> 1040;
1064 -> 1046;
1064 -> 1041;
1064 -> 1045;
1064 -> 1047;
1064 -> 1048;
1064 -> 1060;
1064 -> 1049;
1064 -> 1059;
1064 -> 1050;
1064 -> 1061;
1064 -> 1051;
1064 -> 1062;
1064 -> 1052;
1064 -> 1063;
1064 -> 1053;
1064 -> 1054;
1064 -> 932;
1065 -> 934;
1065 -> 1064;
1065 -> 932;
1066 -> 932;
1067 -> 1064;
1067 -> 932;
1068 -> 1065;
1068 -> 1066;
1069 -> 1068;
1069 -> 1065;
1069 -> 1066;
1070 -> 932;
1071 -> 1069;
1071 -> 932;
1072 -> 932;
1073 -> 932;
1074 -> 932;
1075 -> 1074;
1075 -> 932;
1076 -> 932;
1077 -> 1076;
1077 -> 932;
1078 -> 932;
1079 -> 1078;
1079 -> 932;
1080 -> 933;
1080 -> 1071;
1080 -> 932;
1081 -> 932;
1082 -> 1080;
1082 -> 1081;
1082 -> 932;
1083 -> 1082;
1083 -> 932;
1084 -> 932;
1085 -> 1083;
1085 -> 1084;
1085 -> 932;
1086 -> 1085;
1086 -> 932;
1087 -> 932;
1088 -> 1086;
1088 -> 1087;
1088 -> 932;
1089 -> 1088;
1089 -> 932;
1090 -> 0;
1090 -> 932;
1091 -> 1090;
1091 -> 1089;
1091 -> 932;
1092 -> 933;
1092 -> 932;
1093 -> 1071;
1093 -> 932;
1094 -> 1064;
1094 -> 932;
1095 -> 932;
1096 -> 933;
1096 -> 1095;
1097 -> 1096;
1097 -> 1071;
1097 -> 1095;
1098 -> 1097;
1098 -> 932;
1099 -> 932;
1100 -> 933;
1100 -> 1099;
1101 -> 1100;
1101 -> 1071;
1101 -> 1099;
1102 -> 1101;
1102 -> 932;
1103 -> 939;
1103 -> 932;
1104 -> 936;
1104 -> 932;
1105 -> 1078;
1105 -> 932;
1106 -> 1074;
1106 -> 932;
1107 -> 1076;
1107 -> 932;
1108 -> 1091;
1108 -> 932;
1109 -> 935;
1109 -> 932;
1110 -> 1072;
1110 -> 932;
1111 -> 1073;
1111 -> 932;
1112 -> 1092;
1112 -> 1093;
1112 -> 1094;
1112 -> 1098;
1112 -> 1102;
1112 -> 1103;
1112 -> 1104;
1112 -> 1105;
1112 -> 1106;
1112 -> 1107;
1112 -> 1108;
1112 -> 1109;
1112 -> 1110;
1112 -> 1111;
1112 -> 934;
1112 -> 1071;
1112 -> 1064;
1112 -> 1079;
1112 -> 1075;
1112 -> 1077;
1112 -> 0;
1112 -> 932;
1113 -> 932;
1114 -> 1112;
1114 -> 1113;
1115 -> 1112;
1115 -> 1113;
1116 -> 1112;
1116 -> 1113;
1117 -> 1116;
1117 -> 1112;
1117 -> 1113;
1118 -> 1114;
1118 -> 1113;
1119 -> 1113;
1120 -> 1115;
1120 -> 1113;
1121 -> 1117;
1121 -> 1118;
1121 -> 1119;
1121 -> 1120;
1121 -> 1112;
1121 -> 1113;
1122 -> 1112;
1122 -> 1113;
1123 -> 1122;
1123 -> 1121;
1123 -> 1113;
1124 -> 1112;
1124 -> 1113;
1125 -> 1124;
1125 -> 1123;
1125 -> 1113;
1126 -> 1112;
1126 -> 1113;
1127 -> 1126;
1127 -> 1125;
1127 -> 1113;
1128 -> 1112;
1128 -> 1113;
1129 -> 1128;
1129 -> 1127;
1129 -> 1113;
1130 -> 1112;
1130 -> 1113;
1131 -> 1113;
1132 -> 1130;
1132 -> 1129;
1132 -> 1131;
1132 -> 1113;
1133 -> 1132;
1134 -> 1133;
1134 -> 1130;
1134 -> 1132;
1135 -> 1130;
1135 -> 1129;
1135 -> 1134;
1135 -> 1132;
1136 -> 1132;
1137 -> 1135;
1137 -> 1136;
1138 -> 1130;
1138 -> 1136;
1139 -> 1138;
1139 -> 1129;
1139 -> 1136;
1140 -> 1139;
1140 -> 1129;
1140 -> 1134;
1140 -> 1136;
1141 -> 1132;
1142 -> 1130;
1142 -> 1129;
1142 -> 1134;
1142 -> 1113;
1143 -> 1142;
1143 -> 932;
1144 -> 1142;
1144 -> 932;
1145 -> 1142;
1145 -> 932;
1146 -> 1064;
1146 -> 1145;
1146 -> 1142;
1146 -> 1144;
1146 -> 932;
1147 -> 932;
1148 -> 932;
1149 -> 1148;
1149 -> 932;
1150 -> 1142;
1150 -> 932;
1151 -> 1144;
1151 -> 932;
1152 -> 1146;
1152 -> 932;
1153 -> 1064;
1153 -> 932;
1154 -> 1064;
1154 -> 1146;
1154 -> 932;
1155 -> 936;
1155 -> 932;
1156 -> 939;
1156 -> 932;
1157 -> 1147;
1157 -> 932;
1158 -> 1148;
1158 -> 932;
1159 -> 1150;
1159 -> 1151;
1159 -> 1152;
1159 -> 1153;
1159 -> 1154;
1159 -> 1155;
1159 -> 1156;
1159 -> 1157;
1159 -> 1158;
1159 -> 1146;
1159 -> 1144;
1159 -> 1149;
1159 -> 932;
1160 -> 932;
1161 -> 932;
1162 -> 1161;
1162 -> 1142;
1162 -> 1159;
1162 -> 932;
1163 -> 1142;
1163 -> 1159;
1163 -> 1161;
1163 -> 1162;
1164 -> 1163;
1164 -> 1159;
1164 -> 1162;
1165 -> 1142;
1165 -> 1161;
1165 -> 1159;
1165 -> 1164;
1166 -> 1164;
1167 -> 1165;
1167 -> 1166;
1168 -> 1167;
1168 -> 1165;
1168 -> 1166;
1169 -> 1166;
1170 -> 1167;
1170 -> 1169;
1171 -> 1170;
1171 -> 1166;
1172 -> 1166;
1173 -> 1167;
1173 -> 1172;
1174 -> 1172;
1175 -> 1173;
1175 -> 1174;
1176 -> 1175;
1176 -> 1165;
1176 -> 1174;
1177 -> 1175;
1177 -> 1165;
1177 -> 1176;
1178 -> 1177;
1178 -> 1175;
1178 -> 1176;
1179 -> 1176;
1180 -> 1179;
1180 -> 1175;
1180 -> 1176;
1181 -> 1175;
1181 -> 1177;
1181 -> 1178;
1181 -> 1174;
1182 -> 1181;
1182 -> 1172;
1183 -> 1173;
1183 -> 1177;
1183 -> 1172;
1184 -> 1183;
1184 -> 1166;
1185 -> 1166;
1186 -> 1166;
1187 -> 1168;
1187 -> 1186;
1188 -> 1168;
1188 -> 1186;
1189 -> 1171;
1189 -> 1186;
1190 -> 1184;
1190 -> 1186;
1191 -> 1185;
1191 -> 1186;
1192 -> 1186;
1193 -> 1191;
1193 -> 1192;
1194 -> 1192;
1195 -> 1193;
1195 -> 1194;
1198 -> 1197;
1198 -> 1196;
1199 -> 1196;
1200 -> 1194;
1201 -> 1195;
1201 -> 1200;
1202 -> 1200;
1203 -> 1201;
1203 -> 1202;
1204 -> 1203;
1204 -> 1202;
1205 -> 1201;
1205 -> 1200;
1206 -> 1194;
1207 -> 1206;
1207 -> 1195;
1207 -> 1194;
1208 -> 1195;
1208 -> 1194;
1209 -> 1193;
1209 -> 1192;
1210 -> 1193;
1210 -> 1192;
1211 -> 1193;
1211 -> 1192;
1212 -> 1193;
1212 -> 1192;
1213 -> 1193;
1213 -> 1192;
1214 -> 1193;
1214 -> 1192;
1215 -> 1193;
1215 -> 1192;
1216 -> 1191;
1216 -> 1186;
1217 -> 1191;
1217 -> 1186;
1218 -> 1191;
1218 -> 1186;
1219 -> 1186;
1220 -> 1187;
1220 -> 1219;
1220 -> 1186;
1221 -> 1186;
1222 -> 1188;
1222 -> 1221;
1222 -> 1186;
1223 -> 1187;
1223 -> 1191;
1223 -> 1186;
1224 -> 1188;
1224 -> 1191;
1224 -> 1186;
1225 -> 1187;
1225 -> 1177;
1225 -> 1178;
1225 -> 1180;
1225 -> 1186;
1226 -> 1186;
1227 -> 1226;
1227 -> 1187;
1227 -> 1177;
1227 -> 1178;
1227 -> 1180;
1227 -> 1186;
1228 -> 1191;
1228 -> 1227;
1230 -> 1229;
1231 -> 1187;
1231 -> 1177;
1231 -> 1226;
1231 -> 1178;
1231 -> 1180;
1231 -> 1227;
1232 -> 1190;
1232 -> 1227;
1233 -> 1226;
1233 -> 1227;
1234 -> 1227;
1235 -> 1227;
1236 -> 1228;
1236 -> 1235;
1237 -> 1231;
1237 -> 1235;
1238 -> 1232;
1238 -> 1235;
1239 -> 1233;
1239 -> 1235;
1240 -> 1234;
1240 -> 1235;
1241 -> 1236;
1241 -> 1235;
1242 -> 1237;
1242 -> 1235;
1243 -> 1238;
1243 -> 1235;
1244 -> 1239;
1244 -> 1235;
1245 -> 1235;
1246 -> 1241;
1246 -> 1245;
1247 -> 1242;
1247 -> 1245;
1248 -> 1243;
1248 -> 1245;
1249 -> 1244;
1249 -> 1245;
1250 -> 1240;
1250 -> 1245;
1251 -> 1245;
1252 -> 1250;
1252 -> 1251;
1253 -> 1251;
1254 -> 1252;
1254 -> 1253;
1255 -> 1253;
1256 -> 1254;
1256 -> 1255;
1257 -> 1256;
1257 -> 1255;
1258 -> 1252;
1258 -> 1251;
1259 -> 1250;
1259 -> 1245;
1260 -> 1250;
1260 -> 1245;
1261 -> 1250;
1261 -> 1245;
1262 -> 1250;
1262 -> 1245;
1263 -> 1250;
1263 -> 1245;
1264 -> 1250;
1264 -> 1245;
1265 -> 1250;
1265 -> 1245;
1266 -> 1245;
1267 -> 1266;
1267 -> 1245;
1268 -> 1230;
1268 -> 1245;
1269 -> 1267;
1269 -> 1268;
1269 -> 1245;
1270 -> 1269;
1270 -> 1250;
1270 -> 1245;
1271 -> 1245;
1272 -> 1271;
1272 -> 1245;
1273 -> 1230;
1273 -> 1245;
1274 -> 1272;
1274 -> 1273;
1274 -> 1245;
1275 -> 1274;
1275 -> 1250;
1275 -> 1245;
1276 -> 1250;
1276 -> 1245;
1277 -> 1250;
1277 -> 1245;
1278 -> 1250;
1278 -> 1245;
1279 -> 1250;
1279 -> 1245;
1280 -> 1245;
1281 -> 1246;
1281 -> 1280;
1281 -> 1245;
1282 -> 1245;
1283 -> 1247;
1283 -> 1282;
1283 -> 1245;
1284 -> 1246;
1284 -> 1250;
1284 -> 1245;
1285 -> 1249;
1285 -> 1250;
1285 -> 1245;
1286 -> 1247;
1286 -> 1250;
1286 -> 1245;
1287 -> 1248;
1287 -> 1250;
1287 -> 1245;
1288 -> 1250;
1288 -> 1245;
1289 -> 1245;
1290 -> 1245;
1291 -> 1288;
1291 -> 1290;
1292 -> 1289;
1292 -> 1290;
1293 -> 1290;
1294 -> 1292;
1294 -> 1293;
1295 -> 1293;
1296 -> 1294;
1296 -> 1295;
1297 -> 1295;
1298 -> 1296;
1298 -> 1297;
1299 -> 1297;
1300 -> 1298;
1300 -> 1299;
1301 -> 1300;
1301 -> 1299;
1302 -> 1296;
1302 -> 1295;
1303 -> 1296;
1303 -> 1295;
1304 -> 1294;
1304 -> 1293;
1305 -> 1294;
1305 -> 1293;
1306 -> 1294;
1306 -> 1293;
1307 -> 1292;
1307 -> 1290;
1308 -> 1290;
1309 -> 1291;
1309 -> 1308;
1309 -> 1290;
1310 -> 1291;
1310 -> 1292;
1310 -> 1290;
1311 -> 1289;
1311 -> 1250;
1311 -> 1245;
1312 -> 1250;
1312 -> 1245;
1313 -> 1312;
1313 -> 1257;
1313 -> 1258;
1313 -> 1284;
1313 -> 1285;
1313 -> 1286;
1313 -> 1311;
1313 -> 1263;
1313 -> 1264;
1313 -> 1265;
1313 -> 1270;
1313 -> 1275;
1313 -> 1287;
1313 -> 1277;
1313 -> 1278;
1313 -> 1279;
1313 -> 1269;
1313 -> 1274;
1313 -> 1204;
1313 -> 1205;
1313 -> 1207;
1313 -> 1208;
1313 -> 1209;
1313 -> 1210;
1313 -> 1211;
1313 -> 1212;
1313 -> 1213;
1313 -> 1214;
1313 -> 1215;
1313 -> 1223;
1313 -> 1224;
1313 -> 1218;
1313 -> 1206;
1313 -> 1231;
1313 -> 1301;
1313 -> 1302;
1313 -> 1303;
1313 -> 1304;
1313 -> 1305;
1313 -> 1306;
1313 -> 1310;
1313 -> 1245;
1314 -> 1313;
1314 -> 1250;
1314 -> 1245;
1315 -> 1235;
1316 -> 1239;
1316 -> 1315;
1316 -> 1235;
1317 -> 1234;
1317 -> 1226;
1317 -> 1225;
1317 -> 1227;
1318 -> 1225;
1318 -> 1186;
1319 -> 1318;
1319 -> 1225;
1319 -> 1317;
1319 -> 1313;
1319 -> 1314;
1319 -> 1186;
1320 -> 1319;
1320 -> 1191;
1320 -> 1186;
1321 -> 1189;
1321 -> 1191;
1321 -> 1186;
1322 -> 1185;
1322 -> 1164;
1323 -> 1322;
1323 -> 1163;
1323 -> 1164;
1324 -> 1161;
1324 -> 1164;
1325 -> 1160;
1325 -> 1324;
1325 -> 1164;
1326 -> 1142;
1326 -> 1161;
1326 -> 1319;
1326 -> 1320;
1326 -> 1321;
1326 -> 1162;
1327 -> 1162;
1328 -> 1326;
1328 -> 1327;
1329 -> 1162;
1330 -> 1163;
1330 -> 1159;
1330 -> 1323;
1330 -> 1329;
1331 -> 1330;
1331 -> 1326;
1331 -> 1329;
1332 -> 1328;
1332 -> 1331;
1332 -> 1162;
1333 -> 933;
1333 -> 932;
1334 -> 934;
1334 -> 1326;
1334 -> 932;
1335 -> 933;
1335 -> 1326;
1335 -> 932;
1336 -> 932;
1338 -> 1064;
1338 -> 932;
1339 -> 932;
1340 -> 1333;
1340 -> 1339;
1341 -> 1334;
1341 -> 1339;
1342 -> 1335;
1342 -> 1339;
1343 -> 1338;
1343 -> 1339;
1344 -> 1336;
1344 -> 1339;
1345 -> 1339;
1346 -> 1344;
1346 -> 1345;
1347 -> 1345;
1348 -> 1346;
1348 -> 1347;
1349 -> 1347;
1350 -> 1348;
1350 -> 1349;
1351 -> 1349;
1352 -> 1350;
1352 -> 1351;
1353 -> 1352;
1353 -> 1351;
1354 -> 1350;
1354 -> 1349;
1355 -> 1347;
1356 -> 1355;
1356 -> 1348;
1356 -> 1347;
1357 -> 1348;
1357 -> 1347;
1358 -> 1346;
1358 -> 1345;
1359 -> 1346;
1359 -> 1345;
1360 -> 1346;
1360 -> 1345;
1361 -> 1346;
1361 -> 1345;
1362 -> 1346;
1362 -> 1345;
1363 -> 1346;
1363 -> 1345;
1364 -> 1346;
1364 -> 1345;
1365 -> 1344;
1365 -> 1339;
1366 -> 1344;
1366 -> 1339;
1367 -> 1344;
1367 -> 1339;
1368 -> 1344;
1368 -> 1339;
1369 -> 1344;
1369 -> 1339;
1370 -> 1344;
1370 -> 1339;
1371 -> 1344;
1371 -> 1339;
1372 -> 1344;
1372 -> 1339;
1373 -> 1344;
1373 -> 1339;
1374 -> 1339;
1375 -> 1374;
1375 -> 1344;
1375 -> 1339;
1376 -> 1339;
1377 -> 1376;
1377 -> 1344;
1377 -> 1339;
1378 -> 1339;
1379 -> 1378;
1379 -> 1344;
1379 -> 1339;
1380 -> 1344;
1380 -> 1339;
1381 -> 1344;
1381 -> 1339;
1382 -> 1339;
1383 -> 1340;
1383 -> 1382;
1383 -> 1339;
1384 -> 1339;
1385 -> 1341;
1385 -> 1384;
1385 -> 1339;
1386 -> 1342;
1386 -> 1339;
1387 -> 1343;
1387 -> 1064;
1387 -> 1339;
1388 -> 1340;
1388 -> 1344;
1388 -> 1339;
1389 -> 1341;
1389 -> 1344;
1389 -> 1339;
1390 -> 1339;
1391 -> 1390;
1391 -> 1343;
1391 -> 1064;
1391 -> 1339;
1392 -> 1344;
1392 -> 1339;
1393 -> 1339;
1394 -> 1340;
1394 -> 1393;
1395 -> 1394;
1395 -> 1335;
1395 -> 1393;
1396 -> 1395;
1396 -> 1339;
1397 -> 1342;
1397 -> 1339;
1398 -> 1339;
1399 -> 1339;
1400 -> 1392;
1400 -> 1399;
1401 -> 1396;
1401 -> 1399;
1402 -> 1397;
1402 -> 1399;
1403 -> 1398;
1403 -> 1399;
1404 -> 1399;
1405 -> 1403;
1405 -> 1404;
1406 -> 1404;
1407 -> 1405;
1407 -> 1406;
1408 -> 1406;
1409 -> 1407;
1409 -> 1408;
1410 -> 1409;
1410 -> 1408;
1411 -> 1405;
1411 -> 1404;
1412 -> 1403;
1412 -> 1399;
1413 -> 0;
1413 -> 1403;
1413 -> 1399;
1414 -> 1403;
1414 -> 1399;
1415 -> 1403;
1415 -> 1399;
1416 -> 1403;
1416 -> 1399;
1417 -> 1403;
1417 -> 1399;
1418 -> 1403;
1418 -> 1399;
1419 -> 1399;
1420 -> 1400;
1420 -> 1419;
1420 -> 1399;
1421 -> 1400;
1421 -> 1403;
1421 -> 1399;
1422 -> 1401;
1422 -> 1403;
1422 -> 1399;
1423 -> 1402;
1423 -> 1403;
1423 -> 1399;
1424 -> 1391;
1424 -> 1398;
1424 -> 1410;
1424 -> 1411;
1424 -> 1421;
1424 -> 1413;
1424 -> 1422;
1424 -> 1415;
1424 -> 1416;
1424 -> 1417;
1424 -> 1423;
1424 -> 1353;
1424 -> 1354;
1424 -> 1356;
1424 -> 1357;
1424 -> 1358;
1424 -> 1359;
1424 -> 1360;
1424 -> 1361;
1424 -> 1362;
1424 -> 1363;
1424 -> 1364;
1424 -> 1388;
1424 -> 1366;
1424 -> 1389;
1424 -> 1368;
1424 -> 1369;
1424 -> 1370;
1424 -> 1371;
1424 -> 1372;
1424 -> 1373;
1424 -> 1375;
1424 -> 1377;
1424 -> 1379;
1424 -> 1380;
1424 -> 1381;
1424 -> 1355;
1424 -> 1395;
1424 -> 1374;
1424 -> 1376;
1424 -> 1378;
1424 -> 1339;
1425 -> 1339;
1426 -> 1340;
1426 -> 1425;
1427 -> 1426;
1427 -> 1424;
1427 -> 1425;
1428 -> 1427;
1428 -> 1339;
1429 -> 1428;
1429 -> 1339;
1430 -> 1343;
1430 -> 1339;
1431 -> 1391;
1431 -> 1424;
1431 -> 1339;
1432 -> 1431;
1432 -> 1344;
1432 -> 1339;
1433 -> 1339;
1434 -> 1340;
1434 -> 1433;
1435 -> 1434;
1435 -> 1424;
1435 -> 1433;
1436 -> 1435;
1436 -> 1339;
1437 -> 1436;
1437 -> 1424;
1437 -> 1432;
1437 -> 1339;
1438 -> 932;
1439 -> 932;
1440 -> 1142;
1440 -> 1439;
1440 -> 932;
1441 -> 1440;
1442 -> 1142;
1442 -> 1424;
1442 -> 1432;
1442 -> 1441;
1443 -> 1442;
1443 -> 932;
1444 -> 932;
1445 -> 1443;
1445 -> 1444;
1446 -> 1336;
1446 -> 1444;
1447 -> 1444;
1448 -> 1446;
1448 -> 1424;
1448 -> 1447;
1448 -> 1444;
1449 -> 1445;
1449 -> 1446;
1449 -> 1444;
1450 -> 932;
1451 -> 932;
1452 -> 932;
1453 -> 1142;
1453 -> 1424;
1453 -> 1452;
1453 -> 932;
1454 -> 932;
1455 -> 1454;
1455 -> 932;
1456 -> 1336;
1456 -> 932;
1457 -> 1064;
1457 -> 932;
1458 -> 1453;
1458 -> 932;
1459 -> 1142;
1459 -> 932;
1460 -> 1451;
1460 -> 932;
1461 -> 1454;
1461 -> 932;
1462 -> 932;
1463 -> 1456;
1463 -> 1462;
1464 -> 1457;
1464 -> 1462;
1465 -> 1458;
1465 -> 1462;
1466 -> 1459;
1466 -> 1462;
1467 -> 1460;
1467 -> 1462;
1468 -> 1461;
1468 -> 1462;
1469 -> 1462;
1470 -> 1463;
1470 -> 1469;
1471 -> 1470;
1471 -> 1424;
1471 -> 1432;
1471 -> 1469;
1472 -> 1471;
1472 -> 1462;
1473 -> 1462;
1474 -> 1473;
1474 -> 1464;
1474 -> 1064;
1474 -> 1462;
1475 -> 1472;
1475 -> 1424;
1475 -> 1431;
1475 -> 1474;
1475 -> 1462;
1476 -> 1462;
1477 -> 1472;
1477 -> 1424;
1477 -> 1431;
1477 -> 1476;
1477 -> 1462;
1478 -> 1477;
1478 -> 1462;
1479 -> 1462;
1480 -> 1462;
1481 -> 1480;
1481 -> 1472;
1481 -> 1424;
1481 -> 1431;
1481 -> 1462;
1482 -> 1481;
1483 -> 1482;
1483 -> 1481;
1484 -> 1465;
1484 -> 1483;
1485 -> 1484;
1485 -> 1481;
1486 -> 1484;
1486 -> 1481;
1487 -> 1481;
1488 -> 1481;
1489 -> 1488;
1489 -> 1484;
1489 -> 1481;
1490 -> 1489;
1491 -> 1466;
1491 -> 1424;
1491 -> 1432;
1491 -> 1449;
1491 -> 1490;
1491 -> 1489;
1492 -> 1489;
1493 -> 1466;
1493 -> 1424;
1493 -> 1432;
1493 -> 1449;
1493 -> 1492;
1493 -> 1489;
1494 -> 1479;
1494 -> 1488;
1494 -> 1489;
1495 -> 1493;
1495 -> 1424;
1495 -> 1432;
1495 -> 1449;
1495 -> 1431;
1495 -> 1494;
1495 -> 1489;
1496 -> 1495;
1496 -> 1424;
1496 -> 1431;
1496 -> 1489;
1497 -> 1495;
1497 -> 1424;
1497 -> 1431;
1497 -> 1489;
1498 -> 1466;
1498 -> 1497;
1499 -> 1495;
1499 -> 1497;
1500 -> 1487;
1500 -> 1497;
1501 -> 1497;
1502 -> 1498;
1502 -> 1501;
1503 -> 1499;
1503 -> 1501;
1504 -> 1500;
1504 -> 1501;
1505 -> 1503;
1505 -> 1424;
1505 -> 1431;
1505 -> 1501;
1506 -> 1503;
1506 -> 1424;
1506 -> 1431;
1506 -> 1501;
1507 -> 1502;
1507 -> 1424;
1507 -> 1432;
1507 -> 1449;
1507 -> 1503;
1507 -> 1431;
1507 -> 1501;
1508 -> 1507;
1508 -> 1501;
1509 -> 1501;
1510 -> 1503;
1510 -> 1424;
1510 -> 1431;
1510 -> 1509;
1510 -> 1501;
1511 -> 1507;
1511 -> 1501;
1512 -> 1511;
1512 -> 1488;
1512 -> 1486;
1512 -> 1497;
1513 -> 1495;
1513 -> 1424;
1513 -> 1431;
1513 -> 1488;
1513 -> 1485;
1513 -> 1489;
1514 -> 1485;
1514 -> 1481;
1515 -> 1514;
1515 -> 1485;
1515 -> 1513;
1515 -> 1424;
1515 -> 1432;
1515 -> 1449;
1515 -> 1431;
1515 -> 1481;
1516 -> 1486;
1516 -> 1481;
1517 -> 1516;
1517 -> 1486;
1517 -> 1512;
1517 -> 1515;
1517 -> 1481;
1518 -> 1504;
1518 -> 1481;
1519 -> 1515;
1519 -> 1517;
1519 -> 1518;
1519 -> 1481;
1520 -> 1481;
1521 -> 1472;
1521 -> 1480;
1521 -> 1424;
1521 -> 1432;
1521 -> 1449;
1521 -> 1431;
1521 -> 1519;
1521 -> 1481;
1522 -> 1519;
1522 -> 1481;
1523 -> 1463;
1523 -> 1481;
1524 -> 1481;
1525 -> 1522;
1525 -> 1524;
1526 -> 1523;
1526 -> 1524;
1527 -> 1521;
1527 -> 1524;
1528 -> 1524;
1529 -> 1525;
1529 -> 1528;
1529 -> 1524;
1530 -> 1524;
1531 -> 1527;
1531 -> 1530;
1532 -> 1530;
1533 -> 1531;
1533 -> 1521;
1533 -> 1532;
1533 -> 1530;
1534 -> 1524;
1535 -> 1525;
1535 -> 1527;
1535 -> 1524;
1536 -> 1481;
1537 -> 1479;
1537 -> 1484;
1537 -> 1481;
1538 -> 1478;
1538 -> 1462;
1539 -> 932;
1540 -> 932;
1541 -> 1160;
1541 -> 1325;
1541 -> 1540;
1541 -> 932;
1542 -> 1142;
1542 -> 1541;
1543 -> 1160;
1543 -> 1541;
1544 -> 1336;
1544 -> 1541;
1545 -> 1142;
1545 -> 1541;
1546 -> 1467;
1546 -> 1541;
1547 -> 1541;
1548 -> 1543;
1548 -> 1547;
1549 -> 1544;
1549 -> 1547;
1550 -> 1545;
1550 -> 1547;
1551 -> 1545;
1551 -> 1547;
1552 -> 1546;
1552 -> 1547;
1553 -> 1547;
1554 -> 1548;
1554 -> 1160;
1554 -> 1325;
1554 -> 1553;
1554 -> 1547;
1555 -> 1547;
1556 -> 1549;
1556 -> 1555;
1557 -> 1556;
1557 -> 1521;
1557 -> 1555;
1558 -> 1557;
1558 -> 1547;
1559 -> 1547;
1560 -> 1558;
1560 -> 1559;
1560 -> 1547;
1561 -> 1548;
1561 -> 1547;
1562 -> 1550;
1562 -> 1561;
1562 -> 1521;
1562 -> 1535;
1563 -> 1561;
1564 -> 1562;
1564 -> 1563;
1564 -> 1561;
1565 -> 1550;
1565 -> 1561;
1565 -> 1562;
1565 -> 1564;
1566 -> 1565;
1566 -> 1564;
1567 -> 1551;
1567 -> 1564;
1568 -> 1551;
1568 -> 1565;
1568 -> 1561;
1568 -> 1564;
1569 -> 1552;
1569 -> 1564;
1570 -> 1549;
1570 -> 1564;
1571 -> 1564;
1572 -> 1566;
1572 -> 1571;
1573 -> 1567;
1573 -> 1571;
1574 -> 1568;
1574 -> 1571;
1575 -> 1569;
1575 -> 1571;
1576 -> 1570;
1576 -> 1571;
1577 -> 1574;
1577 -> 1565;
1577 -> 1571;
1578 -> 1574;
1578 -> 1565;
1578 -> 1571;
1579 -> 1574;
1579 -> 1565;
1579 -> 1571;
1580 -> 1571;
1581 -> 1579;
1581 -> 1580;
1582 -> 1581;
1582 -> 1565;
1582 -> 1580;
1583 -> 1582;
1583 -> 1571;
1584 -> 1583;
1584 -> 1565;
1584 -> 1571;
1585 -> 1571;
1586 -> 1571;
1587 -> 1586;
1587 -> 1584;
1587 -> 1571;
1588 -> 1572;
1588 -> 1565;
1588 -> 1586;
1588 -> 1587;
1589 -> 1588;
1589 -> 1587;
1590 -> 1588;
1590 -> 1587;
1591 -> 1587;
1592 -> 1572;
1592 -> 1591;
1593 -> 1592;
1593 -> 1588;
1593 -> 1591;
1594 -> 1593;
1594 -> 1587;
1595 -> 1585;
1595 -> 1587;
1596 -> 1589;
1596 -> 1587;
1597 -> 1587;
1598 -> 1588;
1598 -> 1587;
1599 -> 1594;
1599 -> 1595;
1599 -> 1596;
1599 -> 1597;
1599 -> 1598;
1599 -> 1588;
1599 -> 1589;
1599 -> 1587;
1600 -> 1587;
1601 -> 1587;
1602 -> 1601;
1602 -> 1588;
1602 -> 1587;
1603 -> 1589;
1603 -> 1587;
1604 -> 1603;
1604 -> 1599;
1604 -> 1587;
1605 -> 1590;
1605 -> 1587;
1606 -> 1600;
1606 -> 1587;
1607 -> 1604;
1607 -> 1605;
1607 -> 1606;
1607 -> 1587;
1608 -> 1583;
1608 -> 1586;
1608 -> 1565;
1608 -> 1607;
1608 -> 1587;
1609 -> 1607;
1609 -> 1587;
1610 -> 1576;
1610 -> 1587;
1611 -> 1587;
1612 -> 1609;
1612 -> 1611;
1613 -> 1610;
1613 -> 1611;
1614 -> 1608;
1614 -> 1611;
1615 -> 1611;
1616 -> 1612;
1616 -> 1615;
1616 -> 1611;
1617 -> 1611;
1618 -> 1614;
1618 -> 1617;
1619 -> 1617;
1620 -> 1618;
1620 -> 1608;
1620 -> 1619;
1620 -> 1617;
1621 -> 1611;
1622 -> 1587;
1623 -> 1585;
1623 -> 1588;
1623 -> 1587;
1624 -> 1564;
1625 -> 1547;
1626 -> 1547;
1627 -> 1549;
1627 -> 1626;
1628 -> 1627;
1628 -> 1608;
1628 -> 1626;
1629 -> 1628;
1629 -> 1547;
1630 -> 1547;
1631 -> 1629;
1631 -> 1630;
1631 -> 1608;
1631 -> 1612;
1631 -> 1547;
1632 -> 1547;
1633 -> 1631;
1633 -> 1632;
1634 -> 1632;
1635 -> 1633;
1635 -> 1634;
1636 -> 1634;
1637 -> 1635;
1637 -> 1631;
1637 -> 1636;
1637 -> 1634;
1638 -> 1632;
1639 -> 1633;
1639 -> 1631;
1639 -> 1632;
1640 -> 1548;
1640 -> 1547;
1641 -> 1551;
1641 -> 1631;
1641 -> 1640;
1642 -> 1641;
1642 -> 1631;
1642 -> 1640;
1643 -> 1641;
1643 -> 1631;
1643 -> 1640;
1644 -> 1550;
1644 -> 1640;
1644 -> 1631;
1645 -> 1640;
1646 -> 1644;
1646 -> 1645;
1647 -> 1625;
1647 -> 1640;
1648 -> 1550;
1648 -> 1640;
1648 -> 1646;
1649 -> 1640;
1650 -> 1648;
1650 -> 1649;
1651 -> 1641;
1651 -> 1631;
1651 -> 1640;
1652 -> 1651;
1652 -> 1648;
1652 -> 1640;
1653 -> 1640;
1654 -> 1625;
1654 -> 1647;
1654 -> 1653;
1654 -> 1640;
1655 -> 1558;
1655 -> 1640;
1656 -> 1640;
1657 -> 1655;
1657 -> 1656;
1658 -> 1641;
1658 -> 1631;
1658 -> 1656;
1659 -> 1656;
1660 -> 1658;
1660 -> 1648;
1660 -> 1659;
1660 -> 1656;
1661 -> 1657;
1661 -> 1658;
1661 -> 1656;
1662 -> 1640;
1663 -> 1625;
1663 -> 1647;
1663 -> 1547;
1664 -> 1547;
1665 -> 1575;
1665 -> 1664;
1665 -> 1547;
1666 -> 1541;
1667 -> 933;
1667 -> 1648;
1667 -> 932;
1668 -> 933;
1668 -> 1648;
1668 -> 1667;
1669 -> 934;
1669 -> 1648;
1669 -> 1668;
1670 -> 1160;
1670 -> 1668;
1671 -> 1142;
1671 -> 1668;
1672 -> 1668;
1673 -> 1670;
1673 -> 1672;
1674 -> 1671;
1674 -> 1672;
1675 -> 1671;
1675 -> 1672;
1676 -> 1673;
1676 -> 1672;
1677 -> 1675;
1677 -> 1648;
1677 -> 1661;
1677 -> 1676;
1678 -> 1677;
1678 -> 1648;
1678 -> 1676;
1679 -> 1674;
1679 -> 1676;
1679 -> 1648;
1679 -> 1661;
1680 -> 1676;
1681 -> 1679;
1681 -> 1680;
1681 -> 1676;
1682 -> 1674;
1682 -> 1676;
1682 -> 1679;
1682 -> 1681;
1683 -> 1677;
1683 -> 1648;
1683 -> 1681;
1684 -> 1682;
1684 -> 1683;
1684 -> 1681;
1685 -> 1668;
1686 -> 1159;
1686 -> 1668;
1687 -> 1064;
1687 -> 1668;
1688 -> 1142;
1688 -> 1668;
1689 -> 935;
1689 -> 1684;
1689 -> 1668;
1690 -> 1442;
1690 -> 1668;
1691 -> 1336;
1691 -> 1668;
1692 -> 1690;
1692 -> 1668;
1693 -> 1538;
1693 -> 1668;
1694 -> 1668;
1695 -> 1336;
1695 -> 1694;
1696 -> 1694;
1697 -> 1695;
1697 -> 1696;
1698 -> 1697;
1698 -> 1689;
1698 -> 1696;
1699 -> 1698;
1699 -> 1694;
1700 -> 1694;
1701 -> 1668;
1702 -> 1699;
1702 -> 1701;
1703 -> 1701;
1704 -> 1702;
1704 -> 1703;
1705 -> 1703;
1706 -> 1704;
1706 -> 1699;
1706 -> 1705;
1706 -> 1703;
1707 -> 1701;
1708 -> 1702;
1708 -> 1699;
1708 -> 1701;
1709 -> 1668;
1710 -> 1336;
1710 -> 1709;
1711 -> 1709;
1712 -> 1710;
1712 -> 1711;
1713 -> 1712;
1713 -> 1699;
1713 -> 1711;
1714 -> 1709;
1715 -> 1668;
1716 -> 1713;
1716 -> 1715;
1717 -> 1715;
1718 -> 1716;
1718 -> 1717;
1719 -> 1717;
1720 -> 1718;
1720 -> 1713;
1720 -> 1719;
1720 -> 1717;
1721 -> 1715;
1722 -> 1716;
1722 -> 1713;
1722 -> 1715;
1723 -> 934;
1723 -> 1686;
1723 -> 1687;
1723 -> 1688;
1723 -> 1689;
1723 -> 1692;
1723 -> 1693;
1723 -> 1708;
1723 -> 1722;
1723 -> 1713;
1723 -> 1699;
1723 -> 1064;
1723 -> 1684;
1723 -> 1538;
1723 -> 1159;
1723 -> 1668;
1724 -> 933;
1724 -> 1723;
1724 -> 1668;
1725 -> 934;
1725 -> 1668;
1726 -> 934;
1726 -> 933;
1726 -> 1668;
1727 -> 1336;
1727 -> 933;
1727 -> 1668;
1728 -> 932;
1729 -> 935;
1729 -> 1723;
1729 -> 1726;
1729 -> 1727;
1729 -> 932;
1730 -> 936;
1730 -> 1729;
1730 -> 932;
1731 -> 1728;
1731 -> 928;
1732 -> 930;
1732 -> 1730;
1732 -> 1731;
1732 -> 928;
1733 -> 930;
1733 -> 1730;
1733 -> 928;
1734 -> 929;
1734 -> 1733;
1734 -> 928;
1735 -> 926;
1736 -> 925;
1736 -> 1733;
1736 -> 926;
1737 -> 925;
1737 -> 1733;
1737 -> 924;
1738 -> 1737;
1738 -> 922;
1739 -> 923;
1739 -> 1733;
1739 -> 922;
1740 -> 923;
1740 -> 1739;
1740 -> 922;
1741 -> 1740;
1741 -> 920;
1742 -> 1741;
1742 -> 918;
1743 -> 918;
1744 -> 1742;
1744 -> 1743;
1745 -> 918;
1746 -> 1744;
1746 -> 1;
1747 -> 1;
1748 -> 1746;
1748 -> 1747;
1749 -> 1747;
1750 -> 1748;
1750 -> 1744;
1750 -> 1749;
1750 -> 1747;
1751 -> 1750;
1752 -> 1748;
1752 -> 1750;
1753 -> 1750;
1754 -> 1748;
1754 -> 1753;
1755 -> 1753;
1756 -> 1754;
1756 -> 1744;
1756 -> 1755;
1757 -> 1756;
1757 -> 1744;
1757 -> 1755;
1758 -> 1757;
1758 -> 1753;
1759 -> 1758;
1759 -> 1750;
1760 -> 1750;
1761 -> 1759;
1761 -> 1760;
1762 -> 1760;
1763 -> 1761;
1763 -> 1762;
1764 -> 1763;
1764 -> 1760;
1765 -> 1761;
1765 -> 1760;
1766 -> 1760;
1768 -> 1767;
1770 -> 1769;
1771 -> 1751;
1771 -> 1750;
1772 -> 1750;
1773 -> 1750;
1774 -> 1752;
1774 -> 1773;
1775 -> 1752;
1775 -> 1773;
1776 -> 1764;
1776 -> 1773;
1777 -> 1771;
1777 -> 1773;
1778 -> 1772;
1778 -> 1773;
1779 -> 1773;
1780 -> 1778;
1780 -> 1773;
1781 -> 1778;
1781 -> 1773;
1782 -> 1778;
1782 -> 1773;
1783 -> 1778;
1783 -> 1773;
1784 -> 1778;
1784 -> 1773;
1785 -> 1778;
1785 -> 1773;
1788 -> 1787;
1788 -> 1786;
1790 -> 1789;
1790 -> 1786;
1791 -> 1786;
1794 -> 1793;
1794 -> 1792;
1796 -> 1795;
1796 -> 1792;
1797 -> 1792;
1799 -> 0;
1799 -> 1798;
1801 -> 0;
1801 -> 1800;
1802 -> 1801;
1802 -> 1798;
1803 -> 1798;
1805 -> 0;
1805 -> 1804;
1806 -> 0;
1806 -> 1804;
1807 -> 1804;
1808 -> 1797;
1808 -> 1778;
1808 -> 1773;
1809 -> 1773;
1810 -> 1776;
1810 -> 1809;
1810 -> 1773;
1811 -> 1774;
1811 -> 1778;
1811 -> 1773;
1812 -> 1775;
1812 -> 1778;
1812 -> 1773;
1813 -> 1776;
1813 -> 1778;
1813 -> 1773;
1814 -> 1776;
1814 -> 1764;
1814 -> 1773;
1815 -> 1814;
1815 -> 1764;
1816 -> 1777;
1816 -> 1815;
1816 -> 1751;
1816 -> 1764;
1816 -> 1814;
1817 -> 1751;
1817 -> 1816;
1817 -> 1750;
1818 -> 1751;
1818 -> 1816;
1818 -> 1750;
1819 -> 1748;
1819 -> 1818;
1819 -> 1750;
1820 -> 1772;
1820 -> 1750;
1821 -> 1750;
1822 -> 1819;
1822 -> 1820;
1822 -> 1821;
1822 -> 1778;
1822 -> 1811;
1822 -> 1812;
1822 -> 1813;
1822 -> 1783;
1822 -> 1784;
1822 -> 1785;
1822 -> 1808;
1822 -> 1818;
1822 -> 1794;
1822 -> 1796;
1822 -> 1792;
1822 -> 1750;
1823 -> 1748;
1823 -> 1822;
1823 -> 1747;
1824 -> 1;
1825 -> 1;
1826 -> 1824;
1826 -> 1825;
1827 -> 1823;
1827 -> 1825;
1828 -> 1825;
1829 -> 1828;
1829 -> 1825;
1830 -> 1825;
1831 -> 1827;
1831 -> 1830;
1832 -> 1830;
1833 -> 1831;
1833 -> 1822;
1833 -> 1832;
1833 -> 1830;
1834 -> 1831;
1834 -> 1822;
1834 -> 1833;
1835 -> 1833;
1836 -> 1831;
1836 -> 1835;
1837 -> 1835;
1838 -> 1836;
1838 -> 1822;
1838 -> 1837;
1838 -> 1835;
1839 -> 1838;
1840 -> 1836;
1840 -> 1822;
1840 -> 1838;
1841 -> 1839;
1841 -> 1838;
1842 -> 1838;
1843 -> 1841;
1843 -> 1842;
1844 -> 1836;
1844 -> 1842;
1845 -> 1844;
1845 -> 1822;
1845 -> 1842;
1846 -> 1842;
1847 -> 1845;
1847 -> 1846;
1848 -> 1845;
1848 -> 1846;
1849 -> 1847;
1849 -> 1846;
1850 -> 0;
1850 -> 1846;
1851 -> 1849;
1851 -> 1848;
1851 -> 1846;
1852 -> 1844;
1852 -> 1851;
1852 -> 1842;
1853 -> 1852;
1854 -> 1843;
1854 -> 1852;
1855 -> 1852;
1856 -> 1853;
1856 -> 1855;
1857 -> 1854;
1857 -> 1855;
1858 -> 1844;
1858 -> 1855;
1859 -> 1856;
1859 -> 1851;
1859 -> 1855;
1860 -> 1858;
1860 -> 1859;
1861 -> 1856;
1861 -> 1859;
1862 -> 1857;
1862 -> 1859;
1863 -> 1859;
1864 -> 1859;
1865 -> 1860;
1865 -> 1864;
1866 -> 1861;
1866 -> 1864;
1867 -> 1862;
1867 -> 1864;
1868 -> 1863;
1868 -> 1864;
1869 -> 1863;
1869 -> 1864;
1871 -> 1870;
1873 -> 1872;
1875 -> 1874;
1877 -> 1876;
1879 -> 1878;
1881 -> 1880;
1882 -> 0;
1884 -> 1871;
1884 -> 1883;
1885 -> 1873;
1885 -> 1883;
1886 -> 1875;
1886 -> 1883;
1887 -> 1877;
1887 -> 1883;
1888 -> 1879;
1888 -> 1883;
1889 -> 1881;
1889 -> 1883;
1890 -> 1882;
1890 -> 1883;
1891 -> 1883;
1892 -> 1891;
1892 -> 1883;
1893 -> 1891;
1893 -> 1883;
1894 -> 1891;
1894 -> 1883;
1895 -> 1891;
1895 -> 1883;
1896 -> 1891;
1896 -> 1883;
1897 -> 1891;
1897 -> 1883;
1898 -> 1891;
1898 -> 1883;
1899 -> 1885;
1899 -> 1883;
1900 -> 1883;
1901 -> 1884;
1901 -> 1891;
1901 -> 1883;
1902 -> 1885;
1902 -> 1891;
1902 -> 1883;
1903 -> 1886;
1903 -> 1891;
1903 -> 1883;
1904 -> 1887;
1904 -> 1891;
1904 -> 1883;
1905 -> 1888;
1905 -> 1891;
1905 -> 1883;
1906 -> 1889;
1906 -> 1891;
1906 -> 1883;
1907 -> 1890;
1907 -> 1891;
1907 -> 1883;
1908 -> 1891;
1908 -> 1907;
1908 -> 0;
1908 -> 1883;
1909 -> 1883;
1910 -> 1889;
1910 -> 1883;
1911 -> 1883;
1913 -> 1912;
1915 -> 1914;
1917 -> 1916;
1919 -> 1918;
1921 -> 1920;
1923 -> 1922;
1924 -> 0;
1926 -> 1913;
1926 -> 1925;
1927 -> 1915;
1927 -> 1925;
1928 -> 1917;
1928 -> 1925;
1929 -> 1919;
1929 -> 1925;
1930 -> 1921;
1930 -> 1925;
1931 -> 1923;
1931 -> 1925;
1932 -> 1924;
1932 -> 1925;
1933 -> 1925;
1934 -> 1933;
1934 -> 1925;
1935 -> 1933;
1935 -> 1925;
1936 -> 1933;
1936 -> 1925;
1937 -> 1933;
1937 -> 1925;
1938 -> 1933;
1938 -> 1925;
1939 -> 1933;
1939 -> 1925;
1940 -> 1933;
1940 -> 1925;
1941 -> 1927;
1941 -> 1926;
1941 -> 1925;
1942 -> 1925;
1943 -> 1926;
1943 -> 1933;
1943 -> 1925;
1944 -> 1927;
1944 -> 1933;
1944 -> 1925;
1945 -> 1928;
1945 -> 1933;
1945 -> 1925;
1946 -> 1929;
1946 -> 1933;
1946 -> 1925;
1947 -> 1930;
1947 -> 1933;
1947 -> 1925;
1948 -> 1931;
1948 -> 1933;
1948 -> 1925;
1949 -> 1932;
1949 -> 1933;
1949 -> 1925;
1950 -> 1933;
1950 -> 1949;
1950 -> 0;
1950 -> 1925;
1951 -> 1925;
1952 -> 1931;
1952 -> 1925;
1953 -> 1925;
1955 -> 1954;
1957 -> 1956;
1959 -> 1958;
1961 -> 1960;
1963 -> 1962;
1965 -> 1964;
1966 -> 0;
1968 -> 1955;
1968 -> 1967;
1969 -> 1957;
1969 -> 1967;
1970 -> 1959;
1970 -> 1967;
1971 -> 1961;
1971 -> 1967;
1972 -> 1963;
1972 -> 1967;
1973 -> 1965;
1973 -> 1967;
1974 -> 1966;
1974 -> 1967;
1975 -> 1967;
1976 -> 1975;
1976 -> 1967;
1977 -> 1975;
1977 -> 1967;
1978 -> 1975;
1978 -> 1967;
1979 -> 1975;
1979 -> 1967;
1980 -> 1975;
1980 -> 1967;
1981 -> 1975;
1981 -> 1967;
1982 -> 1975;
1982 -> 1967;
1983 -> 1969;
1983 -> 1968;
1983 -> 1967;
1984 -> 1967;
1985 -> 1968;
1985 -> 1975;
1985 -> 1967;
1986 -> 1969;
1986 -> 1975;
1986 -> 1967;
1987 -> 1970;
1987 -> 1975;
1987 -> 1967;
1988 -> 1971;
1988 -> 1975;
1988 -> 1967;
1989 -> 1972;
1989 -> 1975;
1989 -> 1967;
1990 -> 1973;
1990 -> 1975;
1990 -> 1967;
1991 -> 1974;
1991 -> 1975;
1991 -> 1967;
1992 -> 1975;
1992 -> 1991;
1992 -> 0;
1992 -> 1967;
1993 -> 1967;
1994 -> 1973;
1994 -> 1967;
1995 -> 1967;
1997 -> 1996;
1999 -> 1998;
2001 -> 2000;
2003 -> 2002;
2005 -> 2004;
2007 -> 2006;
2008 -> 0;
2010 -> 1997;
2010 -> 2009;
2011 -> 1999;
2011 -> 2009;
2012 -> 2001;
2012 -> 2009;
2013 -> 2003;
2013 -> 2009;
2014 -> 2005;
2014 -> 2009;
2015 -> 2007;
2015 -> 2009;
2016 -> 2008;
2016 -> 2009;
2017 -> 2009;
2018 -> 2017;
2018 -> 2009;
2019 -> 2017;
2019 -> 2009;
2020 -> 2017;
2020 -> 2009;
2021 -> 2017;
2021 -> 2009;
2022 -> 2017;
2022 -> 2009;
2023 -> 2017;
2023 -> 2009;
2024 -> 2017;
2024 -> 2009;
2025 -> 2011;
2025 -> 2010;
2025 -> 2009;
2026 -> 2009;
2027 -> 2010;
2027 -> 2017;
2027 -> 2009;
2028 -> 2011;
2028 -> 2017;
2028 -> 2009;
2029 -> 2012;
2029 -> 2017;
2029 -> 2009;
2030 -> 2013;
2030 -> 2017;
2030 -> 2009;
2031 -> 2014;
2031 -> 2017;
2031 -> 2009;
2032 -> 2015;
2032 -> 2017;
2032 -> 2009;
2033 -> 2016;
2033 -> 2017;
2033 -> 2009;
2034 -> 2017;
2034 -> 2033;
2034 -> 0;
2034 -> 2009;
2035 -> 2009;
2036 -> 2015;
2036 -> 2009;
2037 -> 2017;
2037 -> 2033;
2037 -> 0;
2037 -> 2036;
2038 -> 2037;
2038 -> 2017;
2038 -> 2036;
2039 -> 2009;
2041 -> 2040;
2043 -> 2042;
2045 -> 2044;
2047 -> 2046;
2049 -> 2048;
2051 -> 2050;
2052 -> 0;
2054 -> 2041;
2054 -> 2053;
2055 -> 2043;
2055 -> 2053;
2056 -> 2045;
2056 -> 2053;
2057 -> 2047;
2057 -> 2053;
2058 -> 2049;
2058 -> 2053;
2059 -> 2051;
2059 -> 2053;
2060 -> 2052;
2060 -> 2053;
2061 -> 2053;
2062 -> 2061;
2062 -> 2053;
2063 -> 2061;
2063 -> 2053;
2064 -> 2061;
2064 -> 2053;
2065 -> 2061;
2065 -> 2053;
2066 -> 2061;
2066 -> 2053;
2067 -> 2061;
2067 -> 2053;
2068 -> 2061;
2068 -> 2053;
2069 -> 2055;
2069 -> 2054;
2069 -> 2053;
2070 -> 2053;
2071 -> 2054;
2071 -> 2061;
2071 -> 2053;
2072 -> 2055;
2072 -> 2061;
2072 -> 2053;
2073 -> 2056;
2073 -> 2061;
2073 -> 2053;
2074 -> 2057;
2074 -> 2061;
2074 -> 2053;
2075 -> 2058;
2075 -> 2061;
2075 -> 2053;
2076 -> 2059;
2076 -> 2061;
2076 -> 2053;
2077 -> 2060;
2077 -> 2061;
2077 -> 2053;
2078 -> 2061;
2078 -> 2077;
2078 -> 0;
2078 -> 2053;
2079 -> 2053;
2080 -> 2059;
2080 -> 2053;
2081 -> 2053;
2083 -> 2082;
2085 -> 2084;
2087 -> 2086;
2089 -> 2088;
2091 -> 2090;
2093 -> 2092;
2094 -> 0;
2096 -> 2083;
2096 -> 2095;
2097 -> 2085;
2097 -> 2095;
2098 -> 2087;
2098 -> 2095;
2099 -> 2089;
2099 -> 2095;
2100 -> 2091;
2100 -> 2095;
2101 -> 2093;
2101 -> 2095;
2102 -> 2094;
2102 -> 2095;
2103 -> 2095;
2104 -> 2103;
2104 -> 2095;
2105 -> 2103;
2105 -> 2095;
2106 -> 2103;
2106 -> 2095;
2107 -> 2103;
2107 -> 2095;
2108 -> 2103;
2108 -> 2095;
2109 -> 2103;
2109 -> 2095;
2110 -> 2103;
2110 -> 2095;
2111 -> 2097;
2111 -> 2096;
2111 -> 2095;
2112 -> 2095;
2113 -> 2096;
2113 -> 2103;
2113 -> 2095;
2114 -> 2097;
2114 -> 2103;
2114 -> 2095;
2115 -> 2098;
2115 -> 2103;
2115 -> 2095;
2116 -> 2099;
2116 -> 2103;
2116 -> 2095;
2117 -> 2100;
2117 -> 2103;
2117 -> 2095;
2118 -> 2101;
2118 -> 2103;
2118 -> 2095;
2119 -> 2102;
2119 -> 2103;
2119 -> 2095;
2120 -> 2103;
2120 -> 2119;
2120 -> 0;
2120 -> 2095;
2121 -> 2095;
2122 -> 2101;
2122 -> 2095;
2123 -> 2095;
2125 -> 2124;
2127 -> 2126;
2129 -> 2128;
2131 -> 2130;
2133 -> 2132;
2135 -> 2134;
2136 -> 0;
2138 -> 2125;
2138 -> 2137;
2139 -> 2127;
2139 -> 2137;
2140 -> 2129;
2140 -> 2137;
2141 -> 2131;
2141 -> 2137;
2142 -> 2133;
2142 -> 2137;
2143 -> 2135;
2143 -> 2137;
2144 -> 2136;
2144 -> 2137;
2145 -> 2137;
2146 -> 2145;
2146 -> 2137;
2147 -> 2145;
2147 -> 2137;
2148 -> 2145;
2148 -> 2137;
2149 -> 2145;
2149 -> 2137;
2150 -> 2145;
2150 -> 2137;
2151 -> 2145;
2151 -> 2137;
2152 -> 2145;
2152 -> 2137;
2153 -> 2139;
2153 -> 2137;
2154 -> 2137;
2155 -> 2138;
2155 -> 2145;
2155 -> 2137;
2156 -> 2139;
2156 -> 2145;
2156 -> 2137;
2157 -> 2140;
2157 -> 2145;
2157 -> 2137;
2158 -> 2141;
2158 -> 2145;
2158 -> 2137;
2159 -> 2142;
2159 -> 2145;
2159 -> 2137;
2160 -> 2143;
2160 -> 2145;
2160 -> 2137;
2161 -> 2144;
2161 -> 2145;
2161 -> 2137;
2162 -> 2145;
2162 -> 2161;
2162 -> 0;
2162 -> 2137;
2163 -> 2137;
2164 -> 2143;
2164 -> 2137;
2165 -> 2137;
2167 -> 2166;
2169 -> 2168;
2171 -> 2170;
2173 -> 2172;
2175 -> 2174;
2177 -> 2176;
2178 -> 0;
2179 -> 2178;
2181 -> 2167;
2181 -> 2180;
2182 -> 2169;
2182 -> 2180;
2183 -> 2171;
2183 -> 2180;
2184 -> 2173;
2184 -> 2180;
2185 -> 2175;
2185 -> 2180;
2186 -> 2177;
2186 -> 2180;
2187 -> 2179;
2187 -> 2180;
2188 -> 2180;
2189 -> 2188;
2189 -> 2180;
2190 -> 2188;
2190 -> 2180;
2191 -> 2188;
2191 -> 2180;
2192 -> 2188;
2192 -> 2180;
2193 -> 2188;
2193 -> 2180;
2194 -> 2188;
2194 -> 2180;
2195 -> 2188;
2195 -> 2180;
2196 -> 2182;
2196 -> 2180;
2197 -> 2180;
2198 -> 2181;
2198 -> 2188;
2198 -> 2180;
2199 -> 2182;
2199 -> 2188;
2199 -> 2180;
2200 -> 2183;
2200 -> 2188;
2200 -> 2180;
2201 -> 2184;
2201 -> 2188;
2201 -> 2180;
2202 -> 2185;
2202 -> 2188;
2202 -> 2180;
2203 -> 2186;
2203 -> 2188;
2203 -> 2180;
2204 -> 2187;
2204 -> 2188;
2204 -> 2180;
2205 -> 2188;
2205 -> 2204;
2205 -> 0;
2205 -> 2180;
2206 -> 2180;
2207 -> 2186;
2207 -> 2180;
2208 -> 2188;
2208 -> 2204;
2208 -> 0;
2208 -> 2207;
2209 -> 2208;
2209 -> 2188;
2209 -> 2207;
2210 -> 2180;
2212 -> 2211;
2214 -> 2213;
2216 -> 2215;
2218 -> 2217;
2220 -> 2219;
2222 -> 2221;
2223 -> 0;
2225 -> 2212;
2225 -> 2224;
2226 -> 2214;
2226 -> 2224;
2227 -> 2216;
2227 -> 2224;
2228 -> 2218;
2228 -> 2224;
2229 -> 2220;
2229 -> 2224;
2230 -> 2222;
2230 -> 2224;
2231 -> 2223;
2231 -> 2224;
2232 -> 2224;
2233 -> 2232;
2233 -> 2224;
2234 -> 2232;
2234 -> 2224;
2235 -> 2232;
2235 -> 2224;
2236 -> 2232;
2236 -> 2224;
2237 -> 2232;
2237 -> 2224;
2238 -> 2232;
2238 -> 2224;
2239 -> 2232;
2239 -> 2224;
2240 -> 2226;
2240 -> 2224;
2241 -> 2224;
2242 -> 2225;
2242 -> 2232;
2242 -> 2224;
2243 -> 2226;
2243 -> 2232;
2243 -> 2224;
2244 -> 2227;
2244 -> 2232;
2244 -> 2224;
2245 -> 2228;
2245 -> 2232;
2245 -> 2224;
2246 -> 2229;
2246 -> 2232;
2246 -> 2224;
2247 -> 2230;
2247 -> 2232;
2247 -> 2224;
2248 -> 2231;
2248 -> 2232;
2248 -> 2224;
2249 -> 2232;
2249 -> 2248;
2249 -> 0;
2249 -> 2224;
2250 -> 2224;
2251 -> 2230;
2251 -> 2224;
2252 -> 2232;
2252 -> 2248;
2252 -> 0;
2252 -> 2251;
2253 -> 2252;
2253 -> 2232;
2253 -> 2251;
2254 -> 2224;
2256 -> 2255;
2258 -> 2257;
2260 -> 2259;
2262 -> 2261;
2264 -> 2263;
2266 -> 2265;
2267 -> 0;
2269 -> 2256;
2269 -> 2268;
2270 -> 2258;
2270 -> 2268;
2271 -> 2260;
2271 -> 2268;
2272 -> 2262;
2272 -> 2268;
2273 -> 2264;
2273 -> 2268;
2274 -> 2266;
2274 -> 2268;
2275 -> 2267;
2275 -> 2268;
2276 -> 2268;
2277 -> 2276;
2277 -> 2268;
2278 -> 2276;
2278 -> 2268;
2279 -> 2276;
2279 -> 2268;
2280 -> 2276;
2280 -> 2268;
2281 -> 2276;
2281 -> 2268;
2282 -> 2276;
2282 -> 2268;
2283 -> 2276;
2283 -> 2268;
2284 -> 2270;
2284 -> 2268;
2285 -> 2268;
2286 -> 2269;
2286 -> 2276;
2286 -> 2268;
2287 -> 2270;
2287 -> 2276;
2287 -> 2268;
2288 -> 2271;
2288 -> 2276;
2288 -> 2268;
2289 -> 2272;
2289 -> 2276;
2289 -> 2268;
2290 -> 2273;
2290 -> 2276;
2290 -> 2268;
2291 -> 2274;
2291 -> 2276;
2291 -> 2268;
2292 -> 2275;
2292 -> 2276;
2292 -> 2268;
2293 -> 2276;
2293 -> 2292;
2293 -> 0;
2293 -> 2268;
2294 -> 2268;
2295 -> 2274;
2295 -> 2268;
2296 -> 2268;
2298 -> 2297;
2300 -> 2299;
2302 -> 2301;
2304 -> 2303;
2306 -> 2305;
2308 -> 2307;
2309 -> 0;
2310 -> 2309;
2310 -> 0;
2311 -> 2310;
2313 -> 2298;
2313 -> 2312;
2314 -> 2300;
2314 -> 2312;
2315 -> 2302;
2315 -> 2312;
2316 -> 2304;
2316 -> 2312;
2317 -> 2306;
2317 -> 2312;
2318 -> 2308;
2318 -> 2312;
2319 -> 2311;
2319 -> 2312;
2320 -> 2312;
2321 -> 2320;
2321 -> 2312;
2322 -> 2320;
2322 -> 2312;
2323 -> 2320;
2323 -> 2312;
2324 -> 2320;
2324 -> 2312;
2325 -> 2320;
2325 -> 2312;
2326 -> 2320;
2326 -> 2312;
2327 -> 2320;
2327 -> 2312;
2328 -> 2314;
2328 -> 2312;
2329 -> 2312;
2330 -> 2313;
2330 -> 2320;
2330 -> 2312;
2331 -> 2314;
2331 -> 2320;
2331 -> 2312;
2332 -> 2315;
2332 -> 2320;
2332 -> 2312;
2333 -> 2316;
2333 -> 2320;
2333 -> 2312;
2334 -> 2317;
2334 -> 2320;
2334 -> 2312;
2335 -> 2318;
2335 -> 2320;
2335 -> 2312;
2336 -> 2319;
2336 -> 2320;
2336 -> 2312;
2337 -> 2320;
2337 -> 2336;
2337 -> 0;
2337 -> 2312;
2338 -> 2312;
2339 -> 2318;
2339 -> 2312;
2340 -> 2312;
2342 -> 2341;
2344 -> 2343;
2346 -> 2345;
2348 -> 2347;
2350 -> 2349;
2352 -> 2351;
2353 -> 0;
2354 -> 2353;
2354 -> 0;
2355 -> 2354;
2357 -> 2342;
2357 -> 2356;
2358 -> 2344;
2358 -> 2356;
2359 -> 2346;
2359 -> 2356;
2360 -> 2348;
2360 -> 2356;
2361 -> 2350;
2361 -> 2356;
2362 -> 2352;
2362 -> 2356;
2363 -> 2355;
2363 -> 2356;
2364 -> 2356;
2365 -> 2364;
2365 -> 2356;
2366 -> 2364;
2366 -> 2356;
2367 -> 2364;
2367 -> 2356;
2368 -> 2364;
2368 -> 2356;
2369 -> 2364;
2369 -> 2356;
2370 -> 2364;
2370 -> 2356;
2371 -> 2364;
2371 -> 2356;
2372 -> 2358;
2372 -> 2356;
2373 -> 2356;
2374 -> 2357;
2374 -> 2364;
2374 -> 2356;
2375 -> 2358;
2375 -> 2364;
2375 -> 2356;
2376 -> 2359;
2376 -> 2364;
2376 -> 2356;
2377 -> 2360;
2377 -> 2364;
2377 -> 2356;
2378 -> 2361;
2378 -> 2364;
2378 -> 2356;
2379 -> 2362;
2379 -> 2364;
2379 -> 2356;
2380 -> 2363;
2380 -> 2364;
2380 -> 2356;
2381 -> 2364;
2381 -> 2380;
2381 -> 0;
2381 -> 2356;
2382 -> 2356;
2383 -> 2362;
2383 -> 2356;
2384 -> 2364;
2384 -> 2380;
2384 -> 0;
2384 -> 2383;
2385 -> 2384;
2385 -> 2364;
2385 -> 2383;
2386 -> 2356;
2388 -> 2387;
2390 -> 2389;
2392 -> 2391;
2394 -> 2393;
2396 -> 2395;
2398 -> 2397;
2399 -> 0;
2400 -> 2399;
2400 -> 0;
2401 -> 2400;
2403 -> 2388;
2403 -> 2402;
2404 -> 2390;
2404 -> 2402;
2405 -> 2392;
2405 -> 2402;
2406 -> 2394;
2406 -> 2402;
2407 -> 2396;
2407 -> 2402;
2408 -> 2398;
2408 -> 2402;
2409 -> 2401;
2409 -> 2402;
2410 -> 2402;
2411 -> 2410;
2411 -> 2402;
2412 -> 2410;
2412 -> 2402;
2413 -> 2410;
2413 -> 2402;
2414 -> 2410;
2414 -> 2402;
2415 -> 2410;
2415 -> 2402;
2416 -> 2410;
2416 -> 2402;
2417 -> 2410;
2417 -> 2402;
2418 -> 2404;
2418 -> 2402;
2419 -> 2402;
2420 -> 2403;
2420 -> 2410;
2420 -> 2402;
2421 -> 2404;
2421 -> 2410;
2421 -> 2402;
2422 -> 2405;
2422 -> 2410;
2422 -> 2402;
2423 -> 2406;
2423 -> 2410;
2423 -> 2402;
2424 -> 2407;
2424 -> 2410;
2424 -> 2402;
2425 -> 2408;
2425 -> 2410;
2425 -> 2402;
2426 -> 2409;
2426 -> 2410;
2426 -> 2402;
2427 -> 2410;
2427 -> 2426;
2427 -> 0;
2427 -> 2402;
2428 -> 2402;
2429 -> 2408;
2429 -> 2402;
2430 -> 2410;
2430 -> 2426;
2430 -> 0;
2430 -> 2429;
2431 -> 2430;
2431 -> 2410;
2431 -> 2429;
2432 -> 2402;
2434 -> 2433;
2436 -> 2435;
2438 -> 2437;
2440 -> 2439;
2442 -> 2441;
2444 -> 2443;
2445 -> 0;
2446 -> 2445;
2446 -> 0;
2447 -> 2446;
2449 -> 2434;
2449 -> 2448;
2450 -> 2436;
2450 -> 2448;
2451 -> 2438;
2451 -> 2448;
2452 -> 2440;
2452 -> 2448;
2453 -> 2442;
2453 -> 2448;
2454 -> 2444;
2454 -> 2448;
2455 -> 2447;
2455 -> 2448;
2456 -> 2448;
2457 -> 2456;
2457 -> 2448;
2458 -> 2456;
2458 -> 2448;
2459 -> 2456;
2459 -> 2448;
2460 -> 2456;
2460 -> 2448;
2461 -> 2456;
2461 -> 2448;
2462 -> 2456;
2462 -> 2448;
2463 -> 2456;
2463 -> 2448;
2464 -> 2450;
2464 -> 2448;
2465 -> 2448;
2466 -> 2449;
2466 -> 2456;
2466 -> 2448;
2467 -> 2450;
2467 -> 2456;
2467 -> 2448;
2468 -> 2451;
2468 -> 2456;
2468 -> 2448;
2469 -> 2452;
2469 -> 2456;
2469 -> 2448;
2470 -> 2453;
2470 -> 2456;
2470 -> 2448;
2471 -> 2454;
2471 -> 2456;
2471 -> 2448;
2472 -> 2455;
2472 -> 2456;
2472 -> 2448;
2473 -> 2456;
2473 -> 2472;
2473 -> 0;
2473 -> 2448;
2474 -> 2448;
2475 -> 2454;
2475 -> 2448;
2476 -> 2448;
2478 -> 2477;
2480 -> 2479;
2482 -> 2481;
2484 -> 2483;
2486 -> 2485;
2488 -> 2487;
2489 -> 0;
2490 -> 2489;
2490 -> 0;
2491 -> 2490;
2493 -> 2478;
2493 -> 2492;
2494 -> 2480;
2494 -> 2492;
2495 -> 2482;
2495 -> 2492;
2496 -> 2484;
2496 -> 2492;
2497 -> 2486;
2497 -> 2492;
2498 -> 2488;
2498 -> 2492;
2499 -> 2491;
2499 -> 2492;
2500 -> 2492;
2501 -> 2500;
2501 -> 2492;
2502 -> 2500;
2502 -> 2492;
2503 -> 2500;
2503 -> 2492;
2504 -> 2500;
2504 -> 2492;
2505 -> 2500;
2505 -> 2492;
2506 -> 2500;
2506 -> 2492;
2507 -> 2500;
2507 -> 2492;
2508 -> 2494;
2508 -> 2493;
2508 -> 2492;
2509 -> 2492;
2510 -> 2493;
2510 -> 2500;
2510 -> 2492;
2511 -> 2494;
2511 -> 2500;
2511 -> 2492;
2512 -> 2495;
2512 -> 2500;
2512 -> 2492;
2513 -> 2496;
2513 -> 2500;
2513 -> 2492;
2514 -> 2497;
2514 -> 2500;
2514 -> 2492;
2515 -> 2498;
2515 -> 2500;
2515 -> 2492;
2516 -> 2499;
2516 -> 2500;
2516 -> 2492;
2517 -> 2500;
2517 -> 2516;
2517 -> 0;
2517 -> 2492;
2518 -> 2492;
2519 -> 2498;
2519 -> 2492;
2520 -> 2500;
2520 -> 2516;
2520 -> 0;
2520 -> 2519;
2521 -> 2520;
2521 -> 2500;
2521 -> 2519;
2522 -> 2492;
2524 -> 2523;
2526 -> 2525;
2528 -> 2527;
2530 -> 2529;
2532 -> 2531;
2534 -> 2533;
2535 -> 0;
2536 -> 2535;
2536 -> 0;
2537 -> 2536;
2539 -> 2524;
2539 -> 2538;
2540 -> 2526;
2540 -> 2538;
2541 -> 2528;
2541 -> 2538;
2542 -> 2530;
2542 -> 2538;
2543 -> 2532;
2543 -> 2538;
2544 -> 2534;
2544 -> 2538;
2545 -> 2537;
2545 -> 2538;
2546 -> 2538;
2547 -> 2546;
2547 -> 2538;
2548 -> 2546;
2548 -> 2538;
2549 -> 2546;
2549 -> 2538;
2550 -> 2546;
2550 -> 2538;
2551 -> 2546;
2551 -> 2538;
2552 -> 2546;
2552 -> 2538;
2553 -> 2546;
2553 -> 2538;
2554 -> 2540;
2554 -> 2539;
2554 -> 2538;
2555 -> 2538;
2556 -> 2539;
2556 -> 2546;
2556 -> 2538;
2557 -> 2540;
2557 -> 2546;
2557 -> 2538;
2558 -> 2541;
2558 -> 2546;
2558 -> 2538;
2559 -> 2542;
2559 -> 2546;
2559 -> 2538;
2560 -> 2543;
2560 -> 2546;
2560 -> 2538;
2561 -> 2544;
2561 -> 2546;
2561 -> 2538;
2562 -> 2545;
2562 -> 2546;
2562 -> 2538;
2563 -> 2546;
2563 -> 2562;
2563 -> 0;
2563 -> 2538;
2564 -> 2538;
2565 -> 2544;
2565 -> 2538;
2566 -> 2538;
2568 -> 2567;
2570 -> 2569;
2572 -> 2571;
2574 -> 2573;
2576 -> 2575;
2578 -> 2577;
2579 -> 0;
2580 -> 2579;
2580 -> 0;
2581 -> 2580;
2583 -> 2568;
2583 -> 2582;
2584 -> 2570;
2584 -> 2582;
2585 -> 2572;
2585 -> 2582;
2586 -> 2574;
2586 -> 2582;
2587 -> 2576;
2587 -> 2582;
2588 -> 2578;
2588 -> 2582;
2589 -> 2581;
2589 -> 2582;
2590 -> 2582;
2591 -> 2590;
2591 -> 2582;
2592 -> 2590;
2592 -> 2582;
2593 -> 2590;
2593 -> 2582;
2594 -> 2590;
2594 -> 2582;
2595 -> 2590;
2595 -> 2582;
2596 -> 2590;
2596 -> 2582;
2597 -> 2590;
2597 -> 2582;
2598 -> 2584;
2598 -> 2582;
2599 -> 2582;
2600 -> 2583;
2600 -> 2590;
2600 -> 2582;
2601 -> 2584;
2601 -> 2590;
2601 -> 2582;
2602 -> 2585;
2602 -> 2590;
2602 -> 2582;
2603 -> 2586;
2603 -> 2590;
2603 -> 2582;
2604 -> 2587;
2604 -> 2590;
2604 -> 2582;
2605 -> 2588;
2605 -> 2590;
2605 -> 2582;
2606 -> 2589;
2606 -> 2590;
2606 -> 2582;
2607 -> 2590;
2607 -> 2606;
2607 -> 0;
2607 -> 2582;
2608 -> 2582;
2609 -> 2588;
2609 -> 2582;
2610 -> 2582;
2612 -> 2611;
2614 -> 2613;
2616 -> 2615;
2618 -> 2617;
2620 -> 2619;
2622 -> 2621;
2623 -> 0;
2624 -> 2623;
2624 -> 0;
2625 -> 2624;
2627 -> 2612;
2627 -> 2626;
2628 -> 2614;
2628 -> 2626;
2629 -> 2616;
2629 -> 2626;
2630 -> 2618;
2630 -> 2626;
2631 -> 2620;
2631 -> 2626;
2632 -> 2622;
2632 -> 2626;
2633 -> 2625;
2633 -> 2626;
2634 -> 2626;
2635 -> 2634;
2635 -> 2626;
2636 -> 2634;
2636 -> 2626;
2637 -> 2634;
2637 -> 2626;
2638 -> 2634;
2638 -> 2626;
2639 -> 2634;
2639 -> 2626;
2640 -> 2634;
2640 -> 2626;
2641 -> 2634;
2641 -> 2626;
2642 -> 2628;
2642 -> 2626;
2643 -> 2626;
2644 -> 2627;
2644 -> 2634;
2644 -> 2626;
2645 -> 2628;
2645 -> 2634;
2645 -> 2626;
2646 -> 2629;
2646 -> 2634;
2646 -> 2626;
2647 -> 2630;
2647 -> 2634;
2647 -> 2626;
2648 -> 2631;
2648 -> 2634;
2648 -> 2626;
2649 -> 2632;
2649 -> 2634;
2649 -> 2626;
2650 -> 2633;
2650 -> 2634;
2650 -> 2626;
2651 -> 2634;
2651 -> 2650;
2651 -> 0;
2651 -> 2626;
2652 -> 2626;
2653 -> 2632;
2653 -> 2626;
2654 -> 2626;
2655 -> 2081;
2656 -> 2655;
2656 -> 2071;
2656 -> 2072;
2656 -> 2073;
2656 -> 2074;
2656 -> 2075;
2656 -> 2076;
2656 -> 2077;
2657 -> 2656;
2658 -> 0;
2659 -> 2658;
2660 -> 2659;
2661 -> 0;
2662 -> 2661;
2663 -> 0;
2664 -> 2663;
2665 -> 1865;
2665 -> 1864;
2666 -> 1866;
2666 -> 1864;
2667 -> 1867;
2667 -> 1864;
2668 -> 1868;
2668 -> 1864;
2669 -> 1864;
2670 -> 2665;
2670 -> 2669;
2671 -> 2666;
2671 -> 2669;
2672 -> 2667;
2672 -> 2669;
2673 -> 2668;
2673 -> 2669;
2674 -> 1869;
2674 -> 2669;
2676 -> 2675;
2678 -> 2677;
2680 -> 2679;
2682 -> 2681;
2684 -> 2682;
2684 -> 2683;
2685 -> 2684;
2687 -> 2686;
2689 -> 2688;
2691 -> 2690;
2693 -> 2692;
2703 -> 2695;
2703 -> 2694;
2704 -> 2696;
2704 -> 2694;
2705 -> 2697;
2705 -> 2694;
2706 -> 2698;
2706 -> 2694;
2707 -> 2699;
2707 -> 2694;
2708 -> 2700;
2708 -> 2694;
2709 -> 2701;
2709 -> 2694;
2710 -> 2702;
2710 -> 2694;
2711 -> 2694;
2712 -> 2673;
2712 -> 2669;
2713 -> 2669;
2714 -> 2712;
2714 -> 2713;
2715 -> 2674;
2715 -> 2713;
2717 -> 2716;
2719 -> 0;
2721 -> 2719;
2721 -> 2720;
2722 -> 2720;
2723 -> 2722;
2723 -> 2720;
2724 -> 2721;
2724 -> 2722;
2724 -> 2720;
2725 -> 2720;
2726 -> 0;
2728 -> 2726;
2728 -> 2727;
2729 -> 2727;
2730 -> 2729;
2730 -> 2727;
2731 -> 2728;
2731 -> 2729;
2731 -> 2727;
2732 -> 2727;
2733 -> 0;
2735 -> 2733;
2735 -> 2734;
2736 -> 2734;
2737 -> 2736;
2737 -> 2734;
2738 -> 2735;
2738 -> 2736;
2738 -> 2734;
2739 -> 2734;
2740 -> 0;
2742 -> 2740;
2742 -> 2741;
2743 -> 2741;
2744 -> 2743;
2744 -> 2741;
2745 -> 2742;
2745 -> 2743;
2745 -> 2741;
2746 -> 2741;
2747 -> 0;
2749 -> 2747;
2749 -> 2748;
2750 -> 2748;
2751 -> 2750;
2751 -> 2748;
2752 -> 2749;
2752 -> 2750;
2752 -> 2748;
2753 -> 2748;
2754 -> 0;
2756 -> 2754;
2756 -> 2755;
2757 -> 2755;
2758 -> 2757;
2758 -> 2755;
2759 -> 2756;
2759 -> 2757;
2759 -> 2755;
2760 -> 2755;
2761 -> 0;
2763 -> 2761;
2763 -> 2762;
2764 -> 2762;
2765 -> 2764;
2765 -> 2762;
2766 -> 2763;
2766 -> 2764;
2766 -> 2762;
2767 -> 2762;
2768 -> 0;
2770 -> 2768;
2770 -> 2769;
2771 -> 2769;
2772 -> 2771;
2772 -> 2769;
2773 -> 2770;
2773 -> 2771;
2773 -> 2769;
2774 -> 2769;
2775 -> 2774;
2777 -> 2718;
2777 -> 2775;
2777 -> 2776;
2777 -> 2771;
2777 -> 2772;
2777 -> 2773;
2778 -> 2777;
2780 -> 2779;
2781 -> 2780;
2781 -> 2779;
2782 -> 2780;
2782 -> 2779;
2783 -> 2780;
2783 -> 2779;
2784 -> 2779;
2786 -> 2785;
2787 -> 2713;
2788 -> 2715;
2788 -> 2787;
2789 -> 2787;
2790 -> 2788;
2790 -> 2787;
2791 -> 2788;
2791 -> 2787;
2792 -> 2715;
2792 -> 2713;
2793 -> 2715;
2793 -> 2713;
2794 -> 2715;
2794 -> 2713;
2795 -> 2714;
2795 -> 2715;
2795 -> 2713;
2796 -> 2674;
2796 -> 2669;
2797 -> 2674;
2797 -> 2669;
2798 -> 2674;
2798 -> 2669;
2800 -> 2799;
2801 -> 2800;
2801 -> 2799;
2802 -> 2800;
2802 -> 2799;
2803 -> 2800;
2803 -> 2799;
2804 -> 2800;
2804 -> 2799;
2805 -> 2800;
2805 -> 2799;
2806 -> 2800;
2806 -> 2799;
2807 -> 2799;
2808 -> 2807;
2808 -> 2674;
2808 -> 2669;
2809 -> 2674;
2809 -> 2669;
2810 -> 2674;
2810 -> 2669;
2811 -> 2674;
2811 -> 2669;
2812 -> 2674;
2812 -> 2669;
2813 -> 2674;
2813 -> 2669;
2814 -> 1797;
2814 -> 2674;
2814 -> 2669;
2815 -> 2674;
2815 -> 2669;
2816 -> 2674;
2816 -> 2669;
2817 -> 2670;
2817 -> 2674;
2817 -> 2669;
2818 -> 2671;
2818 -> 2674;
2818 -> 2669;
2819 -> 2671;
2819 -> 1851;
2819 -> 2669;
2820 -> 2669;
2821 -> 2819;
2821 -> 2820;
2822 -> 2821;
2822 -> 2820;
2823 -> 0;
2823 -> 2822;
2824 -> 2823;
2824 -> 2669;
2825 -> 2672;
2825 -> 2669;
2826 -> 2669;
2827 -> 2824;
2827 -> 2826;
2828 -> 2825;
2828 -> 2826;
2829 -> 2674;
2829 -> 2826;
2830 -> 2826;
2831 -> 2829;
2831 -> 2830;
2832 -> 2831;
2832 -> 2817;
2832 -> 2830;
2833 -> 2832;
2833 -> 2826;
2834 -> 2826;
2835 -> 0;
2835 -> 2826;
2836 -> 2826;
2837 -> 2833;
2837 -> 2836;
2838 -> 0;
2838 -> 2836;
2839 -> 2838;
2839 -> 2826;
2840 -> 0;
2840 -> 2839;
2841 -> 2827;
2841 -> 2826;
2842 -> 0;
2842 -> 2841;
2843 -> 2835;
2843 -> 2842;
2843 -> 2841;
2844 -> 2841;
2845 -> 2829;
2845 -> 2844;
2846 -> 2844;
2847 -> 2845;
2847 -> 2818;
2847 -> 1851;
2847 -> 2846;
2847 -> 2844;
2848 -> 2847;
2848 -> 2841;
2849 -> 2843;
2849 -> 0;
2849 -> 2848;
2850 -> 2826;
2851 -> 2840;
2851 -> 2826;
2852 -> 2849;
2852 -> 2826;
2853 -> 2828;
2853 -> 2826;
2854 -> 2850;
2854 -> 2826;
2855 -> 2826;
2856 -> 2851;
2856 -> 2855;
2857 -> 2852;
2857 -> 2855;
2858 -> 2853;
2858 -> 2855;
2859 -> 2854;
2859 -> 2855;
2860 -> 2829;
2860 -> 2855;
2861 -> 2855;
2862 -> 0;
2862 -> 2855;
2863 -> 2860;
2863 -> 2818;
2863 -> 2847;
2863 -> 2855;
2864 -> 2855;
2865 -> 2855;
2866 -> 2865;
2866 -> 2863;
2866 -> 2855;
2867 -> 2860;
2867 -> 2818;
2867 -> 2847;
2867 -> 2865;
2867 -> 2866;
2868 -> 2867;
2868 -> 2866;
2869 -> 2866;
2870 -> 2861;
2870 -> 2866;
2871 -> 2868;
2871 -> 2870;
2872 -> 2857;
2872 -> 2870;
2873 -> 2860;
2873 -> 2818;
2873 -> 2867;
2873 -> 2865;
2873 -> 2870;
2874 -> 2858;
2874 -> 2870;
2875 -> 2870;
2876 -> 2861;
2876 -> 2870;
2877 -> 2870;
2878 -> 2871;
2878 -> 2877;
2879 -> 2872;
2879 -> 2877;
2880 -> 2873;
2880 -> 2877;
2881 -> 2874;
2881 -> 2877;
2882 -> 2875;
2882 -> 2877;
2883 -> 2876;
2883 -> 2877;
2884 -> 2877;
2885 -> 2878;
2885 -> 2879;
2885 -> 2877;
2886 -> 2878;
2886 -> 2879;
2886 -> 2877;
2887 -> 2885;
2887 -> 0;
2887 -> 2877;
2888 -> 2886;
2888 -> 0;
2888 -> 2877;
2889 -> 2877;
2890 -> 2886;
2890 -> 2877;
2891 -> 2884;
2891 -> 2870;
2892 -> 2890;
2892 -> 2891;
2893 -> 2860;
2893 -> 2891;
2894 -> 2891;
2895 -> 2891;
2896 -> 2892;
2896 -> 2895;
2897 -> 2893;
2897 -> 2895;
2898 -> 2894;
2898 -> 2895;
2899 -> 2896;
2899 -> 2895;
2900 -> 2895;
2901 -> 2899;
2901 -> 2900;
2902 -> 2901;
2902 -> 0;
2902 -> 2900;
2903 -> 2902;
2904 -> 2895;
2905 -> 2897;
2905 -> 2904;
2906 -> 0;
2906 -> 2904;
2907 -> 2906;
2907 -> 2895;
2908 -> 2898;
2908 -> 2907;
2908 -> 2895;
2909 -> 2896;
2909 -> 0;
2909 -> 2895;
2910 -> 2895;
2911 -> 2908;
2911 -> 2909;
2911 -> 2895;
2912 -> 2896;
2912 -> 0;
2912 -> 2911;
2913 -> 2895;
2914 -> 2913;
2914 -> 2891;
2915 -> 2891;
2916 -> 2914;
2916 -> 2915;
2916 -> 2891;
2917 -> 2862;
2917 -> 0;
2917 -> 2866;
2918 -> 2890;
2918 -> 2917;
2919 -> 2918;
2919 -> 0;
2919 -> 2855;
2920 -> 2855;
2921 -> 2864;
2921 -> 2855;
2922 -> 2855;
2923 -> 2860;
2923 -> 2922;
2924 -> 2923;
2924 -> 2818;
2924 -> 2873;
2924 -> 2922;
2925 -> 2924;
2925 -> 2855;
2926 -> 0;
2926 -> 2855;
2927 -> 2918;
2927 -> 2855;
2929 -> 2928;
2930 -> 2829;
2930 -> 2826;
2931 -> 2927;
2931 -> 2826;
2932 -> 2828;
2932 -> 2826;
2933 -> 2826;
2934 -> 2930;
2934 -> 2933;
2935 -> 2931;
2935 -> 2933;
2936 -> 2932;
2936 -> 2933;
2937 -> 2934;
2937 -> 2933;
2938 -> 2935;
2938 -> 2933;
2939 -> 2933;
2940 -> 2934;
2940 -> 2939;
2941 -> 2940;
2941 -> 2818;
2941 -> 2873;
2941 -> 2939;
2942 -> 2941;
2942 -> 2933;
2943 -> 2933;
2944 -> 2936;
2944 -> 2933;
2945 -> 2933;
2946 -> 2937;
2946 -> 2945;
2947 -> 2938;
2947 -> 2945;
2948 -> 2942;
2948 -> 2945;
2949 -> 2944;
2949 -> 2945;
2950 -> 2947;
2950 -> 0;
2950 -> 2945;
2951 -> 2826;
2952 -> 2927;
2952 -> 0;
2952 -> 2826;
2953 -> 2826;
2954 -> 2884;
2954 -> 2952;
2954 -> 2826;
2955 -> 0;
2955 -> 2826;
2956 -> 2927;
2956 -> 2955;
2956 -> 2826;
2957 -> 2884;
2957 -> 2956;
2957 -> 2826;
2958 -> 2827;
2958 -> 2826;
2959 -> 2927;
2959 -> 2826;
2960 -> 2671;
2960 -> 2942;
2960 -> 2669;
2961 -> 2960;
2961 -> 2942;
2962 -> 2672;
2962 -> 2961;
2962 -> 1839;
2962 -> 2942;
2962 -> 2960;
2963 -> 2959;
2963 -> 0;
2963 -> 2669;
2964 -> 2669;
2965 -> 2963;
2965 -> 2964;
2965 -> 2669;
2966 -> 2959;
2966 -> 2674;
2966 -> 2669;
2967 -> 2963;
2967 -> 0;
2967 -> 2669;
2968 -> 2967;
2968 -> 2669;
2969 -> 2968;
2970 -> 2674;
2970 -> 2969;
2971 -> 2969;
2972 -> 2970;
2972 -> 2971;
2973 -> 2972;
2973 -> 2817;
2973 -> 2971;
2974 -> 2973;
2974 -> 2969;
2975 -> 2969;
2976 -> 2974;
2976 -> 2975;
2977 -> 0;
2977 -> 2975;
2978 -> 2977;
2978 -> 2969;
2979 -> 2969;
2980 -> 2970;
2980 -> 2979;
2981 -> 2980;
2981 -> 2817;
2981 -> 2979;
2982 -> 2981;
2982 -> 2969;
2983 -> 2969;
2984 -> 2982;
2984 -> 2983;
2985 -> 2983;
2986 -> 2984;
2986 -> 2962;
2986 -> 2985;
2987 -> 2986;
2987 -> 2962;
2987 -> 2985;
2988 -> 2969;
2989 -> 2987;
2989 -> 2988;
2990 -> 2988;
2991 -> 2989;
2991 -> 2990;
2992 -> 2991;
2992 -> 2988;
2993 -> 2989;
2993 -> 2988;
2994 -> 2978;
2994 -> 2992;
2994 -> 2969;
2995 -> 0;
2995 -> 2994;
2997 -> 2996;
2999 -> 2998;
3000 -> 2997;
3000 -> 2999;
3001 -> 3000;
3003 -> 3002;
3004 -> 3001;
3004 -> 3003;
3005 -> 3004;
3007 -> 3006;
3008 -> 3005;
3008 -> 3007;
3009 -> 3008;
3011 -> 3010;
3012 -> 3009;
3012 -> 3011;
3013 -> 3012;
3015 -> 3014;
3016 -> 3013;
3016 -> 3015;
3017 -> 3016;
3019 -> 3018;
3021 -> 3020;
3021 -> 2999;
3023 -> 3021;
3023 -> 3022;
3024 -> 3023;
3026 -> 3025;
3026 -> 3003;
3028 -> 3026;
3028 -> 3027;
3029 -> 3028;
3031 -> 3030;
3031 -> 3015;
3033 -> 3031;
3033 -> 3032;
3034 -> 3033;
3036 -> 3035;
3036 -> 3019;
3038 -> 3036;
3038 -> 3037;
3039 -> 3038;
3041 -> 3040;
3041 -> 3005;
3042 -> 3041;
3044 -> 3043;
3044 -> 3009;
3045 -> 3044;
3046 -> 3024;
3047 -> 3039;
3048 -> 2995;
3048 -> 2669;
3049 -> 2823;
3049 -> 2669;
3050 -> 2669;
3051 -> 2669;
3052 -> 3048;
3052 -> 3051;
3053 -> 3049;
3053 -> 3051;
3054 -> 3050;
3054 -> 3051;
3055 -> 3052;
3055 -> 3024;
3055 -> 3051;
3056 -> 3055;
3056 -> 2997;
3056 -> 3051;
3057 -> 3053;
3057 -> 3034;
3057 -> 3051;
3058 -> 3057;
3058 -> 3013;
3058 -> 3051;
3059 -> 3056;
3059 -> 3058;
3059 -> 3051;
3060 -> 3059;
3060 -> 3054;
3060 -> 3051;
3061 -> 3050;
3061 -> 2674;
3061 -> 2669;
3062 -> 2669;
3063 -> 2674;
3063 -> 3062;
3064 -> 3063;
3064 -> 2817;
3064 -> 3062;
3065 -> 3064;
3065 -> 2669;
3066 -> 3065;
3066 -> 2669;
3067 -> 2669;
3068 -> 0;
3068 -> 2669;
3069 -> 2669;
3070 -> 3068;
3070 -> 3069;
3071 -> 2674;
3071 -> 3069;
3072 -> 3071;
3072 -> 3069;
3073 -> 3070;
3073 -> 3069;
3074 -> 3072;
3074 -> 3073;
3074 -> 3069;
3075 -> 1869;
3075 -> 1864;
3076 -> 1869;
3076 -> 1864;
3077 -> 1869;
3077 -> 1864;
3078 -> 0;
3078 -> 1869;
3078 -> 1864;
3079 -> 1869;
3079 -> 1864;
3081 -> 3080;
3082 -> 3080;
3083 -> 3082;
3084 -> 3082;
3085 -> 3084;
3085 -> 3082;
3086 -> 3085;
3086 -> 3083;
3087 -> 3083;
3088 -> 3087;
3089 -> 3088;
3090 -> 3089;
3091 -> 3090;
3091 -> 3089;
3092 -> 3088;
3092 -> 3087;
3093 -> 3088;
3093 -> 3087;
3094 -> 3087;
3094 -> 3083;
3095 -> 3087;
3095 -> 3083;
3096 -> 3087;
3096 -> 3083;
3097 -> 3086;
3097 -> 3087;
3097 -> 3083;
3098 -> 3082;
3098 -> 3080;
3099 -> 3081;
3099 -> 3082;
3099 -> 3080;
3100 -> 3080;
3101 -> 3100;
3101 -> 1869;
3101 -> 1864;
3102 -> 1869;
3102 -> 1864;
3103 -> 3100;
3103 -> 1869;
3103 -> 1864;
3104 -> 1866;
3104 -> 2962;
3104 -> 1864;
3105 -> 1864;
3106 -> 1865;
3106 -> 3105;
3107 -> 0;
3107 -> 3105;
3108 -> 3107;
3108 -> 1864;
3109 -> 1852;
3110 -> 1863;
3110 -> 3109;
3111 -> 1851;
3111 -> 3109;
3112 -> 3109;
3113 -> 3110;
3113 -> 3112;
3114 -> 3113;
3114 -> 2818;
3114 -> 2962;
3114 -> 3112;
3115 -> 3114;
3115 -> 3109;
3116 -> 3109;
3117 -> 3115;
3117 -> 3109;
3118 -> 3116;
3118 -> 3109;
3119 -> 3111;
3119 -> 1851;
3119 -> 3117;
3119 -> 3118;
3119 -> 3109;
3120 -> 3110;
3120 -> 3115;
3120 -> 3111;
3120 -> 3119;
3121 -> 1842;
3122 -> 1851;
3122 -> 3121;
3123 -> 3122;
3123 -> 1851;
3123 -> 3120;
3123 -> 3119;
3123 -> 3121;
3124 -> 0;
3124 -> 3121;
3125 -> 3122;
3125 -> 1851;
3125 -> 3120;
3125 -> 3121;
3126 -> 3125;
3126 -> 3119;
3127 -> 3125;
3128 -> 3127;
3128 -> 3125;
3129 -> 3126;
3129 -> 3125;
3130 -> 3125;
3131 -> 3129;
3131 -> 3130;
3131 -> 3125;
3132 -> 3126;
3132 -> 3131;
3133 -> 3131;
3134 -> 3132;
3134 -> 3133;
3135 -> 0;
3135 -> 3133;
3136 -> 3135;
3136 -> 3131;
3137 -> 3136;
3137 -> 3131;
3138 -> 3132;
3138 -> 3137;
3139 -> 3125;
3139 -> 3119;
3140 -> 3138;
3140 -> 3125;
3141 -> 3123;
3141 -> 3139;
3141 -> 3140;
3141 -> 3125;
3142 -> 3123;
3142 -> 3121;
3143 -> 3142;
3143 -> 1842;
3144 -> 1844;
3144 -> 1842;
3145 -> 3143;
3145 -> 1842;
3146 -> 1843;
3146 -> 1842;
3147 -> 1842;
3148 -> 3144;
3148 -> 3147;
3149 -> 3145;
3149 -> 3147;
3150 -> 3146;
3150 -> 3147;
3151 -> 3147;
3152 -> 3147;
3153 -> 3147;
3154 -> 3148;
3154 -> 3153;
3155 -> 3153;
3156 -> 3154;
3156 -> 2962;
3156 -> 3155;
3157 -> 3156;
3157 -> 2962;
3157 -> 3155;
3158 -> 3157;
3158 -> 3147;
3159 -> 3147;
3160 -> 3158;
3160 -> 3159;
3161 -> 3147;
3162 -> 3149;
3162 -> 3123;
3162 -> 3147;
3163 -> 3162;
3163 -> 3123;
3163 -> 3141;
3163 -> 3147;
3164 -> 3151;
3164 -> 3163;
3165 -> 3163;
3166 -> 3149;
3166 -> 3163;
3166 -> 3123;
3166 -> 3141;
3166 -> 2962;
3166 -> 3138;
3167 -> 3166;
3168 -> 3166;
3169 -> 3167;
3169 -> 3168;
3169 -> 3166;
3170 -> 3169;
3170 -> 3166;
3171 -> 3170;
3172 -> 3167;
3172 -> 3171;
3173 -> 3172;
3173 -> 3166;
3173 -> 3171;
3174 -> 3173;
3174 -> 3151;
3174 -> 3164;
3174 -> 3166;
3175 -> 3151;
3175 -> 3164;
3175 -> 3173;
3175 -> 3166;
3176 -> 3166;
3177 -> 3175;
3177 -> 3176;
3177 -> 3166;
3178 -> 3152;
3178 -> 3176;
3178 -> 3166;
3179 -> 3177;
3179 -> 3178;
3179 -> 3166;
3180 -> 3166;
3181 -> 3175;
3181 -> 3180;
3181 -> 3166;
3182 -> 3166;
3182 -> 3173;
3182 -> 3151;
3183 -> 3166;
3184 -> 3167;
3184 -> 3183;
3184 -> 3166;
3185 -> 3184;
3186 -> 3167;
3186 -> 3185;
3187 -> 3186;
3187 -> 3166;
3187 -> 3185;
3188 -> 3185;
3189 -> 3187;
3189 -> 3188;
3190 -> 3189;
3190 -> 0;
3190 -> 3188;
3191 -> 0;
3191 -> 3190;
3192 -> 3191;
3192 -> 3184;
3193 -> 3192;
3193 -> 0;
3193 -> 3184;
3194 -> 1842;
3195 -> 3143;
3195 -> 1842;
3196 -> 1838;
3197 -> 1840;
3197 -> 3195;
3197 -> 3196;
3197 -> 3166;
3197 -> 1838;
3198 -> 3197;
3199 -> 1836;
3199 -> 3198;
3200 -> 3198;
3201 -> 3199;
3201 -> 3200;
3202 -> 0;
3202 -> 3200;
3203 -> 3202;
3203 -> 3198;
3204 -> 3198;
3205 -> 3199;
3205 -> 3204;
3206 -> 3205;
3206 -> 3197;
3206 -> 3204;
3207 -> 3206;
3207 -> 3198;
3208 -> 3198;
3209 -> 3207;
3209 -> 3208;
3209 -> 3198;
3210 -> 3209;
3210 -> 3198;
3211 -> 3210;
3212 -> 3211;
3212 -> 3197;
3213 -> 3197;
3214 -> 3212;
3214 -> 3213;
3215 -> 3214;
3215 -> 3197;
3215 -> 3213;
3216 -> 3213;
3217 -> 3214;
3217 -> 3197;
3217 -> 3216;
3217 -> 3213;
3218 -> 3217;
3219 -> 3214;
3219 -> 3197;
3219 -> 3217;
3220 -> 3218;
3220 -> 3217;
3221 -> 3217;
3222 -> 3214;
3222 -> 3220;
3222 -> 3213;
3223 -> 1839;
3223 -> 3197;
3224 -> 3197;
3225 -> 1836;
3225 -> 3224;
3226 -> 3224;
3227 -> 3225;
3227 -> 3226;
3228 -> 3226;
3229 -> 3227;
3229 -> 3222;
3229 -> 3228;
3230 -> 3229;
3230 -> 3222;
3230 -> 3228;
3231 -> 3230;
3231 -> 3224;
3232 -> 3224;
3233 -> 3231;
3233 -> 3232;
3234 -> 3232;
3235 -> 3233;
3235 -> 3234;
3236 -> 3235;
3236 -> 3232;
3237 -> 3233;
3237 -> 3232;
3238 -> 3236;
3238 -> 3224;
3239 -> 3197;
3240 -> 3197;
3241 -> 1836;
3241 -> 3240;
3242 -> 3240;
3243 -> 3241;
3243 -> 3242;
3244 -> 0;
3244 -> 3242;
3245 -> 3244;
3245 -> 3240;
3246 -> 3240;
3247 -> 3241;
3247 -> 3246;
3248 -> 3247;
3248 -> 3222;
3248 -> 3246;
3249 -> 3240;
3250 -> 3248;
3250 -> 3197;
3251 -> 1836;
3251 -> 3197;
3252 -> 3197;
3253 -> 3251;
3253 -> 3252;
3254 -> 3250;
3254 -> 3252;
3255 -> 3254;
3255 -> 3252;
3256 -> 3253;
3256 -> 3252;
3257 -> 3256;
3257 -> 3222;
3257 -> 3252;
3258 -> 3252;
3259 -> 3255;
3259 -> 3257;
3259 -> 3258;
3259 -> 3252;
3260 -> 3197;
3261 -> 0;
3261 -> 3197;
3262 -> 3197;
3263 -> 3261;
3263 -> 3262;
3264 -> 1836;
3264 -> 3259;
3264 -> 3262;
3265 -> 3264;
3265 -> 3259;
3265 -> 3262;
3266 -> 3263;
3266 -> 3262;
3267 -> 3265;
3267 -> 3266;
3267 -> 3262;
3268 -> 3267;
3268 -> 3197;
3269 -> 1839;
3269 -> 3259;
3269 -> 3267;
3269 -> 1838;
3270 -> 1836;
3270 -> 3269;
3270 -> 1835;
3271 -> 3270;
3271 -> 1833;
3272 -> 1833;
3273 -> 3271;
3273 -> 3272;
3274 -> 0;
3274 -> 3272;
3275 -> 3273;
3275 -> 3272;
3276 -> 3275;
3276 -> 3269;
3277 -> 3275;
3278 -> 3275;
3279 -> 3276;
3279 -> 3275;
3280 -> 3279;
3281 -> 3279;
3281 -> 3280;
3282 -> 3280;
3282 -> 3279;
3283 -> 3282;
3284 -> 3278;
3284 -> 3282;
3285 -> 3283;
3285 -> 3275;
3286 -> 3278;
3286 -> 3285;
3287 -> 3275;
3287 -> 3269;
3287 -> 3286;
3288 -> 3276;
3288 -> 3269;
3288 -> 3286;
3289 -> 3274;
3289 -> 3287;
3289 -> 3288;
3289 -> 3286;
3290 -> 3274;
3290 -> 3272;
3291 -> 3290;
3291 -> 1833;
3292 -> 1833;
3293 -> 1834;
3293 -> 3291;
3293 -> 3292;
3293 -> 3274;
3293 -> 3288;
3293 -> 3289;
3293 -> 1833;
3294 -> 1831;
3294 -> 3293;
3294 -> 1830;
3295 -> 3294;
3295 -> 1825;
3296 -> 1826;
3296 -> 1825;
3297 -> 1828;
3297 -> 1825;
3298 -> 3295;
3298 -> 3296;
3298 -> 3297;
3298 -> 3293;
3298 -> 1829;
3298 -> 1825;
3299 -> 3298;
3299 -> 1825;
3300 -> 1;
3301 -> 1;
3302 -> 3300;
3302 -> 3301;
3303 -> 3299;
3303 -> 3301;
3304 -> 3301;
3305 -> 3304;
3305 -> 3301;
3306 -> 3301;
3307 -> 3303;
3307 -> 3306;
3308 -> 0;
3308 -> 3306;
3309 -> 3306;
3310 -> 3308;
3310 -> 3309;
3311 -> 3307;
3311 -> 3298;
3311 -> 3299;
3311 -> 3309;
3312 -> 3311;
3312 -> 3298;
3312 -> 3299;
3312 -> 3310;
3312 -> 3309;
3313 -> 3306;
3314 -> 3307;
3314 -> 3313;
3315 -> 3313;
3316 -> 3314;
3316 -> 3298;
3316 -> 3299;
3316 -> 3315;
3316 -> 3313;
3317 -> 3316;
3318 -> 3317;
3318 -> 3316;
3319 -> 3316;
3320 -> 3318;
3320 -> 3319;
3321 -> 3314;
3321 -> 3319;
3322 -> 3319;
3323 -> 3319;
3324 -> 3321;
3324 -> 3323;
3325 -> 3324;
3325 -> 3298;
3325 -> 3299;
3325 -> 3323;
3326 -> 3323;
3327 -> 3325;
3327 -> 3326;
3327 -> 3323;
3328 -> 3323;
3329 -> 3328;
3329 -> 3323;
3330 -> 3323;
3331 -> 3329;
3331 -> 3330;
3332 -> 3324;
3332 -> 3330;
3333 -> 3330;
3334 -> 3332;
3334 -> 3333;
3335 -> 3334;
3335 -> 3298;
3335 -> 3299;
3335 -> 3333;
3336 -> 3335;
3336 -> 2807;
3336 -> 3333;
3337 -> 3334;
3337 -> 3298;
3337 -> 3299;
3337 -> 3333;
3338 -> 3333;
3339 -> 3338;
3339 -> 3333;
3340 -> 3333;
3341 -> 3339;
3341 -> 3340;
3342 -> 3334;
3342 -> 3340;
3343 -> 3340;
3344 -> 3340;
3345 -> 3343;
3345 -> 3344;
3346 -> 3344;
3347 -> 3346;
3347 -> 3345;
3347 -> 3344;
3348 -> 3344;
3349 -> 3348;
3349 -> 3345;
3349 -> 3344;
3350 -> 3344;
3351 -> 3350;
3351 -> 3345;
3351 -> 3344;
3352 -> 3345;
3352 -> 3344;
3353 -> 3345;
3353 -> 3344;
3354 -> 3345;
3354 -> 3344;
3355 -> 3344;
3356 -> 3355;
3356 -> 3345;
3356 -> 3344;
3357 -> 3345;
3357 -> 3344;
3358 -> 3345;
3358 -> 3344;
3359 -> 3343;
3359 -> 3340;
3360 -> 3341;
3360 -> 3340;
3361 -> 3340;
3362 -> 3359;
3362 -> 3361;
3363 -> 3360;
3363 -> 3361;
3364 -> 3342;
3364 -> 3361;
3365 -> 3364;
3365 -> 3337;
3365 -> 3361;
3366 -> 3365;
3366 -> 3337;
3367 -> 3365;
3368 -> 3365;
3369 -> 3368;
3369 -> 3365;
3370 -> 3368;
3370 -> 3369;
3371 -> 3362;
3371 -> 3369;
3372 -> 3369;
3373 -> 3370;
3373 -> 3369;
3374 -> 3363;
3374 -> 3369;
3375 -> 3369;
3376 -> 3371;
3376 -> 3375;
3377 -> 3372;
3377 -> 3375;
3378 -> 3373;
3378 -> 3375;
3379 -> 3374;
3379 -> 3375;
3380 -> 3364;
3380 -> 3375;
3381 -> 3375;
3382 -> 3378;
3382 -> 3369;
3382 -> 3381;
3382 -> 3375;
3383 -> 3375;
3384 -> 3378;
3384 -> 3383;
3384 -> 3369;
3384 -> 3375;
3385 -> 3384;
3385 -> 3375;
3386 -> 3375;
3387 -> 3385;
3387 -> 3386;
3388 -> 3380;
3388 -> 3386;
3389 -> 3386;
3390 -> 3388;
3390 -> 3389;
3391 -> 3389;
3392 -> 3390;
3392 -> 3391;
3393 -> 3391;
3393 -> 3389;
3394 -> 3390;
3394 -> 3389;
3395 -> 3389;
3396 -> 3394;
3396 -> 3395;
3397 -> 3396;
3397 -> 3384;
3397 -> 3395;
3398 -> 3397;
3398 -> 3389;
3399 -> 3389;
3400 -> 3398;
3400 -> 3399;
3400 -> 3389;
3401 -> 3400;
3401 -> 3389;
3402 -> 3401;
3403 -> 3402;
3403 -> 3386;
3404 -> 3387;
3404 -> 3386;
3405 -> 3386;
3406 -> 3404;
3406 -> 3405;
3407 -> 3403;
3407 -> 3405;
3408 -> 3406;
3408 -> 3384;
3408 -> 3405;
3409 -> 3405;
3410 -> 3405;
3411 -> 3408;
3411 -> 3410;
3412 -> 3409;
3412 -> 3410;
3413 -> 3407;
3413 -> 3410;
3414 -> 3412;
3414 -> 3410;
3415 -> 3411;
3415 -> 3410;
3416 -> 3410;
3417 -> 3413;
3417 -> 3384;
3417 -> 3410;
3418 -> 3410;
3419 -> 3415;
3419 -> 3418;
3420 -> 3416;
3420 -> 3418;
3421 -> 3417;
3421 -> 3418;
3422 -> 3413;
3422 -> 3418;
3423 -> 3421;
3423 -> 3418;
3424 -> 3420;
3424 -> 3418;
3425 -> 3422;
3425 -> 3384;
3425 -> 3424;
3426 -> 3422;
3426 -> 3384;
3426 -> 3425;
3426 -> 3418;
3427 -> 3423;
3427 -> 3426;
3427 -> 3384;
3427 -> 3425;
3427 -> 3418;
3428 -> 3419;
3428 -> 3418;
3429 -> 3418;
3430 -> 3428;
3430 -> 3429;
3431 -> 3422;
3431 -> 3429;
3432 -> 3430;
3432 -> 3429;
3433 -> 3429;
3434 -> 3432;
3434 -> 3433;
3435 -> 3431;
3435 -> 3433;
3436 -> 3433;
3437 -> 3434;
3437 -> 3436;
3437 -> 3433;
3438 -> 3435;
3438 -> 3427;
3438 -> 3433;
3439 -> 3434;
3439 -> 3433;
3440 -> 3438;
3440 -> 3439;
3440 -> 3433;
3441 -> 3431;
3441 -> 3440;
3441 -> 3429;
3442 -> 3427;
3442 -> 3418;
3443 -> 3418;
3444 -> 3442;
3444 -> 3443;
3444 -> 3418;
3445 -> 3444;
3446 -> 3445;
3446 -> 3441;
3447 -> 3446;
3447 -> 3444;
3448 -> 3427;
3448 -> 3444;
3449 -> 3447;
3449 -> 3444;
3450 -> 3444;
3451 -> 3418;
3452 -> 3449;
3452 -> 3441;
3452 -> 3418;
3453 -> 3418;
3454 -> 3452;
3454 -> 3453;
3454 -> 3418;
3455 -> 3419;
3455 -> 3418;
3456 -> 3420;
3456 -> 3418;
3457 -> 3449;
3457 -> 3441;
3457 -> 3418;
3458 -> 3418;
3459 -> 3455;
3459 -> 3458;
3460 -> 3456;
3460 -> 3458;
3461 -> 3457;
3461 -> 3458;
3462 -> 3422;
3462 -> 3458;
3463 -> 3462;
3463 -> 3458;
3464 -> 3459;
3464 -> 3458;
3465 -> 3460;
3465 -> 3458;
3466 -> 3458;
3467 -> 3458;
3468 -> 3463;
3468 -> 3467;
3469 -> 3464;
3469 -> 3467;
3470 -> 3465;
3470 -> 3467;
3471 -> 3466;
3471 -> 3467;
3472 -> 3471;
3472 -> 3467;
3473 -> 3471;
3473 -> 3467;
3474 -> 3471;
3474 -> 3467;
3475 -> 3471;
3475 -> 3467;
3476 -> 3471;
3476 -> 3467;
3477 -> 3471;
3477 -> 3467;
3478 -> 3468;
3478 -> 3471;
3478 -> 3467;
3479 -> 3469;
3479 -> 3471;
3479 -> 3467;
3480 -> 3470;
3480 -> 3471;
3480 -> 3467;
3481 -> 3471;
3481 -> 3467;
3482 -> 3467;
3483 -> 3481;
3483 -> 3482;
3483 -> 3472;
3483 -> 3478;
3483 -> 3479;
3483 -> 3475;
3483 -> 3480;
3483 -> 3477;
3483 -> 3449;
3483 -> 3467;
3484 -> 3483;
3484 -> 3471;
3484 -> 3467;
3485 -> 3467;
3486 -> 3485;
3486 -> 3471;
3486 -> 3467;
3487 -> 3468;
3487 -> 3467;
3488 -> 3467;
3489 -> 3467;
3490 -> 3487;
3490 -> 3489;
3491 -> 3488;
3491 -> 3489;
3493 -> 3492;
3495 -> 3494;
3497 -> 3496;
3500 -> 3499;
3501 -> 0;
3502 -> 0;
3503 -> 0;
3504 -> 3503;
3506 -> 3501;
3506 -> 3502;
3506 -> 3504;
3506 -> 3505;
3507 -> 3506;
3509 -> 3508;
3511 -> 3510;
3513 -> 3512;
3515 -> 3514;
3516 -> 3490;
3516 -> 3489;
3517 -> 3489;
3518 -> 3516;
3518 -> 3517;
3519 -> 3491;
3519 -> 3517;
3520 -> 3519;
3520 -> 3517;
3521 -> 3519;
3521 -> 3517;
3522 -> 3519;
3522 -> 3517;
3523 -> 3519;
3523 -> 3517;
3524 -> 3519;
3524 -> 3517;
3525 -> 3517;
3526 -> 3518;
3526 -> 3525;
3526 -> 3517;
3527 -> 3519;
3527 -> 3517;
3528 -> 3527;
3528 -> 3520;
3528 -> 3521;
3528 -> 3522;
3528 -> 3523;
3528 -> 3524;
3528 -> 3517;
3529 -> 3517;
3530 -> 3518;
3530 -> 3529;
3531 -> 3530;
3531 -> 3483;
3531 -> 3529;
3532 -> 3531;
3532 -> 3517;
3533 -> 3532;
3533 -> 3483;
3533 -> 3519;
3533 -> 3517;
3534 -> 3518;
3534 -> 3519;
3534 -> 3517;
3535 -> 3488;
3535 -> 3471;
3535 -> 3467;
3536 -> 3466;
3536 -> 3458;
3537 -> 3536;
3537 -> 3483;
3537 -> 3484;
3537 -> 3486;
3537 -> 3535;
3537 -> 3485;
3537 -> 3528;
3537 -> 3533;
3537 -> 3534;
3537 -> 3458;
3538 -> 3458;
3539 -> 3538;
3540 -> 3461;
3540 -> 3538;
3541 -> 3538;
3542 -> 3540;
3542 -> 3541;
3542 -> 3538;
3543 -> 3461;
3543 -> 3538;
3544 -> 3537;
3544 -> 3538;
3545 -> 3540;
3545 -> 3538;
3546 -> 3543;
3546 -> 3544;
3546 -> 3545;
3546 -> 3537;
3546 -> 3538;
3547 -> 3466;
3547 -> 3546;
3548 -> 3406;
3548 -> 3405;
3549 -> 3405;
3550 -> 3548;
3550 -> 3549;
3551 -> 3409;
3551 -> 3549;
3552 -> 3409;
3552 -> 3549;
3553 -> 3547;
3553 -> 3549;
3554 -> 3550;
3554 -> 3546;
3554 -> 3549;
3555 -> 3549;
3556 -> 3553;
3556 -> 3555;
3557 -> 3556;
3557 -> 3546;
3557 -> 3449;
3557 -> 0;
3557 -> 3555;
3558 -> 3557;
3558 -> 3549;
3559 -> 3549;
3560 -> 3550;
3560 -> 3546;
3560 -> 3559;
3560 -> 3549;
3561 -> 3558;
3561 -> 3560;
3561 -> 3549;
3562 -> 3550;
3562 -> 3546;
3562 -> 3561;
3563 -> 3562;
3563 -> 3549;
3564 -> 3554;
3564 -> 3549;
3565 -> 3551;
3565 -> 3549;
3566 -> 3552;
3566 -> 3549;
3567 -> 3549;
3568 -> 3563;
3568 -> 3567;
3569 -> 3564;
3569 -> 3567;
3570 -> 3565;
3570 -> 3567;
3571 -> 3566;
3571 -> 3567;
3572 -> 3553;
3572 -> 3567;
3573 -> 3567;
3574 -> 3568;
3574 -> 3573;
3574 -> 3567;
3575 -> 3571;
3575 -> 3567;
3576 -> 3572;
3576 -> 3546;
3576 -> 3567;
3577 -> 3572;
3577 -> 3546;
3577 -> 3449;
3577 -> 3567;
3578 -> 3567;
3579 -> 3577;
3579 -> 3578;
3580 -> 3576;
3580 -> 3578;
3581 -> 3578;
3582 -> 3581;
3582 -> 3578;
3583 -> 3581;
3583 -> 3578;
3584 -> 3581;
3584 -> 3578;
3585 -> 3581;
3585 -> 3578;
3586 -> 3579;
3586 -> 3581;
3586 -> 3578;
3587 -> 3577;
3587 -> 3576;
3587 -> 3581;
3587 -> 3582;
3587 -> 3583;
3587 -> 3584;
3587 -> 3585;
3587 -> 3586;
3587 -> 3567;
3588 -> 3569;
3588 -> 3567;
3589 -> 3570;
3589 -> 3567;
3590 -> 3571;
3590 -> 3567;
3591 -> 3567;
3592 -> 3588;
3592 -> 3591;
3593 -> 3589;
3593 -> 3591;
3594 -> 3590;
3594 -> 3591;
3595 -> 3587;
3595 -> 3591;
3596 -> 3591;
3597 -> 3591;
3598 -> 3593;
3598 -> 3597;
3599 -> 3596;
3599 -> 3597;
3600 -> 3599;
3600 -> 3597;
3601 -> 3598;
3601 -> 3600;
3602 -> 3593;
3602 -> 3596;
3602 -> 3591;
3603 -> 3594;
3603 -> 3596;
3603 -> 3591;
3604 -> 3602;
3604 -> 3603;
3604 -> 3591;
3605 -> 3592;
3605 -> 3595;
3605 -> 3591;
3606 -> 3593;
3606 -> 3595;
3606 -> 3591;
3607 -> 3594;
3607 -> 3595;
3607 -> 3591;
3608 -> 3567;
3609 -> 3568;
3609 -> 3567;
3610 -> 3567;
3611 -> 3609;
3611 -> 3610;
3612 -> 3587;
3612 -> 3610;
3613 -> 3611;
3613 -> 3610;
3614 -> 3610;
3615 -> 3613;
3615 -> 3614;
3616 -> 3612;
3616 -> 3614;
3617 -> 3616;
3617 -> 3614;
3618 -> 3617;
3618 -> 3615;
3618 -> 3587;
3618 -> 3605;
3618 -> 3606;
3618 -> 3607;
3618 -> 3614;
3619 -> 3614;
3620 -> 3618;
3620 -> 3619;
3621 -> 3618;
3621 -> 3619;
3622 -> 3620;
3622 -> 3619;
3623 -> 3619;
3624 -> 3622;
3624 -> 3623;
3625 -> 3621;
3625 -> 3623;
3626 -> 3625;
3626 -> 3618;
3626 -> 3623;
3627 -> 3624;
3627 -> 3623;
3628 -> 3626;
3628 -> 3627;
3628 -> 3618;
3628 -> 3623;
3629 -> 0;
3629 -> 3623;
3630 -> 3623;
3631 -> 3624;
3631 -> 3628;
3631 -> 3630;
3631 -> 3623;
3632 -> 3625;
3632 -> 3628;
3632 -> 3623;
3633 -> 3624;
3633 -> 3628;
3633 -> 3623;
3634 -> 0;
3634 -> 3631;
3635 -> 3624;
3635 -> 3623;
3636 -> 3634;
3636 -> 3623;
3637 -> 3623;
3638 -> 3635;
3638 -> 3637;
3639 -> 3636;
3639 -> 3637;
3640 -> 3625;
3640 -> 3637;
3641 -> 3638;
3641 -> 3637;
3642 -> 3639;
3642 -> 3637;
3643 -> 3637;
3644 -> 3641;
3644 -> 3643;
3645 -> 3642;
3645 -> 3643;
3646 -> 3645;
3646 -> 3643;
3647 -> 3643;
3648 -> 3644;
3648 -> 3643;
3649 -> 3645;
3649 -> 3643;
3650 -> 3643;
3651 -> 3643;
3652 -> 3648;
3652 -> 3651;
3653 -> 3649;
3653 -> 3651;
3654 -> 3650;
3654 -> 3651;
3655 -> 3652;
3655 -> 3654;
3655 -> 3651;
3656 -> 3653;
3656 -> 3654;
3656 -> 3651;
3657 -> 3650;
3657 -> 3637;
3658 -> 3637;
3659 -> 3637;
3660 -> 3640;
3660 -> 3659;
3661 -> 3660;
3661 -> 3632;
3661 -> 3659;
3662 -> 3661;
3662 -> 3637;
3663 -> 3657;
3663 -> 3637;
3664 -> 3658;
3664 -> 3637;
3665 -> 3663;
3665 -> 3664;
3665 -> 3662;
3665 -> 3655;
3665 -> 3656;
3665 -> 3632;
3665 -> 3637;
3666 -> 3637;
3667 -> 3665;
3667 -> 3666;
3668 -> 3667;
3668 -> 3665;
3668 -> 3666;
3669 -> 3638;
3669 -> 3668;
3670 -> 3668;
3671 -> 3669;
3671 -> 3670;
3672 -> 3671;
3672 -> 3670;
3673 -> 3671;
3673 -> 3670;
3674 -> 3672;
3674 -> 3670;
3675 -> 3670;
3676 -> 3674;
3676 -> 3675;
3677 -> 3673;
3677 -> 3675;
3678 -> 3676;
3678 -> 3671;
3678 -> 3675;
3679 -> 3675;
3680 -> 3679;
3680 -> 3675;
3681 -> 3676;
3681 -> 3671;
3681 -> 3675;
3682 -> 3677;
3682 -> 3681;
3682 -> 3678;
3682 -> 3671;
3683 -> 3677;
3683 -> 3681;
3683 -> 3682;
3684 -> 3682;
3685 -> 3683;
3685 -> 3675;
3686 -> 3675;
3687 -> 3685;
3687 -> 3686;
3687 -> 3675;
3688 -> 3685;
3688 -> 3676;
3688 -> 3675;
3689 -> 3685;
3689 -> 3687;
3690 -> 0;
3690 -> 3687;
3691 -> 3685;
3691 -> 3689;
3691 -> 3687;
3692 -> 3675;
3693 -> 3692;
3693 -> 3670;
3694 -> 3670;
3695 -> 3673;
3695 -> 3694;
3696 -> 3694;
3697 -> 3695;
3697 -> 3691;
3697 -> 3696;
3698 -> 3697;
3698 -> 3694;
3699 -> 3670;
3700 -> 3674;
3700 -> 3699;
3701 -> 3693;
3701 -> 3699;
3702 -> 3698;
3702 -> 3699;
3703 -> 3673;
3703 -> 3699;
3704 -> 3699;
3705 -> 3703;
3705 -> 3704;
3706 -> 3705;
3706 -> 3691;
3706 -> 3704;
3707 -> 3706;
3707 -> 3699;
3708 -> 3699;
3709 -> 3700;
3709 -> 3707;
3709 -> 3699;
3710 -> 3701;
3710 -> 3699;
3711 -> 3702;
3711 -> 3710;
3712 -> 0;
3712 -> 3711;
3713 -> 3700;
3713 -> 3699;
3714 -> 3712;
3714 -> 3699;
3715 -> 3699;
3716 -> 3713;
3716 -> 3715;
3717 -> 3714;
3717 -> 3715;
3718 -> 3717;
3718 -> 3715;
3719 -> 3715;
3720 -> 3715;
3720 -> 3699;
3721 -> 3699;
3722 -> 3699;
3723 -> 3703;
3723 -> 3722;
3724 -> 3723;
3724 -> 3691;
3724 -> 3722;
3725 -> 3724;
3725 -> 3699;
3726 -> 3720;
3726 -> 3699;
3727 -> 3721;
3727 -> 3699;
3728 -> 3726;
3728 -> 3727;
3728 -> 3725;
3728 -> 3716;
3728 -> 3717;
3728 -> 3691;
3728 -> 3699;
3729 -> 3699;
3730 -> 3728;
3731 -> 3703;
3731 -> 3730;
3732 -> 3731;
3732 -> 3728;
3732 -> 3730;
3733 -> 3732;
3733 -> 3728;
3734 -> 3702;
3734 -> 3728;
3735 -> 3734;
3736 -> 3703;
3736 -> 3735;
3737 -> 3736;
3737 -> 3728;
3737 -> 3735;
3738 -> 3737;
3738 -> 3734;
3739 -> 3734;
3740 -> 3738;
3740 -> 3739;
3741 -> 3740;
3741 -> 3728;
3741 -> 3739;
3742 -> 3741;
3743 -> 3742;
3743 -> 3741;
3744 -> 3741;
3745 -> 3743;
3745 -> 3744;
3746 -> 3740;
3746 -> 3744;
3747 -> 3744;
3748 -> 3746;
3748 -> 3747;
3749 -> 3748;
3749 -> 3728;
3749 -> 3747;
3750 -> 3749;
3750 -> 3747;
3751 -> 3748;
3751 -> 3744;
3752 -> 3744;
3753 -> 3751;
3753 -> 3752;
3754 -> 3745;
3754 -> 3753;
3754 -> 3742;
3754 -> 3748;
3754 -> 3744;
3755 -> 3744;
3756 -> 3746;
3756 -> 3755;
3757 -> 3756;
3757 -> 3754;
3757 -> 3755;
3758 -> 3756;
3758 -> 3754;
3758 -> 3755;
3759 -> 3758;
3759 -> 3744;
3760 -> 3744;
3761 -> 3760;
3761 -> 3759;
3761 -> 3754;
3761 -> 3744;
3762 -> 3760;
3762 -> 3761;
3763 -> 3759;
3763 -> 3762;
3763 -> 3760;
3764 -> 3762;
3765 -> 3763;
3765 -> 3764;
3766 -> 3741;
3767 -> 3740;
3767 -> 3741;
3768 -> 3741;
3769 -> 3741;
3770 -> 3767;
3770 -> 3769;
3771 -> 3768;
3771 -> 3769;
3772 -> 0;
3772 -> 3771;
3772 -> 3769;
3773 -> 3770;
3773 -> 3771;
3773 -> 3769;
3774 -> 3768;
3774 -> 3742;
3774 -> 3765;
3774 -> 3741;
3775 -> 3774;
3775 -> 3768;
3776 -> 3775;
3776 -> 3768;
3777 -> 3774;
3777 -> 3768;
3778 -> 3777;
3778 -> 3776;
3778 -> 3768;
3779 -> 3741;
3780 -> 3768;
3780 -> 3779;
3781 -> 3768;
3781 -> 3779;
3782 -> 3778;
3782 -> 3779;
3783 -> 3768;
3783 -> 3779;
3784 -> 3779;
3785 -> 3782;
3785 -> 3778;
3785 -> 3784;
3785 -> 3779;
3786 -> 3779;
3787 -> 3782;
3787 -> 3778;
3787 -> 3786;
3787 -> 3779;
3788 -> 3787;
3788 -> 3779;
3789 -> 3780;
3789 -> 3788;
3790 -> 3781;
3790 -> 3788;
3791 -> 3783;
3791 -> 3788;
3792 -> 3788;
3793 -> 3789;
3793 -> 3792;
3794 -> 3790;
3794 -> 3792;
3795 -> 3788;
3795 -> 3792;
3796 -> 3791;
3796 -> 3792;
3797 -> 3788;
3797 -> 3792;
3798 -> 3792;
3799 -> 3797;
3799 -> 3792;
3800 -> 3797;
3800 -> 3792;
3801 -> 3797;
3801 -> 3792;
3802 -> 3793;
3802 -> 3797;
3802 -> 3792;
3803 -> 3795;
3803 -> 3797;
3803 -> 3792;
3804 -> 3794;
3804 -> 3797;
3804 -> 3792;
3805 -> 3797;
3805 -> 3792;
3806 -> 0;
3806 -> 3792;
3807 -> 3805;
3807 -> 3797;
3807 -> 3792;
3808 -> 3796;
3808 -> 3797;
3808 -> 3792;
3809 -> 3795;
3809 -> 3792;
3810 -> 3809;
3811 -> 3809;
3811 -> 3810;
3812 -> 3811;
3812 -> 3810;
3813 -> 3812;
3813 -> 3809;
3814 -> 3809;
3815 -> 3742;
3815 -> 3778;
3815 -> 3741;
3816 -> 3740;
3816 -> 3815;
3816 -> 3741;
3817 -> 3788;
3817 -> 3741;
3818 -> 3741;
3819 -> 3816;
3819 -> 3817;
3819 -> 3818;
3819 -> 3797;
3819 -> 3804;
3819 -> 3808;
3819 -> 3807;
3819 -> 3802;
3819 -> 3803;
3819 -> 3815;
3819 -> 3772;
3819 -> 3773;
3819 -> 3778;
3819 -> 3805;
3819 -> 3741;
3820 -> 3740;
3820 -> 3819;
3820 -> 3739;
3821 -> 3733;
3821 -> 3734;
3822 -> 3700;
3822 -> 3734;
3823 -> 3701;
3823 -> 3734;
3824 -> 3734;
3825 -> 3734;
3826 -> 3820;
3826 -> 3825;
3827 -> 3821;
3827 -> 3825;
3828 -> 3822;
3828 -> 3825;
3829 -> 3823;
3829 -> 3825;
3830 -> 3824;
3830 -> 3825;
3831 -> 3827;
3831 -> 3825;
3832 -> 3825;
3833 -> 3831;
3833 -> 3832;
3834 -> 3830;
3834 -> 3832;
3835 -> 3832;
3836 -> 3832;
3837 -> 3833;
3837 -> 3836;
3837 -> 3832;
3838 -> 3833;
3838 -> 3834;
3838 -> 3832;
3839 -> 3833;
3839 -> 3819;
3839 -> 3834;
3839 -> 3832;
3840 -> 3833;
3840 -> 3819;
3840 -> 3834;
3840 -> 3832;
3841 -> 3835;
3841 -> 3834;
3841 -> 3832;
3842 -> 3830;
3842 -> 3825;
3843 -> 3830;
3843 -> 3825;
3844 -> 3830;
3844 -> 3825;
3845 -> 3830;
3845 -> 3825;
3846 -> 3830;
3846 -> 3825;
3847 -> 3825;
3848 -> 3826;
3848 -> 3847;
3848 -> 3825;
3849 -> 3825;
3850 -> 3828;
3850 -> 3849;
3850 -> 3825;
3851 -> 3826;
3851 -> 3830;
3851 -> 3825;
3852 -> 3828;
3852 -> 3830;
3852 -> 3829;
3852 -> 3825;
3853 -> 3852;
3853 -> 3830;
3853 -> 3825;
3854 -> 3829;
3854 -> 3825;
3855 -> 3828;
3855 -> 3819;
3855 -> 3854;
3856 -> 3828;
3856 -> 3855;
3857 -> 3856;
3857 -> 3855;
3857 -> 3830;
3858 -> 3734;
3859 -> 3703;
3859 -> 3858;
3860 -> 3859;
3860 -> 3855;
3860 -> 3858;
3861 -> 3860;
3861 -> 3734;
3862 -> 3700;
3862 -> 3734;
3863 -> 3734;
3864 -> 3734;
3865 -> 3861;
3865 -> 3864;
3866 -> 3862;
3866 -> 3864;
3867 -> 3863;
3867 -> 3864;
3868 -> 3865;
3868 -> 3864;
3869 -> 3864;
3870 -> 3868;
3870 -> 3869;
3871 -> 3869;
3872 -> 3870;
3872 -> 3871;
3873 -> 3872;
3873 -> 3871;
3874 -> 3872;
3874 -> 3869;
3875 -> 3869;
3876 -> 3874;
3876 -> 3875;
3877 -> 0;
3877 -> 3869;
3878 -> 3869;
3879 -> 3877;
3879 -> 3878;
3880 -> 3876;
3880 -> 3878;
3881 -> 3880;
3881 -> 3864;
3882 -> 3881;
3883 -> 3728;
3884 -> 3883;
3884 -> 3880;
3885 -> 3884;
3885 -> 3728;
3886 -> 3720;
3886 -> 3728;
3887 -> 3824;
3887 -> 3728;
3888 -> 3886;
3888 -> 3887;
3888 -> 3885;
3888 -> 3716;
3888 -> 3717;
3888 -> 3840;
3888 -> 3839;
3888 -> 3838;
3888 -> 3841;
3888 -> 3834;
3888 -> 3851;
3888 -> 3853;
3888 -> 3844;
3888 -> 3845;
3888 -> 3846;
3888 -> 3857;
3888 -> 3880;
3888 -> 3852;
3888 -> 3855;
3888 -> 3728;
3889 -> 3728;
3890 -> 3824;
3890 -> 3699;
3891 -> 3671;
3891 -> 3890;
3891 -> 3888;
3891 -> 3670;
3892 -> 3639;
3892 -> 3712;
3892 -> 3668;
3893 -> 3892;
3894 -> 3891;
3894 -> 3893;
3895 -> 3894;
3895 -> 3891;
3895 -> 3893;
3896 -> 3893;
3897 -> 3895;
3897 -> 3896;
3897 -> 3893;
3898 -> 3897;
3898 -> 3893;
3899 -> 3898;
3900 -> 3898;
3900 -> 3899;
3901 -> 3895;
3901 -> 3899;
3902 -> 3901;
3902 -> 3891;
3902 -> 3899;
3903 -> 3900;
3903 -> 3902;
3904 -> 3902;
3905 -> 3903;
3905 -> 3904;
3906 -> 3902;
3906 -> 3904;
3907 -> 3904;
3908 -> 3905;
3908 -> 3907;
3908 -> 3904;
3909 -> 3904;
3910 -> 3906;
3910 -> 3909;
3911 -> 3909;
3912 -> 3910;
3912 -> 3911;
3913 -> 0;
3913 -> 3911;
3914 -> 3913;
3914 -> 3909;
3915 -> 3910;
3915 -> 3904;
3916 -> 3905;
3916 -> 3915;
3916 -> 3904;
3917 -> 3902;
3917 -> 3916;
3918 -> 3917;
3918 -> 3892;
3919 -> 3638;
3919 -> 3892;
3920 -> 3892;
3921 -> 3919;
3921 -> 3920;
3922 -> 3918;
3922 -> 3920;
3923 -> 3921;
3923 -> 3891;
3923 -> 3920;
3924 -> 3921;
3924 -> 3920;
3925 -> 3920;
3926 -> 3923;
3926 -> 3925;
3927 -> 3923;
3927 -> 3925;
3928 -> 3923;
3928 -> 3925;
3929 -> 3924;
3929 -> 3925;
3930 -> 3922;
3930 -> 3925;
3931 -> 3928;
3931 -> 3925;
3932 -> 3925;
3933 -> 3931;
3933 -> 3932;
3934 -> 3926;
3934 -> 3925;
3935 -> 3927;
3935 -> 3925;
3936 -> 3925;
3937 -> 3934;
3937 -> 3936;
3938 -> 3935;
3938 -> 3936;
3939 -> 3930;
3939 -> 3936;
3940 -> 3937;
3940 -> 3936;
3941 -> 3936;
3942 -> 3940;
3942 -> 3941;
3943 -> 3939;
3943 -> 3941;
3944 -> 3943;
3944 -> 3923;
3944 -> 3941;
3945 -> 3943;
3945 -> 3923;
3945 -> 3941;
3946 -> 3945;
3946 -> 3942;
3946 -> 3941;
3946 -> 3923;
3947 -> 3936;
3948 -> 3938;
3948 -> 3936;
3949 -> 3946;
3949 -> 3947;
3949 -> 3948;
3949 -> 3936;
3950 -> 3949;
3950 -> 3947;
3951 -> 3950;
3951 -> 3949;
3951 -> 3947;
3952 -> 3951;
3953 -> 3951;
3954 -> 3952;
3954 -> 3953;
3954 -> 3951;
3955 -> 3951;
3956 -> 3952;
3956 -> 3955;
3957 -> 3955;
3958 -> 3956;
3958 -> 3951;
3958 -> 3957;
3959 -> 3958;
3959 -> 3951;
3959 -> 3013;
3959 -> 3957;
3960 -> 3959;
3960 -> 3034;
3960 -> 3957;
3961 -> 3960;
3961 -> 3955;
3962 -> 3961;
3962 -> 3951;
3963 -> 3962;
3963 -> 3933;
3963 -> 3951;
3964 -> 3963;
3965 -> 3929;
3965 -> 3964;
3965 -> 3963;
3966 -> 3965;
3967 -> 3966;
3967 -> 3965;
3968 -> 3967;
3968 -> 3966;
3968 -> 3929;
3969 -> 3967;
3969 -> 3966;
3970 -> 3952;
3970 -> 3968;
3971 -> 3639;
3971 -> 0;
3971 -> 3892;
3972 -> 3970;
3972 -> 3971;
3973 -> 3891;
3973 -> 3971;
3974 -> 3971;
3975 -> 3971;
3976 -> 3972;
3976 -> 3975;
3977 -> 3973;
3977 -> 3975;
3978 -> 3974;
3978 -> 3975;
3979 -> 3974;
3979 -> 3975;
3980 -> 3977;
3980 -> 3975;
3981 -> 3975;
3982 -> 3980;
3982 -> 3981;
3983 -> 3979;
3983 -> 3981;
3984 -> 3981;
3985 -> 3981;
3986 -> 3982;
3986 -> 3985;
3986 -> 3981;
3987 -> 3982;
3987 -> 3969;
3987 -> 3983;
3987 -> 3981;
3988 -> 3982;
3988 -> 3969;
3988 -> 3983;
3988 -> 3981;
3989 -> 3984;
3989 -> 3983;
3989 -> 3981;
3990 -> 3979;
3990 -> 3975;
3991 -> 3979;
3991 -> 3975;
3992 -> 3979;
3992 -> 3975;
3993 -> 3979;
3993 -> 3975;
3994 -> 3979;
3994 -> 3975;
3995 -> 3975;
3996 -> 3976;
3996 -> 3995;
3996 -> 3975;
3997 -> 3976;
3997 -> 3979;
3997 -> 3975;
3999 -> 0;
4000 -> 0;
4001 -> 0;
4004 -> 3998;
4004 -> 4003;
4005 -> 3999;
4005 -> 4003;
4006 -> 4000;
4006 -> 4003;
4007 -> 4001;
4007 -> 4003;
4008 -> 4002;
4008 -> 4003;
4009 -> 4003;
4010 -> 4009;
4010 -> 4003;
4011 -> 4009;
4011 -> 4003;
4012 -> 4009;
4012 -> 4003;
4013 -> 4003;
4014 -> 4005;
4014 -> 4013;
4014 -> 4003;
4015 -> 4006;
4015 -> 0;
4015 -> 4003;
4016 -> 4007;
4016 -> 0;
4016 -> 4003;
4017 -> 4004;
4017 -> 4009;
4017 -> 4003;
4018 -> 4005;
4018 -> 4009;
4018 -> 4003;
4019 -> 4006;
4019 -> 4009;
4019 -> 4003;
4020 -> 4008;
4020 -> 4009;
4020 -> 4003;
4021 -> 4007;
4021 -> 4009;
4021 -> 4003;
4022 -> 4003;
4023 -> 4022;
4023 -> 3975;
4024 -> 4023;
4024 -> 3978;
4024 -> 3975;
4025 -> 4024;
4025 -> 3979;
4025 -> 3975;
4026 -> 3971;
4027 -> 3638;
4027 -> 3969;
4027 -> 4026;
4027 -> 3971;
4028 -> 3638;
4028 -> 3969;
4028 -> 3668;
4029 -> 3668;
4030 -> 4028;
4030 -> 4029;
4031 -> 3974;
4031 -> 4029;
4032 -> 4031;
4032 -> 3987;
4032 -> 4029;
4033 -> 0;
4033 -> 4029;
4034 -> 4029;
4035 -> 4032;
4035 -> 4034;
4036 -> 4033;
4036 -> 4034;
4037 -> 4035;
4037 -> 4036;
4037 -> 4034;
4038 -> 4030;
4038 -> 4029;
4039 -> 4037;
4039 -> 4038;
4039 -> 4029;
4040 -> 4039;
4040 -> 4029;
4041 -> 3668;
4042 -> 4041;
4042 -> 4038;
4043 -> 4042;
4043 -> 3668;
4044 -> 3657;
4044 -> 3668;
4045 -> 4040;
4045 -> 3668;
4046 -> 4044;
4046 -> 4045;
4046 -> 4043;
4046 -> 3655;
4046 -> 3656;
4046 -> 3988;
4046 -> 3987;
4046 -> 3982;
4046 -> 3989;
4046 -> 3983;
4046 -> 3997;
4046 -> 3991;
4046 -> 4025;
4046 -> 3993;
4046 -> 3994;
4046 -> 4038;
4046 -> 3951;
4046 -> 4017;
4046 -> 4020;
4046 -> 4018;
4046 -> 4019;
4046 -> 4021;
4046 -> 0;
4046 -> 3668;
4047 -> 3668;
4048 -> 4040;
4048 -> 3637;
4049 -> 3618;
4049 -> 4048;
4049 -> 4046;
4049 -> 3614;
4050 -> 3587;
4050 -> 3567;
4051 -> 3572;
4051 -> 4049;
4051 -> 4050;
4051 -> 3567;
4052 -> 4049;
4052 -> 3567;
4053 -> 3375;
4054 -> 3375;
4055 -> 3380;
4055 -> 4054;
4056 -> 4054;
4057 -> 4055;
4057 -> 4056;
4058 -> 4056;
4058 -> 4054;
4059 -> 4055;
4059 -> 4054;
4060 -> 4054;
4061 -> 4059;
4061 -> 4060;
4062 -> 4061;
4062 -> 4051;
4062 -> 4060;
4063 -> 4054;
4064 -> 4062;
4064 -> 3375;
4065 -> 3378;
4065 -> 3375;
4066 -> 4065;
4066 -> 4051;
4066 -> 3375;
4067 -> 4066;
4068 -> 4066;
4068 -> 4051;
4069 -> 4066;
4069 -> 4051;
4070 -> 4066;
4070 -> 4069;
4071 -> 4069;
4072 -> 3380;
4072 -> 4071;
4073 -> 4071;
4074 -> 4072;
4074 -> 4069;
4074 -> 4073;
4074 -> 4071;
4075 -> 4074;
4075 -> 4069;
4076 -> 4069;
4077 -> 3380;
4077 -> 4069;
4078 -> 4069;
4079 -> 4070;
4079 -> 4074;
4079 -> 4078;
4079 -> 4069;
4080 -> 3379;
4080 -> 4069;
4081 -> 4076;
4081 -> 4069;
4082 -> 4069;
4083 -> 4077;
4083 -> 4082;
4084 -> 4079;
4084 -> 4082;
4085 -> 4079;
4085 -> 4082;
4086 -> 4080;
4086 -> 4082;
4087 -> 4081;
4087 -> 4082;
4088 -> 4082;
4089 -> 4083;
4089 -> 4088;
4090 -> 4088;
4091 -> 4089;
4091 -> 4090;
4092 -> 4091;
4092 -> 4079;
4092 -> 4090;
4093 -> 4092;
4093 -> 4088;
4094 -> 4093;
4094 -> 4082;
4095 -> 4094;
4095 -> 4082;
4096 -> 0;
4096 -> 4082;
4097 -> 4084;
4097 -> 4082;
4098 -> 4085;
4098 -> 4082;
4099 -> 4095;
4099 -> 4082;
4100 -> 4096;
4100 -> 4082;
4101 -> 4097;
4101 -> 4082;
4102 -> 4086;
4102 -> 4082;
4103 -> 4087;
4103 -> 4082;
4104 -> 4082;
4105 -> 4098;
4105 -> 4104;
4106 -> 4099;
4106 -> 4104;
4107 -> 4100;
4107 -> 4104;
4108 -> 4101;
4108 -> 4104;
4109 -> 4102;
4109 -> 4104;
4110 -> 4103;
4110 -> 4104;
4111 -> 4105;
4111 -> 4104;
4112 -> 4109;
4112 -> 4104;
4113 -> 4104;
4114 -> 4111;
4114 -> 4113;
4115 -> 4112;
4115 -> 4113;
4116 -> 4113;
4117 -> 4113;
4118 -> 4114;
4118 -> 4079;
4118 -> 4097;
4119 -> 0;
4119 -> 4118;
4120 -> 4114;
4121 -> 4119;
4121 -> 4114;
4122 -> 4113;
4122 -> 4114;
4123 -> 4116;
4123 -> 4114;
4124 -> 4117;
4124 -> 4114;
4125 -> 4115;
4125 -> 4114;
4126 -> 4114;
4127 -> 4120;
4127 -> 4126;
4128 -> 4121;
4128 -> 4126;
4129 -> 4122;
4129 -> 4126;
4130 -> 4123;
4130 -> 4126;
4131 -> 4124;
4131 -> 4126;
4132 -> 4125;
4132 -> 4126;
4133 -> 4129;
4133 -> 4128;
4133 -> 4126;
4134 -> 4126;
4135 -> 4119;
4135 -> 0;
4135 -> 4113;
4136 -> 4119;
4136 -> 4104;
4137 -> 4107;
4137 -> 4104;
4138 -> 4108;
4138 -> 4104;
4139 -> 4109;
4139 -> 4104;
4140 -> 4105;
4140 -> 4104;
4141 -> 4110;
4141 -> 4104;
4142 -> 4104;
4143 -> 4136;
4143 -> 4142;
4144 -> 4137;
4144 -> 4142;
4145 -> 4138;
4145 -> 4142;
4146 -> 4139;
4146 -> 4142;
4147 -> 4140;
4147 -> 4142;
4148 -> 4141;
4148 -> 4142;
4149 -> 4142;
4150 -> 4143;
4150 -> 4144;
4150 -> 4142;
4151 -> 4143;
4151 -> 4144;
4151 -> 4142;
4152 -> 4150;
4152 -> 0;
4152 -> 4142;
4153 -> 4151;
4153 -> 0;
4153 -> 4142;
4154 -> 4142;
4155 -> 4151;
4155 -> 4142;
4156 -> 4155;
4156 -> 0;
4156 -> 4104;
4157 -> 4104;
4158 -> 4155;
4158 -> 4106;
4158 -> 4156;
4159 -> 4158;
4159 -> 4104;
4160 -> 4159;
4160 -> 0;
4160 -> 4082;
4161 -> 4082;
4162 -> 4159;
4162 -> 0;
4162 -> 4082;
4163 -> 4082;
4164 -> 4159;
4164 -> 0;
4164 -> 4082;
4165 -> 4082;
4166 -> 4083;
4166 -> 4164;
4167 -> 4159;
4167 -> 4164;
4168 -> 4097;
4168 -> 4164;
4169 -> 4086;
4169 -> 4164;
4170 -> 4164;
4171 -> 4166;
4171 -> 4170;
4172 -> 4167;
4172 -> 4170;
4173 -> 4168;
4173 -> 4170;
4174 -> 4169;
4174 -> 4170;
4175 -> 4172;
4175 -> 0;
4175 -> 4170;
4176 -> 4164;
4177 -> 4159;
4177 -> 4082;
4178 -> 4070;
4178 -> 4118;
4178 -> 4069;
4179 -> 4177;
4179 -> 0;
4179 -> 4178;
4180 -> 4178;
4181 -> 4179;
4181 -> 4178;
4182 -> 4149;
4182 -> 4181;
4183 -> 3379;
4183 -> 4181;
4184 -> 4181;
4185 -> 4181;
4185 -> 4184;
4186 -> 4181;
4186 -> 4184;
4187 -> 4181;
4187 -> 4184;
4188 -> 4182;
4188 -> 4184;
4189 -> 4183;
4189 -> 4184;
4190 -> 4181;
4190 -> 4184;
4191 -> 4185;
4191 -> 4184;
4192 -> 4187;
4192 -> 4184;
4193 -> 4186;
4193 -> 4118;
4193 -> 4184;
4194 -> 4186;
4194 -> 4118;
4194 -> 4184;
4195 -> 4186;
4195 -> 4194;
4195 -> 4184;
4196 -> 4184;
4197 -> 4195;
4197 -> 4196;
4198 -> 4195;
4198 -> 4196;
4199 -> 4195;
4199 -> 4196;
4200 -> 4195;
4200 -> 4196;
4201 -> 4195;
4201 -> 4196;
4202 -> 4195;
4202 -> 4196;
4203 -> 4197;
4203 -> 4196;
4204 -> 4199;
4204 -> 4196;
4205 -> 4200;
4205 -> 4196;
4206 -> 4201;
4206 -> 4196;
4207 -> 4196;
4208 -> 4203;
4208 -> 4207;
4209 -> 4204;
4209 -> 4207;
4210 -> 4205;
4210 -> 4207;
4211 -> 4206;
4211 -> 4207;
4212 -> 4202;
4212 -> 4207;
4213 -> 4208;
4213 -> 4207;
4214 -> 4207;
4215 -> 4213;
4215 -> 4214;
4216 -> 4212;
4216 -> 4214;
4217 -> 4214;
4218 -> 4216;
4218 -> 4217;
4219 -> 4217;
4220 -> 4218;
4220 -> 4219;
4221 -> 4219;
4222 -> 4220;
4222 -> 4219;
4223 -> 4218;
4223 -> 4217;
4224 -> 4216;
4224 -> 4214;
4225 -> 4214;
4226 -> 4215;
4226 -> 4225;
4226 -> 4214;
4227 -> 4215;
4227 -> 4216;
4227 -> 4214;
4228 -> 4212;
4228 -> 4207;
4229 -> 4212;
4229 -> 4207;
4230 -> 4212;
4230 -> 4207;
4231 -> 4212;
4231 -> 4207;
4232 -> 4212;
4232 -> 4207;
4233 -> 0;
4233 -> 4212;
4233 -> 4207;
4234 -> 0;
4234 -> 4212;
4234 -> 4207;
4235 -> 4207;
4236 -> 4209;
4236 -> 4235;
4236 -> 4207;
4237 -> 4207;
4238 -> 4210;
4238 -> 4237;
4238 -> 4207;
4239 -> 4207;
4240 -> 4211;
4240 -> 4239;
4240 -> 4207;
4241 -> 4209;
4241 -> 4212;
4241 -> 4207;
4242 -> 4210;
4242 -> 4212;
4242 -> 4207;
4243 -> 4211;
4243 -> 4212;
4243 -> 4207;
4244 -> 4202;
4244 -> 4196;
4245 -> 4198;
4245 -> 4202;
4245 -> 4196;
4246 -> 4195;
4246 -> 4220;
4246 -> 4222;
4246 -> 4223;
4246 -> 4227;
4246 -> 4241;
4246 -> 4243;
4246 -> 4242;
4246 -> 4231;
4246 -> 4232;
4246 -> 4233;
4246 -> 4234;
4246 -> 4245;
4246 -> 0;
4246 -> 4184;
4247 -> 4186;
4247 -> 4246;
4247 -> 4184;
4248 -> 4184;
4249 -> 4248;
4249 -> 4191;
4249 -> 4192;
4249 -> 4193;
4249 -> 4194;
4249 -> 4247;
4249 -> 4184;
4250 -> 4248;
4250 -> 4184;
4251 -> 4248;
4251 -> 4184;
4252 -> 4248;
4252 -> 4184;
4253 -> 4184;
4254 -> 4186;
4254 -> 4249;
4254 -> 4253;
4254 -> 4184;
4255 -> 4254;
4255 -> 4248;
4255 -> 4184;
4256 -> 4189;
4256 -> 4184;
4257 -> 4184;
4258 -> 4256;
4258 -> 4257;
4259 -> 4248;
4259 -> 4257;
4260 -> 4257;
4261 -> 4259;
4261 -> 4260;
4262 -> 4261;
4262 -> 4249;
4262 -> 4260;
4263 -> 4262;
4263 -> 4257;
4264 -> 4259;
4264 -> 4257;
4265 -> 4257;
4266 -> 4257;
4267 -> 4263;
4267 -> 4266;
4268 -> 4264;
4268 -> 4266;
4269 -> 4265;
4269 -> 4266;
4270 -> 4267;
4270 -> 4266;
4271 -> 4266;
4272 -> 4270;
4272 -> 4271;
4273 -> 4272;
4273 -> 0;
4273 -> 4271;
4274 -> 4273;
4275 -> 4266;
4276 -> 4268;
4276 -> 4275;
4277 -> 0;
4277 -> 4275;
4278 -> 4277;
4278 -> 4266;
4279 -> 4269;
4279 -> 4278;
4279 -> 4266;
4280 -> 4267;
4280 -> 0;
4280 -> 4266;
4281 -> 4266;
4282 -> 4279;
4282 -> 4280;
4282 -> 4266;
4283 -> 4266;
4284 -> 4283;
4284 -> 4257;
4285 -> 4257;
4286 -> 4284;
4286 -> 4285;
4286 -> 4257;
4287 -> 4184;
4288 -> 4188;
4288 -> 4184;
4289 -> 4189;
4289 -> 4288;
4290 -> 4288;
4291 -> 4289;
4291 -> 4290;
4292 -> 4248;
4292 -> 4290;
4293 -> 4290;
4294 -> 4292;
4294 -> 4293;
4295 -> 4294;
4295 -> 4249;
4295 -> 4293;
4296 -> 4295;
4296 -> 4290;
4297 -> 4290;
4298 -> 4296;
4298 -> 4297;
4299 -> 0;
4299 -> 4297;
4300 -> 4297;
4301 -> 4299;
4301 -> 4300;
4302 -> 4298;
4302 -> 4300;
4303 -> 4302;
4303 -> 4249;
4303 -> 4301;
4303 -> 4300;
4304 -> 4300;
4305 -> 4303;
4305 -> 4304;
4305 -> 4300;
4306 -> 4305;
4307 -> 4292;
4307 -> 4306;
4308 -> 4306;
4309 -> 4307;
4309 -> 4308;
4310 -> 4309;
4310 -> 4249;
4310 -> 4308;
4311 -> 4310;
4311 -> 0;
4311 -> 4306;
4312 -> 4306;
4313 -> 4311;
4313 -> 4312;
4313 -> 4306;
4314 -> 4313;
4314 -> 4305;
4315 -> 4314;
4316 -> 4292;
4316 -> 4249;
4316 -> 4315;
4317 -> 0;
4317 -> 4315;
4318 -> 4315;
4319 -> 4317;
4319 -> 4318;
4320 -> 4316;
4320 -> 4318;
4321 -> 4320;
4321 -> 4249;
4321 -> 4319;
4321 -> 4318;
4322 -> 4321;
4322 -> 4314;
4323 -> 4322;
4324 -> 4292;
4324 -> 4323;
4325 -> 4323;
4326 -> 4324;
4326 -> 4325;
4327 -> 4326;
4327 -> 0;
4327 -> 4323;
4328 -> 4323;
4329 -> 4327;
4329 -> 4328;
4329 -> 4323;
4330 -> 4329;
4330 -> 4322;
4331 -> 4288;
4332 -> 4184;
4333 -> 4185;
4333 -> 4332;
4334 -> 4333;
4334 -> 4249;
4334 -> 4332;
4335 -> 4334;
4335 -> 4184;
4336 -> 4181;
4336 -> 4178;
4337 -> 3376;
4337 -> 3347;
4337 -> 4336;
4337 -> 3346;
4337 -> 4249;
4337 -> 4250;
4337 -> 4255;
4337 -> 4251;
4337 -> 4252;
4337 -> 4178;
4338 -> 4178;
4339 -> 4181;
4339 -> 4338;
4340 -> 4338;
4341 -> 4339;
4341 -> 4340;
4342 -> 4341;
4342 -> 4337;
4342 -> 4340;
4343 -> 4342;
4343 -> 0;
4343 -> 4338;
4344 -> 4338;
4345 -> 4343;
4345 -> 4344;
4345 -> 4338;
4346 -> 4345;
4346 -> 4178;
4347 -> 4064;
4347 -> 4178;
4348 -> 4178;
4349 -> 4178;
4350 -> 4346;
4350 -> 4349;
4351 -> 4347;
4351 -> 4349;
4352 -> 4348;
4352 -> 4349;
4353 -> 3376;
4353 -> 4349;
4354 -> 4350;
4354 -> 4349;
4355 -> 4349;
4356 -> 4354;
4356 -> 4355;
4357 -> 4353;
4357 -> 4355;
4358 -> 4356;
4358 -> 4355;
4359 -> 4357;
4359 -> 3358;
4359 -> 4358;
4360 -> 4357;
4360 -> 4359;
4360 -> 4355;
4361 -> 4352;
4361 -> 4349;
4362 -> 4349;
4363 -> 4361;
4363 -> 4362;
4364 -> 4351;
4364 -> 4362;
4365 -> 4363;
4365 -> 4337;
4365 -> 4362;
4366 -> 4362;
4367 -> 4365;
4367 -> 4366;
4368 -> 4365;
4368 -> 4366;
4369 -> 4364;
4369 -> 4366;
4370 -> 4366;
4371 -> 4369;
4371 -> 4370;
4372 -> 4370;
4373 -> 4371;
4373 -> 4372;
4373 -> 4337;
4373 -> 4370;
4374 -> 4373;
4374 -> 4370;
4375 -> 4374;
4375 -> 4366;
4376 -> 4368;
4376 -> 4366;
4377 -> 4367;
4377 -> 4376;
4377 -> 4373;
4377 -> 4337;
4377 -> 4366;
4378 -> 4366;
4379 -> 4369;
4379 -> 4378;
4380 -> 4379;
4380 -> 4377;
4380 -> 4378;
4381 -> 4366;
4382 -> 4380;
4382 -> 4375;
4382 -> 4366;
4383 -> 4360;
4383 -> 4382;
4383 -> 4349;
4384 -> 4178;
4385 -> 3380;
4385 -> 4384;
4386 -> 4384;
4387 -> 4385;
4387 -> 4377;
4387 -> 4386;
4387 -> 4384;
4388 -> 4387;
4388 -> 0;
4388 -> 4384;
4389 -> 4388;
4389 -> 4178;
4390 -> 4178;
4391 -> 4178;
4391 -> 4387;
4391 -> 4390;
4392 -> 4387;
4393 -> 4387;
4394 -> 4387;
4395 -> 4387;
4396 -> 3379;
4396 -> 4387;
4397 -> 4396;
4397 -> 4387;
4398 -> 4395;
4398 -> 4387;
4399 -> 4387;
4400 -> 4397;
4400 -> 4387;
4401 -> 4398;
4401 -> 4387;
4402 -> 4400;
4402 -> 4387;
4403 -> 4387;
4404 -> 4387;
4405 -> 4387;
4406 -> 4403;
4406 -> 4387;
4407 -> 4404;
4407 -> 4387;
4408 -> 4402;
4408 -> 4387;
4409 -> 4387;
4410 -> 4405;
4410 -> 4409;
4411 -> 4405;
4411 -> 4409;
4412 -> 4405;
4412 -> 4409;
4413 -> 4406;
4413 -> 4409;
4414 -> 4407;
4414 -> 4409;
4415 -> 4408;
4415 -> 4409;
4416 -> 4412;
4416 -> 4411;
4416 -> 4409;
4417 -> 4409;
4418 -> 4387;
4418 -> 0;
4419 -> 4399;
4419 -> 4387;
4420 -> 4400;
4420 -> 4387;
4421 -> 4399;
4421 -> 4387;
4422 -> 4401;
4422 -> 4387;
4423 -> 4387;
4424 -> 4387;
4425 -> 4424;
4425 -> 0;
4425 -> 4387;
4426 -> 4387;
4426 -> 0;
4427 -> 4387;
4428 -> 4399;
4428 -> 0;
4428 -> 4387;
4429 -> 4387;
4430 -> 4399;
4430 -> 0;
4430 -> 4387;
4431 -> 4387;
4432 -> 4399;
4432 -> 0;
4432 -> 4387;
4433 -> 4387;
4434 -> 4387;
4434 -> 4432;
4435 -> 4399;
4435 -> 4432;
4436 -> 4397;
4436 -> 4432;
4437 -> 4432;
4438 -> 4434;
4438 -> 4437;
4439 -> 4435;
4439 -> 4437;
4440 -> 4434;
4440 -> 4437;
4441 -> 4436;
4441 -> 4437;
4442 -> 4439;
4442 -> 0;
4442 -> 4437;
4443 -> 4432;
4444 -> 4423;
4444 -> 4399;
4445 -> 3379;
4445 -> 4399;
4446 -> 4444;
4446 -> 4399;
4447 -> 4445;
4447 -> 4399;
4448 -> 4399;
4449 -> 4399;
4450 -> 4399;
4451 -> 4399;
4452 -> 4399;
4453 -> 4399;
4454 -> 4399;
4455 -> 4399;
4456 -> 4399;
4457 -> 4447;
4457 -> 4399;
4458 -> 4399;
4459 -> 4457;
4459 -> 4458;
4460 -> 4399;
4460 -> 4458;
4461 -> 4458;
4462 -> 4460;
4462 -> 4461;
4463 -> 4462;
4463 -> 4399;
4463 -> 4461;
4464 -> 4463;
4464 -> 4458;
4465 -> 4460;
4465 -> 4458;
4466 -> 4458;
4467 -> 4458;
4468 -> 4464;
4468 -> 4467;
4469 -> 4465;
4469 -> 4467;
4470 -> 4466;
4470 -> 4467;
4471 -> 4468;
4471 -> 4467;
4472 -> 4467;
4473 -> 4471;
4473 -> 4472;
4474 -> 4473;
4474 -> 0;
4474 -> 4472;
4475 -> 4474;
4476 -> 4467;
4477 -> 4469;
4477 -> 4476;
4478 -> 0;
4478 -> 4476;
4479 -> 4478;
4479 -> 4467;
4480 -> 4470;
4480 -> 4479;
4480 -> 4467;
4481 -> 4468;
4481 -> 0;
4481 -> 4467;
4482 -> 4467;
4483 -> 4480;
4483 -> 4481;
4483 -> 4467;
4484 -> 4467;
4485 -> 4484;
4485 -> 4458;
4486 -> 4458;
4487 -> 4485;
4487 -> 4486;
4487 -> 4458;
4488 -> 4399;
4489 -> 4446;
4489 -> 4399;
4490 -> 4447;
4490 -> 4489;
4491 -> 4489;
4492 -> 4490;
4492 -> 4491;
4493 -> 4399;
4493 -> 4491;
4494 -> 4491;
4495 -> 4493;
4495 -> 4494;
4496 -> 4495;
4496 -> 4399;
4496 -> 4494;
4497 -> 4496;
4497 -> 4491;
4498 -> 4491;
4499 -> 4497;
4499 -> 4498;
4500 -> 0;
4500 -> 4498;
4501 -> 4498;
4502 -> 4500;
4502 -> 4501;
4503 -> 4499;
4503 -> 4501;
4504 -> 4503;
4504 -> 4399;
4504 -> 4502;
4504 -> 4501;
4505 -> 4501;
4506 -> 4504;
4506 -> 4505;
4506 -> 4501;
4507 -> 4506;
4508 -> 4493;
4508 -> 4507;
4509 -> 4507;
4510 -> 4508;
4510 -> 4509;
4511 -> 4510;
4511 -> 4399;
4511 -> 4509;
4512 -> 4511;
4512 -> 0;
4512 -> 4507;
4513 -> 4507;
4514 -> 4512;
4514 -> 4513;
4514 -> 4507;
4515 -> 4514;
4515 -> 4506;
4516 -> 4515;
4517 -> 4493;
4517 -> 4399;
4517 -> 4516;
4518 -> 0;
4518 -> 4516;
4519 -> 4516;
4520 -> 4518;
4520 -> 4519;
4521 -> 4517;
4521 -> 4519;
4522 -> 4521;
4522 -> 4399;
4522 -> 4520;
4522 -> 4519;
4523 -> 4522;
4523 -> 4515;
4524 -> 4523;
4525 -> 4493;
4525 -> 4524;
4526 -> 4524;
4527 -> 4525;
4527 -> 4526;
4528 -> 4527;
4528 -> 0;
4528 -> 4524;
4529 -> 4524;
4530 -> 4528;
4530 -> 4529;
4530 -> 4524;
4531 -> 4530;
4531 -> 4523;
4532 -> 4489;
4533 -> 4399;
4534 -> 4533;
4534 -> 4399;
4535 -> 4387;
4536 -> 4399;
4536 -> 4535;
4537 -> 4535;
4538 -> 4536;
4538 -> 4537;
4539 -> 4538;
4539 -> 4399;
4539 -> 4537;
4540 -> 4539;
4540 -> 0;
4540 -> 4535;
4541 -> 4535;
4542 -> 4540;
4542 -> 4541;
4542 -> 4535;
4543 -> 4542;
4543 -> 4387;
4544 -> 3376;
4544 -> 4387;
4545 -> 4543;
4545 -> 4387;
4546 -> 4387;
4547 -> 4545;
4547 -> 4546;
4548 -> 4544;
4548 -> 4546;
4549 -> 4547;
4549 -> 4546;
4550 -> 4548;
4550 -> 4359;
4550 -> 4549;
4551 -> 4548;
4551 -> 4550;
4551 -> 4546;
4552 -> 4399;
4552 -> 4387;
4553 -> 4387;
4554 -> 4553;
4554 -> 4552;
4555 -> 4551;
4555 -> 4554;
4555 -> 4387;
4556 -> 4552;
4556 -> 0;
4556 -> 4387;
4557 -> 4556;
4557 -> 4387;
4558 -> 4387;
4559 -> 4387;
4559 -> 4552;
4559 -> 4558;
4560 -> 3376;
4560 -> 3351;
4560 -> 3375;
4561 -> 3377;
4561 -> 3375;
4562 -> 3375;
4563 -> 4560;
4563 -> 4562;
4564 -> 4561;
4564 -> 4562;
4565 -> 4562;
4566 -> 4564;
4566 -> 4565;
4566 -> 4562;
4567 -> 3375;
4568 -> 3376;
4568 -> 3349;
4568 -> 3375;
4569 -> 4053;
4569 -> 3375;
4570 -> 3375;
4571 -> 4568;
4571 -> 4570;
4572 -> 4569;
4572 -> 4570;
4573 -> 4570;
4574 -> 4572;
4574 -> 4573;
4574 -> 4570;
4575 -> 3375;
4576 -> 3340;
4577 -> 3340;
4578 -> 3342;
4578 -> 4577;
4579 -> 4577;
4580 -> 4578;
4580 -> 4552;
4580 -> 4579;
4581 -> 4580;
4581 -> 3340;
4582 -> 3340;
4583 -> 3342;
4583 -> 4582;
4584 -> 4582;
4585 -> 4584;
4585 -> 4582;
4586 -> 4582;
4587 -> 4585;
4587 -> 4586;
4588 -> 4583;
4588 -> 4586;
4589 -> 4586;
4590 -> 4588;
4590 -> 4589;
4591 -> 4589;
4592 -> 4591;
4592 -> 4586;
4593 -> 4586;
4594 -> 4588;
4594 -> 4593;
4595 -> 4594;
4595 -> 4552;
4595 -> 4593;
4596 -> 4595;
4596 -> 4586;
4597 -> 4586;
4598 -> 4596;
4598 -> 4597;
4599 -> 0;
4599 -> 4597;
4600 -> 4599;
4600 -> 4586;
4601 -> 4592;
4601 -> 4600;
4601 -> 4586;
4602 -> 4586;
4603 -> 4588;
4603 -> 4602;
4604 -> 4602;
4605 -> 4603;
4605 -> 4604;
4606 -> 4605;
4606 -> 4552;
4606 -> 4604;
4607 -> 4606;
4607 -> 4602;
4608 -> 4602;
4609 -> 4607;
4610 -> 4607;
4611 -> 4609;
4611 -> 4610;
4611 -> 4607;
4612 -> 4609;
4612 -> 4611;
4613 -> 4612;
4613 -> 4586;
4614 -> 4586;
4615 -> 4613;
4615 -> 4614;
4616 -> 4614;
4617 -> 4615;
4617 -> 4616;
4618 -> 4617;
4618 -> 4552;
4618 -> 4616;
4619 -> 4614;
4620 -> 4618;
4621 -> 4618;
4621 -> 4620;
4622 -> 4621;
4622 -> 4552;
4622 -> 4620;
4623 -> 4622;
4624 -> 4622;
4625 -> 4614;
4626 -> 4625;
4626 -> 4586;
4627 -> 4586;
4628 -> 4601;
4628 -> 4626;
4628 -> 4586;
4629 -> 4586;
4630 -> 4586;
4631 -> 4630;
4631 -> 3340;
4632 -> 3342;
4632 -> 4552;
4632 -> 3340;
4633 -> 4632;
4633 -> 2807;
4633 -> 3340;
4634 -> 3340;
4635 -> 3343;
4635 -> 4634;
4636 -> 4635;
4636 -> 3347;
4636 -> 4632;
4636 -> 4634;
4637 -> 4635;
4637 -> 3349;
4637 -> 4634;
4638 -> 4634;
4639 -> 4637;
4639 -> 4638;
4640 -> 4638;
4641 -> 4639;
4641 -> 3348;
4641 -> 4640;
4641 -> 4638;
4642 -> 4639;
4642 -> 3348;
4642 -> 4641;
4643 -> 0;
4643 -> 4641;
4644 -> 4635;
4644 -> 3351;
4644 -> 4634;
4645 -> 4634;
4646 -> 4644;
4646 -> 4645;
4647 -> 4645;
4648 -> 4646;
4648 -> 3350;
4648 -> 4647;
4648 -> 4645;
4649 -> 4646;
4649 -> 3350;
4649 -> 4648;
4650 -> 0;
4650 -> 4648;
4651 -> 4635;
4651 -> 3352;
4651 -> 4634;
4652 -> 4635;
4652 -> 3353;
4652 -> 4634;
4653 -> 4635;
4653 -> 3354;
4653 -> 4634;
4654 -> 4635;
4654 -> 3356;
4654 -> 4634;
4655 -> 4635;
4655 -> 3357;
4655 -> 4634;
4656 -> 4635;
4656 -> 4550;
4656 -> 4634;
4657 -> 4634;
4658 -> 4634;
4659 -> 4636;
4659 -> 4658;
4660 -> 4643;
4660 -> 4658;
4661 -> 4650;
4661 -> 4658;
4662 -> 4651;
4662 -> 4658;
4663 -> 4652;
4663 -> 4658;
4664 -> 4653;
4664 -> 4658;
4665 -> 4654;
4665 -> 4658;
4666 -> 4655;
4666 -> 4658;
4667 -> 4656;
4667 -> 4658;
4668 -> 4657;
4668 -> 4658;
4669 -> 4668;
4669 -> 4658;
4670 -> 4668;
4670 -> 4658;
4671 -> 4668;
4671 -> 4658;
4672 -> 4668;
4672 -> 4658;
4673 -> 4668;
4673 -> 4658;
4674 -> 4668;
4674 -> 4658;
4675 -> 4659;
4675 -> 4636;
4675 -> 4658;
4676 -> 4660;
4676 -> 0;
4676 -> 4658;
4677 -> 4661;
4677 -> 0;
4677 -> 4658;
4678 -> 4659;
4678 -> 4658;
4679 -> 4658;
4680 -> 4663;
4680 -> 4664;
4680 -> 4658;
4681 -> 4659;
4681 -> 4668;
4681 -> 4658;
4682 -> 4660;
4682 -> 4668;
4682 -> 4658;
4683 -> 4661;
4683 -> 4668;
4683 -> 4658;
4684 -> 4662;
4684 -> 4668;
4684 -> 4658;
4685 -> 4663;
4685 -> 4668;
4685 -> 4658;
4686 -> 4664;
4686 -> 4668;
4686 -> 4658;
4687 -> 4665;
4687 -> 4668;
4687 -> 4658;
4688 -> 4666;
4688 -> 4668;
4688 -> 4658;
4689 -> 4667;
4689 -> 4668;
4689 -> 4658;
4690 -> 4657;
4690 -> 3340;
4691 -> 4690;
4691 -> 3333;
4692 -> 3334;
4692 -> 4678;
4692 -> 3333;
4693 -> 4691;
4693 -> 3333;
4694 -> 2807;
4694 -> 3333;
4695 -> 4692;
4695 -> 4693;
4695 -> 4694;
4695 -> 4684;
4695 -> 4685;
4695 -> 4686;
4695 -> 4687;
4695 -> 4688;
4695 -> 4689;
4695 -> 4681;
4695 -> 4682;
4695 -> 4683;
4695 -> 2801;
4695 -> 2802;
4695 -> 2803;
4695 -> 2804;
4695 -> 2805;
4695 -> 2806;
4695 -> 4678;
4695 -> 4636;
4695 -> 0;
4695 -> 3333;
4696 -> 4695;
4696 -> 2807;
4696 -> 3333;
4697 -> 3338;
4697 -> 3333;
4698 -> 3333;
4699 -> 4697;
4699 -> 4698;
4700 -> 3334;
4700 -> 4698;
4701 -> 4698;
4702 -> 4700;
4702 -> 4701;
4703 -> 4702;
4703 -> 4695;
4703 -> 4701;
4704 -> 4703;
4704 -> 4698;
4705 -> 4699;
4705 -> 3338;
4705 -> 4698;
4706 -> 3333;
4707 -> 3338;
4707 -> 3333;
4708 -> 4691;
4708 -> 3333;
4709 -> 4708;
4709 -> 3330;
4710 -> 4709;
4710 -> 3330;
4711 -> 4709;
4711 -> 3330;
4712 -> 3330;
4713 -> 3330;
4714 -> 4711;
4714 -> 4713;
4715 -> 4712;
4715 -> 4713;
4716 -> 4715;
4716 -> 4713;
4717 -> 4715;
4717 -> 4713;
4718 -> 4715;
4718 -> 4713;
4719 -> 4715;
4719 -> 4713;
4720 -> 4714;
4720 -> 2807;
4720 -> 4713;
4721 -> 4714;
4721 -> 4695;
4721 -> 4715;
4721 -> 4713;
4722 -> 4714;
4722 -> 4695;
4722 -> 4715;
4722 -> 4713;
4723 -> 4712;
4723 -> 3330;
4724 -> 4709;
4724 -> 3330;
4725 -> 3331;
4725 -> 3330;
4726 -> 3330;
4727 -> 4723;
4727 -> 4726;
4728 -> 4724;
4728 -> 4726;
4729 -> 4725;
4729 -> 4726;
4730 -> 3332;
4730 -> 4726;
4731 -> 4726;
4732 -> 4730;
4732 -> 4731;
4733 -> 4731;
4734 -> 4732;
4734 -> 4695;
4734 -> 4733;
4735 -> 4734;
4735 -> 4726;
4736 -> 4727;
4736 -> 4735;
4737 -> 4728;
4737 -> 4735;
4738 -> 4729;
4738 -> 4735;
4739 -> 4735;
4740 -> 4736;
4740 -> 4739;
4741 -> 4737;
4741 -> 4739;
4742 -> 4738;
4742 -> 4739;
4743 -> 4730;
4743 -> 4739;
4744 -> 4743;
4744 -> 4695;
4744 -> 0;
4744 -> 4739;
4745 -> 4744;
4746 -> 4735;
4747 -> 4727;
4747 -> 4735;
4748 -> 4728;
4748 -> 4735;
4749 -> 4729;
4749 -> 4735;
4750 -> 4735;
4751 -> 4747;
4751 -> 4750;
4752 -> 4748;
4752 -> 4750;
4753 -> 4749;
4753 -> 4750;
4754 -> 4730;
4754 -> 4750;
4755 -> 4750;
4756 -> 4750;
4757 -> 4750;
4758 -> 4752;
4758 -> 4750;
4759 -> 4750;
4760 -> 4758;
4760 -> 4759;
4761 -> 4751;
4761 -> 4759;
4762 -> 4760;
4762 -> 4695;
4762 -> 4759;
4763 -> 4762;
4763 -> 4761;
4763 -> 4716;
4763 -> 4759;
4764 -> 4763;
4764 -> 4750;
4765 -> 4764;
4766 -> 4764;
4766 -> 4765;
4767 -> 0;
4767 -> 4765;
4768 -> 4767;
4768 -> 4764;
4769 -> 4755;
4769 -> 4764;
4774 -> 4770;
4774 -> 4773;
4775 -> 4771;
4775 -> 4773;
4776 -> 4772;
4776 -> 4773;
4777 -> 4773;
4778 -> 0;
4779 -> 4778;
4780 -> 0;
4781 -> 4780;
4782 -> 0;
4783 -> 4782;
4784 -> 0;
4785 -> 4784;
4786 -> 4754;
4786 -> 4750;
4787 -> 4750;
4788 -> 4786;
4788 -> 4787;
4789 -> 4787;
4790 -> 4788;
4790 -> 4789;
4790 -> 4787;
4791 -> 4787;
4792 -> 4788;
4792 -> 4791;
4793 -> 4792;
4793 -> 4787;
4794 -> 4756;
4794 -> 4793;
4794 -> 4750;
4795 -> 4750;
4796 -> 4754;
4796 -> 4795;
4797 -> 0;
4797 -> 4795;
4798 -> 4795;
4799 -> 4797;
4799 -> 4798;
4800 -> 4796;
4800 -> 4798;
4801 -> 4800;
4801 -> 4695;
4801 -> 4799;
4801 -> 4798;
4802 -> 4798;
4803 -> 4801;
4803 -> 4802;
4803 -> 4798;
4804 -> 4803;
4804 -> 4750;
4805 -> 4755;
4805 -> 4804;
4805 -> 4750;
4806 -> 4750;
4807 -> 4754;
4807 -> 4806;
4808 -> 4807;
4808 -> 4750;
4809 -> 4805;
4809 -> 4808;
4809 -> 4750;
4810 -> 4794;
4810 -> 4809;
4810 -> 4750;
4811 -> 4810;
4812 -> 4811;
4812 -> 4810;
4813 -> 4812;
4813 -> 4810;
4814 -> 4813;
4815 -> 4813;
4815 -> 4814;
4816 -> 4813;
4816 -> 4814;
4817 -> 4814;
4818 -> 4816;
4818 -> 4817;
4820 -> 4819;
4821 -> 4817;
4822 -> 4818;
4822 -> 4821;
4823 -> 4821;
4824 -> 4822;
4824 -> 4821;
4825 -> 4822;
4825 -> 4821;
4826 -> 4818;
4826 -> 4817;
4827 -> 4816;
4827 -> 4814;
4828 -> 4814;
4829 -> 4815;
4829 -> 4828;
4829 -> 4814;
4830 -> 4815;
4830 -> 4816;
4830 -> 4814;
4831 -> 4752;
4831 -> 4810;
4832 -> 4810;
4833 -> 4813;
4833 -> 4832;
4834 -> 4831;
4834 -> 4832;
4835 -> 4751;
4835 -> 4832;
4836 -> 4835;
4836 -> 4716;
4836 -> 4832;
4837 -> 4836;
4838 -> 4834;
4838 -> 4695;
4838 -> 4837;
4838 -> 4836;
4839 -> 4838;
4839 -> 4835;
4839 -> 4836;
4840 -> 4834;
4840 -> 4695;
4840 -> 4836;
4841 -> 4835;
4841 -> 4839;
4841 -> 4840;
4841 -> 4838;
4841 -> 4695;
4841 -> 4836;
4842 -> 4833;
4842 -> 4832;
4843 -> 4835;
4843 -> 4839;
4843 -> 4842;
4843 -> 4841;
4843 -> 4822;
4843 -> 4824;
4843 -> 4825;
4843 -> 4826;
4843 -> 4830;
4843 -> 4832;
4844 -> 4810;
4845 -> 4752;
4845 -> 4843;
4845 -> 4750;
4846 -> 4750;
4847 -> 4845;
4847 -> 4846;
4848 -> 4847;
4848 -> 4846;
4849 -> 4846;
4850 -> 4757;
4850 -> 4848;
4850 -> 4750;
4851 -> 4750;
4852 -> 4754;
4852 -> 4851;
4853 -> 4852;
4853 -> 4848;
4853 -> 4851;
4854 -> 4853;
4854 -> 0;
4854 -> 4851;
4855 -> 4854;
4855 -> 4750;
4856 -> 4735;
4857 -> 3330;
4858 -> 3332;
4858 -> 4853;
4858 -> 3330;
4859 -> 3330;
4860 -> 4709;
4860 -> 3330;
4861 -> 3330;
4862 -> 4860;
4862 -> 4861;
4863 -> 4712;
4863 -> 4861;
4864 -> 4863;
4864 -> 4839;
4864 -> 4858;
4864 -> 4861;
4865 -> 4863;
4865 -> 4717;
4865 -> 4861;
4866 -> 4865;
4866 -> 4861;
4867 -> 4862;
4867 -> 4858;
4867 -> 4866;
4868 -> 4864;
4868 -> 4861;
4869 -> 4862;
4869 -> 4858;
4869 -> 4861;
4870 -> 4867;
4870 -> 4861;
4871 -> 4863;
4871 -> 4721;
4871 -> 4861;
4872 -> 4863;
4872 -> 4722;
4872 -> 4861;
4873 -> 4861;
4874 -> 4861;
4875 -> 4868;
4875 -> 4874;
4876 -> 4869;
4876 -> 4874;
4877 -> 4870;
4877 -> 4874;
4878 -> 4869;
4878 -> 4874;
4879 -> 4871;
4879 -> 4874;
4880 -> 4872;
4880 -> 4874;
4881 -> 4873;
4881 -> 4874;
4882 -> 4881;
4882 -> 4874;
4883 -> 4881;
4883 -> 4874;
4884 -> 4881;
4884 -> 4874;
4885 -> 4875;
4885 -> 4864;
4885 -> 4874;
4886 -> 4876;
4886 -> 4858;
4886 -> 4874;
4887 -> 4876;
4887 -> 4874;
4888 -> 4874;
4889 -> 4887;
4889 -> 4888;
4889 -> 4858;
4889 -> 4867;
4889 -> 4874;
4890 -> 4877;
4890 -> 4858;
4890 -> 4874;
4891 -> 4877;
4891 -> 4874;
4892 -> 4874;
4893 -> 4891;
4893 -> 4892;
4893 -> 4858;
4893 -> 4867;
4893 -> 4889;
4893 -> 4874;
4894 -> 4875;
4894 -> 4874;
4895 -> 4874;
4896 -> 4894;
4896 -> 4895;
4896 -> 4864;
4896 -> 4893;
4896 -> 4874;
4897 -> 4875;
4897 -> 4874;
4898 -> 4874;
4899 -> 4897;
4899 -> 4898;
4899 -> 4864;
4899 -> 4896;
4899 -> 4874;
4900 -> 4878;
4900 -> 4899;
4900 -> 4874;
4901 -> 4900;
4901 -> 4898;
4902 -> 4898;
4903 -> 4901;
4903 -> 4902;
4904 -> 0;
4904 -> 4902;
4905 -> 4904;
4905 -> 4898;
4906 -> 4900;
4906 -> 4905;
4906 -> 4874;
4907 -> 4901;
4907 -> 4902;
4908 -> 0;
4908 -> 4902;
4909 -> 4908;
4909 -> 4898;
4910 -> 4900;
4910 -> 4909;
4910 -> 4906;
4910 -> 4874;
4911 -> 4900;
4911 -> 4905;
4911 -> 4909;
4911 -> 4874;
4912 -> 4875;
4912 -> 4881;
4912 -> 4874;
4913 -> 4876;
4913 -> 4881;
4913 -> 4874;
4914 -> 4877;
4914 -> 4881;
4914 -> 4874;
4915 -> 4878;
4915 -> 4881;
4915 -> 4874;
4916 -> 4879;
4916 -> 4881;
4916 -> 4874;
4917 -> 4880;
4917 -> 4881;
4917 -> 4874;
4918 -> 4873;
4918 -> 3330;
4919 -> 4918;
4919 -> 3323;
4920 -> 3324;
4920 -> 4899;
4920 -> 3323;
4921 -> 4919;
4921 -> 3323;
4922 -> 3323;
4923 -> 4920;
4923 -> 4921;
4923 -> 4922;
4923 -> 4915;
4923 -> 4916;
4923 -> 4917;
4923 -> 4912;
4923 -> 4913;
4923 -> 4914;
4923 -> 4899;
4923 -> 4864;
4923 -> 4858;
4923 -> 4867;
4923 -> 3323;
4924 -> 3323;
4925 -> 4923;
4925 -> 4924;
4925 -> 3323;
4926 -> 3328;
4926 -> 3323;
4927 -> 3323;
4928 -> 4926;
4928 -> 4927;
4929 -> 3324;
4929 -> 4927;
4930 -> 4927;
4931 -> 4929;
4931 -> 4930;
4932 -> 4931;
4932 -> 4923;
4932 -> 4930;
4933 -> 4932;
4933 -> 4927;
4934 -> 4928;
4934 -> 3328;
4934 -> 4927;
4935 -> 3323;
4936 -> 3328;
4936 -> 3323;
4937 -> 3323;
4938 -> 4937;
4938 -> 3324;
4938 -> 3323;
4939 -> 4919;
4939 -> 3323;
4940 -> 4939;
4940 -> 3319;
4941 -> 3319;
4942 -> 3321;
4942 -> 4941;
4943 -> 4941;
4944 -> 4943;
4944 -> 4941;
4945 -> 4941;
4946 -> 4944;
4946 -> 4945;
4947 -> 4942;
4947 -> 4945;
4948 -> 4945;
4949 -> 4947;
4949 -> 4948;
4950 -> 4948;
4951 -> 4950;
4951 -> 4945;
4952 -> 4945;
4953 -> 4947;
4953 -> 4952;
4954 -> 4953;
4954 -> 4923;
4954 -> 4952;
4955 -> 4954;
4955 -> 4945;
4956 -> 4945;
4957 -> 4955;
4957 -> 4956;
4958 -> 0;
4958 -> 4956;
4959 -> 4958;
4959 -> 4945;
4960 -> 4951;
4960 -> 4959;
4960 -> 4945;
4961 -> 4945;
4962 -> 4947;
4962 -> 4961;
4963 -> 4961;
4964 -> 4962;
4964 -> 4963;
4965 -> 4964;
4965 -> 4923;
4965 -> 4963;
4966 -> 4965;
4966 -> 4961;
4967 -> 4961;
4968 -> 4966;
4969 -> 4966;
4970 -> 4968;
4970 -> 4969;
4970 -> 4966;
4971 -> 4968;
4971 -> 4970;
4972 -> 4971;
4972 -> 4945;
4973 -> 4945;
4974 -> 4972;
4974 -> 4973;
4975 -> 4973;
4976 -> 4974;
4976 -> 4975;
4977 -> 4976;
4977 -> 4923;
4977 -> 4975;
4978 -> 4973;
4979 -> 4977;
4980 -> 4977;
4980 -> 4979;
4981 -> 4980;
4981 -> 4923;
4981 -> 4979;
4982 -> 4981;
4983 -> 4981;
4984 -> 4973;
4985 -> 4984;
4985 -> 4945;
4986 -> 4945;
4987 -> 4960;
4987 -> 4985;
4987 -> 4945;
4988 -> 4945;
4989 -> 4945;
4990 -> 4989;
4990 -> 3319;
4991 -> 4940;
4991 -> 4923;
4991 -> 4990;
4991 -> 3319;
4992 -> 4940;
4992 -> 4923;
4992 -> 4991;
4993 -> 4991;
4994 -> 0;
4994 -> 4991;
4995 -> 4992;
4995 -> 4993;
4995 -> 4994;
4995 -> 4923;
4995 -> 4938;
4995 -> 4991;
4996 -> 4995;
4996 -> 4993;
4997 -> 4996;
4997 -> 4995;
4997 -> 4993;
4998 -> 4995;
4998 -> 4993;
4999 -> 0;
4999 -> 4993;
5000 -> 4995;
5000 -> 4999;
5000 -> 4997;
5000 -> 4991;
5001 -> 5000;
5001 -> 4991;
5002 -> 4991;
5003 -> 3321;
5003 -> 5002;
5004 -> 5002;
5005 -> 5003;
5005 -> 5000;
5005 -> 5004;
5005 -> 5002;
5006 -> 5005;
5007 -> 5003;
5007 -> 5000;
5007 -> 5005;
5008 -> 5006;
5008 -> 5005;
5009 -> 5005;
5010 -> 5008;
5010 -> 5009;
5011 -> 5003;
5011 -> 5009;
5012 -> 5009;
5013 -> 5009;
5014 -> 5011;
5014 -> 5000;
5014 -> 5009;
5015 -> 5009;
5016 -> 5011;
5016 -> 5015;
5017 -> 5016;
5017 -> 5009;
5018 -> 5009;
5019 -> 2660;
5019 -> 2659;
5019 -> 5018;
5019 -> 5009;
5020 -> 5009;
5021 -> 5012;
5021 -> 5020;
5021 -> 5009;
5022 -> 5021;
5022 -> 5009;
5023 -> 2660;
5023 -> 5022;
5024 -> 5012;
5024 -> 5009;
5025 -> 5023;
5025 -> 5005;
5026 -> 5005;
5027 -> 5006;
5027 -> 5025;
5028 -> 5025;
5029 -> 5027;
5029 -> 5028;
5030 -> 5003;
5030 -> 5028;
5031 -> 5028;
5032 -> 5030;
5032 -> 5031;
5033 -> 5032;
5033 -> 5028;
5034 -> 5029;
5034 -> 5006;
5034 -> 5028;
5035 -> 5025;
5036 -> 0;
5036 -> 5025;
5037 -> 5025;
5038 -> 5036;
5038 -> 5037;
5039 -> 5006;
5039 -> 5005;
5040 -> 5003;
5040 -> 5025;
5040 -> 5002;
5041 -> 5040;
5041 -> 4991;
5042 -> 4991;
5043 -> 5001;
5043 -> 5042;
5044 -> 5041;
5044 -> 5042;
5045 -> 5044;
5045 -> 5042;
5046 -> 5045;
5046 -> 5025;
5046 -> 5038;
5046 -> 5042;
5047 -> 4991;
5048 -> 5000;
5048 -> 3319;
5049 -> 3320;
5049 -> 3319;
5050 -> 3319;
5051 -> 5048;
5051 -> 5050;
5052 -> 5049;
5052 -> 5050;
5053 -> 3321;
5053 -> 5050;
5054 -> 5051;
5054 -> 5025;
5054 -> 5050;
5055 -> 5051;
5055 -> 5025;
5055 -> 5050;
5056 -> 5054;
5056 -> 5055;
5056 -> 5025;
5056 -> 5038;
5056 -> 5050;
5057 -> 2123;
5057 -> 5050;
5058 -> 5054;
5058 -> 5050;
5059 -> 5058;
5059 -> 5056;
5059 -> 5050;
5060 -> 5057;
5060 -> 2113;
5060 -> 2114;
5060 -> 2115;
5060 -> 2116;
5060 -> 2117;
5060 -> 2118;
5060 -> 2119;
5060 -> 5059;
5061 -> 5051;
5061 -> 5059;
5061 -> 5056;
5062 -> 5061;
5063 -> 5062;
5063 -> 5061;
5064 -> 5057;
5064 -> 5060;
5064 -> 5061;
5065 -> 5057;
5065 -> 5060;
5065 -> 5061;
5066 -> 5057;
5066 -> 5065;
5066 -> 5061;
5067 -> 5054;
5067 -> 5061;
5068 -> 3319;
5069 -> 5051;
5069 -> 3319;
5070 -> 5069;
5070 -> 3316;
5071 -> 3314;
5071 -> 5067;
5071 -> 3316;
5072 -> 5070;
5072 -> 3316;
5073 -> 3316;
5074 -> 5071;
5074 -> 5072;
5074 -> 5073;
5074 -> 5067;
5074 -> 3316;
5075 -> 3317;
5075 -> 5074;
5076 -> 5074;
5077 -> 5075;
5077 -> 5076;
5078 -> 3314;
5078 -> 5076;
5079 -> 5076;
5080 -> 5078;
5080 -> 5079;
5081 -> 5080;
5081 -> 5076;
5082 -> 5077;
5082 -> 3317;
5082 -> 5076;
5083 -> 5074;
5084 -> 0;
5084 -> 5074;
5085 -> 5074;
5086 -> 5084;
5086 -> 5085;
5087 -> 3317;
5087 -> 3316;
5088 -> 0;
5088 -> 3313;
5089 -> 3313;
5090 -> 3313;
5091 -> 5088;
5091 -> 5090;
5092 -> 5089;
5092 -> 5090;
5093 -> 3314;
5093 -> 5074;
5093 -> 5090;
5094 -> 5091;
5094 -> 5090;
5095 -> 5090;
5096 -> 5094;
5096 -> 5095;
5097 -> 5093;
5097 -> 5095;
5098 -> 5097;
5098 -> 5074;
5098 -> 5086;
5098 -> 5096;
5098 -> 5095;
5099 -> 5098;
5100 -> 3314;
5100 -> 5074;
5100 -> 3313;
5101 -> 5100;
5101 -> 3306;
5102 -> 5101;
5102 -> 3301;
5103 -> 3302;
5103 -> 3301;
5104 -> 3304;
5104 -> 3301;
5105 -> 5102;
5105 -> 5103;
5105 -> 5104;
5105 -> 5074;
5105 -> 5086;
5105 -> 3305;
5105 -> 3301;
5106 -> 5105;
5107 -> 1;
5108 -> 5106;
5108 -> 5107;
5109 -> 5107;
5110 -> 5108;
5110 -> 5109;
5111 -> 0;
5111 -> 5109;
5112 -> 5109;
5113 -> 5111;
5113 -> 5112;
5114 -> 5110;
5114 -> 5112;
5115 -> 5112;
5116 -> 5113;
5116 -> 5115;
5116 -> 5112;
5117 -> 5112;
5118 -> 5114;
5118 -> 5106;
5118 -> 5117;
5118 -> 5112;
5119 -> 5112;
5120 -> 5114;
5120 -> 5119;
5121 -> 5119;
5122 -> 5120;
5122 -> 5121;
5123 -> 5121;
5124 -> 5122;
5124 -> 5106;
5124 -> 5123;
5124 -> 5121;
5125 -> 5124;
5125 -> 5119;
5126 -> 5125;
5126 -> 5112;
5127 -> 5126;
5127 -> 5112;
5128 -> 5112;
5129 -> 5127;
5129 -> 5128;
5130 -> 5129;
5130 -> 5124;
5130 -> 5128;
5131 -> 5130;
5131 -> 5124;
5131 -> 5112;
5132 -> 5112;
5133 -> 5114;
5133 -> 5132;
5134 -> 5132;
5135 -> 5133;
5135 -> 5134;
5136 -> 0;
5136 -> 5134;
5137 -> 5136;
5137 -> 5132;
5138 -> 5132;
5139 -> 5138;
5140 -> 5133;
5140 -> 5139;
5141 -> 5140;
5141 -> 5124;
5141 -> 5139;
5142 -> 5138;
5143 -> 5132;
5144 -> 5141;
5144 -> 5112;
5145 -> 5112;
5146 -> 5112;
5147 -> 5146;
5147 -> 5112;
5148 -> 5112;
5149 -> 5112;
5150 -> 5114;
5150 -> 5149;
5151 -> 5149;
5152 -> 5151;
5152 -> 5112;
5153 -> 5112;
5154 -> 5152;
5154 -> 5153;
5154 -> 5112;
5155 -> 5154;
5156 -> 5114;
5156 -> 5155;
5157 -> 5156;
5157 -> 5124;
5157 -> 5155;
5158 -> 5157;
5158 -> 5154;
5159 -> 5154;
5160 -> 5154;
5161 -> 5158;
5161 -> 5160;
5162 -> 5159;
5162 -> 5160;
5163 -> 5144;
5163 -> 5160;
5164 -> 5162;
5164 -> 5160;
5165 -> 5160;
5166 -> 5160;
5167 -> 5165;
5167 -> 5166;
5168 -> 5167;
5168 -> 5166;
5169 -> 5166;
5170 -> 5169;
5171 -> 5170;
5172 -> 5163;
5172 -> 5161;
5172 -> 5170;
5173 -> 5166;
5174 -> 5166;
5175 -> 5163;
5175 -> 5172;
5175 -> 5166;
5176 -> 5166;
5177 -> 5175;
5177 -> 5176;
5177 -> 5166;
5178 -> 5174;
5178 -> 5166;
5179 -> 5175;
5179 -> 5178;
5179 -> 5172;
5179 -> 5166;
5180 -> 5167;
5180 -> 5166;
5181 -> 5166;
5182 -> 5180;
5182 -> 5181;
5183 -> 5182;
5183 -> 5181;
5184 -> 5181;
5185 -> 5181;
5186 -> 5183;
5186 -> 5185;
5187 -> 5184;
5187 -> 5185;
5188 -> 5187;
5188 -> 5185;
5189 -> 5187;
5189 -> 5185;
5190 -> 5187;
5190 -> 5185;
5191 -> 5187;
5191 -> 5185;
5192 -> 5187;
5192 -> 5185;
5193 -> 5187;
5193 -> 5185;
5194 -> 5186;
5194 -> 5187;
5194 -> 5185;
5195 -> 5187;
5195 -> 5185;
5196 -> 5185;
5197 -> 5185;
5198 -> 5197;
5198 -> 5187;
5198 -> 5185;
5199 -> 5185;
5200 -> 5185;
5201 -> 5199;
5201 -> 5200;
5202 -> 5200;
5203 -> 5201;
5203 -> 5202;
5204 -> 5203;
5204 -> 5202;
5205 -> 5203;
5205 -> 5202;
5206 -> 5203;
5206 -> 5202;
5207 -> 5203;
5207 -> 5202;
5208 -> 5203;
5208 -> 5202;
5209 -> 5202;
5210 -> 5163;
5210 -> 5209;
5210 -> 5202;
5211 -> 5203;
5211 -> 5202;
5212 -> 5211;
5212 -> 5204;
5212 -> 5205;
5212 -> 5206;
5212 -> 5207;
5212 -> 5208;
5212 -> 5202;
5213 -> 5202;
5214 -> 5199;
5214 -> 5187;
5214 -> 5185;
5215 -> 5184;
5215 -> 5181;
5216 -> 5181;
5217 -> 5216;
5218 -> 5216;
5219 -> 5179;
5219 -> 5218;
5219 -> 5216;
5220 -> 5217;
5220 -> 5216;
5221 -> 5179;
5221 -> 5220;
5221 -> 5216;
5222 -> 5131;
5222 -> 5154;
5223 -> 5154;
5224 -> 5154;
5225 -> 5222;
5225 -> 5224;
5226 -> 5223;
5226 -> 5224;
5227 -> 5223;
5227 -> 5224;
5228 -> 5221;
5228 -> 5224;
5229 -> 5225;
5229 -> 5221;
5229 -> 5224;
5230 -> 5224;
5231 -> 5224;
5232 -> 5225;
5232 -> 5221;
5232 -> 5231;
5232 -> 5224;
5233 -> 5226;
5233 -> 5224;
5234 -> 5227;
5234 -> 5224;
5235 -> 5224;
5236 -> 5233;
5236 -> 5235;
5237 -> 5234;
5237 -> 5235;
5238 -> 5235;
5239 -> 5232;
5239 -> 5238;
5239 -> 5235;
5240 -> 5237;
5240 -> 5235;
5241 -> 5235;
5242 -> 5241;
5243 -> 5242;
5243 -> 5241;
5244 -> 5242;
5244 -> 5241;
5245 -> 5242;
5245 -> 5241;
5246 -> 5242;
5246 -> 5241;
5247 -> 5236;
5247 -> 5235;
5248 -> 5237;
5248 -> 5235;
5249 -> 5235;
5250 -> 5247;
5250 -> 5249;
5251 -> 5248;
5251 -> 5249;
5252 -> 5249;
5253 -> 5249;
5254 -> 5250;
5254 -> 5253;
5255 -> 5252;
5255 -> 5253;
5256 -> 5255;
5256 -> 5253;
5257 -> 5254;
5257 -> 5256;
5258 -> 5250;
5258 -> 5252;
5258 -> 5249;
5259 -> 5251;
5259 -> 5252;
5259 -> 5249;
5260 -> 5258;
5260 -> 5259;
5260 -> 5249;
5261 -> 5250;
5261 -> 5228;
5261 -> 5249;
5262 -> 5251;
5262 -> 5228;
5262 -> 5249;
5263 -> 5235;
5264 -> 5235;
5265 -> 5264;
5266 -> 5265;
5267 -> 5232;
5267 -> 5266;
5268 -> 5232;
5268 -> 5266;
5269 -> 5267;
5269 -> 5232;
5269 -> 5266;
5270 -> 5266;
5271 -> 5269;
5271 -> 5270;
5272 -> 5268;
5272 -> 5270;
5273 -> 5272;
5273 -> 5271;
5273 -> 5232;
5273 -> 5270;
5274 -> 5273;
5274 -> 5270;
5275 -> 5273;
5275 -> 5270;
5276 -> 5274;
5276 -> 5273;
5276 -> 5270;
5277 -> 5270;
5278 -> 5276;
5278 -> 5277;
5279 -> 5275;
5279 -> 5277;
5280 -> 5279;
5280 -> 5278;
5280 -> 5273;
5280 -> 5277;
5281 -> 5277;
5282 -> 3712;
5282 -> 5281;
5283 -> 5281;
5284 -> 5281;
5285 -> 5284;
5286 -> 5280;
5286 -> 5285;
5287 -> 5285;
5288 -> 5285;
5289 -> 5285;
5290 -> 5288;
5290 -> 5289;
5291 -> 5288;
5291 -> 5284;
5292 -> 5284;
5293 -> 5284;
5294 -> 5291;
5294 -> 5284;
5295 -> 5292;
5295 -> 5284;
5296 -> 5284;
5297 -> 5280;
5298 -> 5297;
5298 -> 5280;
5299 -> 5280;
5300 -> 5280;
5300 -> 5299;
5301 -> 5300;
5301 -> 5280;
5301 -> 5299;
5302 -> 5301;
5302 -> 5280;
5303 -> 5280;
5304 -> 5280;
5305 -> 5280;
5306 -> 5280;
5307 -> 5280;
5308 -> 5280;
5309 -> 5280;
5310 -> 5280;
5311 -> 5280;
5312 -> 5280;
5313 -> 5312;
5314 -> 5280;
5315 -> 5280;
5316 -> 5280;
5316 -> 5315;
5317 -> 0;
5317 -> 5315;
5318 -> 5317;
5318 -> 5280;
5319 -> 5280;
5320 -> 5280;
5321 -> 5270;
5322 -> 5280;
5322 -> 5321;
5323 -> 5280;
5323 -> 5321;
5324 -> 0;
5324 -> 5321;
5325 -> 5321;
5326 -> 5324;
5326 -> 5325;
5327 -> 5323;
5327 -> 5235;
5328 -> 0;
5328 -> 5154;
5329 -> 5114;
5329 -> 5154;
5330 -> 5154;
5331 -> 5328;
5331 -> 5330;
5332 -> 5329;
5332 -> 5330;
5333 -> 5327;
5333 -> 5330;
5334 -> 5330;
5335 -> 5332;
5335 -> 5334;
5335 -> 5330;
5336 -> 5333;
5336 -> 5330;
5337 -> 5333;
5337 -> 5323;
5337 -> 5331;
5337 -> 5330;
5338 -> 5332;
5338 -> 5330;
5339 -> 5330;
5340 -> 5330;
5341 -> 5336;
5341 -> 5340;
5342 -> 5337;
5342 -> 5340;
5343 -> 5338;
5343 -> 5340;
5344 -> 5339;
5344 -> 5340;
5345 -> 5341;
5345 -> 5340;
5346 -> 5342;
5346 -> 5340;
5347 -> 5340;
5348 -> 5345;
5348 -> 5347;
5349 -> 5346;
5349 -> 5347;
5350 -> 5344;
5350 -> 5347;
5351 -> 5350;
5351 -> 5347;
5352 -> 5350;
5352 -> 5347;
5353 -> 5350;
5353 -> 5347;
5354 -> 5350;
5354 -> 5347;
5355 -> 5350;
5355 -> 5347;
5356 -> 5347;
5357 -> 5348;
5357 -> 5356;
5357 -> 5347;
5358 -> 5349;
5358 -> 5347;
5359 -> 0;
5359 -> 5347;
5360 -> 5347;
5361 -> 5358;
5361 -> 5360;
5362 -> 5359;
5362 -> 5360;
5363 -> 5349;
5363 -> 5347;
5364 -> 0;
5364 -> 5347;
5365 -> 5347;
5366 -> 5363;
5366 -> 5365;
5367 -> 5364;
5367 -> 5365;
5368 -> 5348;
5368 -> 5350;
5368 -> 5347;
5369 -> 5349;
5369 -> 5350;
5369 -> 5347;
5370 -> 5348;
5370 -> 5323;
5370 -> 5350;
5370 -> 5347;
5371 -> 5344;
5371 -> 5340;
5372 -> 5340;
5373 -> 5340;
5374 -> 5343;
5374 -> 5373;
5375 -> 5372;
5375 -> 5373;
5376 -> 5375;
5376 -> 5373;
5377 -> 5374;
5377 -> 5376;
5378 -> 5343;
5378 -> 5372;
5378 -> 5340;
5379 -> 5343;
5379 -> 5344;
5379 -> 5340;
5380 -> 5339;
5380 -> 5154;
5381 -> 5154;
5382 -> 5114;
5382 -> 5381;
5383 -> 5382;
5383 -> 5323;
5383 -> 5381;
5384 -> 5383;
5384 -> 5154;
5385 -> 5154;
5386 -> 5384;
5386 -> 5385;
5387 -> 5385;
5388 -> 5386;
5388 -> 0;
5388 -> 5385;
5389 -> 5131;
5389 -> 5388;
5390 -> 5148;
5390 -> 5388;
5391 -> 5388;
5392 -> 5388;
5393 -> 5389;
5393 -> 5392;
5394 -> 5390;
5394 -> 5392;
5395 -> 5391;
5395 -> 5392;
5396 -> 5391;
5396 -> 5392;
5397 -> 5380;
5397 -> 5392;
5398 -> 5393;
5398 -> 5392;
5399 -> 5394;
5399 -> 5392;
5400 -> 5395;
5400 -> 5392;
5401 -> 5396;
5401 -> 5392;
5402 -> 5392;
5403 -> 5398;
5403 -> 5402;
5404 -> 5399;
5404 -> 5402;
5405 -> 5400;
5405 -> 5402;
5406 -> 5401;
5406 -> 5402;
5407 -> 5397;
5407 -> 5402;
5408 -> 5402;
5409 -> 5404;
5409 -> 5408;
5409 -> 5402;
5410 -> 5403;
5410 -> 5402;
5411 -> 5404;
5411 -> 5402;
5412 -> 5405;
5412 -> 5402;
5413 -> 5402;
5414 -> 5405;
5414 -> 5413;
5414 -> 5402;
5415 -> 5414;
5415 -> 5406;
5415 -> 5402;
5416 -> 5402;
5417 -> 5410;
5417 -> 5416;
5418 -> 5411;
5418 -> 5416;
5419 -> 5412;
5419 -> 5416;
5420 -> 5415;
5420 -> 5416;
5421 -> 5407;
5421 -> 5416;
5422 -> 5417;
5422 -> 5386;
5422 -> 5416;
5423 -> 5417;
5423 -> 5422;
5424 -> 5418;
5424 -> 5422;
5425 -> 5422;
5426 -> 5419;
5426 -> 5422;
5427 -> 5422;
5428 -> 5423;
5428 -> 5427;
5429 -> 5424;
5429 -> 5427;
5430 -> 5425;
5430 -> 5427;
5431 -> 5426;
5431 -> 5427;
5432 -> 5425;
5432 -> 5427;
5433 -> 5421;
5433 -> 5427;
5434 -> 5428;
5434 -> 5422;
5434 -> 5427;
5435 -> 5429;
5435 -> 5427;
5436 -> 5431;
5436 -> 5427;
5437 -> 5427;
5438 -> 5427;
5439 -> 5434;
5439 -> 5438;
5440 -> 5435;
5440 -> 5438;
5441 -> 5436;
5441 -> 5438;
5442 -> 5437;
5442 -> 5438;
5443 -> 5433;
5443 -> 5438;
5444 -> 5442;
5444 -> 5438;
5445 -> 5438;
5446 -> 5440;
5446 -> 5445;
5446 -> 5438;
5447 -> 5441;
5447 -> 5444;
5447 -> 5438;
5448 -> 5447;
5448 -> 5438;
5449 -> 5439;
5450 -> 5440;
5450 -> 5439;
5451 -> 5439;
5452 -> 5449;
5452 -> 5451;
5453 -> 5450;
5453 -> 5451;
5454 -> 5443;
5454 -> 5451;
5455 -> 5452;
5455 -> 5451;
5456 -> 5455;
5456 -> 5451;
5457 -> 5453;
5457 -> 5451;
5458 -> 5451;
5459 -> 5456;
5459 -> 5458;
5460 -> 5457;
5460 -> 5458;
5461 -> 5454;
5461 -> 5458;
5462 -> 5459;
5462 -> 5439;
5462 -> 5458;
5463 -> 5460;
5463 -> 5458;
5464 -> 5459;
5464 -> 5458;
5465 -> 5458;
5466 -> 5462;
5466 -> 5465;
5467 -> 5463;
5467 -> 5465;
5468 -> 5464;
5468 -> 5465;
5469 -> 5461;
5469 -> 5465;
5470 -> 5469;
5470 -> 5370;
5470 -> 5465;
5471 -> 5466;
5471 -> 5465;
5472 -> 5468;
5472 -> 5465;
5473 -> 5467;
5473 -> 5465;
5474 -> 5465;
5475 -> 5470;
5475 -> 5474;
5476 -> 5471;
5476 -> 5474;
5477 -> 5472;
5477 -> 5474;
5478 -> 5473;
5478 -> 5474;
5479 -> 5476;
5479 -> 5474;
5480 -> 5474;
5481 -> 5479;
5481 -> 5480;
5482 -> 5475;
5482 -> 5480;
5483 -> 5481;
5483 -> 0;
5483 -> 5480;
5484 -> 5480;
5485 -> 5481;
5485 -> 5480;
5486 -> 5482;
5486 -> 5485;
5486 -> 5462;
5486 -> 5480;
5487 -> 5486;
5488 -> 5487;
5489 -> 5487;
5489 -> 5486;
5490 -> 5481;
5490 -> 5486;
5491 -> 5486;
5492 -> 5490;
5492 -> 5491;
5493 -> 5489;
5493 -> 5491;
5494 -> 5491;
5495 -> 5493;
5495 -> 5494;
5496 -> 5495;
5496 -> 5491;
5497 -> 5492;
5497 -> 5491;
5498 -> 5491;
5499 -> 5497;
5499 -> 5498;
5500 -> 5496;
5500 -> 5498;
5501 -> 5498;
5502 -> 5500;
5502 -> 5501;
5503 -> 5502;
5503 -> 5498;
5504 -> 5503;
5505 -> 5503;
5505 -> 5504;
5506 -> 5504;
5507 -> 5505;
5507 -> 5506;
5508 -> 5506;
5509 -> 5507;
5509 -> 5487;
5509 -> 5508;
5509 -> 5506;
5510 -> 5504;
5511 -> 5505;
5511 -> 5487;
5511 -> 5504;
5512 -> 5511;
5512 -> 5503;
5513 -> 5503;
5514 -> 5498;
5515 -> 5500;
5515 -> 5487;
5515 -> 5514;
5515 -> 5498;
5516 -> 5499;
5516 -> 5515;
5517 -> 5515;
5518 -> 5515;
5519 -> 5518;
5519 -> 5515;
5520 -> 5515;
5521 -> 5516;
5521 -> 5515;
5522 -> 5515;
5523 -> 5521;
5523 -> 5522;
5524 -> 5519;
5524 -> 5522;
5525 -> 5522;
5526 -> 5522;
5527 -> 5524;
5527 -> 5526;
5528 -> 5527;
5528 -> 5522;
5529 -> 5523;
5529 -> 5516;
5529 -> 5522;
5530 -> 5522;
5531 -> 5529;
5531 -> 5530;
5532 -> 5528;
5532 -> 5530;
5533 -> 5532;
5533 -> 5530;
5534 -> 5531;
5534 -> 5530;
5535 -> 5534;
5536 -> 5534;
5537 -> 5534;
5538 -> 5536;
5538 -> 5537;
5539 -> 5533;
5539 -> 5537;
5540 -> 5537;
5541 -> 5539;
5541 -> 5540;
5542 -> 5540;
5543 -> 5541;
5543 -> 5519;
5543 -> 5542;
5543 -> 5540;
5544 -> 5543;
5545 -> 5543;
5546 -> 5541;
5546 -> 5519;
5546 -> 5545;
5547 -> 5546;
5547 -> 5519;
5547 -> 5545;
5548 -> 5547;
5548 -> 5543;
5549 -> 0;
5549 -> 5543;
5550 -> 5548;
5550 -> 5543;
5551 -> 5543;
5552 -> 5550;
5552 -> 5551;
5553 -> 5541;
5553 -> 5551;
5554 -> 5551;
5555 -> 5552;
5555 -> 5554;
5555 -> 5551;
5556 -> 5551;
5557 -> 5551;
5558 -> 5551;
5559 -> 5553;
5559 -> 5558;
5560 -> 5558;
5561 -> 5560;
5561 -> 5551;
5562 -> 5561;
5562 -> 5551;
5563 -> 5561;
5563 -> 5551;
5564 -> 5563;
5565 -> 5552;
5565 -> 5551;
5566 -> 0;
5566 -> 5551;
5567 -> 5556;
5567 -> 5551;
5568 -> 5557;
5568 -> 5551;
5569 -> 5562;
5569 -> 5564;
5569 -> 5565;
5569 -> 5566;
5569 -> 5567;
5569 -> 5568;
5569 -> 5548;
5569 -> 5551;
5570 -> 5569;
5570 -> 5551;
5571 -> 5551;
5572 -> 5570;
5572 -> 5571;
5573 -> 5553;
5573 -> 5571;
5574 -> 5571;
5575 -> 5573;
5575 -> 5569;
5575 -> 5574;
5575 -> 5571;
5576 -> 0;
5576 -> 5575;
5577 -> 5572;
5577 -> 5575;
5578 -> 5577;
5578 -> 5569;
5579 -> 5573;
5579 -> 5577;
5580 -> 5577;
5581 -> 5577;
5582 -> 5578;
5582 -> 5581;
5583 -> 5579;
5583 -> 5581;
5584 -> 5578;
5584 -> 5581;
5585 -> 5580;
5585 -> 5581;
5586 -> 5581;
5587 -> 5585;
5587 -> 5581;
5588 -> 5585;
5588 -> 5581;
5589 -> 5585;
5589 -> 5581;
5590 -> 5581;
5591 -> 5582;
5591 -> 5590;
5591 -> 5581;
5592 -> 5581;
5593 -> 5583;
5593 -> 5592;
5593 -> 5581;
5594 -> 5581;
5595 -> 5584;
5595 -> 5594;
5595 -> 5581;
5596 -> 5583;
5596 -> 5585;
5596 -> 5581;
5597 -> 5582;
5597 -> 5585;
5597 -> 5581;
5598 -> 5584;
5598 -> 5585;
5598 -> 5581;
5599 -> 5577;
5600 -> 5580;
5600 -> 5599;
5601 -> 5600;
5601 -> 5597;
5601 -> 5599;
5602 -> 5601;
5602 -> 5577;
5603 -> 5580;
5603 -> 5577;
5604 -> 5576;
5604 -> 5602;
5604 -> 5603;
5604 -> 5577;
5605 -> 5573;
5605 -> 5569;
5605 -> 5575;
5606 -> 5576;
5606 -> 5575;
5607 -> 5575;
5608 -> 5605;
5608 -> 5606;
5608 -> 5607;
5608 -> 5576;
5608 -> 5569;
5608 -> 5604;
5608 -> 5585;
5608 -> 5596;
5608 -> 5597;
5608 -> 5598;
5608 -> 5575;
5609 -> 5551;
5610 -> 5569;
5610 -> 5551;
5611 -> 5551;
5612 -> 5610;
5612 -> 5611;
5613 -> 5553;
5613 -> 5611;
5614 -> 5611;
5615 -> 5613;
5615 -> 5608;
5615 -> 5614;
5615 -> 5611;
5616 -> 5615;
5617 -> 5613;
5617 -> 5616;
5618 -> 5617;
5618 -> 5608;
5618 -> 5616;
5619 -> 5618;
5619 -> 5615;
5620 -> 5615;
5621 -> 5615;
5622 -> 5619;
5622 -> 5621;
5623 -> 5622;
5623 -> 5615;
5624 -> 5615;
5625 -> 5612;
5625 -> 5615;
5626 -> 5625;
5626 -> 5623;
5626 -> 5615;
5627 -> 5626;
5628 -> 5623;
5628 -> 5627;
5629 -> 5619;
5629 -> 5628;
5630 -> 5613;
5630 -> 5628;
5631 -> 5627;
5631 -> 5628;
5632 -> 0;
5633 -> 5632;
5634 -> 5633;
5636 -> 5635;
5637 -> 5636;
5637 -> 5635;
5638 -> 0;
5638 -> 5636;
5638 -> 5635;
5639 -> 0;
5639 -> 5636;
5639 -> 5635;
5640 -> 5636;
5640 -> 5635;
5641 -> 5636;
5641 -> 5635;
5642 -> 5636;
5642 -> 5635;
5643 -> 5636;
5643 -> 5635;
5644 -> 3100;
5644 -> 5636;
5644 -> 5635;
5645 -> 0;
5645 -> 5636;
5645 -> 5635;
5646 -> 5635;
5647 -> 5626;
5647 -> 5623;
5647 -> 5628;
5648 -> 5628;
5649 -> 5629;
5649 -> 5648;
5650 -> 5630;
5650 -> 5648;
5651 -> 5631;
5651 -> 5648;
5652 -> 5647;
5652 -> 5648;
5653 -> 5648;
5654 -> 5653;
5654 -> 5648;
5655 -> 5648;
5656 -> 5648;
5657 -> 5649;
5657 -> 5648;
5658 -> 5651;
5658 -> 5648;
5659 -> 5653;
5659 -> 5648;
5660 -> 5655;
5660 -> 5648;
5661 -> 5656;
5661 -> 5648;
5662 -> 5648;
5663 -> 5657;
5663 -> 5662;
5664 -> 5658;
5664 -> 5662;
5665 -> 5659;
5665 -> 5662;
5666 -> 5660;
5666 -> 5662;
5667 -> 5661;
5667 -> 5662;
5668 -> 5662;
5669 -> 5663;
5669 -> 5668;
5670 -> 5669;
5670 -> 5662;
5671 -> 5664;
5671 -> 5662;
5672 -> 5670;
5672 -> 5671;
5672 -> 5623;
5672 -> 5662;
5673 -> 5672;
5673 -> 5662;
5674 -> 5662;
5675 -> 5648;
5676 -> 5648;
5677 -> 5648;
5678 -> 5648;
5679 -> 5673;
5679 -> 5678;
5679 -> 5648;
5680 -> 5649;
5680 -> 5679;
5681 -> 5650;
5681 -> 5679;
5682 -> 5651;
5682 -> 5679;
5683 -> 5652;
5683 -> 5679;
5684 -> 5676;
5684 -> 5679;
5685 -> 5679;
5686 -> 5679;
5687 -> 5680;
5687 -> 5686;
5688 -> 5681;
5688 -> 5686;
5689 -> 5682;
5689 -> 5686;
5690 -> 5683;
5690 -> 5686;
5691 -> 5684;
5691 -> 5686;
5692 -> 5685;
5692 -> 5686;
5693 -> 5687;
5693 -> 5686;
5694 -> 5688;
5694 -> 5686;
5695 -> 5689;
5695 -> 5686;
5696 -> 5690;
5696 -> 5686;
5697 -> 5686;
5698 -> 5691;
5698 -> 5686;
5699 -> 5686;
5700 -> 5693;
5700 -> 5699;
5701 -> 5694;
5701 -> 5699;
5702 -> 5695;
5702 -> 5699;
5703 -> 5696;
5703 -> 5699;
5704 -> 5697;
5704 -> 5699;
5705 -> 5698;
5705 -> 5699;
5706 -> 5692;
5706 -> 5699;
5707 -> 5699;
5708 -> 5706;
5708 -> 5707;
5709 -> 5707;
5710 -> 5707;
5711 -> 5708;
5711 -> 5710;
5712 -> 5710;
5713 -> 5711;
5713 -> 5710;
5714 -> 5711;
5714 -> 5710;
5715 -> 5708;
5715 -> 5707;
5716 -> 5708;
5716 -> 5707;
5717 -> 5708;
5717 -> 5707;
5718 -> 5709;
5718 -> 5708;
5718 -> 5707;
5719 -> 5706;
5719 -> 5699;
5720 -> 5706;
5720 -> 5699;
5721 -> 5706;
5721 -> 5699;
5722 -> 5706;
5722 -> 5699;
5723 -> 5706;
5723 -> 5699;
5724 -> 5706;
5724 -> 5699;
5725 -> 5706;
5725 -> 5699;
5726 -> 5706;
5726 -> 5699;
5727 -> 5706;
5727 -> 5699;
5728 -> 3100;
5728 -> 5706;
5728 -> 5699;
5729 -> 5699;
5730 -> 5729;
5730 -> 5706;
5730 -> 5699;
5731 -> 3100;
5731 -> 5706;
5731 -> 5699;
5732 -> 5699;
5733 -> 5732;
5733 -> 5706;
5733 -> 5699;
5734 -> 5706;
5734 -> 5699;
5735 -> 0;
5735 -> 5706;
5735 -> 5699;
5736 -> 5706;
5736 -> 5699;
5737 -> 5706;
5737 -> 5699;
5738 -> 5702;
5738 -> 5623;
5738 -> 5699;
5739 -> 5699;
5740 -> 5701;
5740 -> 5739;
5740 -> 5699;
5741 -> 5699;
5742 -> 5704;
5742 -> 5741;
5742 -> 5699;
5743 -> 5699;
5744 -> 5699;
5745 -> 5699;
5746 -> 5700;
5746 -> 5745;
5747 -> 5746;
5747 -> 5699;
5748 -> 5702;
5748 -> 5699;
5749 -> 5747;
5749 -> 5748;
5749 -> 5672;
5749 -> 5623;
5749 -> 5699;
5750 -> 5702;
5750 -> 5706;
5750 -> 5699;
5751 -> 5701;
5751 -> 5706;
5751 -> 5699;
5752 -> 5699;
5753 -> 5700;
5753 -> 5752;
5754 -> 5753;
5754 -> 5749;
5754 -> 5752;
5755 -> 5754;
5755 -> 5699;
5756 -> 5702;
5756 -> 5699;
5757 -> 5755;
5757 -> 5706;
5757 -> 5699;
5758 -> 5699;
5759 -> 5704;
5759 -> 5758;
5759 -> 5699;
5760 -> 5749;
5760 -> 5706;
5760 -> 5759;
5761 -> 5759;
5762 -> 5699;
5763 -> 5703;
5763 -> 5762;
5763 -> 5699;
5764 -> 5699;
5765 -> 5700;
5765 -> 5764;
5766 -> 5765;
5766 -> 5755;
5766 -> 5764;
5767 -> 5766;
5767 -> 5699;
5768 -> 5699;
5769 -> 5767;
5769 -> 5768;
5770 -> 5768;
5771 -> 5769;
5771 -> 5770;
5772 -> 5771;
5772 -> 5768;
5773 -> 5769;
5773 -> 5768;
5774 -> 5769;
5774 -> 5755;
5774 -> 0;
5774 -> 5768;
5775 -> 5763;
5775 -> 5772;
5775 -> 5699;
5776 -> 5699;
5777 -> 5706;
5777 -> 5776;
5778 -> 0;
5778 -> 5776;
5779 -> 5777;
5779 -> 5757;
5779 -> 0;
5779 -> 5776;
5780 -> 0;
5780 -> 5779;
5781 -> 5780;
5781 -> 5776;
5782 -> 5781;
5782 -> 5699;
5783 -> 5775;
5783 -> 5782;
5783 -> 5699;
5784 -> 0;
5784 -> 5706;
5784 -> 5783;
5785 -> 5744;
5785 -> 5699;
5786 -> 5648;
5787 -> 5674;
5787 -> 5786;
5787 -> 5648;
5788 -> 5685;
5788 -> 5648;
5789 -> 5620;
5789 -> 5788;
5789 -> 5711;
5789 -> 5713;
5789 -> 5714;
5789 -> 5715;
5789 -> 5716;
5789 -> 5718;
5789 -> 5751;
5789 -> 5760;
5789 -> 5757;
5789 -> 5784;
5789 -> 5723;
5789 -> 5724;
5789 -> 5725;
5789 -> 5726;
5789 -> 5727;
5789 -> 5728;
5789 -> 5730;
5789 -> 5731;
5789 -> 5733;
5789 -> 5734;
5789 -> 5735;
5789 -> 5736;
5789 -> 5737;
5789 -> 5750;
5789 -> 3091;
5789 -> 3092;
5789 -> 3093;
5789 -> 3094;
5789 -> 3095;
5789 -> 3097;
5789 -> 3099;
5789 -> 5729;
5789 -> 5732;
5789 -> 0;
5789 -> 5623;
5789 -> 5755;
5789 -> 5628;
5790 -> 5789;
5791 -> 5790;
5791 -> 5789;
5792 -> 5789;
5793 -> 5789;
5794 -> 5790;
5794 -> 5789;
5795 -> 5792;
5795 -> 5789;
5796 -> 5793;
5796 -> 5789;
5797 -> 5789;
5798 -> 5789;
5799 -> 5789;
5800 -> 5798;
5800 -> 5789;
5801 -> 5800;
5801 -> 5789;
5802 -> 5801;
5802 -> 5798;
5803 -> 5798;
5804 -> 5798;
5805 -> 5798;
5806 -> 5798;
5807 -> 5798;
5808 -> 5798;
5808 -> 5789;
5809 -> 5798;
5810 -> 5798;
5811 -> 5798;
5812 -> 5798;
5813 -> 5798;
5814 -> 0;
5814 -> 5798;
5815 -> 5812;
5815 -> 5798;
5816 -> 5789;
5817 -> 5797;
5817 -> 5816;
5817 -> 5789;
5818 -> 5798;
5819 -> 5818;
5819 -> 5798;
5820 -> 5798;
5821 -> 5798;
5822 -> 5818;
5822 -> 5798;
5823 -> 5820;
5823 -> 5798;
5824 -> 5821;
5824 -> 5798;
5825 -> 5798;
5826 -> 5798;
5827 -> 5798;
5828 -> 5827;
5828 -> 5798;
5829 -> 5828;
5829 -> 5798;
5830 -> 5798;
5831 -> 5798;
5832 -> 5825;
5832 -> 5831;
5832 -> 5798;
5833 -> 5818;
5834 -> 5833;
5834 -> 5818;
5835 -> 5834;
5835 -> 5818;
5836 -> 5818;
5837 -> 5818;
5838 -> 5818;
5839 -> 5818;
5840 -> 5818;
5841 -> 5818;
5841 -> 5798;
5842 -> 5818;
5843 -> 5818;
5844 -> 5818;
5845 -> 5818;
5846 -> 5818;
5847 -> 0;
5847 -> 5818;
5848 -> 5845;
5848 -> 5818;
5849 -> 5818;
5850 -> 5818;
5851 -> 5818;
5852 -> 5818;
5853 -> 5850;
5853 -> 5818;
5854 -> 5851;
5854 -> 5818;
5855 -> 5818;
5856 -> 5818;
5857 -> 5818;
5858 -> 5818;
5859 -> 5855;
5859 -> 5858;
5859 -> 5818;
5860 -> 5850;
5860 -> 5818;
5861 -> 5850;
5862 -> 5861;
5862 -> 5850;
5863 -> 5862;
5863 -> 5850;
5864 -> 5850;
5865 -> 5850;
5866 -> 5850;
5867 -> 5850;
5868 -> 5850;
5869 -> 5850;
5869 -> 5818;
5870 -> 5850;
5871 -> 5850;
5872 -> 5850;
5873 -> 5850;
5874 -> 5850;
5875 -> 0;
5875 -> 5850;
5876 -> 5873;
5876 -> 5850;
5877 -> 5615;
5878 -> 0;
5878 -> 5615;
5879 -> 5877;
5879 -> 5878;
5879 -> 5620;
5879 -> 5850;
5879 -> 5615;
5880 -> 5879;
5880 -> 5877;
5881 -> 5880;
5881 -> 5879;
5881 -> 5877;
5882 -> 5620;
5882 -> 5881;
5882 -> 5615;
5883 -> 5615;
5884 -> 5624;
5884 -> 5883;
5884 -> 5615;
5885 -> 5613;
5885 -> 5882;
5885 -> 5615;
5886 -> 5881;
5886 -> 5615;
5887 -> 5615;
5888 -> 5615;
5889 -> 5885;
5889 -> 5888;
5889 -> 5615;
5890 -> 5881;
5890 -> 5889;
5891 -> 5889;
5892 -> 5890;
5892 -> 5891;
5893 -> 5619;
5893 -> 5891;
5894 -> 5891;
5895 -> 5893;
5895 -> 5885;
5895 -> 5894;
5895 -> 5891;
5896 -> 5891;
5897 -> 5893;
5897 -> 5885;
5897 -> 5896;
5898 -> 5897;
5898 -> 5891;
5899 -> 5892;
5899 -> 5885;
5899 -> 5891;
5900 -> 5899;
5901 -> 5900;
5902 -> 5900;
5903 -> 5900;
5903 -> 5902;
5904 -> 5903;
5904 -> 5885;
5904 -> 5902;
5905 -> 5904;
5905 -> 5900;
5906 -> 5900;
5907 -> 5893;
5907 -> 5885;
5907 -> 5905;
5907 -> 5906;
5907 -> 5900;
5908 -> 5907;
5908 -> 5900;
5909 -> 5900;
5910 -> 5900;
5910 -> 5909;
5911 -> 5910;
5911 -> 5907;
5911 -> 5909;
5912 -> 5911;
5912 -> 5900;
5913 -> 5898;
5913 -> 5912;
5913 -> 5900;
5914 -> 5907;
5915 -> 5907;
5916 -> 5907;
5917 -> 5907;
5917 -> 5916;
5918 -> 5917;
5918 -> 5907;
5918 -> 5916;
5919 -> 5918;
5919 -> 5907;
5920 -> 5898;
5920 -> 5919;
5920 -> 5907;
5921 -> 5889;
5922 -> 5551;
5923 -> 5543;
5924 -> 5537;
5925 -> 5537;
5926 -> 5537;
5927 -> 5926;
5927 -> 5537;
5928 -> 5538;
5928 -> 5537;
5929 -> 5925;
5929 -> 5537;
5930 -> 5539;
5930 -> 5907;
5930 -> 5928;
5930 -> 5929;
5930 -> 5537;
5931 -> 5538;
5931 -> 5930;
5932 -> 5926;
5932 -> 5930;
5933 -> 5539;
5933 -> 5930;
5933 -> 5931;
5933 -> 5932;
5933 -> 5927;
5934 -> 5930;
5934 -> 5933;
5935 -> 5934;
5936 -> 5934;
5937 -> 5935;
5937 -> 5936;
5937 -> 5934;
5938 -> 5937;
5939 -> 5535;
5939 -> 5938;
5939 -> 5937;
5940 -> 5935;
5940 -> 5937;
5941 -> 5940;
5941 -> 5534;
5942 -> 5534;
5943 -> 5941;
5943 -> 5942;
5943 -> 5534;
5944 -> 5941;
5944 -> 5530;
5945 -> 5522;
5946 -> 5944;
5946 -> 5945;
5946 -> 5522;
5947 -> 5523;
5947 -> 5946;
5948 -> 5946;
5949 -> 5947;
5949 -> 5948;
5950 -> 5944;
5950 -> 5948;
5951 -> 5949;
5951 -> 5516;
5951 -> 5948;
5952 -> 5950;
5952 -> 5948;
5953 -> 5948;
5954 -> 5952;
5954 -> 5953;
5955 -> 0;
5955 -> 5953;
5956 -> 5955;
5956 -> 5948;
5957 -> 5948;
5958 -> 5948;
5959 -> 5958;
5959 -> 5948;
5960 -> 5948;
5961 -> 5952;
5961 -> 5960;
5962 -> 5960;
5963 -> 5961;
5963 -> 5962;
5964 -> 0;
5964 -> 5962;
5965 -> 5964;
5965 -> 5960;
5966 -> 5965;
5966 -> 5948;
5967 -> 0;
5967 -> 5948;
5968 -> 5948;
5969 -> 5967;
5969 -> 5968;
5970 -> 5952;
5970 -> 5968;
5971 -> 5968;
5972 -> 5970;
5972 -> 5971;
5973 -> 5972;
5973 -> 5934;
5973 -> 5933;
5973 -> 5971;
5974 -> 5972;
5974 -> 5934;
5974 -> 5933;
5974 -> 5973;
5975 -> 5973;
5976 -> 5972;
5976 -> 5975;
5977 -> 5976;
5977 -> 5975;
5978 -> 5975;
5979 -> 5975;
5980 -> 5977;
5980 -> 5979;
5981 -> 5978;
5981 -> 5979;
5982 -> 5979;
5983 -> 5981;
5983 -> 5982;
5984 -> 5982;
5985 -> 5983;
5985 -> 5984;
5986 -> 5981;
5986 -> 5979;
5987 -> 5980;
5987 -> 5979;
5988 -> 5980;
5988 -> 5981;
5988 -> 5979;
5989 -> 5978;
5989 -> 5973;
5990 -> 5973;
5991 -> 5974;
5991 -> 5989;
5991 -> 5990;
5991 -> 5988;
5991 -> 5933;
5991 -> 5934;
5991 -> 5973;
5992 -> 5972;
5992 -> 5991;
5992 -> 5971;
5993 -> 5992;
5993 -> 5968;
5994 -> 5969;
5994 -> 5968;
5995 -> 5968;
5996 -> 5993;
5996 -> 5995;
5997 -> 5994;
5997 -> 5995;
5998 -> 5996;
5998 -> 5995;
5999 -> 5997;
5999 -> 5995;
6000 -> 5995;
6001 -> 5998;
6001 -> 6000;
6002 -> 5999;
6002 -> 6000;
6003 -> 6002;
6003 -> 6000;
6004 -> 6001;
6004 -> 6000;
6005 -> 6000;
6006 -> 6003;
6006 -> 6000;
6007 -> 6000;
6008 -> 6004;
6008 -> 6007;
6009 -> 6005;
6009 -> 6007;
6010 -> 6005;
6010 -> 6007;
6011 -> 6006;
6011 -> 6007;
6012 -> 6005;
6012 -> 6007;
6013 -> 6007;
6014 -> 6008;
6014 -> 6013;
6014 -> 6007;
6015 -> 6012;
6015 -> 6007;
6016 -> 6015;
6017 -> 6009;
6017 -> 6016;
6017 -> 6015;
6018 -> 6015;
6019 -> 6010;
6019 -> 6018;
6019 -> 6015;
6020 -> 6008;
6020 -> 6007;
6021 -> 6007;
6023 -> 6022;
6025 -> 6024;
6026 -> 6021;
6026 -> 6007;
6027 -> 6011;
6027 -> 6007;
6028 -> 6009;
6028 -> 6007;
6029 -> 6010;
6029 -> 6007;
6030 -> 6007;
6031 -> 6007;
6032 -> 6026;
6032 -> 6031;
6033 -> 6027;
6033 -> 6031;
6034 -> 6028;
6034 -> 6031;
6035 -> 6029;
6035 -> 6031;
6036 -> 6030;
6036 -> 6031;
6037 -> 6032;
6037 -> 6031;
6038 -> 6033;
6038 -> 6031;
6039 -> 6031;
6040 -> 6034;
6040 -> 6031;
6041 -> 6035;
6041 -> 6031;
6042 -> 6031;
6043 -> 6042;
6043 -> 6037;
6043 -> 6038;
6043 -> 6039;
6043 -> 6040;
6043 -> 6041;
6043 -> 6021;
6043 -> 0;
6043 -> 6031;
6044 -> 6042;
6044 -> 6031;
6045 -> 6042;
6045 -> 6031;
6046 -> 6033;
6046 -> 6043;
6046 -> 6031;
6047 -> 0;
6047 -> 6031;
6048 -> 6046;
6048 -> 6042;
6048 -> 6031;
6049 -> 6030;
6049 -> 6007;
6050 -> 6007;
6051 -> 6049;
6051 -> 6050;
6052 -> 6008;
6052 -> 6050;
6053 -> 6051;
6053 -> 6050;
6054 -> 6050;
6055 -> 6053;
6055 -> 6054;
6056 -> 6052;
6056 -> 6054;
6057 -> 6056;
6057 -> 6054;
6058 -> 6054;
6059 -> 6057;
6059 -> 6058;
6060 -> 6055;
6060 -> 6058;
6061 -> 6060;
6061 -> 6043;
6061 -> 6058;
6062 -> 6060;
6062 -> 6043;
6062 -> 6044;
6062 -> 6048;
6062 -> 6045;
6062 -> 6058;
6063 -> 0;
6063 -> 6058;
6064 -> 6060;
6064 -> 6043;
6064 -> 6044;
6064 -> 6048;
6064 -> 6045;
6064 -> 0;
6064 -> 6058;
6065 -> 6064;
6066 -> 6059;
6066 -> 6065;
6067 -> 6065;
6068 -> 6066;
6068 -> 6067;
6069 -> 6068;
6069 -> 5991;
6069 -> 6067;
6070 -> 6065;
6071 -> 6069;
6071 -> 6070;
6072 -> 6070;
6073 -> 6071;
6073 -> 6072;
6074 -> 6073;
6074 -> 5991;
6074 -> 6072;
6075 -> 6074;
6075 -> 6070;
6076 -> 6070;
6077 -> 6075;
6078 -> 6075;
6079 -> 6077;
6079 -> 6078;
6079 -> 6075;
6080 -> 6077;
6080 -> 6079;
6081 -> 6065;
6082 -> 6080;
6082 -> 6081;
6083 -> 6082;
6083 -> 6081;
6084 -> 6081;
6085 -> 6083;
6085 -> 6084;
6086 -> 6084;
6087 -> 6085;
6087 -> 6086;
6088 -> 6087;
6089 -> 6088;
6090 -> 6087;
6091 -> 6087;
6092 -> 6087;
6092 -> 6084;
6093 -> 6092;
6093 -> 6064;
6094 -> 6093;
6094 -> 6064;
6095 -> 6064;
6096 -> 6094;
6096 -> 6095;
6097 -> 6060;
6097 -> 6095;
6098 -> 6096;
6098 -> 6095;
6099 -> 6095;
6100 -> 6098;
6100 -> 6099;
6100 -> 6095;
6101 -> 6097;
6101 -> 6043;
6101 -> 6044;
6101 -> 6048;
6101 -> 6045;
6101 -> 0;
6101 -> 6095;
6102 -> 6095;
6103 -> 6098;
6103 -> 6102;
6104 -> 6102;
6105 -> 6103;
6105 -> 6087;
6105 -> 6104;
6106 -> 6104;
6106 -> 6095;
6107 -> 6097;
6107 -> 6043;
6107 -> 6044;
6107 -> 6048;
6107 -> 6045;
6107 -> 0;
6107 -> 6095;
6108 -> 6106;
6108 -> 6107;
6108 -> 6095;
6109 -> 6108;
6109 -> 6064;
6110 -> 6058;
6111 -> 6059;
6111 -> 6110;
6112 -> 6110;
6113 -> 6111;
6113 -> 6087;
6113 -> 6112;
6114 -> 6112;
6115 -> 6114;
6115 -> 6058;
6116 -> 0;
6116 -> 6115;
6117 -> 6059;
6117 -> 6115;
6118 -> 6115;
6119 -> 6059;
6119 -> 6118;
6120 -> 6118;
6121 -> 6119;
6121 -> 6120;
6122 -> 6121;
6122 -> 6087;
6122 -> 6120;
6123 -> 6118;
6124 -> 6122;
6124 -> 6123;
6125 -> 6124;
6125 -> 6115;
6126 -> 6115;
6127 -> 6116;
6127 -> 6126;
6128 -> 6117;
6128 -> 6126;
6129 -> 6125;
6129 -> 6126;
6130 -> 6060;
6130 -> 6126;
6131 -> 6126;
6132 -> 6129;
6132 -> 6131;
6132 -> 6126;
6133 -> 6132;
6133 -> 6126;
6134 -> 6130;
6134 -> 6043;
6134 -> 6044;
6134 -> 6048;
6134 -> 6133;
6135 -> 6134;
6135 -> 6133;
6136 -> 6127;
6136 -> 6126;
6137 -> 6128;
6137 -> 6126;
6138 -> 6135;
6138 -> 6126;
6139 -> 6136;
6139 -> 6137;
6139 -> 6138;
6139 -> 6087;
6139 -> 6126;
6140 -> 6054;
6141 -> 6050;
6142 -> 6007;
6143 -> 6021;
6143 -> 6139;
6143 -> 6007;
6144 -> 6143;
6144 -> 5949;
6144 -> 5516;
6144 -> 5948;
6145 -> 5966;
6145 -> 6144;
6145 -> 5948;
6146 -> 5949;
6146 -> 5516;
6146 -> 5948;
6147 -> 5949;
6147 -> 5516;
6147 -> 6146;
6148 -> 6146;
6149 -> 5949;
6149 -> 5516;
6149 -> 5948;
6150 -> 5949;
6150 -> 5516;
6150 -> 5948;
6151 -> 6150;
6152 -> 6151;
6153 -> 6149;
6153 -> 6152;
6153 -> 6151;
6154 -> 6153;
6155 -> 5949;
6155 -> 5516;
6155 -> 5948;
6156 -> 5948;
6157 -> 6155;
6157 -> 6156;
6158 -> 5952;
6158 -> 6156;
6159 -> 6156;
6160 -> 6158;
6160 -> 6159;
6161 -> 6160;
6161 -> 6143;
6161 -> 6159;
6162 -> 6159;
6163 -> 6160;
6163 -> 6143;
6163 -> 6162;
6163 -> 6159;
6164 -> 6163;
6165 -> 6161;
6165 -> 6164;
6165 -> 6163;
6166 -> 6161;
6166 -> 6163;
6167 -> 6163;
6168 -> 6166;
6168 -> 6167;
6169 -> 6167;
6170 -> 6168;
6170 -> 6169;
6170 -> 6167;
6171 -> 6167;
6172 -> 6167;
6173 -> 6167;
6173 -> 6172;
6174 -> 6172;
6175 -> 6173;
6175 -> 6174;
6176 -> 6175;
6176 -> 6172;
6177 -> 6172;
6178 -> 6173;
6178 -> 6177;
6179 -> 6178;
6179 -> 6172;
6180 -> 6172;
6181 -> 6179;
6181 -> 6180;
6182 -> 6180;
6182 -> 6172;
6183 -> 6172;
6184 -> 6176;
6184 -> 6172;
6185 -> 6167;
6185 -> 6184;
6185 -> 6168;
6185 -> 6143;
6186 -> 6185;
6187 -> 6185;
6188 -> 6185;
6189 -> 6185;
6190 -> 6185;
6191 -> 6185;
6192 -> 6167;
6192 -> 6185;
6193 -> 6185;
6194 -> 6192;
6194 -> 6185;
6194 -> 6193;
6195 -> 6194;
6195 -> 6185;
6196 -> 6185;
6197 -> 6195;
6198 -> 6195;
6199 -> 6195;
6200 -> 6195;
6201 -> 6198;
6201 -> 6195;
6202 -> 6195;
6203 -> 6195;
6204 -> 6195;
6205 -> 6204;
6205 -> 6195;
6206 -> 6205;
6206 -> 6195;
6207 -> 6195;
6208 -> 6195;
6209 -> 6195;
6210 -> 6195;
6211 -> 6195;
6212 -> 6195;
6213 -> 6195;
6214 -> 6195;
6215 -> 6195;
6216 -> 6195;
6217 -> 6195;
6218 -> 0;
6218 -> 6195;
6219 -> 0;
6219 -> 6195;
6220 -> 6195;
6220 -> 6219;
6221 -> 6220;
6221 -> 6195;
6221 -> 6219;
6222 -> 6216;
6222 -> 6195;
6223 -> 6195;
6224 -> 6202;
6224 -> 6223;
6224 -> 6195;
6225 -> 6221;
6226 -> 6221;
6227 -> 6221;
6228 -> 6221;
6229 -> 6226;
6229 -> 6221;
6230 -> 6221;
6231 -> 6221;
6232 -> 6221;
6233 -> 6232;
6233 -> 6221;
6234 -> 6233;
6234 -> 6221;
6235 -> 6221;
6236 -> 6221;
6237 -> 6221;
6238 -> 6221;
6239 -> 6221;
6240 -> 6221;
6241 -> 6221;
6242 -> 6221;
6243 -> 6221;
6244 -> 6221;
6245 -> 6221;
6246 -> 0;
6246 -> 6221;
6247 -> 6244;
6247 -> 6221;
6248 -> 6221;
6249 -> 6230;
6249 -> 6248;
6249 -> 6221;
6250 -> 6226;
6250 -> 6221;
6251 -> 6226;
6251 -> 6221;
6252 -> 6226;
6253 -> 6252;
6253 -> 6226;
6254 -> 6253;
6254 -> 6226;
6255 -> 6226;
6256 -> 6226;
6257 -> 6226;
6258 -> 6226;
6259 -> 6226;
6260 -> 6226;
6260 -> 6221;
6261 -> 6226;
6262 -> 6226;
6263 -> 6226;
6264 -> 6226;
6265 -> 6226;
6266 -> 0;
6266 -> 6226;
6267 -> 6264;
6267 -> 6226;
6268 -> 6226;
6269 -> 6226;
6270 -> 6226;
6271 -> 6226;
6272 -> 6226;
6273 -> 6226;
6274 -> 6226;
6275 -> 6226;
6276 -> 6272;
6276 -> 6275;
6276 -> 6226;
6277 -> 6226;
6278 -> 6226;
6279 -> 6277;
6279 -> 6278;
6280 -> 6277;
6280 -> 6278;
6281 -> 6277;
6281 -> 6278;
6282 -> 6277;
6282 -> 6278;
6283 -> 6277;
6283 -> 6278;
6284 -> 6277;
6284 -> 6278;
6285 -> 6277;
6285 -> 6278;
6286 -> 6277;
6286 -> 6278;
6287 -> 6279;
6287 -> 6278;
6288 -> 6280;
6288 -> 6278;
6289 -> 6281;
6289 -> 6278;
6290 -> 6282;
6290 -> 6278;
6291 -> 6284;
6291 -> 6278;
6292 -> 6285;
6292 -> 6278;
6293 -> 6278;
6294 -> 6287;
6294 -> 6293;
6295 -> 6288;
6295 -> 6293;
6296 -> 6289;
6296 -> 6293;
6297 -> 6290;
6297 -> 6293;
6298 -> 6291;
6298 -> 6293;
6299 -> 6292;
6299 -> 6293;
6300 -> 6286;
6300 -> 6293;
6301 -> 6286;
6301 -> 6293;
6302 -> 6286;
6302 -> 6293;
6303 -> 6286;
6303 -> 6293;
6304 -> 6286;
6304 -> 6293;
6305 -> 6296;
6305 -> 6226;
6305 -> 6293;
6306 -> 6293;
6307 -> 6295;
6307 -> 6306;
6307 -> 6293;
6308 -> 6293;
6309 -> 6298;
6309 -> 6308;
6309 -> 6293;
6310 -> 6293;
6311 -> 6293;
6312 -> 6294;
6312 -> 6296;
6312 -> 6226;
6312 -> 6293;
6313 -> 6312;
6313 -> 6298;
6314 -> 6298;
6315 -> 6313;
6315 -> 6286;
6315 -> 6298;
6316 -> 6286;
6316 -> 6315;
6316 -> 6298;
6317 -> 6312;
6317 -> 6298;
6318 -> 6286;
6318 -> 6315;
6318 -> 6312;
6318 -> 6298;
6319 -> 6286;
6319 -> 6315;
6319 -> 6298;
6320 -> 6312;
6320 -> 6298;
6321 -> 6297;
6321 -> 6312;
6321 -> 6293;
6322 -> 0;
6322 -> 6293;
6323 -> 6311;
6323 -> 6293;
6324 -> 6286;
6324 -> 6278;
6325 -> 6286;
6325 -> 6278;
6326 -> 6278;
6327 -> 6283;
6327 -> 6226;
6327 -> 6326;
6327 -> 6278;
6328 -> 6284;
6328 -> 6286;
6328 -> 6278;
6329 -> 6283;
6329 -> 6286;
6329 -> 6278;
6330 -> 6319;
6330 -> 6286;
6330 -> 6278;
6331 -> 6185;
6331 -> 6277;
6331 -> 6312;
6331 -> 6286;
6331 -> 6295;
6331 -> 6315;
6331 -> 6321;
6331 -> 6296;
6331 -> 6328;
6331 -> 6330;
6331 -> 6329;
6331 -> 6293;
6331 -> 6226;
6332 -> 6331;
6333 -> 6331;
6334 -> 6331;
6335 -> 6331;
6336 -> 6331;
6337 -> 6331;
6338 -> 6331;
6339 -> 6338;
6339 -> 6331;
6340 -> 6339;
6340 -> 6331;
6341 -> 6331;
6342 -> 6331;
6343 -> 6331;
6344 -> 6331;
6345 -> 6331;
6346 -> 6331;
6347 -> 6331;
6348 -> 6331;
6349 -> 6331;
6350 -> 6331;
6351 -> 6331;
6352 -> 0;
6352 -> 6331;
6353 -> 6350;
6353 -> 6331;
6354 -> 6331;
6355 -> 6336;
6355 -> 6354;
6355 -> 6331;
6356 -> 6331;
6357 -> 6356;
6357 -> 6331;
6358 -> 6357;
6358 -> 6331;
6359 -> 6331;
6360 -> 6331;
6361 -> 6331;
6362 -> 6331;
6363 -> 6185;
6364 -> 6196;
6364 -> 6363;
6364 -> 6185;
6365 -> 6331;
6366 -> 6331;
6367 -> 6366;
6367 -> 6331;
6368 -> 6331;
6369 -> 6331;
6370 -> 6331;
6371 -> 6331;
6371 -> 6370;
6372 -> 6371;
6372 -> 6331;
6372 -> 6370;
6373 -> 6372;
6373 -> 6331;
6374 -> 6367;
6374 -> 6373;
6374 -> 6331;
6375 -> 6331;
6375 -> 6374;
6376 -> 6374;
6377 -> 6375;
6377 -> 6376;
6378 -> 6331;
6378 -> 6376;
6379 -> 6376;
6380 -> 6377;
6380 -> 6379;
6381 -> 6380;
6381 -> 6376;
6382 -> 6381;
6382 -> 0;
6382 -> 6376;
6383 -> 6376;
6384 -> 6377;
6384 -> 6383;
6385 -> 6383;
6386 -> 6384;
6386 -> 6385;
6387 -> 6386;
6387 -> 6331;
6387 -> 6385;
6388 -> 6387;
6388 -> 6383;
6389 -> 6383;
6390 -> 6388;
6390 -> 6389;
6390 -> 6383;
6391 -> 6390;
6391 -> 6383;
6392 -> 6391;
6393 -> 6388;
6393 -> 6392;
6394 -> 6392;
6395 -> 6393;
6395 -> 6394;
6396 -> 6395;
6396 -> 6392;
6397 -> 6392;
6398 -> 6396;
6398 -> 6397;
6399 -> 6398;
6399 -> 6376;
6400 -> 6378;
6400 -> 6376;
6401 -> 6399;
6401 -> 6400;
6401 -> 6376;
6402 -> 6376;
6403 -> 6377;
6403 -> 6402;
6404 -> 6402;
6405 -> 6403;
6405 -> 6404;
6406 -> 6405;
6406 -> 6331;
6406 -> 6404;
6407 -> 6404;
6408 -> 6406;
6408 -> 6407;
6409 -> 0;
6409 -> 6407;
6410 -> 6409;
6410 -> 6404;
6411 -> 6404;
6412 -> 6406;
6412 -> 6411;
6413 -> 6412;
6413 -> 6404;
6414 -> 6413;
6414 -> 6402;
6415 -> 6414;
6415 -> 6376;
6416 -> 6376;
6417 -> 6415;
6417 -> 6416;
6418 -> 6417;
6418 -> 6331;
6418 -> 6416;
6419 -> 6376;
6420 -> 6376;
6421 -> 6378;
6421 -> 6420;
6422 -> 6421;
6422 -> 6376;
6423 -> 6378;
6423 -> 6376;
6424 -> 6376;
6425 -> 6378;
6425 -> 6331;
6425 -> 6424;
6425 -> 6376;
6426 -> 6378;
6426 -> 6331;
6426 -> 6425;
6427 -> 6425;
6428 -> 6378;
6428 -> 6426;
6428 -> 6381;
6428 -> 6376;
6429 -> 6377;
6429 -> 6376;
6430 -> 6376;
6431 -> 6378;
6431 -> 6428;
6432 -> 6428;
6433 -> 6378;
6433 -> 6428;
6433 -> 6431;
6433 -> 6432;
6434 -> 6378;
6434 -> 6428;
6434 -> 6431;
6434 -> 0;
6435 -> 6374;
6436 -> 6374;
6437 -> 6331;
6437 -> 6428;
6437 -> 6436;
6438 -> 6437;
6438 -> 6428;
6438 -> 6431;
6438 -> 0;
6438 -> 6436;
6439 -> 6438;
6439 -> 6374;
6440 -> 6431;
6441 -> 6431;
6442 -> 6439;
6442 -> 0;
6443 -> 6439;
6444 -> 6439;
6444 -> 6443;
6445 -> 6443;
6446 -> 6444;
6446 -> 6445;
6447 -> 6446;
6447 -> 6431;
6447 -> 6445;
6448 -> 6447;
6448 -> 6443;
6449 -> 6443;
6450 -> 6448;
6450 -> 6449;
6450 -> 6443;
6451 -> 6450;
6451 -> 6443;
6452 -> 6451;
6453 -> 6448;
6453 -> 6452;
6454 -> 6452;
6455 -> 6453;
6455 -> 6454;
6456 -> 6455;
6456 -> 6452;
6457 -> 6452;
6458 -> 6456;
6458 -> 6457;
6459 -> 6458;
6459 -> 6439;
6460 -> 6439;
6461 -> 6439;
6462 -> 6439;
6462 -> 6461;
6463 -> 6461;
6464 -> 6462;
6464 -> 6463;
6465 -> 6464;
6465 -> 6431;
6465 -> 6463;
6466 -> 6463;
6467 -> 6465;
6467 -> 6466;
6468 -> 0;
6468 -> 6466;
6469 -> 6468;
6469 -> 6463;
6470 -> 6463;
6471 -> 6465;
6471 -> 6470;
6472 -> 6471;
6472 -> 6463;
6473 -> 6472;
6473 -> 6461;
6474 -> 6473;
6474 -> 6439;
6475 -> 6439;
6476 -> 6474;
6476 -> 6475;
6477 -> 6476;
6477 -> 6431;
6477 -> 6475;
6478 -> 6439;
6479 -> 6439;
6480 -> 6479;
6480 -> 6439;
6481 -> 6439;
6482 -> 6439;
6483 -> 6439;
6483 -> 0;
6484 -> 6439;
6485 -> 6439;
6486 -> 6479;
6486 -> 0;
6487 -> 6479;
6488 -> 6479;
6488 -> 6487;
6489 -> 6487;
6490 -> 6488;
6490 -> 6489;
6491 -> 6490;
6491 -> 6439;
6491 -> 6489;
6492 -> 6491;
6492 -> 6487;
6493 -> 6487;
6494 -> 6492;
6494 -> 6493;
6494 -> 6487;
6495 -> 6494;
6495 -> 6487;
6496 -> 6495;
6497 -> 6492;
6497 -> 6496;
6498 -> 6496;
6499 -> 6497;
6499 -> 6498;
6500 -> 6499;
6500 -> 6496;
6501 -> 6496;
6502 -> 6500;
6502 -> 6501;
6503 -> 6502;
6503 -> 6479;
6504 -> 6479;
6505 -> 6479;
6506 -> 6479;
6506 -> 6505;
6507 -> 6505;
6508 -> 6506;
6508 -> 6507;
6509 -> 6508;
6509 -> 6439;
6509 -> 6507;
6510 -> 6507;
6511 -> 6509;
6511 -> 6510;
6512 -> 0;
6512 -> 6510;
6513 -> 6512;
6513 -> 6507;
6514 -> 6507;
6515 -> 6509;
6515 -> 6514;
6516 -> 6515;
6516 -> 6507;
6517 -> 6516;
6517 -> 6505;
6518 -> 6517;
6518 -> 6479;
6519 -> 6479;
6520 -> 6518;
6520 -> 6519;
6521 -> 6520;
6521 -> 6439;
6521 -> 6519;
6522 -> 6479;
6523 -> 6479;
6524 -> 6479;
6525 -> 6479;
6525 -> 0;
6526 -> 6479;
6527 -> 6479;
6528 -> 6490;
6528 -> 6479;
6528 -> 6489;
6529 -> 6528;
6529 -> 6487;
6530 -> 6529;
6530 -> 6493;
6530 -> 6487;
6531 -> 6530;
6531 -> 6487;
6532 -> 6531;
6533 -> 6529;
6533 -> 6532;
6534 -> 6532;
6535 -> 6533;
6535 -> 6534;
6536 -> 6535;
6536 -> 6532;
6537 -> 6532;
6538 -> 6536;
6538 -> 6537;
6539 -> 6538;
6539 -> 6479;
6540 -> 6508;
6540 -> 6479;
6540 -> 6507;
6541 -> 6540;
6541 -> 6510;
6542 -> 6540;
6542 -> 6514;
6543 -> 6542;
6543 -> 6507;
6544 -> 6543;
6544 -> 6505;
6545 -> 6544;
6545 -> 6479;
6546 -> 6545;
6546 -> 6519;
6547 -> 6546;
6547 -> 6479;
6547 -> 6519;
6548 -> 6163;
6549 -> 6160;
6549 -> 6479;
6549 -> 6163;
6550 -> 6163;
6551 -> 6156;
6552 -> 6156;
6553 -> 6552;
6553 -> 6156;
6554 -> 6157;
6554 -> 6156;
6555 -> 6552;
6555 -> 6156;
6556 -> 6158;
6556 -> 6549;
6556 -> 6554;
6556 -> 6555;
6556 -> 6553;
6556 -> 6156;
6557 -> 6556;
6557 -> 6156;
6558 -> 6557;
6558 -> 5948;
6559 -> 6558;
6560 -> 6558;
6560 -> 6559;
6561 -> 6559;
6562 -> 6561;
6562 -> 6558;
6563 -> 6558;
6564 -> 6154;
6564 -> 6563;
6564 -> 6558;
6565 -> 6558;
6566 -> 6558;
6566 -> 6565;
6567 -> 6565;
6568 -> 6567;
6568 -> 6558;
6569 -> 6154;
6569 -> 6568;
6569 -> 6558;
6570 -> 6562;
6570 -> 6569;
6570 -> 6558;
6571 -> 6570;
6572 -> 5957;
6572 -> 6571;
6572 -> 6570;
6573 -> 6558;
6573 -> 6570;
6574 -> 5948;
6575 -> 6573;
6575 -> 6574;
6575 -> 5948;
6576 -> 6573;
6576 -> 5948;
6577 -> 5522;
6578 -> 6576;
6578 -> 6577;
6578 -> 5522;
6579 -> 6576;
6579 -> 5522;
6580 -> 5515;
6581 -> 6579;
6581 -> 6580;
6582 -> 6580;
6582 -> 5515;
6583 -> 5515;
6584 -> 6579;
6584 -> 6583;
6585 -> 0;
6585 -> 6583;
6586 -> 6584;
6586 -> 5515;
6587 -> 6582;
6587 -> 6586;
6587 -> 5515;
6588 -> 6579;
6588 -> 5515;
6589 -> 5515;
6590 -> 6588;
6590 -> 6589;
6591 -> 5500;
6591 -> 6589;
6592 -> 6589;
6593 -> 6590;
6593 -> 0;
6593 -> 6589;
6594 -> 6589;
6595 -> 6590;
6595 -> 6594;
6596 -> 6594;
6597 -> 6595;
6597 -> 6596;
6598 -> 6597;
6598 -> 6557;
6598 -> 6596;
6599 -> 6598;
6599 -> 6594;
6600 -> 6594;
6601 -> 6599;
6601 -> 6600;
6601 -> 6594;
6602 -> 6601;
6602 -> 6594;
6603 -> 6602;
6604 -> 6599;
6604 -> 6603;
6605 -> 6603;
6606 -> 6604;
6606 -> 6605;
6607 -> 6606;
6607 -> 6603;
6608 -> 6603;
6609 -> 6607;
6609 -> 6608;
6610 -> 6609;
6610 -> 6589;
6611 -> 6591;
6611 -> 6589;
6612 -> 6589;
6613 -> 6590;
6613 -> 6612;
6614 -> 6612;
6615 -> 6613;
6615 -> 6614;
6616 -> 6615;
6616 -> 6557;
6616 -> 6614;
6617 -> 6614;
6618 -> 6616;
6618 -> 6617;
6619 -> 0;
6619 -> 6617;
6620 -> 6619;
6620 -> 6614;
6621 -> 6614;
6622 -> 6616;
6622 -> 6621;
6623 -> 6621;
6624 -> 6622;
6624 -> 6614;
6625 -> 6624;
6625 -> 6612;
6626 -> 6625;
6626 -> 6589;
6627 -> 6589;
6628 -> 6626;
6628 -> 6627;
6629 -> 6628;
6629 -> 6557;
6629 -> 6627;
6630 -> 6589;
6631 -> 6589;
6632 -> 6591;
6632 -> 6631;
6633 -> 6632;
6633 -> 6557;
6633 -> 6631;
6634 -> 6633;
6634 -> 6589;
6635 -> 6591;
6635 -> 6589;
6636 -> 6589;
6637 -> 6591;
6637 -> 6557;
6637 -> 6636;
6637 -> 6589;
6638 -> 6589;
6639 -> 6590;
6640 -> 6591;
6640 -> 6590;
6641 -> 5515;
6642 -> 5500;
6642 -> 6590;
6642 -> 5499;
6642 -> 5498;
6643 -> 5480;
6644 -> 6642;
6644 -> 6643;
6645 -> 6644;
6645 -> 5480;
6646 -> 6642;
6646 -> 5480;
6647 -> 5474;
6648 -> 6646;
6648 -> 6647;
6648 -> 5474;
6649 -> 6646;
6649 -> 5474;
6650 -> 5478;
6650 -> 5474;
6651 -> 5477;
6651 -> 5474;
6652 -> 5474;
6653 -> 6649;
6653 -> 6652;
6654 -> 6650;
6654 -> 6652;
6655 -> 6651;
6655 -> 6652;
6656 -> 6652;
6657 -> 6653;
6657 -> 6656;
6658 -> 6657;
6658 -> 6590;
6658 -> 6656;
6659 -> 0;
6659 -> 6656;
6660 -> 6658;
6661 -> 6657;
6661 -> 6660;
6662 -> 6660;
6663 -> 6662;
6663 -> 6660;
6664 -> 6660;
6665 -> 6661;
6665 -> 6664;
6666 -> 6664;
6667 -> 6666;
6667 -> 6664;
6668 -> 6664;
6669 -> 6665;
6669 -> 6668;
6670 -> 6668;
6671 -> 6669;
6671 -> 6670;
6672 -> 6671;
6672 -> 6590;
6672 -> 6670;
6673 -> 3100;
6673 -> 6670;
6674 -> 6671;
6674 -> 6590;
6674 -> 6672;
6675 -> 6672;
6676 -> 6671;
6676 -> 6675;
6677 -> 6675;
6678 -> 6675;
6679 -> 6677;
6679 -> 6678;
6680 -> 6676;
6680 -> 6678;
6681 -> 6678;
6682 -> 6678;
6683 -> 6681;
6683 -> 6682;
6684 -> 6680;
6684 -> 6682;
6685 -> 6684;
6685 -> 6590;
6685 -> 6682;
6686 -> 3100;
6686 -> 6682;
6687 -> 6685;
6688 -> 6684;
6688 -> 6687;
6689 -> 6688;
6689 -> 6590;
6689 -> 6687;
6690 -> 6689;
6691 -> 6688;
6691 -> 6690;
6692 -> 6691;
6692 -> 6590;
6692 -> 6690;
6693 -> 6690;
6694 -> 6692;
6694 -> 6693;
6695 -> 0;
6695 -> 6693;
6696 -> 6695;
6696 -> 6690;
6697 -> 6690;
6698 -> 6692;
6698 -> 6697;
6699 -> 6698;
6699 -> 6690;
6700 -> 6699;
6700 -> 6689;
6701 -> 6689;
6702 -> 6700;
6702 -> 6701;
6703 -> 6702;
6703 -> 6689;
6704 -> 6688;
6704 -> 6590;
6704 -> 6689;
6705 -> 6703;
6705 -> 6689;
6706 -> 6700;
6706 -> 6705;
6707 -> 6688;
6707 -> 6705;
6708 -> 6705;
6709 -> 6705;
6710 -> 6706;
6710 -> 6709;
6711 -> 6707;
6711 -> 6709;
6712 -> 6708;
6712 -> 6709;
6713 -> 6710;
6713 -> 6709;
6714 -> 6711;
6714 -> 6709;
6715 -> 6709;
6716 -> 6709;
6717 -> 6713;
6717 -> 6716;
6718 -> 6714;
6718 -> 6716;
6719 -> 6715;
6719 -> 6716;
6720 -> 6712;
6720 -> 6716;
6721 -> 6716;
6722 -> 6717;
6722 -> 6721;
6723 -> 6716;
6724 -> 6717;
6724 -> 6723;
6725 -> 6724;
6725 -> 6716;
6726 -> 6725;
6727 -> 6725;
6728 -> 6726;
6728 -> 6727;
6729 -> 6728;
6729 -> 6703;
6729 -> 6727;
6731 -> 6730;
6732 -> 6730;
6733 -> 6732;
6733 -> 6716;
6734 -> 6717;
6734 -> 6716;
6735 -> 6716;
6736 -> 6735;
6736 -> 6722;
6736 -> 6729;
6736 -> 6733;
6736 -> 6734;
6736 -> 6703;
6736 -> 6731;
6736 -> 6716;
6737 -> 6735;
6737 -> 6716;
6738 -> 6735;
6738 -> 6716;
6739 -> 6716;
6740 -> 6717;
6740 -> 6739;
6740 -> 6716;
6741 -> 6718;
6741 -> 6735;
6741 -> 6716;
6742 -> 6719;
6742 -> 6735;
6742 -> 6716;
6743 -> 6703;
6743 -> 6705;
6744 -> 6743;
6744 -> 6708;
6744 -> 6703;
6744 -> 6736;
6744 -> 6737;
6744 -> 6741;
6744 -> 6738;
6744 -> 6742;
6744 -> 6705;
6745 -> 6744;
6745 -> 6708;
6746 -> 6745;
6746 -> 6744;
6746 -> 6708;
6747 -> 6746;
6747 -> 6685;
6748 -> 6747;
6748 -> 6685;
6749 -> 6683;
6749 -> 6748;
6750 -> 6748;
6751 -> 6750;
6752 -> 6750;
6752 -> 6751;
6753 -> 0;
6753 -> 6751;
6754 -> 6753;
6754 -> 6750;
6755 -> 6750;
6755 -> 6748;
6756 -> 6747;
6756 -> 6748;
6757 -> 6748;
6758 -> 6684;
6758 -> 6746;
6758 -> 6748;
6759 -> 6755;
6759 -> 6748;
6760 -> 6748;
6761 -> 6756;
6761 -> 6760;
6762 -> 6757;
6762 -> 6760;
6763 -> 6758;
6763 -> 6760;
6764 -> 6759;
6764 -> 6760;
6765 -> 6757;
6765 -> 6760;
6766 -> 6760;
6767 -> 6761;
6767 -> 6766;
6767 -> 6760;
6768 -> 6760;
6769 -> 6768;
6769 -> 6760;
6770 -> 6760;
6771 -> 6764;
6771 -> 6770;
6772 -> 6771;
6772 -> 6760;
6773 -> 6763;
6773 -> 6760;
6774 -> 6768;
6774 -> 6760;
6775 -> 6772;
6775 -> 6773;
6775 -> 6774;
6775 -> 6746;
6775 -> 6769;
6775 -> 6760;
6776 -> 6761;
6776 -> 6760;
6777 -> 6776;
6777 -> 6748;
6778 -> 6684;
6778 -> 6775;
6778 -> 6748;
6779 -> 6755;
6779 -> 6748;
6780 -> 6748;
6781 -> 6777;
6781 -> 6780;
6782 -> 6778;
6782 -> 6780;
6783 -> 6779;
6783 -> 6780;
6784 -> 6780;
6785 -> 6783;
6785 -> 6784;
6786 -> 6785;
6786 -> 6775;
6786 -> 6784;
6787 -> 6786;
6787 -> 6780;
6788 -> 6782;
6788 -> 6780;
6789 -> 6780;
6790 -> 6787;
6790 -> 6788;
6790 -> 6789;
6790 -> 6775;
6790 -> 6780;
6791 -> 6790;
6791 -> 6780;
6792 -> 6781;
6792 -> 6791;
6793 -> 6792;
6793 -> 6748;
6794 -> 6684;
6794 -> 6790;
6794 -> 6748;
6795 -> 6755;
6795 -> 6748;
6796 -> 6748;
6797 -> 6793;
6797 -> 6796;
6798 -> 6794;
6798 -> 6796;
6799 -> 6795;
6799 -> 6796;
6800 -> 6796;
6801 -> 6800;
6801 -> 6796;
6802 -> 6796;
6803 -> 6799;
6803 -> 6802;
6804 -> 6803;
6804 -> 6790;
6804 -> 6802;
6805 -> 6804;
6805 -> 6796;
6806 -> 6798;
6806 -> 6796;
6807 -> 6800;
6807 -> 6796;
6808 -> 6805;
6808 -> 6806;
6808 -> 6807;
6808 -> 6790;
6808 -> 6801;
6808 -> 6796;
6809 -> 6808;
6809 -> 6796;
6810 -> 6797;
6810 -> 6796;
6811 -> 6808;
6811 -> 6796;
6812 -> 6796;
6813 -> 6810;
6813 -> 6812;
6814 -> 6811;
6814 -> 6812;
6815 -> 6811;
6815 -> 6812;
6816 -> 6813;
6816 -> 6812;
6817 -> 6816;
6817 -> 6808;
6817 -> 6812;
6818 -> 6814;
6818 -> 6812;
6819 -> 6812;
6820 -> 6812;
6821 -> 6818;
6821 -> 6820;
6822 -> 6819;
6822 -> 6820;
6823 -> 6821;
6823 -> 6822;
6823 -> 6820;
6824 -> 6821;
6824 -> 6808;
6824 -> 6820;
6825 -> 6824;
6826 -> 6825;
6826 -> 6822;
6826 -> 6820;
6827 -> 6820;
6828 -> 6827;
6828 -> 6822;
6828 -> 6820;
6829 -> 6820;
6830 -> 6829;
6830 -> 6822;
6830 -> 6820;
6831 -> 6813;
6831 -> 6812;
6832 -> 6812;
6833 -> 6831;
6833 -> 6832;
6834 -> 6819;
6834 -> 6832;
6835 -> 6832;
6836 -> 6833;
6836 -> 6835;
6837 -> 6835;
6837 -> 6832;
6838 -> 6833;
6838 -> 6837;
6839 -> 6837;
6840 -> 6838;
6840 -> 6839;
6841 -> 6834;
6841 -> 6839;
6842 -> 6839;
6843 -> 6840;
6843 -> 6842;
6844 -> 0;
6844 -> 6842;
6845 -> 6844;
6845 -> 6839;
6846 -> 6845;
6846 -> 6839;
6847 -> 6839;
6848 -> 6846;
6848 -> 6847;
6849 -> 6841;
6849 -> 6847;
6850 -> 6848;
6850 -> 0;
6850 -> 6847;
6851 -> 6848;
6851 -> 6850;
6852 -> 6840;
6852 -> 6839;
6853 -> 6839;
6854 -> 6840;
6854 -> 6853;
6855 -> 6854;
6855 -> 6817;
6855 -> 6853;
6856 -> 6855;
6856 -> 6839;
6857 -> 6839;
6858 -> 6856;
6858 -> 6839;
6859 -> 6856;
6859 -> 6858;
6860 -> 6859;
6860 -> 6839;
6861 -> 6856;
6861 -> 6839;
6862 -> 6845;
6862 -> 6851;
6862 -> 6839;
6863 -> 6862;
6863 -> 6860;
6863 -> 6839;
6864 -> 6839;
6865 -> 6852;
6865 -> 6864;
6866 -> 6864;
6867 -> 6866;
6867 -> 6864;
6868 -> 6867;
6868 -> 6864;
6869 -> 6865;
6869 -> 6864;
6870 -> 6864;
6871 -> 6869;
6871 -> 6870;
6872 -> 6870;
6873 -> 6872;
6873 -> 6864;
6874 -> 6864;
6875 -> 6869;
6875 -> 6874;
6876 -> 6875;
6876 -> 6817;
6876 -> 6874;
6877 -> 6876;
6877 -> 6864;
6878 -> 6864;
6879 -> 6877;
6879 -> 6878;
6880 -> 0;
6880 -> 6878;
6881 -> 6880;
6881 -> 6864;
6882 -> 6873;
6882 -> 6881;
6882 -> 6864;
6883 -> 6864;
6884 -> 6869;
6884 -> 6883;
6885 -> 6884;
6885 -> 6883;
6886 -> 6885;
6886 -> 6817;
6886 -> 6883;
6887 -> 6886;
6887 -> 6864;
6888 -> 6864;
6889 -> 6887;
6889 -> 6888;
6890 -> 6864;
6891 -> 6889;
6891 -> 6890;
6892 -> 6890;
6892 -> 6864;
6893 -> 6864;
6894 -> 6882;
6894 -> 6892;
6894 -> 6864;
6895 -> 6864;
6896 -> 6869;
6896 -> 6895;
6897 -> 6896;
6897 -> 6817;
6897 -> 6895;
6898 -> 6897;
6898 -> 6864;
6899 -> 6898;
6899 -> 2687;
6899 -> 6864;
6900 -> 6894;
6900 -> 6899;
6900 -> 6864;
6901 -> 6864;
6902 -> 6864;
6902 -> 6839;
6903 -> 6852;
6903 -> 6839;
6904 -> 6819;
6904 -> 6828;
6904 -> 6812;
6905 -> 6815;
6905 -> 6904;
6906 -> 6903;
6906 -> 6905;
6907 -> 0;
6908 -> 0;
6909 -> 0;
6910 -> 6909;
6912 -> 6907;
6912 -> 6908;
6912 -> 6910;
6912 -> 6911;
6913 -> 6912;
6914 -> 0;
6915 -> 0;
6916 -> 0;
6917 -> 6916;
6917 -> 0;
6918 -> 6917;
6920 -> 6914;
6920 -> 6915;
6920 -> 6918;
6920 -> 6919;
6921 -> 6920;
6922 -> 6906;
6922 -> 6748;
6923 -> 6748;
6924 -> 6748;
6925 -> 6922;
6925 -> 6924;
6926 -> 6923;
6926 -> 6924;
6927 -> 6923;
6927 -> 6924;
6928 -> 6925;
6928 -> 6924;
6929 -> 6926;
6929 -> 0;
6929 -> 6924;
6930 -> 6926;
6930 -> 6924;
6931 -> 6925;
6931 -> 6930;
6932 -> 6930;
6933 -> 6931;
6933 -> 6932;
6934 -> 6932;
6935 -> 6933;
6935 -> 6934;
6936 -> 6934;
6937 -> 6935;
6937 -> 6936;
6938 -> 6936;
6939 -> 6937;
6939 -> 6938;
6940 -> 6939;
6940 -> 6938;
6941 -> 6940;
6941 -> 6936;
6942 -> 6941;
6942 -> 6934;
6943 -> 6942;
6943 -> 6932;
6944 -> 6932;
6945 -> 6943;
6945 -> 6944;
6946 -> 6945;
6946 -> 6817;
6946 -> 6944;
6947 -> 6925;
6947 -> 6924;
6948 -> 6926;
6948 -> 6924;
6949 -> 6927;
6949 -> 6924;
6950 -> 6924;
6951 -> 6947;
6951 -> 6950;
6952 -> 6948;
6952 -> 6950;
6953 -> 6949;
6953 -> 6950;
6954 -> 0;
6956 -> 6954;
6956 -> 6955;
6957 -> 6955;
6958 -> 6957;
6959 -> 6956;
6959 -> 0;
6959 -> 6955;
6960 -> 6956;
6960 -> 6957;
6960 -> 6955;
6961 -> 6955;
6962 -> 6951;
6962 -> 6950;
6963 -> 6952;
6963 -> 6950;
6964 -> 6953;
6964 -> 6950;
6965 -> 6950;
6966 -> 6964;
6966 -> 6965;
6967 -> 6966;
6967 -> 6949;
6967 -> 6965;
6968 -> 6961;
6968 -> 6967;
6969 -> 6950;
6970 -> 6950;
6971 -> 6962;
6971 -> 6970;
6972 -> 6963;
6972 -> 6970;
6973 -> 6968;
6973 -> 6970;
6974 -> 6969;
6974 -> 6970;
6975 -> 6971;
6975 -> 6970;
6976 -> 6975;
6976 -> 6970;
6977 -> 6971;
6977 -> 6976;
6978 -> 6976;
6979 -> 6977;
6979 -> 6978;
6980 -> 6978;
6981 -> 6979;
6981 -> 6980;
6982 -> 6980;
6983 -> 6981;
6983 -> 6982;
6984 -> 6982;
6985 -> 6983;
6985 -> 6984;
6986 -> 6985;
6986 -> 6984;
6987 -> 6986;
6987 -> 6982;
6988 -> 6987;
6988 -> 6980;
6989 -> 6988;
6989 -> 6978;
6990 -> 6978;
6991 -> 6989;
6991 -> 6990;
6992 -> 6991;
6992 -> 6817;
6992 -> 6990;
6993 -> 6972;
6993 -> 0;
6993 -> 6970;
6994 -> 6970;
6995 -> 6992;
6995 -> 6994;
6995 -> 6970;
6996 -> 6970;
6997 -> 6973;
6997 -> 6996;
6997 -> 6970;
6998 -> 6971;
6998 -> 6974;
6998 -> 6970;
6999 -> 6972;
6999 -> 6974;
6999 -> 6970;
7000 -> 6973;
7000 -> 6974;
7000 -> 6970;
7001 -> 6969;
7001 -> 6924;
7002 -> 7001;
7002 -> 6748;
7003 -> 6684;
7003 -> 6817;
7003 -> 6748;
7004 -> 6755;
7004 -> 6748;
7005 -> 6684;
7005 -> 6748;
7006 -> 6748;
7007 -> 7002;
7007 -> 7006;
7008 -> 7003;
7008 -> 7006;
7009 -> 7004;
7009 -> 7006;
7010 -> 7005;
7010 -> 7006;
7011 -> 7005;
7011 -> 7006;
7012 -> 7006;
7013 -> 7007;
7013 -> 7012;
7014 -> 7013;
7014 -> 6998;
7014 -> 7012;
7015 -> 7014;
7015 -> 7012;
7016 -> 7015;
7016 -> 7006;
7017 -> 7006;
7018 -> 7010;
7018 -> 7017;
7019 -> 7017;
7020 -> 7018;
7020 -> 7019;
7021 -> 7019;
7022 -> 7020;
7022 -> 7021;
7023 -> 7021;
7024 -> 7022;
7024 -> 7023;
7025 -> 7023;
7026 -> 7024;
7026 -> 7025;
7027 -> 7026;
7027 -> 7025;
7028 -> 7027;
7028 -> 7023;
7029 -> 7028;
7029 -> 7021;
7030 -> 7029;
7030 -> 7019;
7031 -> 7030;
7031 -> 7017;
7032 -> 7031;
7032 -> 7006;
7033 -> 7006;
7034 -> 7010;
7034 -> 7033;
7035 -> 7033;
7036 -> 7034;
7036 -> 7035;
7037 -> 7036;
7037 -> 6817;
7037 -> 7035;
7038 -> 7035;
7039 -> 7037;
7039 -> 7038;
7040 -> 0;
7040 -> 7038;
7041 -> 7040;
7041 -> 7035;
7042 -> 7037;
7042 -> 7033;
7043 -> 7042;
7043 -> 7006;
7044 -> 7043;
7044 -> 7009;
7044 -> 7006;
7045 -> 7006;
7046 -> 7010;
7046 -> 7006;
7047 -> 7006;
7048 -> 7046;
7048 -> 7047;
7049 -> 7045;
7049 -> 7047;
7050 -> 7048;
7050 -> 7047;
7051 -> 7047;
7052 -> 7048;
7052 -> 7051;
7053 -> 7051;
7053 -> 7047;
7054 -> 7047;
7055 -> 7047;
7056 -> 7048;
7056 -> 7055;
7057 -> 0;
7057 -> 7055;
7058 -> 7056;
7058 -> 6817;
7058 -> 0;
7058 -> 7055;
7059 -> 7058;
7059 -> 7047;
7060 -> 7047;
7061 -> 7048;
7061 -> 7060;
7062 -> 7061;
7062 -> 6817;
7062 -> 7060;
7063 -> 7062;
7063 -> 7047;
7064 -> 7063;
7064 -> 7047;
7065 -> 7047;
7066 -> 7065;
7066 -> 7006;
7067 -> 7006;
7068 -> 7006;
7069 -> 7068;
7069 -> 7006;
7070 -> 7006;
7071 -> 7009;
7071 -> 7070;
7072 -> 7071;
7072 -> 6817;
7072 -> 7070;
7073 -> 7072;
7073 -> 7006;
7074 -> 7008;
7074 -> 7006;
7075 -> 7067;
7075 -> 7006;
7076 -> 7068;
7076 -> 7006;
7077 -> 7073;
7077 -> 7074;
7077 -> 7075;
7077 -> 7076;
7077 -> 6817;
7077 -> 7069;
7077 -> 7006;
7078 -> 7077;
7079 -> 7011;
7079 -> 7078;
7080 -> 7078;
7081 -> 7079;
7081 -> 7077;
7081 -> 7078;
7082 -> 7080;
7082 -> 7078;
7083 -> 7078;
7084 -> 7081;
7084 -> 7083;
7085 -> 7082;
7085 -> 7083;
7086 -> 7084;
7086 -> 7083;
7087 -> 7086;
7088 -> 7086;
7089 -> 7088;
7090 -> 7089;
7091 -> 7089;
7091 -> 7090;
7092 -> 0;
7092 -> 7090;
7093 -> 7092;
7093 -> 7089;
7094 -> 7089;
7094 -> 7088;
7095 -> 7088;
7096 -> 7094;
7096 -> 7095;
7097 -> 7079;
7097 -> 7077;
7097 -> 7088;
7098 -> 7088;
7099 -> 7096;
7099 -> 7088;
7100 -> 7099;
7101 -> 7079;
7101 -> 7096;
7101 -> 7100;
7102 -> 7100;
7103 -> 7101;
7103 -> 7102;
7104 -> 7102;
7105 -> 7104;
7105 -> 7100;
7106 -> 7100;
7107 -> 7101;
7107 -> 7106;
7108 -> 7107;
7108 -> 7100;
7109 -> 7100;
7110 -> 7108;
7110 -> 7109;
7111 -> 7109;
7112 -> 7110;
7112 -> 7111;
7113 -> 7111;
7114 -> 7113;
7114 -> 7109;
7115 -> 7109;
7116 -> 7110;
7116 -> 7115;
7117 -> 7116;
7117 -> 7096;
7117 -> 7115;
7118 -> 7117;
7118 -> 7111;
7119 -> 7117;
7119 -> 7115;
7120 -> 7119;
7120 -> 7096;
7120 -> 7115;
7121 -> 7120;
7121 -> 7111;
7122 -> 7120;
7122 -> 7115;
7123 -> 7115;
7124 -> 7123;
7124 -> 7109;
7125 -> 7124;
7125 -> 7114;
7125 -> 7109;
7126 -> 7125;
7126 -> 7088;
7127 -> 7088;
7128 -> 7126;
7128 -> 7127;
7129 -> 7128;
7129 -> 7127;
7130 -> 0;
7130 -> 7129;
7131 -> 7130;
7131 -> 7079;
7131 -> 7088;
7132 -> 7125;
7132 -> 7078;
7133 -> 7132;
7133 -> 7077;
7134 -> 7077;
7135 -> 7133;
7135 -> 7134;
7135 -> 7077;
7136 -> 7007;
7136 -> 7135;
7137 -> 6748;
7138 -> 7136;
7138 -> 7137;
7139 -> 7138;
7139 -> 6998;
7139 -> 7137;
7140 -> 7137;
7141 -> 7139;
7141 -> 7140;
7142 -> 7138;
7142 -> 7000;
7142 -> 7140;
7143 -> 7141;
7143 -> 7140;
7144 -> 7143;
7144 -> 7137;
7145 -> 6684;
7145 -> 7096;
7145 -> 6685;
7146 -> 7144;
7146 -> 6685;
7147 -> 3100;
7147 -> 6685;
7148 -> 7145;
7148 -> 7146;
7148 -> 7147;
7148 -> 7096;
7148 -> 7131;
7148 -> 6685;
7149 -> 6684;
7149 -> 7148;
7149 -> 6682;
7150 -> 7149;
7150 -> 6678;
7151 -> 7150;
7151 -> 6675;
7152 -> 6675;
7153 -> 7151;
7153 -> 7152;
7153 -> 6675;
7154 -> 7151;
7154 -> 6675;
7155 -> 6676;
7155 -> 6675;
7156 -> 6675;
7157 -> 7154;
7157 -> 7156;
7158 -> 7155;
7158 -> 7156;
7159 -> 7156;
7160 -> 7157;
7160 -> 7159;
7160 -> 7156;
7161 -> 7156;
7162 -> 7158;
7162 -> 7161;
7162 -> 7156;
7163 -> 7156;
7164 -> 7158;
7164 -> 7163;
7165 -> 7163;
7166 -> 7164;
7166 -> 7165;
7167 -> 7165;
7168 -> 7166;
7168 -> 7167;
7169 -> 7167;
7170 -> 7168;
7170 -> 7169;
7171 -> 7169;
7172 -> 7170;
7172 -> 7171;
7173 -> 7172;
7173 -> 7171;
7174 -> 7173;
7174 -> 7169;
7175 -> 7174;
7175 -> 7167;
7176 -> 7175;
7176 -> 7165;
7177 -> 7176;
7177 -> 7163;
7178 -> 7177;
7178 -> 7156;
7179 -> 7156;
7180 -> 7157;
7180 -> 7156;
7181 -> 7156;
7182 -> 7157;
7182 -> 7181;
7183 -> 7181;
7184 -> 7183;
7184 -> 7156;
7185 -> 7179;
7185 -> 7156;
7186 -> 7156;
7187 -> 7180;
7187 -> 7186;
7188 -> 7184;
7188 -> 7186;
7189 -> 7185;
7189 -> 7186;
7190 -> 7186;
7191 -> 7187;
7191 -> 7190;
7191 -> 7186;
7192 -> 7186;
7193 -> 7187;
7193 -> 7192;
7194 -> 7193;
7194 -> 7192;
7195 -> 7194;
7195 -> 7186;
7196 -> 7195;
7196 -> 7186;
7197 -> 7196;
7197 -> 7189;
7197 -> 7148;
7197 -> 7179;
7197 -> 7186;
7198 -> 7186;
7199 -> 7197;
7199 -> 7198;
7200 -> 7198;
7201 -> 7199;
7201 -> 7200;
7202 -> 7201;
7202 -> 7198;
7203 -> 7198;
7204 -> 7199;
7204 -> 7203;
7205 -> 7204;
7205 -> 7198;
7206 -> 7205;
7207 -> 7195;
7207 -> 7206;
7208 -> 7207;
7208 -> 7205;
7208 -> 7206;
7209 -> 7208;
7209 -> 7205;
7210 -> 7209;
7211 -> 7209;
7212 -> 7210;
7212 -> 7211;
7213 -> 7211;
7214 -> 7211;
7215 -> 7211;
7215 -> 7214;
7216 -> 0;
7216 -> 7214;
7217 -> 7216;
7217 -> 7211;
7218 -> 7211;
7219 -> 7213;
7219 -> 7211;
7220 -> 7211;
7221 -> 7211;
7222 -> 7211;
7223 -> 7211;
7224 -> 7211;
7225 -> 7224;
7225 -> 7211;
7226 -> 7225;
7226 -> 7224;
7226 -> 7211;
7227 -> 7225;
7227 -> 7211;
7228 -> 7227;
7229 -> 7228;
7229 -> 7224;
7229 -> 7211;
7230 -> 7211;
7231 -> 7230;
7231 -> 7224;
7231 -> 7211;
7232 -> 7224;
7232 -> 7211;
7233 -> 7211;
7234 -> 7232;
7234 -> 7211;
7235 -> 7211;
7236 -> 7211;
7236 -> 7235;
7237 -> 0;
7237 -> 7235;
7238 -> 7237;
7238 -> 7211;
7239 -> 7238;
7239 -> 7211;
7240 -> 7211;
7241 -> 7239;
7241 -> 7240;
7242 -> 7234;
7242 -> 7240;
7243 -> 7241;
7243 -> 0;
7243 -> 7240;
7244 -> 7241;
7244 -> 7243;
7245 -> 7211;
7246 -> 7211;
7246 -> 7245;
7247 -> 7246;
7247 -> 7211;
7247 -> 7245;
7248 -> 7247;
7248 -> 7211;
7249 -> 7211;
7250 -> 7248;
7250 -> 7211;
7251 -> 7248;
7251 -> 7250;
7252 -> 7251;
7252 -> 7211;
7253 -> 7248;
7253 -> 7211;
7254 -> 7238;
7254 -> 7244;
7254 -> 7211;
7255 -> 7254;
7255 -> 7252;
7255 -> 7211;
7256 -> 7211;
7257 -> 7211;
7257 -> 7256;
7258 -> 7256;
7259 -> 7258;
7259 -> 7256;
7260 -> 7259;
7260 -> 7256;
7261 -> 7257;
7261 -> 7256;
7262 -> 7256;
7263 -> 7261;
7263 -> 7262;
7264 -> 7262;
7265 -> 7264;
7265 -> 7256;
7266 -> 7256;
7267 -> 7261;
7267 -> 7266;
7268 -> 7267;
7268 -> 7211;
7268 -> 7266;
7269 -> 7268;
7269 -> 7256;
7270 -> 7256;
7271 -> 7269;
7271 -> 7270;
7272 -> 0;
7272 -> 7270;
7273 -> 7272;
7273 -> 7256;
7274 -> 7265;
7274 -> 7273;
7274 -> 7256;
7275 -> 7256;
7276 -> 7261;
7276 -> 7275;
7277 -> 7276;
7277 -> 7275;
7278 -> 7277;
7278 -> 7211;
7278 -> 7275;
7279 -> 7278;
7279 -> 7256;
7280 -> 7256;
7281 -> 7279;
7281 -> 7280;
7282 -> 7256;
7283 -> 7281;
7283 -> 7282;
7284 -> 7282;
7284 -> 7256;
7285 -> 7256;
7286 -> 7274;
7286 -> 7284;
7286 -> 7256;
7287 -> 7256;
7288 -> 7261;
7288 -> 7287;
7289 -> 7288;
7289 -> 7256;
7290 -> 7289;
7290 -> 2687;
7290 -> 7256;
7291 -> 7286;
7291 -> 7290;
7291 -> 7256;
7292 -> 7256;
7293 -> 7256;
7293 -> 7211;
7294 -> 7224;
7294 -> 7211;
7295 -> 7224;
7295 -> 7211;
7296 -> 7224;
7296 -> 7211;
7297 -> 7294;
7297 -> 0;
7297 -> 7211;
7298 -> 7294;
7298 -> 7211;
7299 -> 7224;
7299 -> 7298;
7300 -> 7298;
7301 -> 7299;
7301 -> 7300;
7302 -> 7300;
7303 -> 7301;
7303 -> 7302;
7304 -> 7302;
7305 -> 7303;
7305 -> 7304;
7306 -> 7304;
7307 -> 7305;
7307 -> 7306;
7308 -> 7307;
7308 -> 7304;
7309 -> 7308;
7309 -> 7302;
7310 -> 7309;
7310 -> 7300;
7311 -> 7300;
7312 -> 7310;
7312 -> 7311;
7313 -> 7294;
7313 -> 7211;
7314 -> 7295;
7314 -> 7211;
7315 -> 7211;
7316 -> 7314;
7316 -> 7315;
7317 -> 7316;
7317 -> 7295;
7317 -> 7315;
7318 -> 6961;
7318 -> 7317;
7319 -> 7313;
7319 -> 7211;
7320 -> 7318;
7320 -> 7211;
7321 -> 7224;
7321 -> 7211;
7322 -> 7321;
7322 -> 7211;
7323 -> 7224;
7323 -> 7322;
7324 -> 7322;
7325 -> 7323;
7325 -> 7324;
7326 -> 7324;
7327 -> 7325;
7327 -> 7326;
7328 -> 7326;
7329 -> 7327;
7329 -> 7328;
7330 -> 7328;
7331 -> 7329;
7331 -> 7330;
7332 -> 7331;
7332 -> 7328;
7333 -> 7332;
7333 -> 7326;
7334 -> 7333;
7334 -> 7324;
7335 -> 7324;
7336 -> 7334;
7336 -> 7335;
7337 -> 7319;
7337 -> 0;
7337 -> 7211;
7338 -> 7211;
7339 -> 7336;
7339 -> 7338;
7339 -> 7211;
7340 -> 7211;
7341 -> 7320;
7341 -> 7340;
7341 -> 7211;
7342 -> 7319;
7342 -> 7224;
7342 -> 7211;
7343 -> 7320;
7343 -> 7224;
7343 -> 7211;
7344 -> 7224;
7344 -> 7211;
7345 -> 7211;
7346 -> 7224;
7346 -> 7345;
7347 -> 7346;
7347 -> 7224;
7347 -> 7345;
7348 -> 7347;
7348 -> 7345;
7349 -> 7348;
7349 -> 7211;
7350 -> 7211;
7351 -> 7344;
7351 -> 7350;
7352 -> 7350;
7353 -> 7351;
7353 -> 7352;
7354 -> 7352;
7355 -> 7353;
7355 -> 7354;
7356 -> 7354;
7357 -> 7355;
7357 -> 7356;
7358 -> 7356;
7359 -> 7357;
7359 -> 7358;
7360 -> 7359;
7360 -> 7356;
7361 -> 7360;
7361 -> 7354;
7362 -> 7361;
7362 -> 7352;
7363 -> 7362;
7363 -> 7350;
7364 -> 7363;
7364 -> 7211;
7365 -> 7211;
7366 -> 7344;
7366 -> 7365;
7367 -> 7365;
7368 -> 7366;
7368 -> 7367;
7369 -> 7367;
7370 -> 7368;
7370 -> 7369;
7371 -> 0;
7371 -> 7369;
7372 -> 7371;
7372 -> 7367;
7373 -> 7368;
7373 -> 7365;
7374 -> 7373;
7374 -> 7211;
7375 -> 7211;
7376 -> 7344;
7376 -> 7211;
7377 -> 7211;
7378 -> 7376;
7378 -> 7377;
7379 -> 7375;
7379 -> 7377;
7380 -> 7378;
7380 -> 7377;
7381 -> 7377;
7382 -> 7378;
7382 -> 7381;
7383 -> 7381;
7383 -> 7377;
7384 -> 7377;
7385 -> 7377;
7386 -> 7378;
7386 -> 7385;
7387 -> 0;
7387 -> 7385;
7388 -> 7386;
7388 -> 7377;
7389 -> 7377;
7390 -> 7378;
7390 -> 7389;
7391 -> 7390;
7391 -> 7211;
7391 -> 7389;
7392 -> 7391;
7392 -> 7377;
7393 -> 7392;
7393 -> 7377;
7394 -> 7377;
7395 -> 7394;
7395 -> 7211;
7396 -> 7224;
7397 -> 7396;
7397 -> 7224;
7398 -> 7224;
7399 -> 7396;
7400 -> 7396;
7400 -> 7399;
7401 -> 0;
7401 -> 7399;
7402 -> 7401;
7402 -> 7396;
7403 -> 7224;
7403 -> 7396;
7404 -> 7403;
7404 -> 7396;
7405 -> 7403;
7405 -> 7396;
7406 -> 7405;
7406 -> 7396;
7407 -> 7406;
7407 -> 7396;
7408 -> 7406;
7408 -> 7396;
7409 -> 7408;
7409 -> 7396;
7410 -> 7409;
7410 -> 7396;
7411 -> 7409;
7411 -> 7396;
7412 -> 7396;
7412 -> 7343;
7412 -> 7211;
7413 -> 7396;
7413 -> 7209;
7414 -> 7188;
7414 -> 7209;
7415 -> 7189;
7415 -> 7209;
7416 -> 7209;
7417 -> 7413;
7417 -> 7416;
7418 -> 7414;
7418 -> 7416;
7419 -> 7415;
7419 -> 7416;
7420 -> 7416;
7421 -> 7417;
7421 -> 7420;
7421 -> 7416;
7422 -> 7416;
7423 -> 7417;
7423 -> 7422;
7424 -> 7423;
7424 -> 7416;
7425 -> 0;
7425 -> 7424;
7426 -> 7425;
7427 -> 7425;
7428 -> 7425;
7429 -> 7425;
7429 -> 7428;
7430 -> 0;
7430 -> 7428;
7431 -> 7430;
7431 -> 7425;
7432 -> 7425;
7433 -> 7418;
7433 -> 7425;
7434 -> 7425;
7435 -> 7432;
7435 -> 7434;
7435 -> 7425;
7436 -> 7435;
7437 -> 7425;
7438 -> 7418;
7438 -> 7437;
7438 -> 7425;
7439 -> 7205;
7440 -> 7188;
7440 -> 7439;
7440 -> 7205;
7441 -> 7156;
7442 -> 7158;
7442 -> 7156;
7443 -> 7442;
7443 -> 7179;
7443 -> 7432;
7443 -> 7156;
7444 -> 7156;
7445 -> 7444;
7446 -> 7444;
7447 -> 7179;
7447 -> 7443;
7447 -> 7156;
7448 -> 7443;
7448 -> 7156;
7449 -> 6675;
7450 -> 6676;
7450 -> 7449;
7451 -> 7449;
7452 -> 7451;
7452 -> 7450;
7452 -> 7449;
7453 -> 6675;
7454 -> 7151;
7454 -> 6675;
7455 -> 7454;
7455 -> 6672;
7456 -> 3100;
7456 -> 6672;
7457 -> 6674;
7457 -> 7455;
7457 -> 7456;
7457 -> 7447;
7457 -> 7452;
7457 -> 6672;
7458 -> 6671;
7458 -> 7457;
7458 -> 6670;
7459 -> 7458;
7459 -> 6668;
7460 -> 6668;
7461 -> 7459;
7461 -> 7460;
7461 -> 6668;
7462 -> 7459;
7462 -> 7461;
7463 -> 7461;
7464 -> 7462;
7464 -> 7463;
7465 -> 7463;
7466 -> 7464;
7466 -> 7465;
7466 -> 7463;
7467 -> 7463;
7468 -> 7464;
7468 -> 7467;
7469 -> 7467;
7469 -> 7463;
7470 -> 7469;
7470 -> 7461;
7471 -> 7461;
7472 -> 7471;
7473 -> 7471;
7474 -> 7471;
7475 -> 7471;
7476 -> 7471;
7477 -> 7471;
7478 -> 7471;
7478 -> 7477;
7479 -> 7477;
7480 -> 7478;
7480 -> 7479;
7481 -> 7479;
7482 -> 7480;
7482 -> 7481;
7483 -> 7481;
7484 -> 7482;
7484 -> 7483;
7485 -> 7483;
7486 -> 7484;
7486 -> 7485;
7487 -> 7486;
7487 -> 7483;
7488 -> 7487;
7488 -> 7481;
7489 -> 7488;
7489 -> 7479;
7490 -> 7489;
7490 -> 7477;
7491 -> 7490;
7491 -> 7471;
7492 -> 7471;
7493 -> 7471;
7493 -> 7492;
7494 -> 7492;
7495 -> 7494;
7495 -> 7471;
7496 -> 7471;
7497 -> 7496;
7498 -> 7471;
7499 -> 7495;
7499 -> 7498;
7499 -> 7471;
7500 -> 7471;
7501 -> 7471;
7502 -> 7471;
7502 -> 7461;
7503 -> 7502;
7504 -> 7502;
7505 -> 7503;
7505 -> 7504;
7506 -> 7504;
7507 -> 7505;
7507 -> 7506;
7507 -> 7504;
7508 -> 7504;
7509 -> 7505;
7509 -> 7508;
7510 -> 7508;
7510 -> 7504;
7511 -> 7510;
7511 -> 7502;
7512 -> 7502;
7513 -> 7502;
7514 -> 7502;
7515 -> 7514;
7516 -> 6668;
7517 -> 7516;
7517 -> 6664;
7518 -> 6664;
7519 -> 6667;
7519 -> 7518;
7520 -> 7517;
7520 -> 7518;
7521 -> 6665;
7521 -> 7518;
7522 -> 7518;
7523 -> 7520;
7523 -> 7522;
7523 -> 7518;
7524 -> 7523;
7525 -> 6664;
7526 -> 6665;
7526 -> 7525;
7527 -> 7525;
7528 -> 7526;
7528 -> 7527;
7529 -> 7528;
7529 -> 7515;
7529 -> 7527;
7530 -> 7527;
7531 -> 7529;
7531 -> 7530;
7532 -> 0;
7532 -> 7530;
7533 -> 7532;
7533 -> 7527;
7534 -> 7527;
7535 -> 7529;
7535 -> 7525;
7536 -> 7535;
7536 -> 6664;
7537 -> 6664;
7538 -> 7536;
7538 -> 7537;
7539 -> 7537;
7540 -> 7538;
7540 -> 7539;
7541 -> 7539;
7542 -> 7540;
7542 -> 7541;
7543 -> 7541;
7544 -> 7542;
7544 -> 7515;
7544 -> 7543;
7544 -> 7541;
7545 -> 7539;
7546 -> 7540;
7546 -> 7537;
7547 -> 7537;
7548 -> 7519;
7548 -> 6664;
7549 -> 7548;
7549 -> 6660;
7550 -> 6660;
7551 -> 6663;
7551 -> 7550;
7552 -> 7549;
7552 -> 7550;
7553 -> 6661;
7553 -> 7550;
7554 -> 7550;
7555 -> 7552;
7555 -> 7554;
7555 -> 7550;
7556 -> 7555;
7557 -> 7556;
7558 -> 6661;
7558 -> 7557;
7559 -> 7558;
7559 -> 7515;
7559 -> 7557;
7560 -> 7557;
7561 -> 7559;
7561 -> 7560;
7562 -> 0;
7562 -> 7560;
7563 -> 7562;
7563 -> 7557;
7564 -> 7557;
7565 -> 7559;
7565 -> 7556;
7566 -> 7556;
7567 -> 7565;
7567 -> 7566;
7568 -> 6661;
7568 -> 7515;
7568 -> 7556;
7569 -> 7567;
7570 -> 6661;
7570 -> 7569;
7571 -> 7570;
7571 -> 7567;
7571 -> 7569;
7572 -> 7571;
7572 -> 0;
7572 -> 7569;
7573 -> 7570;
7573 -> 7567;
7573 -> 7572;
7574 -> 7573;
7575 -> 7573;
7576 -> 7574;
7576 -> 7575;
7577 -> 7575;
7577 -> 7573;
7578 -> 0;
7578 -> 7573;
7579 -> 7573;
7580 -> 7577;
7580 -> 7579;
7580 -> 7573;
7581 -> 7580;
7582 -> 7581;
7582 -> 7580;
7583 -> 7582;
7583 -> 7580;
7584 -> 7583;
7585 -> 7584;
7585 -> 7583;
7586 -> 0;
7586 -> 7585;
7587 -> 7586;
7587 -> 7570;
7587 -> 7572;
7588 -> 7586;
7588 -> 7569;
7589 -> 7588;
7589 -> 7567;
7590 -> 7551;
7590 -> 6660;
7591 -> 7590;
7591 -> 6658;
7592 -> 7591;
7592 -> 6657;
7592 -> 6658;
7593 -> 6657;
7593 -> 7567;
7593 -> 7592;
7593 -> 6656;
7594 -> 7593;
7594 -> 6652;
7595 -> 6652;
7596 -> 7594;
7596 -> 7595;
7596 -> 6652;
7597 -> 6646;
7597 -> 5474;
7598 -> 5455;
7598 -> 7567;
7598 -> 5451;
7599 -> 5451;
7600 -> 7598;
7600 -> 7599;
7601 -> 5454;
7601 -> 7599;
7602 -> 7600;
7602 -> 7567;
7602 -> 7599;
7603 -> 7602;
7603 -> 7567;
7603 -> 7587;
7603 -> 7592;
7603 -> 7599;
7604 -> 7600;
7604 -> 7567;
7604 -> 7599;
7605 -> 7599;
7606 -> 7604;
7606 -> 7605;
7607 -> 7604;
7607 -> 7605;
7608 -> 7601;
7608 -> 7605;
7609 -> 7606;
7609 -> 7605;
7610 -> 7607;
7610 -> 7605;
7611 -> 7609;
7611 -> 7610;
7611 -> 7603;
7611 -> 7605;
7612 -> 7611;
7612 -> 7605;
7613 -> 7612;
7614 -> 7608;
7614 -> 5370;
7614 -> 7613;
7615 -> 7614;
7615 -> 7612;
7616 -> 0;
7616 -> 7612;
7617 -> 7612;
7618 -> 7608;
7618 -> 7617;
7619 -> 7618;
7619 -> 5368;
7619 -> 7617;
7620 -> 7619;
7620 -> 7615;
7620 -> 7617;
7621 -> 7617;
7622 -> 7618;
7622 -> 5368;
7622 -> 7621;
7623 -> 7622;
7623 -> 7620;
7623 -> 7621;
7624 -> 7623;
7624 -> 7621;
7625 -> 7621;
7626 -> 7624;
7626 -> 7625;
7627 -> 7625;
7628 -> 7626;
7628 -> 7623;
7628 -> 7627;
7629 -> 7628;
7629 -> 7625;
7630 -> 7629;
7631 -> 7630;
7631 -> 7621;
7632 -> 7631;
7632 -> 7621;
7633 -> 7597;
7633 -> 5451;
7634 -> 5451;
7635 -> 5451;
7636 -> 7632;
7636 -> 7635;
7637 -> 7633;
7637 -> 7635;
7638 -> 7634;
7638 -> 7635;
7639 -> 7637;
7639 -> 7635;
7640 -> 7637;
7640 -> 7635;
7641 -> 7638;
7641 -> 7635;
7642 -> 7636;
7642 -> 7641;
7643 -> 0;
7643 -> 7642;
7644 -> 7635;
7645 -> 7635;
7646 -> 7640;
7646 -> 7645;
7647 -> 7643;
7647 -> 7645;
7648 -> 7644;
7648 -> 7645;
7649 -> 7646;
7649 -> 7645;
7650 -> 7647;
7650 -> 0;
7650 -> 7645;
7651 -> 7647;
7651 -> 7645;
7652 -> 7646;
7652 -> 7651;
7653 -> 7651;
7654 -> 7652;
7654 -> 7653;
7655 -> 7653;
7656 -> 7654;
7656 -> 7655;
7657 -> 7655;
7658 -> 7656;
7658 -> 7657;
7659 -> 7657;
7660 -> 7658;
7660 -> 7659;
7661 -> 7660;
7661 -> 7657;
7662 -> 7661;
7662 -> 7655;
7663 -> 7662;
7663 -> 7653;
7664 -> 7653;
7665 -> 7663;
7665 -> 7664;
7666 -> 7646;
7666 -> 7645;
7667 -> 7648;
7667 -> 7645;
7668 -> 7645;
7669 -> 7666;
7669 -> 7668;
7670 -> 7647;
7670 -> 7668;
7671 -> 7667;
7671 -> 7668;
7672 -> 7669;
7672 -> 7668;
7673 -> 7671;
7673 -> 7668;
7674 -> 7668;
7675 -> 7673;
7675 -> 7674;
7676 -> 7675;
7676 -> 7667;
7676 -> 7674;
7677 -> 6961;
7677 -> 7676;
7678 -> 7668;
7679 -> 7668;
7680 -> 7672;
7680 -> 7679;
7681 -> 7670;
7681 -> 7679;
7682 -> 7677;
7682 -> 7679;
7683 -> 7678;
7683 -> 7679;
7684 -> 7680;
7684 -> 7679;
7685 -> 7684;
7685 -> 7679;
7686 -> 7680;
7686 -> 7685;
7687 -> 7685;
7688 -> 7686;
7688 -> 7687;
7689 -> 7687;
7690 -> 7688;
7690 -> 7689;
7691 -> 7689;
7692 -> 7690;
7692 -> 7691;
7693 -> 7691;
7694 -> 7692;
7694 -> 7693;
7695 -> 7694;
7695 -> 7693;
7696 -> 7695;
7696 -> 7691;
7697 -> 7696;
7697 -> 7689;
7698 -> 7697;
7698 -> 7687;
7699 -> 7687;
7700 -> 7698;
7700 -> 7699;
7701 -> 7700;
7701 -> 7623;
7701 -> 7699;
7702 -> 7681;
7702 -> 0;
7702 -> 7679;
7703 -> 7679;
7704 -> 7701;
7704 -> 7703;
7704 -> 7679;
7705 -> 7679;
7706 -> 7682;
7706 -> 7705;
7706 -> 7679;
7707 -> 7680;
7707 -> 7683;
7707 -> 7679;
7708 -> 7681;
7708 -> 7683;
7708 -> 7679;
7709 -> 7682;
7709 -> 7683;
7709 -> 7679;
7710 -> 7678;
7710 -> 7645;
7711 -> 7710;
7711 -> 7635;
7712 -> 7711;
7712 -> 5451;
7713 -> 7712;
7713 -> 7635;
7714 -> 7713;
7714 -> 7635;
7715 -> 7635;
7716 -> 7635;
7717 -> 7714;
7717 -> 7716;
7718 -> 7715;
7718 -> 7716;
7719 -> 7716;
7720 -> 7717;
7720 -> 7719;
7721 -> 7720;
7721 -> 7707;
7721 -> 7719;
7722 -> 7721;
7722 -> 7719;
7723 -> 7722;
7723 -> 7716;
7724 -> 7717;
7724 -> 7718;
7724 -> 7716;
7725 -> 7716;
7726 -> 7725;
7726 -> 7718;
7726 -> 7716;
7727 -> 7716;
7728 -> 7727;
7728 -> 7718;
7728 -> 7716;
7729 -> 7715;
7729 -> 5451;
7730 -> 7729;
7730 -> 5439;
7731 -> 5438;
7732 -> 7730;
7732 -> 7731;
7733 -> 7731;
7734 -> 7732;
7734 -> 7724;
7734 -> 7733;
7735 -> 7734;
7735 -> 7707;
7735 -> 7733;
7736 -> 7735;
7736 -> 7733;
7737 -> 7736;
7737 -> 7733;
7738 -> 7737;
7738 -> 7731;
7739 -> 7738;
7739 -> 5438;
7740 -> 7739;
7741 -> 7740;
7741 -> 7739;
7742 -> 7741;
7743 -> 7730;
7743 -> 7742;
7744 -> 7743;
7744 -> 7724;
7744 -> 7742;
7745 -> 7744;
7745 -> 7741;
7746 -> 5443;
7746 -> 7741;
7747 -> 5439;
7747 -> 7741;
7748 -> 5440;
7748 -> 7741;
7749 -> 7741;
7750 -> 7746;
7750 -> 7749;
7751 -> 7747;
7751 -> 7749;
7752 -> 7748;
7752 -> 7749;
7753 -> 7745;
7753 -> 7749;
7754 -> 7753;
7754 -> 7749;
7755 -> 7750;
7755 -> 7749;
7756 -> 7751;
7756 -> 7749;
7757 -> 7752;
7757 -> 7749;
7758 -> 7749;
7759 -> 7754;
7759 -> 7758;
7760 -> 7755;
7760 -> 7758;
7761 -> 7756;
7761 -> 7758;
7762 -> 7757;
7762 -> 7758;
7763 -> 7753;
7763 -> 7709;
7763 -> 7758;
7764 -> 7760;
7764 -> 7758;
7765 -> 7761;
7765 -> 7758;
7766 -> 7762;
7766 -> 7758;
7767 -> 7758;
7768 -> 7764;
7768 -> 7767;
7769 -> 7765;
7769 -> 7767;
7770 -> 7766;
7770 -> 7767;
7771 -> 7759;
7771 -> 7767;
7772 -> 7770;
7772 -> 7767;
7773 -> 7767;
7774 -> 7771;
7774 -> 7773;
7775 -> 7774;
7775 -> 7707;
7775 -> 7773;
7776 -> 7773;
7777 -> 7775;
7777 -> 7776;
7778 -> 7774;
7778 -> 7709;
7778 -> 7776;
7779 -> 7777;
7779 -> 7776;
7780 -> 7779;
7780 -> 7773;
7781 -> 7780;
7781 -> 7767;
7782 -> 7769;
7782 -> 7767;
7783 -> 7767;
7784 -> 7767;
7785 -> 7772;
7785 -> 7784;
7786 -> 7781;
7786 -> 7784;
7787 -> 7782;
7787 -> 7784;
7788 -> 7783;
7788 -> 7784;
7789 -> 7768;
7789 -> 7784;
7790 -> 7785;
7790 -> 7784;
7791 -> 7786;
7791 -> 7784;
7792 -> 7787;
7792 -> 7784;
7793 -> 7788;
7793 -> 7784;
7794 -> 7784;
7795 -> 7790;
7795 -> 7794;
7796 -> 7791;
7796 -> 7794;
7797 -> 7792;
7797 -> 7794;
7798 -> 7793;
7798 -> 7794;
7799 -> 7789;
7799 -> 7794;
7800 -> 7794;
7801 -> 7796;
7801 -> 7800;
7802 -> 7800;
7802 -> 7794;
7803 -> 7795;
7803 -> 7802;
7804 -> 7796;
7804 -> 7802;
7805 -> 7797;
7805 -> 7802;
7806 -> 7798;
7806 -> 7802;
7807 -> 7802;
7808 -> 7799;
7808 -> 7807;
7809 -> 7808;
7809 -> 5379;
7809 -> 7807;
7810 -> 7809;
7810 -> 7802;
7811 -> 7802;
7812 -> 7799;
7812 -> 7811;
7813 -> 7811;
7814 -> 7812;
7814 -> 7813;
7815 -> 7814;
7815 -> 5379;
7815 -> 7813;
7816 -> 7815;
7816 -> 7811;
7817 -> 7816;
7817 -> 7811;
7818 -> 7811;
7819 -> 7816;
7819 -> 7818;
7820 -> 0;
7820 -> 7818;
7821 -> 7820;
7821 -> 7811;
7822 -> 7817;
7822 -> 7821;
7822 -> 7811;
7823 -> 7816;
7823 -> 7811;
7824 -> 7823;
7825 -> 7824;
7825 -> 7623;
7826 -> 7825;
7826 -> 7823;
7827 -> 7826;
7827 -> 7802;
7828 -> 7799;
7828 -> 5369;
7828 -> 7802;
7829 -> 7802;
7830 -> 7803;
7830 -> 7829;
7831 -> 7804;
7831 -> 7829;
7832 -> 7805;
7832 -> 7829;
7833 -> 7806;
7833 -> 7829;
7834 -> 7810;
7834 -> 7829;
7835 -> 7827;
7835 -> 7829;
7836 -> 7828;
7836 -> 7829;
7837 -> 7831;
7837 -> 7829;
7838 -> 7837;
7838 -> 7623;
7838 -> 7829;
7839 -> 7829;
7840 -> 7831;
7840 -> 7839;
7841 -> 7839;
7841 -> 7829;
7842 -> 7829;
7843 -> 7831;
7843 -> 7842;
7844 -> 7842;
7844 -> 7829;
7845 -> 7831;
7845 -> 7829;
7846 -> 7835;
7846 -> 7829;
7847 -> 7829;
7848 -> 7845;
7848 -> 7847;
7849 -> 7846;
7849 -> 7847;
7850 -> 7847;
7851 -> 7848;
7851 -> 7850;
7852 -> 7850;
7852 -> 7847;
7853 -> 7848;
7853 -> 7852;
7854 -> 7833;
7854 -> 7829;
7855 -> 7854;
7855 -> 7829;
7856 -> 7830;
7856 -> 7829;
7857 -> 7853;
7857 -> 7829;
7858 -> 7832;
7858 -> 7829;
7859 -> 7834;
7859 -> 7829;
7860 -> 7836;
7860 -> 7829;
7861 -> 7829;
7862 -> 7856;
7862 -> 7861;
7863 -> 7857;
7863 -> 7861;
7864 -> 7858;
7864 -> 7861;
7865 -> 7859;
7865 -> 7861;
7866 -> 7860;
7866 -> 7861;
7867 -> 7861;
7868 -> 7862;
7868 -> 7867;
7868 -> 7861;
7869 -> 7863;
7869 -> 7861;
7870 -> 7865;
7870 -> 7861;
7871 -> 7861;
7872 -> 7861;
7873 -> 7869;
7873 -> 7872;
7874 -> 7870;
7874 -> 7872;
7875 -> 7871;
7875 -> 7872;
7876 -> 7872;
7877 -> 7873;
7877 -> 7876;
7878 -> 7876;
7879 -> 7877;
7879 -> 7878;
7880 -> 7878;
7881 -> 7879;
7881 -> 7880;
7882 -> 7881;
7882 -> 7838;
7882 -> 7880;
7883 -> 7880;
7884 -> 7882;
7884 -> 7883;
7884 -> 7880;
7885 -> 7880;
7886 -> 7881;
7886 -> 7885;
7887 -> 7885;
7888 -> 7886;
7888 -> 7887;
7889 -> 7888;
7889 -> 7838;
7889 -> 7887;
7890 -> 7887;
7891 -> 7889;
7891 -> 7890;
7892 -> 0;
7892 -> 7890;
7893 -> 7892;
7893 -> 7887;
7894 -> 7887;
7895 -> 7889;
7895 -> 7885;
7896 -> 7886;
7896 -> 7838;
7896 -> 7885;
7897 -> 7885;
7898 -> 7896;
7898 -> 7897;
7899 -> 7895;
7899 -> 7897;
7900 -> 7898;
7900 -> 7897;
7901 -> 7899;
7901 -> 7838;
7901 -> 7900;
7901 -> 7897;
7902 -> 7901;
7903 -> 7902;
7904 -> 7903;
7904 -> 7880;
7905 -> 7904;
7906 -> 7904;
7907 -> 7905;
7907 -> 7906;
7908 -> 7907;
7908 -> 7906;
7909 -> 0;
7909 -> 7907;
7909 -> 7906;
7910 -> 0;
7910 -> 7907;
7910 -> 7906;
7911 -> 7907;
7911 -> 7906;
7912 -> 7907;
7912 -> 7906;
7913 -> 7907;
7913 -> 7906;
7914 -> 7907;
7914 -> 7906;
7915 -> 3100;
7915 -> 7907;
7915 -> 7906;
7916 -> 0;
7916 -> 7907;
7916 -> 7906;
7917 -> 7881;
7917 -> 7901;
7917 -> 7904;
7918 -> 7905;
7918 -> 7904;
7919 -> 7904;
7920 -> 7917;
7920 -> 7918;
7920 -> 7919;
7920 -> 7908;
7920 -> 7909;
7920 -> 7910;
7920 -> 7911;
7920 -> 7912;
7920 -> 7913;
7920 -> 7914;
7920 -> 7915;
7920 -> 7916;
7920 -> 7901;
7920 -> 0;
7920 -> 7904;
7921 -> 7920;
7921 -> 7878;
7922 -> 7921;
7922 -> 5646;
7922 -> 7878;
7923 -> 7878;
7924 -> 7879;
7924 -> 7923;
7925 -> 7923;
7926 -> 7924;
7926 -> 7925;
7927 -> 7926;
7927 -> 7920;
7927 -> 7925;
7928 -> 7925;
7929 -> 7927;
7929 -> 7928;
7929 -> 7925;
7930 -> 7927;
7930 -> 5646;
7930 -> 7929;
7931 -> 7929;
7932 -> 7927;
7932 -> 7929;
7933 -> 7932;
7933 -> 7923;
7934 -> 7933;
7934 -> 5646;
7934 -> 7923;
7935 -> 7933;
7935 -> 7920;
7935 -> 7923;
7936 -> 0;
7936 -> 7935;
7937 -> 7935;
7938 -> 7937;
7939 -> 7938;
7939 -> 7935;
7940 -> 7939;
7941 -> 7940;
7942 -> 7940;
7942 -> 7941;
7943 -> 0;
7943 -> 7941;
7944 -> 7943;
7944 -> 7940;
7945 -> 7940;
7945 -> 7939;
7946 -> 7939;
7947 -> 7945;
7947 -> 7946;
7948 -> 7947;
7948 -> 7939;
7949 -> 7924;
7949 -> 7920;
7949 -> 7939;
7950 -> 7948;
7950 -> 7949;
7950 -> 7920;
7950 -> 7939;
7951 -> 7950;
7951 -> 7933;
7951 -> 7935;
7952 -> 7933;
7952 -> 7950;
7952 -> 7951;
7952 -> 7923;
7953 -> 7952;
7953 -> 7878;
7954 -> 7921;
7954 -> 7950;
7954 -> 7878;
7955 -> 7879;
7955 -> 7950;
7955 -> 7878;
7956 -> 7878;
7957 -> 7879;
7957 -> 7956;
7958 -> 7957;
7958 -> 7950;
7958 -> 7956;
7959 -> 7956;
7960 -> 7958;
7960 -> 7959;
7961 -> 0;
7961 -> 7959;
7962 -> 7961;
7962 -> 7956;
7963 -> 7956;
7964 -> 7958;
7964 -> 7878;
7965 -> 7953;
7965 -> 7878;
7966 -> 7878;
7967 -> 7954;
7967 -> 7966;
7968 -> 7955;
7968 -> 7966;
7969 -> 7964;
7969 -> 7966;
7970 -> 7965;
7970 -> 7966;
7971 -> 7967;
7971 -> 7966;
7972 -> 0;
7972 -> 7966;
7973 -> 7968;
7973 -> 7971;
7974 -> 7969;
7974 -> 7971;
7975 -> 7970;
7975 -> 7971;
7976 -> 7971;
7977 -> 7973;
7977 -> 7976;
7978 -> 7974;
7978 -> 7976;
7979 -> 7975;
7979 -> 7976;
7980 -> 7976;
7981 -> 7978;
7981 -> 7980;
7982 -> 7981;
7982 -> 7976;
7983 -> 7977;
7983 -> 7976;
7984 -> 7978;
7984 -> 7976;
7985 -> 7976;
7986 -> 7976;
7987 -> 7984;
7987 -> 7986;
7988 -> 7985;
7988 -> 7986;
7989 -> 7987;
7989 -> 7986;
7990 -> 7986;
7991 -> 7986;
7992 -> 7986;
7993 -> 7989;
7993 -> 7992;
7994 -> 7990;
7994 -> 7992;
7995 -> 7991;
7995 -> 7992;
7996 -> 7993;
7996 -> 7950;
7996 -> 7951;
7997 -> 7992;
7998 -> 7993;
7998 -> 7997;
7998 -> 7992;
7999 -> 7979;
7999 -> 7976;
8000 -> 7982;
8000 -> 7983;
8000 -> 7985;
8000 -> 7999;
8000 -> 7996;
8000 -> 7992;
8000 -> 7994;
8000 -> 7995;
8000 -> 7950;
8000 -> 7951;
8000 -> 7976;
8001 -> 7976;
8002 -> 8000;
8002 -> 8001;
8002 -> 7976;
8003 -> 8000;
8003 -> 7976;
8004 -> 7967;
8004 -> 7971;
8005 -> 8003;
8005 -> 7971;
8006 -> 0;
8006 -> 7971;
8007 -> 7878;
8008 -> 7921;
8008 -> 8005;
8008 -> 7878;
8009 -> 8008;
8009 -> 7876;
8010 -> 7876;
8011 -> 8009;
8011 -> 8010;
8011 -> 7876;
8012 -> 8011;
8012 -> 7876;
8013 -> 8012;
8013 -> 7872;
8014 -> 0;
8014 -> 8013;
8015 -> 7861;
8016 -> 8014;
8016 -> 7861;
8017 -> 7861;
8018 -> 8015;
8018 -> 8017;
8018 -> 7861;
8019 -> 8014;
8019 -> 7861;
8020 -> 8019;
8020 -> 7829;
8021 -> 7854;
8021 -> 8020;
8022 -> 7802;
8023 -> 7784;
8024 -> 7758;
8025 -> 7741;
8026 -> 7730;
8026 -> 7739;
8027 -> 8026;
8027 -> 5438;
8028 -> 5440;
8028 -> 5438;
8029 -> 5439;
8029 -> 5438;
8030 -> 5441;
8030 -> 5438;
8031 -> 5438;
8032 -> 8027;
8032 -> 8031;
8033 -> 8028;
8033 -> 8031;
8034 -> 8029;
8034 -> 8031;
8035 -> 8030;
8035 -> 8031;
8036 -> 5443;
8036 -> 8031;
8037 -> 8031;
8038 -> 8032;
8038 -> 8037;
8039 -> 8038;
8039 -> 7726;
8039 -> 8037;
8040 -> 8039;
8040 -> 0;
8040 -> 8037;
8041 -> 8040;
8041 -> 8031;
8042 -> 8032;
8042 -> 8031;
8043 -> 5438;
8044 -> 8042;
8044 -> 8043;
8045 -> 8044;
8045 -> 7724;
8045 -> 8043;
8046 -> 5427;
8047 -> 8045;
8047 -> 8046;
8048 -> 8047;
8048 -> 7707;
8048 -> 8046;
8049 -> 8046;
8050 -> 8048;
8050 -> 8049;
8051 -> 8047;
8051 -> 7709;
8051 -> 8049;
8052 -> 8049;
8053 -> 8050;
8053 -> 8052;
8054 -> 8053;
8054 -> 8005;
8054 -> 0;
8054 -> 8052;
8055 -> 8052;
8056 -> 8054;
8056 -> 5427;
8057 -> 5432;
8057 -> 5427;
8058 -> 8057;
8059 -> 5433;
8059 -> 8058;
8060 -> 8059;
8060 -> 5369;
8060 -> 8058;
8061 -> 0;
8061 -> 8058;
8062 -> 8058;
8063 -> 8060;
8063 -> 8062;
8064 -> 8061;
8064 -> 8062;
8065 -> 8063;
8065 -> 8057;
8066 -> 5429;
8066 -> 8065;
8067 -> 8045;
8067 -> 8065;
8068 -> 8067;
8068 -> 7707;
8068 -> 7708;
8068 -> 7709;
8068 -> 8005;
8068 -> 6960;
8068 -> 0;
8068 -> 8065;
8069 -> 8066;
8069 -> 8068;
8069 -> 5148;
8069 -> 8065;
8070 -> 5427;
8071 -> 5428;
8071 -> 8069;
8071 -> 8070;
8071 -> 5427;
8072 -> 5428;
8072 -> 8069;
8072 -> 8071;
8073 -> 8072;
8073 -> 8071;
8074 -> 8071;
8075 -> 8073;
8075 -> 8072;
8075 -> 8074;
8075 -> 8071;
8076 -> 5430;
8076 -> 8075;
8076 -> 8071;
8077 -> 8071;
8078 -> 8077;
8078 -> 8075;
8079 -> 8077;
8079 -> 8075;
8080 -> 8079;
8080 -> 8077;
8081 -> 8077;
8081 -> 8075;
8082 -> 8081;
8082 -> 8071;
8083 -> 8045;
8083 -> 8071;
8084 -> 8072;
8084 -> 8081;
8084 -> 8071;
8085 -> 8071;
8086 -> 8082;
8086 -> 8085;
8087 -> 8083;
8087 -> 8085;
8088 -> 8084;
8088 -> 8085;
8089 -> 8085;
8090 -> 8088;
8090 -> 8089;
8090 -> 8085;
8091 -> 8086;
8091 -> 8090;
8092 -> 8087;
8092 -> 8090;
8093 -> 8090;
8094 -> 8091;
8094 -> 8093;
8095 -> 8092;
8095 -> 8093;
8096 -> 8095;
8096 -> 8093;
8097 -> 0;
8097 -> 8093;
8098 -> 8093;
8099 -> 8097;
8099 -> 8098;
8100 -> 8094;
8100 -> 8098;
8101 -> 8098;
8102 -> 8100;
8102 -> 8101;
8103 -> 8102;
8103 -> 8098;
8104 -> 8103;
8105 -> 8103;
8105 -> 8104;
8106 -> 8104;
8107 -> 8105;
8107 -> 8106;
8108 -> 8106;
8109 -> 8107;
8109 -> 8081;
8109 -> 8108;
8109 -> 8106;
8110 -> 8104;
8111 -> 8105;
8111 -> 8081;
8111 -> 8104;
8112 -> 8111;
8112 -> 8103;
8113 -> 8103;
8114 -> 8100;
8114 -> 8081;
8114 -> 8099;
8114 -> 8098;
8115 -> 8100;
8115 -> 8081;
8115 -> 8099;
8115 -> 8098;
8116 -> 8094;
8116 -> 8093;
8117 -> 8093;
8118 -> 8096;
8118 -> 8117;
8119 -> 8116;
8119 -> 8117;
8120 -> 8117;
8121 -> 0;
8121 -> 8117;
8122 -> 8117;
8123 -> 8121;
8123 -> 8122;
8124 -> 8119;
8124 -> 8122;
8125 -> 8122;
8126 -> 8124;
8126 -> 8125;
8127 -> 8126;
8127 -> 8122;
8128 -> 8127;
8129 -> 8127;
8129 -> 8128;
8130 -> 8128;
8131 -> 8129;
8131 -> 8130;
8132 -> 8130;
8133 -> 8131;
8133 -> 8081;
8133 -> 8132;
8133 -> 8130;
8134 -> 8128;
8135 -> 8129;
8135 -> 8081;
8135 -> 8128;
8136 -> 8135;
8136 -> 8127;
8137 -> 8127;
8138 -> 8124;
8138 -> 8081;
8138 -> 8123;
8138 -> 8122;
8139 -> 8138;
8140 -> 8138;
8141 -> 8138;
8142 -> 8138;
8143 -> 8140;
8143 -> 8142;
8143 -> 8138;
8144 -> 8138;
8145 -> 8138;
8146 -> 8138;
8147 -> 8138;
8148 -> 8138;
8149 -> 8148;
8149 -> 8138;
8150 -> 8138;
8151 -> 8149;
8151 -> 8150;
8152 -> 8150;
8152 -> 8138;
8153 -> 8138;
8154 -> 8152;
8155 -> 8149;
8155 -> 8154;
8156 -> 8155;
8156 -> 8152;
8157 -> 8152;
8158 -> 8152;
8159 -> 8149;
8159 -> 8158;
8160 -> 8159;
8160 -> 8152;
8161 -> 8160;
8161 -> 8150;
8162 -> 8156;
8163 -> 8156;
8164 -> 8156;
8165 -> 8156;
8166 -> 8156;
8167 -> 8156;
8168 -> 8156;
8169 -> 8156;
8170 -> 8156;
8171 -> 8156;
8172 -> 8156;
8173 -> 8156;
8174 -> 8156;
8175 -> 8156;
8176 -> 8175;
8176 -> 8156;
8177 -> 8176;
8177 -> 8156;
8178 -> 8156;
8179 -> 8156;
8180 -> 8156;
8181 -> 8156;
8182 -> 8156;
8183 -> 8156;
8184 -> 8156;
8185 -> 8156;
8186 -> 8156;
8187 -> 8156;
8188 -> 8156;
8189 -> 0;
8189 -> 8156;
8190 -> 8187;
8190 -> 8156;
8191 -> 8156;
8192 -> 8173;
8192 -> 8191;
8192 -> 8156;
8193 -> 8156;
8194 -> 8168;
8194 -> 8193;
8194 -> 8156;
8195 -> 8156;
8196 -> 8156;
8197 -> 8156;
8197 -> 0;
8198 -> 8156;
8199 -> 8156;
8199 -> 8198;
8200 -> 8198;
8201 -> 8199;
8201 -> 8200;
8202 -> 8201;
8202 -> 8156;
8202 -> 8200;
8203 -> 8202;
8203 -> 8198;
8204 -> 8198;
8205 -> 8203;
8205 -> 8204;
8205 -> 8198;
8206 -> 8205;
8206 -> 8198;
8207 -> 8206;
8208 -> 8203;
8208 -> 8207;
8209 -> 8207;
8210 -> 8208;
8210 -> 8209;
8211 -> 8210;
8211 -> 8207;
8212 -> 8207;
8213 -> 8211;
8213 -> 8212;
8214 -> 8213;
8214 -> 8156;
8215 -> 8156;
8216 -> 8156;
8217 -> 8156;
8217 -> 8216;
8218 -> 8216;
8219 -> 8217;
8219 -> 8218;
8220 -> 8218;
8221 -> 8219;
8221 -> 8220;
8222 -> 0;
8222 -> 8220;
8223 -> 8222;
8223 -> 8218;
8224 -> 8219;
8224 -> 8216;
8225 -> 8224;
8225 -> 8156;
8226 -> 8156;
8227 -> 8225;
8227 -> 8226;
8228 -> 8227;
8228 -> 8156;
8228 -> 8226;
8229 -> 8156;
8230 -> 8156;
8231 -> 8156;
8232 -> 8156;
8232 -> 0;
8233 -> 8156;
8234 -> 8140;
8234 -> 8233;
8234 -> 8156;
8235 -> 8156;
8235 -> 8144;
8235 -> 8138;
8236 -> 8156;
8236 -> 8138;
8237 -> 8156;
8238 -> 8156;
8238 -> 8237;
8239 -> 0;
8239 -> 8237;
8240 -> 8239;
8240 -> 8156;
8241 -> 8156;
8242 -> 8156;
8243 -> 8242;
8243 -> 8156;
8244 -> 8156;
8245 -> 8156;
8245 -> 8244;
8246 -> 8244;
8247 -> 8245;
8247 -> 8246;
8248 -> 0;
8248 -> 8246;
8249 -> 8248;
8249 -> 8244;
8250 -> 8249;
8250 -> 8156;
8251 -> 8156;
8252 -> 8251;
8253 -> 8156;
8254 -> 8156;
8255 -> 8156;
8256 -> 8156;
8257 -> 8255;
8257 -> 8156;
8258 -> 8257;
8259 -> 8257;
8260 -> 8156;
8261 -> 8156;
8262 -> 8156;
8263 -> 0;
8263 -> 8156;
8264 -> 8156;
8265 -> 8264;
8265 -> 8156;
8266 -> 8265;
8266 -> 8156;
8267 -> 8156;
8268 -> 8266;
8268 -> 8267;
8269 -> 8156;
8269 -> 8267;
8270 -> 8268;
8270 -> 8267;
8271 -> 8267;
8272 -> 8270;
8272 -> 8271;
8272 -> 8267;
8273 -> 8269;
8273 -> 8156;
8273 -> 0;
8273 -> 8267;
8274 -> 8267;
8275 -> 8270;
8275 -> 8274;
8276 -> 8275;
8276 -> 8156;
8276 -> 8274;
8277 -> 8274;
8277 -> 8267;
8278 -> 8277;
8278 -> 8156;
8279 -> 8156;
8279 -> 8278;
8280 -> 8278;
8281 -> 8279;
8281 -> 8280;
8282 -> 8279;
8282 -> 8280;
8283 -> 8282;
8283 -> 8279;
8283 -> 8280;
8284 -> 8280;
8285 -> 8281;
8285 -> 8280;
8286 -> 8280;
8287 -> 8283;
8287 -> 8286;
8288 -> 8283;
8288 -> 8286;
8289 -> 8283;
8289 -> 8286;
8290 -> 8283;
8290 -> 8286;
8291 -> 8283;
8291 -> 8286;
8292 -> 8283;
8292 -> 8286;
8293 -> 8284;
8293 -> 8286;
8294 -> 8285;
8294 -> 8286;
8295 -> 8284;
8295 -> 8286;
8296 -> 8287;
8296 -> 8286;
8297 -> 8288;
8297 -> 8286;
8298 -> 8293;
8298 -> 8286;
8299 -> 8289;
8299 -> 8286;
8300 -> 8290;
8300 -> 8286;
8301 -> 8294;
8301 -> 8286;
8302 -> 8286;
8303 -> 8302;
8303 -> 8296;
8303 -> 8297;
8303 -> 8298;
8303 -> 8299;
8303 -> 8300;
8303 -> 8301;
8303 -> 8279;
8303 -> 8286;
8304 -> 8291;
8304 -> 8302;
8304 -> 8286;
8305 -> 8292;
8305 -> 8302;
8305 -> 8286;
8306 -> 8284;
8306 -> 8278;
8307 -> 8279;
8307 -> 8306;
8307 -> 8303;
8307 -> 8302;
8307 -> 8304;
8307 -> 8305;
8307 -> 8278;
8308 -> 8278;
8309 -> 8307;
8309 -> 8308;
8310 -> 8265;
8310 -> 8308;
8311 -> 8309;
8311 -> 8307;
8311 -> 8308;
8312 -> 8309;
8312 -> 8307;
8312 -> 8308;
8313 -> 8310;
8313 -> 8309;
8314 -> 8313;
8314 -> 8309;
8315 -> 8309;
8316 -> 8314;
8316 -> 8309;
8317 -> 8309;
8318 -> 8316;
8318 -> 8317;
8318 -> 8309;
8319 -> 8315;
8319 -> 8307;
8319 -> 0;
8319 -> 8309;
8320 -> 8316;
8320 -> 8309;
8321 -> 8320;
8321 -> 8307;
8321 -> 8309;
8322 -> 8309;
8322 -> 8307;
8323 -> 8309;
8323 -> 8307;
8324 -> 8320;
8324 -> 8307;
8324 -> 8309;
8325 -> 8313;
8325 -> 8309;
8326 -> 8325;
8326 -> 8307;
8326 -> 8309;
8327 -> 8309;
8328 -> 8313;
8328 -> 8327;
8329 -> 8328;
8329 -> 8313;
8329 -> 8327;
8330 -> 8327;
8330 -> 8309;
8331 -> 8309;
8332 -> 8330;
8332 -> 8331;
8333 -> 8309;
8333 -> 8331;
8334 -> 0;
8334 -> 8331;
8335 -> 8331;
8336 -> 8332;
8336 -> 8331;
8337 -> 8331;
8338 -> 8334;
8338 -> 8337;
8339 -> 8335;
8339 -> 8337;
8340 -> 8336;
8340 -> 8337;
8341 -> 8333;
8341 -> 8337;
8342 -> 8341;
8342 -> 8313;
8342 -> 8340;
8343 -> 8309;
8344 -> 8310;
8344 -> 8308;
8345 -> 8344;
8345 -> 8342;
8345 -> 8308;
8346 -> 8278;
8347 -> 8278;
8348 -> 8265;
8348 -> 8347;
8349 -> 8348;
8349 -> 8342;
8349 -> 8347;
8350 -> 8347;
8350 -> 8278;
8351 -> 8278;
8352 -> 8330;
8352 -> 8351;
8353 -> 8156;
8353 -> 8351;
8354 -> 0;
8354 -> 8351;
8355 -> 8351;
8356 -> 8352;
8356 -> 8351;
8357 -> 8351;
8358 -> 8354;
8358 -> 8357;
8359 -> 8355;
8359 -> 8357;
8360 -> 8356;
8360 -> 8357;
8361 -> 8353;
8361 -> 8357;
8362 -> 8278;
8363 -> 8156;
8364 -> 8363;
8364 -> 8342;
8364 -> 8156;
8365 -> 8250;
8365 -> 8342;
8365 -> 8156;
8366 -> 8156;
8366 -> 8138;
8367 -> 8156;
8367 -> 8138;
8367 -> 8366;
8368 -> 8366;
8369 -> 8366;
8370 -> 8156;
8370 -> 8138;
8370 -> 8369;
8371 -> 8369;
8372 -> 8370;
8372 -> 8371;
8373 -> 8371;
8373 -> 8342;
8374 -> 8371;
8374 -> 8342;
8375 -> 8374;
8376 -> 8374;
8377 -> 8374;
8378 -> 8374;
8379 -> 8378;
8379 -> 8374;
8380 -> 8379;
8380 -> 8374;
8381 -> 8379;
8381 -> 8374;
8382 -> 8379;
8383 -> 8379;
8384 -> 8379;
8385 -> 8379;
8386 -> 8379;
8387 -> 8379;
8388 -> 8379;
8389 -> 8379;
8390 -> 8389;
8390 -> 8379;
8391 -> 8390;
8391 -> 8379;
8392 -> 8379;
8393 -> 8379;
8394 -> 8379;
8395 -> 8379;
8396 -> 8379;
8397 -> 8379;
8398 -> 8379;
8399 -> 8379;
8400 -> 8379;
8401 -> 8379;
8402 -> 8379;
8403 -> 0;
8403 -> 8379;
8404 -> 8401;
8404 -> 8379;
8405 -> 8379;
8406 -> 8379;
8407 -> 8379;
8408 -> 8379;
8409 -> 8387;
8409 -> 8408;
8409 -> 8379;
8410 -> 8379;
8411 -> 8410;
8411 -> 8379;
8412 -> 8411;
8412 -> 8379;
8413 -> 8379;
8414 -> 8379;
8415 -> 8382;
8415 -> 8414;
8415 -> 8379;
8416 -> 8379;
8417 -> 8379;
8418 -> 8379;
8418 -> 0;
8419 -> 8379;
8420 -> 8379;
8420 -> 8419;
8421 -> 8419;
8422 -> 8420;
8422 -> 8421;
8423 -> 8422;
8423 -> 8379;
8423 -> 8421;
8424 -> 8423;
8424 -> 8419;
8425 -> 8419;
8426 -> 8424;
8426 -> 8425;
8426 -> 8419;
8427 -> 8426;
8427 -> 8419;
8428 -> 8427;
8429 -> 8424;
8429 -> 8428;
8430 -> 8428;
8431 -> 8429;
8431 -> 8430;
8432 -> 8431;
8432 -> 8428;
8433 -> 8428;
8434 -> 8432;
8434 -> 8433;
8435 -> 8434;
8435 -> 8379;
8436 -> 8379;
8437 -> 8379;
8438 -> 8379;
8438 -> 8437;
8439 -> 8437;
8440 -> 8438;
8440 -> 8439;
8441 -> 8439;
8442 -> 8440;
8442 -> 8441;
8443 -> 0;
8443 -> 8441;
8444 -> 8443;
8444 -> 8439;
8445 -> 8440;
8445 -> 8437;
8446 -> 8445;
8446 -> 8379;
8447 -> 8379;
8448 -> 8446;
8448 -> 8447;
8449 -> 8448;
8449 -> 8379;
8449 -> 8447;
8450 -> 8379;
8451 -> 8379;
8452 -> 8379;
8453 -> 8379;
8453 -> 0;
8454 -> 8371;
8455 -> 8371;
8455 -> 8379;
8455 -> 8372;
8456 -> 8455;
8456 -> 8369;
8457 -> 8456;
8458 -> 8456;
8458 -> 8457;
8459 -> 8458;
8459 -> 8455;
8459 -> 8457;
8460 -> 8459;
8460 -> 8456;
8461 -> 8456;
8462 -> 8456;
8462 -> 8461;
8463 -> 8462;
8463 -> 8455;
8463 -> 8461;
8464 -> 8463;
8464 -> 8456;
8465 -> 8460;
8465 -> 8464;
8465 -> 8456;
8466 -> 8465;
8467 -> 8241;
8467 -> 8466;
8467 -> 8465;
8468 -> 8456;
8468 -> 8465;
8469 -> 8156;
8470 -> 8468;
8470 -> 8469;
8470 -> 8156;
8471 -> 8138;
8472 -> 8468;
8472 -> 8471;
8472 -> 8138;
8473 -> 8138;
8474 -> 8468;
8474 -> 8473;
8475 -> 8473;
8475 -> 8138;
8476 -> 8138;
8477 -> 8468;
8477 -> 8476;
8478 -> 0;
8478 -> 8476;
8479 -> 8477;
8479 -> 8138;
8480 -> 8475;
8480 -> 8479;
8480 -> 8138;
8481 -> 8468;
8481 -> 0;
8481 -> 8138;
8482 -> 8138;
8483 -> 8468;
8483 -> 8482;
8484 -> 8482;
8485 -> 8483;
8485 -> 8484;
8486 -> 8485;
8486 -> 8455;
8486 -> 8484;
8487 -> 8486;
8487 -> 8482;
8488 -> 8482;
8489 -> 8487;
8489 -> 8488;
8489 -> 8482;
8490 -> 8489;
8490 -> 8482;
8491 -> 8490;
8492 -> 8487;
8492 -> 8491;
8493 -> 8491;
8494 -> 8492;
8494 -> 8493;
8495 -> 8494;
8495 -> 8491;
8496 -> 8491;
8497 -> 8495;
8497 -> 8496;
8498 -> 8497;
8498 -> 8138;
8499 -> 8138;
8500 -> 8138;
8501 -> 8468;
8501 -> 8500;
8502 -> 8500;
8503 -> 8501;
8503 -> 8502;
8504 -> 8502;
8505 -> 8503;
8505 -> 8504;
8506 -> 0;
8506 -> 8504;
8507 -> 8506;
8507 -> 8502;
8508 -> 8503;
8508 -> 8500;
8509 -> 8508;
8509 -> 8138;
8510 -> 8138;
8511 -> 8509;
8511 -> 8510;
8512 -> 8511;
8512 -> 8455;
8512 -> 8510;
8513 -> 8138;
8514 -> 8455;
8514 -> 8138;
8515 -> 8138;
8516 -> 8468;
8517 -> 8138;
8517 -> 8468;
8518 -> 8468;
8518 -> 8117;
8519 -> 8117;
8520 -> 8518;
8520 -> 8519;
8521 -> 8519;
8522 -> 8520;
8522 -> 8521;
8522 -> 8519;
8523 -> 8519;
8524 -> 8520;
8524 -> 8523;
8525 -> 8523;
8525 -> 8519;
8526 -> 8525;
8526 -> 8117;
8527 -> 8468;
8527 -> 8526;
8528 -> 8118;
8528 -> 8526;
8529 -> 8528;
8529 -> 7707;
8529 -> 7708;
8529 -> 7709;
8529 -> 8468;
8529 -> 8526;
8530 -> 8526;
8531 -> 8526;
8532 -> 8527;
8532 -> 8531;
8533 -> 8529;
8533 -> 8531;
8534 -> 8530;
8534 -> 8531;
8535 -> 8530;
8535 -> 8531;
8536 -> 8530;
8536 -> 8531;
8537 -> 8531;
8538 -> 8532;
8538 -> 8537;
8539 -> 8538;
8539 -> 8468;
8539 -> 8537;
8540 -> 8531;
8541 -> 8532;
8541 -> 8540;
8542 -> 8541;
8542 -> 8468;
8542 -> 8540;
8543 -> 8531;
8544 -> 8532;
8544 -> 8543;
8545 -> 8531;
8546 -> 8544;
8546 -> 8545;
8547 -> 8545;
8548 -> 8546;
8548 -> 8547;
8549 -> 8548;
8549 -> 8468;
8549 -> 8547;
8550 -> 8549;
8551 -> 8550;
8552 -> 8550;
8552 -> 8551;
8553 -> 0;
8553 -> 8551;
8554 -> 8553;
8554 -> 8550;
8555 -> 8550;
8555 -> 8549;
8556 -> 8548;
8556 -> 8468;
8556 -> 8549;
8557 -> 8548;
8557 -> 8468;
8557 -> 8549;
8558 -> 8549;
8559 -> 8558;
8559 -> 8557;
8559 -> 8549;
8560 -> 8555;
8560 -> 8559;
8561 -> 8548;
8561 -> 8559;
8562 -> 8558;
8562 -> 8559;
8563 -> 8556;
8563 -> 8558;
8563 -> 8559;
8564 -> 8559;
8565 -> 8559;
8566 -> 8560;
8566 -> 8565;
8567 -> 8561;
8567 -> 8565;
8568 -> 8562;
8568 -> 8565;
8569 -> 8563;
8569 -> 8565;
8570 -> 8564;
8570 -> 8565;
8571 -> 8566;
8571 -> 8565;
8572 -> 8567;
8572 -> 8565;
8573 -> 8568;
8573 -> 8565;
8574 -> 8569;
8574 -> 8565;
8575 -> 8565;
8576 -> 8571;
8576 -> 8575;
8577 -> 8572;
8577 -> 8575;
8578 -> 8573;
8578 -> 8575;
8579 -> 8574;
8579 -> 8575;
8580 -> 8570;
8580 -> 8575;
8581 -> 8575;
8582 -> 8580;
8582 -> 8581;
8583 -> 8581;
8584 -> 8582;
8584 -> 8581;
8585 -> 8580;
8585 -> 8575;
8586 -> 8580;
8586 -> 8575;
8587 -> 8580;
8587 -> 8575;
8588 -> 0;
8588 -> 8580;
8588 -> 8575;
8589 -> 8580;
8589 -> 8575;
8590 -> 8580;
8590 -> 8575;
8592 -> 8591;
8593 -> 8592;
8593 -> 8591;
8594 -> 8592;
8594 -> 8591;
8595 -> 8591;
8596 -> 8595;
8596 -> 8592;
8596 -> 8591;
8597 -> 8591;
8598 -> 8597;
8598 -> 8592;
8598 -> 8591;
8599 -> 8591;
8600 -> 8599;
8600 -> 8580;
8600 -> 8575;
8601 -> 8575;
8602 -> 8576;
8602 -> 8601;
8602 -> 8575;
8603 -> 8575;
8604 -> 8577;
8604 -> 8603;
8604 -> 8575;
8605 -> 8575;
8606 -> 8578;
8606 -> 8605;
8606 -> 8575;
8607 -> 8579;
8607 -> 8563;
8607 -> 8575;
8608 -> 8577;
8608 -> 8580;
8608 -> 8575;
8609 -> 8575;
8610 -> 8575;
8611 -> 8576;
8611 -> 8610;
8612 -> 8611;
8612 -> 8563;
8612 -> 8610;
8613 -> 8612;
8613 -> 8575;
8614 -> 8579;
8614 -> 8575;
8615 -> 8580;
8615 -> 8586;
8615 -> 8575;
8616 -> 8609;
8616 -> 8575;
8617 -> 8613;
8617 -> 8614;
8617 -> 8615;
8617 -> 8616;
8617 -> 8563;
8617 -> 8575;
8618 -> 8617;
8618 -> 0;
8618 -> 8575;
8619 -> 8575;
8620 -> 8618;
8620 -> 8575;
8621 -> 8620;
8621 -> 8580;
8621 -> 8575;
8622 -> 8578;
8622 -> 8580;
8622 -> 8575;
8623 -> 8579;
8623 -> 8580;
8623 -> 8575;
8624 -> 8564;
8624 -> 8558;
8624 -> 8557;
8624 -> 8559;
8625 -> 8548;
8625 -> 8617;
8625 -> 8549;
8626 -> 8557;
8626 -> 8549;
8627 -> 8626;
8627 -> 8557;
8627 -> 8624;
8627 -> 8582;
8627 -> 8584;
8627 -> 8608;
8627 -> 8617;
8627 -> 8622;
8627 -> 8588;
8627 -> 8621;
8627 -> 8590;
8627 -> 8600;
8627 -> 8623;
8627 -> 8596;
8627 -> 8598;
8627 -> 8563;
8627 -> 8549;
8628 -> 8545;
8629 -> 8546;
8629 -> 8627;
8629 -> 8545;
8631 -> 8630;
8632 -> 0;
8633 -> 8632;
8633 -> 0;
8634 -> 8633;
8636 -> 8635;
8637 -> 8634;
8637 -> 8635;
8638 -> 8637;
8638 -> 8636;
8639 -> 8636;
8640 -> 8639;
8641 -> 8639;
8641 -> 8636;
8642 -> 8638;
8642 -> 8639;
8642 -> 8636;
8643 -> 8634;
8643 -> 8635;
8644 -> 8635;
8645 -> 8533;
8645 -> 8531;
8646 -> 8531;
8647 -> 8542;
8647 -> 8646;
8648 -> 8629;
8648 -> 8646;
8649 -> 8645;
8649 -> 8646;
8650 -> 8646;
8651 -> 8647;
8651 -> 8646;
8652 -> 8646;
8653 -> 8651;
8653 -> 8652;
8654 -> 8653;
8654 -> 8652;
8655 -> 8652;
8656 -> 8654;
8656 -> 8655;
8656 -> 8652;
8657 -> 8656;
8657 -> 8652;
8658 -> 8657;
8658 -> 8643;
8659 -> 8658;
8659 -> 8650;
8660 -> 8650;
8661 -> 8660;
8662 -> 8660;
8662 -> 8650;
8663 -> 8659;
8663 -> 8660;
8663 -> 8650;
8664 -> 8646;
8665 -> 8664;
8665 -> 8648;
8665 -> 8627;
8665 -> 8646;
8666 -> 8648;
8666 -> 8664;
8666 -> 8627;
8666 -> 8665;
8667 -> 8649;
8667 -> 8664;
8667 -> 8468;
8667 -> 7707;
8667 -> 7708;
8667 -> 7709;
8667 -> 8529;
8667 -> 8666;
8667 -> 8665;
8668 -> 8666;
8668 -> 8665;
8669 -> 8665;
8670 -> 8668;
8670 -> 8669;
8671 -> 8667;
8671 -> 8669;
8673 -> 8672;
8675 -> 8674;
8677 -> 8676;
8678 -> 8671;
8678 -> 8667;
8678 -> 8669;
8679 -> 8669;
8680 -> 8678;
8680 -> 8679;
8681 -> 8680;
8681 -> 7643;
8681 -> 8679;
8682 -> 8671;
8682 -> 8667;
8682 -> 8670;
8682 -> 8669;
8683 -> 8681;
8683 -> 8682;
8683 -> 8669;
8684 -> 8666;
8684 -> 8683;
8685 -> 8667;
8685 -> 8683;
8686 -> 8650;
8686 -> 8663;
8686 -> 8684;
8686 -> 8685;
8686 -> 8658;
8686 -> 8667;
8686 -> 8683;
8687 -> 8531;
8688 -> 8532;
8688 -> 8687;
8689 -> 0;
8690 -> 8532;
8690 -> 8531;
8691 -> 8534;
8691 -> 8531;
8692 -> 8535;
8692 -> 8531;
8693 -> 8531;
8694 -> 8539;
8694 -> 8693;
8695 -> 8646;
8695 -> 8693;
8696 -> 8688;
8696 -> 8693;
8697 -> 8690;
8697 -> 8693;
8698 -> 8691;
8698 -> 8693;
8699 -> 8692;
8699 -> 8693;
8700 -> 8536;
8700 -> 8693;
8701 -> 8696;
8701 -> 8693;
8702 -> 8699;
8702 -> 8693;
8703 -> 8693;
8704 -> 8701;
8704 -> 8703;
8705 -> 8702;
8705 -> 8703;
8706 -> 8700;
8706 -> 8703;
8707 -> 8705;
8707 -> 8703;
8708 -> 8703;
8709 -> 8707;
8709 -> 8708;
8710 -> 8706;
8710 -> 8708;
8711 -> 8706;
8711 -> 8703;
8712 -> 8703;
8713 -> 8704;
8713 -> 8712;
8713 -> 8703;
8714 -> 8704;
8714 -> 8706;
8714 -> 8703;
8715 -> 8700;
8715 -> 8693;
8716 -> 8700;
8716 -> 8693;
8717 -> 8700;
8717 -> 8693;
8718 -> 8700;
8718 -> 8693;
8719 -> 8700;
8719 -> 8693;
8720 -> 8700;
8720 -> 8693;
8721 -> 8693;
8722 -> 8696;
8722 -> 8721;
8723 -> 8721;
8724 -> 8722;
8724 -> 8723;
8725 -> 8723;
8726 -> 8724;
8726 -> 8725;
8727 -> 8725;
8728 -> 8726;
8728 -> 8727;
8729 -> 8727;
8730 -> 8728;
8730 -> 8729;
8731 -> 8730;
8731 -> 8727;
8732 -> 8731;
8732 -> 8725;
8733 -> 8732;
8733 -> 8723;
8734 -> 8733;
8734 -> 8721;
8735 -> 8734;
8735 -> 8693;
8736 -> 8696;
8736 -> 8693;
8737 -> 8693;
8738 -> 8736;
8738 -> 8737;
8739 -> 8737;
8740 -> 8738;
8740 -> 8739;
8740 -> 8737;
8741 -> 8738;
8741 -> 8737;
8742 -> 8737;
8742 -> 8693;
8743 -> 8694;
8743 -> 8700;
8743 -> 8693;
8744 -> 8695;
8744 -> 8700;
8744 -> 8693;
8745 -> 8698;
8745 -> 8700;
8745 -> 8693;
8746 -> 8693;
8747 -> 8697;
8747 -> 8746;
8747 -> 8693;
8748 -> 8747;
8749 -> 8697;
8749 -> 8748;
8750 -> 8749;
8750 -> 8748;
8751 -> 8750;
8751 -> 8747;
8752 -> 8697;
8752 -> 8747;
8753 -> 8747;
8754 -> 8697;
8754 -> 8753;
8755 -> 8753;
8756 -> 8754;
8756 -> 8755;
8757 -> 8756;
8757 -> 8686;
8757 -> 8755;
8758 -> 8753;
8759 -> 8754;
8759 -> 8686;
8759 -> 8753;
8760 -> 8759;
8760 -> 8747;
8761 -> 8760;
8761 -> 8700;
8761 -> 8747;
8762 -> 8695;
8762 -> 8700;
8762 -> 8747;
8763 -> 8536;
8763 -> 8531;
8764 -> 8533;
8764 -> 8536;
8764 -> 8531;
8765 -> 8532;
8765 -> 8536;
8765 -> 8531;
8766 -> 8531;
8767 -> 8532;
8767 -> 8766;
8768 -> 8767;
8768 -> 8686;
8768 -> 8766;
8769 -> 8768;
8769 -> 8531;
8770 -> 8531;
8771 -> 8532;
8771 -> 8770;
8772 -> 8771;
8772 -> 8686;
8772 -> 8770;
8773 -> 8772;
8773 -> 8531;
8774 -> 8531;
8775 -> 8120;
8775 -> 8530;
8775 -> 8706;
8775 -> 8709;
8775 -> 8714;
8775 -> 8745;
8775 -> 8744;
8775 -> 8743;
8775 -> 8762;
8775 -> 8719;
8775 -> 8720;
8775 -> 8761;
8775 -> 8765;
8775 -> 8764;
8775 -> 8686;
8775 -> 8663;
8775 -> 8468;
8775 -> 7707;
8775 -> 7708;
8775 -> 7709;
8775 -> 8529;
8775 -> 8526;
8776 -> 0;
8776 -> 8117;
8777 -> 8117;
8778 -> 8776;
8778 -> 8777;
8779 -> 8119;
8779 -> 8777;
8780 -> 8779;
8780 -> 8775;
8780 -> 8777;
8781 -> 8777;
8782 -> 8780;
8782 -> 8781;
8783 -> 8782;
8783 -> 8777;
8784 -> 8783;
8785 -> 8783;
8785 -> 8784;
8786 -> 8784;
8787 -> 8785;
8787 -> 8786;
8788 -> 8786;
8789 -> 8787;
8789 -> 8775;
8789 -> 8788;
8789 -> 8786;
8790 -> 8784;
8791 -> 8785;
8791 -> 8775;
8791 -> 8784;
8792 -> 8791;
8792 -> 8783;
8793 -> 8783;
8794 -> 8780;
8794 -> 8775;
8794 -> 8778;
8794 -> 8777;
8795 -> 8794;
8796 -> 8794;
8797 -> 8794;
8798 -> 8794;
8799 -> 8796;
8799 -> 8798;
8799 -> 8794;
8800 -> 8794;
8801 -> 8794;
8802 -> 8794;
8803 -> 8794;
8803 -> 8802;
8804 -> 0;
8804 -> 8802;
8805 -> 8804;
8805 -> 8794;
8806 -> 8794;
8807 -> 8794;
8808 -> 8807;
8808 -> 8794;
8809 -> 8794;
8810 -> 8794;
8810 -> 8809;
8811 -> 8809;
8812 -> 8810;
8812 -> 8811;
8813 -> 0;
8813 -> 8811;
8814 -> 8813;
8814 -> 8809;
8815 -> 8814;
8815 -> 8794;
8816 -> 8794;
8817 -> 8794;
8818 -> 8816;
8818 -> 8794;
8819 -> 8818;
8820 -> 8818;
8821 -> 8794;
8822 -> 8794;
8823 -> 8794;
8824 -> 0;
8824 -> 8794;
8825 -> 8794;
8826 -> 8794;
8827 -> 8825;
8827 -> 8794;
8828 -> 8794;
8829 -> 8827;
8829 -> 8828;
8829 -> 8794;
8830 -> 8826;
8830 -> 8794;
8830 -> 0;
8831 -> 8827;
8831 -> 8794;
8832 -> 8831;
8832 -> 8794;
8833 -> 8831;
8833 -> 8794;
8834 -> 8794;
8835 -> 8834;
8835 -> 8794;
8836 -> 8794;
8837 -> 8794;
8838 -> 8794;
8839 -> 8806;
8839 -> 8838;
8839 -> 8794;
8840 -> 8815;
8840 -> 8839;
8841 -> 8840;
8842 -> 8794;
8842 -> 8841;
8843 -> 8841;
8844 -> 8842;
8844 -> 8794;
8844 -> 8843;
8845 -> 8844;
8845 -> 8841;
8846 -> 8845;
8846 -> 8840;
8847 -> 8794;
8847 -> 8840;
8848 -> 8840;
8849 -> 8840;
8850 -> 8846;
8850 -> 8849;
8851 -> 8847;
8851 -> 8849;
8852 -> 8848;
8852 -> 8849;
8853 -> 8848;
8853 -> 8849;
8854 -> 8850;
8854 -> 8849;
8855 -> 8851;
8855 -> 8849;
8856 -> 8849;
8857 -> 8852;
8857 -> 8849;
8858 -> 8849;
8859 -> 8854;
8859 -> 8858;
8860 -> 8855;
8860 -> 8858;
8861 -> 8856;
8861 -> 8858;
8862 -> 8857;
8862 -> 8858;
8863 -> 8853;
8863 -> 8858;
8864 -> 8859;
8864 -> 8858;
8865 -> 8860;
8865 -> 8858;
8866 -> 8858;
8867 -> 8860;
8867 -> 8794;
8867 -> 8866;
8867 -> 8858;
8868 -> 8867;
8868 -> 8858;
8869 -> 8862;
8869 -> 8858;
8870 -> 8861;
8870 -> 8858;
8871 -> 8858;
8872 -> 8864;
8872 -> 8871;
8873 -> 8865;
8873 -> 8871;
8874 -> 8868;
8874 -> 8871;
8875 -> 8869;
8875 -> 8871;
8876 -> 8870;
8876 -> 8871;
8877 -> 8863;
8877 -> 8871;
8878 -> 8872;
8878 -> 8871;
8879 -> 8873;
8879 -> 8794;
8879 -> 8871;
8880 -> 8874;
8880 -> 8871;
8881 -> 8873;
8881 -> 8794;
8881 -> 8880;
8882 -> 8874;
8882 -> 8871;
8883 -> 8873;
8883 -> 8794;
8883 -> 8882;
8884 -> 8874;
8884 -> 8871;
8885 -> 8871;
8886 -> 8875;
8886 -> 8871;
8887 -> 8871;
8888 -> 8876;
8888 -> 8871;
8889 -> 8871;
8890 -> 8871;
8891 -> 8878;
8891 -> 8890;
8892 -> 8879;
8892 -> 8890;
8893 -> 8881;
8893 -> 8890;
8894 -> 8883;
8894 -> 8890;
8895 -> 8884;
8895 -> 8890;
8896 -> 8885;
8896 -> 8890;
8897 -> 8886;
8897 -> 8890;
8898 -> 8887;
8898 -> 8890;
8899 -> 8888;
8899 -> 8890;
8900 -> 8889;
8900 -> 8890;
8901 -> 8877;
8901 -> 8890;
8902 -> 8893;
8902 -> 8890;
8903 -> 8894;
8903 -> 8890;
8904 -> 8895;
8904 -> 8890;
8905 -> 8900;
8905 -> 8890;
8906 -> 8890;
8907 -> 8902;
8907 -> 8906;
8908 -> 8903;
8908 -> 8906;
8909 -> 8904;
8909 -> 8906;
8910 -> 8905;
8910 -> 8906;
8911 -> 8901;
8911 -> 8906;
8912 -> 8910;
8912 -> 8906;
8913 -> 8906;
8914 -> 8912;
8914 -> 8913;
8915 -> 8911;
8915 -> 8913;
8916 -> 8914;
8916 -> 8911;
8916 -> 8913;
8917 -> 8911;
8917 -> 8906;
8918 -> 8911;
8918 -> 8906;
8919 -> 8911;
8919 -> 8906;
8920 -> 8906;
8921 -> 8907;
8921 -> 8920;
8921 -> 8906;
8922 -> 8907;
8922 -> 8911;
8922 -> 8906;
8923 -> 8908;
8923 -> 8911;
8923 -> 8906;
8924 -> 8906;
8925 -> 8908;
8925 -> 8924;
8925 -> 8906;
8926 -> 8909;
8926 -> 8925;
8926 -> 8906;
8927 -> 8926;
8927 -> 8911;
8927 -> 8906;
8928 -> 8901;
8928 -> 8890;
8929 -> 8901;
8929 -> 8890;
8930 -> 8901;
8930 -> 8890;
8931 -> 8901;
8931 -> 8890;
8932 -> 8901;
8932 -> 8890;
8933 -> 8901;
8933 -> 8890;
8934 -> 8890;
8935 -> 8891;
8935 -> 8934;
8935 -> 8890;
8936 -> 8890;
8937 -> 8892;
8937 -> 8936;
8937 -> 8890;
8938 -> 8890;
8939 -> 8899;
8939 -> 8938;
8939 -> 8890;
8940 -> 8892;
8940 -> 8901;
8940 -> 8890;
8941 -> 8891;
8941 -> 8901;
8941 -> 8890;
8942 -> 8896;
8942 -> 8901;
8942 -> 8890;
8943 -> 8897;
8943 -> 8901;
8943 -> 8890;
8944 -> 8898;
8944 -> 8901;
8944 -> 8890;
8945 -> 8899;
8945 -> 8901;
8945 -> 8890;
8946 -> 8794;
8947 -> 8848;
8947 -> 8946;
8947 -> 8794;
8948 -> 8794;
8949 -> 8848;
8949 -> 8948;
8950 -> 0;
8950 -> 8948;
8951 -> 8950;
8951 -> 8794;
8952 -> 8848;
8952 -> 8794;
8953 -> 8794;
8954 -> 8952;
8954 -> 8953;
8955 -> 8953;
8956 -> 8954;
8956 -> 8945;
8956 -> 8955;
8956 -> 8953;
8957 -> 0;
8957 -> 8956;
8958 -> 8956;
8959 -> 8954;
8959 -> 8941;
8959 -> 8958;
8960 -> 8959;
8960 -> 8956;
8961 -> 8956;
8962 -> 8954;
8962 -> 8961;
8963 -> 8962;
8963 -> 8923;
8963 -> 8961;
8964 -> 8963;
8964 -> 8956;
8965 -> 8956;
8966 -> 8956;
8967 -> 8954;
8967 -> 8966;
8968 -> 8967;
8968 -> 8927;
8968 -> 8966;
8969 -> 8968;
8969 -> 8956;
8970 -> 8964;
8970 -> 8969;
8970 -> 8956;
8971 -> 8960;
8971 -> 8965;
8971 -> 8956;
8972 -> 8970;
8972 -> 8971;
8972 -> 8956;
8973 -> 8960;
8973 -> 8956;
8974 -> 8956;
8975 -> 8960;
8975 -> 8974;
8976 -> 8975;
8976 -> 8956;
8977 -> 8972;
8977 -> 8976;
8977 -> 8956;
8978 -> 8956;
8979 -> 8954;
8979 -> 8941;
8979 -> 8978;
8980 -> 8979;
8980 -> 8794;
8980 -> 8978;
8981 -> 8980;
8981 -> 8956;
8982 -> 8977;
8982 -> 8981;
8982 -> 8956;
8983 -> 8954;
8983 -> 8940;
8983 -> 8982;
8984 -> 8982;
8985 -> 8954;
8985 -> 8984;
8986 -> 8984;
8987 -> 8985;
8987 -> 8986;
8988 -> 8987;
8988 -> 8984;
8989 -> 8988;
8990 -> 8985;
8990 -> 8989;
8991 -> 8990;
8991 -> 8922;
8991 -> 8989;
8992 -> 8988;
8993 -> 8991;
8993 -> 8992;
8993 -> 8988;
8994 -> 8993;
8994 -> 8982;
8995 -> 8983;
8995 -> 8994;
8995 -> 8982;
8996 -> 8995;
8996 -> 8982;
8997 -> 8954;
8997 -> 8945;
8997 -> 8956;
8998 -> 8996;
8998 -> 8956;
8999 -> 8956;
9000 -> 8954;
9000 -> 8998;
9000 -> 8953;
9001 -> 9000;
9001 -> 8794;
9002 -> 9001;
9002 -> 0;
9002 -> 8794;
9003 -> 9002;
9003 -> 8794;
9004 -> 8952;
9004 -> 8998;
9004 -> 9003;
9005 -> 9004;
9005 -> 0;
9005 -> 8794;
9006 -> 8794;
9007 -> 8848;
9007 -> 9006;
9008 -> 9006;
9009 -> 9007;
9009 -> 8941;
9009 -> 9008;
9010 -> 9009;
9010 -> 9006;
9011 -> 9010;
9011 -> 8794;
9012 -> 8794;
9013 -> 8794;
9014 -> 8848;
9014 -> 9013;
9015 -> 9014;
9015 -> 8941;
9015 -> 9013;
9016 -> 9015;
9016 -> 8794;
9017 -> 8794;
9018 -> 9016;
9018 -> 9017;
9019 -> 9018;
9019 -> 8794;
9019 -> 9017;
9020 -> 8794;
9021 -> 8794;
9022 -> 9004;
9022 -> 8848;
9022 -> 8794;
9022 -> 8911;
9022 -> 8916;
9022 -> 8922;
9022 -> 8923;
9022 -> 8927;
9022 -> 8940;
9022 -> 8941;
9022 -> 8942;
9022 -> 8943;
9022 -> 8944;
9023 -> 9022;
9024 -> 8794;
9024 -> 9022;
9024 -> 0;
9025 -> 9022;
9025 -> 8117;
9026 -> 8117;
9027 -> 9025;
9027 -> 9026;
9028 -> 9026;
9029 -> 9027;
9029 -> 9028;
9029 -> 9026;
9030 -> 9026;
9031 -> 9027;
9031 -> 9030;
9032 -> 0;
9032 -> 9030;
9033 -> 9032;
9033 -> 9026;
9034 -> 9033;
9034 -> 8117;
9035 -> 8120;
9035 -> 9022;
9035 -> 8117;
9036 -> 8093;
9037 -> 8096;
9037 -> 9036;
9038 -> 8115;
9038 -> 9036;
9039 -> 9035;
9039 -> 9036;
9040 -> 9037;
9040 -> 9036;
9041 -> 9038;
9041 -> 9036;
9042 -> 9039;
9042 -> 9036;
9043 -> 9036;
9044 -> 9036;
9045 -> 9040;
9045 -> 9044;
9046 -> 9041;
9046 -> 9044;
9047 -> 9042;
9047 -> 9044;
9048 -> 9043;
9048 -> 9044;
9049 -> 9045;
9049 -> 9044;
9050 -> 9046;
9050 -> 9044;
9051 -> 9044;
9052 -> 9049;
9052 -> 9051;
9053 -> 9050;
9053 -> 9051;
9054 -> 9048;
9054 -> 9051;
9055 -> 9051;
9056 -> 9054;
9056 -> 9051;
9057 -> 9054;
9057 -> 9051;
9058 -> 9051;
9059 -> 9052;
9059 -> 9058;
9060 -> 9059;
9060 -> 7707;
9060 -> 9058;
9061 -> 9060;
9061 -> 9058;
9062 -> 9061;
9062 -> 9051;
9063 -> 9051;
9064 -> 9053;
9064 -> 9063;
9064 -> 9051;
9065 -> 9052;
9065 -> 9054;
9065 -> 9051;
9066 -> 9053;
9066 -> 9054;
9066 -> 9051;
9067 -> 9044;
9068 -> 9047;
9068 -> 9035;
9068 -> 9067;
9068 -> 9044;
9069 -> 9047;
9069 -> 9048;
9069 -> 9044;
9070 -> 9043;
9070 -> 8093;
9071 -> 9070;
9071 -> 8090;
9072 -> 8072;
9072 -> 9022;
9072 -> 8071;
9073 -> 8071;
9074 -> 9072;
9074 -> 9073;
9075 -> 9071;
9075 -> 8071;
9076 -> 8071;
9077 -> 8071;
9078 -> 9074;
9078 -> 9077;
9079 -> 9075;
9079 -> 9077;
9080 -> 9076;
9080 -> 9077;
9081 -> 9079;
9081 -> 9077;
9082 -> 9079;
9082 -> 9077;
9083 -> 9078;
9083 -> 0;
9083 -> 9077;
9084 -> 9078;
9084 -> 9077;
9085 -> 9079;
9085 -> 9084;
9086 -> 9084;
9087 -> 9085;
9087 -> 9086;
9088 -> 9086;
9089 -> 9087;
9089 -> 9088;
9090 -> 9088;
9091 -> 9089;
9091 -> 9090;
9092 -> 9091;
9092 -> 9090;
9093 -> 9092;
9093 -> 9088;
9094 -> 9093;
9094 -> 9086;
9095 -> 9086;
9096 -> 9094;
9096 -> 9095;
9097 -> 0;
9097 -> 9095;
9098 -> 9097;
9098 -> 9086;
9099 -> 9098;
9099 -> 9084;
9100 -> 9085;
9100 -> 9099;
9100 -> 9084;
9101 -> 9079;
9101 -> 9077;
9102 -> 9101;
9102 -> 9077;
9103 -> 9079;
9103 -> 9102;
9104 -> 9102;
9105 -> 9103;
9105 -> 9104;
9106 -> 9104;
9107 -> 9105;
9107 -> 9106;
9108 -> 9106;
9109 -> 9107;
9109 -> 9108;
9110 -> 9109;
9110 -> 9108;
9111 -> 9110;
9111 -> 9106;
9112 -> 9111;
9112 -> 9104;
9113 -> 9104;
9114 -> 9112;
9114 -> 9113;
9115 -> 0;
9115 -> 9113;
9116 -> 9115;
9116 -> 9104;
9117 -> 9116;
9117 -> 9102;
9118 -> 9078;
9118 -> 0;
9118 -> 9077;
9119 -> 9077;
9120 -> 9117;
9120 -> 9119;
9120 -> 9077;
9121 -> 9077;
9122 -> 9077;
9122 -> 8071;
9123 -> 5430;
9123 -> 9074;
9123 -> 8071;
9124 -> 9074;
9124 -> 8077;
9125 -> 9122;
9125 -> 8071;
9126 -> 9125;
9126 -> 8085;
9127 -> 9126;
9127 -> 9074;
9128 -> 9074;
9129 -> 9128;
9130 -> 9129;
9130 -> 9128;
9131 -> 9130;
9132 -> 9130;
9132 -> 9131;
9133 -> 9131;
9134 -> 9132;
9134 -> 9133;
9135 -> 9133;
9136 -> 9134;
9136 -> 9074;
9136 -> 9135;
9136 -> 9133;
9137 -> 9131;
9138 -> 9132;
9138 -> 9074;
9138 -> 9131;
9139 -> 9138;
9139 -> 9130;
9140 -> 9130;
9141 -> 9128;
9141 -> 9074;
9142 -> 9074;
9143 -> 9141;
9143 -> 9142;
9143 -> 9074;
9144 -> 9141;
9144 -> 9074;
9145 -> 9127;
9145 -> 9128;
9146 -> 9145;
9146 -> 9079;
9146 -> 9078;
9146 -> 9077;
9146 -> 9054;
9146 -> 9056;
9146 -> 9066;
9146 -> 9065;
9146 -> 9069;
9146 -> 7707;
9146 -> 7708;
9146 -> 7709;
9146 -> 9074;
9146 -> 9035;
9146 -> 9128;
9147 -> 9128;
9148 -> 9128;
9149 -> 9128;
9150 -> 9128;
9151 -> 9128;
9152 -> 9128;
9153 -> 9128;
9154 -> 9128;
9155 -> 9128;
9156 -> 9128;
9157 -> 9128;
9158 -> 9128;
9158 -> 9157;
9159 -> 9157;
9160 -> 9158;
9160 -> 9159;
9161 -> 9159;
9162 -> 9160;
9162 -> 9161;
9163 -> 9161;
9164 -> 9162;
9164 -> 9163;
9165 -> 9163;
9166 -> 9164;
9166 -> 9165;
9167 -> 9166;
9167 -> 9163;
9168 -> 9167;
9168 -> 9161;
9169 -> 9168;
9169 -> 9159;
9170 -> 9169;
9170 -> 9157;
9171 -> 9170;
9171 -> 9128;
9172 -> 9128;
9173 -> 9128;
9174 -> 9172;
9174 -> 9173;
9175 -> 9173;
9176 -> 9174;
9176 -> 9175;
9176 -> 9173;
9177 -> 9174;
9177 -> 9173;
9178 -> 9173;
9178 -> 9128;
9179 -> 9128;
9180 -> 9128;
9180 -> 9179;
9181 -> 9180;
9181 -> 9179;
9182 -> 9181;
9182 -> 9128;
9183 -> 9128;
9184 -> 9128;
9185 -> 9128;
9186 -> 9185;
9186 -> 9146;
9187 -> 9186;
9187 -> 9128;
9188 -> 9128;
9189 -> 9188;
9189 -> 9146;
9190 -> 9189;
9190 -> 9128;
9191 -> 9128;
9192 -> 9146;
9192 -> 9129;
9193 -> 9192;
9193 -> 9128;
9194 -> 9193;
9195 -> 9193;
9195 -> 9194;
9196 -> 9194;
9197 -> 9195;
9197 -> 9196;
9198 -> 9196;
9199 -> 9197;
9199 -> 9146;
9199 -> 9198;
9199 -> 9196;
9200 -> 9194;
9201 -> 9195;
9201 -> 9146;
9201 -> 9194;
9202 -> 9201;
9202 -> 9193;
9203 -> 9193;
9204 -> 9146;
9204 -> 9074;
9205 -> 9074;
9206 -> 9204;
9206 -> 9205;
9207 -> 9205;
9208 -> 9206;
9208 -> 9207;
9208 -> 9205;
9209 -> 9206;
9209 -> 9205;
9210 -> 0;
9210 -> 9205;
9211 -> 9210;
9211 -> 9074;
9212 -> 9074;
9213 -> 9127;
9213 -> 9212;
9214 -> 9128;
9214 -> 9212;
9215 -> 9213;
9215 -> 9212;
9216 -> 9214;
9216 -> 9212;
9217 -> 9212;
9218 -> 9212;
9219 -> 9215;
9219 -> 9218;
9220 -> 9216;
9220 -> 9218;
9221 -> 9217;
9221 -> 9218;
9222 -> 9219;
9222 -> 9218;
9223 -> 9220;
9223 -> 9218;
9224 -> 9218;
9225 -> 9222;
9225 -> 9224;
9226 -> 9223;
9226 -> 9224;
9227 -> 9221;
9227 -> 9224;
9228 -> 9224;
9229 -> 9227;
9229 -> 9224;
9230 -> 9227;
9230 -> 9224;
9231 -> 9224;
9232 -> 9225;
9232 -> 9231;
9233 -> 9232;
9233 -> 9079;
9233 -> 9231;
9234 -> 9233;
9234 -> 9231;
9235 -> 9234;
9235 -> 9224;
9236 -> 9224;
9237 -> 9226;
9237 -> 9236;
9237 -> 9224;
9238 -> 9225;
9238 -> 9227;
9238 -> 9224;
9239 -> 9226;
9239 -> 9227;
9239 -> 9224;
9240 -> 9218;
9241 -> 9146;
9241 -> 9240;
9241 -> 9218;
9242 -> 9217;
9242 -> 9077;
9243 -> 9242;
9243 -> 9077;
9244 -> 9242;
9244 -> 9077;
9245 -> 9146;
9245 -> 0;
9245 -> 9077;
9246 -> 9146;
9246 -> 9077;
9247 -> 9242;
9247 -> 9246;
9248 -> 9246;
9249 -> 9247;
9249 -> 9248;
9250 -> 9248;
9251 -> 9249;
9251 -> 9250;
9252 -> 9250;
9253 -> 9251;
9253 -> 9252;
9254 -> 9253;
9254 -> 9252;
9255 -> 9254;
9255 -> 9250;
9256 -> 9255;
9256 -> 9248;
9257 -> 9248;
9258 -> 9256;
9258 -> 9257;
9259 -> 0;
9259 -> 9257;
9260 -> 9259;
9260 -> 9248;
9261 -> 9260;
9261 -> 9246;
9262 -> 9242;
9262 -> 9077;
9263 -> 9262;
9263 -> 9077;
9264 -> 9242;
9264 -> 9263;
9265 -> 9263;
9266 -> 9264;
9266 -> 9265;
9267 -> 9265;
9268 -> 9266;
9268 -> 9267;
9269 -> 9267;
9270 -> 9268;
9270 -> 9269;
9271 -> 9270;
9271 -> 9269;
9272 -> 9271;
9272 -> 9267;
9273 -> 9272;
9273 -> 9265;
9274 -> 9265;
9275 -> 9273;
9275 -> 9274;
9276 -> 0;
9276 -> 9274;
9277 -> 9276;
9277 -> 9265;
9278 -> 9277;
9278 -> 9263;
9279 -> 9146;
9279 -> 0;
9279 -> 9077;
9280 -> 9278;
9280 -> 9119;
9280 -> 9077;
9281 -> 9122;
9281 -> 5427;
9282 -> 5427;
9283 -> 5427;
9284 -> 9282;
9284 -> 9283;
9285 -> 9283;
9286 -> 9281;
9286 -> 9285;
9287 -> 9286;
9287 -> 9242;
9287 -> 9285;
9288 -> 9287;
9288 -> 9285;
9289 -> 9288;
9289 -> 9283;
9290 -> 9283;
9291 -> 9290;
9291 -> 9284;
9291 -> 9283;
9292 -> 9283;
9293 -> 9292;
9293 -> 9284;
9293 -> 9283;
9294 -> 9282;
9294 -> 5422;
9295 -> 5402;
9296 -> 9294;
9296 -> 9295;
9297 -> 9295;
9298 -> 9281;
9298 -> 9242;
9298 -> 9297;
9299 -> 9298;
9300 -> 9298;
9301 -> 9298;
9302 -> 9299;
9302 -> 9298;
9303 -> 9300;
9303 -> 9298;
9304 -> 9301;
9304 -> 9298;
9305 -> 9302;
9305 -> 9298;
9306 -> 9303;
9306 -> 9298;
9307 -> 9304;
9307 -> 9298;
9308 -> 9298;
9308 -> 9077;
9309 -> 9305;
9309 -> 9298;
9310 -> 9306;
9310 -> 9298;
9311 -> 9307;
9311 -> 9298;
9312 -> 9309;
9312 -> 9298;
9313 -> 9310;
9313 -> 9298;
9314 -> 9311;
9314 -> 9298;
9315 -> 9298;
9315 -> 9077;
9316 -> 9314;
9316 -> 9298;
9317 -> 9313;
9317 -> 9298;
9318 -> 9298;
9319 -> 9312;
9319 -> 9298;
9320 -> 9316;
9320 -> 9298;
9321 -> 9317;
9321 -> 9298;
9322 -> 9318;
9322 -> 9298;
9323 -> 9319;
9323 -> 9298;
9324 -> 9298;
9325 -> 0;
9325 -> 9298;
9326 -> 9298;
9327 -> 5394;
9327 -> 5392;
9328 -> 5393;
9328 -> 5392;
9329 -> 5395;
9329 -> 5392;
9330 -> 5392;
9331 -> 9327;
9331 -> 9330;
9332 -> 9328;
9332 -> 9330;
9333 -> 9329;
9333 -> 9330;
9334 -> 5397;
9334 -> 9330;
9335 -> 9330;
9336 -> 9298;
9336 -> 9335;
9337 -> 9336;
9337 -> 9291;
9337 -> 9335;
9338 -> 9337;
9338 -> 0;
9338 -> 9335;
9339 -> 9338;
9339 -> 9330;
9340 -> 5392;
9341 -> 5154;
9342 -> 5114;
9342 -> 9341;
9343 -> 9341;
9344 -> 9342;
9344 -> 9343;
9345 -> 9344;
9345 -> 9146;
9345 -> 9343;
9346 -> 9345;
9346 -> 0;
9346 -> 9341;
9347 -> 9341;
9348 -> 9346;
9348 -> 9347;
9348 -> 9341;
9349 -> 9348;
9349 -> 5154;
9350 -> 5114;
9350 -> 9146;
9350 -> 5112;
9351 -> 5112;
9352 -> 5114;
9352 -> 9351;
9353 -> 9351;
9354 -> 9352;
9354 -> 9353;
9355 -> 9353;
9356 -> 9354;
9356 -> 9355;
9357 -> 9356;
9357 -> 9146;
9357 -> 9355;
9358 -> 9357;
9358 -> 0;
9358 -> 9353;
9359 -> 9353;
9360 -> 9358;
9360 -> 9359;
9360 -> 9353;
9361 -> 9360;
9361 -> 9351;
9362 -> 0;
9362 -> 9361;
9363 -> 9362;
9363 -> 5112;
9364 -> 5112;
9365 -> 9363;
9365 -> 9364;
9366 -> 9298;
9366 -> 9364;
9367 -> 9366;
9367 -> 9364;
9368 -> 9365;
9368 -> 9364;
9369 -> 9364;
9370 -> 9367;
9370 -> 9369;
9371 -> 9368;
9371 -> 9369;
9372 -> 9366;
9372 -> 9077;
9372 -> 9369;
9373 -> 9370;
9373 -> 9242;
9373 -> 9369;
9374 -> 9370;
9374 -> 9146;
9374 -> 9369;
9375 -> 9371;
9375 -> 9369;
9376 -> 9369;
9377 -> 9373;
9377 -> 9376;
9378 -> 9374;
9378 -> 9376;
9379 -> 9375;
9379 -> 9376;
9380 -> 9376;
9381 -> 9376;
9382 -> 9376;
9383 -> 9381;
9383 -> 9382;
9384 -> 9377;
9384 -> 9382;
9385 -> 9384;
9385 -> 9382;
9386 -> 9377;
9386 -> 9385;
9387 -> 9385;
9388 -> 9386;
9388 -> 9387;
9389 -> 9387;
9390 -> 9388;
9390 -> 9389;
9391 -> 9389;
9392 -> 9390;
9392 -> 9391;
9393 -> 9392;
9393 -> 9391;
9394 -> 9393;
9394 -> 9389;
9395 -> 9394;
9395 -> 9387;
9396 -> 9387;
9397 -> 9395;
9397 -> 9396;
9398 -> 0;
9398 -> 9396;
9399 -> 9398;
9399 -> 9387;
9400 -> 9399;
9400 -> 9385;
9401 -> 9378;
9401 -> 0;
9401 -> 9382;
9402 -> 9382;
9403 -> 9400;
9403 -> 9402;
9403 -> 9382;
9404 -> 9382;
9405 -> 9379;
9405 -> 9404;
9405 -> 9382;
9406 -> 9381;
9406 -> 9369;
9407 -> 9406;
9407 -> 5112;
9410 -> 9408;
9410 -> 9409;
9411 -> 9409;
9412 -> 9410;
9412 -> 9411;
9412 -> 9409;
9413 -> 9409;
9414 -> 5112;
9415 -> 5112;
9416 -> 9407;
9416 -> 9415;
9417 -> 9414;
9417 -> 9415;
9418 -> 9416;
9418 -> 9417;
9418 -> 9415;
9419 -> 9350;
9419 -> 9414;
9419 -> 9418;
9419 -> 9146;
9419 -> 9377;
9419 -> 9378;
9419 -> 9379;
9419 -> 9227;
9419 -> 9229;
9419 -> 9239;
9419 -> 9238;
9419 -> 9079;
9419 -> 9078;
9419 -> 9077;
9419 -> 5112;
9420 -> 9419;
9421 -> 9420;
9421 -> 9077;
9422 -> 9420;
9422 -> 9419;
9423 -> 5145;
9423 -> 9419;
9424 -> 9419;
9425 -> 9422;
9425 -> 9424;
9426 -> 9423;
9426 -> 9424;
9427 -> 5114;
9427 -> 9424;
9428 -> 9424;
9429 -> 9425;
9429 -> 9428;
9430 -> 9428;
9431 -> 9430;
9431 -> 9424;
9432 -> 9425;
9432 -> 9431;
9433 -> 9431;
9434 -> 9432;
9434 -> 9433;
9435 -> 9433;
9436 -> 9434;
9436 -> 9435;
9437 -> 0;
9437 -> 9435;
9438 -> 9437;
9438 -> 9433;
9439 -> 9438;
9439 -> 9431;
9440 -> 9425;
9440 -> 9439;
9441 -> 9439;
9442 -> 9439;
9443 -> 9440;
9443 -> 9442;
9444 -> 9441;
9444 -> 9442;
9445 -> 9442;
9446 -> 9443;
9446 -> 9445;
9446 -> 9442;
9447 -> 9442;
9448 -> 9443;
9448 -> 9447;
9449 -> 9447;
9449 -> 9442;
9450 -> 9444;
9450 -> 9442;
9451 -> 9450;
9452 -> 9451;
9453 -> 9425;
9453 -> 9452;
9454 -> 9452;
9455 -> 9454;
9455 -> 9451;
9456 -> 9455;
9457 -> 9427;
9457 -> 9456;
9458 -> 9456;
9459 -> 9457;
9459 -> 9458;
9460 -> 9459;
9460 -> 0;
9460 -> 9456;
9461 -> 9456;
9462 -> 9460;
9462 -> 9461;
9462 -> 9456;
9463 -> 9462;
9463 -> 9455;
9464 -> 9463;
9465 -> 9464;
9465 -> 9463;
9466 -> 9424;
9467 -> 9427;
9467 -> 9424;
9468 -> 9425;
9468 -> 9424;
9469 -> 9466;
9469 -> 9424;
9470 -> 9424;
9471 -> 9467;
9471 -> 9470;
9472 -> 9468;
9472 -> 9470;
9473 -> 9469;
9473 -> 9470;
9474 -> 9472;
9474 -> 9470;
9475 -> 9471;
9475 -> 9470;
9476 -> 9473;
9476 -> 9470;
9477 -> 9470;
9478 -> 9474;
9478 -> 9477;
9479 -> 9475;
9479 -> 9477;
9480 -> 9476;
9480 -> 9477;
9481 -> 9480;
9481 -> 9477;
9482 -> 9478;
9482 -> 9477;
9483 -> 9481;
9483 -> 9477;
9484 -> 9479;
9484 -> 9477;
9485 -> 9477;
9486 -> 9477;
9487 -> 9482;
9487 -> 9486;
9488 -> 9483;
9488 -> 9486;
9489 -> 9484;
9489 -> 9486;
9490 -> 9485;
9490 -> 9486;
9491 -> 9486;
9492 -> 9487;
9492 -> 9486;
9493 -> 9488;
9493 -> 9486;
9494 -> 9489;
9494 -> 9486;
9495 -> 9490;
9495 -> 9486;
9496 -> 9486;
9497 -> 9491;
9497 -> 9496;
9498 -> 9492;
9498 -> 9496;
9499 -> 9491;
9499 -> 9496;
9500 -> 9493;
9500 -> 9496;
9501 -> 9494;
9501 -> 9496;
9502 -> 9495;
9502 -> 9496;
9503 -> 9491;
9503 -> 9496;
9504 -> 9496;
9505 -> 9497;
9505 -> 9504;
9506 -> 9505;
9506 -> 9491;
9506 -> 9504;
9507 -> 9506;
9507 -> 9504;
9508 -> 9507;
9508 -> 9496;
9509 -> 9498;
9509 -> 9496;
9510 -> 9508;
9510 -> 9509;
9510 -> 9496;
9511 -> 9496;
9512 -> 9502;
9512 -> 9511;
9512 -> 9496;
9513 -> 9503;
9513 -> 9511;
9513 -> 9496;
9514 -> 9512;
9514 -> 9513;
9514 -> 9496;
9515 -> 9496;
9516 -> 9498;
9516 -> 9515;
9517 -> 9515;
9518 -> 9515;
9519 -> 9516;
9519 -> 9518;
9520 -> 0;
9520 -> 9518;
9521 -> 9520;
9521 -> 9515;
9522 -> 9515;
9523 -> 9497;
9523 -> 9522;
9524 -> 9523;
9524 -> 9491;
9524 -> 9522;
9525 -> 9524;
9525 -> 9522;
9526 -> 9525;
9526 -> 9515;
9527 -> 9526;
9528 -> 9500;
9528 -> 9527;
9528 -> 9526;
9529 -> 9516;
9529 -> 9528;
9530 -> 9501;
9530 -> 9528;
9531 -> 9517;
9531 -> 9528;
9532 -> 9529;
9532 -> 9530;
9532 -> 9531;
9532 -> 9500;
9532 -> 9419;
9532 -> 9483;
9532 -> 9528;
9533 -> 9528;
9534 -> 9532;
9534 -> 9533;
9535 -> 9532;
9535 -> 9533;
9536 -> 9532;
9536 -> 9533;
9537 -> 9533;
9538 -> 9534;
9538 -> 9537;
9539 -> 0;
9539 -> 9537;
9540 -> 9539;
9540 -> 9533;
9541 -> 9540;
9542 -> 9536;
9542 -> 9541;
9542 -> 9532;
9542 -> 9528;
9543 -> 9515;
9544 -> 9543;
9544 -> 9515;
9545 -> 9515;
9546 -> 9516;
9546 -> 9545;
9547 -> 0;
9547 -> 9545;
9548 -> 9547;
9548 -> 9515;
9549 -> 9548;
9550 -> 9516;
9550 -> 9549;
9551 -> 9550;
9551 -> 9542;
9551 -> 9549;
9552 -> 9551;
9552 -> 9548;
9553 -> 9502;
9553 -> 9515;
9554 -> 9553;
9555 -> 9502;
9555 -> 9515;
9556 -> 9555;
9557 -> 9552;
9557 -> 9556;
9558 -> 9557;
9558 -> 9542;
9558 -> 9556;
9559 -> 9556;
9560 -> 9558;
9560 -> 9559;
9561 -> 9557;
9561 -> 9542;
9561 -> 9559;
9562 -> 9560;
9562 -> 9559;
9563 -> 9559;
9564 -> 9562;
9564 -> 9563;
9565 -> 9564;
9565 -> 9563;
9566 -> 9563;
9567 -> 9565;
9567 -> 9566;
9568 -> 9566;
9569 -> 9567;
9569 -> 9568;
9570 -> 9568;
9571 -> 9569;
9571 -> 9570;
9572 -> 9571;
9572 -> 9570;
9573 -> 9572;
9573 -> 9568;
9574 -> 9573;
9574 -> 9566;
9575 -> 9566;
9576 -> 9574;
9576 -> 9575;
9577 -> 0;
9577 -> 9575;
9578 -> 9577;
9578 -> 9566;
9579 -> 9578;
9579 -> 9563;
9580 -> 9564;
9580 -> 9579;
9581 -> 9580;
9581 -> 9555;
9582 -> 9581;
9582 -> 9518;
9583 -> 9554;
9583 -> 9522;
9584 -> 9583;
9584 -> 9554;
9584 -> 9522;
9585 -> 9584;
9585 -> 9522;
9586 -> 9585;
9586 -> 9515;
9587 -> 9586;
9588 -> 9500;
9588 -> 9587;
9588 -> 9586;
9589 -> 9581;
9589 -> 9588;
9590 -> 9501;
9590 -> 9588;
9591 -> 9517;
9591 -> 9588;
9592 -> 9588;
9593 -> 9589;
9593 -> 9592;
9594 -> 9589;
9594 -> 9592;
9595 -> 9592;
9596 -> 9593;
9596 -> 9595;
9597 -> 0;
9597 -> 9595;
9598 -> 9597;
9598 -> 9592;
9599 -> 9598;
9600 -> 9581;
9600 -> 9545;
9601 -> 9589;
9601 -> 9559;
9602 -> 9589;
9602 -> 9566;
9603 -> 9602;
9603 -> 9568;
9604 -> 9603;
9604 -> 9570;
9605 -> 9570;
9606 -> 9604;
9606 -> 9605;
9607 -> 9606;
9607 -> 9570;
9608 -> 9607;
9608 -> 9568;
9609 -> 9608;
9609 -> 9518;
9610 -> 9609;
9610 -> 9515;
9611 -> 9610;
9612 -> 9611;
9612 -> 9610;
9613 -> 9610;
9614 -> 9612;
9614 -> 9613;
9614 -> 9610;
9615 -> 9608;
9615 -> 9592;
9616 -> 9608;
9616 -> 9592;
9617 -> 9615;
9618 -> 9616;
9618 -> 9615;
9619 -> 9608;
9619 -> 9615;
9620 -> 9615;
9621 -> 9617;
9621 -> 9620;
9622 -> 9618;
9622 -> 9620;
9623 -> 9619;
9623 -> 9620;
9624 -> 9620;
9625 -> 9621;
9625 -> 9624;
9626 -> 0;
9626 -> 9624;
9627 -> 9625;
9627 -> 9620;
9628 -> 9627;
9628 -> 0;
9628 -> 9620;
9629 -> 9628;
9630 -> 9623;
9630 -> 9629;
9630 -> 9608;
9630 -> 9588;
9631 -> 9630;
9632 -> 9608;
9632 -> 9631;
9633 -> 0;
9633 -> 9631;
9634 -> 9633;
9634 -> 9630;
9635 -> 9634;
9635 -> 0;
9635 -> 9630;
9636 -> 9635;
9637 -> 9481;
9637 -> 9477;
9638 -> 9636;
9638 -> 9477;
9639 -> 9426;
9639 -> 9424;
9640 -> 9424;
9641 -> 9427;
9641 -> 9640;
9642 -> 9641;
9642 -> 9630;
9642 -> 9640;
9643 -> 9642;
9643 -> 9424;
9644 -> 9637;
9644 -> 9424;
9645 -> 9639;
9645 -> 9643;
9645 -> 9644;
9645 -> 5145;
9645 -> 9630;
9645 -> 9424;
9646 -> 9419;
9647 -> 9419;
9648 -> 9647;
9648 -> 9645;
9649 -> 9647;
9649 -> 9645;
9650 -> 9647;
9650 -> 9645;
9651 -> 9650;
9651 -> 9419;
9652 -> 5145;
9652 -> 9419;
9653 -> 9419;
9654 -> 5130;
9654 -> 9651;
9654 -> 9653;
9654 -> 9419;
9655 -> 9654;
9655 -> 9419;
9656 -> 9655;
9657 -> 9656;
9657 -> 9654;
9658 -> 9656;
9658 -> 9655;
9659 -> 5148;
9659 -> 9655;
9660 -> 0;
9660 -> 9419;
9661 -> 9419;
9662 -> 9660;
9662 -> 9661;
9663 -> 5114;
9663 -> 9658;
9663 -> 9661;
9664 -> 9663;
9664 -> 9662;
9664 -> 9661;
9665 -> 5145;
9665 -> 9658;
9665 -> 9664;
9665 -> 5112;
9666 -> 5148;
9666 -> 9665;
9666 -> 5112;
9667 -> 5114;
9667 -> 9666;
9667 -> 5112;
9668 -> 9667;
9668 -> 5109;
9669 -> 5107;
9670 -> 9668;
9670 -> 9669;
9671 -> 9669;
9672 -> 9670;
9672 -> 9666;
9672 -> 9671;
9673 -> 0;
9673 -> 1;
9674 -> 1;
9675 -> 9670;
9675 -> 9674;
9676 -> 0;
9676 -> 9674;
9677 -> 9676;
9677 -> 1;
9678 -> 1;
9679 -> 9670;
9679 -> 1;
9680 -> 1;
9681 -> 9679;
9681 -> 9680;
9682 -> 9680;
9683 -> 9680;
9684 -> 9682;
9684 -> 9683;
9685 -> 9681;
9685 -> 9683;
9686 -> 9685;
9686 -> 9666;
9686 -> 9683;
9687 -> 9686;
9687 -> 9680;
9688 -> 1;
9689 -> 9670;
9689 -> 1;
9690 -> 1;
9691 -> 9689;
9691 -> 9690;
9692 -> 9690;
9693 -> 9690;
9694 -> 9692;
9694 -> 9693;
9695 -> 9691;
9695 -> 9693;
9696 -> 9695;
9696 -> 9666;
9696 -> 9693;
9697 -> 9696;
9697 -> 9690;
9698 -> 1;
9699 -> 9697;
9699 -> 9698;
9700 -> 9698;
9701 -> 9699;
9701 -> 9697;
9701 -> 9700;
9702 -> 9701;
9702 -> 9698;
9703 -> 1;
9704 -> 9670;
9704 -> 1;
9705 -> 1;
9706 -> 9704;
9706 -> 9705;
9707 -> 9705;
9708 -> 9706;
9708 -> 9707;
9709 -> 9707;
9710 -> 9708;
9710 -> 9709;
9711 -> 9709;
9712 -> 9710;
9712 -> 9711;
9713 -> 9712;
9713 -> 9697;
9713 -> 9711;
9714 -> 9711;
9715 -> 9713;
9715 -> 9714;
9715 -> 9711;
9716 -> 9712;
9716 -> 9711;
9717 -> 9711;
9718 -> 9716;
9719 -> 9716;
9719 -> 9718;
9720 -> 9718;
9720 -> 9716;
9721 -> 9720;
9721 -> 9716;
9722 -> 9721;
9723 -> 9721;
9723 -> 9722;
9724 -> 9716;
9724 -> 9722;
9725 -> 9724;
9725 -> 9697;
9725 -> 9722;
9726 -> 9725;
9726 -> 9697;
9726 -> 9716;
9727 -> 9726;
9728 -> 9726;
9729 -> 9727;
9729 -> 9728;
9730 -> 9729;
9730 -> 9728;
9731 -> 9729;
9731 -> 9728;
9732 -> 9729;
9732 -> 9728;
9733 -> 9712;
9733 -> 9697;
9733 -> 9726;
9734 -> 9727;
9734 -> 9726;
9735 -> 9726;
9736 -> 9733;
9736 -> 9734;
9736 -> 9735;
9736 -> 9730;
9736 -> 9731;
9736 -> 9732;
9736 -> 9697;
9736 -> 9726;
9737 -> 9736;
9737 -> 9709;
9738 -> 9737;
9738 -> 2784;
9738 -> 9709;
9739 -> 9737;
9739 -> 9736;
9739 -> 9709;
9740 -> 9737;
9740 -> 9736;
9740 -> 9739;
9741 -> 9739;
9742 -> 9710;
9742 -> 9741;
9743 -> 9741;
9744 -> 2725;
9744 -> 9741;
9745 -> 9742;
9745 -> 9741;
9746 -> 9741;
9747 -> 9745;
9748 -> 9745;
9748 -> 9747;
9749 -> 9747;
9749 -> 9745;
9750 -> 9749;
9750 -> 9745;
9751 -> 9750;
9752 -> 9750;
9752 -> 9751;
9753 -> 9745;
9754 -> 9751;
9754 -> 9736;
9754 -> 9753;
9754 -> 9745;
9755 -> 9751;
9755 -> 9754;
9755 -> 9736;
9756 -> 9744;
9756 -> 9754;
9757 -> 9743;
9757 -> 9754;
9758 -> 9754;
9759 -> 9755;
9759 -> 9758;
9760 -> 9756;
9760 -> 9758;
9761 -> 9757;
9761 -> 9758;
9762 -> 9759;
9762 -> 9758;
9763 -> 9762;
9763 -> 9760;
9763 -> 9755;
9763 -> 9744;
9763 -> 2722;
9763 -> 2723;
9763 -> 2724;
9763 -> 9758;
9764 -> 9758;
9765 -> 9763;
9765 -> 9764;
9766 -> 9763;
9766 -> 9764;
9767 -> 9765;
9767 -> 9764;
9768 -> 9767;
9768 -> 9764;
9769 -> 9768;
9770 -> 9765;
9770 -> 9769;
9771 -> 9769;
9772 -> 9770;
9772 -> 9763;
9772 -> 9771;
9772 -> 9769;
9773 -> 9770;
9773 -> 9772;
9774 -> 9772;
9775 -> 9773;
9775 -> 9774;
9776 -> 9774;
9777 -> 9775;
9777 -> 9776;
9778 -> 9777;
9778 -> 9763;
9778 -> 9776;
9779 -> 9778;
9779 -> 9774;
9780 -> 0;
9780 -> 9774;
9781 -> 9774;
9782 -> 9779;
9782 -> 9781;
9783 -> 9780;
9783 -> 9781;
9784 -> 9775;
9784 -> 9781;
9785 -> 9782;
9785 -> 9784;
9785 -> 9781;
9786 -> 9781;
9787 -> 9782;
9787 -> 9786;
9787 -> 9781;
9788 -> 9783;
9788 -> 0;
9788 -> 9781;
9789 -> 9781;
9790 -> 9788;
9791 -> 9782;
9791 -> 9790;
9792 -> 0;
9792 -> 9791;
9793 -> 9792;
9793 -> 9788;
9794 -> 9782;
9794 -> 9781;
9795 -> 9781;
9796 -> 9794;
9796 -> 9795;
9796 -> 9781;
9797 -> 9781;
9798 -> 9784;
9798 -> 9797;
9799 -> 9798;
9799 -> 9763;
9799 -> 9797;
9800 -> 9799;
9800 -> 9781;
9801 -> 9781;
9802 -> 9794;
9802 -> 9801;
9803 -> 9802;
9803 -> 9781;
9804 -> 9784;
9804 -> 9800;
9804 -> 9781;
9805 -> 9794;
9805 -> 9803;
9805 -> 9781;
9806 -> 9804;
9806 -> 9781;
9807 -> 9804;
9807 -> 9805;
9807 -> 9781;
9808 -> 0;
9808 -> 9781;
9809 -> 9783;
9809 -> 9808;
9809 -> 9781;
9810 -> 9781;
9811 -> 9807;
9811 -> 9809;
9811 -> 9781;
9812 -> 9800;
9812 -> 9781;
9813 -> 9803;
9813 -> 9781;
9814 -> 9783;
9814 -> 9781;
9815 -> 9781;
9816 -> 9812;
9816 -> 9815;
9817 -> 9813;
9817 -> 9815;
9818 -> 9814;
9818 -> 9815;
9819 -> 9816;
9819 -> 9815;
9820 -> 9817;
9820 -> 9815;
9821 -> 9818;
9821 -> 9815;
9822 -> 9815;
9823 -> 9820;
9823 -> 9822;
9824 -> 9821;
9824 -> 9822;
9825 -> 9816;
9825 -> 9822;
9826 -> 9823;
9826 -> 9825;
9826 -> 9822;
9827 -> 9826;
9828 -> 9794;
9828 -> 9781;
9829 -> 9783;
9829 -> 9781;
9830 -> 9781;
9831 -> 9828;
9831 -> 9830;
9832 -> 9829;
9832 -> 9830;
9833 -> 9784;
9833 -> 9830;
9834 -> 9830;
9835 -> 9833;
9835 -> 9834;
9836 -> 9835;
9836 -> 9763;
9836 -> 9834;
9837 -> 9836;
9837 -> 9830;
9838 -> 9830;
9839 -> 9830;
9840 -> 9833;
9840 -> 9839;
9841 -> 9840;
9841 -> 9763;
9841 -> 9839;
9842 -> 9841;
9842 -> 9830;
9843 -> 9833;
9843 -> 9830;
9844 -> 9830;
9845 -> 9831;
9845 -> 9844;
9846 -> 9845;
9846 -> 9844;
9847 -> 9846;
9847 -> 9830;
9848 -> 9831;
9848 -> 9830;
9849 -> 9842;
9849 -> 9830;
9850 -> 9830;
9851 -> 9833;
9851 -> 9850;
9852 -> 9851;
9852 -> 9763;
9852 -> 9850;
9853 -> 9852;
9853 -> 9830;
9854 -> 9830;
9855 -> 9831;
9855 -> 9854;
9856 -> 9854;
9857 -> 9856;
9857 -> 9830;
9858 -> 9853;
9858 -> 9857;
9858 -> 9830;
9859 -> 9842;
9859 -> 9847;
9859 -> 9830;
9860 -> 0;
9860 -> 9830;
9861 -> 9832;
9861 -> 9860;
9861 -> 9830;
9862 -> 9830;
9863 -> 9859;
9863 -> 9861;
9863 -> 9830;
9864 -> 9830;
9865 -> 9833;
9865 -> 9864;
9866 -> 9865;
9866 -> 9763;
9866 -> 9864;
9867 -> 9866;
9867 -> 9830;
9868 -> 9830;
9869 -> 9831;
9869 -> 9868;
9870 -> 9868;
9871 -> 9869;
9871 -> 9870;
9872 -> 9870;
9873 -> 9871;
9873 -> 9872;
9874 -> 9873;
9874 -> 9763;
9874 -> 9792;
9874 -> 9872;
9875 -> 9872;
9876 -> 9873;
9876 -> 9870;
9877 -> 9870;
9878 -> 9876;
9878 -> 9877;
9879 -> 9878;
9879 -> 9877;
9880 -> 9877;
9881 -> 9879;
9881 -> 9880;
9881 -> 9763;
9881 -> 9792;
9881 -> 9877;
9882 -> 9881;
9882 -> 9880;
9883 -> 9881;
9883 -> 0;
9883 -> 9880;
9884 -> 9881;
9884 -> 9880;
9885 -> 9881;
9885 -> 9884;
9886 -> 9884;
9887 -> 9885;
9887 -> 9886;
9888 -> 9887;
9888 -> 9886;
9889 -> 9886;
9890 -> 9888;
9890 -> 9889;
9891 -> 9890;
9891 -> 9889;
9892 -> 9891;
9892 -> 9886;
9893 -> 9892;
9893 -> 9886;
9894 -> 9886;
9894 -> 9884;
9895 -> 9881;
9895 -> 9880;
9896 -> 9895;
9896 -> 9880;
9897 -> 9881;
9897 -> 9896;
9898 -> 9896;
9899 -> 9897;
9899 -> 9898;
9900 -> 9899;
9900 -> 9898;
9901 -> 9898;
9902 -> 9900;
9902 -> 9901;
9903 -> 9902;
9903 -> 9901;
9904 -> 9903;
9904 -> 9898;
9905 -> 9904;
9905 -> 9898;
9906 -> 9898;
9906 -> 9896;
9907 -> 9881;
9907 -> 0;
9907 -> 9880;
9908 -> 9880;
9909 -> 9906;
9909 -> 9908;
9909 -> 9880;
9910 -> 9880;
9911 -> 9881;
9911 -> 9910;
9911 -> 9880;
9912 -> 9881;
9912 -> 9868;
9913 -> 9912;
9913 -> 9830;
9914 -> 9867;
9914 -> 9763;
9914 -> 9830;
9915 -> 9914;
9915 -> 9913;
9915 -> 9881;
9915 -> 9830;
9916 -> 9830;
9917 -> 9916;
9917 -> 9914;
9917 -> 9830;
9918 -> 9867;
9918 -> 9916;
9918 -> 9763;
9918 -> 9792;
9918 -> 9881;
9918 -> 9917;
9919 -> 9913;
9919 -> 9916;
9919 -> 9881;
9919 -> 9918;
9919 -> 9917;
9920 -> 9919;
9920 -> 9917;
9921 -> 9832;
9921 -> 9917;
9922 -> 9917;
9923 -> 9920;
9923 -> 9922;
9924 -> 9921;
9924 -> 9922;
9925 -> 9918;
9925 -> 9922;
9926 -> 9923;
9926 -> 9922;
9927 -> 9922;
9928 -> 9926;
9928 -> 9927;
9929 -> 9925;
9929 -> 9927;
9930 -> 9929;
9930 -> 9918;
9930 -> 9927;
9931 -> 9928;
9931 -> 9919;
9931 -> 9927;
9932 -> 9930;
9932 -> 9931;
9932 -> 9927;
9933 -> 9922;
9934 -> 9925;
9934 -> 9933;
9935 -> 9934;
9935 -> 9922;
9936 -> 9935;
9937 -> 9923;
9937 -> 9936;
9938 -> 9937;
9938 -> 9935;
9939 -> 9923;
9939 -> 9935;
9940 -> 9924;
9940 -> 9935;
9941 -> 9935;
9942 -> 9939;
9942 -> 9941;
9943 -> 9940;
9943 -> 9941;
9944 -> 9925;
9944 -> 9941;
9945 -> 9944;
9945 -> 9941;
9946 -> 9942;
9946 -> 9941;
9947 -> 9943;
9947 -> 9941;
9948 -> 9941;
9949 -> 9945;
9949 -> 9948;
9950 -> 9946;
9950 -> 9948;
9951 -> 9947;
9951 -> 9948;
9952 -> 9944;
9952 -> 9918;
9952 -> 9948;
9953 -> 9950;
9953 -> 9948;
9954 -> 9951;
9954 -> 9948;
9955 -> 9948;
9956 -> 9953;
9956 -> 9955;
9957 -> 9954;
9957 -> 9955;
9958 -> 9949;
9958 -> 9955;
9959 -> 9955;
9960 -> 9958;
9960 -> 9959;
9961 -> 9960;
9961 -> 9918;
9961 -> 9959;
9962 -> 9960;
9962 -> 9955;
9963 -> 9955;
9964 -> 9956;
9964 -> 9963;
9965 -> 9964;
9965 -> 9919;
9965 -> 9963;
9966 -> 9964;
9966 -> 9955;
9967 -> 9957;
9967 -> 9955;
9968 -> 9955;
9969 -> 9966;
9969 -> 9968;
9970 -> 9967;
9970 -> 9968;
9971 -> 9962;
9971 -> 9968;
9972 -> 9969;
9972 -> 9968;
9973 -> 9970;
9973 -> 9968;
9974 -> 9968;
9975 -> 9972;
9975 -> 9974;
9976 -> 9973;
9976 -> 9974;
9977 -> 9971;
9977 -> 9974;
9978 -> 9977;
9978 -> 9974;
9979 -> 9975;
9979 -> 9974;
9980 -> 9978;
9980 -> 9979;
9980 -> 9974;
9981 -> 9974;
9982 -> 9975;
9982 -> 9981;
9982 -> 9974;
9983 -> 9982;
9984 -> 9938;
9984 -> 9983;
9984 -> 9935;
9985 -> 9984;
9986 -> 9985;
9987 -> 9775;
9987 -> 9774;
9988 -> 9774;
9989 -> 9987;
9989 -> 9988;
9990 -> 9988;
9991 -> 9989;
9991 -> 9990;
9992 -> 9991;
9992 -> 9919;
9992 -> 9990;
9993 -> 9992;
9993 -> 9988;
9994 -> 9988;
9995 -> 9989;
9995 -> 9994;
9996 -> 9995;
9996 -> 9919;
9996 -> 9994;
9997 -> 9996;
9997 -> 9988;
9998 -> 9988;
9999 -> 9997;
9999 -> 9998;
10000 -> 9998;
10001 -> 9988;
10002 -> 10001;
10002 -> 9993;
10002 -> 9919;
10002 -> 9988;
10003 -> 9999;
10003 -> 10001;
10003 -> 9919;
10003 -> 10002;
10004 -> 10002;
10005 -> 10003;
10005 -> 10004;
10006 -> 10005;
10006 -> 10003;
10006 -> 10004;
10007 -> 10002;
10008 -> 10005;
10008 -> 10007;
10009 -> 10008;
10009 -> 10007;
10010 -> 10009;
10010 -> 10007;
10011 -> 0;
10011 -> 10002;
10012 -> 10002;
10013 -> 10010;
10013 -> 10012;
10014 -> 10011;
10014 -> 10012;
10015 -> 10003;
10015 -> 10012;
10016 -> 10013;
10016 -> 10012;
10017 -> 10014;
10017 -> 10012;
10018 -> 10012;
10019 -> 10016;
10019 -> 10018;
10020 -> 10017;
10020 -> 10018;
10021 -> 10015;
10021 -> 10018;
10022 -> 10021;
10022 -> 10018;
10023 -> 10019;
10023 -> 10018;
10024 -> 10022;
10024 -> 10023;
10024 -> 10018;
10025 -> 10018;
10026 -> 10019;
10026 -> 10025;
10026 -> 10018;
10027 -> 10026;
10028 -> 10027;
10029 -> 9774;
10030 -> 9775;
10030 -> 10029;
10031 -> 10030;
10031 -> 10003;
10031 -> 10029;
10032 -> 10031;
10032 -> 9774;
10033 -> 9774;
10034 -> 10032;
10034 -> 10033;
10035 -> 9774;
10036 -> 9775;
10036 -> 10035;
10037 -> 10036;
10037 -> 10034;
10037 -> 10035;
10038 -> 10037;
10038 -> 9774;
10039 -> 10034;
10039 -> 9774;
10040 -> 9774;
10041 -> 9775;
10041 -> 10040;
10042 -> 10041;
10042 -> 10038;
10042 -> 10040;
10043 -> 10042;
10043 -> 9774;
10044 -> 10043;
10045 -> 10044;
10045 -> 10043;
10046 -> 10045;
10047 -> 10046;
10047 -> 10038;
10048 -> 10046;
10048 -> 10045;
10049 -> 10038;
10049 -> 10045;
10050 -> 10045;
10051 -> 10048;
10051 -> 10050;
10052 -> 10050;
10053 -> 10051;
10053 -> 10050;
10054 -> 10050;
10055 -> 10053;
10055 -> 10054;
10056 -> 10054;
10056 -> 10050;
10057 -> 10053;
10057 -> 10056;
10058 -> 10056;
10059 -> 10057;
10059 -> 10058;
10060 -> 10058;
10061 -> 10060;
10061 -> 10056;
10062 -> 10052;
10062 -> 10056;
10063 -> 10061;
10063 -> 10062;
10063 -> 10056;
10064 -> 10056;
10065 -> 10057;
10065 -> 10064;
10066 -> 10064;
10067 -> 10065;
10067 -> 10048;
10067 -> 10066;
10068 -> 10067;
10068 -> 10048;
10068 -> 10066;
10069 -> 10067;
10069 -> 10064;
10070 -> 10069;
10070 -> 10056;
10071 -> 10070;
10071 -> 10050;
10072 -> 10063;
10072 -> 10050;
10073 -> 10071;
10073 -> 10072;
10073 -> 10048;
10073 -> 10050;
10074 -> 10050;
10075 -> 9774;
10076 -> 10073;
10076 -> 10075;
10076 -> 9774;
10077 -> 10073;
10077 -> 9774;
10078 -> 10077;
10078 -> 9770;
10078 -> 9772;
10079 -> 9770;
10079 -> 10073;
10079 -> 10078;
10079 -> 9769;
10080 -> 10079;
10081 -> 10079;
10082 -> 10080;
10082 -> 10081;
10083 -> 9759;
10083 -> 10081;
10084 -> 10083;
10084 -> 10079;
10084 -> 10081;
10085 -> 10084;
10086 -> 10083;
10086 -> 10085;
10087 -> 10085;
10088 -> 10086;
10088 -> 10087;
10089 -> 10088;
10089 -> 10079;
10089 -> 10087;
10090 -> 10089;
10091 -> 10085;
10092 -> 10086;
10092 -> 10079;
10092 -> 10085;
10093 -> 10092;
10093 -> 10084;
10094 -> 10084;
10095 -> 10094;
10095 -> 10084;
10096 -> 10082;
10096 -> 10084;
10097 -> 10084;
10098 -> 10096;
10098 -> 10097;
10099 -> 10095;
10099 -> 10097;
10100 -> 10099;
10100 -> 10079;
10100 -> 10097;
10101 -> 10099;
10101 -> 10079;
10101 -> 10100;
10102 -> 10100;
10103 -> 10099;
10103 -> 10102;
10104 -> 10102;
10105 -> 10102;
10106 -> 10104;
10106 -> 10105;
10107 -> 10103;
10107 -> 10105;
10108 -> 10107;
10108 -> 10079;
10108 -> 10105;
10109 -> 10107;
10109 -> 10079;
10109 -> 10108;
10110 -> 10108;
10111 -> 10107;
10111 -> 10110;
10112 -> 10110;
10113 -> 10111;
10113 -> 10112;
10114 -> 10112;
10115 -> 10113;
10115 -> 10114;
10116 -> 10114;
10116 -> 10112;
10117 -> 10113;
10117 -> 10110;
10118 -> 10110;
10119 -> 10117;
10119 -> 10118;
10120 -> 10119;
10120 -> 10110;
10121 -> 10111;
10121 -> 10079;
10121 -> 10110;
10122 -> 10110;
10123 -> 10120;
10123 -> 10122;
10123 -> 10110;
10124 -> 10120;
10124 -> 10123;
10125 -> 10117;
10125 -> 10123;
10126 -> 10111;
10126 -> 10123;
10127 -> 10123;
10128 -> 10123;
10129 -> 10125;
10129 -> 10128;
10130 -> 10126;
10130 -> 10128;
10131 -> 10127;
10131 -> 10128;
10132 -> 10128;
10133 -> 10129;
10133 -> 10132;
10133 -> 10128;
10134 -> 10120;
10134 -> 10123;
10135 -> 10134;
10136 -> 10135;
10136 -> 10129;
10137 -> 10136;
10137 -> 10134;
10138 -> 10134;
10139 -> 10137;
10139 -> 10134;
10140 -> 10134;
10141 -> 10139;
10141 -> 10140;
10142 -> 10139;
10142 -> 10140;
10143 -> 10142;
10143 -> 10139;
10143 -> 10140;
10144 -> 10140;
10145 -> 10143;
10145 -> 10144;
10145 -> 10140;
10146 -> 10140;
10147 -> 10143;
10147 -> 10146;
10148 -> 10147;
10148 -> 10139;
10148 -> 10146;
10149 -> 10148;
10149 -> 10140;
10150 -> 10140;
10151 -> 10143;
10151 -> 10150;
10152 -> 10151;
10152 -> 10140;
10153 -> 10149;
10153 -> 10152;
10153 -> 10140;
10154 -> 10153;
10154 -> 10141;
10154 -> 10140;
10155 -> 10140;
10156 -> 10143;
10156 -> 10155;
10156 -> 10140;
10157 -> 10140;
10158 -> 10143;
10158 -> 10157;
10159 -> 10158;
10159 -> 10139;
10159 -> 10157;
10160 -> 10159;
10160 -> 10140;
10161 -> 10160;
10161 -> 10141;
10161 -> 10140;
10162 -> 10140;
10163 -> 10143;
10163 -> 10162;
10164 -> 10163;
10164 -> 10139;
10164 -> 10162;
10165 -> 10164;
10165 -> 10140;
10166 -> 10140;
10167 -> 10143;
10167 -> 10166;
10168 -> 10167;
10168 -> 10140;
10169 -> 10165;
10169 -> 10168;
10169 -> 10140;
10170 -> 10141;
10170 -> 10169;
10170 -> 10140;
10171 -> 10140;
10172 -> 10170;
10172 -> 10171;
10172 -> 10140;
10173 -> 10140;
10174 -> 10143;
10174 -> 10173;
10175 -> 10174;
10175 -> 10140;
10176 -> 10170;
10176 -> 10175;
10176 -> 10140;
10177 -> 10140;
10178 -> 10143;
10178 -> 10177;
10179 -> 10177;
10180 -> 10178;
10180 -> 10140;
10181 -> 10180;
10181 -> 10170;
10181 -> 10139;
10181 -> 10140;
10182 -> 10139;
10182 -> 10140;
10183 -> 10139;
10183 -> 10140;
10184 -> 10139;
10184 -> 10140;
10185 -> 10139;
10185 -> 10140;
10186 -> 10139;
10186 -> 10140;
10187 -> 10183;
10187 -> 10140;
10188 -> 10184;
10188 -> 10140;
10189 -> 10188;
10189 -> 10181;
10189 -> 10140;
10190 -> 10189;
10191 -> 10189;
10191 -> 10181;
10191 -> 10190;
10192 -> 0;
10192 -> 10190;
10193 -> 10192;
10193 -> 10189;
10194 -> 10183;
10194 -> 10140;
10195 -> 10140;
10196 -> 10182;
10196 -> 10195;
10197 -> 10196;
10197 -> 10181;
10197 -> 10195;
10198 -> 10197;
10198 -> 10140;
10199 -> 10140;
10200 -> 10198;
10200 -> 10199;
10201 -> 10200;
10201 -> 10181;
10201 -> 10199;
10202 -> 10140;
10203 -> 10140;
10204 -> 10182;
10204 -> 10203;
10205 -> 10204;
10205 -> 10181;
10205 -> 10203;
10206 -> 10205;
10206 -> 10140;
10207 -> 10201;
10207 -> 10181;
10207 -> 10206;
10207 -> 10140;
10208 -> 10194;
10208 -> 10140;
10209 -> 10140;
10210 -> 10208;
10210 -> 10209;
10211 -> 10209;
10212 -> 10210;
10212 -> 10211;
10213 -> 10212;
10213 -> 10206;
10213 -> 10211;
10214 -> 10213;
10214 -> 10209;
10215 -> 10209;
10216 -> 10214;
10217 -> 10216;
10218 -> 10216;
10218 -> 10217;
10219 -> 10217;
10219 -> 10216;
10220 -> 10216;
10221 -> 10216;
10222 -> 10216;
10223 -> 10216;
10224 -> 10216;
10225 -> 10216;
10226 -> 10216;
10227 -> 10216;
10228 -> 10216;
10228 -> 10214;
10229 -> 10140;
10230 -> 10228;
10230 -> 10216;
10230 -> 10229;
10230 -> 10140;
10231 -> 10228;
10231 -> 10216;
10231 -> 10184;
10231 -> 10181;
10231 -> 10140;
10232 -> 10228;
10232 -> 10140;
10233 -> 10184;
10233 -> 10140;
10234 -> 10140;
10235 -> 10233;
10235 -> 10234;
10235 -> 10181;
10235 -> 10216;
10235 -> 10140;
10236 -> 10232;
10236 -> 10235;
10236 -> 10234;
10236 -> 10216;
10236 -> 10140;
10237 -> 10236;
10237 -> 10234;
10238 -> 10236;
10238 -> 10234;
10239 -> 10237;
10239 -> 10234;
10240 -> 9146;
10240 -> 10234;
10241 -> 10238;
10241 -> 10234;
10242 -> 10234;
10243 -> 10241;
10243 -> 10242;
10244 -> 10243;
10244 -> 10236;
10244 -> 10242;
10245 -> 0;
10245 -> 10244;
10246 -> 10234;
10247 -> 10239;
10247 -> 10246;
10248 -> 10240;
10248 -> 10246;
10249 -> 10245;
10249 -> 10246;
10250 -> 10247;
10250 -> 10246;
10251 -> 10248;
10251 -> 0;
10251 -> 10246;
10252 -> 10248;
10252 -> 10246;
10253 -> 10247;
10253 -> 10252;
10254 -> 10252;
10255 -> 10253;
10255 -> 10254;
10256 -> 10255;
10256 -> 10254;
10257 -> 10254;
10258 -> 10256;
10258 -> 10257;
10259 -> 10258;
10259 -> 10257;
10260 -> 10259;
10260 -> 10254;
10261 -> 10260;
10261 -> 10254;
10262 -> 10254;
10262 -> 10252;
10263 -> 10253;
10263 -> 10262;
10263 -> 10252;
10264 -> 10247;
10264 -> 10246;
10265 -> 10264;
10265 -> 10246;
10266 -> 10247;
10266 -> 10265;
10267 -> 10265;
10268 -> 10266;
10268 -> 10267;
10269 -> 10268;
10269 -> 10267;
10270 -> 10267;
10271 -> 10269;
10271 -> 10270;
10272 -> 10271;
10272 -> 10270;
10273 -> 10272;
10273 -> 10267;
10274 -> 10273;
10274 -> 10267;
10275 -> 10267;
10275 -> 10265;
10276 -> 10248;
10276 -> 0;
10276 -> 10246;
10277 -> 10246;
10278 -> 10275;
10278 -> 10277;
10278 -> 10246;
10279 -> 10246;
10280 -> 10249;
10280 -> 10279;
10280 -> 10246;
10281 -> 10246;
10281 -> 10234;
10282 -> 10236;
10282 -> 10281;
10282 -> 10247;
10282 -> 10248;
10282 -> 10249;
10282 -> 10140;
10283 -> 10236;
10283 -> 10234;
10284 -> 10236;
10284 -> 10234;
10285 -> 10236;
10285 -> 10234;
10286 -> 10236;
10286 -> 10234;
10287 -> 10283;
10287 -> 10234;
10288 -> 10284;
10288 -> 10234;
10289 -> 10234;
10290 -> 10287;
10290 -> 10289;
10291 -> 10288;
10291 -> 10289;
10292 -> 0;
10292 -> 10289;
10293 -> 10292;
10293 -> 10282;
10293 -> 10289;
10294 -> 10290;
10294 -> 10282;
10294 -> 10291;
10294 -> 10289;
10295 -> 10289;
10296 -> 10295;
10296 -> 10290;
10296 -> 10282;
10296 -> 10289;
10297 -> 10290;
10297 -> 10295;
10297 -> 10282;
10297 -> 10293;
10297 -> 10296;
10298 -> 10291;
10298 -> 10295;
10298 -> 10282;
10298 -> 10297;
10298 -> 10296;
10299 -> 10297;
10299 -> 10296;
10300 -> 10296;
10301 -> 10299;
10301 -> 10300;
10302 -> 10298;
10302 -> 10300;
10303 -> 10302;
10303 -> 10298;
10303 -> 10301;
10303 -> 10300;
10304 -> 10297;
10304 -> 10303;
10305 -> 10298;
10305 -> 10303;
10306 -> 10293;
10306 -> 10289;
10307 -> 10234;
10308 -> 10306;
10308 -> 10307;
10309 -> 10286;
10309 -> 10307;
10310 -> 10286;
10310 -> 10307;
10311 -> 10283;
10311 -> 10234;
10312 -> 10234;
10313 -> 10311;
10313 -> 10312;
10313 -> 10282;
10313 -> 10304;
10313 -> 10234;
10314 -> 10285;
10314 -> 10313;
10314 -> 10234;
10315 -> 10236;
10315 -> 10313;
10315 -> 10308;
10315 -> 10140;
10316 -> 10194;
10316 -> 10140;
10317 -> 10140;
10318 -> 10316;
10318 -> 10317;
10319 -> 10315;
10319 -> 10317;
10320 -> 10318;
10320 -> 10317;
10321 -> 10317;
10322 -> 10317;
10323 -> 10318;
10323 -> 10322;
10324 -> 10322;
10325 -> 10324;
10325 -> 10317;
10326 -> 10317;
10327 -> 10318;
10327 -> 10326;
10328 -> 10326;
10329 -> 10328;
10329 -> 10317;
10330 -> 10317;
10331 -> 10318;
10331 -> 10330;
10332 -> 10331;
10332 -> 10330;
10333 -> 10332;
10333 -> 10317;
10334 -> 10333;
10334 -> 10317;
10335 -> 10317;
10336 -> 10334;
10336 -> 10335;
10337 -> 10319;
10337 -> 10335;
10338 -> 10335;
10339 -> 10336;
10339 -> 10338;
10340 -> 10339;
10340 -> 10335;
10341 -> 10335;
10342 -> 10336;
10342 -> 10341;
10343 -> 10342;
10343 -> 10315;
10343 -> 10341;
10344 -> 10343;
10344 -> 10335;
10345 -> 10335;
10346 -> 10344;
10346 -> 10345;
10347 -> 10337;
10347 -> 10345;
10348 -> 10346;
10348 -> 10345;
10349 -> 10345;
10350 -> 10348;
10351 -> 10335;
10352 -> 10350;
10352 -> 10351;
10352 -> 10335;
10353 -> 10336;
10353 -> 10352;
10354 -> 10317;
10355 -> 10318;
10355 -> 10354;
10356 -> 10355;
10356 -> 10315;
10356 -> 10354;
10357 -> 10354;
10358 -> 10355;
10358 -> 10315;
10358 -> 10354;
10359 -> 10358;
10359 -> 10354;
10360 -> 10358;
10360 -> 0;
10360 -> 10354;
10361 -> 10358;
10361 -> 10354;
10362 -> 10358;
10362 -> 10361;
10363 -> 10361;
10364 -> 10362;
10364 -> 10363;
10365 -> 10364;
10365 -> 10363;
10366 -> 10363;
10367 -> 10365;
10367 -> 10366;
10368 -> 10367;
10368 -> 10366;
10369 -> 10368;
10369 -> 10363;
10370 -> 10369;
10370 -> 10363;
10371 -> 10363;
10371 -> 10361;
10372 -> 10358;
10372 -> 10354;
10373 -> 10372;
10373 -> 10354;
10374 -> 10358;
10374 -> 10373;
10375 -> 10373;
10376 -> 10374;
10376 -> 10375;
10377 -> 10376;
10377 -> 10375;
10378 -> 10375;
10379 -> 10377;
10379 -> 10378;
10380 -> 10379;
10380 -> 10378;
10381 -> 10380;
10381 -> 10375;
10382 -> 10381;
10382 -> 10375;
10383 -> 10375;
10383 -> 10373;
10384 -> 10358;
10384 -> 0;
10384 -> 10354;
10385 -> 10354;
10386 -> 10383;
10386 -> 10385;
10386 -> 10354;
10387 -> 10354;
10388 -> 10358;
10388 -> 10387;
10388 -> 10354;
10389 -> 10358;
10389 -> 10317;
10390 -> 10333;
10390 -> 10317;
10391 -> 10353;
10391 -> 10317;
10392 -> 10389;
10392 -> 10358;
10392 -> 10317;
10393 -> 10317;
10394 -> 10393;
10394 -> 10389;
10394 -> 10358;
10394 -> 10317;
10395 -> 10389;
10395 -> 10393;
10395 -> 10358;
10395 -> 10394;
10396 -> 10319;
10396 -> 10394;
10397 -> 10394;
10398 -> 10396;
10398 -> 10397;
10399 -> 10395;
10399 -> 10397;
10400 -> 10399;
10400 -> 10397;
10401 -> 10398;
10401 -> 10397;
10402 -> 10397;
10403 -> 10400;
10403 -> 10402;
10404 -> 10401;
10404 -> 10402;
10405 -> 10399;
10405 -> 10395;
10405 -> 10402;
10406 -> 10404;
10406 -> 10402;
10407 -> 10402;
10408 -> 10406;
10408 -> 10407;
10409 -> 10403;
10409 -> 10407;
10410 -> 10409;
10410 -> 10395;
10410 -> 0;
10410 -> 10407;
10411 -> 10407;
10412 -> 10409;
10412 -> 10411;
10413 -> 10411;
10414 -> 10412;
10414 -> 10395;
10414 -> 10413;
10415 -> 10414;
10415 -> 10395;
10415 -> 10413;
10416 -> 10415;
10416 -> 10407;
10417 -> 10407;
10418 -> 10416;
10418 -> 10417;
10419 -> 10408;
10419 -> 10417;
10420 -> 10418;
10420 -> 10395;
10420 -> 10417;
10421 -> 10418;
10421 -> 10420;
10422 -> 10407;
10423 -> 10409;
10423 -> 10422;
10424 -> 10423;
10424 -> 10395;
10424 -> 10422;
10425 -> 10423;
10425 -> 10407;
10426 -> 10425;
10426 -> 10407;
10427 -> 10407;
10428 -> 10426;
10428 -> 10427;
10429 -> 10408;
10429 -> 10427;
10430 -> 10428;
10430 -> 10427;
10431 -> 10427;
10432 -> 10427;
10433 -> 10427;
10434 -> 10428;
10434 -> 10433;
10435 -> 0;
10435 -> 10433;
10436 -> 10435;
10436 -> 10427;
10437 -> 10428;
10437 -> 10436;
10438 -> 10436;
10439 -> 10437;
10439 -> 10438;
10440 -> 10429;
10440 -> 10438;
10441 -> 10438;
10442 -> 10441;
10442 -> 10438;
10443 -> 10439;
10443 -> 10438;
10444 -> 10441;
10444 -> 10438;
10445 -> 10440;
10445 -> 10395;
10445 -> 10443;
10445 -> 10444;
10445 -> 10442;
10445 -> 10438;
10446 -> 10445;
10447 -> 10425;
10447 -> 10407;
10448 -> 10407;
10449 -> 10447;
10449 -> 10448;
10450 -> 10448;
10451 -> 10449;
10451 -> 10450;
10451 -> 10448;
10452 -> 10448;
10453 -> 10449;
10453 -> 10452;
10454 -> 0;
10454 -> 10452;
10455 -> 10454;
10455 -> 10448;
10456 -> 10455;
10456 -> 10407;
10457 -> 10425;
10457 -> 10407;
10458 -> 10407;
10459 -> 10457;
10459 -> 10458;
10460 -> 10446;
10460 -> 10458;
10461 -> 10460;
10461 -> 10445;
10461 -> 10459;
10461 -> 10458;
10462 -> 10425;
10462 -> 10461;
10463 -> 10461;
10464 -> 10462;
10464 -> 10463;
10465 -> 10463;
10466 -> 10463;
10466 -> 10465;
10467 -> 10465;
10468 -> 10466;
10468 -> 10395;
10468 -> 10467;
10469 -> 10468;
10469 -> 10445;
10469 -> 10467;
10470 -> 10464;
10470 -> 10469;
10470 -> 10445;
10470 -> 10463;
10471 -> 10446;
10471 -> 10445;
10471 -> 0;
10471 -> 10461;
10472 -> 10446;
10472 -> 10470;
10473 -> 10472;
10473 -> 10394;
10474 -> 10394;
10475 -> 10473;
10475 -> 10474;
10476 -> 10395;
10476 -> 10474;
10477 -> 10476;
10477 -> 10395;
10477 -> 10474;
10478 -> 10475;
10478 -> 10445;
10478 -> 10474;
10479 -> 10477;
10479 -> 10478;
10479 -> 10474;
10480 -> 10391;
10480 -> 10479;
10480 -> 10394;
10481 -> 10480;
10482 -> 10472;
10482 -> 10394;
10483 -> 10392;
10483 -> 10482;
10483 -> 10445;
10483 -> 10394;
10484 -> 10481;
10484 -> 10317;
10485 -> 10353;
10485 -> 10317;
10486 -> 10392;
10486 -> 10483;
10486 -> 10317;
10487 -> 10317;
10488 -> 10485;
10488 -> 10487;
10489 -> 10486;
10489 -> 10487;
10490 -> 10487;
10491 -> 10488;
10491 -> 10490;
10492 -> 10491;
10492 -> 10483;
10492 -> 10490;
10493 -> 10490;
10494 -> 10491;
10494 -> 10483;
10494 -> 10490;
10495 -> 10494;
10495 -> 10487;
10496 -> 10487;
10497 -> 10489;
10497 -> 10486;
10497 -> 10496;
10497 -> 10487;
10498 -> 10495;
10498 -> 10483;
10498 -> 10497;
10498 -> 10487;
10499 -> 10487;
10500 -> 10488;
10500 -> 10499;
10501 -> 10500;
10501 -> 10483;
10501 -> 10499;
10502 -> 10499;
10503 -> 10500;
10503 -> 10483;
10503 -> 10499;
10504 -> 10503;
10504 -> 10487;
10505 -> 10504;
10505 -> 10483;
10505 -> 10487;
10506 -> 10489;
10506 -> 10505;
10507 -> 10505;
10508 -> 10506;
10508 -> 10507;
10509 -> 10505;
10509 -> 10507;
10510 -> 10488;
10510 -> 10507;
10511 -> 10510;
10511 -> 10507;
10512 -> 10507;
10513 -> 10510;
10513 -> 10512;
10514 -> 10513;
10514 -> 10507;
10515 -> 10507;
10516 -> 10510;
10516 -> 10515;
10517 -> 10516;
10517 -> 10507;
10518 -> 10507;
10519 -> 10508;
10519 -> 10486;
10519 -> 10507;
10520 -> 10508;
10520 -> 10507;
10521 -> 2678;
10521 -> 10507;
10522 -> 10520;
10522 -> 10521;
10522 -> 10486;
10522 -> 2677;
10522 -> 10483;
10522 -> 10507;
10523 -> 10507;
10524 -> 10507;
10525 -> 10510;
10525 -> 10524;
10526 -> 10525;
10526 -> 10522;
10526 -> 10524;
10527 -> 10526;
10527 -> 10507;
10528 -> 10509;
10528 -> 10507;
10529 -> 10507;
10530 -> 10510;
10530 -> 10529;
10531 -> 10530;
10531 -> 10522;
10531 -> 10529;
10532 -> 10529;
10533 -> 10530;
10533 -> 10522;
10533 -> 10529;
10534 -> 10533;
10534 -> 10507;
10535 -> 10508;
10535 -> 10507;
10536 -> 10507;
10537 -> 10534;
10537 -> 10536;
10538 -> 10535;
10538 -> 10536;
10539 -> 10537;
10539 -> 10522;
10539 -> 10536;
10540 -> 10538;
10540 -> 10486;
10540 -> 10539;
10540 -> 10536;
10541 -> 10536;
10542 -> 10538;
10542 -> 10486;
10542 -> 10541;
10542 -> 10536;
10543 -> 10536;
10544 -> 10543;
10544 -> 10539;
10544 -> 10536;
10545 -> 10538;
10545 -> 10543;
10545 -> 10486;
10545 -> 10522;
10545 -> 10544;
10546 -> 10544;
10547 -> 10545;
10547 -> 10546;
10548 -> 10545;
10548 -> 10546;
10549 -> 10548;
10550 -> 10508;
10550 -> 10507;
10551 -> 10509;
10551 -> 10507;
10552 -> 10507;
10553 -> 10550;
10553 -> 10552;
10554 -> 10551;
10554 -> 10552;
10555 -> 10510;
10555 -> 10552;
10556 -> 10555;
10556 -> 10552;
10557 -> 10553;
10557 -> 10552;
10558 -> 10554;
10558 -> 10552;
10559 -> 10552;
10560 -> 10552;
10561 -> 10556;
10561 -> 10560;
10562 -> 10557;
10562 -> 10560;
10563 -> 10558;
10563 -> 10560;
10564 -> 10559;
10564 -> 10560;
10565 -> 10559;
10565 -> 10560;
10566 -> 10561;
10566 -> 10545;
10566 -> 10560;
10567 -> 10561;
10567 -> 10545;
10567 -> 10560;
10568 -> 10561;
10568 -> 10545;
10568 -> 10560;
10569 -> 10560;
10570 -> 10561;
10570 -> 10545;
10570 -> 10560;
10571 -> 10560;
10572 -> 10560;
10573 -> 10562;
10573 -> 10560;
10573 -> 10486;
10573 -> 10570;
10574 -> 10565;
10574 -> 10560;
10575 -> 10565;
10575 -> 10560;
10576 -> 10560;
10577 -> 10561;
10577 -> 10576;
10577 -> 10560;
10578 -> 10565;
10578 -> 10560;
10579 -> 10565;
10579 -> 10560;
10580 -> 10565;
10580 -> 10560;
10581 -> 10565;
10581 -> 10560;
10582 -> 10560;
10583 -> 10561;
10583 -> 10582;
10584 -> 10582;
10585 -> 10583;
10585 -> 10584;
10586 -> 10584;
10587 -> 10585;
10587 -> 10586;
10588 -> 10586;
10589 -> 10587;
10589 -> 10588;
10590 -> 10589;
10590 -> 10586;
10591 -> 10590;
10591 -> 10584;
10592 -> 10591;
10592 -> 10582;
10593 -> 10592;
10593 -> 10560;
10594 -> 10561;
10594 -> 10560;
10595 -> 10560;
10596 -> 10594;
10596 -> 10595;
10597 -> 10595;
10598 -> 10596;
10598 -> 10597;
10598 -> 10595;
10599 -> 10596;
10599 -> 10595;
10600 -> 10595;
10600 -> 10560;
10601 -> 10561;
10602 -> 10601;
10602 -> 10561;
10603 -> 10561;
10604 -> 10561;
10605 -> 10565;
10605 -> 10560;
10606 -> 10560;
10607 -> 10561;
10607 -> 10606;
10608 -> 10607;
10608 -> 10573;
10608 -> 10606;
10609 -> 10608;
10609 -> 10560;
10610 -> 10560;
10611 -> 10561;
10611 -> 10610;
10612 -> 10611;
10612 -> 10573;
10612 -> 10610;
10613 -> 10612;
10613 -> 10560;
10614 -> 10560;
10615 -> 10559;
10615 -> 10507;
10616 -> 10318;
10616 -> 10317;
10617 -> 10317;
10618 -> 10616;
10618 -> 10617;
10619 -> 10615;
10619 -> 10617;
10620 -> 10617;
10621 -> 10619;
10621 -> 10620;
10622 -> 10620;
10623 -> 10622;
10623 -> 10620;
10624 -> 10623;
10624 -> 10620;
10625 -> 10621;
10625 -> 10620;
10626 -> 10620;
10627 -> 10625;
10627 -> 10626;
10628 -> 10627;
10628 -> 10563;
10628 -> 10626;
10629 -> 10628;
10629 -> 10620;
10630 -> 10620;
10631 -> 10625;
10631 -> 10630;
10632 -> 10631;
10632 -> 10566;
10632 -> 10630;
10633 -> 10632;
10633 -> 10620;
10634 -> 10620;
10635 -> 10633;
10635 -> 10634;
10636 -> 10634;
10636 -> 10620;
10637 -> 10629;
10637 -> 10636;
10637 -> 10620;
10638 -> 10620;
10639 -> 10625;
10639 -> 10638;
10640 -> 10639;
10640 -> 10638;
10641 -> 10640;
10641 -> 10566;
10641 -> 10638;
10642 -> 10641;
10642 -> 10620;
10643 -> 10620;
10644 -> 10642;
10644 -> 10643;
10645 -> 10644;
10645 -> 10573;
10645 -> 10643;
10646 -> 10620;
10647 -> 10645;
10647 -> 10646;
10648 -> 10646;
10648 -> 10620;
10649 -> 10620;
10650 -> 10637;
10650 -> 10648;
10650 -> 10620;
10651 -> 10620;
10652 -> 10620;
10652 -> 10617;
10653 -> 10619;
10653 -> 10652;
10654 -> 10202;
10654 -> 10140;
10655 -> 10653;
10655 -> 10140;
10656 -> 10139;
10656 -> 10655;
10656 -> 10573;
10656 -> 10565;
10656 -> 10564;
10656 -> 10561;
10656 -> 10563;
10656 -> 10566;
10656 -> 10562;
10656 -> 10567;
10656 -> 10486;
10656 -> 10134;
10657 -> 10656;
10657 -> 10134;
10658 -> 10134;
10659 -> 10117;
10659 -> 10134;
10660 -> 10134;
10661 -> 10657;
10661 -> 10660;
10662 -> 10658;
10662 -> 10660;
10663 -> 10659;
10663 -> 10660;
10664 -> 10663;
10664 -> 10656;
10664 -> 10660;
10665 -> 10661;
10665 -> 10134;
10666 -> 10134;
10667 -> 10117;
10667 -> 10134;
10668 -> 10134;
10669 -> 10665;
10669 -> 10668;
10670 -> 10666;
10670 -> 10668;
10671 -> 10667;
10671 -> 10668;
10672 -> 10671;
10672 -> 10664;
10672 -> 10668;
10673 -> 10672;
10673 -> 10668;
10674 -> 10672;
10674 -> 10668;
10675 -> 10674;
10675 -> 10668;
10676 -> 10674;
10676 -> 10672;
10676 -> 10668;
10677 -> 10676;
10678 -> 10677;
10678 -> 10668;
10679 -> 10668;
10680 -> 10679;
10680 -> 10668;
10681 -> 10668;
10682 -> 10669;
10682 -> 10668;
10683 -> 10668;
10684 -> 10682;
10684 -> 10683;
10685 -> 10684;
10685 -> 10668;
10686 -> 10668;
10687 -> 10685;
10687 -> 10686;
10688 -> 10686;
10688 -> 10668;
10689 -> 10669;
10689 -> 10688;
10690 -> 10681;
10690 -> 10688;
10691 -> 10688;
10692 -> 10689;
10692 -> 10691;
10693 -> 10692;
10693 -> 10688;
10694 -> 10693;
10694 -> 10688;
10695 -> 10688;
10696 -> 10694;
10696 -> 10695;
10697 -> 10690;
10697 -> 10695;
10698 -> 10696;
10698 -> 10669;
10698 -> 10695;
10699 -> 10696;
10699 -> 10669;
10699 -> 10695;
10700 -> 10695;
10701 -> 10695;
10702 -> 10696;
10702 -> 10669;
10702 -> 10701;
10702 -> 10695;
10703 -> 10696;
10703 -> 10702;
10703 -> 10669;
10704 -> 10703;
10704 -> 10702;
10705 -> 10702;
10706 -> 10704;
10706 -> 10705;
10707 -> 10697;
10707 -> 10705;
10708 -> 10705;
10709 -> 10706;
10709 -> 10708;
10710 -> 10709;
10710 -> 10703;
10710 -> 10708;
10711 -> 10709;
10711 -> 10705;
10712 -> 10711;
10712 -> 10705;
10713 -> 10705;
10714 -> 10712;
10714 -> 10713;
10715 -> 10707;
10715 -> 10713;
10716 -> 10714;
10716 -> 10713;
10717 -> 10714;
10717 -> 10713;
10718 -> 10717;
10718 -> 10705;
10719 -> 10711;
10719 -> 10705;
10720 -> 10718;
10720 -> 10705;
10721 -> 10703;
10721 -> 10702;
10722 -> 10702;
10723 -> 10721;
10723 -> 10722;
10724 -> 10720;
10724 -> 10722;
10725 -> 10724;
10725 -> 10703;
10725 -> 10722;
10726 -> 10723;
10726 -> 10703;
10726 -> 10722;
10727 -> 10725;
10727 -> 10726;
10727 -> 10722;
10728 -> 10724;
10728 -> 10703;
10728 -> 10723;
10728 -> 10722;
10729 -> 10700;
10729 -> 10727;
10729 -> 10702;
10730 -> 10720;
10730 -> 10702;
10731 -> 10699;
10731 -> 10730;
10731 -> 10703;
10731 -> 10702;
10732 -> 10729;
10732 -> 10695;
10733 -> 10699;
10733 -> 10731;
10733 -> 10732;
10734 -> 10696;
10734 -> 10732;
10735 -> 10688;
10736 -> 10689;
10736 -> 10735;
10737 -> 10736;
10737 -> 10733;
10737 -> 10735;
10738 -> 10737;
10738 -> 10688;
10739 -> 10688;
10740 -> 10738;
10740 -> 10688;
10741 -> 10738;
10741 -> 10740;
10742 -> 10741;
10742 -> 10688;
10743 -> 10738;
10743 -> 10688;
10744 -> 10693;
10744 -> 10734;
10744 -> 10688;
10745 -> 10744;
10745 -> 10742;
10745 -> 10688;
10746 -> 10688;
10747 -> 10689;
10747 -> 10746;
10748 -> 10746;
10749 -> 10748;
10749 -> 10746;
10750 -> 10749;
10750 -> 10746;
10751 -> 10747;
10751 -> 10746;
10752 -> 10746;
10753 -> 10751;
10753 -> 10752;
10754 -> 10753;
10754 -> 10733;
10754 -> 10752;
10755 -> 10754;
10755 -> 10746;
10756 -> 10746;
10757 -> 10751;
10757 -> 10756;
10758 -> 10757;
10758 -> 10733;
10758 -> 10756;
10759 -> 10758;
10759 -> 10746;
10760 -> 10746;
10761 -> 10759;
10761 -> 10760;
10762 -> 10760;
10762 -> 10746;
10763 -> 10755;
10763 -> 10762;
10763 -> 10746;
10764 -> 10746;
10765 -> 10751;
10765 -> 10764;
10766 -> 10765;
10766 -> 10764;
10767 -> 10766;
10767 -> 10733;
10767 -> 10764;
10768 -> 10767;
10768 -> 10746;
10769 -> 10746;
10770 -> 10768;
10770 -> 10769;
10771 -> 10746;
10772 -> 10770;
10772 -> 10771;
10773 -> 10771;
10773 -> 10746;
10774 -> 10746;
10775 -> 10763;
10775 -> 10773;
10775 -> 10746;
10776 -> 10746;
10777 -> 10746;
10777 -> 10688;
10778 -> 10689;
10778 -> 10134;
10779 -> 10134;
10780 -> 10134;
10781 -> 10778;
10781 -> 10780;
10782 -> 10779;
10782 -> 10780;
10783 -> 10779;
10783 -> 10780;
10784 -> 10781;
10784 -> 10780;
10785 -> 10782;
10785 -> 0;
10785 -> 10780;
10786 -> 10782;
10786 -> 10780;
10787 -> 10781;
10787 -> 10786;
10788 -> 10786;
10789 -> 10787;
10789 -> 10788;
10790 -> 10789;
10790 -> 10733;
10790 -> 10788;
10791 -> 10781;
10791 -> 10780;
10792 -> 10791;
10792 -> 10780;
10793 -> 10781;
10793 -> 10792;
10794 -> 10792;
10795 -> 10793;
10795 -> 10794;
10796 -> 10795;
10796 -> 10733;
10796 -> 10794;
10797 -> 10782;
10797 -> 0;
10797 -> 10780;
10798 -> 10780;
10799 -> 10796;
10799 -> 10798;
10799 -> 10780;
10800 -> 10780;
10801 -> 10783;
10801 -> 10800;
10801 -> 10780;
10802 -> 10780;
10802 -> 10134;
10803 -> 10117;
10803 -> 10134;
10804 -> 10111;
10804 -> 10134;
10805 -> 10134;
10806 -> 10802;
10806 -> 10805;
10807 -> 10779;
10807 -> 10805;
10808 -> 10803;
10808 -> 10805;
10809 -> 10804;
10809 -> 10805;
10810 -> 10804;
10810 -> 10805;
10811 -> 10805;
10812 -> 10806;
10812 -> 10811;
10813 -> 10812;
10813 -> 10781;
10813 -> 10811;
10814 -> 10813;
10814 -> 10805;
10815 -> 10805;
10816 -> 10809;
10816 -> 10815;
10817 -> 10815;
10818 -> 10816;
10818 -> 10817;
10819 -> 10817;
10820 -> 10818;
10820 -> 10819;
10821 -> 10819;
10822 -> 10820;
10822 -> 10821;
10823 -> 10822;
10823 -> 10819;
10824 -> 10823;
10824 -> 10817;
10825 -> 10824;
10825 -> 10815;
10826 -> 10825;
10826 -> 10805;
10827 -> 10805;
10828 -> 10809;
10828 -> 10827;
10829 -> 10827;
10830 -> 10828;
10830 -> 10829;
10831 -> 10830;
10831 -> 10733;
10831 -> 10829;
10832 -> 10829;
10833 -> 10831;
10833 -> 10832;
10834 -> 10832;
10834 -> 10829;
10835 -> 10831;
10835 -> 10827;
10836 -> 10835;
10836 -> 10805;
10837 -> 10805;
10838 -> 10809;
10838 -> 10805;
10839 -> 10805;
10840 -> 10838;
10840 -> 10839;
10841 -> 10837;
10841 -> 10839;
10842 -> 10840;
10842 -> 10839;
10843 -> 10839;
10844 -> 10840;
10844 -> 10843;
10845 -> 10843;
10845 -> 10839;
10846 -> 10839;
10847 -> 10839;
10848 -> 10840;
10848 -> 10847;
10849 -> 0;
10849 -> 10847;
10850 -> 10848;
10850 -> 10733;
10850 -> 0;
10850 -> 10847;
10851 -> 10850;
10851 -> 10839;
10852 -> 10839;
10853 -> 10840;
10853 -> 10852;
10854 -> 10853;
10854 -> 10733;
10854 -> 10852;
10855 -> 10854;
10855 -> 10839;
10856 -> 10855;
10856 -> 10839;
10857 -> 10839;
10858 -> 10857;
10858 -> 10805;
10859 -> 10808;
10859 -> 10733;
10859 -> 10805;
10860 -> 10859;
10861 -> 10859;
10862 -> 10859;
10863 -> 10859;
10863 -> 10862;
10864 -> 10862;
10864 -> 10859;
10865 -> 10859;
10866 -> 10865;
10866 -> 10859;
10867 -> 10865;
10867 -> 10859;
10868 -> 10867;
10868 -> 10859;
10869 -> 10868;
10869 -> 10859;
10870 -> 10868;
10870 -> 10859;
10871 -> 10870;
10871 -> 10859;
10872 -> 10871;
10872 -> 10859;
10873 -> 10871;
10873 -> 10859;
10874 -> 10806;
10874 -> 10865;
10875 -> 10134;
10876 -> 10874;
10876 -> 10875;
10877 -> 10876;
10877 -> 10783;
10877 -> 10875;
10878 -> 10876;
10878 -> 10134;
10879 -> 10878;
10879 -> 10134;
10880 -> 10124;
10880 -> 10879;
10880 -> 10859;
10880 -> 10865;
10880 -> 10134;
10881 -> 10880;
10882 -> 10880;
10883 -> 10882;
10883 -> 10880;
10884 -> 10880;
10885 -> 10884;
10885 -> 10880;
10886 -> 10883;
10886 -> 10885;
10886 -> 10880;
10887 -> 10880;
10888 -> 10880;
10889 -> 10888;
10889 -> 10880;
10890 -> 10882;
10890 -> 10884;
10890 -> 10880;
10891 -> 10880;
10892 -> 10890;
10892 -> 10891;
10892 -> 10880;
10893 -> 10880;
10894 -> 10893;
10894 -> 10880;
10895 -> 10890;
10895 -> 10894;
10895 -> 10880;
10896 -> 10880;
10897 -> 10880;
10898 -> 10880;
10899 -> 10880;
10900 -> 10880;
10901 -> 10900;
10901 -> 10890;
10901 -> 10880;
10902 -> 10901;
10903 -> 10901;
10903 -> 10890;
10903 -> 10902;
10904 -> 10902;
10904 -> 10901;
10905 -> 10880;
10906 -> 10905;
10906 -> 10890;
10907 -> 10906;
10907 -> 10880;
10908 -> 10880;
10909 -> 10907;
10909 -> 10908;
10910 -> 10909;
10910 -> 10890;
10910 -> 10908;
10911 -> 10880;
10912 -> 10890;
10913 -> 10890;
10913 -> 10912;
10914 -> 10912;
10914 -> 10890;
10915 -> 10890;
10916 -> 10890;
10917 -> 10890;
10918 -> 10890;
10919 -> 10890;
10920 -> 10890;
10921 -> 10890;
10922 -> 10890;
10923 -> 10880;
10924 -> 10890;
10924 -> 10923;
10924 -> 10880;
10925 -> 10890;
10925 -> 10880;
10926 -> 10890;
10926 -> 10880;
10927 -> 10880;
10927 -> 0;
10928 -> 10880;
10929 -> 10890;
10929 -> 10928;
10930 -> 10928;
10931 -> 10929;
10931 -> 10930;
10932 -> 10931;
10932 -> 10930;
10933 -> 10930;
10934 -> 10932;
10934 -> 10933;
10935 -> 10934;
10935 -> 10933;
10936 -> 10935;
10936 -> 10930;
10937 -> 10936;
10937 -> 10930;
10938 -> 10930;
10938 -> 10928;
10939 -> 10929;
10939 -> 10938;
10939 -> 10928;
10940 -> 10890;
10940 -> 10880;
10941 -> 10940;
10941 -> 10880;
10942 -> 10890;
10942 -> 10941;
10943 -> 10941;
10944 -> 10942;
10944 -> 10943;
10945 -> 10944;
10945 -> 10943;
10946 -> 10943;
10947 -> 10945;
10947 -> 10946;
10948 -> 10947;
10948 -> 10946;
10949 -> 10948;
10949 -> 10943;
10950 -> 10949;
10950 -> 10943;
10951 -> 10943;
10951 -> 10941;
10952 -> 10880;
10952 -> 0;
10953 -> 10880;
10954 -> 10951;
10954 -> 10953;
10954 -> 10880;
10955 -> 10880;
10956 -> 10890;
10956 -> 10955;
10956 -> 10880;
10957 -> 10890;
10957 -> 10880;
10958 -> 10890;
10958 -> 10880;
10959 -> 10890;
10959 -> 10880;
10960 -> 10890;
10960 -> 10880;
10961 -> 10880;
10962 -> 10880;
10962 -> 10961;
10963 -> 10961;
10964 -> 10963;
10964 -> 10880;
10965 -> 10880;
10966 -> 10880;
10966 -> 10965;
10967 -> 10965;
10968 -> 10967;
10968 -> 10880;
10969 -> 10890;
10969 -> 10880;
10970 -> 10880;
10971 -> 10970;
10971 -> 10880;
10972 -> 10890;
10972 -> 0;
10972 -> 10880;
10973 -> 10890;
10973 -> 10880;
10974 -> 10890;
10974 -> 10973;
10975 -> 10973;
10976 -> 10974;
10976 -> 10975;
10977 -> 10976;
10977 -> 10975;
10978 -> 10975;
10979 -> 10977;
10979 -> 10978;
10980 -> 10979;
10980 -> 10978;
10981 -> 10980;
10981 -> 10975;
10982 -> 10981;
10982 -> 10975;
10983 -> 10975;
10983 -> 10973;
10984 -> 10890;
10984 -> 0;
10984 -> 10880;
10985 -> 10880;
10986 -> 10890;
10986 -> 10880;
10987 -> 10890;
10988 -> 10890;
10988 -> 0;
10989 -> 10890;
10990 -> 10989;
10990 -> 10890;
10991 -> 10890;
10992 -> 10990;
10992 -> 10991;
10993 -> 10890;
10993 -> 10991;
10994 -> 10992;
10994 -> 10890;
10994 -> 10991;
10995 -> 10992;
10995 -> 10994;
10996 -> 10890;
10997 -> 10890;
10998 -> 10890;
10999 -> 10890;
11000 -> 10890;
11001 -> 10890;
11002 -> 11000;
11002 -> 11001;
11003 -> 11001;
11004 -> 11002;
11004 -> 11003;
11004 -> 11001;
11005 -> 11001;
11006 -> 11002;
11006 -> 11005;
11007 -> 0;
11007 -> 11005;
11008 -> 11007;
11008 -> 11001;
11009 -> 11008;
11009 -> 10890;
11010 -> 10989;
11010 -> 10890;
11011 -> 10890;
11012 -> 11010;
11012 -> 11011;
11013 -> 10986;
11013 -> 11012;
11013 -> 10890;
11014 -> 11013;
11015 -> 11014;
11015 -> 10880;
11016 -> 10880;
11017 -> 10890;
11017 -> 11016;
11018 -> 11017;
11018 -> 10989;
11018 -> 11016;
11019 -> 11016;
11020 -> 11017;
11020 -> 10989;
11020 -> 11016;
11021 -> 11020;
11021 -> 10880;
11022 -> 10880;
11023 -> 10989;
11023 -> 11022;
11023 -> 10880;
11024 -> 10989;
11025 -> 10989;
11026 -> 11025;
11026 -> 10989;
11027 -> 10989;
11028 -> 11027;
11028 -> 10989;
11029 -> 10989;
11030 -> 10989;
11031 -> 10989;
11032 -> 11031;
11032 -> 10989;
11033 -> 10989;
11034 -> 10989;
11035 -> 10989;
11036 -> 10989;
11037 -> 10989;
11038 -> 11037;
11039 -> 10989;
11040 -> 10989;
11041 -> 10989;
11042 -> 10989;
11043 -> 10989;
11044 -> 10989;
11045 -> 10989;
11046 -> 10989;
11047 -> 10989;
11048 -> 10989;
11049 -> 10989;
11049 -> 11048;
11050 -> 11048;
11051 -> 11049;
11051 -> 11050;
11052 -> 11050;
11053 -> 11051;
11053 -> 11052;
11054 -> 11052;
11055 -> 11053;
11055 -> 11054;
11056 -> 11055;
11056 -> 11052;
11057 -> 11056;
11057 -> 11050;
11058 -> 11057;
11058 -> 11048;
11059 -> 11058;
11059 -> 10989;
11060 -> 10989;
11061 -> 10989;
11062 -> 11060;
11062 -> 11061;
11063 -> 11061;
11064 -> 11062;
11064 -> 11063;
11064 -> 11061;
11065 -> 11062;
11065 -> 11061;
11066 -> 11061;
11066 -> 10989;
11067 -> 10989;
11068 -> 11067;
11068 -> 10989;
11069 -> 10989;
11070 -> 10989;
11071 -> 10989;
11072 -> 11071;
11072 -> 11037;
11073 -> 11072;
11073 -> 10989;
11074 -> 10989;
11075 -> 11074;
11075 -> 11037;
11076 -> 11075;
11076 -> 10989;
11077 -> 10989;
11078 -> 10880;
11079 -> 10989;
11079 -> 10880;
11080 -> 10880;
11081 -> 11080;
11081 -> 10880;
11082 -> 11081;
11082 -> 10880;
11083 -> 11079;
11083 -> 10880;
11084 -> 10880;
11085 -> 11083;
11085 -> 11084;
11086 -> 11085;
11086 -> 10989;
11086 -> 11084;
11087 -> 11086;
11087 -> 10880;
11088 -> 10880;
11089 -> 11083;
11089 -> 11088;
11090 -> 11089;
11090 -> 10989;
11090 -> 11088;
11091 -> 11090;
11091 -> 10880;
11092 -> 10880;
11093 -> 11091;
11093 -> 11092;
11094 -> 11092;
11094 -> 10880;
11095 -> 11087;
11095 -> 11094;
11095 -> 10880;
11096 -> 10880;
11097 -> 11083;
11097 -> 11096;
11098 -> 11097;
11098 -> 11096;
11099 -> 11098;
11099 -> 10989;
11099 -> 11096;
11100 -> 11099;
11100 -> 10880;
11101 -> 10880;
11102 -> 11100;
11102 -> 11101;
11103 -> 11102;
11103 -> 11037;
11103 -> 11101;
11104 -> 10880;
11105 -> 11103;
11105 -> 11104;
11106 -> 11104;
11106 -> 10880;
11107 -> 10880;
11108 -> 11095;
11108 -> 11106;
11108 -> 10880;
11109 -> 10880;
11110 -> 10911;
11110 -> 10880;
11111 -> 11037;
11111 -> 10880;
11112 -> 11037;
11112 -> 10880;
11113 -> 11112;
11113 -> 10880;
11114 -> 11112;
11114 -> 11037;
11114 -> 10880;
11115 -> 11114;
11116 -> 11115;
11116 -> 10880;
11117 -> 10880;
11118 -> 11117;
11118 -> 10880;
11119 -> 10880;
11120 -> 11037;
11120 -> 10880;
11121 -> 10880;
11122 -> 11120;
11122 -> 11121;
11123 -> 11122;
11123 -> 10880;
11124 -> 11119;
11124 -> 10880;
11125 -> 11124;
11125 -> 10880;
11126 -> 11037;
11126 -> 10880;
11127 -> 11125;
11127 -> 11037;
11128 -> 11037;
11129 -> 11037;
11130 -> 11037;
11131 -> 10880;
11132 -> 11037;
11132 -> 11131;
11133 -> 11132;
11133 -> 10880;
11134 -> 10880;
11135 -> 11133;
11135 -> 10880;
11136 -> 11133;
11136 -> 11135;
11137 -> 11136;
11137 -> 10880;
11138 -> 11133;
11138 -> 10880;
11139 -> 11037;
11139 -> 11130;
11139 -> 10880;
11140 -> 11139;
11140 -> 11137;
11140 -> 10880;
11141 -> 10880;
11142 -> 11037;
11142 -> 11141;
11143 -> 11141;
11144 -> 11143;
11144 -> 11141;
11145 -> 11144;
11145 -> 11141;
11146 -> 11142;
11146 -> 11141;
11147 -> 11141;
11148 -> 11146;
11148 -> 11147;
11149 -> 11148;
11149 -> 11037;
11149 -> 11147;
11150 -> 11149;
11150 -> 11141;
11151 -> 11141;
11152 -> 11146;
11152 -> 11151;
11153 -> 11152;
11153 -> 11037;
11153 -> 11151;
11154 -> 11153;
11154 -> 11141;
11155 -> 11141;
11156 -> 11154;
11156 -> 11155;
11157 -> 11155;
11157 -> 11141;
11158 -> 11150;
11158 -> 11157;
11158 -> 11141;
11159 -> 11141;
11160 -> 11146;
11160 -> 11159;
11161 -> 11160;
11161 -> 11159;
11162 -> 11161;
11162 -> 11037;
11162 -> 11159;
11163 -> 11162;
11163 -> 11141;
11164 -> 11141;
11165 -> 11163;
11165 -> 11164;
11166 -> 11141;
11167 -> 11165;
11167 -> 11166;
11168 -> 11166;
11168 -> 11141;
11169 -> 11141;
11170 -> 11158;
11170 -> 11168;
11170 -> 11141;
11171 -> 11141;
11172 -> 11141;
11172 -> 10880;
11173 -> 11037;
11173 -> 10880;
11174 -> 11037;
11174 -> 10928;
11175 -> 11174;
11175 -> 10930;
11176 -> 11037;
11176 -> 10880;
11177 -> 11176;
11177 -> 10880;
11178 -> 11037;
11178 -> 11177;
11179 -> 11177;
11180 -> 11178;
11180 -> 11179;
11181 -> 11180;
11181 -> 10953;
11181 -> 10880;
11182 -> 10880;
11183 -> 10880;
11184 -> 11183;
11184 -> 11037;
11185 -> 11184;
11185 -> 10880;
11186 -> 10880;
11187 -> 11182;
11187 -> 11186;
11188 -> 11186;
11189 -> 11187;
11189 -> 11188;
11190 -> 11188;
11191 -> 11189;
11191 -> 11190;
11192 -> 11190;
11193 -> 11191;
11193 -> 11192;
11194 -> 11193;
11194 -> 11190;
11195 -> 11194;
11195 -> 11188;
11196 -> 11195;
11196 -> 11186;
11197 -> 11196;
11197 -> 10880;
11198 -> 10880;
11199 -> 11182;
11199 -> 11198;
11200 -> 11198;
11201 -> 11199;
11201 -> 11200;
11202 -> 11201;
11202 -> 11037;
11202 -> 11200;
11203 -> 11200;
11204 -> 11202;
11204 -> 11203;
11205 -> 11203;
11205 -> 11200;
11206 -> 11202;
11206 -> 11198;
11207 -> 11206;
11207 -> 10880;
11208 -> 10880;
11209 -> 11182;
11209 -> 10880;
11210 -> 10880;
11211 -> 11209;
11211 -> 11210;
11212 -> 11208;
11212 -> 11210;
11213 -> 11211;
11213 -> 11210;
11214 -> 11210;
11215 -> 11211;
11215 -> 11214;
11216 -> 11214;
11216 -> 11210;
11217 -> 11210;
11218 -> 11210;
11219 -> 11211;
11219 -> 11218;
11220 -> 0;
11220 -> 11218;
11221 -> 11219;
11221 -> 11037;
11221 -> 0;
11221 -> 11218;
11222 -> 11221;
11222 -> 11210;
11223 -> 11210;
11224 -> 11211;
11224 -> 11223;
11225 -> 11224;
11225 -> 11037;
11225 -> 11223;
11226 -> 11225;
11226 -> 11210;
11227 -> 11226;
11227 -> 11210;
11228 -> 11210;
11229 -> 11228;
11229 -> 10880;
11230 -> 11037;
11231 -> 11037;
11232 -> 11037;
11233 -> 11231;
11233 -> 10880;
11234 -> 11231;
11235 -> 11231;
11236 -> 11235;
11236 -> 11231;
11237 -> 11235;
11237 -> 11231;
11238 -> 11237;
11239 -> 11238;
11239 -> 11231;
11240 -> 11231;
11241 -> 11240;
11241 -> 11231;
11242 -> 11231;
11243 -> 11231;
11244 -> 11242;
11244 -> 11231;
11245 -> 11231;
11246 -> 0;
11246 -> 11231;
11247 -> 11244;
11247 -> 11231;
11248 -> 11246;
11248 -> 0;
11248 -> 11231;
11249 -> 11246;
11249 -> 11248;
11250 -> 11231;
11251 -> 11250;
11251 -> 11231;
11252 -> 11231;
11253 -> 11251;
11253 -> 11231;
11254 -> 11251;
11254 -> 11253;
11255 -> 11254;
11255 -> 11231;
11256 -> 11251;
11256 -> 11231;
11257 -> 11246;
11257 -> 11249;
11257 -> 11231;
11258 -> 11257;
11258 -> 11255;
11258 -> 11231;
11259 -> 11231;
11260 -> 11231;
11260 -> 11259;
11261 -> 11259;
11262 -> 11261;
11262 -> 11259;
11263 -> 11262;
11263 -> 11259;
11264 -> 11260;
11264 -> 11259;
11265 -> 11259;
11266 -> 11264;
11266 -> 11265;
11267 -> 11265;
11268 -> 11267;
11268 -> 11259;
11269 -> 11259;
11270 -> 11264;
11270 -> 11269;
11271 -> 11270;
11271 -> 11259;
11272 -> 11259;
11273 -> 11271;
11273 -> 11272;
11274 -> 11272;
11274 -> 11259;
11275 -> 11268;
11275 -> 11274;
11275 -> 11259;
11276 -> 11259;
11277 -> 11264;
11277 -> 11276;
11278 -> 11277;
11278 -> 11259;
11279 -> 11259;
11280 -> 11278;
11280 -> 11279;
11281 -> 11259;
11282 -> 11280;
11282 -> 11281;
11283 -> 11281;
11283 -> 11259;
11284 -> 11259;
11285 -> 11275;
11285 -> 11283;
11285 -> 11259;
11286 -> 11259;
11287 -> 11259;
11287 -> 11231;
11288 -> 11231;
11289 -> 11231;
11289 -> 0;
11290 -> 11231;
11291 -> 11231;
11291 -> 11290;
11292 -> 11290;
11293 -> 11291;
11293 -> 11292;
11294 -> 11231;
11295 -> 11294;
11295 -> 11231;
11296 -> 11231;
11296 -> 11295;
11297 -> 11295;
11298 -> 11296;
11298 -> 11297;
11299 -> 11231;
11299 -> 0;
11300 -> 11231;
11301 -> 11298;
11301 -> 11300;
11301 -> 11231;
11302 -> 11231;
11303 -> 11231;
11304 -> 11231;
11305 -> 11304;
11305 -> 11231;
11306 -> 11231;
11307 -> 11303;
11307 -> 11306;
11308 -> 11306;
11309 -> 11307;
11309 -> 11308;
11310 -> 11308;
11311 -> 11309;
11311 -> 11310;
11312 -> 11310;
11313 -> 11311;
11313 -> 11312;
11314 -> 11313;
11314 -> 11310;
11315 -> 11314;
11315 -> 11308;
11316 -> 11315;
11316 -> 11306;
11317 -> 11316;
11317 -> 11231;
11318 -> 11231;
11319 -> 11303;
11319 -> 11318;
11320 -> 11318;
11321 -> 11319;
11321 -> 11320;
11322 -> 11320;
11323 -> 11321;
11323 -> 11322;
11324 -> 11322;
11324 -> 11320;
11325 -> 11321;
11325 -> 11318;
11326 -> 11325;
11326 -> 11231;
11327 -> 11231;
11328 -> 11303;
11328 -> 11231;
11329 -> 11231;
11330 -> 11328;
11330 -> 11329;
11331 -> 11327;
11331 -> 11329;
11332 -> 11330;
11332 -> 11329;
11333 -> 11329;
11334 -> 11330;
11334 -> 11333;
11335 -> 11333;
11335 -> 11329;
11336 -> 11329;
11337 -> 11329;
11338 -> 11330;
11338 -> 11337;
11339 -> 0;
11339 -> 11337;
11340 -> 11338;
11340 -> 11329;
11341 -> 11329;
11342 -> 11330;
11342 -> 11341;
11343 -> 11342;
11343 -> 11329;
11344 -> 11343;
11344 -> 11329;
11345 -> 11329;
11346 -> 11345;
11346 -> 11231;
11347 -> 11231;
11348 -> 11231;
11349 -> 11231;
11350 -> 10124;
11350 -> 11231;
11350 -> 10123;
11351 -> 11350;
11351 -> 10108;
11352 -> 10108;
11353 -> 10107;
11353 -> 11351;
11353 -> 10105;
11354 -> 11353;
11354 -> 10102;
11355 -> 10102;
11356 -> 10103;
11356 -> 11355;
11357 -> 11356;
11357 -> 11351;
11357 -> 11355;
11358 -> 11357;
11358 -> 10102;
11359 -> 11354;
11359 -> 10102;
11360 -> 10103;
11360 -> 10102;
11361 -> 10102;
11362 -> 11361;
11363 -> 11359;
11363 -> 11362;
11363 -> 11361;
11364 -> 11361;
11365 -> 11359;
11365 -> 11364;
11365 -> 11361;
11366 -> 11361;
11367 -> 11359;
11367 -> 11366;
11368 -> 11366;
11369 -> 11367;
11369 -> 11368;
11370 -> 11368;
11371 -> 11369;
11371 -> 11370;
11372 -> 11370;
11373 -> 11371;
11373 -> 11372;
11374 -> 11373;
11374 -> 11370;
11375 -> 11374;
11375 -> 11368;
11376 -> 11375;
11376 -> 11366;
11377 -> 11376;
11377 -> 11361;
11378 -> 11361;
11379 -> 11359;
11379 -> 11378;
11380 -> 11378;
11381 -> 11379;
11381 -> 11380;
11382 -> 11380;
11383 -> 11381;
11383 -> 11382;
11384 -> 11380;
11385 -> 11383;
11385 -> 11384;
11386 -> 11384;
11386 -> 11380;
11387 -> 11386;
11387 -> 11378;
11388 -> 11379;
11388 -> 11378;
11389 -> 11388;
11389 -> 11359;
11389 -> 11378;
11390 -> 11389;
11390 -> 11361;
11391 -> 11361;
11392 -> 11359;
11392 -> 11391;
11392 -> 11361;
11393 -> 11359;
11394 -> 11359;
11395 -> 11393;
11395 -> 11394;
11396 -> 11394;
11397 -> 11394;
11397 -> 11396;
11398 -> 11396;
11398 -> 11394;
11399 -> 11394;
11400 -> 11394;
11401 -> 11394;
11402 -> 11394;
11403 -> 11402;
11403 -> 11394;
11404 -> 11394;
11405 -> 11402;
11405 -> 11404;
11405 -> 11394;
11406 -> 11394;
11407 -> 11406;
11407 -> 11394;
11408 -> 11402;
11408 -> 11407;
11408 -> 11394;
11409 -> 11394;
11410 -> 11394;
11410 -> 11402;
11411 -> 11394;
11411 -> 11402;
11412 -> 11402;
11413 -> 11402;
11414 -> 11413;
11415 -> 11413;
11415 -> 11402;
11415 -> 11414;
11416 -> 11414;
11416 -> 11413;
11417 -> 11402;
11418 -> 11417;
11418 -> 11402;
11419 -> 11402;
11420 -> 11418;
11420 -> 11419;
11421 -> 11420;
11421 -> 11402;
11421 -> 11419;
11422 -> 11402;
11423 -> 11402;
11424 -> 11402;
11425 -> 11402;
11426 -> 11402;
11427 -> 11402;
11427 -> 0;
11428 -> 11402;
11429 -> 11402;
11429 -> 11428;
11430 -> 11428;
11431 -> 11429;
11431 -> 11430;
11432 -> 11431;
11432 -> 11430;
11433 -> 11430;
11434 -> 11432;
11434 -> 11433;
11435 -> 11434;
11435 -> 11433;
11436 -> 11435;
11436 -> 11430;
11437 -> 11436;
11437 -> 11430;
11438 -> 11430;
11438 -> 11428;
11439 -> 11402;
11440 -> 11439;
11440 -> 11402;
11441 -> 11402;
11441 -> 11440;
11442 -> 11440;
11443 -> 11441;
11443 -> 11442;
11444 -> 11443;
11444 -> 11442;
11445 -> 11442;
11446 -> 11444;
11446 -> 11445;
11447 -> 11446;
11447 -> 11445;
11448 -> 11447;
11448 -> 11442;
11449 -> 11448;
11449 -> 11442;
11450 -> 11442;
11450 -> 11440;
11451 -> 11402;
11451 -> 0;
11452 -> 11402;
11453 -> 11450;
11453 -> 11452;
11453 -> 11402;
11454 -> 11402;
11455 -> 11402;
11456 -> 11402;
11457 -> 11402;
11458 -> 11402;
11459 -> 11402;
11460 -> 11402;
11460 -> 11459;
11461 -> 11459;
11462 -> 11461;
11462 -> 11402;
11463 -> 11402;
11464 -> 11402;
11464 -> 11463;
11465 -> 11463;
11466 -> 11465;
11466 -> 11402;
11467 -> 11402;
11468 -> 11402;
11469 -> 11468;
11469 -> 11402;
11470 -> 11402;
11471 -> 11402;
11472 -> 11402;
11472 -> 0;
11473 -> 11402;
11474 -> 11402;
11475 -> 11473;
11475 -> 11474;
11476 -> 11402;
11476 -> 11474;
11477 -> 11475;
11477 -> 11402;
11477 -> 11474;
11478 -> 11475;
11478 -> 11477;
11479 -> 11402;
11480 -> 11402;
11481 -> 11402;
11482 -> 11402;
11483 -> 11402;
11484 -> 11402;
11485 -> 11483;
11485 -> 11484;
11486 -> 11484;
11487 -> 11485;
11487 -> 11486;
11487 -> 11484;
11488 -> 11484;
11489 -> 11485;
11489 -> 11488;
11490 -> 0;
11490 -> 11488;
11491 -> 11490;
11491 -> 11484;
11492 -> 11491;
11492 -> 11402;
11493 -> 11402;
11494 -> 11402;
11495 -> 11493;
11495 -> 11494;
11496 -> 11470;
11496 -> 11495;
11496 -> 11402;
11497 -> 11496;
11498 -> 11497;
11498 -> 11402;
11499 -> 11402;
11500 -> 11499;
11501 -> 11499;
11501 -> 11402;
11502 -> 11402;
11503 -> 11499;
11504 -> 11499;
11505 -> 11504;
11505 -> 11499;
11506 -> 11499;
11507 -> 11506;
11507 -> 11499;
11508 -> 11499;
11509 -> 11499;
11509 -> 11402;
11510 -> 11499;
11511 -> 11510;
11511 -> 11499;
11512 -> 11499;
11513 -> 11499;
11513 -> 11402;
11514 -> 11499;
11515 -> 11499;
11516 -> 11499;
11517 -> 11499;
11518 -> 11499;
11519 -> 11499;
11520 -> 11499;
11521 -> 11499;
11522 -> 11499;
11523 -> 11499;
11524 -> 11499;
11525 -> 11499;
11526 -> 11499;
11526 -> 11525;
11527 -> 11525;
11528 -> 11526;
11528 -> 11527;
11529 -> 11527;
11530 -> 11528;
11530 -> 11529;
11531 -> 11529;
11532 -> 11530;
11532 -> 11531;
11533 -> 11532;
11533 -> 11529;
11534 -> 11533;
11534 -> 11527;
11535 -> 11534;
11535 -> 11525;
11536 -> 11535;
11536 -> 11499;
11537 -> 11499;
11538 -> 11499;
11539 -> 11537;
11539 -> 11538;
11540 -> 11538;
11541 -> 11539;
11541 -> 11540;
11541 -> 11538;
11542 -> 11539;
11542 -> 11538;
11543 -> 11538;
11543 -> 11499;
11544 -> 11499;
11545 -> 11544;
11545 -> 11499;
11546 -> 11499;
11547 -> 11499;
11548 -> 11499;
11549 -> 11548;
11549 -> 11499;
11550 -> 11499;
11551 -> 11550;
11551 -> 11499;
11552 -> 11499;
11553 -> 11499;
11553 -> 11402;
11554 -> 11499;
11554 -> 11402;
11555 -> 11402;
11556 -> 11555;
11556 -> 11402;
11557 -> 11556;
11557 -> 11402;
11558 -> 11554;
11558 -> 11402;
11559 -> 11402;
11560 -> 11558;
11560 -> 11559;
11561 -> 11560;
11561 -> 11499;
11561 -> 11559;
11562 -> 11561;
11562 -> 11402;
11563 -> 11402;
11564 -> 11558;
11564 -> 11563;
11565 -> 11564;
11565 -> 11499;
11565 -> 11563;
11566 -> 11565;
11566 -> 11402;
11567 -> 11402;
11568 -> 11566;
11568 -> 11567;
11569 -> 11567;
11569 -> 11402;
11570 -> 11562;
11570 -> 11569;
11570 -> 11402;
11571 -> 11402;
11572 -> 11558;
11572 -> 11571;
11573 -> 11572;
11573 -> 11571;
11574 -> 11573;
11574 -> 11499;
11574 -> 11571;
11575 -> 11574;
11575 -> 11402;
11576 -> 11402;
11577 -> 11575;
11577 -> 11576;
11578 -> 11402;
11579 -> 11577;
11579 -> 11578;
11580 -> 11578;
11580 -> 11402;
11581 -> 11402;
11582 -> 11570;
11582 -> 11580;
11582 -> 11402;
11583 -> 11402;
11584 -> 11422;
11584 -> 11402;
11585 -> 11499;
11585 -> 11394;
11586 -> 11499;
11586 -> 11394;
11587 -> 11586;
11587 -> 11394;
11588 -> 11586;
11588 -> 11499;
11588 -> 11394;
11589 -> 11588;
11590 -> 11589;
11590 -> 11394;
11591 -> 11394;
11592 -> 11591;
11592 -> 11394;
11593 -> 11394;
11594 -> 11499;
11594 -> 11394;
11595 -> 11394;
11596 -> 11594;
11596 -> 11595;
11597 -> 11596;
11597 -> 11394;
11598 -> 11593;
11598 -> 11394;
11599 -> 11598;
11599 -> 11394;
11600 -> 11499;
11600 -> 11394;
11601 -> 11599;
11601 -> 11499;
11602 -> 11499;
11603 -> 11499;
11604 -> 11499;
11605 -> 11394;
11606 -> 11499;
11606 -> 11605;
11607 -> 11606;
11607 -> 11394;
11608 -> 11394;
11609 -> 11607;
11609 -> 11394;
11610 -> 11607;
11610 -> 11609;
11611 -> 11610;
11611 -> 11394;
11612 -> 11607;
11612 -> 11394;
11613 -> 11499;
11613 -> 11604;
11613 -> 11394;
11614 -> 11613;
11614 -> 11611;
11614 -> 11394;
11615 -> 11394;
11616 -> 11499;
11616 -> 11615;
11617 -> 11615;
11618 -> 11617;
11618 -> 11615;
11619 -> 11618;
11619 -> 11615;
11620 -> 11616;
11620 -> 11615;
11621 -> 11615;
11622 -> 11620;
11622 -> 11621;
11623 -> 11622;
11623 -> 11499;
11623 -> 11621;
11624 -> 11623;
11624 -> 11615;
11625 -> 11615;
11626 -> 11620;
11626 -> 11625;
11627 -> 11626;
11627 -> 11499;
11627 -> 11625;
11628 -> 11627;
11628 -> 11615;
11629 -> 11615;
11630 -> 11628;
11630 -> 11629;
11631 -> 11629;
11631 -> 11615;
11632 -> 11624;
11632 -> 11631;
11632 -> 11615;
11633 -> 11615;
11634 -> 11620;
11634 -> 11633;
11635 -> 11634;
11635 -> 11633;
11636 -> 11635;
11636 -> 11499;
11636 -> 11633;
11637 -> 11636;
11637 -> 11615;
11638 -> 11615;
11639 -> 11637;
11639 -> 11638;
11640 -> 11615;
11641 -> 11639;
11641 -> 11640;
11642 -> 11640;
11642 -> 11615;
11643 -> 11615;
11644 -> 11632;
11644 -> 11642;
11644 -> 11615;
11645 -> 11615;
11646 -> 11615;
11646 -> 11394;
11647 -> 11499;
11647 -> 11394;
11648 -> 11402;
11648 -> 0;
11648 -> 11394;
11649 -> 11402;
11649 -> 11394;
11650 -> 11499;
11650 -> 11649;
11651 -> 11649;
11652 -> 11650;
11652 -> 11651;
11653 -> 11499;
11653 -> 11402;
11654 -> 11653;
11654 -> 11402;
11655 -> 11499;
11655 -> 11654;
11656 -> 11654;
11657 -> 11655;
11657 -> 11656;
11658 -> 11499;
11658 -> 0;
11658 -> 11402;
11659 -> 11657;
11659 -> 11452;
11659 -> 11402;
11660 -> 11499;
11660 -> 11454;
11660 -> 11402;
11661 -> 11394;
11662 -> 11394;
11663 -> 11499;
11663 -> 11662;
11664 -> 11663;
11664 -> 11394;
11665 -> 11394;
11666 -> 11661;
11666 -> 11665;
11667 -> 11665;
11668 -> 11666;
11668 -> 11667;
11669 -> 11667;
11670 -> 11668;
11670 -> 11669;
11671 -> 11669;
11672 -> 11670;
11672 -> 11671;
11673 -> 11672;
11673 -> 11669;
11674 -> 11673;
11674 -> 11667;
11675 -> 11674;
11675 -> 11665;
11676 -> 11675;
11676 -> 11394;
11677 -> 11394;
11678 -> 11661;
11678 -> 11677;
11679 -> 11677;
11680 -> 11678;
11680 -> 11679;
11681 -> 11680;
11681 -> 11499;
11681 -> 11679;
11682 -> 11679;
11683 -> 11681;
11683 -> 11682;
11684 -> 11682;
11684 -> 11679;
11685 -> 11681;
11685 -> 11677;
11686 -> 11685;
11686 -> 11394;
11687 -> 11394;
11688 -> 11661;
11688 -> 11394;
11689 -> 11394;
11690 -> 11688;
11690 -> 11689;
11691 -> 11687;
11691 -> 11689;
11692 -> 11690;
11692 -> 11689;
11693 -> 11689;
11694 -> 11690;
11694 -> 11693;
11695 -> 11693;
11695 -> 11689;
11696 -> 11689;
11697 -> 11689;
11698 -> 11690;
11698 -> 11697;
11699 -> 0;
11699 -> 11697;
11700 -> 11698;
11700 -> 11499;
11700 -> 0;
11700 -> 11697;
11701 -> 11700;
11701 -> 11689;
11702 -> 11689;
11703 -> 11690;
11703 -> 11702;
11704 -> 11703;
11704 -> 11499;
11704 -> 11702;
11705 -> 11704;
11705 -> 11689;
11706 -> 11705;
11706 -> 11689;
11707 -> 11689;
11708 -> 11707;
11708 -> 11394;
11709 -> 11499;
11710 -> 11499;
11711 -> 11499;
11712 -> 11499;
11712 -> 11711;
11713 -> 11711;
11713 -> 11499;
11714 -> 11499;
11715 -> 11499;
11716 -> 11715;
11716 -> 11499;
11717 -> 11716;
11717 -> 11499;
11718 -> 11716;
11718 -> 11499;
11719 -> 11718;
11719 -> 11499;
11720 -> 11719;
11720 -> 11499;
11721 -> 11719;
11721 -> 11499;
11722 -> 11499;
11722 -> 11402;
11723 -> 11499;
11724 -> 11499;
11725 -> 11724;
11725 -> 11499;
11726 -> 11724;
11726 -> 11499;
11727 -> 11726;
11728 -> 11727;
11728 -> 11499;
11729 -> 11499;
11730 -> 11729;
11730 -> 11499;
11731 -> 11499;
11732 -> 11499;
11733 -> 11731;
11733 -> 11499;
11734 -> 11499;
11735 -> 0;
11735 -> 11499;
11736 -> 11733;
11736 -> 11499;
11737 -> 11735;
11737 -> 0;
11737 -> 11499;
11738 -> 11735;
11738 -> 11737;
11739 -> 11499;
11740 -> 11739;
11740 -> 11499;
11741 -> 11499;
11742 -> 11740;
11742 -> 11499;
11743 -> 11740;
11743 -> 11742;
11744 -> 11743;
11744 -> 11499;
11745 -> 11740;
11745 -> 11499;
11746 -> 11735;
11746 -> 11738;
11746 -> 11499;
11747 -> 11746;
11747 -> 11744;
11747 -> 11499;
11748 -> 11499;
11749 -> 11499;
11749 -> 11748;
11750 -> 11748;
11751 -> 11750;
11751 -> 11748;
11752 -> 11751;
11752 -> 11748;
11753 -> 11749;
11753 -> 11748;
11754 -> 11748;
11755 -> 11753;
11755 -> 11754;
11756 -> 11754;
11757 -> 11756;
11757 -> 11748;
11758 -> 11748;
11759 -> 11753;
11759 -> 11758;
11760 -> 11759;
11760 -> 11748;
11761 -> 11748;
11762 -> 11760;
11762 -> 11761;
11763 -> 11761;
11763 -> 11748;
11764 -> 11757;
11764 -> 11763;
11764 -> 11748;
11765 -> 11748;
11766 -> 11753;
11766 -> 11765;
11767 -> 11766;
11767 -> 11748;
11768 -> 11748;
11769 -> 11767;
11769 -> 11768;
11770 -> 11748;
11771 -> 11769;
11771 -> 11770;
11772 -> 11770;
11772 -> 11748;
11773 -> 11748;
11774 -> 11764;
11774 -> 11772;
11774 -> 11748;
11775 -> 11748;
11776 -> 11748;
11776 -> 11499;
11777 -> 11499;
11778 -> 11499;
11778 -> 0;
11779 -> 11499;
11780 -> 11499;
11780 -> 11779;
11781 -> 11779;
11782 -> 11780;
11782 -> 11781;
11783 -> 11499;
11784 -> 11783;
11784 -> 11499;
11785 -> 11499;
11785 -> 11784;
11786 -> 11784;
11787 -> 11785;
11787 -> 11786;
11788 -> 11499;
11788 -> 0;
11789 -> 11499;
11790 -> 11787;
11790 -> 11789;
11790 -> 11499;
11791 -> 11499;
11792 -> 11499;
11793 -> 11499;
11794 -> 11793;
11794 -> 11499;
11795 -> 11499;
11796 -> 11792;
11796 -> 11795;
11797 -> 11795;
11798 -> 11796;
11798 -> 11797;
11799 -> 11797;
11800 -> 11798;
11800 -> 11799;
11801 -> 11799;
11802 -> 11800;
11802 -> 11801;
11803 -> 11802;
11803 -> 11799;
11804 -> 11803;
11804 -> 11797;
11805 -> 11804;
11805 -> 11795;
11806 -> 11805;
11806 -> 11499;
11807 -> 11499;
11808 -> 11792;
11808 -> 11807;
11809 -> 11807;
11810 -> 11808;
11810 -> 11809;
11811 -> 11809;
11812 -> 11810;
11812 -> 11811;
11813 -> 11811;
11813 -> 11809;
11814 -> 11810;
11814 -> 11807;
11815 -> 11814;
11815 -> 11499;
11816 -> 11499;
11817 -> 11792;
11817 -> 11499;
11818 -> 11499;
11819 -> 11817;
11819 -> 11818;
11820 -> 11816;
11820 -> 11818;
11821 -> 11819;
11821 -> 11818;
11822 -> 11818;
11823 -> 11819;
11823 -> 11822;
11824 -> 11822;
11824 -> 11818;
11825 -> 11818;
11826 -> 11818;
11827 -> 11819;
11827 -> 11826;
11828 -> 0;
11828 -> 11826;
11829 -> 11827;
11829 -> 11818;
11830 -> 11818;
11831 -> 11819;
11831 -> 11830;
11832 -> 11831;
11832 -> 11818;
11833 -> 11832;
11833 -> 11818;
11834 -> 11818;
11835 -> 11834;
11835 -> 11499;
11836 -> 11499;
11837 -> 11499;
11837 -> 11359;
11838 -> 11837;
11839 -> 11390;
11839 -> 11837;
11840 -> 11361;
11840 -> 11837;
11841 -> 11837;
11842 -> 11838;
11842 -> 11841;
11843 -> 11839;
11843 -> 11841;
11844 -> 11840;
11844 -> 11841;
11845 -> 11841;
11846 -> 11842;
11846 -> 11845;
11846 -> 11841;
11847 -> 11842;
11848 -> 11842;
11849 -> 11842;
11849 -> 11848;
11850 -> 11848;
11850 -> 11842;
11851 -> 11842;
11852 -> 11842;
11853 -> 11842;
11854 -> 11853;
11854 -> 11842;
11855 -> 11853;
11855 -> 11842;
11856 -> 11855;
11857 -> 11856;
11857 -> 11842;
11858 -> 11842;
11859 -> 11858;
11859 -> 11842;
11860 -> 11842;
11861 -> 11842;
11862 -> 11860;
11862 -> 11842;
11863 -> 11842;
11864 -> 0;
11864 -> 11842;
11865 -> 11862;
11865 -> 11842;
11866 -> 11864;
11866 -> 0;
11866 -> 11842;
11867 -> 11864;
11867 -> 11866;
11868 -> 11842;
11869 -> 11868;
11869 -> 11842;
11870 -> 11842;
11871 -> 11869;
11871 -> 11842;
11872 -> 11869;
11872 -> 11871;
11873 -> 11872;
11873 -> 11842;
11874 -> 11869;
11874 -> 11842;
11875 -> 11864;
11875 -> 11867;
11875 -> 11842;
11876 -> 11875;
11876 -> 11873;
11876 -> 11842;
11877 -> 11842;
11878 -> 11842;
11878 -> 11877;
11879 -> 11877;
11880 -> 11879;
11880 -> 11877;
11881 -> 11880;
11881 -> 11877;
11882 -> 11878;
11882 -> 11877;
11883 -> 11877;
11884 -> 11882;
11884 -> 11883;
11885 -> 11883;
11886 -> 11885;
11886 -> 11877;
11887 -> 11877;
11888 -> 11882;
11888 -> 11887;
11889 -> 11888;
11889 -> 11877;
11890 -> 11877;
11891 -> 11889;
11891 -> 11890;
11892 -> 11890;
11892 -> 11877;
11893 -> 11886;
11893 -> 11892;
11893 -> 11877;
11894 -> 11877;
11895 -> 11882;
11895 -> 11894;
11896 -> 11895;
11896 -> 11877;
11897 -> 11877;
11898 -> 11896;
11898 -> 11897;
11899 -> 11877;
11900 -> 11898;
11900 -> 11899;
11901 -> 11899;
11901 -> 11877;
11902 -> 11877;
11903 -> 11893;
11903 -> 11901;
11903 -> 11877;
11904 -> 11877;
11905 -> 11877;
11905 -> 11842;
11906 -> 11842;
11907 -> 11842;
11907 -> 0;
11908 -> 11842;
11909 -> 11842;
11909 -> 11908;
11910 -> 11908;
11911 -> 11909;
11911 -> 11910;
11912 -> 11842;
11913 -> 11912;
11913 -> 11842;
11914 -> 11842;
11914 -> 11913;
11915 -> 11913;
11916 -> 11914;
11916 -> 11915;
11917 -> 11842;
11917 -> 0;
11918 -> 11842;
11919 -> 11916;
11919 -> 11918;
11919 -> 11842;
11920 -> 11842;
11921 -> 11842;
11922 -> 11842;
11923 -> 11922;
11923 -> 11842;
11924 -> 11842;
11925 -> 11921;
11925 -> 11924;
11926 -> 11924;
11927 -> 11925;
11927 -> 11926;
11928 -> 11926;
11929 -> 11927;
11929 -> 11928;
11930 -> 11928;
11931 -> 11929;
11931 -> 11930;
11932 -> 11931;
11932 -> 11928;
11933 -> 11932;
11933 -> 11926;
11934 -> 11933;
11934 -> 11924;
11935 -> 11934;
11935 -> 11842;
11936 -> 11842;
11937 -> 11921;
11937 -> 11936;
11938 -> 11936;
11939 -> 11937;
11939 -> 11938;
11940 -> 11938;
11941 -> 11939;
11941 -> 11940;
11942 -> 11940;
11942 -> 11938;
11943 -> 11939;
11943 -> 11936;
11944 -> 11943;
11944 -> 11842;
11945 -> 11842;
11946 -> 11921;
11946 -> 11842;
11947 -> 11842;
11948 -> 11946;
11948 -> 11947;
11949 -> 11945;
11949 -> 11947;
11950 -> 11948;
11950 -> 11947;
11951 -> 11947;
11952 -> 11948;
11952 -> 11951;
11953 -> 11951;
11953 -> 11947;
11954 -> 11947;
11955 -> 11947;
11956 -> 11948;
11956 -> 11955;
11957 -> 0;
11957 -> 11955;
11958 -> 11956;
11958 -> 11947;
11959 -> 11947;
11960 -> 11948;
11960 -> 11959;
11961 -> 11960;
11961 -> 11947;
11962 -> 11961;
11962 -> 11947;
11963 -> 11947;
11964 -> 11963;
11964 -> 11842;
11965 -> 11842;
11966 -> 11842;
11967 -> 11842;
11968 -> 11842;
11969 -> 11968;
11969 -> 11842;
11970 -> 11969;
11970 -> 11842;
11971 -> 11969;
11971 -> 11842;
11972 -> 11971;
11972 -> 11842;
11973 -> 11972;
11973 -> 11842;
11974 -> 11972;
11974 -> 11842;
11975 -> 11842;
11976 -> 11842;
11977 -> 8794;
11977 -> 11842;
11978 -> 11844;
11979 -> 11843;
11979 -> 11978;
11979 -> 11844;
11980 -> 11390;
11980 -> 11977;
11981 -> 11977;
11982 -> 11977;
11983 -> 11977;
11984 -> 11982;
11984 -> 11977;
11985 -> 11977;
11986 -> 11977;
11987 -> 11984;
11987 -> 11986;
11988 -> 11985;
11988 -> 11986;
11989 -> 11983;
11989 -> 11986;
11990 -> 11987;
11990 -> 11986;
11991 -> 11990;
11991 -> 11986;
11992 -> 11990;
11992 -> 11986;
11993 -> 11988;
11993 -> 11986;
11994 -> 11986;
11995 -> 11992;
11995 -> 11994;
11996 -> 11993;
11996 -> 11994;
11997 -> 11989;
11997 -> 11994;
11998 -> 11995;
11998 -> 11994;
11999 -> 11998;
11999 -> 11994;
12000 -> 11996;
12000 -> 11999;
12001 -> 11999;
12002 -> 12000;
12002 -> 12001;
12003 -> 11997;
12003 -> 12001;
12004 -> 12001;
12004 -> 12003;
12005 -> 12004;
12006 -> 11359;
12007 -> 11390;
12007 -> 12006;
12007 -> 11359;
12008 -> 12005;
12008 -> 11361;
12009 -> 11383;
12009 -> 12008;
12009 -> 11382;
12010 -> 12009;
12010 -> 11384;
12011 -> 11388;
12011 -> 12008;
12011 -> 11378;
12012 -> 12011;
12012 -> 11361;
12013 -> 12008;
12014 -> 12008;
12015 -> 12008;
12016 -> 12012;
12016 -> 12015;
12016 -> 12008;
12017 -> 11359;
12017 -> 11378;
12018 -> 11378;
12019 -> 12018;
12019 -> 11361;
12020 -> 12019;
12020 -> 12015;
12020 -> 12008;
12021 -> 12008;
12021 -> 10100;
12022 -> 10100;
12023 -> 10099;
12023 -> 12021;
12023 -> 10097;
12024 -> 10084;
12025 -> 12023;
12025 -> 12024;
12026 -> 10093;
12026 -> 12024;
12027 -> 12024;
12028 -> 12024;
12029 -> 12028;
12029 -> 12025;
12029 -> 12021;
12029 -> 12024;
12030 -> 12025;
12030 -> 12028;
12030 -> 12021;
12030 -> 12029;
12031 -> 12030;
12031 -> 12029;
12032 -> 12029;
12033 -> 12031;
12033 -> 12032;
12034 -> 12026;
12034 -> 12032;
12035 -> 12032;
12036 -> 12033;
12036 -> 12035;
12037 -> 12036;
12037 -> 12030;
12037 -> 12035;
12038 -> 12037;
12038 -> 12032;
12039 -> 12032;
12040 -> 12033;
12040 -> 12039;
12041 -> 12039;
12042 -> 12041;
12042 -> 12032;
12043 -> 12034;
12043 -> 12032;
12044 -> 12032;
12045 -> 12033;
12045 -> 12044;
12046 -> 12045;
12046 -> 12032;
12047 -> 12033;
12047 -> 12032;
12048 -> 12034;
12048 -> 12033;
12049 -> 12033;
12050 -> 12033;
12050 -> 0;
12051 -> 12033;
12052 -> 12033;
12053 -> 12051;
12053 -> 12052;
12054 -> 12048;
12054 -> 12052;
12055 -> 12053;
12055 -> 12033;
12055 -> 12052;
12056 -> 12053;
12056 -> 12055;
12057 -> 12033;
12058 -> 12033;
12059 -> 12033;
12060 -> 12033;
12061 -> 12033;
12062 -> 12033;
12063 -> 12061;
12063 -> 12062;
12064 -> 12062;
12065 -> 12063;
12065 -> 12064;
12065 -> 12062;
12066 -> 12062;
12067 -> 12063;
12067 -> 12066;
12068 -> 0;
12068 -> 12066;
12069 -> 12068;
12069 -> 12062;
12070 -> 12069;
12070 -> 12033;
12071 -> 12048;
12071 -> 12033;
12072 -> 12033;
12073 -> 12071;
12073 -> 12072;
12074 -> 12047;
12074 -> 12073;
12074 -> 12033;
12075 -> 12074;
12076 -> 12075;
12076 -> 12032;
12077 -> 12032;
12078 -> 12048;
12078 -> 12032;
12079 -> 12032;
12080 -> 12048;
12080 -> 12079;
12080 -> 12032;
12081 -> 12048;
12082 -> 12048;
12083 -> 12082;
12083 -> 12048;
12084 -> 12048;
12085 -> 12084;
12085 -> 12048;
12086 -> 12048;
12087 -> 12048;
12088 -> 12048;
12089 -> 12088;
12089 -> 12048;
12090 -> 12048;
12091 -> 12048;
12092 -> 12048;
12093 -> 12048;
12094 -> 12048;
12095 -> 12048;
12096 -> 12048;
12097 -> 12048;
12098 -> 12048;
12099 -> 12048;
12100 -> 12048;
12101 -> 12048;
12102 -> 12048;
12103 -> 12048;
12104 -> 12048;
12105 -> 12048;
12105 -> 12104;
12106 -> 12104;
12107 -> 12105;
12107 -> 12106;
12108 -> 12106;
12109 -> 12107;
12109 -> 12108;
12110 -> 12108;
12111 -> 12109;
12111 -> 12110;
12112 -> 12111;
12112 -> 12108;
12113 -> 12112;
12113 -> 12106;
12114 -> 12113;
12114 -> 12104;
12115 -> 12114;
12115 -> 12048;
12116 -> 12048;
12117 -> 12048;
12118 -> 12116;
12118 -> 12117;
12119 -> 12117;
12120 -> 12118;
12120 -> 12119;
12120 -> 12117;
12121 -> 12118;
12121 -> 12117;
12122 -> 12117;
12122 -> 12048;
12123 -> 12048;
12124 -> 12123;
12124 -> 12048;
12125 -> 12048;
12126 -> 12048;
12127 -> 12048;
12128 -> 12127;
12128 -> 12048;
12129 -> 12048;
12130 -> 12129;
12130 -> 12048;
12131 -> 12048;
12132 -> 12033;
12132 -> 12032;
12133 -> 12048;
12133 -> 12032;
12134 -> 12032;
12135 -> 12134;
12135 -> 12032;
12136 -> 12135;
12136 -> 12032;
12137 -> 12133;
12137 -> 12032;
12138 -> 12032;
12139 -> 12137;
12139 -> 12138;
12140 -> 12139;
12140 -> 12048;
12140 -> 12138;
12141 -> 12140;
12141 -> 12032;
12142 -> 12032;
12143 -> 12137;
12143 -> 12142;
12144 -> 12143;
12144 -> 12048;
12144 -> 12142;
12145 -> 12144;
12145 -> 12032;
12146 -> 12032;
12147 -> 12145;
12147 -> 12146;
12148 -> 12146;
12148 -> 12032;
12149 -> 12141;
12149 -> 12148;
12149 -> 12032;
12150 -> 12032;
12151 -> 12137;
12151 -> 12150;
12152 -> 12151;
12152 -> 12150;
12153 -> 12152;
12153 -> 12048;
12153 -> 12150;
12154 -> 12153;
12154 -> 12032;
12155 -> 12032;
12156 -> 12154;
12156 -> 12155;
12157 -> 12032;
12158 -> 12156;
12158 -> 12157;
12159 -> 12157;
12159 -> 12032;
12160 -> 12032;
12161 -> 12149;
12161 -> 12159;
12161 -> 12032;
12162 -> 12032;
12163 -> 12048;
12163 -> 12029;
12164 -> 12030;
12164 -> 12029;
12165 -> 12163;
12166 -> 12027;
12166 -> 12165;
12166 -> 12163;
12167 -> 12025;
12167 -> 12048;
12167 -> 12166;
12168 -> 12166;
12169 -> 12029;
12170 -> 12167;
12170 -> 12169;
12170 -> 12029;
12171 -> 12048;
12171 -> 12028;
12171 -> 12167;
12171 -> 12170;
12172 -> 12048;
12173 -> 12048;
12173 -> 12172;
12174 -> 12173;
12174 -> 12048;
12174 -> 12172;
12175 -> 12174;
12175 -> 12048;
12176 -> 12048;
12177 -> 12048;
12177 -> 12176;
12178 -> 12176;
12179 -> 12178;
12179 -> 12048;
12180 -> 12048;
12181 -> 12048;
12182 -> 12181;
12182 -> 12048;
12183 -> 12048;
12184 -> 12048;
12185 -> 12048;
12185 -> 0;
12186 -> 12048;
12187 -> 12048;
12188 -> 12186;
12188 -> 12187;
12189 -> 12048;
12189 -> 12187;
12190 -> 12188;
12190 -> 12048;
12190 -> 12187;
12191 -> 12188;
12191 -> 12190;
12192 -> 12048;
12193 -> 12048;
12194 -> 12048;
12195 -> 12048;
12196 -> 12048;
12197 -> 12048;
12198 -> 12196;
12198 -> 12197;
12199 -> 12197;
12200 -> 12198;
12200 -> 12199;
12200 -> 12197;
12201 -> 12197;
12202 -> 12198;
12202 -> 12201;
12203 -> 0;
12203 -> 12201;
12204 -> 12203;
12204 -> 12197;
12205 -> 12204;
12205 -> 12048;
12206 -> 12048;
12207 -> 12048;
12208 -> 12206;
12208 -> 12207;
12209 -> 12183;
12209 -> 12208;
12209 -> 12048;
12210 -> 12209;
12211 -> 12210;
12211 -> 12048;
12212 -> 12048;
12213 -> 12094;
12213 -> 12048;
12214 -> 12094;
12214 -> 12048;
12214 -> 12093;
12215 -> 12127;
12215 -> 12094;
12216 -> 12215;
12216 -> 12048;
12217 -> 12129;
12217 -> 12094;
12218 -> 12217;
12218 -> 12048;
12219 -> 12048;
12220 -> 12048;
12221 -> 12048;
12222 -> 12221;
12222 -> 12048;
12223 -> 12222;
12223 -> 12048;
12224 -> 12220;
12224 -> 12048;
12225 -> 12048;
12226 -> 12224;
12226 -> 12225;
12227 -> 12226;
12227 -> 12048;
12227 -> 12225;
12228 -> 12227;
12228 -> 12048;
12229 -> 12048;
12230 -> 12224;
12230 -> 12229;
12231 -> 12230;
12231 -> 12094;
12231 -> 12229;
12232 -> 12231;
12232 -> 12048;
12233 -> 12048;
12234 -> 12232;
12234 -> 12233;
12235 -> 12233;
12235 -> 12048;
12236 -> 12228;
12236 -> 12235;
12236 -> 12048;
12237 -> 12048;
12238 -> 12224;
12238 -> 12237;
12239 -> 12238;
12239 -> 12237;
12240 -> 12239;
12240 -> 12094;
12240 -> 12237;
12241 -> 12240;
12241 -> 12048;
12242 -> 12048;
12243 -> 12241;
12243 -> 12242;
12244 -> 12048;
12245 -> 12243;
12245 -> 12244;
12246 -> 12244;
12246 -> 12048;
12247 -> 12048;
12248 -> 12236;
12248 -> 12246;
12248 -> 12048;
12249 -> 12048;
12250 -> 12048;
12251 -> 12250;
12252 -> 12048;
12253 -> 12167;
12253 -> 12252;
12253 -> 12048;
12254 -> 12048;
12254 -> 12029;
12254 -> 12167;
12254 -> 12253;
12255 -> 12094;
12256 -> 12094;
12256 -> 12255;
12257 -> 12255;
12258 -> 12257;
12258 -> 12094;
12259 -> 12094;
12260 -> 12094;
12260 -> 12259;
12261 -> 12259;
12262 -> 12261;
12262 -> 12094;
12263 -> 12094;
12264 -> 12094;
12265 -> 12264;
12265 -> 12094;
12266 -> 12094;
12267 -> 0;
12267 -> 12094;
12268 -> 12094;
12269 -> 12268;
12269 -> 12094;
12270 -> 12267;
12270 -> 12269;
12271 -> 12094;
12271 -> 12269;
12272 -> 12271;
12272 -> 12094;
12273 -> 12094;
12274 -> 12094;
12275 -> 12167;
12275 -> 12274;
12275 -> 12094;
12276 -> 12271;
12276 -> 12048;
12276 -> 12167;
12276 -> 12275;
12277 -> 12024;
12278 -> 12167;
12278 -> 12277;
12278 -> 12024;
12279 -> 12278;
12279 -> 12024;
12280 -> 12279;
12280 -> 12167;
12280 -> 12171;
12280 -> 12254;
12280 -> 12276;
12280 -> 12048;
12280 -> 12094;
12281 -> 12280;
12281 -> 10079;
12282 -> 10079;
12283 -> 12281;
12283 -> 12280;
12283 -> 12282;
12283 -> 10079;
12284 -> 12281;
12284 -> 12283;
12284 -> 12280;
12285 -> 12284;
12285 -> 12283;
12286 -> 9760;
12286 -> 12283;
12287 -> 9761;
12287 -> 12283;
12288 -> 12283;
12289 -> 12285;
12289 -> 12288;
12290 -> 12286;
12290 -> 12288;
12291 -> 12287;
12291 -> 12288;
12292 -> 12289;
12292 -> 12288;
12293 -> 12289;
12294 -> 12289;
12295 -> 12289;
12296 -> 12295;
12296 -> 12289;
12297 -> 12289;
12298 -> 12291;
12298 -> 12297;
12298 -> 9743;
12298 -> 12289;
12299 -> 12283;
12300 -> 12298;
12300 -> 12288;
12301 -> 12298;
12302 -> 12298;
12303 -> 12298;
12304 -> 12298;
12305 -> 12304;
12305 -> 12298;
12306 -> 12298;
12307 -> 12306;
12307 -> 12298;
12308 -> 12298;
12308 -> 12305;
12309 -> 12298;
12309 -> 12307;
12310 -> 12308;
12310 -> 12298;
12311 -> 12308;
12311 -> 12309;
12311 -> 12298;
12312 -> 0;
12312 -> 12298;
12313 -> 12298;
12314 -> 12305;
12314 -> 12298;
12315 -> 12307;
12315 -> 12298;
12316 -> 12298;
12317 -> 12298;
12318 -> 12314;
12318 -> 12317;
12319 -> 12315;
12319 -> 12317;
12320 -> 12316;
12320 -> 12317;
12321 -> 12318;
12321 -> 12317;
12322 -> 12319;
12322 -> 12317;
12323 -> 12320;
12323 -> 12317;
12324 -> 12317;
12325 -> 12322;
12325 -> 12324;
12326 -> 12323;
12326 -> 12324;
12327 -> 12318;
12327 -> 12324;
12328 -> 12325;
12328 -> 12327;
12328 -> 12324;
12329 -> 12298;
12330 -> 12298;
12331 -> 12330;
12331 -> 12298;
12332 -> 12298;
12333 -> 12298;
12334 -> 12333;
12334 -> 12298;
12335 -> 12298;
12336 -> 12298;
12337 -> 12336;
12337 -> 12298;
12338 -> 12298;
12339 -> 12334;
12339 -> 12298;
12340 -> 12298;
12341 -> 12298;
12341 -> 12340;
12342 -> 12341;
12342 -> 12298;
12342 -> 12340;
12343 -> 12342;
12343 -> 12298;
12344 -> 12298;
12345 -> 12298;
12345 -> 12344;
12346 -> 12344;
12347 -> 12346;
12347 -> 12298;
12348 -> 12343;
12348 -> 12347;
12348 -> 12298;
12349 -> 12334;
12349 -> 12337;
12349 -> 12298;
12350 -> 0;
12350 -> 12298;
12351 -> 12329;
12351 -> 12350;
12351 -> 12298;
12352 -> 12298;
12353 -> 12349;
12353 -> 12351;
12353 -> 12298;
12354 -> 12298;
12355 -> 12298;
12356 -> 12298;
12356 -> 0;
12357 -> 12298;
12358 -> 12298;
12358 -> 12357;
12359 -> 12357;
12360 -> 12358;
12360 -> 12359;
12361 -> 12360;
12361 -> 12359;
12362 -> 12359;
12363 -> 12361;
12363 -> 12362;
12364 -> 12363;
12364 -> 12362;
12365 -> 12364;
12365 -> 12359;
12366 -> 12365;
12366 -> 12359;
12367 -> 12359;
12367 -> 12357;
12368 -> 12298;
12369 -> 12368;
12369 -> 12298;
12370 -> 12298;
12370 -> 12369;
12371 -> 12369;
12372 -> 12370;
12372 -> 12371;
12373 -> 12372;
12373 -> 12371;
12374 -> 12371;
12375 -> 12373;
12375 -> 12374;
12376 -> 12375;
12376 -> 12374;
12377 -> 12376;
12377 -> 12371;
12378 -> 12377;
12378 -> 12371;
12379 -> 12371;
12379 -> 12369;
12380 -> 12298;
12380 -> 0;
12381 -> 12298;
12382 -> 12379;
12382 -> 12381;
12382 -> 12298;
12383 -> 12298;
12384 -> 12298;
12385 -> 12298;
12386 -> 12329;
12386 -> 12298;
12387 -> 12298;
12388 -> 12385;
12388 -> 12387;
12389 -> 12386;
12389 -> 12387;
12390 -> 12298;
12390 -> 12387;
12391 -> 12388;
12391 -> 12387;
12392 -> 12387;
12393 -> 12391;
12393 -> 12392;
12394 -> 12390;
12394 -> 12392;
12395 -> 12394;
12395 -> 12393;
12395 -> 12392;
12396 -> 12387;
12397 -> 12390;
12397 -> 12396;
12398 -> 12397;
12398 -> 12387;
12399 -> 12398;
12400 -> 12388;
12400 -> 12399;
12401 -> 12400;
12401 -> 12398;
12402 -> 12388;
12402 -> 12398;
12403 -> 12389;
12403 -> 12398;
12404 -> 12398;
12405 -> 12402;
12405 -> 12404;
12406 -> 12403;
12406 -> 12404;
12407 -> 12390;
12407 -> 12404;
12408 -> 12407;
12408 -> 12404;
12409 -> 12405;
12409 -> 12404;
12410 -> 12406;
12410 -> 12404;
12411 -> 12404;
12412 -> 12408;
12412 -> 12411;
12413 -> 12409;
12413 -> 12411;
12414 -> 12410;
12414 -> 12411;
12415 -> 12407;
12415 -> 12298;
12415 -> 12411;
12416 -> 12413;
12416 -> 12411;
12417 -> 12414;
12417 -> 12411;
12418 -> 12411;
12419 -> 12416;
12419 -> 12418;
12420 -> 12417;
12420 -> 12418;
12421 -> 12412;
12421 -> 12418;
12422 -> 12418;
12423 -> 12421;
12423 -> 12422;
12424 -> 12423;
12424 -> 12298;
12424 -> 12422;
12425 -> 12423;
12425 -> 12418;
12426 -> 12418;
12427 -> 12419;
12427 -> 12426;
12428 -> 12427;
12428 -> 12298;
12428 -> 12426;
12429 -> 12427;
12429 -> 12418;
12430 -> 12420;
12430 -> 12418;
12431 -> 12418;
12432 -> 12429;
12432 -> 12431;
12433 -> 12430;
12433 -> 12431;
12434 -> 12425;
12434 -> 12431;
12435 -> 12432;
12435 -> 12431;
12436 -> 12433;
12436 -> 12431;
12437 -> 12431;
12438 -> 12435;
12438 -> 12437;
12439 -> 12436;
12439 -> 12437;
12440 -> 12434;
12440 -> 12437;
12441 -> 12440;
12441 -> 12437;
12442 -> 12438;
12442 -> 12437;
12443 -> 12441;
12443 -> 12442;
12443 -> 12437;
12444 -> 12437;
12445 -> 12438;
12445 -> 12444;
12445 -> 12437;
12446 -> 12445;
12447 -> 12401;
12447 -> 12446;
12447 -> 12398;
12448 -> 12447;
12449 -> 12448;
12450 -> 12298;
12451 -> 12304;
12451 -> 12450;
12452 -> 12451;
12452 -> 12304;
12452 -> 12450;
12453 -> 12298;
12454 -> 12451;
12454 -> 12453;
12455 -> 12454;
12455 -> 12453;
12456 -> 12455;
12456 -> 12453;
12457 -> 12298;
12458 -> 12456;
12458 -> 12457;
12459 -> 12298;
12459 -> 12457;
12460 -> 12304;
12460 -> 12457;
12461 -> 12458;
12461 -> 12457;
12462 -> 12459;
12462 -> 12457;
12463 -> 12457;
12464 -> 12461;
12464 -> 12463;
12465 -> 12462;
12465 -> 12463;
12466 -> 12460;
12466 -> 12463;
12467 -> 12466;
12467 -> 12463;
12468 -> 12464;
12468 -> 12463;
12469 -> 12467;
12469 -> 12468;
12469 -> 12463;
12470 -> 12463;
12471 -> 12464;
12471 -> 12470;
12471 -> 12463;
12472 -> 12471;
12473 -> 12472;
12474 -> 12330;
12474 -> 12304;
12474 -> 12298;
12475 -> 12333;
12475 -> 12474;
12475 -> 12298;
12476 -> 12475;
12476 -> 12474;
12477 -> 12475;
12478 -> 12475;
12479 -> 12475;
12480 -> 12298;
12481 -> 12475;
12481 -> 12480;
12481 -> 12298;
12482 -> 12475;
12483 -> 12475;
12484 -> 12475;
12484 -> 12483;
12485 -> 12484;
12485 -> 12475;
12485 -> 12483;
12486 -> 12485;
12487 -> 12475;
12488 -> 12482;
12488 -> 12475;
12489 -> 12475;
12490 -> 12475;
12491 -> 12490;
12491 -> 12475;
12492 -> 12475;
12493 -> 12475;
12494 -> 12475;
12495 -> 12475;
12495 -> 12494;
12496 -> 12494;
12497 -> 12495;
12497 -> 12496;
12498 -> 12496;
12499 -> 12497;
12499 -> 12498;
12500 -> 12498;
12501 -> 12499;
12501 -> 12500;
12502 -> 12501;
12502 -> 12498;
12503 -> 12502;
12503 -> 12496;
12504 -> 12503;
12504 -> 12494;
12505 -> 12504;
12505 -> 12475;
12506 -> 12475;
12507 -> 12475;
12507 -> 12506;
12508 -> 12506;
12509 -> 12508;
12509 -> 12475;
12510 -> 12475;
12511 -> 12490;
12512 -> 12475;
12513 -> 12509;
12513 -> 12512;
12513 -> 12475;
12514 -> 12482;
12515 -> 12482;
12515 -> 12514;
12516 -> 12514;
12517 -> 12516;
12517 -> 12482;
12518 -> 12482;
12519 -> 12482;
12519 -> 12518;
12520 -> 12518;
12521 -> 12520;
12521 -> 12482;
12522 -> 12482;
12523 -> 12482;
12524 -> 12523;
12524 -> 12482;
12525 -> 12482;
12526 -> 0;
12526 -> 12482;
12527 -> 12526;
12527 -> 12482;
12528 -> 12482;
12529 -> 12482;
12530 -> 12482;
12531 -> 12482;
12532 -> 12529;
12532 -> 12482;
12533 -> 12532;
12533 -> 12482;
12534 -> 12530;
12534 -> 12533;
12535 -> 12531;
12535 -> 12482;
12535 -> 12533;
12536 -> 12533;
12537 -> 12534;
12537 -> 12536;
12538 -> 12535;
12538 -> 12536;
12539 -> 12537;
12539 -> 12536;
12540 -> 12538;
12540 -> 12536;
12541 -> 12540;
12541 -> 12537;
12542 -> 12537;
12542 -> 12288;
12543 -> 12537;
12544 -> 12537;
12545 -> 12537;
12546 -> 12537;
12547 -> 12537;
12548 -> 12547;
12548 -> 12537;
12549 -> 12537;
12549 -> 12546;
12550 -> 12537;
12550 -> 12548;
12551 -> 12549;
12551 -> 12537;
12552 -> 12549;
12552 -> 12550;
12552 -> 12537;
12553 -> 0;
12553 -> 12537;
12554 -> 12537;
12555 -> 12546;
12555 -> 12537;
12556 -> 12548;
12556 -> 12537;
12557 -> 12537;
12558 -> 12537;
12559 -> 12555;
12559 -> 12558;
12560 -> 12556;
12560 -> 12558;
12561 -> 12557;
12561 -> 12558;
12562 -> 12559;
12562 -> 12558;
12563 -> 12560;
12563 -> 12558;
12564 -> 12561;
12564 -> 12558;
12565 -> 12558;
12566 -> 12563;
12566 -> 12565;
12567 -> 12564;
12567 -> 12565;
12568 -> 12559;
12568 -> 12565;
12569 -> 12566;
12569 -> 12568;
12569 -> 12565;
12570 -> 12537;
12571 -> 12537;
12572 -> 12537;
12573 -> 12537;
12574 -> 12573;
12574 -> 12537;
12575 -> 12537;
12576 -> 12572;
12576 -> 12537;
12577 -> 12537;
12578 -> 12537;
12578 -> 12577;
12579 -> 12578;
12579 -> 12537;
12579 -> 12577;
12580 -> 12579;
12580 -> 12537;
12581 -> 12537;
12582 -> 12537;
12582 -> 12581;
12583 -> 12581;
12584 -> 12583;
12584 -> 12537;
12585 -> 12580;
12585 -> 12584;
12585 -> 12537;
12586 -> 12572;
12586 -> 12574;
12586 -> 12537;
12587 -> 0;
12587 -> 12537;
12588 -> 12570;
12588 -> 12587;
12588 -> 12537;
12589 -> 12537;
12590 -> 12586;
12590 -> 12588;
12590 -> 12537;
12591 -> 12537;
12592 -> 12537;
12593 -> 12537;
12593 -> 0;
12594 -> 12537;
12595 -> 12537;
12595 -> 12594;
12596 -> 12594;
12597 -> 12595;
12597 -> 12596;
12598 -> 12597;
12598 -> 12596;
12599 -> 12596;
12600 -> 12598;
12600 -> 12599;
12601 -> 12600;
12601 -> 12599;
12602 -> 12601;
12602 -> 12596;
12603 -> 12602;
12603 -> 12596;
12604 -> 12596;
12604 -> 12594;
12605 -> 12537;
12606 -> 12605;
12606 -> 12537;
12607 -> 12537;
12607 -> 12606;
12608 -> 12606;
12609 -> 12607;
12609 -> 12608;
12610 -> 12609;
12610 -> 12608;
12611 -> 12608;
12612 -> 12610;
12612 -> 12611;
12613 -> 12612;
12613 -> 12611;
12614 -> 12613;
12614 -> 12608;
12615 -> 12614;
12615 -> 12608;
12616 -> 12608;
12616 -> 12606;
12617 -> 12537;
12617 -> 0;
12618 -> 12537;
12619 -> 12616;
12619 -> 12618;
12619 -> 12537;
12620 -> 12537;
12621 -> 12537;
12622 -> 12537;
12623 -> 12570;
12623 -> 12537;
12624 -> 12537;
12625 -> 12622;
12625 -> 12624;
12626 -> 12623;
12626 -> 12624;
12627 -> 12537;
12627 -> 12624;
12628 -> 12625;
12628 -> 12624;
12629 -> 12624;
12630 -> 12628;
12630 -> 12629;
12631 -> 12627;
12631 -> 12629;
12632 -> 12631;
12632 -> 12630;
12632 -> 12629;
12633 -> 12624;
12634 -> 12627;
12634 -> 12633;
12635 -> 12634;
12635 -> 12624;
12636 -> 12635;
12637 -> 12625;
12637 -> 12636;
12638 -> 12637;
12638 -> 12635;
12639 -> 12625;
12639 -> 12635;
12640 -> 12626;
12640 -> 12635;
12641 -> 12635;
12642 -> 12639;
12642 -> 12641;
12643 -> 12640;
12643 -> 12641;
12644 -> 12627;
12644 -> 12641;
12645 -> 12644;
12645 -> 12641;
12646 -> 12642;
12646 -> 12641;
12647 -> 12643;
12647 -> 12641;
12648 -> 12641;
12649 -> 12645;
12649 -> 12648;
12650 -> 12646;
12650 -> 12648;
12651 -> 12647;
12651 -> 12648;
12652 -> 12644;
12652 -> 12537;
12652 -> 12648;
12653 -> 12650;
12653 -> 12648;
12654 -> 12651;
12654 -> 12648;
12655 -> 12648;
12656 -> 12653;
12656 -> 12655;
12657 -> 12654;
12657 -> 12655;
12658 -> 12649;
12658 -> 12655;
12659 -> 12655;
12660 -> 12658;
12660 -> 12659;
12661 -> 12660;
12661 -> 12537;
12661 -> 12659;
12662 -> 12660;
12662 -> 12655;
12663 -> 12655;
12664 -> 12656;
12664 -> 12663;
12665 -> 12664;
12665 -> 12537;
12665 -> 12663;
12666 -> 12664;
12666 -> 12655;
12667 -> 12657;
12667 -> 12655;
12668 -> 12655;
12669 -> 12666;
12669 -> 12668;
12670 -> 12667;
12670 -> 12668;
12671 -> 12662;
12671 -> 12668;
12672 -> 12669;
12672 -> 12668;
12673 -> 12670;
12673 -> 12668;
12674 -> 12668;
12675 -> 12672;
12675 -> 12674;
12676 -> 12673;
12676 -> 12674;
12677 -> 12671;
12677 -> 12674;
12678 -> 12677;
12678 -> 12674;
12679 -> 12675;
12679 -> 12674;
12680 -> 12678;
12680 -> 12679;
12680 -> 12674;
12681 -> 12674;
12682 -> 12675;
12682 -> 12681;
12682 -> 12674;
12683 -> 12682;
12684 -> 12638;
12684 -> 12683;
12684 -> 12635;
12685 -> 12684;
12686 -> 12685;
12687 -> 12537;
12688 -> 12687;
12688 -> 12537;
12689 -> 12537;
12690 -> 12687;
12690 -> 12689;
12691 -> 12690;
12691 -> 12689;
12692 -> 12691;
12692 -> 12689;
12693 -> 12537;
12694 -> 12692;
12694 -> 12693;
12695 -> 12537;
12695 -> 12693;
12696 -> 12537;
12696 -> 12693;
12697 -> 12694;
12697 -> 12693;
12698 -> 12695;
12698 -> 12693;
12699 -> 12693;
12700 -> 12697;
12700 -> 12699;
12701 -> 12698;
12701 -> 12699;
12702 -> 12696;
12702 -> 12699;
12703 -> 12702;
12703 -> 12699;
12704 -> 12700;
12704 -> 12699;
12705 -> 12703;
12705 -> 12704;
12705 -> 12699;
12706 -> 12699;
12707 -> 12700;
12707 -> 12706;
12707 -> 12699;
12708 -> 12707;
12709 -> 12708;
12710 -> 12547;
12711 -> 12547;
12712 -> 12547;
12713 -> 12537;
12714 -> 12547;
12714 -> 12713;
12714 -> 12537;
12715 -> 12547;
12716 -> 12547;
12716 -> 12715;
12717 -> 12716;
12717 -> 12547;
12717 -> 12715;
12718 -> 12717;
12719 -> 12547;
12720 -> 12547;
12721 -> 12547;
12722 -> 12547;
12723 -> 12722;
12723 -> 12547;
12724 -> 12547;
12725 -> 12547;
12726 -> 12547;
12727 -> 12547;
12727 -> 12726;
12728 -> 12726;
12729 -> 12727;
12729 -> 12728;
12730 -> 12728;
12731 -> 12729;
12731 -> 12730;
12732 -> 12730;
12733 -> 12731;
12733 -> 12732;
12734 -> 12733;
12734 -> 12730;
12735 -> 12734;
12735 -> 12728;
12736 -> 12735;
12736 -> 12726;
12737 -> 12736;
12737 -> 12547;
12738 -> 12547;
12739 -> 12738;
12740 -> 12738;
12740 -> 12739;
12741 -> 12739;
12742 -> 12740;
12742 -> 12741;
12743 -> 12742;
12743 -> 12739;
12744 -> 12739;
12744 -> 12738;
12745 -> 12738;
12746 -> 12745;
12746 -> 12547;
12746 -> 12738;
12747 -> 12746;
12747 -> 12547;
12748 -> 12547;
12749 -> 12722;
12750 -> 12747;
12750 -> 12722;
12751 -> 12722;
12752 -> 12722;
12753 -> 12750;
12753 -> 12752;
12753 -> 12722;
12754 -> 12547;
12755 -> 12747;
12755 -> 12754;
12755 -> 12547;
12756 -> 12722;
12757 -> 12722;
12758 -> 12722;
12759 -> 12722;
12759 -> 12758;
12760 -> 12758;
12761 -> 12759;
12761 -> 12760;
12762 -> 12760;
12763 -> 12761;
12763 -> 12762;
12764 -> 12762;
12765 -> 12763;
12765 -> 12764;
12766 -> 12765;
12766 -> 12762;
12767 -> 12766;
12767 -> 12760;
12768 -> 12767;
12768 -> 12758;
12769 -> 12768;
12769 -> 12722;
12770 -> 12722;
12771 -> 12722;
12771 -> 12770;
12772 -> 12770;
12773 -> 12772;
12773 -> 12722;
12774 -> 12773;
12774 -> 12752;
12774 -> 12722;
12775 -> 12722;
12776 -> 12722;
12776 -> 12775;
12777 -> 12776;
12777 -> 12722;
12777 -> 12775;
12778 -> 12777;
12778 -> 12722;
12779 -> 12722;
12780 -> 12722;
12780 -> 12779;
12781 -> 12779;
12782 -> 12781;
12782 -> 12722;
12783 -> 12722;
12784 -> 12722;
12785 -> 12784;
12785 -> 12722;
12786 -> 12722;
12787 -> 12722;
12787 -> 0;
12788 -> 12722;
12789 -> 12722;
12790 -> 12788;
12790 -> 12789;
12791 -> 12722;
12791 -> 12789;
12792 -> 12790;
12792 -> 12722;
12792 -> 12789;
12793 -> 12790;
12793 -> 12792;
12794 -> 12722;
12795 -> 12722;
12796 -> 12722;
12797 -> 12722;
12798 -> 12722;
12799 -> 12722;
12800 -> 12798;
12800 -> 12799;
12801 -> 12799;
12802 -> 12800;
12802 -> 12801;
12802 -> 12799;
12803 -> 12799;
12804 -> 12800;
12804 -> 12803;
12805 -> 0;
12805 -> 12803;
12806 -> 12805;
12806 -> 12799;
12807 -> 12806;
12807 -> 12722;
12808 -> 12722;
12809 -> 12722;
12810 -> 12808;
12810 -> 12809;
12811 -> 12810;
12812 -> 12722;
12813 -> 12722;
12814 -> 12722;
12815 -> 12722;
12816 -> 12815;
12816 -> 12722;
12817 -> 12722;
12818 -> 12817;
12818 -> 12722;
12819 -> 12722;
12820 -> 12722;
12821 -> 12722;
12822 -> 12821;
12822 -> 12722;
12823 -> 12722;
12824 -> 12722;
12825 -> 12722;
12826 -> 12722;
12827 -> 12722;
12828 -> 12722;
12829 -> 12722;
12830 -> 12722;
12831 -> 12722;
12832 -> 12722;
12833 -> 12722;
12834 -> 12722;
12835 -> 12722;
12836 -> 12722;
12836 -> 12835;
12837 -> 12835;
12838 -> 12836;
12838 -> 12837;
12839 -> 12837;
12840 -> 12838;
12840 -> 12839;
12841 -> 12839;
12842 -> 12840;
12842 -> 12841;
12843 -> 12842;
12843 -> 12839;
12844 -> 12843;
12844 -> 12837;
12845 -> 12844;
12845 -> 12835;
12846 -> 12845;
12846 -> 12722;
12847 -> 12722;
12848 -> 12722;
12849 -> 12847;
12849 -> 12848;
12850 -> 12848;
12851 -> 12849;
12851 -> 12850;
12851 -> 12848;
12852 -> 12849;
12852 -> 12848;
12853 -> 12848;
12853 -> 12722;
12854 -> 12722;
12855 -> 12854;
12855 -> 12722;
12856 -> 12722;
12857 -> 12722;
12858 -> 12722;
12859 -> 12858;
12859 -> 12722;
12860 -> 12722;
12861 -> 12860;
12861 -> 12722;
12862 -> 12722;
12863 -> 12722;
12864 -> 12722;
12865 -> 12722;
12866 -> 12865;
12866 -> 12722;
12867 -> 12866;
12867 -> 12722;
12868 -> 12864;
12868 -> 12722;
12869 -> 12722;
12870 -> 12868;
12870 -> 12869;
12871 -> 12870;
12871 -> 12722;
12871 -> 12869;
12872 -> 12871;
12872 -> 12722;
12873 -> 12722;
12874 -> 12868;
12874 -> 12873;
12875 -> 12874;
12875 -> 12722;
12875 -> 12873;
12876 -> 12875;
12876 -> 12722;
12877 -> 12722;
12878 -> 12876;
12878 -> 12877;
12879 -> 12877;
12879 -> 12722;
12880 -> 12872;
12880 -> 12879;
12880 -> 12722;
12881 -> 12722;
12882 -> 12868;
12882 -> 12881;
12883 -> 12882;
12883 -> 12881;
12884 -> 12883;
12884 -> 12722;
12884 -> 12881;
12885 -> 12884;
12885 -> 12722;
12886 -> 12722;
12887 -> 12885;
12887 -> 12886;
12888 -> 12722;
12889 -> 12887;
12889 -> 12888;
12890 -> 12888;
12890 -> 12722;
12891 -> 12722;
12892 -> 12880;
12892 -> 12890;
12892 -> 12722;
12893 -> 12722;
12894 -> 12722;
12895 -> 12722;
12895 -> 12775;
12896 -> 12775;
12897 -> 12896;
12897 -> 12722;
12898 -> 12722;
12899 -> 0;
12899 -> 12722;
12900 -> 12899;
12900 -> 12784;
12901 -> 12784;
12902 -> 12784;
12903 -> 12902;
12903 -> 12784;
12904 -> 12784;
12905 -> 12903;
12905 -> 12784;
12906 -> 12902;
12907 -> 12902;
12908 -> 12902;
12909 -> 12902;
12910 -> 12902;
12911 -> 12902;
12912 -> 12902;
12912 -> 12910;
12913 -> 12902;
12913 -> 12911;
12914 -> 12912;
12914 -> 12902;
12915 -> 12912;
12915 -> 12913;
12915 -> 12902;
12916 -> 0;
12916 -> 12902;
12917 -> 12902;
12918 -> 12910;
12918 -> 12902;
12919 -> 12911;
12919 -> 12902;
12920 -> 12902;
12921 -> 12902;
12922 -> 12918;
12922 -> 12921;
12923 -> 12919;
12923 -> 12921;
12924 -> 12920;
12924 -> 12921;
12925 -> 12922;
12925 -> 12921;
12926 -> 12923;
12926 -> 12921;
12927 -> 12924;
12927 -> 12921;
12928 -> 12921;
12929 -> 12926;
12929 -> 12928;
12930 -> 12927;
12930 -> 12928;
12931 -> 12922;
12931 -> 12928;
12932 -> 12929;
12932 -> 12931;
12932 -> 12928;
12933 -> 12902;
12934 -> 12902;
12935 -> 12902;
12936 -> 12902;
12937 -> 12936;
12937 -> 12902;
12938 -> 12902;
12939 -> 12935;
12939 -> 12902;
12940 -> 12902;
12941 -> 12902;
12941 -> 12940;
12942 -> 12941;
12942 -> 12902;
12942 -> 12940;
12943 -> 12942;
12943 -> 12902;
12944 -> 12902;
12945 -> 12902;
12945 -> 12944;
12946 -> 12944;
12947 -> 12946;
12947 -> 12902;
12948 -> 12943;
12948 -> 12947;
12948 -> 12902;
12949 -> 12935;
12949 -> 12937;
12949 -> 12902;
12950 -> 0;
12950 -> 12902;
12951 -> 12933;
12951 -> 12950;
12951 -> 12902;
12952 -> 12902;
12953 -> 12949;
12953 -> 12951;
12953 -> 12902;
12954 -> 12902;
12955 -> 12902;
12956 -> 12902;
12956 -> 0;
12957 -> 12902;
12958 -> 12902;
12958 -> 12957;
12959 -> 12957;
12960 -> 12958;
12960 -> 12959;
12961 -> 12960;
12961 -> 12959;
12962 -> 12959;
12963 -> 12961;
12963 -> 12962;
12964 -> 12963;
12964 -> 12962;
12965 -> 12964;
12965 -> 12959;
12966 -> 12965;
12966 -> 12959;
12967 -> 12959;
12967 -> 12957;
12968 -> 12902;
12969 -> 12968;
12969 -> 12902;
12970 -> 12902;
12970 -> 12969;
12971 -> 12969;
12972 -> 12970;
12972 -> 12971;
12973 -> 12972;
12973 -> 12971;
12974 -> 12971;
12975 -> 12973;
12975 -> 12974;
12976 -> 12975;
12976 -> 12974;
12977 -> 12976;
12977 -> 12971;
12978 -> 12977;
12978 -> 12971;
12979 -> 12971;
12979 -> 12969;
12980 -> 12902;
12980 -> 0;
12981 -> 12902;
12982 -> 12979;
12982 -> 12981;
12982 -> 12902;
12983 -> 12902;
12984 -> 12902;
12985 -> 12902;
12986 -> 12933;
12986 -> 12902;
12987 -> 12902;
12988 -> 12985;
12988 -> 12987;
12989 -> 12986;
12989 -> 12987;
12990 -> 12902;
12990 -> 12987;
12991 -> 12988;
12991 -> 12987;
12992 -> 12987;
12993 -> 12991;
12993 -> 12992;
12994 -> 12990;
12994 -> 12992;
12995 -> 12994;
12995 -> 12993;
12995 -> 12992;
12996 -> 12987;
12997 -> 12990;
12997 -> 12996;
12998 -> 12997;
12998 -> 12987;
12999 -> 12998;
13000 -> 12988;
13000 -> 12999;
13001 -> 13000;
13001 -> 12998;
13002 -> 12988;
13002 -> 12998;
13003 -> 12989;
13003 -> 12998;
13004 -> 12998;
13005 -> 13002;
13005 -> 13004;
13006 -> 13003;
13006 -> 13004;
13007 -> 12990;
13007 -> 13004;
13008 -> 13007;
13008 -> 13004;
13009 -> 13005;
13009 -> 13004;
13010 -> 13006;
13010 -> 13004;
13011 -> 13004;
13012 -> 13008;
13012 -> 13011;
13013 -> 13009;
13013 -> 13011;
13014 -> 13010;
13014 -> 13011;
13015 -> 13007;
13015 -> 12902;
13015 -> 13011;
13016 -> 13013;
13016 -> 13011;
13017 -> 13014;
13017 -> 13011;
13018 -> 13011;
13019 -> 13016;
13019 -> 13018;
13020 -> 13017;
13020 -> 13018;
13021 -> 13012;
13021 -> 13018;
13022 -> 13018;
13023 -> 13021;
13023 -> 13022;
13024 -> 13023;
13024 -> 12902;
13024 -> 13022;
13025 -> 13023;
13025 -> 13018;
13026 -> 13018;
13027 -> 13019;
13027 -> 13026;
13028 -> 13027;
13028 -> 12902;
13028 -> 13026;
13029 -> 13027;
13029 -> 13018;
13030 -> 13020;
13030 -> 13018;
13031 -> 13018;
13032 -> 13029;
13032 -> 13031;
13033 -> 13030;
13033 -> 13031;
13034 -> 13025;
13034 -> 13031;
13035 -> 13032;
13035 -> 13031;
13036 -> 13033;
13036 -> 13031;
13037 -> 13031;
13038 -> 13035;
13038 -> 13037;
13039 -> 13036;
13039 -> 13037;
13040 -> 13034;
13040 -> 13037;
13041 -> 13040;
13041 -> 13037;
13042 -> 13038;
13042 -> 13037;
13043 -> 13041;
13043 -> 13042;
13043 -> 13037;
13044 -> 13037;
13045 -> 13038;
13045 -> 13044;
13045 -> 13037;
13046 -> 13045;
13047 -> 13001;
13047 -> 13046;
13047 -> 12998;
13048 -> 13047;
13049 -> 13048;
13050 -> 12902;
13051 -> 13050;
13051 -> 12902;
13052 -> 12902;
13053 -> 13050;
13053 -> 13052;
13054 -> 13053;
13054 -> 13052;
13055 -> 13054;
13055 -> 13052;
13056 -> 12902;
13057 -> 13055;
13057 -> 13056;
13058 -> 12902;
13058 -> 13056;
13059 -> 12902;
13059 -> 13056;
13060 -> 13057;
13060 -> 13056;
13061 -> 13058;
13061 -> 13056;
13062 -> 13056;
13063 -> 13060;
13063 -> 13062;
13064 -> 13061;
13064 -> 13062;
13065 -> 13059;
13065 -> 13062;
13066 -> 13065;
13066 -> 13062;
13067 -> 13063;
13067 -> 13062;
13068 -> 13066;
13068 -> 13067;
13068 -> 13062;
13069 -> 13062;
13070 -> 13063;
13070 -> 13069;
13070 -> 13062;
13071 -> 13070;
13072 -> 13071;
13073 -> 13050;
13074 -> 13050;
13075 -> 13050;
13076 -> 12902;
13077 -> 13050;
13077 -> 13076;
13077 -> 12902;
13078 -> 13050;
13078 -> 12902;
13079 -> 12902;
13080 -> 13050;
13080 -> 12902;
13081 -> 13050;
13081 -> 12902;
13082 -> 12902;
13082 -> 13080;
13083 -> 12902;
13083 -> 13081;
13084 -> 13082;
13084 -> 12902;
13085 -> 13082;
13085 -> 13083;
13085 -> 12902;
13086 -> 13080;
13086 -> 12902;
13087 -> 13081;
13087 -> 12902;
13088 -> 13078;
13088 -> 12902;
13089 -> 13086;
13089 -> 12921;
13090 -> 13087;
13090 -> 12921;
13091 -> 13088;
13091 -> 12921;
13092 -> 13089;
13092 -> 12921;
13093 -> 13090;
13093 -> 12921;
13094 -> 13091;
13094 -> 12921;
13095 -> 13093;
13095 -> 12928;
13096 -> 13094;
13096 -> 12928;
13097 -> 13089;
13097 -> 12928;
13098 -> 13095;
13098 -> 13097;
13098 -> 12928;
13099 -> 13078;
13099 -> 12902;
13100 -> 13050;
13100 -> 12902;
13101 -> 13050;
13101 -> 12902;
13102 -> 12936;
13102 -> 13050;
13103 -> 13102;
13103 -> 12902;
13104 -> 13101;
13104 -> 12902;
13105 -> 12941;
13105 -> 13050;
13105 -> 12940;
13106 -> 13105;
13106 -> 12902;
13107 -> 12902;
13107 -> 12944;
13108 -> 13107;
13108 -> 13050;
13108 -> 12944;
13109 -> 13108;
13109 -> 12902;
13110 -> 13106;
13110 -> 13109;
13110 -> 12902;
13111 -> 13101;
13111 -> 13103;
13111 -> 12902;
13112 -> 13050;
13112 -> 12902;
13113 -> 13050;
13114 -> 13099;
13114 -> 13050;
13115 -> 13050;
13116 -> 13113;
13116 -> 13115;
13117 -> 13114;
13117 -> 13115;
13118 -> 13050;
13118 -> 13115;
13119 -> 13116;
13119 -> 13115;
13120 -> 13115;
13121 -> 13119;
13121 -> 13120;
13122 -> 13118;
13122 -> 13120;
13123 -> 13122;
13123 -> 13121;
13123 -> 13120;
13124 -> 13122;
13124 -> 13050;
13124 -> 13121;
13124 -> 13120;
13125 -> 13123;
13126 -> 12902;
13127 -> 12902;
13127 -> 13126;
13128 -> 13126;
13129 -> 13128;
13129 -> 13126;
13130 -> 13129;
13130 -> 13126;
13131 -> 13127;
13131 -> 13126;
13132 -> 13126;
13133 -> 13131;
13133 -> 13132;
13134 -> 13133;
13134 -> 13050;
13134 -> 13132;
13135 -> 13134;
13135 -> 13126;
13136 -> 13126;
13137 -> 13131;
13137 -> 13136;
13138 -> 13137;
13138 -> 13050;
13138 -> 13136;
13139 -> 13138;
13139 -> 13126;
13140 -> 13126;
13141 -> 13139;
13141 -> 13140;
13142 -> 13140;
13142 -> 13126;
13143 -> 13135;
13143 -> 13142;
13143 -> 13126;
13144 -> 13126;
13145 -> 13131;
13145 -> 13144;
13146 -> 13145;
13146 -> 13144;
13147 -> 13146;
13147 -> 13050;
13147 -> 13144;
13148 -> 13147;
13148 -> 13126;
13149 -> 13126;
13150 -> 13148;
13150 -> 13149;
13151 -> 13126;
13152 -> 13150;
13152 -> 13151;
13153 -> 13151;
13153 -> 13126;
13154 -> 13126;
13155 -> 13143;
13155 -> 13153;
13155 -> 13126;
13156 -> 13126;
13157 -> 13126;
13157 -> 12902;
13158 -> 12902;
13159 -> 12902;
13159 -> 13158;
13159 -> 13050;
13159 -> 12784;
13160 -> 9759;
13160 -> 10079;
13161 -> 9754;
13162 -> 9745;
13163 -> 9745;
13163 -> 13162;
13164 -> 13163;
13164 -> 13159;
13164 -> 13162;
13165 -> 13164;
13166 -> 13164;
13167 -> 13164;
13167 -> 13166;
13168 -> 13166;
13168 -> 13164;
13169 -> 13164;
13170 -> 13165;
13170 -> 13164;
13171 -> 13164;
13171 -> 13170;
13172 -> 0;
13172 -> 13164;
13173 -> 13172;
13174 -> 13172;
13175 -> 13172;
13176 -> 13172;
13176 -> 13175;
13177 -> 13175;
13177 -> 13172;
13178 -> 13172;
13179 -> 13172;
13180 -> 13172;
13181 -> 13180;
13181 -> 13172;
13182 -> 13180;
13182 -> 13172;
13183 -> 13182;
13184 -> 13183;
13184 -> 13172;
13185 -> 13172;
13186 -> 13185;
13186 -> 13172;
13187 -> 13172;
13188 -> 13172;
13189 -> 13187;
13189 -> 13172;
13190 -> 13172;
13191 -> 0;
13191 -> 13172;
13192 -> 13189;
13192 -> 13172;
13193 -> 13191;
13193 -> 0;
13193 -> 13172;
13194 -> 13191;
13194 -> 13193;
13195 -> 13172;
13196 -> 13195;
13196 -> 13172;
13197 -> 13172;
13198 -> 13196;
13198 -> 13172;
13199 -> 13196;
13199 -> 13198;
13200 -> 13199;
13200 -> 13172;
13201 -> 13196;
13201 -> 13172;
13202 -> 13191;
13202 -> 13194;
13202 -> 13172;
13203 -> 13202;
13203 -> 13200;
13203 -> 13172;
13204 -> 13172;
13205 -> 13172;
13205 -> 13204;
13206 -> 13204;
13207 -> 13206;
13207 -> 13204;
13208 -> 13207;
13208 -> 13204;
13209 -> 13205;
13209 -> 13204;
13210 -> 13204;
13211 -> 13209;
13211 -> 13210;
13212 -> 13210;
13213 -> 13212;
13213 -> 13204;
13214 -> 13204;
13215 -> 13209;
13215 -> 13214;
13216 -> 13215;
13216 -> 13204;
13217 -> 13204;
13218 -> 13216;
13218 -> 13217;
13219 -> 13217;
13219 -> 13204;
13220 -> 13213;
13220 -> 13219;
13220 -> 13204;
13221 -> 13204;
13222 -> 13209;
13222 -> 13221;
13223 -> 13222;
13223 -> 13204;
13224 -> 13204;
13225 -> 13223;
13225 -> 13224;
13226 -> 13204;
13227 -> 13225;
13227 -> 13226;
13228 -> 13226;
13228 -> 13204;
13229 -> 13204;
13230 -> 13220;
13230 -> 13228;
13230 -> 13204;
13231 -> 13204;
13232 -> 13209;
13232 -> 13231;
13233 -> 13232;
13233 -> 13204;
13234 -> 13233;
13234 -> 2687;
13234 -> 13204;
13235 -> 13230;
13235 -> 13234;
13235 -> 13204;
13236 -> 13204;
13237 -> 13204;
13237 -> 13172;
13238 -> 13172;
13239 -> 13172;
13239 -> 0;
13240 -> 13172;
13241 -> 13172;
13241 -> 13240;
13242 -> 13240;
13243 -> 13241;
13243 -> 13242;
13244 -> 13172;
13245 -> 13244;
13245 -> 13172;
13246 -> 13172;
13246 -> 13245;
13247 -> 13245;
13248 -> 13246;
13248 -> 13247;
13249 -> 13172;
13249 -> 0;
13250 -> 13172;
13251 -> 13248;
13251 -> 13250;
13251 -> 13172;
13252 -> 13172;
13253 -> 13172;
13254 -> 13172;
13255 -> 13254;
13255 -> 13172;
13256 -> 13172;
13257 -> 13253;
13257 -> 13256;
13258 -> 13256;
13259 -> 13257;
13259 -> 13258;
13260 -> 13258;
13261 -> 13259;
13261 -> 13260;
13262 -> 13260;
13263 -> 13261;
13263 -> 13262;
13264 -> 13263;
13264 -> 13260;
13265 -> 13264;
13265 -> 13258;
13266 -> 13265;
13266 -> 13256;
13267 -> 13266;
13267 -> 13172;
13268 -> 13172;
13269 -> 13253;
13269 -> 13268;
13270 -> 13268;
13271 -> 13269;
13271 -> 13270;
13272 -> 13270;
13273 -> 13271;
13273 -> 13272;
13274 -> 13272;
13274 -> 13270;
13275 -> 13271;
13275 -> 13268;
13276 -> 13275;
13276 -> 13172;
13277 -> 13172;
13278 -> 13253;
13278 -> 13172;
13279 -> 13172;
13280 -> 13278;
13280 -> 13279;
13281 -> 13277;
13281 -> 13279;
13282 -> 13280;
13282 -> 13279;
13283 -> 13279;
13284 -> 13280;
13284 -> 13283;
13285 -> 13283;
13285 -> 13279;
13286 -> 13279;
13287 -> 13279;
13288 -> 13280;
13288 -> 13287;
13289 -> 0;
13289 -> 13287;
13290 -> 13288;
13290 -> 13279;
13291 -> 13279;
13292 -> 13280;
13292 -> 13291;
13293 -> 13292;
13293 -> 13279;
13294 -> 13293;
13294 -> 13279;
13295 -> 13279;
13296 -> 13295;
13296 -> 13172;
13297 -> 13172;
13298 -> 13172;
13299 -> 13172;
13300 -> 13172;
13301 -> 13300;
13301 -> 13172;
13302 -> 13301;
13302 -> 13172;
13303 -> 13301;
13303 -> 13172;
13304 -> 13303;
13304 -> 13172;
13305 -> 13304;
13305 -> 13172;
13306 -> 13304;
13306 -> 13172;
13307 -> 13172;
13308 -> 13225;
13308 -> 13226;
13309 -> 13172;
13310 -> 13309;
13310 -> 13172;
13311 -> 13309;
13311 -> 13172;
13312 -> 13309;
13313 -> 13309;
13314 -> 13313;
13314 -> 13309;
13315 -> 13313;
13315 -> 13309;
13316 -> 13315;
13317 -> 13316;
13317 -> 13309;
13318 -> 13309;
13319 -> 13318;
13319 -> 13309;
13320 -> 13309;
13321 -> 13309;
13322 -> 13320;
13322 -> 13309;
13323 -> 13309;
13324 -> 0;
13324 -> 13309;
13325 -> 13322;
13325 -> 13309;
13326 -> 13324;
13326 -> 0;
13326 -> 13309;
13327 -> 13324;
13327 -> 13326;
13328 -> 13309;
13329 -> 13328;
13329 -> 13309;
13330 -> 13309;
13331 -> 13329;
13331 -> 13309;
13332 -> 13329;
13332 -> 13331;
13333 -> 13332;
13333 -> 13309;
13334 -> 13329;
13334 -> 13309;
13335 -> 13324;
13335 -> 13327;
13335 -> 13309;
13336 -> 13335;
13336 -> 13333;
13336 -> 13309;
13337 -> 13309;
13338 -> 13309;
13338 -> 13337;
13339 -> 13337;
13340 -> 13339;
13340 -> 13337;
13341 -> 13340;
13341 -> 13337;
13342 -> 13338;
13342 -> 13337;
13343 -> 13337;
13344 -> 13342;
13344 -> 13343;
13345 -> 13343;
13346 -> 13345;
13346 -> 13337;
13347 -> 13337;
13348 -> 13342;
13348 -> 13347;
13349 -> 13348;
13349 -> 13337;
13350 -> 13337;
13351 -> 13349;
13351 -> 13350;
13352 -> 13350;
13352 -> 13337;
13353 -> 13346;
13353 -> 13352;
13353 -> 13337;
13354 -> 13337;
13355 -> 13342;
13355 -> 13354;
13356 -> 13355;
13356 -> 13337;
13357 -> 13337;
13358 -> 13356;
13358 -> 13357;
13359 -> 13337;
13360 -> 13358;
13360 -> 13359;
13361 -> 13359;
13361 -> 13337;
13362 -> 13337;
13363 -> 13353;
13363 -> 13361;
13363 -> 13337;
13364 -> 13337;
13365 -> 13337;
13365 -> 13309;
13366 -> 13309;
13367 -> 13309;
13367 -> 0;
13368 -> 13309;
13369 -> 13309;
13369 -> 13368;
13370 -> 13368;
13371 -> 13369;
13371 -> 13370;
13372 -> 13309;
13373 -> 13372;
13373 -> 13309;
13374 -> 13309;
13374 -> 13373;
13375 -> 13373;
13376 -> 13374;
13376 -> 13375;
13377 -> 13309;
13377 -> 0;
13378 -> 13309;
13379 -> 13376;
13379 -> 13378;
13379 -> 13309;
13380 -> 13309;
13381 -> 13309;
13382 -> 13309;
13383 -> 13382;
13383 -> 13309;
13384 -> 13309;
13385 -> 13381;
13385 -> 13384;
13386 -> 13384;
13387 -> 13385;
13387 -> 13386;
13388 -> 13386;
13389 -> 13387;
13389 -> 13388;
13390 -> 13388;
13391 -> 13389;
13391 -> 13390;
13392 -> 13391;
13392 -> 13388;
13393 -> 13392;
13393 -> 13386;
13394 -> 13393;
13394 -> 13384;
13395 -> 13394;
13395 -> 13309;
13396 -> 13309;
13397 -> 13381;
13397 -> 13396;
13398 -> 13396;
13399 -> 13397;
13399 -> 13398;
13400 -> 13398;
13401 -> 13399;
13401 -> 13400;
13402 -> 13400;
13402 -> 13398;
13403 -> 13399;
13403 -> 13396;
13404 -> 13403;
13404 -> 13309;
13405 -> 13309;
13406 -> 13381;
13406 -> 13309;
13407 -> 13309;
13408 -> 13406;
13408 -> 13407;
13409 -> 13405;
13409 -> 13407;
13410 -> 13408;
13410 -> 13407;
13411 -> 13407;
13412 -> 13408;
13412 -> 13411;
13413 -> 13411;
13413 -> 13407;
13414 -> 13407;
13415 -> 13407;
13416 -> 13408;
13416 -> 13415;
13417 -> 0;
13417 -> 13415;
13418 -> 13416;
13418 -> 13407;
13419 -> 13407;
13420 -> 13408;
13420 -> 13419;
13421 -> 13420;
13421 -> 13407;
13422 -> 13421;
13422 -> 13407;
13423 -> 13407;
13424 -> 13423;
13424 -> 13309;
13425 -> 13309;
13426 -> 13309;
13427 -> 13309;
13427 -> 13172;
13428 -> 13309;
13428 -> 13427;
13429 -> 13428;
13430 -> 13428;
13431 -> 13428;
13432 -> 13428;
13433 -> 13428;
13433 -> 13432;
13434 -> 13432;
13434 -> 13428;
13435 -> 13428;
13436 -> 13428;
13437 -> 13435;
13437 -> 13428;
13438 -> 13435;
13439 -> 13435;
13440 -> 13435;
13441 -> 13435;
13442 -> 13435;
13442 -> 13441;
13443 -> 13441;
13443 -> 13435;
13444 -> 13435;
13445 -> 13435;
13446 -> 13435;
13447 -> 13446;
13447 -> 13435;
13448 -> 13446;
13448 -> 13435;
13449 -> 13448;
13450 -> 13449;
13450 -> 13435;
13451 -> 13435;
13452 -> 13451;
13452 -> 13435;
13453 -> 13435;
13454 -> 13435;
13455 -> 13453;
13455 -> 13435;
13456 -> 13435;
13457 -> 0;
13457 -> 13435;
13458 -> 13455;
13458 -> 13435;
13459 -> 13457;
13459 -> 0;
13459 -> 13435;
13460 -> 13457;
13460 -> 13459;
13461 -> 13435;
13462 -> 13461;
13462 -> 13435;
13463 -> 13435;
13464 -> 13462;
13464 -> 13435;
13465 -> 13462;
13465 -> 13464;
13466 -> 13465;
13466 -> 13435;
13467 -> 13462;
13467 -> 13435;
13468 -> 13457;
13468 -> 13460;
13468 -> 13435;
13469 -> 13468;
13469 -> 13466;
13469 -> 13435;
13470 -> 13435;
13471 -> 13435;
13471 -> 13470;
13472 -> 13470;
13473 -> 13472;
13473 -> 13470;
13474 -> 13473;
13474 -> 13470;
13475 -> 13471;
13475 -> 13470;
13476 -> 13470;
13477 -> 13475;
13477 -> 13476;
13478 -> 13476;
13479 -> 13478;
13479 -> 13470;
13480 -> 13470;
13481 -> 13475;
13481 -> 13480;
13482 -> 13481;
13482 -> 13470;
13483 -> 13470;
13484 -> 13482;
13484 -> 13483;
13485 -> 13483;
13485 -> 13470;
13486 -> 13479;
13486 -> 13485;
13486 -> 13470;
13487 -> 13470;
13488 -> 13475;
13488 -> 13487;
13489 -> 13488;
13489 -> 13470;
13490 -> 13470;
13491 -> 13489;
13491 -> 13490;
13492 -> 13470;
13493 -> 13491;
13493 -> 13492;
13494 -> 13492;
13494 -> 13470;
13495 -> 13470;
13496 -> 13486;
13496 -> 13494;
13496 -> 13470;
13497 -> 13470;
13498 -> 13470;
13498 -> 13435;
13499 -> 13435;
13500 -> 13435;
13500 -> 0;
13501 -> 13435;
13502 -> 13435;
13502 -> 13501;
13503 -> 13501;
13504 -> 13502;
13504 -> 13503;
13505 -> 13435;
13506 -> 13505;
13506 -> 13435;
13507 -> 13435;
13507 -> 13506;
13508 -> 13506;
13509 -> 13507;
13509 -> 13508;
13510 -> 13435;
13510 -> 0;
13511 -> 13435;
13512 -> 13509;
13512 -> 13511;
13512 -> 13435;
13513 -> 13435;
13514 -> 13435;
13515 -> 13435;
13516 -> 13515;
13516 -> 13435;
13517 -> 13435;
13518 -> 13514;
13518 -> 13517;
13519 -> 13517;
13520 -> 13518;
13520 -> 13519;
13521 -> 13519;
13522 -> 13520;
13522 -> 13521;
13523 -> 13521;
13524 -> 13522;
13524 -> 13523;
13525 -> 13524;
13525 -> 13521;
13526 -> 13525;
13526 -> 13519;
13527 -> 13526;
13527 -> 13517;
13528 -> 13527;
13528 -> 13435;
13529 -> 13435;
13530 -> 13514;
13530 -> 13529;
13531 -> 13529;
13532 -> 13530;
13532 -> 13531;
13533 -> 13531;
13534 -> 13532;
13534 -> 13533;
13535 -> 13533;
13535 -> 13531;
13536 -> 13532;
13536 -> 13529;
13537 -> 13536;
13537 -> 13435;
13538 -> 13435;
13539 -> 13514;
13539 -> 13435;
13540 -> 13435;
13541 -> 13539;
13541 -> 13540;
13542 -> 13538;
13542 -> 13540;
13543 -> 13541;
13543 -> 13540;
13544 -> 13540;
13545 -> 13541;
13545 -> 13544;
13546 -> 13544;
13546 -> 13540;
13547 -> 13540;
13548 -> 13540;
13549 -> 13541;
13549 -> 13548;
13550 -> 0;
13550 -> 13548;
13551 -> 13549;
13551 -> 13540;
13552 -> 13540;
13553 -> 13541;
13553 -> 13552;
13554 -> 13553;
13554 -> 13540;
13555 -> 13554;
13555 -> 13540;
13556 -> 13540;
13557 -> 13556;
13557 -> 13435;
13558 -> 13435;
13559 -> 13435;
13560 -> 13435;
13561 -> 13435;
13562 -> 13561;
13562 -> 13435;
13563 -> 13562;
13563 -> 13435;
13564 -> 13562;
13564 -> 13435;
13565 -> 13564;
13565 -> 13435;
13566 -> 13565;
13566 -> 13435;
13567 -> 13565;
13567 -> 13435;
13568 -> 13435;
13569 -> 13435;
13570 -> 13435;
13571 -> 13435;
13572 -> 13435;
13572 -> 13571;
13573 -> 13571;
13574 -> 13572;
13574 -> 13573;
13575 -> 13573;
13576 -> 13574;
13576 -> 13575;
13577 -> 13575;
13578 -> 13576;
13578 -> 13577;
13579 -> 13578;
13579 -> 13575;
13580 -> 13579;
13580 -> 13573;
13581 -> 13580;
13581 -> 13571;
13582 -> 13581;
13582 -> 13435;
13583 -> 13435;
13584 -> 13435;
13584 -> 13583;
13585 -> 13583;
13586 -> 13585;
13586 -> 13435;
13587 -> 13435;
13588 -> 13435;
13589 -> 13586;
13589 -> 13588;
13589 -> 13435;
13590 -> 13435;
13591 -> 13435;
13592 -> 13591;
13592 -> 13435;
13593 -> 13591;
13594 -> 13591;
13595 -> 13591;
13596 -> 13591;
13596 -> 13595;
13597 -> 13595;
13597 -> 13591;
13598 -> 13591;
13599 -> 13591;
13600 -> 13591;
13601 -> 13600;
13601 -> 13591;
13602 -> 13600;
13602 -> 13591;
13603 -> 13602;
13604 -> 13603;
13604 -> 13591;
13605 -> 13591;
13606 -> 13605;
13606 -> 13591;
13607 -> 13591;
13608 -> 13591;
13609 -> 13607;
13609 -> 13591;
13610 -> 13591;
13611 -> 0;
13611 -> 13591;
13612 -> 13609;
13612 -> 13591;
13613 -> 13611;
13613 -> 0;
13613 -> 13591;
13614 -> 13611;
13614 -> 13613;
13615 -> 13591;
13616 -> 13615;
13616 -> 13591;
13617 -> 13591;
13618 -> 13616;
13618 -> 13591;
13619 -> 13616;
13619 -> 13618;
13620 -> 13619;
13620 -> 13591;
13621 -> 13616;
13621 -> 13591;
13622 -> 13611;
13622 -> 13614;
13622 -> 13591;
13623 -> 13622;
13623 -> 13620;
13623 -> 13591;
13624 -> 13591;
13625 -> 13591;
13625 -> 13624;
13626 -> 13624;
13627 -> 13626;
13627 -> 13624;
13628 -> 13627;
13628 -> 13624;
13629 -> 13625;
13629 -> 13624;
13630 -> 13624;
13631 -> 13629;
13631 -> 13630;
13632 -> 13630;
13633 -> 13632;
13633 -> 13624;
13634 -> 13624;
13635 -> 13629;
13635 -> 13634;
13636 -> 13635;
13636 -> 13624;
13637 -> 13624;
13638 -> 13636;
13638 -> 13637;
13639 -> 13637;
13639 -> 13624;
13640 -> 13633;
13640 -> 13639;
13640 -> 13624;
13641 -> 13624;
13642 -> 13629;
13642 -> 13641;
13643 -> 13642;
13643 -> 13624;
13644 -> 13624;
13645 -> 13643;
13645 -> 13644;
13646 -> 13624;
13647 -> 13645;
13647 -> 13646;
13648 -> 13646;
13648 -> 13624;
13649 -> 13624;
13650 -> 13640;
13650 -> 13648;
13650 -> 13624;
13651 -> 13624;
13652 -> 13624;
13652 -> 13591;
13653 -> 13591;
13654 -> 13591;
13654 -> 0;
13655 -> 13591;
13656 -> 13591;
13656 -> 13655;
13657 -> 13655;
13658 -> 13656;
13658 -> 13657;
13659 -> 13591;
13660 -> 13659;
13660 -> 13591;
13661 -> 13591;
13661 -> 13660;
13662 -> 13660;
13663 -> 13661;
13663 -> 13662;
13664 -> 13591;
13664 -> 0;
13665 -> 13591;
13666 -> 13663;
13666 -> 13665;
13666 -> 13591;
13667 -> 13591;
13668 -> 13591;
13669 -> 13591;
13670 -> 13669;
13670 -> 13591;
13671 -> 13591;
13672 -> 13668;
13672 -> 13671;
13673 -> 13671;
13674 -> 13672;
13674 -> 13673;
13675 -> 13673;
13676 -> 13674;
13676 -> 13675;
13677 -> 13675;
13678 -> 13676;
13678 -> 13677;
13679 -> 13678;
13679 -> 13675;
13680 -> 13679;
13680 -> 13673;
13681 -> 13680;
13681 -> 13671;
13682 -> 13681;
13682 -> 13591;
13683 -> 13591;
13684 -> 13668;
13684 -> 13683;
13685 -> 13683;
13686 -> 13684;
13686 -> 13685;
13687 -> 13685;
13688 -> 13686;
13688 -> 13687;
13689 -> 13687;
13689 -> 13685;
13690 -> 13686;
13690 -> 13683;
13691 -> 13690;
13691 -> 13591;
13692 -> 13591;
13693 -> 13668;
13693 -> 13591;
13694 -> 13591;
13695 -> 13693;
13695 -> 13694;
13696 -> 13692;
13696 -> 13694;
13697 -> 13695;
13697 -> 13694;
13698 -> 13694;
13699 -> 13695;
13699 -> 13698;
13700 -> 13698;
13700 -> 13694;
13701 -> 13694;
13702 -> 13694;
13703 -> 13695;
13703 -> 13702;
13704 -> 0;
13704 -> 13702;
13705 -> 13703;
13705 -> 13694;
13706 -> 13694;
13707 -> 13695;
13707 -> 13706;
13708 -> 13707;
13708 -> 13694;
13709 -> 13708;
13709 -> 13694;
13710 -> 13694;
13711 -> 13710;
13711 -> 13591;
13712 -> 13591;
13713 -> 13591;
13714 -> 13591;
13715 -> 13591;
13716 -> 13715;
13716 -> 13591;
13717 -> 13716;
13717 -> 13591;
13718 -> 13716;
13718 -> 13591;
13719 -> 13718;
13719 -> 13591;
13720 -> 13719;
13720 -> 13591;
13721 -> 13719;
13721 -> 13591;
13722 -> 13591;
13723 -> 13591;
13724 -> 13591;
13725 -> 13591;
13726 -> 13591;
13726 -> 13725;
13727 -> 13725;
13728 -> 13726;
13728 -> 13727;
13729 -> 13727;
13730 -> 13728;
13730 -> 13729;
13731 -> 13729;
13732 -> 13730;
13732 -> 13731;
13733 -> 13732;
13733 -> 13729;
13734 -> 13733;
13734 -> 13727;
13735 -> 13734;
13735 -> 13725;
13736 -> 13735;
13736 -> 13591;
13737 -> 13591;
13738 -> 13591;
13738 -> 13737;
13739 -> 13737;
13740 -> 13739;
13740 -> 13591;
13741 -> 13591;
13742 -> 13591;
13743 -> 13740;
13743 -> 13742;
13743 -> 13591;
13744 -> 13591;
13745 -> 13591;
13746 -> 13591;
13747 -> 13591;
13748 -> 13747;
13748 -> 13591;
13749 -> 13591;
13750 -> 13591;
13751 -> 13591;
13752 -> 13645;
13752 -> 13646;
13753 -> 13624;
13754 -> 13629;
13754 -> 13753;
13755 -> 13754;
13755 -> 13624;
13756 -> 13755;
13756 -> 2687;
13756 -> 13624;
13757 -> 13650;
13757 -> 13756;
13757 -> 13624;
13758 -> 13741;
13759 -> 13591;
13760 -> 9743;
13760 -> 13591;
13760 -> 9741;
13761 -> 9743;
13761 -> 13760;
13761 -> 9741;
13762 -> 13761;
13762 -> 9739;
13763 -> 9737;
13763 -> 13762;
13763 -> 9709;
13764 -> 13763;
13764 -> 9707;
13765 -> 13764;
13765 -> 9705;
13766 -> 9670;
13766 -> 1;
13767 -> 1;
13768 -> 13766;
13768 -> 13767;
13769 -> 13767;
13770 -> 13768;
13770 -> 13769;
13771 -> 13769;
13772 -> 13770;
13772 -> 13771;
13773 -> 13771;
13774 -> 13772;
13774 -> 13773;
13775 -> 13774;
13775 -> 13762;
13775 -> 13773;
13776 -> 13773;
13777 -> 13775;
13777 -> 13776;
13777 -> 13773;
13778 -> 13775;
13778 -> 2784;
13778 -> 13777;
13779 -> 13777;
13780 -> 13775;
13780 -> 13777;
13781 -> 13780;
13781 -> 2784;
13781 -> 13771;
13782 -> 13780;
13782 -> 13762;
13782 -> 13771;
13783 -> 13782;
13783 -> 13769;
13784 -> 13783;
13784 -> 13767;
13785 -> 1;
13786 -> 13784;
13786 -> 13785;
13787 -> 13785;
13788 -> 13786;
13788 -> 13784;
13788 -> 13787;
13789 -> 13788;
13789 -> 13785;
13790 -> 1;
13791 -> 13789;
13791 -> 13790;
13791 -> 1;
13792 -> 1;
13793 -> 13789;
13793 -> 13792;
13793 -> 1;
13794 -> 1;
13795 -> 13789;
13795 -> 13794;
13795 -> 1;
13796 -> 1;
13797 -> 13789;
13797 -> 13796;
13797 -> 1;
13798 -> 1;
13799 -> 13789;
13799 -> 13798;
13799 -> 1;
13800 -> 1;
13801 -> 13789;
13801 -> 13800;
13801 -> 1;
13802 -> 1;
13803 -> 13789;
13803 -> 13802;
13803 -> 1;
13804 -> 1;
13805 -> 13789;
13805 -> 13804;
13805 -> 1;
13806 -> 1;
13807 -> 13789;
13807 -> 13806;
13807 -> 1;
13808 -> 1;
13809 -> 13791;
13809 -> 1;
13810 -> 1;
13811 -> 13809;
13811 -> 13810;
13812 -> 0;
13812 -> 13810;
13813 -> 13810;
13814 -> 13812;
13814 -> 13813;
13815 -> 13811;
13815 -> 13813;
13816 -> 13813;
13817 -> 13815;
13818 -> 13817;
13818 -> 13815;
13819 -> 13815;
13820 -> 13817;
13820 -> 13819;
13821 -> 13820;
13821 -> 13819;
13822 -> 9146;
13822 -> 13819;
13823 -> 13819;
13824 -> 13821;
13824 -> 13823;
13825 -> 13822;
13825 -> 13823;
13826 -> 13825;
13826 -> 0;
13826 -> 13823;
13827 -> 13825;
13827 -> 13823;
13828 -> 13823;
13829 -> 13824;
13829 -> 13828;
13830 -> 13828;
13831 -> 13829;
13831 -> 13830;
13832 -> 13831;
13832 -> 13828;
13833 -> 13832;
13833 -> 0;
13833 -> 13828;
13834 -> 13833;
13834 -> 13823;
13835 -> 13823;
13836 -> 0;
13836 -> 13823;
13837 -> 13836;
13837 -> 13815;
13838 -> 13815;
13839 -> 13815;
13840 -> 13818;
13840 -> 13839;
13841 -> 13837;
13841 -> 13839;
13842 -> 13838;
13842 -> 13839;
13843 -> 13841;
13843 -> 13839;
13844 -> 13839;
13845 -> 13843;
13845 -> 13844;
13846 -> 13842;
13846 -> 13844;
13847 -> 13845;
13847 -> 13844;
13848 -> 13844;
13849 -> 13847;
13849 -> 13848;
13850 -> 13846;
13850 -> 13848;
13851 -> 13848;
13852 -> 13850;
13852 -> 13851;
13853 -> 13851;
13854 -> 13852;
13854 -> 13853;
13855 -> 13850;
13855 -> 13848;
13856 -> 13849;
13856 -> 13850;
13856 -> 13848;
13857 -> 13842;
13857 -> 13839;
13858 -> 13840;
13858 -> 13839;
13859 -> 13840;
13859 -> 13839;
13860 -> 13839;
13861 -> 13859;
13861 -> 13860;
13862 -> 13860;
13863 -> 13861;
13863 -> 13862;
13863 -> 13860;
13864 -> 13861;
13864 -> 13860;
13865 -> 13860;
13865 -> 13839;
13866 -> 13840;
13866 -> 13842;
13866 -> 13839;
13867 -> 13815;
13867 -> 13838;
13867 -> 13856;
13867 -> 13866;
13867 -> 13789;
13867 -> 13831;
13868 -> 13814;
13868 -> 13813;
13869 -> 13813;
13870 -> 13868;
13870 -> 13869;
13871 -> 13870;
13871 -> 13869;
13872 -> 13869;
13873 -> 13871;
13873 -> 13872;
13874 -> 13873;
13874 -> 13872;
13875 -> 13872;
13876 -> 13874;
13876 -> 13872;
13877 -> 13872;
13878 -> 13875;
13878 -> 13877;
13879 -> 13875;
13879 -> 13877;
13880 -> 13876;
13880 -> 13877;
13881 -> 13875;
13881 -> 13877;
13882 -> 13877;
13883 -> 13867;
13883 -> 13882;
13883 -> 13877;
13884 -> 13881;
13884 -> 13877;
13885 -> 13884;
13886 -> 13878;
13886 -> 13885;
13886 -> 13884;
13887 -> 13884;
13888 -> 13879;
13888 -> 13887;
13888 -> 13884;
13889 -> 13867;
13889 -> 13877;
13890 -> 13877;
13891 -> 13890;
13891 -> 13877;
13892 -> 13880;
13892 -> 13877;
13893 -> 13878;
13893 -> 13877;
13894 -> 13879;
13894 -> 13877;
13895 -> 13877;
13896 -> 13877;
13897 -> 13891;
13897 -> 13896;
13898 -> 13892;
13898 -> 13896;
13899 -> 13893;
13899 -> 13896;
13900 -> 13894;
13900 -> 13896;
13901 -> 13895;
13901 -> 13896;
13902 -> 13897;
13902 -> 13896;
13903 -> 13898;
13903 -> 13896;
13904 -> 13896;
13905 -> 13899;
13905 -> 13896;
13906 -> 13900;
13906 -> 13896;
13907 -> 13896;
13908 -> 13907;
13908 -> 13902;
13908 -> 13903;
13908 -> 13904;
13908 -> 13905;
13908 -> 13906;
13908 -> 13890;
13908 -> 0;
13908 -> 13896;
13909 -> 13907;
13909 -> 13896;
13910 -> 13907;
13910 -> 13896;
13911 -> 13898;
13911 -> 13908;
13911 -> 13896;
13912 -> 0;
13912 -> 13896;
13913 -> 13911;
13913 -> 13907;
13913 -> 13896;
13914 -> 13895;
13914 -> 13877;
13915 -> 13877;
13916 -> 13914;
13916 -> 13915;
13917 -> 13916;
13917 -> 13915;
13918 -> 13915;
13919 -> 13917;
13919 -> 13918;
13920 -> 13867;
13920 -> 13918;
13921 -> 13920;
13921 -> 13918;
13922 -> 13918;
13923 -> 13921;
13923 -> 13922;
13924 -> 13919;
13924 -> 13922;
13925 -> 13923;
13925 -> 13922;
13926 -> 13922;
13927 -> 13925;
13927 -> 13926;
13928 -> 13924;
13928 -> 13926;
13929 -> 13928;
13929 -> 13908;
13929 -> 13926;
13930 -> 13928;
13930 -> 13908;
13930 -> 13909;
13930 -> 13913;
13930 -> 13910;
13930 -> 13926;
13931 -> 0;
13931 -> 13926;
13932 -> 13926;
13933 -> 13927;
13933 -> 13932;
13934 -> 13932;
13935 -> 13933;
13935 -> 13934;
13936 -> 13935;
13936 -> 13867;
13936 -> 13934;
13937 -> 13932;
13938 -> 13936;
13938 -> 13937;
13939 -> 13937;
13940 -> 13939;
13940 -> 13926;
13941 -> 13930;
13941 -> 13940;
13941 -> 13926;
13942 -> 13928;
13942 -> 13908;
13942 -> 13909;
13942 -> 13913;
13942 -> 13910;
13942 -> 13926;
13943 -> 0;
13943 -> 13926;
13944 -> 13927;
13944 -> 13942;
13945 -> 13942;
13946 -> 13944;
13946 -> 13945;
13947 -> 13945;
13948 -> 13946;
13948 -> 13947;
13949 -> 13948;
13949 -> 13944;
13949 -> 13947;
13950 -> 13949;
13950 -> 13945;
13951 -> 13945;
13952 -> 13950;
13952 -> 13951;
13953 -> 13951;
13954 -> 13953;
13955 -> 13945;
13956 -> 13952;
13956 -> 13955;
13957 -> 13956;
13957 -> 13955;
13958 -> 13955;
13959 -> 13957;
13959 -> 13958;
13960 -> 13958;
13961 -> 13944;
13961 -> 13945;
13962 -> 13945;
13963 -> 13961;
13963 -> 13962;
13964 -> 13963;
13964 -> 13959;
13964 -> 13962;
13965 -> 13945;
13966 -> 13964;
13966 -> 13965;
13967 -> 13926;
13968 -> 13927;
13968 -> 13967;
13969 -> 13967;
13970 -> 13968;
13970 -> 13969;
13971 -> 13970;
13971 -> 13966;
13971 -> 13969;
13972 -> 13967;
13973 -> 13971;
13973 -> 13972;
13974 -> 13972;
13975 -> 13974;
13975 -> 13972;
13976 -> 13972;
13977 -> 13975;
13977 -> 13976;
13978 -> 13973;
13978 -> 13976;
13979 -> 13976;
13980 -> 13978;
13980 -> 13979;
13981 -> 13979;
13982 -> 13981;
13982 -> 13976;
13983 -> 13976;
13984 -> 13978;
13984 -> 13983;
13985 -> 13984;
13985 -> 13976;
13986 -> 13976;
13987 -> 13985;
13987 -> 13986;
13988 -> 0;
13988 -> 13986;
13989 -> 13988;
13989 -> 13976;
13990 -> 13982;
13990 -> 13989;
13990 -> 13976;
13991 -> 13976;
13992 -> 13978;
13992 -> 13991;
13993 -> 13991;
13994 -> 13991;
13995 -> 13992;
13995 -> 13976;
13996 -> 13976;
13997 -> 13995;
13997 -> 13996;
13998 -> 13996;
13999 -> 13996;
14000 -> 13976;
14001 -> 13997;
14001 -> 14000;
14002 -> 14000;
14003 -> 14002;
14003 -> 13976;
14004 -> 13976;
14005 -> 13990;
14005 -> 14003;
14005 -> 13976;
14006 -> 13976;
14007 -> 13978;
14007 -> 14006;
14008 -> 14007;
14008 -> 13976;
14009 -> 14008;
14009 -> 2687;
14009 -> 13976;
14010 -> 14005;
14010 -> 14009;
14010 -> 13976;
14011 -> 13976;
14012 -> 13976;
14013 -> 14012;
14013 -> 13926;
14014 -> 13928;
14014 -> 13908;
14014 -> 14013;
14014 -> 13926;
14015 -> 13927;
14015 -> 13926;
14016 -> 13926;
14017 -> 14015;
14017 -> 14016;
14018 -> 13928;
14018 -> 14016;
14019 -> 14018;
14019 -> 13908;
14019 -> 13909;
14019 -> 13913;
14019 -> 13910;
14019 -> 14016;
14020 -> 0;
14020 -> 14016;
14021 -> 13926;
14022 -> 13927;
14022 -> 13926;
14023 -> 13926;
14024 -> 14022;
14024 -> 14023;
14025 -> 13928;
14025 -> 14023;
14026 -> 14023;
14027 -> 14024;
14027 -> 14026;
14028 -> 14026;
14029 -> 14027;
14029 -> 14028;
14030 -> 14029;
14030 -> 13966;
14030 -> 14028;
14031 -> 14030;
14031 -> 14026;
14032 -> 14026;
14033 -> 14031;
14033 -> 14032;
14034 -> 14033;
14034 -> 14023;
14035 -> 14025;
14035 -> 13908;
14035 -> 14034;
14035 -> 14023;
14036 -> 13926;
14037 -> 13927;
14037 -> 14036;
14038 -> 14036;
14039 -> 14037;
14039 -> 14038;
14040 -> 14039;
14040 -> 13966;
14040 -> 14038;
14041 -> 14040;
14041 -> 14036;
14042 -> 14036;
14043 -> 14041;
14043 -> 14042;
14044 -> 14036;
14045 -> 14043;
14045 -> 14044;
14046 -> 14045;
14046 -> 14044;
14047 -> 14044;
14048 -> 14046;
14048 -> 14047;
14049 -> 14047;
14050 -> 14048;
14050 -> 13926;
14051 -> 14050;
14051 -> 13926;
14052 -> 13926;
14053 -> 14051;
14053 -> 14052;
14054 -> 13928;
14054 -> 14052;
14055 -> 14053;
14055 -> 14052;
14056 -> 14052;
14057 -> 14055;
14057 -> 14056;
14057 -> 14052;
14058 -> 14054;
14058 -> 13908;
14058 -> 13909;
14058 -> 13913;
14058 -> 13910;
14058 -> 0;
14058 -> 14052;
14059 -> 14052;
14060 -> 14055;
14060 -> 14059;
14061 -> 14059;
14062 -> 14060;
14062 -> 13966;
14062 -> 14061;
14063 -> 14061;
14064 -> 14063;
14064 -> 14052;
14065 -> 14064;
14065 -> 13926;
14066 -> 14050;
14066 -> 14065;
14067 -> 14065;
14068 -> 14066;
14068 -> 14067;
14069 -> 14068;
14069 -> 13966;
14069 -> 14067;
14070 -> 14067;
14070 -> 14065;
14071 -> 14070;
14071 -> 14065;
14072 -> 13928;
14072 -> 13908;
14072 -> 13909;
14072 -> 13913;
14072 -> 13910;
14072 -> 14071;
14073 -> 14071;
14074 -> 14072;
14074 -> 14073;
14075 -> 14072;
14075 -> 14073;
14076 -> 14075;
14076 -> 14072;
14076 -> 14073;
14077 -> 14073;
14078 -> 14074;
14078 -> 14073;
14079 -> 14073;
14080 -> 14076;
14080 -> 14079;
14081 -> 14076;
14081 -> 14079;
14082 -> 14076;
14082 -> 14079;
14083 -> 14076;
14083 -> 14079;
14084 -> 14076;
14084 -> 14079;
14085 -> 14076;
14085 -> 14079;
14086 -> 14077;
14086 -> 14079;
14087 -> 14078;
14087 -> 14079;
14088 -> 14077;
14088 -> 14079;
14089 -> 14080;
14089 -> 14079;
14090 -> 14081;
14090 -> 14079;
14091 -> 14086;
14091 -> 14079;
14092 -> 14082;
14092 -> 14079;
14093 -> 14083;
14093 -> 14079;
14094 -> 14087;
14094 -> 14079;
14095 -> 14079;
14096 -> 14095;
14096 -> 14089;
14096 -> 14090;
14096 -> 14091;
14096 -> 14092;
14096 -> 14093;
14096 -> 14094;
14096 -> 14072;
14096 -> 14079;
14097 -> 14095;
14097 -> 14079;
14098 -> 14095;
14098 -> 14079;
14099 -> 14084;
14099 -> 14095;
14099 -> 14079;
14100 -> 14085;
14100 -> 14095;
14100 -> 14079;
14101 -> 14077;
14101 -> 14071;
14102 -> 14072;
14102 -> 14101;
14102 -> 14096;
14102 -> 14097;
14102 -> 14099;
14102 -> 14098;
14102 -> 14100;
14102 -> 14071;
14103 -> 14071;
14104 -> 14102;
14104 -> 14103;
14105 -> 14066;
14105 -> 14103;
14106 -> 14104;
14106 -> 14103;
14107 -> 14103;
14108 -> 14106;
14108 -> 14107;
14109 -> 14108;
14109 -> 14102;
14109 -> 14107;
14110 -> 14108;
14110 -> 14102;
14110 -> 14107;
14111 -> 14108;
14111 -> 14102;
14111 -> 0;
14111 -> 14107;
14112 -> 14111;
14113 -> 14105;
14113 -> 14112;
14114 -> 14112;
14115 -> 14112;
14116 -> 14115;
14117 -> 14115;
14118 -> 14112;
14119 -> 14118;
14120 -> 14119;
14121 -> 14111;
14122 -> 14113;
14122 -> 14121;
14123 -> 14108;
14123 -> 14121;
14124 -> 14122;
14124 -> 14121;
14125 -> 14121;
14126 -> 14124;
14126 -> 14125;
14126 -> 14121;
14127 -> 14123;
14127 -> 14102;
14127 -> 0;
14127 -> 14121;
14128 -> 14124;
14128 -> 14121;
14129 -> 14128;
14129 -> 13966;
14129 -> 14121;
14130 -> 14121;
14131 -> 14130;
14131 -> 14123;
14131 -> 14121;
14132 -> 14131;
14132 -> 14111;
14133 -> 14107;
14134 -> 14105;
14134 -> 14133;
14135 -> 14134;
14135 -> 13966;
14135 -> 14133;
14136 -> 14133;
14136 -> 14107;
14137 -> 0;
14137 -> 14136;
14138 -> 14136;
14139 -> 14138;
14140 -> 14138;
14141 -> 14136;
14142 -> 14137;
14142 -> 14141;
14143 -> 14108;
14143 -> 14141;
14144 -> 14141;
14145 -> 14105;
14146 -> 14105;
14146 -> 14145;
14147 -> 14146;
14147 -> 14145;
14148 -> 14147;
14149 -> 14143;
14149 -> 14102;
14149 -> 14148;
14149 -> 14105;
14150 -> 14149;
14151 -> 14149;
14151 -> 14150;
14152 -> 14151;
14152 -> 14150;
14153 -> 14152;
14153 -> 0;
14153 -> 14150;
14154 -> 14153;
14154 -> 14150;
14155 -> 14142;
14155 -> 14141;
14156 -> 14103;
14157 -> 14103;
14158 -> 14071;
14159 -> 14071;
14160 -> 14066;
14160 -> 14159;
14161 -> 14160;
14161 -> 14154;
14161 -> 14159;
14162 -> 14159;
14162 -> 14071;
14163 -> 8794;
14163 -> 14162;
14164 -> 14071;
14165 -> 14163;
14165 -> 14164;
14166 -> 13928;
14166 -> 14164;
14167 -> 0;
14167 -> 14164;
14168 -> 14164;
14169 -> 14164;
14170 -> 14167;
14170 -> 14169;
14171 -> 14168;
14171 -> 14169;
14172 -> 14166;
14172 -> 14169;
14173 -> 14169;
14174 -> 14165;
14175 -> 14165;
14175 -> 14174;
14176 -> 14175;
14176 -> 14174;
14177 -> 14176;
14178 -> 14172;
14178 -> 14154;
14178 -> 14177;
14178 -> 14165;
14179 -> 14170;
14179 -> 14169;
14180 -> 14171;
14180 -> 14169;
14181 -> 14071;
14182 -> 13928;
14182 -> 14178;
14182 -> 0;
14182 -> 13926;
14183 -> 14182;
14184 -> 13927;
14184 -> 14183;
14185 -> 14183;
14186 -> 14184;
14186 -> 14185;
14187 -> 14186;
14187 -> 14183;
14188 -> 14183;
14189 -> 14187;
14189 -> 14188;
14190 -> 14183;
14191 -> 14189;
14191 -> 14190;
14192 -> 14191;
14192 -> 14190;
14193 -> 14190;
14194 -> 14192;
14194 -> 14193;
14195 -> 14194;
14195 -> 14182;
14196 -> 14182;
14197 -> 14195;
14197 -> 14196;
14198 -> 13928;
14198 -> 14196;
14199 -> 14197;
14199 -> 14196;
14200 -> 14199;
14201 -> 13927;
14201 -> 13926;
14202 -> 13926;
14203 -> 14201;
14203 -> 14202;
14204 -> 13928;
14204 -> 14202;
14205 -> 14202;
14206 -> 14203;
14206 -> 14205;
14207 -> 14205;
14208 -> 14206;
14208 -> 14207;
14209 -> 14208;
14209 -> 14178;
14209 -> 14207;
14210 -> 14205;
14211 -> 14209;
14211 -> 14210;
14212 -> 14210;
14213 -> 14212;
14213 -> 14202;
14214 -> 14213;
14215 -> 14203;
14215 -> 14214;
14216 -> 14214;
14217 -> 14215;
14217 -> 14216;
14218 -> 14217;
14218 -> 14178;
14218 -> 14216;
14219 -> 14214;
14220 -> 14218;
14220 -> 14219;
14221 -> 14219;
14222 -> 14221;
14222 -> 14219;
14223 -> 14219;
14224 -> 14222;
14224 -> 14223;
14225 -> 14220;
14225 -> 14223;
14226 -> 14223;
14227 -> 14225;
14227 -> 14226;
14228 -> 14226;
14229 -> 14228;
14229 -> 14223;
14230 -> 14223;
14231 -> 14225;
14231 -> 14230;
14232 -> 14231;
14232 -> 14223;
14233 -> 14223;
14234 -> 14232;
14234 -> 14233;
14235 -> 0;
14235 -> 14233;
14236 -> 14235;
14236 -> 14223;
14237 -> 14229;
14237 -> 14236;
14237 -> 14223;
14238 -> 14223;
14239 -> 14225;
14239 -> 14238;
14240 -> 14238;
14241 -> 14238;
14242 -> 14239;
14242 -> 14223;
14243 -> 14223;
14244 -> 14242;
14244 -> 14243;
14245 -> 14243;
14246 -> 14243;
14247 -> 14223;
14248 -> 14244;
14248 -> 14247;
14249 -> 14247;
14250 -> 14249;
14250 -> 14223;
14251 -> 14223;
14252 -> 14237;
14252 -> 14250;
14252 -> 14223;
14253 -> 14223;
14254 -> 14225;
14254 -> 14253;
14255 -> 14254;
14255 -> 14223;
14256 -> 14255;
14256 -> 2687;
14256 -> 14223;
14257 -> 14252;
14257 -> 14256;
14257 -> 14223;
14258 -> 14223;
14259 -> 14223;
14260 -> 14259;
14260 -> 14213;
14261 -> 14202;
14262 -> 14203;
14262 -> 14202;
14263 -> 14262;
14264 -> 14203;
14264 -> 14263;
14265 -> 14264;
14265 -> 14178;
14265 -> 14263;
14266 -> 14265;
14266 -> 14262;
14267 -> 14266;
14267 -> 14202;
14268 -> 14202;
14269 -> 14267;
14269 -> 14268;
14269 -> 14202;
14270 -> 14266;
14270 -> 14269;
14271 -> 14269;
14272 -> 14270;
14272 -> 14271;
14272 -> 14269;
14273 -> 14266;
14273 -> 14272;
14274 -> 14272;
14275 -> 14273;
14275 -> 14274;
14275 -> 14272;
14276 -> 14203;
14276 -> 14202;
14277 -> 14202;
14278 -> 14276;
14278 -> 14277;
14279 -> 14277;
14280 -> 14278;
14280 -> 14279;
14281 -> 14279;
14282 -> 14280;
14282 -> 14281;
14283 -> 14282;
14283 -> 14178;
14283 -> 14281;
14284 -> 14283;
14284 -> 14279;
14285 -> 14279;
14286 -> 14284;
14286 -> 14285;
14287 -> 14286;
14287 -> 14277;
14288 -> 0;
14288 -> 14287;
14289 -> 14202;
14290 -> 14261;
14290 -> 14289;
14290 -> 14202;
14291 -> 14290;
14292 -> 14203;
14292 -> 14291;
14293 -> 14291;
14294 -> 14292;
14294 -> 14293;
14295 -> 14294;
14295 -> 14178;
14295 -> 14293;
14296 -> 14291;
14297 -> 14295;
14297 -> 14290;
14298 -> 14204;
14298 -> 14178;
14298 -> 14202;
14299 -> 0;
14299 -> 14202;
14300 -> 14288;
14300 -> 0;
14300 -> 14202;
14301 -> 14298;
14301 -> 14300;
14301 -> 14202;
14302 -> 14203;
14302 -> 14301;
14303 -> 14297;
14303 -> 14301;
14304 -> 14301;
14305 -> 14302;
14305 -> 14304;
14306 -> 14303;
14306 -> 14304;
14307 -> 14204;
14307 -> 14304;
14308 -> 14307;
14308 -> 14178;
14308 -> 14304;
14309 -> 14306;
14309 -> 14304;
14310 -> 14288;
14310 -> 14301;
14311 -> 14203;
14311 -> 14301;
14312 -> 14309;
14312 -> 14301;
14313 -> 14301;
14314 -> 14310;
14314 -> 14313;
14315 -> 14311;
14315 -> 14313;
14316 -> 14312;
14316 -> 14313;
14317 -> 14204;
14317 -> 14316;
14317 -> 14202;
14318 -> 0;
14318 -> 14202;
14319 -> 14317;
14320 -> 14203;
14320 -> 14319;
14321 -> 14319;
14322 -> 14320;
14322 -> 14321;
14323 -> 14322;
14323 -> 14316;
14323 -> 14321;
14324 -> 14323;
14324 -> 14319;
14325 -> 14319;
14326 -> 14324;
14326 -> 14325;
14327 -> 14325;
14327 -> 14319;
14328 -> 14327;
14328 -> 14317;
14329 -> 14317;
14330 -> 14203;
14330 -> 14328;
14331 -> 14328;
14332 -> 14330;
14332 -> 14331;
14333 -> 14204;
14333 -> 14331;
14334 -> 14332;
14334 -> 14331;
14335 -> 14331;
14336 -> 14334;
14336 -> 14335;
14337 -> 14333;
14337 -> 14335;
14338 -> 14335;
14339 -> 14336;
14339 -> 14338;
14340 -> 14339;
14340 -> 14335;
14341 -> 14337;
14341 -> 14316;
14341 -> 14340;
14341 -> 14335;
14342 -> 14328;
14343 -> 14202;
14344 -> 14266;
14344 -> 14343;
14345 -> 14344;
14345 -> 14202;
14346 -> 13926;
14347 -> 13922;
14348 -> 13923;
14348 -> 13922;
14349 -> 13922;
14350 -> 14348;
14350 -> 14349;
14351 -> 13924;
14351 -> 14349;
14352 -> 14350;
14352 -> 14349;
14353 -> 14349;
14354 -> 14352;
14354 -> 14353;
14355 -> 14351;
14355 -> 14353;
14356 -> 14353;
14357 -> 14354;
14357 -> 14356;
14358 -> 14357;
14358 -> 14316;
14358 -> 14356;
14359 -> 14358;
14359 -> 14353;
14360 -> 14353;
14361 -> 14360;
14361 -> 14349;
14362 -> 13922;
14363 -> 13918;
14364 -> 13915;
14365 -> 13877;
14366 -> 1;
14367 -> 13793;
14367 -> 1;
14368 -> 1;
14369 -> 14367;
14369 -> 14368;
14370 -> 0;
14370 -> 14368;
14371 -> 14368;
14372 -> 14370;
14372 -> 14371;
14373 -> 14369;
14373 -> 14371;
14374 -> 14371;
14375 -> 14373;
14375 -> 14316;
14375 -> 14374;
14376 -> 9146;
14376 -> 14375;
14377 -> 14376;
14377 -> 14375;
14378 -> 14377;
14378 -> 0;
14378 -> 14375;
14379 -> 14377;
14379 -> 14375;
14380 -> 14375;
14381 -> 14380;
14381 -> 0;
14381 -> 14375;
14382 -> 14375;
14383 -> 14382;
14384 -> 14375;
14385 -> 14375;
14386 -> 14375;
14387 -> 14375;
14388 -> 14375;
14389 -> 14387;
14389 -> 14388;
14390 -> 14388;
14391 -> 14389;
14391 -> 14390;
14391 -> 14388;
14392 -> 14389;
14392 -> 14388;
14393 -> 14388;
14393 -> 14375;
14394 -> 14372;
14394 -> 14371;
14395 -> 14371;
14396 -> 14394;
14396 -> 14395;
14397 -> 14396;
14397 -> 14395;
14398 -> 14395;
14399 -> 14397;
14399 -> 14398;
14400 -> 14399;
14400 -> 14398;
14401 -> 14398;
14402 -> 14400;
14402 -> 14398;
14403 -> 14398;
14404 -> 14401;
14404 -> 14403;
14405 -> 14401;
14405 -> 14403;
14406 -> 14402;
14406 -> 14403;
14407 -> 14401;
14407 -> 14403;
14408 -> 14403;
14409 -> 14375;
14409 -> 14408;
14409 -> 14403;
14410 -> 14407;
14410 -> 14403;
14411 -> 14410;
14412 -> 14404;
14412 -> 14411;
14412 -> 14410;
14413 -> 14410;
14414 -> 14405;
14414 -> 14413;
14414 -> 14410;
14415 -> 14375;
14415 -> 14403;
14416 -> 14403;
14417 -> 14416;
14417 -> 14403;
14418 -> 14406;
14418 -> 14403;
14419 -> 14404;
14419 -> 14403;
14420 -> 14405;
14420 -> 14403;
14421 -> 14403;
14422 -> 14403;
14423 -> 14417;
14423 -> 14422;
14424 -> 14418;
14424 -> 14422;
14425 -> 14419;
14425 -> 14422;
14426 -> 14420;
14426 -> 14422;
14427 -> 14421;
14427 -> 14422;
14428 -> 14423;
14428 -> 14422;
14429 -> 14424;
14429 -> 14422;
14430 -> 14422;
14431 -> 14425;
14431 -> 14422;
14432 -> 14426;
14432 -> 14422;
14433 -> 14422;
14434 -> 14433;
14434 -> 14422;
14435 -> 14433;
14435 -> 14422;
14436 -> 0;
14436 -> 14422;
14437 -> 14421;
14437 -> 14403;
14438 -> 14403;
14439 -> 14437;
14439 -> 14438;
14440 -> 14439;
14440 -> 14438;
14441 -> 14438;
14442 -> 14440;
14442 -> 14441;
14443 -> 14441;
14444 -> 14442;
14444 -> 14443;
14445 -> 14443;
14446 -> 14444;
14446 -> 14445;
14447 -> 14446;
14447 -> 14375;
14447 -> 14445;
14448 -> 14446;
14448 -> 14375;
14448 -> 14434;
14448 -> 14435;
14448 -> 14445;
14449 -> 0;
14449 -> 14445;
14450 -> 14445;
14451 -> 14375;
14451 -> 14450;
14452 -> 14450;
14453 -> 14451;
14453 -> 14452;
14454 -> 14450;
14455 -> 14453;
14455 -> 14454;
14456 -> 14454;
14457 -> 14456;
14457 -> 14445;
14458 -> 14448;
14458 -> 14457;
14458 -> 14445;
14459 -> 0;
14459 -> 14445;
14460 -> 14445;
14461 -> 14375;
14461 -> 14460;
14462 -> 14460;
14463 -> 14461;
14463 -> 14462;
14464 -> 14460;
14465 -> 14463;
14465 -> 14464;
14466 -> 14464;
14467 -> 14466;
14467 -> 14464;
14468 -> 14464;
14469 -> 14467;
14469 -> 14468;
14470 -> 14465;
14470 -> 14468;
14471 -> 14468;
14472 -> 14470;
14472 -> 14471;
14473 -> 14471;
14474 -> 14473;
14474 -> 14468;
14475 -> 14468;
14476 -> 14470;
14476 -> 14475;
14477 -> 14476;
14477 -> 14468;
14478 -> 14468;
14479 -> 14477;
14479 -> 14478;
14480 -> 0;
14480 -> 14478;
14481 -> 14480;
14481 -> 14468;
14482 -> 14474;
14482 -> 14481;
14482 -> 14468;
14483 -> 14468;
14484 -> 14470;
14484 -> 14483;
14485 -> 14483;
14486 -> 14483;
14487 -> 14484;
14487 -> 14468;
14488 -> 14468;
14489 -> 14487;
14489 -> 14488;
14490 -> 14488;
14491 -> 14488;
14492 -> 14468;
14493 -> 14489;
14493 -> 14492;
14494 -> 14492;
14495 -> 14494;
14495 -> 14468;
14496 -> 14468;
14497 -> 14482;
14497 -> 14495;
14497 -> 14468;
14498 -> 14468;
14499 -> 14468;
14500 -> 14499;
14500 -> 14445;
14501 -> 14446;
14501 -> 14375;
14501 -> 14500;
14501 -> 14445;
14502 -> 14375;
14502 -> 14445;
14503 -> 14445;
14504 -> 14502;
14504 -> 14503;
14505 -> 14446;
14505 -> 14503;
14506 -> 14505;
14506 -> 14375;
14506 -> 14503;
14507 -> 0;
14507 -> 14503;
14508 -> 14445;
14509 -> 14375;
14509 -> 14445;
14510 -> 14445;
14511 -> 14509;
14511 -> 14510;
14512 -> 14446;
14512 -> 14510;
14513 -> 14510;
14514 -> 14511;
14514 -> 14513;
14515 -> 14513;
14516 -> 14513;
14517 -> 14514;
14517 -> 14510;
14518 -> 14512;
14518 -> 14375;
14518 -> 14517;
14518 -> 14510;
14519 -> 14445;
14520 -> 14519;
14521 -> 14519;
14522 -> 14519;
14523 -> 14522;
14524 -> 14523;
14525 -> 14445;
14526 -> 14375;
14526 -> 14525;
14527 -> 14446;
14527 -> 14525;
14528 -> 14526;
14528 -> 14525;
14529 -> 14525;
14530 -> 14528;
14530 -> 14529;
14530 -> 14525;
14531 -> 14527;
14531 -> 14375;
14531 -> 0;
14531 -> 14525;
14532 -> 14525;
14533 -> 14528;
14533 -> 14532;
14534 -> 14532;
14535 -> 14533;
14535 -> 14375;
14535 -> 14534;
14536 -> 14534;
14537 -> 14536;
14537 -> 14525;
14538 -> 14537;
14538 -> 14445;
14539 -> 14538;
14540 -> 14375;
14540 -> 14539;
14541 -> 14540;
14541 -> 14375;
14541 -> 14539;
14542 -> 14539;
14542 -> 14538;
14543 -> 14542;
14543 -> 14538;
14544 -> 14543;
14545 -> 14544;
14546 -> 14544;
14547 -> 14545;
14547 -> 14546;
14548 -> 14545;
14548 -> 14546;
14549 -> 14547;
14549 -> 14546;
14550 -> 14546;
14551 -> 14550;
14551 -> 14546;
14552 -> 14550;
14552 -> 14546;
14553 -> 14545;
14553 -> 14543;
14554 -> 14543;
14555 -> 14554;
14556 -> 14375;
14556 -> 14555;
14557 -> 14375;
14557 -> 14555;
14558 -> 14375;
14559 -> 14375;
14560 -> 14558;
14560 -> 14375;
14561 -> 14375;
14562 -> 14560;
14562 -> 14561;
14562 -> 14375;
14563 -> 14559;
14563 -> 14375;
14563 -> 0;
14564 -> 14560;
14564 -> 14375;
14565 -> 14564;
14565 -> 14375;
14566 -> 14375;
14567 -> 14375;
14568 -> 14564;
14568 -> 14375;
14569 -> 14375;
14570 -> 14569;
14570 -> 14375;
14571 -> 14555;
14572 -> 14375;
14572 -> 14571;
14573 -> 14572;
14573 -> 14375;
14573 -> 14571;
14574 -> 14571;
14574 -> 14555;
14575 -> 0;
14575 -> 14574;
14576 -> 14574;
14577 -> 14576;
14578 -> 14576;
14579 -> 14574;
14580 -> 14575;
14580 -> 14579;
14581 -> 14579;
14582 -> 14580;
14582 -> 14579;
14583 -> 14554;
14584 -> 14554;
14585 -> 14543;
14586 -> 14543;
14587 -> 14375;
14587 -> 14586;
14588 -> 14587;
14588 -> 14375;
14588 -> 14586;
14589 -> 14586;
14589 -> 14543;
14590 -> 14543;
14591 -> 14446;
14591 -> 14590;
14592 -> 0;
14592 -> 14590;
14593 -> 14590;
14594 -> 14590;
14595 -> 14592;
14595 -> 14594;
14596 -> 14593;
14596 -> 14594;
14597 -> 14591;
14597 -> 14594;
14598 -> 14594;
14599 -> 14595;
14599 -> 14594;
14600 -> 14596;
14600 -> 14594;
14601 -> 14543;
14602 -> 14446;
14602 -> 14375;
14602 -> 0;
14602 -> 14445;
14603 -> 14602;
14604 -> 14375;
14604 -> 14603;
14605 -> 14603;
14606 -> 14604;
14606 -> 14605;
14607 -> 14606;
14607 -> 14603;
14608 -> 14603;
14609 -> 14607;
14609 -> 14608;
14610 -> 14603;
14611 -> 14609;
14611 -> 14610;
14612 -> 14611;
14612 -> 14610;
14613 -> 14610;
14614 -> 14612;
14614 -> 14613;
14615 -> 14614;
14615 -> 14602;
14616 -> 14602;
14617 -> 14615;
14617 -> 14616;
14618 -> 14446;
14618 -> 14616;
14619 -> 14617;
14619 -> 14616;
14620 -> 14619;
14621 -> 14445;
14622 -> 14446;
14622 -> 14621;
14623 -> 14621;
14624 -> 14375;
14624 -> 14623;
14625 -> 14623;
14626 -> 14624;
14626 -> 14625;
14627 -> 14623;
14628 -> 14626;
14628 -> 14627;
14629 -> 14627;
14630 -> 14629;
14630 -> 14621;
14631 -> 14630;
14632 -> 14375;
14632 -> 14631;
14633 -> 14631;
14634 -> 14632;
14634 -> 14633;
14635 -> 14631;
14636 -> 14634;
14636 -> 14635;
14637 -> 14635;
14638 -> 14637;
14638 -> 14635;
14639 -> 14635;
14640 -> 14638;
14640 -> 14639;
14641 -> 14636;
14641 -> 14639;
14642 -> 14639;
14643 -> 14641;
14643 -> 14642;
14644 -> 14642;
14645 -> 14644;
14645 -> 14639;
14646 -> 14639;
14647 -> 14641;
14647 -> 14646;
14648 -> 14647;
14648 -> 14639;
14649 -> 14639;
14650 -> 14648;
14650 -> 14649;
14651 -> 0;
14651 -> 14649;
14652 -> 14651;
14652 -> 14639;
14653 -> 14645;
14653 -> 14652;
14653 -> 14639;
14654 -> 14639;
14655 -> 14641;
14655 -> 14654;
14656 -> 14654;
14657 -> 14654;
14658 -> 14655;
14658 -> 14639;
14659 -> 14639;
14660 -> 14658;
14660 -> 14659;
14661 -> 14659;
14662 -> 14659;
14663 -> 14639;
14664 -> 14660;
14664 -> 14663;
14665 -> 14663;
14666 -> 14665;
14666 -> 14639;
14667 -> 14639;
14668 -> 14653;
14668 -> 14666;
14668 -> 14639;
14669 -> 14639;
14670 -> 14639;
14671 -> 14670;
14671 -> 14630;
14672 -> 14621;
14673 -> 14375;
14673 -> 14621;
14674 -> 14673;
14675 -> 14375;
14675 -> 14674;
14676 -> 14675;
14676 -> 14375;
14676 -> 14674;
14677 -> 14676;
14677 -> 14673;
14678 -> 14677;
14678 -> 14621;
14679 -> 14621;
14680 -> 14678;
14680 -> 14679;
14680 -> 14621;
14681 -> 14677;
14681 -> 14680;
14682 -> 14680;
14683 -> 14681;
14683 -> 14682;
14683 -> 14680;
14684 -> 14677;
14684 -> 14683;
14685 -> 14683;
14686 -> 14684;
14686 -> 14685;
14686 -> 14683;
14687 -> 14621;
14688 -> 14687;
14689 -> 14688;
14690 -> 14688;
14691 -> 14621;
14692 -> 14672;
14692 -> 14691;
14692 -> 14621;
14693 -> 14692;
14694 -> 14693;
14695 -> 14693;
14696 -> 0;
14696 -> 14621;
14697 -> 14375;
14698 -> 14622;
14698 -> 14375;
14699 -> 14698;
14699 -> 14375;
14700 -> 14622;
14700 -> 14375;
14700 -> 14621;
14701 -> 0;
14701 -> 14621;
14702 -> 14700;
14703 -> 14375;
14703 -> 14702;
14704 -> 14702;
14705 -> 14703;
14705 -> 14704;
14706 -> 14705;
14706 -> 14375;
14706 -> 14704;
14707 -> 14706;
14707 -> 14702;
14708 -> 14702;
14709 -> 14707;
14709 -> 14708;
14710 -> 14708;
14710 -> 14702;
14711 -> 14710;
14711 -> 14700;
14712 -> 14700;
14713 -> 14375;
14713 -> 14711;
14714 -> 14711;
14715 -> 14713;
14715 -> 14714;
14716 -> 14622;
14716 -> 14714;
14717 -> 14715;
14717 -> 14714;
14718 -> 14714;
14719 -> 14717;
14719 -> 14718;
14720 -> 14716;
14720 -> 14718;
14721 -> 14718;
14722 -> 14719;
14722 -> 14721;
14723 -> 14722;
14723 -> 14718;
14724 -> 14720;
14724 -> 14375;
14724 -> 14723;
14724 -> 14718;
14725 -> 14711;
14726 -> 14621;
14727 -> 14677;
14727 -> 14726;
14728 -> 14727;
14728 -> 14621;
14729 -> 14445;
14730 -> 14443;
14731 -> 14375;
14731 -> 14443;
14732 -> 14443;
14733 -> 14731;
14733 -> 14732;
14734 -> 14444;
14734 -> 14732;
14735 -> 14733;
14735 -> 14732;
14736 -> 14732;
14737 -> 14735;
14737 -> 14736;
14738 -> 14734;
14738 -> 14736;
14739 -> 14736;
14740 -> 14737;
14740 -> 14739;
14741 -> 14740;
14741 -> 14375;
14741 -> 14739;
14742 -> 14741;
14742 -> 14736;
14743 -> 14736;
14744 -> 14743;
14744 -> 14732;
14745 -> 14443;
14746 -> 14441;
14747 -> 14438;
14748 -> 14403;
14749 -> 1;
14750 -> 13795;
14750 -> 1;
14751 -> 1;
14752 -> 14750;
14752 -> 14751;
14753 -> 0;
14753 -> 14751;
14754 -> 14751;
14755 -> 14753;
14755 -> 14754;
14756 -> 14752;
14756 -> 14754;
14757 -> 14754;
14758 -> 14756;
14758 -> 14375;
14758 -> 14757;
14759 -> 9146;
14759 -> 14758;
14760 -> 14759;
14760 -> 14758;
14761 -> 14760;
14761 -> 0;
14761 -> 14758;
14762 -> 14760;
14762 -> 14758;
14763 -> 14758;
14764 -> 14758;
14765 -> 14763;
14765 -> 14375;
14765 -> 14764;
14766 -> 14765;
14766 -> 14758;
14767 -> 14766;
14767 -> 14758;
14768 -> 14767;
14768 -> 0;
14768 -> 14758;
14769 -> 14758;
14770 -> 14769;
14771 -> 14758;
14772 -> 14758;
14773 -> 14758;
14774 -> 14758;
14775 -> 14758;
14776 -> 14774;
14776 -> 14775;
14777 -> 14775;
14778 -> 14776;
14778 -> 14777;
14778 -> 14775;
14779 -> 14776;
14779 -> 14775;
14780 -> 14775;
14781 -> 14779;
14781 -> 14780;
14782 -> 14781;
14782 -> 14775;
14783 -> 14775;
14783 -> 14758;
14784 -> 14755;
14784 -> 14754;
14785 -> 14754;
14786 -> 14784;
14786 -> 14785;
14787 -> 14786;
14787 -> 14785;
14788 -> 14785;
14789 -> 14787;
14789 -> 14788;
14790 -> 14789;
14790 -> 14788;
14791 -> 14788;
14792 -> 14790;
14792 -> 14788;
14793 -> 14788;
14794 -> 14791;
14794 -> 14793;
14795 -> 14791;
14795 -> 14793;
14796 -> 14792;
14796 -> 14793;
14797 -> 14791;
14797 -> 14793;
14798 -> 14793;
14799 -> 14758;
14799 -> 14798;
14799 -> 14793;
14800 -> 14797;
14800 -> 14793;
14801 -> 14800;
14802 -> 14794;
14802 -> 14801;
14802 -> 14800;
14803 -> 14800;
14804 -> 14795;
14804 -> 14803;
14804 -> 14800;
14805 -> 14758;
14805 -> 14793;
14806 -> 14793;
14807 -> 14806;
14807 -> 14793;
14808 -> 14796;
14808 -> 14793;
14809 -> 14794;
14809 -> 14793;
14810 -> 14795;
14810 -> 14793;
14811 -> 14793;
14812 -> 14793;
14813 -> 14807;
14813 -> 14812;
14814 -> 14808;
14814 -> 14812;
14815 -> 14809;
14815 -> 14812;
14816 -> 14810;
14816 -> 14812;
14817 -> 14811;
14817 -> 14812;
14818 -> 14813;
14818 -> 14812;
14819 -> 14814;
14819 -> 14812;
14820 -> 14812;
14821 -> 14815;
14821 -> 14812;
14822 -> 14816;
14822 -> 14812;
14823 -> 14812;
14824 -> 14823;
14824 -> 14812;
14825 -> 14823;
14825 -> 14812;
14826 -> 0;
14826 -> 14812;
14827 -> 14811;
14827 -> 14793;
14828 -> 14793;
14829 -> 14827;
14829 -> 14828;
14830 -> 14829;
14830 -> 14828;
14831 -> 14828;
14832 -> 14830;
14832 -> 14831;
14833 -> 14831;
14834 -> 14832;
14834 -> 14833;
14835 -> 14833;
14836 -> 14834;
14836 -> 14835;
14837 -> 14836;
14837 -> 14758;
14837 -> 14835;
14838 -> 14836;
14838 -> 14758;
14838 -> 14824;
14838 -> 14825;
14838 -> 14835;
14839 -> 0;
14839 -> 14835;
14840 -> 14835;
14841 -> 14758;
14841 -> 14840;
14842 -> 14840;
14843 -> 14841;
14843 -> 14842;
14844 -> 14840;
14845 -> 14843;
14845 -> 14844;
14846 -> 14844;
14847 -> 14846;
14847 -> 14835;
14848 -> 14838;
14848 -> 14847;
14848 -> 14835;
14849 -> 0;
14849 -> 14835;
14850 -> 14758;
14851 -> 14850;
14851 -> 0;
14851 -> 14758;
14852 -> 14776;
14852 -> 14775;
14853 -> 14835;
14854 -> 14758;
14854 -> 14853;
14855 -> 14853;
14856 -> 14854;
14856 -> 14855;
14857 -> 14853;
14858 -> 14856;
14858 -> 14857;
14859 -> 14857;
14860 -> 14859;
14860 -> 14857;
14861 -> 14857;
14862 -> 14860;
14862 -> 14861;
14863 -> 14858;
14863 -> 14861;
14864 -> 14861;
14865 -> 14863;
14865 -> 14864;
14866 -> 14865;
14866 -> 14758;
14866 -> 14864;
14867 -> 14866;
14867 -> 14861;
14868 -> 14861;
14869 -> 14863;
14869 -> 14868;
14870 -> 14869;
14870 -> 14758;
14870 -> 14868;
14871 -> 14870;
14871 -> 14861;
14872 -> 14861;
14873 -> 14871;
14873 -> 14872;
14874 -> 0;
14874 -> 14872;
14875 -> 14874;
14875 -> 14861;
14876 -> 14867;
14876 -> 14875;
14876 -> 14861;
14877 -> 14861;
14878 -> 14863;
14878 -> 14877;
14879 -> 14877;
14880 -> 14878;
14880 -> 14879;
14881 -> 14880;
14881 -> 14758;
14881 -> 14879;
14882 -> 14877;
14883 -> 14881;
14883 -> 14861;
14884 -> 14861;
14885 -> 14883;
14885 -> 14884;
14886 -> 14884;
14887 -> 14884;
14888 -> 14861;
14889 -> 14885;
14889 -> 14888;
14890 -> 14888;
14891 -> 14890;
14891 -> 14861;
14892 -> 14861;
14893 -> 14876;
14893 -> 14891;
14893 -> 14861;
14894 -> 14861;
14895 -> 14861;
14896 -> 14895;
14896 -> 14835;
14897 -> 14836;
14897 -> 14758;
14897 -> 14896;
14897 -> 14835;
14898 -> 14758;
14898 -> 14835;
14899 -> 14835;
14900 -> 14898;
14900 -> 14899;
14901 -> 14836;
14901 -> 14899;
14902 -> 14901;
14902 -> 14758;
14902 -> 14899;
14903 -> 0;
14903 -> 14899;
14904 -> 14835;
14905 -> 14758;
14905 -> 14835;
14906 -> 14835;
14907 -> 14905;
14907 -> 14906;
14908 -> 14836;
14908 -> 14906;
14909 -> 14906;
14910 -> 14907;
14910 -> 14909;
14911 -> 14909;
14912 -> 14909;
14913 -> 14910;
14913 -> 14912;
14914 -> 14912;
14915 -> 14913;
14915 -> 14758;
14915 -> 14914;
14916 -> 14915;
14916 -> 14912;
14917 -> 14916;
14917 -> 14906;
14918 -> 14908;
14918 -> 14758;
14918 -> 14917;
14918 -> 14906;
14919 -> 14835;
14920 -> 14919;
14921 -> 14919;
14922 -> 14758;
14922 -> 14921;
14923 -> 14922;
14923 -> 14758;
14923 -> 14921;
14924 -> 14919;
14925 -> 14924;
14926 -> 14925;
14927 -> 14835;
14928 -> 14923;
14928 -> 14927;
14929 -> 14836;
14929 -> 14927;
14930 -> 14928;
14930 -> 14927;
14931 -> 14927;
14932 -> 14930;
14932 -> 14931;
14932 -> 14927;
14933 -> 14929;
14933 -> 14758;
14933 -> 0;
14933 -> 14927;
14934 -> 14927;
14935 -> 14930;
14935 -> 14934;
14936 -> 14934;
14937 -> 14935;
14937 -> 14758;
14937 -> 14936;
14938 -> 14936;
14939 -> 14938;
14939 -> 14927;
14940 -> 14939;
14940 -> 14835;
14941 -> 14940;
14942 -> 14923;
14942 -> 14941;
14943 -> 14942;
14943 -> 14758;
14943 -> 14941;
14944 -> 14941;
14944 -> 14940;
14945 -> 14944;
14945 -> 14940;
14946 -> 14945;
14947 -> 14946;
14948 -> 14946;
14949 -> 14947;
14949 -> 14948;
14950 -> 14947;
14950 -> 14948;
14951 -> 14949;
14951 -> 14948;
14952 -> 14948;
14953 -> 14952;
14953 -> 14948;
14954 -> 14952;
14954 -> 14948;
14955 -> 14947;
14955 -> 14945;
14956 -> 14945;
14957 -> 14956;
14958 -> 14758;
14958 -> 14957;
14959 -> 14758;
14959 -> 14957;
14960 -> 14923;
14960 -> 14758;
14961 -> 14758;
14962 -> 14960;
14962 -> 14758;
14963 -> 14758;
14964 -> 14962;
14964 -> 14963;
14964 -> 14758;
14965 -> 14961;
14965 -> 14758;
14965 -> 0;
14966 -> 14962;
14966 -> 14758;
14967 -> 14966;
14967 -> 14758;
14968 -> 14758;
14969 -> 14758;
14970 -> 14966;
14970 -> 14758;
14971 -> 14923;
14971 -> 14758;
14972 -> 14971;
14972 -> 14758;
14973 -> 14971;
14973 -> 14923;
14973 -> 14758;
14974 -> 14957;
14975 -> 14923;
14975 -> 14974;
14976 -> 14975;
14976 -> 14923;
14976 -> 14974;
14977 -> 14974;
14977 -> 14957;
14978 -> 0;
14978 -> 14977;
14979 -> 14977;
14980 -> 14979;
14981 -> 14979;
14982 -> 14977;
14983 -> 14978;
14983 -> 14982;
14984 -> 14982;
14985 -> 14983;
14985 -> 14982;
14986 -> 14956;
14987 -> 14956;
14988 -> 14945;
14989 -> 14945;
14990 -> 14923;
14990 -> 14989;
14991 -> 14990;
14991 -> 14923;
14991 -> 14989;
14992 -> 14989;
14992 -> 14945;
14993 -> 14945;
14994 -> 14836;
14994 -> 14993;
14995 -> 0;
14995 -> 14993;
14996 -> 14993;
14997 -> 14993;
14998 -> 14995;
14998 -> 14997;
14999 -> 14996;
14999 -> 14997;
15000 -> 14994;
15000 -> 14997;
15001 -> 14997;
15002 -> 14998;
15002 -> 14997;
15003 -> 14999;
15003 -> 14997;
15004 -> 14945;
15005 -> 14836;
15005 -> 14923;
15005 -> 0;
15005 -> 14835;
15006 -> 15005;
15007 -> 14758;
15007 -> 15006;
15008 -> 15006;
15009 -> 15007;
15009 -> 15008;
15010 -> 15009;
15010 -> 15006;
15011 -> 15006;
15012 -> 15010;
15012 -> 15011;
15013 -> 15006;
15014 -> 15012;
15014 -> 15013;
15015 -> 15014;
15015 -> 15013;
15016 -> 15013;
15017 -> 15015;
15017 -> 15016;
15018 -> 15017;
15018 -> 15005;
15019 -> 15005;
15020 -> 15018;
15020 -> 15019;
15021 -> 14836;
15021 -> 15019;
15022 -> 15020;
15022 -> 15019;
15023 -> 15022;
15024 -> 14835;
15025 -> 14836;
15025 -> 15024;
15026 -> 15024;
15027 -> 14758;
15027 -> 15026;
15028 -> 15026;
15029 -> 15027;
15029 -> 15028;
15030 -> 15029;
15030 -> 14923;
15030 -> 15028;
15031 -> 15026;
15032 -> 15030;
15032 -> 15031;
15033 -> 15031;
15034 -> 15033;
15034 -> 15024;
15035 -> 15034;
15036 -> 14758;
15036 -> 15035;
15037 -> 15035;
15038 -> 15036;
15038 -> 15037;
15039 -> 15038;
15039 -> 14923;
15039 -> 15037;
15040 -> 15035;
15041 -> 15039;
15041 -> 15040;
15042 -> 15040;
15043 -> 15042;
15043 -> 15040;
15044 -> 15040;
15045 -> 15043;
15045 -> 15044;
15046 -> 15041;
15046 -> 15044;
15047 -> 15044;
15048 -> 15046;
15048 -> 15047;
15049 -> 15048;
15049 -> 14923;
15049 -> 15047;
15050 -> 15049;
15050 -> 15044;
15051 -> 15044;
15052 -> 15046;
15052 -> 15051;
15053 -> 15052;
15053 -> 15044;
15054 -> 15044;
15055 -> 15053;
15055 -> 15054;
15056 -> 0;
15056 -> 15054;
15057 -> 15056;
15057 -> 15044;
15058 -> 15050;
15058 -> 15057;
15058 -> 15044;
15059 -> 15044;
15060 -> 15046;
15060 -> 15059;
15061 -> 15059;
15062 -> 15059;
15063 -> 15060;
15063 -> 15044;
15064 -> 15044;
15065 -> 15063;
15065 -> 15064;
15066 -> 15064;
15067 -> 15064;
15068 -> 15044;
15069 -> 15065;
15069 -> 15068;
15070 -> 15068;
15071 -> 15070;
15071 -> 15044;
15072 -> 15044;
15073 -> 15058;
15073 -> 15071;
15073 -> 15044;
15074 -> 15044;
15075 -> 15044;
15076 -> 15075;
15076 -> 15034;
15077 -> 15024;
15078 -> 14758;
15078 -> 15024;
15079 -> 15078;
15080 -> 14758;
15080 -> 15079;
15081 -> 15080;
15081 -> 14923;
15081 -> 15079;
15082 -> 15081;
15082 -> 15078;
15083 -> 15082;
15083 -> 15024;
15084 -> 15024;
15085 -> 15083;
15085 -> 15084;
15085 -> 15024;
15086 -> 15082;
15086 -> 15085;
15087 -> 15085;
15088 -> 15086;
15088 -> 15087;
15088 -> 15085;
15089 -> 15082;
15089 -> 15088;
15090 -> 15088;
15091 -> 15089;
15091 -> 15090;
15091 -> 15088;
15092 -> 15024;
15093 -> 15092;
15094 -> 15093;
15095 -> 15093;
15096 -> 14923;
15096 -> 15095;
15097 -> 15095;
15098 -> 15096;
15098 -> 14923;
15098 -> 15097;
15099 -> 15098;
15099 -> 15095;
15100 -> 15024;
15101 -> 15077;
15101 -> 15100;
15101 -> 15024;
15102 -> 15101;
15103 -> 15102;
15104 -> 15102;
15105 -> 15104;
15106 -> 0;
15106 -> 15024;
15107 -> 15099;
15108 -> 15025;
15108 -> 15099;
15109 -> 15108;
15109 -> 14923;
15109 -> 15099;
15110 -> 15025;
15110 -> 15099;
15110 -> 15024;
15111 -> 0;
15111 -> 15024;
15112 -> 15110;
15113 -> 14758;
15113 -> 15112;
15114 -> 15112;
15115 -> 15113;
15115 -> 15114;
15116 -> 15115;
15116 -> 15099;
15116 -> 15114;
15117 -> 15116;
15117 -> 15112;
15118 -> 15112;
15119 -> 15117;
15119 -> 15118;
15120 -> 15118;
15121 -> 15119;
15121 -> 15099;
15121 -> 15120;
15122 -> 15121;
15122 -> 15118;
15123 -> 15122;
15123 -> 15110;
15124 -> 15110;
15125 -> 15025;
15125 -> 15099;
15125 -> 15110;
15126 -> 0;
15126 -> 15110;
15127 -> 15082;
15127 -> 15123;
15128 -> 15123;
15129 -> 14758;
15129 -> 15128;
15130 -> 15128;
15131 -> 15129;
15131 -> 15130;
15132 -> 15128;
15133 -> 15131;
15133 -> 15132;
15134 -> 15133;
15134 -> 15099;
15134 -> 15132;
15135 -> 15134;
15135 -> 15123;
15136 -> 15127;
15136 -> 15135;
15136 -> 15123;
15137 -> 15082;
15137 -> 15136;
15138 -> 15136;
15139 -> 15137;
15139 -> 15138;
15140 -> 15025;
15140 -> 15138;
15141 -> 15140;
15141 -> 15099;
15141 -> 15138;
15142 -> 0;
15142 -> 15138;
15143 -> 15141;
15144 -> 15139;
15144 -> 15143;
15144 -> 15141;
15145 -> 15144;
15146 -> 15145;
15146 -> 15144;
15147 -> 15144;
15148 -> 14758;
15148 -> 15136;
15149 -> 15146;
15149 -> 15136;
15150 -> 15136;
15151 -> 15148;
15151 -> 15150;
15152 -> 15149;
15152 -> 15150;
15153 -> 15025;
15153 -> 15150;
15154 -> 15150;
15155 -> 15154;
15155 -> 15150;
15156 -> 15150;
15157 -> 15151;
15157 -> 15156;
15158 -> 15156;
15159 -> 15157;
15159 -> 15158;
15160 -> 15159;
15160 -> 15146;
15160 -> 15158;
15161 -> 15156;
15162 -> 15160;
15162 -> 15161;
15163 -> 15161;
15164 -> 15162;
15164 -> 15163;
15165 -> 15164;
15165 -> 15161;
15166 -> 15161;
15166 -> 15150;
15167 -> 15166;
15168 -> 15151;
15168 -> 15167;
15169 -> 15168;
15169 -> 15146;
15169 -> 15167;
15170 -> 15168;
15170 -> 15146;
15170 -> 15169;
15171 -> 15169;
15172 -> 15171;
15172 -> 15169;
15173 -> 15169;
15174 -> 15172;
15174 -> 15173;
15175 -> 15169;
15176 -> 15174;
15176 -> 15175;
15177 -> 15176;
15177 -> 15175;
15178 -> 15175;
15179 -> 15177;
15179 -> 15178;
15180 -> 15178;
15181 -> 15179;
15181 -> 15180;
15182 -> 15181;
15182 -> 15177;
15182 -> 15180;
15183 -> 15181;
15183 -> 15178;
15184 -> 15179;
15184 -> 15178;
15185 -> 15178;
15186 -> 15184;
15186 -> 15185;
15187 -> 15185;
15188 -> 15186;
15188 -> 15187;
15189 -> 15188;
15189 -> 15177;
15189 -> 15187;
15190 -> 15186;
15190 -> 15177;
15190 -> 15185;
15191 -> 15185;
15192 -> 15188;
15192 -> 15191;
15193 -> 15190;
15193 -> 15191;
15194 -> 15193;
15194 -> 0;
15194 -> 15191;
15195 -> 15193;
15195 -> 15191;
15196 -> 15192;
15196 -> 15191;
15197 -> 15191;
15198 -> 15191;
15198 -> 15178;
15199 -> 15178;
15200 -> 15198;
15200 -> 15199;
15201 -> 15183;
15201 -> 15199;
15202 -> 15199;
15203 -> 15201;
15203 -> 15202;
15204 -> 9146;
15204 -> 15202;
15205 -> 15204;
15205 -> 15202;
15206 -> 15205;
15206 -> 0;
15206 -> 15202;
15207 -> 15205;
15207 -> 15202;
15208 -> 15203;
15208 -> 15202;
15209 -> 15202;
15210 -> 15202;
15210 -> 15199;
15211 -> 15200;
15211 -> 15210;
15211 -> 15199;
15212 -> 15211;
15213 -> 15201;
15213 -> 15212;
15214 -> 15213;
15215 -> 15214;
15215 -> 15213;
15216 -> 15213;
15217 -> 15214;
15217 -> 15216;
15218 -> 9146;
15218 -> 15216;
15219 -> 15218;
15219 -> 15216;
15220 -> 15219;
15220 -> 0;
15220 -> 15216;
15221 -> 15219;
15221 -> 15216;
15222 -> 15217;
15222 -> 15216;
15223 -> 15216;
15224 -> 15216;
15224 -> 15213;
15225 -> 15213;
15226 -> 15213;
15227 -> 15215;
15227 -> 15226;
15228 -> 15224;
15228 -> 15226;
15229 -> 15225;
15229 -> 15226;
15230 -> 15228;
15230 -> 15226;
15231 -> 15226;
15232 -> 15230;
15232 -> 15231;
15233 -> 15229;
15233 -> 15231;
15234 -> 15231;
15235 -> 15233;
15235 -> 15234;
15236 -> 15229;
15236 -> 15231;
15237 -> 15229;
15237 -> 15226;
15238 -> 15229;
15238 -> 15226;
15239 -> 15227;
15239 -> 15226;
15240 -> 15227;
15240 -> 15229;
15240 -> 15226;
15241 -> 15213;
15241 -> 15225;
15241 -> 15232;
15241 -> 15240;
15241 -> 15238;
15241 -> 15239;
15242 -> 15241;
15242 -> 15211;
15243 -> 15169;
15244 -> 15168;
15244 -> 15242;
15244 -> 15167;
15245 -> 15244;
15245 -> 15166;
15246 -> 15150;
15247 -> 15245;
15247 -> 15242;
15247 -> 15246;
15247 -> 15150;
15248 -> 15153;
15248 -> 15242;
15248 -> 15150;
15249 -> 0;
15249 -> 15150;
15250 -> 15247;
15250 -> 15248;
15250 -> 15150;
15251 -> 0;
15251 -> 15250;
15252 -> 15250;
15253 -> 15251;
15253 -> 15252;
15254 -> 15250;
15255 -> 15250;
15256 -> 15250;
15257 -> 15245;
15257 -> 15256;
15257 -> 15242;
15257 -> 15253;
15258 -> 15255;
15258 -> 15256;
15259 -> 15256;
15260 -> 15256;
15261 -> 15256;
15262 -> 15257;
15262 -> 15261;
15263 -> 15261;
15264 -> 15262;
15264 -> 15263;
15265 -> 15264;
15265 -> 15257;
15265 -> 15263;
15266 -> 15265;
15266 -> 15261;
15267 -> 0;
15267 -> 15261;
15268 -> 15267;
15268 -> 15256;
15269 -> 15153;
15269 -> 15257;
15269 -> 15268;
15270 -> 15268;
15271 -> 15269;
15271 -> 15270;
15272 -> 15269;
15272 -> 15270;
15273 -> 15270;
15273 -> 15268;
15274 -> 15272;
15274 -> 15256;
15275 -> 15256;
15276 -> 15274;
15276 -> 15275;
15277 -> 15257;
15277 -> 15275;
15278 -> 15276;
15278 -> 15275;
15279 -> 15277;
15279 -> 15275;
15280 -> 15279;
15280 -> 15275;
15281 -> 15275;
15282 -> 15280;
15282 -> 15281;
15283 -> 15278;
15283 -> 15281;
15284 -> 15282;
15284 -> 15281;
15285 -> 15281;
15286 -> 15284;
15286 -> 15285;
15287 -> 15283;
15287 -> 15285;
15288 -> 15286;
15288 -> 15285;
15289 -> 15287;
15289 -> 15272;
15289 -> 15285;
15290 -> 15285;
15291 -> 15288;
15291 -> 15290;
15292 -> 15289;
15292 -> 15290;
15293 -> 15287;
15293 -> 15290;
15294 -> 15291;
15294 -> 15290;
15295 -> 15290;
15296 -> 15294;
15296 -> 15295;
15297 -> 15293;
15297 -> 15295;
15298 -> 15295;
15299 -> 15295;
15300 -> 15297;
15300 -> 15299;
15301 -> 15300;
15301 -> 15272;
15301 -> 15299;
15302 -> 15299;
15303 -> 15301;
15303 -> 15302;
15303 -> 15299;
15304 -> 15299;
15305 -> 15300;
15305 -> 15304;
15306 -> 15305;
15306 -> 15272;
15306 -> 15304;
15307 -> 15306;
15308 -> 15307;
15308 -> 15299;
15309 -> 15300;
15309 -> 15272;
15309 -> 15299;
15310 -> 15308;
15310 -> 15299;
15311 -> 15299;
15312 -> 15310;
15312 -> 15295;
15313 -> 15296;
15313 -> 15295;
15314 -> 15298;
15314 -> 15295;
15315 -> 15312;
15315 -> 15313;
15315 -> 15314;
15315 -> 15310;
15315 -> 15295;
15316 -> 15315;
15316 -> 15295;
15317 -> 15290;
15318 -> 15316;
15318 -> 15317;
15318 -> 15290;
15319 -> 15290;
15320 -> 15319;
15320 -> 15285;
15321 -> 15287;
15321 -> 15315;
15321 -> 15285;
15322 -> 0;
15322 -> 15285;
15323 -> 15286;
15323 -> 15285;
15324 -> 15285;
15325 -> 15323;
15325 -> 15324;
15326 -> 15325;
15326 -> 15315;
15326 -> 15324;
15327 -> 15325;
15327 -> 15315;
15327 -> 15326;
15328 -> 15326;
15329 -> 15328;
15329 -> 15326;
15330 -> 15326;
15331 -> 15329;
15331 -> 15330;
15332 -> 15331;
15332 -> 15315;
15332 -> 15330;
15333 -> 15331;
15333 -> 15330;
15334 -> 15330;
15335 -> 15333;
15335 -> 15334;
15336 -> 15335;
15336 -> 15315;
15336 -> 15334;
15337 -> 15333;
15337 -> 15315;
15337 -> 15330;
15338 -> 15337;
15338 -> 15330;
15339 -> 15338;
15339 -> 0;
15339 -> 15330;
15340 -> 15338;
15340 -> 15330;
15341 -> 15335;
15341 -> 15330;
15342 -> 15341;
15342 -> 0;
15342 -> 15330;
15343 -> 15342;
15343 -> 15330;
15344 -> 9146;
15344 -> 15330;
15345 -> 15344;
15345 -> 15330;
15346 -> 15345;
15346 -> 0;
15346 -> 15330;
15347 -> 15345;
15347 -> 15330;
15348 -> 15331;
15348 -> 15330;
15349 -> 15348;
15349 -> 0;
15349 -> 15330;
15350 -> 15349;
15350 -> 15330;
15351 -> 9146;
15351 -> 15331;
15352 -> 15351;
15352 -> 15331;
15353 -> 15352;
15353 -> 0;
15353 -> 15331;
15354 -> 15352;
15354 -> 15331;
15355 -> 15331;
15356 -> 15355;
15356 -> 0;
15356 -> 15331;
15357 -> 15356;
15357 -> 15331;
15358 -> 15331;
15359 -> 15358;
15360 -> 15331;
15361 -> 15331;
15362 -> 15331;
15363 -> 15331;
15364 -> 15331;
15365 -> 15363;
15365 -> 15364;
15366 -> 15364;
15367 -> 15365;
15367 -> 15366;
15367 -> 15364;
15368 -> 15365;
15368 -> 15364;
15369 -> 15364;
15369 -> 15331;
15370 -> 15326;
15371 -> 15325;
15371 -> 15331;
15371 -> 15324;
15372 -> 15371;
15372 -> 15285;
15373 -> 15285;
15374 -> 15372;
15374 -> 15373;
15375 -> 15373;
15376 -> 15374;
15376 -> 15375;
15377 -> 15376;
15377 -> 15373;
15378 -> 15373;
15378 -> 15285;
15379 -> 15287;
15379 -> 15331;
15379 -> 15285;
15380 -> 15285;
15381 -> 15379;
15381 -> 15380;
15382 -> 15372;
15382 -> 15380;
15383 -> 15381;
15383 -> 15331;
15383 -> 15380;
15384 -> 15381;
15384 -> 15331;
15384 -> 15380;
15385 -> 0;
15385 -> 15380;
15386 -> 15380;
15387 -> 15382;
15387 -> 15386;
15388 -> 15386;
15389 -> 15387;
15389 -> 15388;
15390 -> 15386;
15391 -> 15389;
15391 -> 15390;
15392 -> 15390;
15393 -> 15392;
15393 -> 15380;
15394 -> 15384;
15394 -> 15393;
15394 -> 15380;
15395 -> 15382;
15395 -> 15381;
15396 -> 15380;
15397 -> 15382;
15397 -> 15396;
15398 -> 15396;
15399 -> 15397;
15399 -> 15398;
15400 -> 15399;
15400 -> 15395;
15400 -> 15398;
15401 -> 15396;
15402 -> 15400;
15402 -> 15401;
15403 -> 15401;
15404 -> 15403;
15404 -> 15401;
15405 -> 15404;
15405 -> 15401;
15406 -> 15402;
15406 -> 15401;
15407 -> 15401;
15408 -> 15406;
15408 -> 15407;
15409 -> 15407;
15410 -> 15409;
15410 -> 15401;
15411 -> 15401;
15412 -> 15406;
15412 -> 15411;
15413 -> 15412;
15413 -> 15401;
15414 -> 15401;
15415 -> 15413;
15415 -> 15414;
15416 -> 15414;
15416 -> 15401;
15417 -> 15410;
15417 -> 15416;
15417 -> 15401;
15418 -> 15401;
15419 -> 15406;
15419 -> 15418;
15420 -> 15419;
15420 -> 15401;
15421 -> 15401;
15422 -> 15420;
15422 -> 15421;
15423 -> 15401;
15424 -> 15422;
15424 -> 15423;
15425 -> 15423;
15425 -> 15401;
15426 -> 15401;
15427 -> 15417;
15427 -> 15425;
15427 -> 15401;
15428 -> 15401;
15429 -> 15406;
15429 -> 15428;
15430 -> 15429;
15430 -> 15401;
15431 -> 15430;
15431 -> 2687;
15431 -> 15401;
15432 -> 15427;
15432 -> 15431;
15432 -> 15401;
15433 -> 15401;
15434 -> 15401;
15434 -> 15380;
15435 -> 15381;
15435 -> 15395;
15435 -> 15434;
15435 -> 15380;
15436 -> 15382;
15436 -> 15380;
15437 -> 15380;
15438 -> 15436;
15438 -> 15437;
15439 -> 15381;
15439 -> 15437;
15440 -> 15439;
15440 -> 15395;
15440 -> 15437;
15441 -> 15380;
15442 -> 15382;
15442 -> 15380;
15443 -> 15380;
15444 -> 15442;
15444 -> 15443;
15445 -> 15381;
15445 -> 15443;
15446 -> 15445;
15446 -> 15395;
15446 -> 15443;
15447 -> 15446;
15447 -> 15380;
15448 -> 15395;
15448 -> 15380;
15449 -> 15381;
15449 -> 15380;
15450 -> 15448;
15450 -> 15380;
15451 -> 15380;
15452 -> 15450;
15452 -> 15451;
15452 -> 15380;
15453 -> 15449;
15453 -> 15395;
15453 -> 0;
15453 -> 15380;
15454 -> 15450;
15454 -> 15380;
15455 -> 15454;
15455 -> 15395;
15455 -> 15380;
15456 -> 15395;
15456 -> 15380;
15457 -> 15456;
15457 -> 15395;
15457 -> 15380;
15458 -> 15395;
15458 -> 15380;
15459 -> 15395;
15459 -> 15380;
15460 -> 15395;
15461 -> 15395;
15462 -> 15460;
15462 -> 15395;
15463 -> 15395;
15464 -> 15462;
15464 -> 15463;
15464 -> 15395;
15465 -> 15461;
15465 -> 15395;
15465 -> 0;
15466 -> 15462;
15466 -> 15395;
15467 -> 15466;
15467 -> 15395;
15468 -> 15381;
15468 -> 15395;
15468 -> 0;
15468 -> 15380;
15469 -> 15468;
15470 -> 15382;
15470 -> 15469;
15471 -> 15469;
15472 -> 15470;
15472 -> 15471;
15473 -> 15472;
15473 -> 15469;
15474 -> 15469;
15475 -> 15473;
15475 -> 15474;
15476 -> 15469;
15477 -> 15475;
15477 -> 15476;
15478 -> 15477;
15478 -> 15476;
15479 -> 15476;
15480 -> 15478;
15480 -> 15479;
15481 -> 15480;
15481 -> 15468;
15482 -> 15468;
15483 -> 15481;
15483 -> 15482;
15484 -> 15381;
15484 -> 15482;
15485 -> 15483;
15485 -> 15482;
15486 -> 15485;
15487 -> 15380;
15488 -> 15382;
15488 -> 15487;
15489 -> 15487;
15490 -> 15488;
15490 -> 15489;
15491 -> 15490;
15491 -> 15395;
15491 -> 15489;
15492 -> 15487;
15493 -> 15491;
15493 -> 15492;
15494 -> 15492;
15495 -> 15494;
15495 -> 15380;
15496 -> 15495;
15497 -> 15382;
15497 -> 15496;
15498 -> 15496;
15499 -> 15497;
15499 -> 15498;
15500 -> 15499;
15500 -> 15395;
15500 -> 15498;
15501 -> 15496;
15502 -> 15500;
15502 -> 15501;
15503 -> 15501;
15504 -> 15503;
15504 -> 15501;
15505 -> 15504;
15505 -> 15501;
15506 -> 15502;
15506 -> 15501;
15507 -> 15501;
15508 -> 15506;
15508 -> 15507;
15509 -> 15507;
15510 -> 15509;
15510 -> 15501;
15511 -> 15501;
15512 -> 15506;
15512 -> 15511;
15513 -> 15512;
15513 -> 15501;
15514 -> 15501;
15515 -> 15513;
15515 -> 15514;
15516 -> 15514;
15516 -> 15501;
15517 -> 15510;
15517 -> 15516;
15517 -> 15501;
15518 -> 15501;
15519 -> 15506;
15519 -> 15518;
15520 -> 15519;
15520 -> 15501;
15521 -> 15501;
15522 -> 15520;
15522 -> 15521;
15523 -> 15501;
15524 -> 15522;
15524 -> 15523;
15525 -> 15523;
15525 -> 15501;
15526 -> 15501;
15527 -> 15517;
15527 -> 15525;
15527 -> 15501;
15528 -> 15501;
15529 -> 15506;
15529 -> 15528;
15530 -> 15529;
15530 -> 15501;
15531 -> 15530;
15531 -> 2687;
15531 -> 15501;
15532 -> 15527;
15532 -> 15531;
15532 -> 15501;
15533 -> 15501;
15534 -> 15501;
15534 -> 15495;
15535 -> 15395;
15535 -> 15380;
15536 -> 15380;
15537 -> 15535;
15537 -> 15536;
15537 -> 15380;
15538 -> 15395;
15538 -> 15537;
15539 -> 15537;
15540 -> 15538;
15540 -> 15539;
15540 -> 15537;
15541 -> 15395;
15541 -> 15540;
15542 -> 15540;
15543 -> 15541;
15543 -> 15542;
15543 -> 15540;
15544 -> 0;
15544 -> 15395;
15545 -> 15544;
15546 -> 15381;
15546 -> 15544;
15547 -> 15546;
15547 -> 15395;
15547 -> 15544;
15548 -> 15544;
15549 -> 15382;
15549 -> 15544;
15550 -> 15544;
15551 -> 15549;
15551 -> 15550;
15552 -> 15381;
15552 -> 15550;
15553 -> 15551;
15553 -> 15550;
15554 -> 15550;
15555 -> 15553;
15555 -> 15554;
15556 -> 15552;
15556 -> 15554;
15557 -> 15556;
15557 -> 15544;
15557 -> 15554;
15558 -> 15557;
15558 -> 15550;
15559 -> 15544;
15560 -> 15380;
15561 -> 15395;
15561 -> 15560;
15562 -> 15561;
15562 -> 15380;
15563 -> 15382;
15563 -> 15380;
15564 -> 15380;
15565 -> 15563;
15565 -> 15564;
15566 -> 15381;
15566 -> 15564;
15567 -> 15565;
15567 -> 15564;
15568 -> 15564;
15569 -> 15567;
15569 -> 15568;
15570 -> 15566;
15570 -> 15568;
15571 -> 15568;
15572 -> 15569;
15572 -> 15571;
15573 -> 15572;
15573 -> 15544;
15573 -> 15571;
15574 -> 15573;
15574 -> 15568;
15575 -> 15570;
15575 -> 15544;
15575 -> 15574;
15576 -> 0;
15576 -> 15574;
15577 -> 15568;
15578 -> 15577;
15578 -> 15564;
15579 -> 15380;
15580 -> 15285;
15581 -> 15286;
15581 -> 15285;
15582 -> 15285;
15583 -> 15581;
15583 -> 15582;
15583 -> 15285;
15584 -> 15581;
15584 -> 15372;
15584 -> 15285;
15585 -> 15287;
15585 -> 15544;
15585 -> 15584;
15586 -> 15585;
15587 -> 15581;
15587 -> 15586;
15588 -> 15586;
15589 -> 15587;
15589 -> 15544;
15589 -> 15588;
15590 -> 15586;
15591 -> 15589;
15591 -> 15590;
15592 -> 15591;
15592 -> 15585;
15593 -> 15585;
15594 -> 15585;
15595 -> 15592;
15595 -> 15594;
15596 -> 15593;
15596 -> 15594;
15597 -> 15593;
15597 -> 15594;
15598 -> 15287;
15598 -> 15594;
15599 -> 15598;
15599 -> 15544;
15599 -> 15594;
15600 -> 0;
15600 -> 15594;
15601 -> 15599;
15601 -> 15595;
15601 -> 15544;
15601 -> 15594;
15602 -> 15581;
15602 -> 15584;
15603 -> 15584;
15604 -> 15602;
15604 -> 15603;
15605 -> 15287;
15605 -> 15603;
15606 -> 15605;
15606 -> 15544;
15606 -> 15603;
15607 -> 0;
15607 -> 15603;
15608 -> 0;
15608 -> 15603;
15609 -> 15603;
15610 -> 15608;
15610 -> 15609;
15611 -> 15605;
15611 -> 15609;
15612 -> 15611;
15612 -> 15544;
15612 -> 15610;
15613 -> 15603;
15614 -> 15603;
15615 -> 15604;
15615 -> 15614;
15616 -> 15614;
15617 -> 15615;
15617 -> 15612;
15617 -> 15616;
15618 -> 15616;
15618 -> 15603;
15619 -> 15603;
15620 -> 15618;
15621 -> 15604;
15621 -> 15620;
15622 -> 15620;
15623 -> 15621;
15623 -> 15612;
15623 -> 15622;
15624 -> 15622;
15625 -> 15624;
15625 -> 15618;
15626 -> 15603;
15627 -> 15603;
15628 -> 15604;
15628 -> 15627;
15629 -> 15627;
15630 -> 15628;
15630 -> 15612;
15630 -> 15629;
15631 -> 15629;
15631 -> 15603;
15632 -> 0;
15632 -> 15603;
15633 -> 15603;
15634 -> 15632;
15634 -> 15633;
15635 -> 15605;
15635 -> 15633;
15636 -> 15635;
15636 -> 15612;
15636 -> 15634;
15637 -> 15603;
15638 -> 15584;
15639 -> 15584;
15640 -> 15639;
15640 -> 15636;
15641 -> 15639;
15641 -> 15636;
15642 -> 15641;
15642 -> 15584;
15643 -> 15281;
15644 -> 15282;
15644 -> 15281;
15645 -> 15281;
15646 -> 15644;
15646 -> 15645;
15647 -> 15283;
15647 -> 15645;
15648 -> 15646;
15648 -> 15645;
15649 -> 15645;
15650 -> 15648;
15650 -> 15649;
15651 -> 15647;
15651 -> 15649;
15652 -> 15649;
15653 -> 15650;
15653 -> 15652;
15654 -> 15653;
15654 -> 15636;
15654 -> 15652;
15655 -> 15654;
15655 -> 15649;
15656 -> 15649;
15657 -> 15656;
15657 -> 15645;
15658 -> 15281;
15659 -> 15275;
15660 -> 15256;
15661 -> 15152;
15661 -> 15146;
15661 -> 15256;
15662 -> 15152;
15662 -> 15256;
15662 -> 15146;
15662 -> 15636;
15662 -> 15661;
15663 -> 15661;
15664 -> 15661;
15665 -> 15662;
15665 -> 15664;
15666 -> 15663;
15666 -> 15664;
15667 -> 15663;
15667 -> 15664;
15668 -> 15153;
15668 -> 15664;
15669 -> 15668;
15669 -> 15662;
15669 -> 15664;
15670 -> 0;
15670 -> 15664;
15671 -> 15669;
15671 -> 15665;
15671 -> 15662;
15671 -> 15664;
15672 -> 0;
15672 -> 15250;
15673 -> 15250;
15674 -> 15672;
15674 -> 15673;
15675 -> 15673;
15675 -> 15662;
15675 -> 15674;
15676 -> 15250;
15677 -> 15136;
15678 -> 14758;
15678 -> 15136;
15679 -> 15136;
15680 -> 15678;
15680 -> 15679;
15681 -> 15025;
15681 -> 15679;
15682 -> 15680;
15682 -> 15679;
15683 -> 15679;
15684 -> 15682;
15684 -> 15683;
15685 -> 15681;
15685 -> 15683;
15686 -> 15683;
15687 -> 15684;
15687 -> 15686;
15688 -> 15687;
15688 -> 15675;
15688 -> 15686;
15689 -> 15688;
15689 -> 15683;
15690 -> 15685;
15690 -> 15675;
15690 -> 15689;
15690 -> 15683;
15691 -> 15136;
15692 -> 15136;
15693 -> 14758;
15693 -> 15692;
15694 -> 15693;
15694 -> 15675;
15694 -> 15692;
15695 -> 15693;
15695 -> 15675;
15695 -> 15692;
15696 -> 15695;
15696 -> 15136;
15697 -> 15136;
15698 -> 15696;
15698 -> 15697;
15699 -> 15025;
15699 -> 15697;
15700 -> 15699;
15700 -> 15675;
15700 -> 15697;
15701 -> 0;
15701 -> 15697;
15702 -> 15136;
15703 -> 15024;
15704 -> 15082;
15704 -> 15703;
15705 -> 15704;
15705 -> 15675;
15705 -> 15703;
15706 -> 15705;
15706 -> 15024;
15707 -> 14835;
15708 -> 14833;
15709 -> 14758;
15709 -> 14833;
15710 -> 14833;
15711 -> 15709;
15711 -> 15710;
15712 -> 14834;
15712 -> 15710;
15713 -> 15711;
15713 -> 15710;
15714 -> 15710;
15715 -> 15713;
15715 -> 15714;
15716 -> 15712;
15716 -> 15714;
15717 -> 15714;
15718 -> 15715;
15718 -> 15717;
15719 -> 15718;
15719 -> 15675;
15719 -> 15717;
15720 -> 15719;
15720 -> 15714;
15721 -> 15714;
15722 -> 15721;
15722 -> 15710;
15723 -> 14833;
15724 -> 14831;
15725 -> 14828;
15726 -> 14793;
15727 -> 1;
15728 -> 13797;
15728 -> 1;
15729 -> 1;
15730 -> 15728;
15730 -> 15729;
15731 -> 0;
15731 -> 15729;
15732 -> 15729;
15733 -> 15731;
15733 -> 15732;
15734 -> 15730;
15734 -> 15732;
15735 -> 15732;
15736 -> 15734;
15736 -> 15675;
15736 -> 15735;
15737 -> 9146;
15737 -> 15736;
15738 -> 15737;
15738 -> 15736;
15739 -> 15738;
15739 -> 0;
15739 -> 15736;
15740 -> 15738;
15740 -> 15736;
15741 -> 15736;
15742 -> 15741;
15742 -> 0;
15742 -> 15736;
15743 -> 15736;
15744 -> 15743;
15745 -> 15736;
15746 -> 15736;
15747 -> 15736;
15748 -> 15736;
15749 -> 15736;
15750 -> 15748;
15750 -> 15749;
15751 -> 15749;
15752 -> 15750;
15752 -> 15751;
15752 -> 15749;
15753 -> 15750;
15753 -> 15749;
15754 -> 15749;
15755 -> 15753;
15755 -> 15754;
15756 -> 15755;
15756 -> 15749;
15757 -> 15749;
15757 -> 15736;
15758 -> 15733;
15758 -> 15732;
15759 -> 15732;
15760 -> 15758;
15760 -> 15759;
15761 -> 15760;
15761 -> 15759;
15762 -> 15759;
15763 -> 15761;
15763 -> 15762;
15764 -> 15763;
15764 -> 15762;
15765 -> 15762;
15766 -> 15764;
15766 -> 15762;
15767 -> 15762;
15768 -> 15765;
15768 -> 15767;
15769 -> 15765;
15769 -> 15767;
15770 -> 15766;
15770 -> 15767;
15771 -> 15765;
15771 -> 15767;
15772 -> 15767;
15773 -> 15736;
15773 -> 15772;
15773 -> 15767;
15774 -> 15771;
15774 -> 15767;
15775 -> 15774;
15776 -> 15768;
15776 -> 15775;
15776 -> 15774;
15777 -> 15774;
15778 -> 15769;
15778 -> 15777;
15778 -> 15774;
15779 -> 15736;
15779 -> 15767;
15780 -> 15767;
15781 -> 15780;
15781 -> 15767;
15782 -> 15770;
15782 -> 15767;
15783 -> 15768;
15783 -> 15767;
15784 -> 15769;
15784 -> 15767;
15785 -> 15767;
15786 -> 15767;
15787 -> 15781;
15787 -> 15786;
15788 -> 15782;
15788 -> 15786;
15789 -> 15783;
15789 -> 15786;
15790 -> 15784;
15790 -> 15786;
15791 -> 15785;
15791 -> 15786;
15792 -> 15787;
15792 -> 15786;
15793 -> 15788;
15793 -> 15786;
15794 -> 15786;
15795 -> 15789;
15795 -> 15786;
15796 -> 15790;
15796 -> 15786;
15797 -> 15786;
15798 -> 15797;
15798 -> 15786;
15799 -> 15797;
15799 -> 15786;
15800 -> 0;
15800 -> 15786;
15801 -> 15785;
15801 -> 15767;
15802 -> 15767;
15803 -> 15801;
15803 -> 15802;
15804 -> 15803;
15804 -> 15802;
15805 -> 15802;
15806 -> 15804;
15806 -> 15805;
15807 -> 15805;
15808 -> 15806;
15808 -> 15807;
15809 -> 15807;
15810 -> 15808;
15810 -> 15809;
15811 -> 15810;
15811 -> 15736;
15811 -> 15809;
15812 -> 15810;
15812 -> 15736;
15812 -> 15798;
15812 -> 15799;
15812 -> 15809;
15813 -> 0;
15813 -> 15809;
15814 -> 15809;
15815 -> 15736;
15815 -> 15814;
15816 -> 15814;
15817 -> 15815;
15817 -> 15816;
15818 -> 15814;
15819 -> 15817;
15819 -> 15818;
15820 -> 15818;
15821 -> 15820;
15821 -> 15809;
15822 -> 15812;
15822 -> 15821;
15822 -> 15809;
15823 -> 0;
15823 -> 15809;
15824 -> 15750;
15824 -> 15749;
15825 -> 15809;
15826 -> 15736;
15826 -> 15825;
15827 -> 15825;
15828 -> 15826;
15828 -> 15827;
15829 -> 15825;
15830 -> 15828;
15830 -> 15829;
15831 -> 15829;
15832 -> 15831;
15832 -> 15829;
15833 -> 15829;
15834 -> 15832;
15834 -> 15833;
15835 -> 15830;
15835 -> 15833;
15836 -> 15833;
15837 -> 15835;
15837 -> 15836;
15838 -> 15837;
15838 -> 15833;
15839 -> 15833;
15840 -> 15835;
15840 -> 15839;
15841 -> 15840;
15841 -> 15833;
15842 -> 15833;
15843 -> 15841;
15843 -> 15842;
15844 -> 0;
15844 -> 15842;
15845 -> 15844;
15845 -> 15833;
15846 -> 15838;
15846 -> 15845;
15846 -> 15833;
15847 -> 15833;
15848 -> 15835;
15848 -> 15847;
15849 -> 15847;
15850 -> 15847;
15851 -> 15848;
15851 -> 15833;
15852 -> 15833;
15853 -> 15851;
15853 -> 15852;
15854 -> 15852;
15855 -> 15852;
15856 -> 15833;
15857 -> 15853;
15857 -> 15856;
15858 -> 15856;
15859 -> 15858;
15859 -> 15833;
15860 -> 15833;
15861 -> 15846;
15861 -> 15859;
15861 -> 15833;
15862 -> 15833;
15863 -> 15833;
15864 -> 15863;
15864 -> 15809;
15865 -> 15810;
15865 -> 15736;
15865 -> 15864;
15865 -> 15809;
15866 -> 15736;
15866 -> 15809;
15867 -> 15809;
15868 -> 15866;
15868 -> 15867;
15869 -> 15810;
15869 -> 15867;
15870 -> 15869;
15870 -> 15736;
15870 -> 15867;
15871 -> 0;
15871 -> 15867;
15872 -> 15809;
15873 -> 15736;
15873 -> 15809;
15874 -> 15809;
15875 -> 15873;
15875 -> 15874;
15876 -> 15810;
15876 -> 15874;
15877 -> 15874;
15878 -> 15875;
15878 -> 15877;
15879 -> 15877;
15880 -> 15877;
15881 -> 15880;
15882 -> 15878;
15882 -> 15874;
15883 -> 15876;
15883 -> 15736;
15883 -> 15882;
15883 -> 15874;
15884 -> 15809;
15885 -> 15884;
15886 -> 15884;
15887 -> 15884;
15888 -> 15887;
15889 -> 15888;
15890 -> 15809;
15891 -> 15736;
15891 -> 15890;
15892 -> 15810;
15892 -> 15890;
15893 -> 15891;
15893 -> 15890;
15894 -> 15890;
15895 -> 15893;
15895 -> 15894;
15895 -> 15890;
15896 -> 15892;
15896 -> 15736;
15896 -> 0;
15896 -> 15890;
15897 -> 15890;
15898 -> 15893;
15898 -> 15897;
15899 -> 15897;
15900 -> 15898;
15900 -> 15736;
15900 -> 15899;
15901 -> 15899;
15902 -> 15901;
15902 -> 15890;
15903 -> 15902;
15903 -> 15809;
15904 -> 15903;
15905 -> 15736;
15905 -> 15904;
15906 -> 15905;
15906 -> 15736;
15906 -> 15904;
15907 -> 15904;
15907 -> 15903;
15908 -> 15907;
15908 -> 15903;
15909 -> 15908;
15910 -> 15909;
15911 -> 15909;
15912 -> 15910;
15912 -> 15911;
15913 -> 15910;
15913 -> 15911;
15914 -> 15912;
15914 -> 15911;
15915 -> 15911;
15916 -> 15915;
15916 -> 15911;
15917 -> 15915;
15917 -> 15911;
15918 -> 15910;
15918 -> 15908;
15919 -> 15908;
15920 -> 15919;
15921 -> 15736;
15921 -> 15920;
15922 -> 15736;
15922 -> 15920;
15923 -> 15736;
15924 -> 15736;
15925 -> 15923;
15925 -> 15736;
15926 -> 15736;
15927 -> 15925;
15927 -> 15926;
15927 -> 15736;
15928 -> 15924;
15928 -> 15736;
15928 -> 0;
15929 -> 15925;
15929 -> 15736;
15930 -> 15929;
15930 -> 15736;
15931 -> 15736;
15932 -> 15736;
15933 -> 15929;
15933 -> 15736;
15934 -> 15736;
15935 -> 15934;
15935 -> 15736;
15936 -> 15920;
15937 -> 15736;
15937 -> 15936;
15938 -> 15937;
15938 -> 15736;
15938 -> 15936;
15939 -> 15936;
15939 -> 15920;
15940 -> 0;
15940 -> 15939;
15941 -> 15939;
15942 -> 15941;
15943 -> 15941;
15944 -> 15939;
15945 -> 15940;
15945 -> 15944;
15946 -> 15944;
15947 -> 15945;
15947 -> 15944;
15948 -> 15919;
15949 -> 15919;
15950 -> 15908;
15951 -> 15908;
15952 -> 15736;
15952 -> 15951;
15953 -> 15952;
15953 -> 15736;
15953 -> 15951;
15954 -> 15951;
15954 -> 15908;
15955 -> 15908;
15956 -> 15810;
15956 -> 15955;
15957 -> 0;
15957 -> 15955;
15958 -> 15955;
15959 -> 15955;
15960 -> 15957;
15960 -> 15959;
15961 -> 15958;
15961 -> 15959;
15962 -> 15956;
15962 -> 15959;
15963 -> 15959;
15964 -> 15960;
15964 -> 15959;
15965 -> 15961;
15965 -> 15959;
15966 -> 15908;
15967 -> 15810;
15967 -> 15736;
15967 -> 0;
15967 -> 15809;
15968 -> 15967;
15969 -> 15736;
15969 -> 15968;
15970 -> 15968;
15971 -> 15969;
15971 -> 15970;
15972 -> 15971;
15972 -> 15968;
15973 -> 15968;
15974 -> 15972;
15974 -> 15973;
15975 -> 15968;
15976 -> 15974;
15976 -> 15975;
15977 -> 15976;
15977 -> 15975;
15978 -> 15975;
15979 -> 15977;
15979 -> 15978;
15980 -> 15979;
15980 -> 15967;
15981 -> 15967;
15982 -> 15980;
15982 -> 15981;
15983 -> 15810;
15983 -> 15981;
15984 -> 15982;
15984 -> 15981;
15985 -> 15984;
15986 -> 15809;
15987 -> 15810;
15987 -> 15986;
15988 -> 15986;
15989 -> 15736;
15989 -> 15988;
15990 -> 15988;
15991 -> 15989;
15991 -> 15990;
15992 -> 15988;
15993 -> 15991;
15993 -> 15992;
15994 -> 15992;
15995 -> 15994;
15995 -> 15986;
15996 -> 15995;
15997 -> 15736;
15997 -> 15996;
15998 -> 15996;
15999 -> 15997;
15999 -> 15998;
16000 -> 15996;
16001 -> 15999;
16001 -> 16000;
16002 -> 16000;
16003 -> 16002;
16003 -> 16000;
16004 -> 16000;
16005 -> 16003;
16005 -> 16004;
16006 -> 16001;
16006 -> 16004;
16007 -> 16004;
16008 -> 16006;
16008 -> 16007;
16009 -> 16008;
16009 -> 16004;
16010 -> 16004;
16011 -> 16006;
16011 -> 16010;
16012 -> 16011;
16012 -> 16004;
16013 -> 16004;
16014 -> 16012;
16014 -> 16013;
16015 -> 0;
16015 -> 16013;
16016 -> 16015;
16016 -> 16004;
16017 -> 16009;
16017 -> 16016;
16017 -> 16004;
16018 -> 16004;
16019 -> 16006;
16019 -> 16018;
16020 -> 16018;
16021 -> 16018;
16022 -> 16019;
16022 -> 16004;
16023 -> 16004;
16024 -> 16022;
16024 -> 16023;
16025 -> 16023;
16026 -> 16023;
16027 -> 16004;
16028 -> 16024;
16028 -> 16027;
16029 -> 16027;
16030 -> 16029;
16030 -> 16004;
16031 -> 16004;
16032 -> 16017;
16032 -> 16030;
16032 -> 16004;
16033 -> 16004;
16034 -> 16004;
16035 -> 16034;
16035 -> 15995;
16036 -> 15986;
16037 -> 15736;
16037 -> 15986;
16038 -> 15986;
16039 -> 16037;
16039 -> 16038;
16039 -> 15986;
16040 -> 15736;
16040 -> 16039;
16041 -> 16039;
16042 -> 16040;
16042 -> 16041;
16042 -> 16039;
16043 -> 15736;
16043 -> 16042;
16044 -> 16042;
16045 -> 16043;
16045 -> 16044;
16045 -> 16042;
16046 -> 15986;
16047 -> 16046;
16048 -> 16047;
16049 -> 16047;
16050 -> 16049;
16051 -> 15986;
16052 -> 16036;
16052 -> 16051;
16052 -> 15986;
16053 -> 16052;
16054 -> 16053;
16055 -> 16053;
16056 -> 16055;
16057 -> 0;
16057 -> 15986;
16058 -> 15736;
16059 -> 15987;
16059 -> 15736;
16060 -> 16059;
16060 -> 15736;
16061 -> 0;
16061 -> 15986;
16062 -> 15736;
16063 -> 16062;
16063 -> 15736;
16064 -> 15736;
16065 -> 15736;
16066 -> 16064;
16066 -> 16065;
16067 -> 16066;
16067 -> 15736;
16068 -> 15736;
16069 -> 16067;
16069 -> 16068;
16070 -> 16069;
16070 -> 15749;
16071 -> 15749;
16072 -> 15749;
16073 -> 15749;
16074 -> 16072;
16074 -> 16073;
16075 -> 16074;
16075 -> 15749;
16075 -> 16073;
16076 -> 16072;
16076 -> 15749;
16077 -> 16076;
16077 -> 15749;
16078 -> 16077;
16078 -> 0;
16078 -> 15749;
16079 -> 16077;
16079 -> 15749;
16080 -> 16074;
16080 -> 15749;
16081 -> 15749;
16082 -> 9146;
16082 -> 15749;
16083 -> 16082;
16083 -> 15749;
16084 -> 16083;
16084 -> 0;
16084 -> 15749;
16085 -> 16083;
16085 -> 15749;
16086 -> 15749;
16087 -> 15749;
16088 -> 16087;
16088 -> 15749;
16089 -> 15749;
16090 -> 15749;
16091 -> 15749;
16092 -> 15749;
16093 -> 16091;
16093 -> 16092;
16094 -> 16093;
16094 -> 15749;
16094 -> 16092;
16095 -> 16094;
16095 -> 15749;
16096 -> 15749;
16097 -> 15749;
16098 -> 15749;
16099 -> 16097;
16099 -> 16098;
16099 -> 15749;
16100 -> 15749;
16101 -> 15749;
16102 -> 16100;
16102 -> 16101;
16102 -> 15749;
16103 -> 15749;
16104 -> 15749;
16105 -> 0;
16105 -> 15749;
16106 -> 15749;
16107 -> 15749;
16107 -> 16106;
16108 -> 16106;
16109 -> 16107;
16109 -> 16108;
16110 -> 16109;
16110 -> 16106;
16111 -> 16106;
16111 -> 15749;
16112 -> 15749;
16113 -> 15749;
16114 -> 0;
16114 -> 15749;
16115 -> 15749;
16116 -> 15749;
16116 -> 16115;
16117 -> 16115;
16118 -> 16116;
16118 -> 16117;
16119 -> 16115;
16120 -> 16118;
16120 -> 16119;
16121 -> 16119;
16122 -> 16121;
16122 -> 15749;
16123 -> 15749;
16124 -> 15749;
16124 -> 16123;
16125 -> 16123;
16126 -> 16124;
16126 -> 16125;
16127 -> 16123;
16128 -> 16126;
16128 -> 16127;
16129 -> 16127;
16130 -> 16129;
16130 -> 16127;
16131 -> 16130;
16131 -> 16127;
16132 -> 16128;
16132 -> 16127;
16133 -> 16127;
16134 -> 16132;
16134 -> 16133;
16135 -> 16133;
16136 -> 16135;
16136 -> 16127;
16137 -> 16127;
16138 -> 16132;
16138 -> 16137;
16139 -> 16138;
16139 -> 16127;
16140 -> 16127;
16141 -> 16139;
16141 -> 16140;
16142 -> 16140;
16142 -> 16127;
16143 -> 16136;
16143 -> 16142;
16143 -> 16127;
16144 -> 16127;
16145 -> 16132;
16145 -> 16144;
16146 -> 16145;
16146 -> 16127;
16147 -> 16127;
16148 -> 16146;
16148 -> 16147;
16149 -> 16127;
16150 -> 16148;
16150 -> 16149;
16151 -> 16149;
16151 -> 16127;
16152 -> 16127;
16153 -> 16143;
16153 -> 16151;
16153 -> 16127;
16154 -> 16127;
16155 -> 16132;
16155 -> 16154;
16156 -> 16155;
16156 -> 16127;
16157 -> 16156;
16157 -> 2687;
16157 -> 16127;
16158 -> 16153;
16158 -> 16157;
16158 -> 16127;
16159 -> 16127;
16160 -> 16127;
16160 -> 15749;
16161 -> 15749;
16162 -> 15749;
16163 -> 16161;
16163 -> 16162;
16164 -> 15749;
16164 -> 16162;
16165 -> 16164;
16165 -> 15749;
16165 -> 16162;
16166 -> 15749;
16167 -> 15749;
16168 -> 16166;
16168 -> 16167;
16169 -> 15749;
16169 -> 16167;
16170 -> 16169;
16170 -> 15749;
16170 -> 16167;
16171 -> 16170;
16171 -> 15749;
16172 -> 15749;
16173 -> 15749;
16174 -> 16172;
16174 -> 15749;
16175 -> 15749;
16176 -> 16174;
16176 -> 16175;
16176 -> 15749;
16177 -> 16173;
16177 -> 15749;
16177 -> 0;
16178 -> 16174;
16178 -> 15749;
16179 -> 16178;
16179 -> 15749;
16180 -> 15749;
16181 -> 16180;
16181 -> 15749;
16182 -> 15749;
16183 -> 15749;
16184 -> 16178;
16184 -> 15749;
16185 -> 15749;
16185 -> 0;
16186 -> 16185;
16187 -> 15749;
16187 -> 16186;
16188 -> 16186;
16189 -> 16187;
16189 -> 16188;
16190 -> 16189;
16190 -> 16186;
16191 -> 16186;
16192 -> 16190;
16192 -> 16191;
16193 -> 16186;
16194 -> 16192;
16194 -> 16193;
16195 -> 16194;
16195 -> 16193;
16196 -> 16193;
16197 -> 16195;
16197 -> 16196;
16198 -> 16197;
16198 -> 16185;
16199 -> 16185;
16200 -> 16198;
16200 -> 16199;
16201 -> 15749;
16201 -> 16199;
16202 -> 16200;
16202 -> 16199;
16203 -> 16202;
16204 -> 15749;
16205 -> 15749;
16205 -> 16204;
16206 -> 16204;
16207 -> 16205;
16207 -> 16206;
16208 -> 16204;
16209 -> 16207;
16209 -> 16208;
16210 -> 16208;
16211 -> 16210;
16211 -> 15749;
16212 -> 16211;
16213 -> 15749;
16213 -> 16212;
16214 -> 16212;
16215 -> 16213;
16215 -> 16214;
16216 -> 16212;
16217 -> 16215;
16217 -> 16216;
16218 -> 16216;
16219 -> 16218;
16219 -> 16216;
16220 -> 16219;
16220 -> 16216;
16221 -> 16217;
16221 -> 16216;
16222 -> 16216;
16223 -> 16221;
16223 -> 16222;
16224 -> 16222;
16225 -> 16224;
16225 -> 16216;
16226 -> 16216;
16227 -> 16221;
16227 -> 16226;
16228 -> 16227;
16228 -> 16216;
16229 -> 16216;
16230 -> 16228;
16230 -> 16229;
16231 -> 16229;
16231 -> 16216;
16232 -> 16225;
16232 -> 16231;
16232 -> 16216;
16233 -> 16216;
16234 -> 16221;
16234 -> 16233;
16235 -> 16234;
16235 -> 16216;
16236 -> 16216;
16237 -> 16235;
16237 -> 16236;
16238 -> 16216;
16239 -> 16237;
16239 -> 16238;
16240 -> 16238;
16240 -> 16216;
16241 -> 16216;
16242 -> 16232;
16242 -> 16240;
16242 -> 16216;
16243 -> 16216;
16244 -> 16221;
16244 -> 16243;
16245 -> 16244;
16245 -> 16216;
16246 -> 16245;
16246 -> 2687;
16246 -> 16216;
16247 -> 16242;
16247 -> 16246;
16247 -> 16216;
16248 -> 16216;
16249 -> 16216;
16249 -> 16211;
16250 -> 15749;
16251 -> 15749;
16252 -> 16250;
16252 -> 16251;
16252 -> 15749;
16253 -> 15749;
16253 -> 16252;
16254 -> 16252;
16255 -> 16253;
16255 -> 16254;
16255 -> 16252;
16256 -> 15749;
16256 -> 16255;
16257 -> 16255;
16258 -> 16256;
16258 -> 16257;
16258 -> 16255;
16259 -> 15749;
16260 -> 15749;
16261 -> 16260;
16261 -> 15749;
16262 -> 15749;
16263 -> 15749;
16264 -> 15749;
16265 -> 16263;
16265 -> 16264;
16266 -> 15749;
16266 -> 16264;
16267 -> 16265;
16267 -> 16264;
16268 -> 16264;
16269 -> 16267;
16269 -> 16268;
16270 -> 16266;
16270 -> 16268;
16271 -> 16270;
16271 -> 15749;
16271 -> 16268;
16272 -> 16271;
16272 -> 16264;
16273 -> 15749;
16274 -> 16273;
16274 -> 15749;
16275 -> 15749;
16276 -> 15749;
16277 -> 16275;
16277 -> 16276;
16278 -> 15749;
16278 -> 16276;
16279 -> 16277;
16279 -> 16276;
16280 -> 16276;
16281 -> 16279;
16281 -> 16280;
16282 -> 16278;
16282 -> 16280;
16283 -> 16280;
16284 -> 16281;
16284 -> 16283;
16285 -> 16284;
16285 -> 15749;
16285 -> 16283;
16286 -> 16285;
16286 -> 16280;
16287 -> 16282;
16287 -> 15749;
16287 -> 16286;
16288 -> 0;
16288 -> 16286;
16289 -> 16280;
16290 -> 16289;
16290 -> 16276;
16291 -> 15749;
16292 -> 16291;
16293 -> 15749;
16293 -> 16292;
16294 -> 16292;
16295 -> 16293;
16295 -> 15749;
16295 -> 16294;
16296 -> 16292;
16297 -> 16295;
16297 -> 16296;
16298 -> 16297;
16298 -> 16291;
16299 -> 16291;
16300 -> 16291;
16301 -> 16298;
16301 -> 16300;
16302 -> 16299;
16302 -> 16300;
16303 -> 16299;
16303 -> 16300;
16304 -> 15749;
16304 -> 16300;
16305 -> 16304;
16305 -> 15749;
16305 -> 16300;
16306 -> 0;
16306 -> 16300;
16307 -> 16305;
16307 -> 16301;
16307 -> 15749;
16307 -> 16300;
16308 -> 15749;
16309 -> 16308;
16309 -> 15749;
16310 -> 15749;
16311 -> 0;
16311 -> 15749;
16312 -> 15749;
16313 -> 16309;
16313 -> 16312;
16314 -> 16312;
16315 -> 16313;
16315 -> 15749;
16315 -> 16314;
16316 -> 16314;
16316 -> 15749;
16317 -> 15749;
16318 -> 16316;
16319 -> 16309;
16319 -> 16318;
16320 -> 16318;
16321 -> 16319;
16321 -> 15749;
16321 -> 16320;
16322 -> 16320;
16323 -> 16322;
16323 -> 16316;
16324 -> 15749;
16325 -> 15749;
16326 -> 16309;
16326 -> 16325;
16327 -> 16325;
16328 -> 16326;
16328 -> 15749;
16328 -> 16327;
16329 -> 16327;
16329 -> 15749;
16330 -> 15749;
16331 -> 16330;
16331 -> 15749;
16332 -> 15749;
16333 -> 15749;
16334 -> 16332;
16334 -> 16333;
16335 -> 15749;
16335 -> 16333;
16336 -> 16334;
16336 -> 16333;
16337 -> 16333;
16338 -> 16336;
16338 -> 16337;
16339 -> 16335;
16339 -> 16337;
16340 -> 16337;
16341 -> 16338;
16341 -> 16340;
16342 -> 16341;
16342 -> 15749;
16342 -> 16340;
16343 -> 16342;
16343 -> 16337;
16344 -> 16337;
16345 -> 16344;
16345 -> 16333;
16346 -> 15749;
16347 -> 15749;
16347 -> 16346;
16348 -> 15749;
16348 -> 16346;
16349 -> 15749;
16349 -> 16346;
16350 -> 15736;
16350 -> 16346;
16351 -> 16350;
16351 -> 15749;
16351 -> 16346;
16352 -> 0;
16352 -> 16346;
16353 -> 16351;
16353 -> 16347;
16353 -> 15749;
16353 -> 16346;
16354 -> 15736;
16355 -> 15736;
16356 -> 16354;
16356 -> 16355;
16357 -> 15987;
16357 -> 16355;
16358 -> 16356;
16358 -> 16355;
16359 -> 16355;
16360 -> 16358;
16360 -> 16359;
16361 -> 16357;
16361 -> 16359;
16362 -> 16359;
16363 -> 16360;
16363 -> 16362;
16364 -> 16363;
16364 -> 15749;
16364 -> 16362;
16365 -> 16364;
16365 -> 16359;
16366 -> 16361;
16366 -> 15749;
16366 -> 16365;
16366 -> 16359;
16367 -> 15736;
16368 -> 16367;
16368 -> 15749;
16369 -> 16367;
16369 -> 15749;
16370 -> 16369;
16370 -> 15736;
16371 -> 15736;
16372 -> 16370;
16372 -> 16371;
16373 -> 15987;
16373 -> 16371;
16374 -> 16373;
16374 -> 15749;
16374 -> 16371;
16375 -> 0;
16375 -> 16371;
16376 -> 15736;
16377 -> 15986;
16378 -> 15736;
16378 -> 16377;
16379 -> 16378;
16379 -> 15749;
16379 -> 16377;
16380 -> 16379;
16380 -> 15986;
16381 -> 15809;
16382 -> 15807;
16383 -> 15736;
16383 -> 15807;
16384 -> 15807;
16385 -> 16383;
16385 -> 16384;
16386 -> 15808;
16386 -> 16384;
16387 -> 16385;
16387 -> 16384;
16388 -> 16384;
16389 -> 16387;
16389 -> 16388;
16390 -> 16386;
16390 -> 16388;
16391 -> 16388;
16392 -> 16389;
16392 -> 16391;
16393 -> 16392;
16393 -> 15749;
16393 -> 16391;
16394 -> 16393;
16394 -> 16388;
16395 -> 16388;
16396 -> 16395;
16396 -> 16384;
16397 -> 15807;
16398 -> 15805;
16399 -> 15802;
16400 -> 15767;
16401 -> 1;
16402 -> 13799;
16402 -> 1;
16403 -> 1;
16404 -> 16402;
16404 -> 16403;
16405 -> 0;
16405 -> 16403;
16406 -> 16403;
16407 -> 16405;
16407 -> 16406;
16408 -> 16404;
16408 -> 16406;
16409 -> 16406;
16410 -> 16408;
16410 -> 15749;
16410 -> 16409;
16411 -> 9146;
16411 -> 16410;
16412 -> 16411;
16412 -> 16410;
16413 -> 16412;
16413 -> 0;
16413 -> 16410;
16414 -> 16412;
16414 -> 16410;
16415 -> 16410;
16416 -> 16415;
16416 -> 0;
16416 -> 16410;
16417 -> 16410;
16418 -> 16417;
16419 -> 16410;
16420 -> 16410;
16421 -> 16410;
16422 -> 16410;
16423 -> 16422;
16423 -> 16410;
16424 -> 16410;
16425 -> 16423;
16425 -> 16424;
16425 -> 16410;
16426 -> 16423;
16426 -> 16410;
16427 -> 16407;
16427 -> 16406;
16428 -> 16406;
16429 -> 16427;
16429 -> 16428;
16430 -> 16429;
16430 -> 16428;
16431 -> 16428;
16432 -> 16430;
16432 -> 16431;
16433 -> 16432;
16433 -> 16431;
16434 -> 16431;
16435 -> 16433;
16435 -> 16431;
16436 -> 16431;
16437 -> 16434;
16437 -> 16436;
16438 -> 16434;
16438 -> 16436;
16439 -> 16435;
16439 -> 16436;
16440 -> 16434;
16440 -> 16436;
16441 -> 16436;
16442 -> 16410;
16442 -> 16441;
16442 -> 16436;
16443 -> 16440;
16443 -> 16436;
16444 -> 16443;
16445 -> 16437;
16445 -> 16444;
16445 -> 16443;
16446 -> 16443;
16447 -> 16438;
16447 -> 16446;
16447 -> 16443;
16448 -> 16410;
16448 -> 16436;
16449 -> 16436;
16450 -> 16449;
16450 -> 16436;
16451 -> 16439;
16451 -> 16436;
16452 -> 16437;
16452 -> 16436;
16453 -> 16438;
16453 -> 16436;
16454 -> 16436;
16455 -> 16436;
16456 -> 16450;
16456 -> 16455;
16457 -> 16451;
16457 -> 16455;
16458 -> 16452;
16458 -> 16455;
16459 -> 16453;
16459 -> 16455;
16460 -> 16454;
16460 -> 16455;
16461 -> 16456;
16461 -> 16455;
16462 -> 16457;
16462 -> 16455;
16463 -> 16455;
16464 -> 16458;
16464 -> 16455;
16465 -> 16459;
16465 -> 16455;
16466 -> 16455;
16467 -> 16466;
16467 -> 16455;
16468 -> 16466;
16468 -> 16455;
16469 -> 0;
16469 -> 16455;
16470 -> 16454;
16470 -> 16436;
16471 -> 16436;
16472 -> 16470;
16472 -> 16471;
16473 -> 16472;
16473 -> 16471;
16474 -> 16471;
16475 -> 16473;
16475 -> 16474;
16476 -> 16474;
16477 -> 16475;
16477 -> 16476;
16478 -> 16476;
16479 -> 16477;
16479 -> 16478;
16480 -> 16479;
16480 -> 16410;
16480 -> 16478;
16481 -> 16479;
16481 -> 16410;
16481 -> 16467;
16481 -> 16468;
16481 -> 16478;
16482 -> 0;
16482 -> 16478;
16483 -> 16478;
16484 -> 16410;
16484 -> 16483;
16485 -> 16483;
16486 -> 16484;
16486 -> 16485;
16487 -> 16483;
16488 -> 16486;
16488 -> 16487;
16489 -> 16487;
16490 -> 16489;
16490 -> 16478;
16491 -> 16481;
16491 -> 16490;
16491 -> 16478;
16492 -> 0;
16492 -> 16478;
16493 -> 16478;
16494 -> 16410;
16494 -> 16493;
16495 -> 16493;
16496 -> 16494;
16496 -> 16495;
16497 -> 16493;
16498 -> 16496;
16498 -> 16497;
16499 -> 16497;
16500 -> 16499;
16500 -> 16497;
16501 -> 16497;
16502 -> 16500;
16502 -> 16501;
16503 -> 16498;
16503 -> 16501;
16504 -> 16501;
16505 -> 16503;
16505 -> 16504;
16506 -> 16504;
16507 -> 16506;
16507 -> 16501;
16508 -> 16501;
16509 -> 16503;
16509 -> 16508;
16510 -> 16509;
16510 -> 16501;
16511 -> 16501;
16512 -> 16510;
16512 -> 16511;
16513 -> 0;
16513 -> 16511;
16514 -> 16513;
16514 -> 16501;
16515 -> 16507;
16515 -> 16514;
16515 -> 16501;
16516 -> 16501;
16517 -> 16503;
16517 -> 16516;
16518 -> 16516;
16519 -> 16516;
16520 -> 16517;
16520 -> 16501;
16521 -> 16501;
16522 -> 16520;
16522 -> 16521;
16523 -> 16521;
16524 -> 16521;
16525 -> 16501;
16526 -> 16522;
16526 -> 16525;
16527 -> 16525;
16528 -> 16527;
16528 -> 16501;
16529 -> 16501;
16530 -> 16515;
16530 -> 16528;
16530 -> 16501;
16531 -> 16501;
16532 -> 16501;
16533 -> 16532;
16533 -> 16478;
16534 -> 16479;
16534 -> 16410;
16534 -> 16533;
16534 -> 16478;
16535 -> 16410;
16535 -> 16478;
16536 -> 16478;
16537 -> 16535;
16537 -> 16536;
16538 -> 16479;
16538 -> 16536;
16539 -> 16538;
16539 -> 16410;
16539 -> 16536;
16540 -> 0;
16540 -> 16536;
16541 -> 16478;
16542 -> 16410;
16542 -> 16478;
16543 -> 16478;
16544 -> 16542;
16544 -> 16543;
16545 -> 16479;
16545 -> 16543;
16546 -> 16543;
16547 -> 16544;
16547 -> 16546;
16548 -> 16546;
16549 -> 16546;
16550 -> 16547;
16550 -> 16543;
16551 -> 16545;
16551 -> 16410;
16551 -> 16550;
16551 -> 16543;
16552 -> 16478;
16553 -> 16552;
16554 -> 16552;
16555 -> 16552;
16556 -> 16555;
16557 -> 16556;
16558 -> 16478;
16559 -> 16410;
16559 -> 16558;
16560 -> 16479;
16560 -> 16558;
16561 -> 16559;
16561 -> 16558;
16562 -> 16558;
16563 -> 16561;
16563 -> 16562;
16563 -> 16558;
16564 -> 16560;
16564 -> 16410;
16564 -> 0;
16564 -> 16558;
16565 -> 16558;
16566 -> 16561;
16566 -> 16565;
16567 -> 16565;
16568 -> 16566;
16568 -> 16410;
16568 -> 16567;
16569 -> 16567;
16570 -> 16569;
16570 -> 16558;
16571 -> 16570;
16571 -> 16478;
16572 -> 16571;
16573 -> 16410;
16573 -> 16572;
16574 -> 16573;
16574 -> 16410;
16574 -> 16572;
16575 -> 16572;
16575 -> 16571;
16576 -> 16575;
16576 -> 16571;
16577 -> 16576;
16578 -> 16577;
16579 -> 16577;
16580 -> 16578;
16580 -> 16579;
16581 -> 16578;
16581 -> 16579;
16582 -> 16580;
16582 -> 16579;
16583 -> 16579;
16584 -> 16583;
16584 -> 16579;
16585 -> 16583;
16585 -> 16579;
16586 -> 16578;
16586 -> 16576;
16587 -> 16576;
16588 -> 16587;
16589 -> 16410;
16589 -> 16588;
16590 -> 16410;
16590 -> 16588;
16591 -> 16410;
16592 -> 16410;
16593 -> 16591;
16593 -> 16410;
16594 -> 16410;
16595 -> 16593;
16595 -> 16594;
16595 -> 16410;
16596 -> 16592;
16596 -> 16410;
16596 -> 0;
16597 -> 16593;
16597 -> 16410;
16598 -> 16597;
16598 -> 16410;
16599 -> 16410;
16600 -> 16410;
16601 -> 16597;
16601 -> 16410;
16602 -> 16410;
16603 -> 16602;
16603 -> 16410;
16604 -> 16588;
16605 -> 16410;
16605 -> 16604;
16606 -> 16605;
16606 -> 16410;
16606 -> 16604;
16607 -> 16604;
16607 -> 16588;
16608 -> 0;
16608 -> 16607;
16609 -> 16607;
16610 -> 16609;
16611 -> 16609;
16612 -> 16607;
16613 -> 16608;
16613 -> 16612;
16614 -> 16612;
16615 -> 16613;
16615 -> 16612;
16616 -> 16587;
16617 -> 16587;
16618 -> 16576;
16619 -> 16576;
16620 -> 16410;
16620 -> 16619;
16621 -> 16620;
16621 -> 16410;
16621 -> 16619;
16622 -> 16619;
16622 -> 16576;
16623 -> 16576;
16624 -> 16479;
16624 -> 16623;
16625 -> 0;
16625 -> 16623;
16626 -> 16623;
16627 -> 16623;
16628 -> 16625;
16628 -> 16627;
16629 -> 16626;
16629 -> 16627;
16630 -> 16624;
16630 -> 16627;
16631 -> 16627;
16632 -> 16628;
16632 -> 16627;
16633 -> 16629;
16633 -> 16627;
16634 -> 16576;
16635 -> 16479;
16635 -> 16410;
16635 -> 0;
16635 -> 16478;
16636 -> 16635;
16637 -> 16410;
16637 -> 16636;
16638 -> 16636;
16639 -> 16637;
16639 -> 16638;
16640 -> 16639;
16640 -> 16636;
16641 -> 16636;
16642 -> 16640;
16642 -> 16641;
16643 -> 16636;
16644 -> 16642;
16644 -> 16643;
16645 -> 16644;
16645 -> 16643;
16646 -> 16643;
16647 -> 16645;
16647 -> 16646;
16648 -> 16647;
16648 -> 16635;
16649 -> 16635;
16650 -> 16648;
16650 -> 16649;
16651 -> 16479;
16651 -> 16649;
16652 -> 16650;
16652 -> 16649;
16653 -> 16652;
16654 -> 16478;
16655 -> 16479;
16655 -> 16654;
16656 -> 16654;
16657 -> 16410;
16657 -> 16656;
16658 -> 16656;
16659 -> 16657;
16659 -> 16658;
16660 -> 16656;
16661 -> 16659;
16661 -> 16660;
16662 -> 16660;
16663 -> 16662;
16663 -> 16654;
16664 -> 16663;
16665 -> 16410;
16665 -> 16664;
16666 -> 16664;
16667 -> 16665;
16667 -> 16666;
16668 -> 16664;
16669 -> 16667;
16669 -> 16668;
16670 -> 16668;
16671 -> 16670;
16671 -> 16668;
16672 -> 16668;
16673 -> 16671;
16673 -> 16672;
16674 -> 16669;
16674 -> 16672;
16675 -> 16672;
16676 -> 16674;
16676 -> 16675;
16677 -> 16675;
16678 -> 16677;
16678 -> 16672;
16679 -> 16672;
16680 -> 16674;
16680 -> 16679;
16681 -> 16680;
16681 -> 16672;
16682 -> 16672;
16683 -> 16681;
16683 -> 16682;
16684 -> 0;
16684 -> 16682;
16685 -> 16684;
16685 -> 16672;
16686 -> 16678;
16686 -> 16685;
16686 -> 16672;
16687 -> 16672;
16688 -> 16674;
16688 -> 16687;
16689 -> 16687;
16690 -> 16687;
16691 -> 16688;
16691 -> 16672;
16692 -> 16672;
16693 -> 16691;
16693 -> 16692;
16694 -> 16692;
16695 -> 16692;
16696 -> 16672;
16697 -> 16693;
16697 -> 16696;
16698 -> 16696;
16699 -> 16698;
16699 -> 16672;
16700 -> 16672;
16701 -> 16686;
16701 -> 16699;
16701 -> 16672;
16702 -> 16672;
16703 -> 16672;
16704 -> 16703;
16704 -> 16663;
16705 -> 16654;
16706 -> 16410;
16706 -> 16654;
16707 -> 16654;
16708 -> 16706;
16708 -> 16707;
16708 -> 16654;
16709 -> 16410;
16709 -> 16708;
16710 -> 16708;
16711 -> 16709;
16711 -> 16710;
16711 -> 16708;
16712 -> 16410;
16712 -> 16711;
16713 -> 16711;
16714 -> 16712;
16714 -> 16713;
16714 -> 16711;
16715 -> 16654;
16716 -> 16715;
16717 -> 16716;
16718 -> 16716;
16719 -> 16654;
16720 -> 16705;
16720 -> 16719;
16720 -> 16654;
16721 -> 16720;
16722 -> 16721;
16723 -> 16721;
16724 -> 0;
16724 -> 16654;
16725 -> 16410;
16726 -> 16655;
16726 -> 16410;
16727 -> 16726;
16727 -> 16410;
16728 -> 0;
16728 -> 16654;
16729 -> 16410;
16730 -> 16410;
16731 -> 16410;
16732 -> 16730;
16732 -> 16731;
16733 -> 16655;
16733 -> 16731;
16734 -> 16732;
16734 -> 16731;
16735 -> 16731;
16736 -> 16734;
16736 -> 16735;
16737 -> 16733;
16737 -> 16735;
16738 -> 16735;
16739 -> 16736;
16739 -> 16738;
16740 -> 16739;
16740 -> 16735;
16741 -> 16737;
16741 -> 16410;
16741 -> 16740;
16741 -> 16735;
16742 -> 16654;
16743 -> 16410;
16743 -> 16742;
16744 -> 16743;
16744 -> 16654;
16745 -> 16478;
16746 -> 16476;
16747 -> 16410;
16747 -> 16476;
16748 -> 16476;
16749 -> 16747;
16749 -> 16748;
16750 -> 16477;
16750 -> 16748;
16751 -> 16749;
16751 -> 16748;
16752 -> 16748;
16753 -> 16751;
16753 -> 16752;
16754 -> 16750;
16754 -> 16752;
16755 -> 16752;
16756 -> 16753;
16756 -> 16755;
16757 -> 16756;
16757 -> 16410;
16757 -> 16755;
16758 -> 16757;
16758 -> 16752;
16759 -> 16752;
16760 -> 16759;
16760 -> 16748;
16761 -> 16476;
16762 -> 16474;
16763 -> 16471;
16764 -> 16436;
16765 -> 1;
16766 -> 13801;
16766 -> 1;
16767 -> 1;
16768 -> 16766;
16768 -> 16767;
16769 -> 0;
16769 -> 16767;
16770 -> 16767;
16771 -> 16769;
16771 -> 16770;
16772 -> 16768;
16772 -> 16770;
16773 -> 16770;
16774 -> 16772;
16774 -> 16410;
16774 -> 16773;
16775 -> 9146;
16775 -> 16774;
16776 -> 16775;
16776 -> 16774;
16777 -> 16776;
16777 -> 0;
16777 -> 16774;
16778 -> 16776;
16778 -> 16774;
16779 -> 16774;
16780 -> 16779;
16780 -> 0;
16780 -> 16774;
16781 -> 16774;
16782 -> 16781;
16783 -> 16774;
16784 -> 16774;
16785 -> 16774;
16786 -> 16774;
16787 -> 16786;
16787 -> 16774;
16788 -> 16774;
16789 -> 16787;
16789 -> 16788;
16789 -> 16774;
16790 -> 16787;
16790 -> 16774;
16791 -> 16771;
16791 -> 16770;
16792 -> 16770;
16793 -> 16791;
16793 -> 16792;
16794 -> 16793;
16794 -> 16792;
16795 -> 16792;
16796 -> 16794;
16796 -> 16795;
16797 -> 16796;
16797 -> 16795;
16798 -> 16795;
16799 -> 16797;
16799 -> 16795;
16800 -> 16795;
16801 -> 16798;
16801 -> 16800;
16802 -> 16798;
16802 -> 16800;
16803 -> 16799;
16803 -> 16800;
16804 -> 16798;
16804 -> 16800;
16805 -> 16800;
16806 -> 16774;
16806 -> 16805;
16806 -> 16800;
16807 -> 16804;
16807 -> 16800;
16808 -> 16807;
16809 -> 16801;
16809 -> 16808;
16809 -> 16807;
16810 -> 16807;
16811 -> 16802;
16811 -> 16810;
16811 -> 16807;
16812 -> 16774;
16812 -> 16800;
16813 -> 16800;
16814 -> 16813;
16814 -> 16800;
16815 -> 16803;
16815 -> 16800;
16816 -> 16801;
16816 -> 16800;
16817 -> 16802;
16817 -> 16800;
16818 -> 16800;
16819 -> 16800;
16820 -> 16814;
16820 -> 16819;
16821 -> 16815;
16821 -> 16819;
16822 -> 16816;
16822 -> 16819;
16823 -> 16817;
16823 -> 16819;
16824 -> 16818;
16824 -> 16819;
16825 -> 16820;
16825 -> 16819;
16826 -> 16821;
16826 -> 16819;
16827 -> 16819;
16828 -> 16822;
16828 -> 16819;
16829 -> 16823;
16829 -> 16819;
16830 -> 16819;
16831 -> 16830;
16831 -> 16819;
16832 -> 16830;
16832 -> 16819;
16833 -> 0;
16833 -> 16819;
16834 -> 16818;
16834 -> 16800;
16835 -> 16800;
16836 -> 16834;
16836 -> 16835;
16837 -> 16836;
16837 -> 16835;
16838 -> 16835;
16839 -> 16837;
16839 -> 16838;
16840 -> 16838;
16841 -> 16839;
16841 -> 16840;
16842 -> 16840;
16843 -> 16841;
16843 -> 16842;
16844 -> 16843;
16844 -> 16774;
16844 -> 16842;
16845 -> 16843;
16845 -> 16774;
16845 -> 16831;
16845 -> 16832;
16845 -> 16842;
16846 -> 0;
16846 -> 16842;
16847 -> 16842;
16848 -> 16774;
16848 -> 16847;
16849 -> 16847;
16850 -> 16848;
16850 -> 16849;
16851 -> 16847;
16852 -> 16850;
16852 -> 16851;
16853 -> 16851;
16854 -> 16853;
16854 -> 16842;
16855 -> 16845;
16855 -> 16854;
16855 -> 16842;
16856 -> 0;
16856 -> 16842;
16857 -> 16842;
16858 -> 16774;
16858 -> 16857;
16859 -> 16857;
16860 -> 16858;
16860 -> 16859;
16861 -> 16857;
16862 -> 16860;
16862 -> 16861;
16863 -> 16861;
16864 -> 16863;
16864 -> 16861;
16865 -> 16861;
16866 -> 16864;
16866 -> 16865;
16867 -> 16862;
16867 -> 16865;
16868 -> 16865;
16869 -> 16867;
16869 -> 16868;
16870 -> 16868;
16871 -> 16870;
16871 -> 16865;
16872 -> 16865;
16873 -> 16867;
16873 -> 16872;
16874 -> 16873;
16874 -> 16865;
16875 -> 16865;
16876 -> 16874;
16876 -> 16875;
16877 -> 0;
16877 -> 16875;
16878 -> 16877;
16878 -> 16865;
16879 -> 16871;
16879 -> 16878;
16879 -> 16865;
16880 -> 16865;
16881 -> 16867;
16881 -> 16880;
16882 -> 16880;
16883 -> 16880;
16884 -> 16881;
16884 -> 16865;
16885 -> 16865;
16886 -> 16884;
16886 -> 16885;
16887 -> 16885;
16888 -> 16885;
16889 -> 16865;
16890 -> 16886;
16890 -> 16889;
16891 -> 16889;
16892 -> 16891;
16892 -> 16865;
16893 -> 16865;
16894 -> 16879;
16894 -> 16892;
16894 -> 16865;
16895 -> 16865;
16896 -> 16865;
16897 -> 16896;
16897 -> 16842;
16898 -> 16843;
16898 -> 16774;
16898 -> 16897;
16898 -> 16842;
16899 -> 16774;
16899 -> 16842;
16900 -> 16842;
16901 -> 16899;
16901 -> 16900;
16902 -> 16843;
16902 -> 16900;
16903 -> 16902;
16903 -> 16774;
16903 -> 16900;
16904 -> 0;
16904 -> 16900;
16905 -> 16842;
16906 -> 16774;
16906 -> 16842;
16907 -> 16842;
16908 -> 16906;
16908 -> 16907;
16909 -> 16843;
16909 -> 16907;
16910 -> 16907;
16911 -> 16908;
16911 -> 16910;
16912 -> 16910;
16913 -> 16910;
16914 -> 16911;
16914 -> 16907;
16915 -> 16909;
16915 -> 16774;
16915 -> 16914;
16915 -> 16907;
16916 -> 16842;
16917 -> 16916;
16918 -> 16916;
16919 -> 16916;
16920 -> 16919;
16921 -> 16920;
16922 -> 16842;
16923 -> 16774;
16923 -> 16922;
16924 -> 16843;
16924 -> 16922;
16925 -> 16923;
16925 -> 16922;
16926 -> 16922;
16927 -> 16925;
16927 -> 16926;
16927 -> 16922;
16928 -> 16924;
16928 -> 16774;
16928 -> 0;
16928 -> 16922;
16929 -> 16922;
16930 -> 16925;
16930 -> 16929;
16931 -> 16929;
16932 -> 16930;
16932 -> 16774;
16932 -> 16931;
16933 -> 16931;
16934 -> 16933;
16934 -> 16922;
16935 -> 16934;
16935 -> 16842;
16936 -> 16935;
16937 -> 16774;
16937 -> 16936;
16938 -> 16937;
16938 -> 16774;
16938 -> 16936;
16939 -> 16936;
16939 -> 16935;
16940 -> 16939;
16940 -> 16935;
16941 -> 16940;
16942 -> 16941;
16943 -> 16941;
16944 -> 16942;
16944 -> 16943;
16945 -> 16942;
16945 -> 16943;
16946 -> 16944;
16946 -> 16943;
16947 -> 16943;
16948 -> 16947;
16948 -> 16943;
16949 -> 16947;
16949 -> 16943;
16950 -> 16942;
16950 -> 16940;
16951 -> 16940;
16952 -> 16951;
16953 -> 16774;
16953 -> 16952;
16954 -> 16774;
16954 -> 16952;
16955 -> 16774;
16956 -> 16774;
16957 -> 16955;
16957 -> 16774;
16958 -> 16774;
16959 -> 16957;
16959 -> 16958;
16959 -> 16774;
16960 -> 16956;
16960 -> 16774;
16960 -> 0;
16961 -> 16957;
16961 -> 16774;
16962 -> 16961;
16962 -> 16774;
16963 -> 16774;
16964 -> 16774;
16965 -> 16961;
16965 -> 16774;
16966 -> 16774;
16967 -> 16966;
16967 -> 16774;
16968 -> 16952;
16969 -> 16774;
16969 -> 16968;
16970 -> 16969;
16970 -> 16774;
16970 -> 16968;
16971 -> 16968;
16971 -> 16952;
16972 -> 0;
16972 -> 16971;
16973 -> 16971;
16974 -> 16973;
16975 -> 16973;
16976 -> 16971;
16977 -> 16972;
16977 -> 16976;
16978 -> 16976;
16979 -> 16977;
16979 -> 16976;
16980 -> 16951;
16981 -> 16951;
16982 -> 16940;
16983 -> 16940;
16984 -> 16774;
16984 -> 16983;
16985 -> 16984;
16985 -> 16774;
16985 -> 16983;
16986 -> 16983;
16986 -> 16940;
16987 -> 16940;
16988 -> 16843;
16988 -> 16987;
16989 -> 0;
16989 -> 16987;
16990 -> 16987;
16991 -> 16987;
16992 -> 16989;
16992 -> 16991;
16993 -> 16990;
16993 -> 16991;
16994 -> 16988;
16994 -> 16991;
16995 -> 16991;
16996 -> 16992;
16996 -> 16991;
16997 -> 16993;
16997 -> 16991;
16998 -> 16940;
16999 -> 16843;
16999 -> 16774;
16999 -> 0;
16999 -> 16842;
17000 -> 16999;
17001 -> 16774;
17001 -> 17000;
17002 -> 17000;
17003 -> 17001;
17003 -> 17002;
17004 -> 17003;
17004 -> 17000;
17005 -> 17000;
17006 -> 17004;
17006 -> 17005;
17007 -> 17000;
17008 -> 17006;
17008 -> 17007;
17009 -> 17008;
17009 -> 17007;
17010 -> 17007;
17011 -> 17009;
17011 -> 17010;
17012 -> 17011;
17012 -> 16999;
17013 -> 16999;
17014 -> 17012;
17014 -> 17013;
17015 -> 16843;
17015 -> 17013;
17016 -> 17014;
17016 -> 17013;
17017 -> 17016;
17018 -> 16842;
17019 -> 16843;
17019 -> 17018;
17020 -> 17018;
17021 -> 16774;
17021 -> 17020;
17022 -> 17020;
17023 -> 17021;
17023 -> 17022;
17024 -> 17020;
17025 -> 17023;
17025 -> 17024;
17026 -> 17024;
17027 -> 17026;
17027 -> 17018;
17028 -> 17027;
17029 -> 16774;
17029 -> 17028;
17030 -> 17028;
17031 -> 17029;
17031 -> 17030;
17032 -> 17028;
17033 -> 17031;
17033 -> 17032;
17034 -> 17032;
17035 -> 17034;
17035 -> 17032;
17036 -> 17032;
17037 -> 17035;
17037 -> 17036;
17038 -> 17033;
17038 -> 17036;
17039 -> 17036;
17040 -> 17038;
17040 -> 17039;
17041 -> 17039;
17042 -> 17041;
17042 -> 17036;
17043 -> 17036;
17044 -> 17038;
17044 -> 17043;
17045 -> 17044;
17045 -> 17036;
17046 -> 17036;
17047 -> 17045;
17047 -> 17046;
17048 -> 0;
17048 -> 17046;
17049 -> 17048;
17049 -> 17036;
17050 -> 17042;
17050 -> 17049;
17050 -> 17036;
17051 -> 17036;
17052 -> 17038;
17052 -> 17051;
17053 -> 17051;
17054 -> 17051;
17055 -> 17052;
17055 -> 17036;
17056 -> 17036;
17057 -> 17055;
17057 -> 17056;
17058 -> 17056;
17059 -> 17056;
17060 -> 17036;
17061 -> 17057;
17061 -> 17060;
17062 -> 17060;
17063 -> 17062;
17063 -> 17036;
17064 -> 17036;
17065 -> 17050;
17065 -> 17063;
17065 -> 17036;
17066 -> 17036;
17067 -> 17036;
17068 -> 17067;
17068 -> 17027;
17069 -> 17018;
17070 -> 16774;
17070 -> 17018;
17071 -> 17018;
17072 -> 17070;
17072 -> 17071;
17072 -> 17018;
17073 -> 16774;
17073 -> 17072;
17074 -> 17072;
17075 -> 17073;
17075 -> 17074;
17075 -> 17072;
17076 -> 16774;
17076 -> 17075;
17077 -> 17075;
17078 -> 17076;
17078 -> 17077;
17078 -> 17075;
17079 -> 17018;
17080 -> 17079;
17081 -> 17080;
17082 -> 17080;
17083 -> 17018;
17084 -> 17069;
17084 -> 17083;
17084 -> 17018;
17085 -> 17084;
17086 -> 17085;
17087 -> 17085;
17088 -> 0;
17088 -> 17018;
17089 -> 16774;
17090 -> 17019;
17090 -> 16774;
17091 -> 17090;
17091 -> 16774;
17092 -> 0;
17092 -> 17018;
17093 -> 16774;
17094 -> 16774;
17095 -> 16774;
17096 -> 17094;
17096 -> 17095;
17097 -> 17019;
17097 -> 17095;
17098 -> 17096;
17098 -> 17095;
17099 -> 17095;
17100 -> 17098;
17100 -> 17099;
17101 -> 17097;
17101 -> 17099;
17102 -> 17099;
17103 -> 17100;
17103 -> 17102;
17104 -> 17103;
17104 -> 17099;
17105 -> 17101;
17105 -> 16774;
17105 -> 17104;
17105 -> 17099;
17106 -> 17018;
17107 -> 16774;
17107 -> 17106;
17108 -> 17107;
17108 -> 17018;
17109 -> 16842;
17110 -> 16840;
17111 -> 16774;
17111 -> 16840;
17112 -> 16840;
17113 -> 17111;
17113 -> 17112;
17114 -> 16841;
17114 -> 17112;
17115 -> 17113;
17115 -> 17112;
17116 -> 17112;
17117 -> 17115;
17117 -> 17116;
17118 -> 17114;
17118 -> 17116;
17119 -> 17116;
17120 -> 17117;
17120 -> 17119;
17121 -> 17120;
17121 -> 16774;
17121 -> 17119;
17122 -> 17121;
17122 -> 17116;
17123 -> 17116;
17124 -> 17123;
17124 -> 17112;
17125 -> 16840;
17126 -> 16838;
17127 -> 16835;
17128 -> 16800;
17129 -> 1;
17130 -> 13803;
17130 -> 1;
17131 -> 1;
17132 -> 17130;
17132 -> 17131;
17133 -> 0;
17133 -> 17131;
17134 -> 17131;
17135 -> 17133;
17135 -> 17134;
17136 -> 17132;
17136 -> 17134;
17137 -> 17134;
17138 -> 17136;
17138 -> 16774;
17138 -> 17137;
17139 -> 9146;
17139 -> 17138;
17140 -> 17139;
17140 -> 17138;
17141 -> 17140;
17141 -> 0;
17141 -> 17138;
17142 -> 17140;
17142 -> 17138;
17143 -> 17138;
17144 -> 17143;
17144 -> 0;
17144 -> 17138;
17145 -> 17138;
17146 -> 17145;
17147 -> 17138;
17148 -> 17138;
17149 -> 17138;
17150 -> 17138;
17151 -> 17150;
17151 -> 17138;
17152 -> 17138;
17153 -> 17151;
17153 -> 17152;
17153 -> 17138;
17154 -> 17151;
17154 -> 17138;
17155 -> 17138;
17156 -> 17154;
17156 -> 17155;
17157 -> 17156;
17157 -> 17138;
17158 -> 17135;
17158 -> 17134;
17159 -> 17134;
17160 -> 17158;
17160 -> 17159;
17161 -> 17160;
17161 -> 17159;
17162 -> 17159;
17163 -> 17161;
17163 -> 17162;
17164 -> 17163;
17164 -> 17162;
17165 -> 17162;
17166 -> 17164;
17166 -> 17162;
17167 -> 17162;
17168 -> 17165;
17168 -> 17167;
17169 -> 17165;
17169 -> 17167;
17170 -> 17166;
17170 -> 17167;
17171 -> 17165;
17171 -> 17167;
17172 -> 17167;
17173 -> 17138;
17173 -> 17172;
17173 -> 17167;
17174 -> 17171;
17174 -> 17167;
17175 -> 17174;
17176 -> 17168;
17176 -> 17175;
17176 -> 17174;
17177 -> 17174;
17178 -> 17169;
17178 -> 17177;
17178 -> 17174;
17179 -> 17138;
17179 -> 17167;
17180 -> 17167;
17181 -> 17180;
17181 -> 17167;
17182 -> 17170;
17182 -> 17167;
17183 -> 17168;
17183 -> 17167;
17184 -> 17169;
17184 -> 17167;
17185 -> 17167;
17186 -> 17167;
17187 -> 17181;
17187 -> 17186;
17188 -> 17182;
17188 -> 17186;
17189 -> 17183;
17189 -> 17186;
17190 -> 17184;
17190 -> 17186;
17191 -> 17185;
17191 -> 17186;
17192 -> 17187;
17192 -> 17186;
17193 -> 17188;
17193 -> 17186;
17194 -> 17186;
17195 -> 17189;
17195 -> 17186;
17196 -> 17190;
17196 -> 17186;
17197 -> 17186;
17198 -> 17197;
17198 -> 17186;
17199 -> 17197;
17199 -> 17186;
17200 -> 0;
17200 -> 17186;
17201 -> 17185;
17201 -> 17167;
17202 -> 17167;
17203 -> 17201;
17203 -> 17202;
17204 -> 17203;
17204 -> 17202;
17205 -> 17202;
17206 -> 17204;
17206 -> 17205;
17207 -> 17205;
17208 -> 17206;
17208 -> 17207;
17209 -> 17207;
17210 -> 17208;
17210 -> 17209;
17211 -> 17210;
17211 -> 17138;
17211 -> 17209;
17212 -> 17210;
17212 -> 17138;
17212 -> 17198;
17212 -> 17199;
17212 -> 17209;
17213 -> 0;
17213 -> 17209;
17214 -> 17209;
17215 -> 17138;
17215 -> 17214;
17216 -> 17214;
17217 -> 17215;
17217 -> 17216;
17218 -> 17214;
17219 -> 17217;
17219 -> 17218;
17220 -> 17218;
17221 -> 17220;
17221 -> 17209;
17222 -> 17212;
17222 -> 17221;
17222 -> 17209;
17223 -> 0;
17223 -> 17209;
17224 -> 17151;
17224 -> 17138;
17225 -> 17209;
17226 -> 17138;
17226 -> 17225;
17227 -> 17225;
17228 -> 17226;
17228 -> 17227;
17229 -> 17225;
17230 -> 17228;
17230 -> 17229;
17231 -> 17229;
17232 -> 17231;
17232 -> 17229;
17233 -> 17229;
17234 -> 17232;
17234 -> 17233;
17235 -> 17230;
17235 -> 17233;
17236 -> 17233;
17237 -> 17235;
17237 -> 17236;
17238 -> 17237;
17238 -> 17233;
17239 -> 17233;
17240 -> 17235;
17240 -> 17239;
17241 -> 17240;
17241 -> 17233;
17242 -> 17233;
17243 -> 17241;
17243 -> 17242;
17244 -> 0;
17244 -> 17242;
17245 -> 17244;
17245 -> 17233;
17246 -> 17238;
17246 -> 17245;
17246 -> 17233;
17247 -> 17233;
17248 -> 17235;
17248 -> 17247;
17249 -> 17247;
17250 -> 17247;
17251 -> 17248;
17251 -> 17233;
17252 -> 17233;
17253 -> 17251;
17253 -> 17252;
17254 -> 17252;
17255 -> 17252;
17256 -> 17233;
17257 -> 17253;
17257 -> 17256;
17258 -> 17256;
17259 -> 17258;
17259 -> 17233;
17260 -> 17233;
17261 -> 17246;
17261 -> 17259;
17261 -> 17233;
17262 -> 17233;
17263 -> 17233;
17264 -> 17263;
17264 -> 17209;
17265 -> 17210;
17265 -> 17138;
17265 -> 17264;
17265 -> 17209;
17266 -> 17138;
17266 -> 17209;
17267 -> 17209;
17268 -> 17266;
17268 -> 17267;
17269 -> 17210;
17269 -> 17267;
17270 -> 17269;
17270 -> 17138;
17270 -> 17267;
17271 -> 0;
17271 -> 17267;
17272 -> 17209;
17273 -> 17138;
17273 -> 17209;
17274 -> 17209;
17275 -> 17273;
17275 -> 17274;
17276 -> 17210;
17276 -> 17274;
17277 -> 17274;
17278 -> 17275;
17278 -> 17277;
17279 -> 17277;
17280 -> 17277;
17281 -> 17280;
17282 -> 17278;
17282 -> 17274;
17283 -> 17276;
17283 -> 17138;
17283 -> 17282;
17283 -> 17274;
17284 -> 17209;
17285 -> 17284;
17286 -> 17284;
17287 -> 17284;
17288 -> 17287;
17289 -> 17288;
17290 -> 17209;
17291 -> 17138;
17291 -> 17290;
17292 -> 17210;
17292 -> 17290;
17293 -> 17291;
17293 -> 17290;
17294 -> 17290;
17295 -> 17293;
17295 -> 17294;
17295 -> 17290;
17296 -> 17292;
17296 -> 17138;
17296 -> 0;
17296 -> 17290;
17297 -> 17290;
17298 -> 17293;
17298 -> 17297;
17299 -> 17297;
17300 -> 17298;
17300 -> 17138;
17300 -> 17299;
17301 -> 17299;
17302 -> 17301;
17302 -> 17290;
17303 -> 17302;
17303 -> 17209;
17304 -> 17303;
17305 -> 17138;
17305 -> 17304;
17306 -> 17305;
17306 -> 17138;
17306 -> 17304;
17307 -> 17304;
17307 -> 17303;
17308 -> 17307;
17308 -> 17303;
17309 -> 17308;
17310 -> 17309;
17311 -> 17309;
17312 -> 17310;
17312 -> 17311;
17313 -> 17310;
17313 -> 17311;
17314 -> 17312;
17314 -> 17311;
17315 -> 17311;
17316 -> 17315;
17316 -> 17311;
17317 -> 17315;
17317 -> 17311;
17318 -> 17310;
17318 -> 17308;
17319 -> 17308;
17320 -> 17319;
17321 -> 17138;
17321 -> 17320;
17322 -> 17138;
17322 -> 17320;
17323 -> 17138;
17324 -> 17138;
17325 -> 17323;
17325 -> 17138;
17326 -> 17138;
17327 -> 17325;
17327 -> 17326;
17327 -> 17138;
17328 -> 17324;
17328 -> 17138;
17328 -> 0;
17329 -> 17325;
17329 -> 17138;
17330 -> 17329;
17330 -> 17138;
17331 -> 17138;
17332 -> 17138;
17333 -> 17329;
17333 -> 17138;
17334 -> 17138;
17335 -> 17334;
17335 -> 17138;
17336 -> 17320;
17337 -> 17138;
17337 -> 17336;
17338 -> 17337;
17338 -> 17138;
17338 -> 17336;
17339 -> 17336;
17339 -> 17320;
17340 -> 0;
17340 -> 17339;
17341 -> 17339;
17342 -> 17341;
17343 -> 17341;
17344 -> 17339;
17345 -> 17340;
17345 -> 17344;
17346 -> 17344;
17347 -> 17345;
17347 -> 17344;
17348 -> 17319;
17349 -> 17319;
17350 -> 17308;
17351 -> 17308;
17352 -> 17138;
17352 -> 17351;
17353 -> 17352;
17353 -> 17138;
17353 -> 17351;
17354 -> 17351;
17354 -> 17308;
17355 -> 17308;
17356 -> 17210;
17356 -> 17355;
17357 -> 0;
17357 -> 17355;
17358 -> 17355;
17359 -> 17355;
17360 -> 17357;
17360 -> 17359;
17361 -> 17358;
17361 -> 17359;
17362 -> 17356;
17362 -> 17359;
17363 -> 17359;
17364 -> 17360;
17364 -> 17359;
17365 -> 17361;
17365 -> 17359;
17366 -> 17308;
17367 -> 17210;
17367 -> 17138;
17367 -> 0;
17367 -> 17209;
17368 -> 17367;
17369 -> 17138;
17369 -> 17368;
17370 -> 17368;
17371 -> 17369;
17371 -> 17370;
17372 -> 17371;
17372 -> 17368;
17373 -> 17368;
17374 -> 17372;
17374 -> 17373;
17375 -> 17368;
17376 -> 17374;
17376 -> 17375;
17377 -> 17376;
17377 -> 17375;
17378 -> 17375;
17379 -> 17377;
17379 -> 17378;
17380 -> 17379;
17380 -> 17367;
17381 -> 17367;
17382 -> 17380;
17382 -> 17381;
17383 -> 17210;
17383 -> 17381;
17384 -> 17382;
17384 -> 17381;
17385 -> 17384;
17386 -> 17209;
17387 -> 17210;
17387 -> 17386;
17388 -> 17386;
17389 -> 17138;
17389 -> 17388;
17390 -> 17388;
17391 -> 17389;
17391 -> 17390;
17392 -> 17388;
17393 -> 17391;
17393 -> 17392;
17394 -> 17392;
17395 -> 17394;
17395 -> 17386;
17396 -> 17395;
17397 -> 17138;
17397 -> 17396;
17398 -> 17396;
17399 -> 17397;
17399 -> 17398;
17400 -> 17396;
17401 -> 17399;
17401 -> 17400;
17402 -> 17400;
17403 -> 17402;
17403 -> 17400;
17404 -> 17400;
17405 -> 17403;
17405 -> 17404;
17406 -> 17401;
17406 -> 17404;
17407 -> 17404;
17408 -> 17406;
17408 -> 17407;
17409 -> 17408;
17409 -> 17404;
17410 -> 17404;
17411 -> 17406;
17411 -> 17410;
17412 -> 17411;
17412 -> 17404;
17413 -> 17404;
17414 -> 17412;
17414 -> 17413;
17415 -> 0;
17415 -> 17413;
17416 -> 17415;
17416 -> 17404;
17417 -> 17409;
17417 -> 17416;
17417 -> 17404;
17418 -> 17404;
17419 -> 17406;
17419 -> 17418;
17420 -> 17418;
17421 -> 17418;
17422 -> 17419;
17422 -> 17404;
17423 -> 17404;
17424 -> 17422;
17424 -> 17423;
17425 -> 17423;
17426 -> 17423;
17427 -> 17404;
17428 -> 17424;
17428 -> 17427;
17429 -> 17427;
17430 -> 17429;
17430 -> 17404;
17431 -> 17404;
17432 -> 17417;
17432 -> 17430;
17432 -> 17404;
17433 -> 17404;
17434 -> 17404;
17435 -> 17434;
17435 -> 17395;
17436 -> 17386;
17437 -> 17138;
17437 -> 17386;
17438 -> 17386;
17439 -> 17437;
17439 -> 17438;
17439 -> 17386;
17440 -> 17138;
17440 -> 17439;
17441 -> 17439;
17442 -> 17440;
17442 -> 17441;
17442 -> 17439;
17443 -> 17138;
17443 -> 17442;
17444 -> 17442;
17445 -> 17443;
17445 -> 17444;
17445 -> 17442;
17446 -> 17386;
17447 -> 17446;
17448 -> 17447;
17449 -> 17447;
17450 -> 17449;
17451 -> 17386;
17452 -> 17436;
17452 -> 17451;
17452 -> 17386;
17453 -> 17452;
17454 -> 17453;
17455 -> 17453;
17456 -> 17455;
17457 -> 0;
17457 -> 17386;
17458 -> 17138;
17459 -> 17387;
17459 -> 17138;
17460 -> 17459;
17460 -> 17138;
17461 -> 0;
17461 -> 17386;
17462 -> 17138;
17463 -> 17462;
17463 -> 17138;
17464 -> 17138;
17465 -> 17138;
17466 -> 17464;
17466 -> 17465;
17467 -> 17466;
17467 -> 17138;
17468 -> 17467;
17468 -> 17155;
17469 -> 17468;
17469 -> 17138;
17470 -> 17138;
17471 -> 17138;
17472 -> 17138;
17473 -> 17471;
17473 -> 17472;
17474 -> 17473;
17474 -> 17138;
17474 -> 17472;
17475 -> 17471;
17475 -> 17138;
17476 -> 17475;
17476 -> 17138;
17477 -> 17476;
17477 -> 0;
17477 -> 17138;
17478 -> 17476;
17478 -> 17138;
17479 -> 17473;
17479 -> 17138;
17480 -> 17138;
17481 -> 17138;
17482 -> 17138;
17483 -> 17482;
17483 -> 17138;
17484 -> 17138;
17485 -> 17138;
17486 -> 17464;
17486 -> 17465;
17487 -> 17486;
17487 -> 17138;
17487 -> 17465;
17488 -> 17487;
17488 -> 17138;
17489 -> 17138;
17490 -> 17138;
17491 -> 17138;
17492 -> 17490;
17492 -> 17491;
17492 -> 17138;
17493 -> 17138;
17494 -> 17138;
17495 -> 17493;
17495 -> 17494;
17495 -> 17138;
17496 -> 17138;
17497 -> 17138;
17498 -> 0;
17498 -> 17138;
17499 -> 17138;
17500 -> 17138;
17500 -> 17499;
17501 -> 17499;
17502 -> 17500;
17502 -> 17501;
17503 -> 17502;
17503 -> 17499;
17504 -> 17499;
17504 -> 17138;
17505 -> 17138;
17506 -> 17138;
17507 -> 0;
17507 -> 17138;
17508 -> 17138;
17509 -> 17138;
17509 -> 17508;
17510 -> 17508;
17511 -> 17509;
17511 -> 17510;
17512 -> 17508;
17513 -> 17511;
17513 -> 17512;
17514 -> 17512;
17515 -> 17514;
17515 -> 17138;
17516 -> 17138;
17517 -> 17138;
17517 -> 17516;
17518 -> 17516;
17519 -> 17517;
17519 -> 17518;
17520 -> 17516;
17521 -> 17519;
17521 -> 17520;
17522 -> 17520;
17523 -> 17522;
17523 -> 17520;
17524 -> 17523;
17524 -> 17520;
17525 -> 17521;
17525 -> 17520;
17526 -> 17520;
17527 -> 17525;
17527 -> 17526;
17528 -> 17526;
17529 -> 17528;
17529 -> 17520;
17530 -> 17520;
17531 -> 17525;
17531 -> 17530;
17532 -> 17531;
17532 -> 17520;
17533 -> 17520;
17534 -> 17532;
17534 -> 17533;
17535 -> 17533;
17535 -> 17520;
17536 -> 17529;
17536 -> 17535;
17536 -> 17520;
17537 -> 17520;
17538 -> 17525;
17538 -> 17537;
17539 -> 17538;
17539 -> 17520;
17540 -> 17520;
17541 -> 17539;
17541 -> 17540;
17542 -> 17520;
17543 -> 17541;
17543 -> 17542;
17544 -> 17542;
17544 -> 17520;
17545 -> 17520;
17546 -> 17536;
17546 -> 17544;
17546 -> 17520;
17547 -> 17520;
17548 -> 17525;
17548 -> 17547;
17549 -> 17548;
17549 -> 17520;
17550 -> 17549;
17550 -> 2687;
17550 -> 17520;
17551 -> 17546;
17551 -> 17550;
17551 -> 17520;
17552 -> 17520;
17553 -> 17520;
17553 -> 17138;
17554 -> 17138;
17555 -> 17138;
17556 -> 17554;
17556 -> 17555;
17557 -> 17138;
17557 -> 17555;
17558 -> 17557;
17558 -> 17138;
17558 -> 17555;
17559 -> 17138;
17560 -> 17138;
17561 -> 17559;
17561 -> 17560;
17562 -> 17138;
17562 -> 17560;
17563 -> 17562;
17563 -> 17138;
17563 -> 17560;
17564 -> 17563;
17564 -> 17138;
17565 -> 17324;
17566 -> 17565;
17566 -> 17138;
17566 -> 17324;
17567 -> 17324;
17567 -> 17138;
17568 -> 17324;
17568 -> 17138;
17569 -> 17324;
17570 -> 17569;
17570 -> 17324;
17571 -> 17324;
17572 -> 17570;
17572 -> 17571;
17572 -> 17324;
17573 -> 17570;
17573 -> 17324;
17574 -> 17573;
17574 -> 17138;
17574 -> 17324;
17575 -> 17565;
17575 -> 17324;
17576 -> 17138;
17576 -> 17324;
17576 -> 0;
17577 -> 17576;
17578 -> 17138;
17578 -> 17577;
17579 -> 17577;
17580 -> 17578;
17580 -> 17579;
17581 -> 17580;
17581 -> 17577;
17582 -> 17577;
17583 -> 17581;
17583 -> 17582;
17584 -> 17577;
17585 -> 17583;
17585 -> 17584;
17586 -> 17585;
17586 -> 17584;
17587 -> 17584;
17588 -> 17586;
17588 -> 17587;
17589 -> 17588;
17589 -> 17576;
17590 -> 17576;
17591 -> 17589;
17591 -> 17590;
17592 -> 17138;
17592 -> 17590;
17593 -> 17591;
17593 -> 17590;
17594 -> 17593;
17595 -> 17138;
17596 -> 17138;
17596 -> 17595;
17597 -> 17595;
17598 -> 17596;
17598 -> 17597;
17599 -> 17598;
17599 -> 17324;
17599 -> 17597;
17600 -> 17595;
17601 -> 17599;
17601 -> 17600;
17602 -> 17600;
17603 -> 17602;
17603 -> 17138;
17604 -> 17603;
17605 -> 17138;
17605 -> 17604;
17606 -> 17604;
17607 -> 17605;
17607 -> 17606;
17608 -> 17607;
17608 -> 17324;
17608 -> 17606;
17609 -> 17604;
17610 -> 17608;
17610 -> 17609;
17611 -> 17609;
17612 -> 17611;
17612 -> 17609;
17613 -> 17612;
17613 -> 17609;
17614 -> 17610;
17614 -> 17609;
17615 -> 17609;
17616 -> 17614;
17616 -> 17615;
17617 -> 17615;
17618 -> 17617;
17618 -> 17609;
17619 -> 17609;
17620 -> 17614;
17620 -> 17619;
17621 -> 17620;
17621 -> 17609;
17622 -> 17609;
17623 -> 17621;
17623 -> 17622;
17624 -> 17622;
17624 -> 17609;
17625 -> 17618;
17625 -> 17624;
17625 -> 17609;
17626 -> 17609;
17627 -> 17614;
17627 -> 17626;
17628 -> 17627;
17628 -> 17609;
17629 -> 17609;
17630 -> 17628;
17630 -> 17629;
17631 -> 17609;
17632 -> 17630;
17632 -> 17631;
17633 -> 17631;
17633 -> 17609;
17634 -> 17609;
17635 -> 17625;
17635 -> 17633;
17635 -> 17609;
17636 -> 17609;
17637 -> 17614;
17637 -> 17636;
17638 -> 17637;
17638 -> 17609;
17639 -> 17638;
17639 -> 2687;
17639 -> 17609;
17640 -> 17635;
17640 -> 17639;
17640 -> 17609;
17641 -> 17609;
17642 -> 17609;
17642 -> 17603;
17643 -> 17324;
17643 -> 17138;
17644 -> 17138;
17645 -> 17643;
17645 -> 17644;
17645 -> 17138;
17646 -> 17324;
17646 -> 17645;
17647 -> 17645;
17648 -> 17646;
17648 -> 17647;
17648 -> 17645;
17649 -> 17324;
17649 -> 17648;
17650 -> 17648;
17651 -> 17649;
17651 -> 17650;
17651 -> 17648;
17652 -> 17324;
17653 -> 17138;
17653 -> 17324;
17654 -> 17653;
17654 -> 17324;
17655 -> 17324;
17656 -> 17138;
17656 -> 17324;
17657 -> 17324;
17658 -> 17656;
17658 -> 17657;
17659 -> 17138;
17659 -> 17657;
17660 -> 17658;
17660 -> 17657;
17661 -> 17657;
17662 -> 17660;
17662 -> 17661;
17663 -> 17659;
17663 -> 17661;
17664 -> 17663;
17664 -> 17324;
17664 -> 17661;
17665 -> 17664;
17665 -> 17657;
17666 -> 17324;
17667 -> 17138;
17668 -> 17324;
17668 -> 17667;
17669 -> 17668;
17669 -> 17138;
17670 -> 17138;
17671 -> 17138;
17672 -> 17670;
17672 -> 17671;
17673 -> 17138;
17673 -> 17671;
17674 -> 17672;
17674 -> 17671;
17675 -> 17671;
17676 -> 17674;
17676 -> 17675;
17677 -> 17673;
17677 -> 17675;
17678 -> 17675;
17679 -> 17676;
17679 -> 17678;
17680 -> 17679;
17680 -> 17324;
17680 -> 17678;
17681 -> 17680;
17681 -> 17675;
17682 -> 17677;
17682 -> 17324;
17682 -> 17681;
17683 -> 0;
17683 -> 17681;
17684 -> 17675;
17685 -> 17684;
17685 -> 17671;
17686 -> 17138;
17686 -> 17324;
17687 -> 17686;
17688 -> 17138;
17688 -> 17687;
17689 -> 17687;
17690 -> 17688;
17690 -> 17324;
17690 -> 17689;
17691 -> 17687;
17692 -> 17690;
17692 -> 17691;
17693 -> 17692;
17693 -> 17686;
17694 -> 17686;
17695 -> 17686;
17696 -> 17693;
17696 -> 17695;
17697 -> 17694;
17697 -> 17695;
17698 -> 17694;
17698 -> 17695;
17699 -> 17138;
17699 -> 17695;
17700 -> 17699;
17700 -> 17324;
17700 -> 17695;
17701 -> 0;
17701 -> 17695;
17702 -> 17700;
17702 -> 17696;
17702 -> 17324;
17702 -> 17695;
17703 -> 17138;
17704 -> 17703;
17704 -> 17138;
17705 -> 17138;
17705 -> 17324;
17706 -> 0;
17706 -> 17138;
17707 -> 17138;
17708 -> 17704;
17708 -> 17707;
17709 -> 17707;
17710 -> 17708;
17710 -> 17324;
17710 -> 17709;
17711 -> 17709;
17711 -> 17138;
17712 -> 17138;
17713 -> 17711;
17714 -> 17704;
17714 -> 17713;
17715 -> 17713;
17716 -> 17714;
17716 -> 17324;
17716 -> 17715;
17717 -> 17715;
17718 -> 17717;
17718 -> 17711;
17719 -> 17138;
17720 -> 17138;
17721 -> 17704;
17721 -> 17720;
17722 -> 17720;
17723 -> 17721;
17723 -> 17324;
17723 -> 17722;
17724 -> 17722;
17724 -> 17138;
17725 -> 17138;
17726 -> 17725;
17726 -> 17324;
17727 -> 17725;
17727 -> 17324;
17728 -> 17727;
17728 -> 17138;
17729 -> 17138;
17730 -> 17138;
17731 -> 17729;
17731 -> 17730;
17732 -> 17138;
17732 -> 17730;
17733 -> 17731;
17733 -> 17730;
17734 -> 17730;
17735 -> 17733;
17735 -> 17734;
17736 -> 17732;
17736 -> 17734;
17737 -> 17734;
17738 -> 17735;
17738 -> 17737;
17739 -> 17738;
17739 -> 17324;
17739 -> 17737;
17740 -> 17739;
17740 -> 17734;
17741 -> 17734;
17742 -> 17741;
17742 -> 17730;
17743 -> 17138;
17744 -> 17324;
17744 -> 17743;
17745 -> 17324;
17745 -> 17743;
17746 -> 17324;
17746 -> 17743;
17747 -> 17138;
17747 -> 17743;
17748 -> 17747;
17748 -> 17324;
17748 -> 17743;
17749 -> 0;
17749 -> 17743;
17750 -> 17748;
17750 -> 17744;
17750 -> 17324;
17750 -> 17743;
17751 -> 17138;
17752 -> 17138;
17753 -> 17751;
17753 -> 17752;
17754 -> 17387;
17754 -> 17752;
17755 -> 17753;
17755 -> 17752;
17756 -> 17752;
17757 -> 17755;
17757 -> 17756;
17758 -> 17754;
17758 -> 17756;
17759 -> 17756;
17760 -> 17757;
17760 -> 17759;
17761 -> 17760;
17761 -> 17324;
17761 -> 17759;
17762 -> 17761;
17762 -> 17756;
17763 -> 17758;
17763 -> 17324;
17763 -> 17762;
17763 -> 17756;
17764 -> 17138;
17765 -> 17764;
17765 -> 17324;
17766 -> 17764;
17766 -> 17324;
17767 -> 17766;
17767 -> 17138;
17768 -> 17138;
17769 -> 17767;
17769 -> 17768;
17770 -> 17387;
17770 -> 17768;
17771 -> 17770;
17771 -> 17324;
17771 -> 17768;
17772 -> 0;
17772 -> 17768;
17773 -> 17138;
17774 -> 17386;
17775 -> 17138;
17775 -> 17774;
17776 -> 17775;
17776 -> 17324;
17776 -> 17774;
17777 -> 17776;
17777 -> 17386;
17778 -> 17209;
17779 -> 17207;
17780 -> 17138;
17780 -> 17207;
17781 -> 17207;
17782 -> 17780;
17782 -> 17781;
17783 -> 17208;
17783 -> 17781;
17784 -> 17782;
17784 -> 17781;
17785 -> 17781;
17786 -> 17784;
17786 -> 17785;
17787 -> 17783;
17787 -> 17785;
17788 -> 17785;
17789 -> 17786;
17789 -> 17788;
17790 -> 17789;
17790 -> 17324;
17790 -> 17788;
17791 -> 17790;
17791 -> 17785;
17792 -> 17785;
17793 -> 17792;
17793 -> 17781;
17794 -> 17207;
17795 -> 17205;
17796 -> 17202;
17797 -> 17167;
17798 -> 1;
17799 -> 13805;
17799 -> 1;
17800 -> 1;
17801 -> 17799;
17801 -> 17800;
17802 -> 0;
17802 -> 17800;
17803 -> 17800;
17804 -> 17802;
17804 -> 17803;
17805 -> 17801;
17805 -> 17803;
17806 -> 17803;
17807 -> 17805;
17807 -> 17324;
17807 -> 17806;
17808 -> 9146;
17808 -> 17807;
17809 -> 17808;
17809 -> 17807;
17810 -> 17809;
17810 -> 0;
17810 -> 17807;
17811 -> 17809;
17811 -> 17807;
17812 -> 17807;
17813 -> 17812;
17813 -> 0;
17813 -> 17807;
17814 -> 17807;
17815 -> 17814;
17816 -> 17807;
17817 -> 17807;
17818 -> 17807;
17819 -> 17807;
17820 -> 17819;
17820 -> 17807;
17821 -> 17807;
17822 -> 17820;
17822 -> 17821;
17822 -> 17807;
17823 -> 17820;
17823 -> 17807;
17824 -> 17804;
17824 -> 17803;
17825 -> 17803;
17826 -> 17824;
17826 -> 17825;
17827 -> 17826;
17827 -> 17825;
17828 -> 17825;
17829 -> 17827;
17829 -> 17828;
17830 -> 17829;
17830 -> 17828;
17831 -> 17828;
17832 -> 17830;
17832 -> 17828;
17833 -> 17828;
17834 -> 17831;
17834 -> 17833;
17835 -> 17831;
17835 -> 17833;
17836 -> 17832;
17836 -> 17833;
17837 -> 17831;
17837 -> 17833;
17838 -> 17833;
17839 -> 17807;
17839 -> 17838;
17839 -> 17833;
17840 -> 17837;
17840 -> 17833;
17841 -> 17840;
17842 -> 17834;
17842 -> 17841;
17842 -> 17840;
17843 -> 17840;
17844 -> 17835;
17844 -> 17843;
17844 -> 17840;
17845 -> 17807;
17845 -> 17833;
17846 -> 17833;
17847 -> 17846;
17847 -> 17833;
17848 -> 17836;
17848 -> 17833;
17849 -> 17834;
17849 -> 17833;
17850 -> 17835;
17850 -> 17833;
17851 -> 17833;
17852 -> 17833;
17853 -> 17847;
17853 -> 17852;
17854 -> 17848;
17854 -> 17852;
17855 -> 17849;
17855 -> 17852;
17856 -> 17850;
17856 -> 17852;
17857 -> 17851;
17857 -> 17852;
17858 -> 17853;
17858 -> 17852;
17859 -> 17854;
17859 -> 17852;
17860 -> 17852;
17861 -> 17855;
17861 -> 17852;
17862 -> 17856;
17862 -> 17852;
17863 -> 17852;
17864 -> 17863;
17864 -> 17852;
17865 -> 17863;
17865 -> 17852;
17866 -> 0;
17866 -> 17852;
17867 -> 17851;
17867 -> 17833;
17868 -> 17833;
17869 -> 17867;
17869 -> 17868;
17870 -> 17869;
17870 -> 17868;
17871 -> 17868;
17872 -> 17870;
17872 -> 17871;
17873 -> 17871;
17874 -> 17872;
17874 -> 17873;
17875 -> 17873;
17876 -> 17874;
17876 -> 17875;
17877 -> 17876;
17877 -> 17807;
17877 -> 17875;
17878 -> 17876;
17878 -> 17807;
17878 -> 17864;
17878 -> 17865;
17878 -> 17875;
17879 -> 0;
17879 -> 17875;
17880 -> 17875;
17881 -> 17807;
17881 -> 17880;
17882 -> 17880;
17883 -> 17881;
17883 -> 17882;
17884 -> 17880;
17885 -> 17883;
17885 -> 17884;
17886 -> 17884;
17887 -> 17886;
17887 -> 17875;
17888 -> 17878;
17888 -> 17887;
17888 -> 17875;
17889 -> 0;
17889 -> 17875;
17890 -> 17875;
17891 -> 17807;
17891 -> 17890;
17892 -> 17890;
17893 -> 17891;
17893 -> 17892;
17894 -> 17890;
17895 -> 17893;
17895 -> 17894;
17896 -> 17894;
17897 -> 17896;
17897 -> 17894;
17898 -> 17894;
17899 -> 17897;
17899 -> 17898;
17900 -> 17895;
17900 -> 17898;
17901 -> 17898;
17902 -> 17900;
17902 -> 17901;
17903 -> 17901;
17904 -> 17903;
17904 -> 17898;
17905 -> 17898;
17906 -> 17900;
17906 -> 17905;
17907 -> 17906;
17907 -> 17898;
17908 -> 17898;
17909 -> 17907;
17909 -> 17908;
17910 -> 0;
17910 -> 17908;
17911 -> 17910;
17911 -> 17898;
17912 -> 17904;
17912 -> 17911;
17912 -> 17898;
17913 -> 17898;
17914 -> 17900;
17914 -> 17913;
17915 -> 17913;
17916 -> 17913;
17917 -> 17914;
17917 -> 17898;
17918 -> 17898;
17919 -> 17917;
17919 -> 17918;
17920 -> 17918;
17921 -> 17918;
17922 -> 17898;
17923 -> 17919;
17923 -> 17922;
17924 -> 17922;
17925 -> 17924;
17925 -> 17898;
17926 -> 17898;
17927 -> 17912;
17927 -> 17925;
17927 -> 17898;
17928 -> 17898;
17929 -> 17898;
17930 -> 17929;
17930 -> 17875;
17931 -> 17876;
17931 -> 17807;
17931 -> 17930;
17931 -> 17875;
17932 -> 17807;
17932 -> 17875;
17933 -> 17875;
17934 -> 17932;
17934 -> 17933;
17935 -> 17876;
17935 -> 17933;
17936 -> 17935;
17936 -> 17807;
17936 -> 17933;
17937 -> 0;
17937 -> 17933;
17938 -> 17875;
17939 -> 17807;
17939 -> 17875;
17940 -> 17875;
17941 -> 17939;
17941 -> 17940;
17942 -> 17876;
17942 -> 17940;
17943 -> 17940;
17944 -> 17941;
17944 -> 17943;
17945 -> 17943;
17946 -> 17943;
17947 -> 17944;
17947 -> 17940;
17948 -> 17942;
17948 -> 17807;
17948 -> 17947;
17948 -> 17940;
17949 -> 17875;
17950 -> 17949;
17951 -> 17949;
17952 -> 17949;
17953 -> 17952;
17954 -> 17953;
17955 -> 17875;
17956 -> 17807;
17956 -> 17955;
17957 -> 17876;
17957 -> 17955;
17958 -> 17956;
17958 -> 17955;
17959 -> 17955;
17960 -> 17958;
17960 -> 17959;
17960 -> 17955;
17961 -> 17957;
17961 -> 17807;
17961 -> 0;
17961 -> 17955;
17962 -> 17955;
17963 -> 17958;
17963 -> 17962;
17964 -> 17962;
17965 -> 17963;
17965 -> 17807;
17965 -> 17964;
17966 -> 17964;
17967 -> 17966;
17967 -> 17955;
17968 -> 17967;
17968 -> 17875;
17969 -> 17968;
17970 -> 17807;
17970 -> 17969;
17971 -> 17970;
17971 -> 17807;
17971 -> 17969;
17972 -> 17969;
17972 -> 17968;
17973 -> 17972;
17973 -> 17968;
17974 -> 17973;
17975 -> 17974;
17976 -> 17974;
17977 -> 17975;
17977 -> 17976;
17978 -> 17975;
17978 -> 17976;
17979 -> 17977;
17979 -> 17976;
17980 -> 17976;
17981 -> 17980;
17981 -> 17976;
17982 -> 17980;
17982 -> 17976;
17983 -> 17975;
17983 -> 17973;
17984 -> 17973;
17985 -> 17984;
17986 -> 17807;
17986 -> 17985;
17987 -> 17807;
17987 -> 17985;
17988 -> 17807;
17989 -> 17988;
17989 -> 17807;
17990 -> 17807;
17991 -> 17989;
17991 -> 17990;
17991 -> 17807;
17992 -> 17807;
17992 -> 0;
17993 -> 17989;
17993 -> 17807;
17994 -> 17993;
17994 -> 17807;
17995 -> 17807;
17996 -> 17807;
17997 -> 17993;
17997 -> 17807;
17998 -> 17807;
17999 -> 17998;
17999 -> 17807;
18000 -> 17985;
18001 -> 17807;
18001 -> 18000;
18002 -> 18001;
18002 -> 17807;
18002 -> 18000;
18003 -> 18000;
18003 -> 17985;
18004 -> 0;
18004 -> 18003;
18005 -> 18003;
18006 -> 18005;
18007 -> 18005;
18008 -> 18003;
18009 -> 18004;
18009 -> 18008;
18010 -> 18008;
18011 -> 18009;
18011 -> 18008;
18012 -> 17984;
18013 -> 17984;
18014 -> 17973;
18015 -> 17973;
18016 -> 17807;
18016 -> 18015;
18017 -> 18016;
18017 -> 17807;
18017 -> 18015;
18018 -> 18015;
18018 -> 17973;
18019 -> 17973;
18020 -> 17876;
18020 -> 18019;
18021 -> 0;
18021 -> 18019;
18022 -> 18019;
18023 -> 18019;
18024 -> 18021;
18024 -> 18023;
18025 -> 18022;
18025 -> 18023;
18026 -> 18020;
18026 -> 18023;
18027 -> 18023;
18028 -> 18024;
18028 -> 18023;
18029 -> 18025;
18029 -> 18023;
18030 -> 17973;
18031 -> 17876;
18031 -> 17807;
18031 -> 0;
18031 -> 17875;
18032 -> 18031;
18033 -> 17807;
18033 -> 18032;
18034 -> 18032;
18035 -> 18033;
18035 -> 18034;
18036 -> 18035;
18036 -> 18032;
18037 -> 18032;
18038 -> 18036;
18038 -> 18037;
18039 -> 18032;
18040 -> 18038;
18040 -> 18039;
18041 -> 18040;
18041 -> 18039;
18042 -> 18039;
18043 -> 18041;
18043 -> 18042;
18044 -> 18043;
18044 -> 18031;
18045 -> 18031;
18046 -> 18044;
18046 -> 18045;
18047 -> 17876;
18047 -> 18045;
18048 -> 18046;
18048 -> 18045;
18049 -> 18048;
18050 -> 17875;
18051 -> 17876;
18051 -> 18050;
18052 -> 18050;
18053 -> 17807;
18053 -> 18052;
18054 -> 18052;
18055 -> 18053;
18055 -> 18054;
18056 -> 18052;
18057 -> 18055;
18057 -> 18056;
18058 -> 18056;
18059 -> 18058;
18059 -> 18050;
18060 -> 18059;
18061 -> 17807;
18061 -> 18060;
18062 -> 18060;
18063 -> 18061;
18063 -> 18062;
18064 -> 18060;
18065 -> 18063;
18065 -> 18064;
18066 -> 18064;
18067 -> 18066;
18067 -> 18064;
18068 -> 18064;
18069 -> 18067;
18069 -> 18068;
18070 -> 18065;
18070 -> 18068;
18071 -> 18068;
18072 -> 18070;
18072 -> 18071;
18073 -> 18071;
18074 -> 18073;
18074 -> 18068;
18075 -> 18068;
18076 -> 18070;
18076 -> 18075;
18077 -> 18076;
18077 -> 18068;
18078 -> 18068;
18079 -> 18077;
18079 -> 18078;
18080 -> 0;
18080 -> 18078;
18081 -> 18080;
18081 -> 18068;
18082 -> 18074;
18082 -> 18081;
18082 -> 18068;
18083 -> 18068;
18084 -> 18070;
18084 -> 18083;
18085 -> 18083;
18086 -> 18083;
18087 -> 18084;
18087 -> 18068;
18088 -> 18068;
18089 -> 18087;
18089 -> 18088;
18090 -> 18088;
18091 -> 18088;
18092 -> 18068;
18093 -> 18089;
18093 -> 18092;
18094 -> 18092;
18095 -> 18094;
18095 -> 18068;
18096 -> 18068;
18097 -> 18082;
18097 -> 18095;
18097 -> 18068;
18098 -> 18068;
18099 -> 18068;
18100 -> 18099;
18100 -> 18059;
18101 -> 18050;
18102 -> 17807;
18102 -> 18050;
18103 -> 18050;
18104 -> 18102;
18104 -> 18103;
18104 -> 18050;
18105 -> 17807;
18105 -> 18104;
18106 -> 18104;
18107 -> 18105;
18107 -> 18106;
18107 -> 18104;
18108 -> 17807;
18108 -> 18107;
18109 -> 18107;
18110 -> 18108;
18110 -> 18109;
18110 -> 18107;
18111 -> 18050;
18112 -> 18111;
18113 -> 18112;
18114 -> 18112;
18115 -> 18050;
18116 -> 18101;
18116 -> 18115;
18116 -> 18050;
18117 -> 18116;
18118 -> 18117;
18119 -> 18117;
18120 -> 0;
18120 -> 18050;
18121 -> 17807;
18122 -> 18051;
18122 -> 17807;
18123 -> 18122;
18123 -> 17807;
18124 -> 0;
18124 -> 18050;
18125 -> 17807;
18126 -> 17807;
18127 -> 17807;
18128 -> 18126;
18128 -> 18127;
18129 -> 18051;
18129 -> 18127;
18130 -> 18128;
18130 -> 18127;
18131 -> 18127;
18132 -> 18130;
18132 -> 18131;
18133 -> 18129;
18133 -> 18131;
18134 -> 18131;
18135 -> 18132;
18135 -> 18134;
18136 -> 18135;
18136 -> 18131;
18137 -> 18133;
18137 -> 17807;
18137 -> 18136;
18137 -> 18131;
18138 -> 18050;
18139 -> 17807;
18139 -> 18138;
18140 -> 18139;
18140 -> 18050;
18141 -> 17875;
18142 -> 17873;
18143 -> 17807;
18143 -> 17873;
18144 -> 17873;
18145 -> 18143;
18145 -> 18144;
18146 -> 17874;
18146 -> 18144;
18147 -> 18145;
18147 -> 18144;
18148 -> 18144;
18149 -> 18147;
18149 -> 18148;
18150 -> 18146;
18150 -> 18148;
18151 -> 18148;
18152 -> 18149;
18152 -> 18151;
18153 -> 18152;
18153 -> 17807;
18153 -> 18151;
18154 -> 18153;
18154 -> 18148;
18155 -> 18148;
18156 -> 18155;
18156 -> 18144;
18157 -> 17873;
18158 -> 17871;
18159 -> 17868;
18160 -> 17833;
18161 -> 1;
18162 -> 13807;
18162 -> 1;
18163 -> 1;
18164 -> 18162;
18164 -> 18163;
18165 -> 0;
18165 -> 18163;
18166 -> 18163;
18167 -> 18165;
18167 -> 18166;
18168 -> 18164;
18168 -> 18166;
18169 -> 18166;
18170 -> 18168;
18170 -> 17807;
18170 -> 18169;
18171 -> 9146;
18171 -> 18170;
18172 -> 18171;
18172 -> 18170;
18173 -> 18172;
18173 -> 0;
18173 -> 18170;
18174 -> 18172;
18174 -> 18170;
18175 -> 18170;
18176 -> 18175;
18176 -> 0;
18176 -> 18170;
18177 -> 18170;
18178 -> 18177;
18179 -> 18170;
18180 -> 18170;
18181 -> 18170;
18182 -> 18170;
18183 -> 18182;
18183 -> 18170;
18184 -> 18170;
18185 -> 18183;
18185 -> 18184;
18185 -> 18170;
18186 -> 18183;
18186 -> 18170;
18187 -> 18167;
18187 -> 18166;
18188 -> 18166;
18189 -> 18187;
18189 -> 18188;
18190 -> 18189;
18190 -> 18188;
18191 -> 18188;
18192 -> 18190;
18192 -> 18191;
18193 -> 18192;
18193 -> 18191;
18194 -> 18191;
18195 -> 18193;
18195 -> 18191;
18196 -> 18191;
18197 -> 18194;
18197 -> 18196;
18198 -> 18194;
18198 -> 18196;
18199 -> 18195;
18199 -> 18196;
18200 -> 18194;
18200 -> 18196;
18201 -> 18196;
18202 -> 18170;
18202 -> 18201;
18202 -> 18196;
18203 -> 18200;
18203 -> 18196;
18204 -> 18203;
18205 -> 18197;
18205 -> 18204;
18205 -> 18203;
18206 -> 18203;
18207 -> 18198;
18207 -> 18206;
18207 -> 18203;
18208 -> 18170;
18208 -> 18196;
18209 -> 18196;
18210 -> 18209;
18210 -> 18196;
18211 -> 18199;
18211 -> 18196;
18212 -> 18197;
18212 -> 18196;
18213 -> 18198;
18213 -> 18196;
18214 -> 18196;
18215 -> 18196;
18216 -> 18210;
18216 -> 18215;
18217 -> 18211;
18217 -> 18215;
18218 -> 18212;
18218 -> 18215;
18219 -> 18213;
18219 -> 18215;
18220 -> 18214;
18220 -> 18215;
18221 -> 18216;
18221 -> 18215;
18222 -> 18217;
18222 -> 18215;
18223 -> 18215;
18224 -> 18218;
18224 -> 18215;
18225 -> 18219;
18225 -> 18215;
18226 -> 18215;
18227 -> 18226;
18227 -> 18215;
18228 -> 18226;
18228 -> 18215;
18229 -> 0;
18229 -> 18215;
18230 -> 18214;
18230 -> 18196;
18231 -> 18196;
18232 -> 18230;
18232 -> 18231;
18233 -> 18232;
18233 -> 18231;
18234 -> 18231;
18235 -> 18233;
18235 -> 18234;
18236 -> 18234;
18237 -> 18235;
18237 -> 18236;
18238 -> 18236;
18239 -> 18237;
18239 -> 18238;
18240 -> 18239;
18240 -> 18170;
18240 -> 18238;
18241 -> 18239;
18241 -> 18170;
18241 -> 18227;
18241 -> 18228;
18241 -> 18238;
18242 -> 0;
18242 -> 18238;
18243 -> 18238;
18244 -> 18170;
18244 -> 18243;
18245 -> 18243;
18246 -> 18244;
18246 -> 18245;
18247 -> 18243;
18248 -> 18246;
18248 -> 18247;
18249 -> 18247;
18250 -> 18249;
18250 -> 18238;
18251 -> 18241;
18251 -> 18250;
18251 -> 18238;
18252 -> 0;
18252 -> 18238;
18253 -> 18238;
18254 -> 18170;
18254 -> 18253;
18255 -> 18253;
18256 -> 18254;
18256 -> 18255;
18257 -> 18253;
18258 -> 18256;
18258 -> 18257;
18259 -> 18257;
18260 -> 18259;
18260 -> 18257;
18261 -> 18257;
18262 -> 18260;
18262 -> 18261;
18263 -> 18258;
18263 -> 18261;
18264 -> 18261;
18265 -> 18263;
18265 -> 18264;
18266 -> 18264;
18267 -> 18266;
18267 -> 18261;
18268 -> 18261;
18269 -> 18263;
18269 -> 18268;
18270 -> 18269;
18270 -> 18261;
18271 -> 18261;
18272 -> 18270;
18272 -> 18271;
18273 -> 0;
18273 -> 18271;
18274 -> 18273;
18274 -> 18261;
18275 -> 18267;
18275 -> 18274;
18275 -> 18261;
18276 -> 18261;
18277 -> 18263;
18277 -> 18276;
18278 -> 18276;
18279 -> 18276;
18280 -> 18277;
18280 -> 18261;
18281 -> 18261;
18282 -> 18280;
18282 -> 18281;
18283 -> 18281;
18284 -> 18281;
18285 -> 18261;
18286 -> 18282;
18286 -> 18285;
18287 -> 18285;
18288 -> 18287;
18288 -> 18261;
18289 -> 18261;
18290 -> 18275;
18290 -> 18288;
18290 -> 18261;
18291 -> 18261;
18292 -> 18261;
18293 -> 18292;
18293 -> 18238;
18294 -> 18239;
18294 -> 18170;
18294 -> 18293;
18294 -> 18238;
18295 -> 18170;
18295 -> 18238;
18296 -> 18238;
18297 -> 18295;
18297 -> 18296;
18298 -> 18239;
18298 -> 18296;
18299 -> 18298;
18299 -> 18170;
18299 -> 18296;
18300 -> 0;
18300 -> 18296;
18301 -> 18238;
18302 -> 18170;
18302 -> 18238;
18303 -> 18238;
18304 -> 18302;
18304 -> 18303;
18305 -> 18239;
18305 -> 18303;
18306 -> 18303;
18307 -> 18304;
18307 -> 18306;
18308 -> 18306;
18309 -> 18306;
18310 -> 18307;
18310 -> 18303;
18311 -> 18305;
18311 -> 18170;
18311 -> 18310;
18311 -> 18303;
18312 -> 18238;
18313 -> 18312;
18314 -> 18312;
18315 -> 18312;
18316 -> 18315;
18317 -> 18316;
18318 -> 18238;
18319 -> 18170;
18319 -> 18318;
18320 -> 18239;
18320 -> 18318;
18321 -> 18319;
18321 -> 18318;
18322 -> 18318;
18323 -> 18321;
18323 -> 18322;
18323 -> 18318;
18324 -> 18320;
18324 -> 18170;
18324 -> 0;
18324 -> 18318;
18325 -> 18318;
18326 -> 18321;
18326 -> 18325;
18327 -> 18325;
18328 -> 18326;
18328 -> 18170;
18328 -> 18327;
18329 -> 18327;
18330 -> 18329;
18330 -> 18318;
18331 -> 18330;
18331 -> 18238;
18332 -> 18331;
18333 -> 18170;
18333 -> 18332;
18334 -> 18333;
18334 -> 18170;
18334 -> 18332;
18335 -> 18332;
18335 -> 18331;
18336 -> 18335;
18336 -> 18331;
18337 -> 18336;
18338 -> 18337;
18339 -> 18337;
18340 -> 18338;
18340 -> 18339;
18341 -> 18338;
18341 -> 18339;
18342 -> 18340;
18342 -> 18339;
18343 -> 18339;
18344 -> 18343;
18344 -> 18339;
18345 -> 18343;
18345 -> 18339;
18346 -> 18338;
18346 -> 18336;
18347 -> 18336;
18348 -> 18347;
18349 -> 18170;
18349 -> 18348;
18350 -> 18170;
18350 -> 18348;
18351 -> 18170;
18352 -> 18351;
18352 -> 18170;
18353 -> 18170;
18354 -> 18352;
18354 -> 18353;
18354 -> 18170;
18355 -> 18170;
18355 -> 0;
18356 -> 18352;
18356 -> 18170;
18357 -> 18356;
18357 -> 18170;
18358 -> 18170;
18359 -> 18170;
18360 -> 18356;
18360 -> 18170;
18361 -> 18170;
18362 -> 18361;
18362 -> 18170;
18363 -> 18348;
18364 -> 18170;
18364 -> 18363;
18365 -> 18364;
18365 -> 18170;
18365 -> 18363;
18366 -> 18363;
18366 -> 18348;
18367 -> 0;
18367 -> 18366;
18368 -> 18366;
18369 -> 18368;
18370 -> 18368;
18371 -> 18366;
18372 -> 18367;
18372 -> 18371;
18373 -> 18371;
18374 -> 18372;
18374 -> 18371;
18375 -> 18347;
18376 -> 18347;
18377 -> 18336;
18378 -> 18336;
18379 -> 18170;
18379 -> 18378;
18380 -> 18379;
18380 -> 18170;
18380 -> 18378;
18381 -> 18378;
18381 -> 18336;
18382 -> 18336;
18383 -> 18239;
18383 -> 18382;
18384 -> 0;
18384 -> 18382;
18385 -> 18382;
18386 -> 18382;
18387 -> 18384;
18387 -> 18386;
18388 -> 18385;
18388 -> 18386;
18389 -> 18383;
18389 -> 18386;
18390 -> 18386;
18391 -> 18387;
18391 -> 18386;
18392 -> 18388;
18392 -> 18386;
18393 -> 18336;
18394 -> 18239;
18394 -> 18170;
18394 -> 0;
18394 -> 18238;
18395 -> 18394;
18396 -> 18170;
18396 -> 18395;
18397 -> 18395;
18398 -> 18396;
18398 -> 18397;
18399 -> 18398;
18399 -> 18395;
18400 -> 18395;
18401 -> 18399;
18401 -> 18400;
18402 -> 18395;
18403 -> 18401;
18403 -> 18402;
18404 -> 18403;
18404 -> 18402;
18405 -> 18402;
18406 -> 18404;
18406 -> 18405;
18407 -> 18406;
18407 -> 18394;
18408 -> 18394;
18409 -> 18407;
18409 -> 18408;
18410 -> 18239;
18410 -> 18408;
18411 -> 18409;
18411 -> 18408;
18412 -> 18411;
18413 -> 18238;
18414 -> 18239;
18414 -> 18413;
18415 -> 18413;
18416 -> 18170;
18416 -> 18415;
18417 -> 18415;
18418 -> 18416;
18418 -> 18417;
18419 -> 18415;
18420 -> 18418;
18420 -> 18419;
18421 -> 18419;
18422 -> 18421;
18422 -> 18413;
18423 -> 18422;
18424 -> 18170;
18424 -> 18423;
18425 -> 18423;
18426 -> 18424;
18426 -> 18425;
18427 -> 18423;
18428 -> 18426;
18428 -> 18427;
18429 -> 18427;
18430 -> 18429;
18430 -> 18427;
18431 -> 18427;
18432 -> 18430;
18432 -> 18431;
18433 -> 18428;
18433 -> 18431;
18434 -> 18431;
18435 -> 18433;
18435 -> 18434;
18436 -> 18434;
18437 -> 18436;
18437 -> 18431;
18438 -> 18431;
18439 -> 18433;
18439 -> 18438;
18440 -> 18439;
18440 -> 18431;
18441 -> 18431;
18442 -> 18440;
18442 -> 18441;
18443 -> 0;
18443 -> 18441;
18444 -> 18443;
18444 -> 18431;
18445 -> 18437;
18445 -> 18444;
18445 -> 18431;
18446 -> 18431;
18447 -> 18433;
18447 -> 18446;
18448 -> 18446;
18449 -> 18446;
18450 -> 18447;
18450 -> 18431;
18451 -> 18431;
18452 -> 18450;
18452 -> 18451;
18453 -> 18451;
18454 -> 18451;
18455 -> 18431;
18456 -> 18452;
18456 -> 18455;
18457 -> 18455;
18458 -> 18457;
18458 -> 18431;
18459 -> 18431;
18460 -> 18445;
18460 -> 18458;
18460 -> 18431;
18461 -> 18431;
18462 -> 18431;
18463 -> 18462;
18463 -> 18422;
18464 -> 18413;
18465 -> 18170;
18465 -> 18413;
18466 -> 18413;
18467 -> 18465;
18467 -> 18466;
18467 -> 18413;
18468 -> 18170;
18468 -> 18467;
18469 -> 18467;
18470 -> 18468;
18470 -> 18469;
18470 -> 18467;
18471 -> 18170;
18471 -> 18470;
18472 -> 18470;
18473 -> 18471;
18473 -> 18472;
18473 -> 18470;
18474 -> 18413;
18475 -> 18474;
18476 -> 18475;
18477 -> 18475;
18478 -> 18413;
18479 -> 18464;
18479 -> 18478;
18479 -> 18413;
18480 -> 18479;
18481 -> 18480;
18482 -> 18480;
18483 -> 0;
18483 -> 18413;
18484 -> 18170;
18485 -> 18414;
18485 -> 18170;
18486 -> 18485;
18486 -> 18170;
18487 -> 0;
18487 -> 18413;
18488 -> 18170;
18489 -> 18170;
18490 -> 18170;
18491 -> 18489;
18491 -> 18490;
18492 -> 18414;
18492 -> 18490;
18493 -> 18491;
18493 -> 18490;
18494 -> 18490;
18495 -> 18493;
18495 -> 18494;
18496 -> 18492;
18496 -> 18494;
18497 -> 18494;
18498 -> 18495;
18498 -> 18497;
18499 -> 18498;
18499 -> 18494;
18500 -> 18496;
18500 -> 18170;
18500 -> 18499;
18500 -> 18494;
18501 -> 18413;
18502 -> 18170;
18502 -> 18501;
18503 -> 18502;
18503 -> 18413;
18504 -> 18238;
18505 -> 18236;
18506 -> 18170;
18506 -> 18236;
18507 -> 18236;
18508 -> 18506;
18508 -> 18507;
18509 -> 18237;
18509 -> 18507;
18510 -> 18508;
18510 -> 18507;
18511 -> 18507;
18512 -> 18510;
18512 -> 18511;
18513 -> 18509;
18513 -> 18511;
18514 -> 18511;
18515 -> 18512;
18515 -> 18514;
18516 -> 18515;
18516 -> 18170;
18516 -> 18514;
18517 -> 18516;
18517 -> 18511;
18518 -> 18511;
18519 -> 18518;
18519 -> 18507;
18520 -> 18236;
18521 -> 18234;
18522 -> 18231;
18523 -> 18196;
18524 -> 1;
18525 -> 1;
18526 -> 18524;
18526 -> 18525;
18527 -> 3299;
18527 -> 18525;
18528 -> 18525;
18529 -> 18528;
18529 -> 18525;
18530 -> 18525;
18531 -> 18527;
18531 -> 18530;
18532 -> 0;
18532 -> 18530;
18533 -> 18530;
18534 -> 18532;
18534 -> 18533;
18535 -> 18531;
18535 -> 18170;
18535 -> 18533;
18536 -> 18535;
18536 -> 18170;
18536 -> 18534;
18536 -> 18533;
18537 -> 18531;
18537 -> 18170;
18537 -> 18536;
18538 -> 18526;
18538 -> 18525;
18539 -> 18528;
18539 -> 18525;
18540 -> 18537;
18540 -> 18538;
18540 -> 18539;
18540 -> 18170;
18540 -> 18529;
18540 -> 18525;
18541 -> 1;
18542 -> 18540;
18542 -> 18541;
18543 -> 18541;
18544 -> 0;
18544 -> 18543;
18545 -> 18543;
18546 -> 18544;
18546 -> 18545;
18547 -> 18545;
18548 -> 18546;
18548 -> 18547;
18548 -> 18545;
18549 -> 18545;
18550 -> 18542;
18550 -> 18540;
18550 -> 18549;
18550 -> 18545;
18551 -> 18545;
18552 -> 18551;
18553 -> 18552;
18554 -> 18545;
18555 -> 18545;
18556 -> 18555;
18557 -> 18542;
18557 -> 18556;
18558 -> 0;
18558 -> 18556;
18559 -> 18558;
18559 -> 18555;
18560 -> 18555;
18561 -> 18560;
18562 -> 18560;
18563 -> 18555;
18564 -> 18545;
18565 -> 18545;
18566 -> 18565;
18566 -> 18545;
18567 -> 18545;
18568 -> 18545;
18569 -> 18542;
18569 -> 18568;
18570 -> 18568;
18571 -> 18570;
18571 -> 18545;
18572 -> 18545;
18573 -> 18571;
18573 -> 18572;
18573 -> 18545;
18574 -> 18573;
18575 -> 18573;
18576 -> 18573;
18577 -> 18575;
18577 -> 18576;
18578 -> 18577;
18578 -> 18576;
18579 -> 18576;
18580 -> 18576;
18581 -> 18579;
18581 -> 18580;
18582 -> 18581;
18582 -> 18580;
18583 -> 18580;
18584 -> 18583;
18585 -> 18584;
18586 -> 18580;
18587 -> 18580;
18588 -> 18580;
18589 -> 18587;
18589 -> 18580;
18590 -> 18542;
18591 -> 18573;
18592 -> 18573;
18593 -> 18591;
18593 -> 18592;
18594 -> 18591;
18594 -> 18592;
18595 -> 18592;
18596 -> 18592;
18597 -> 18593;
18597 -> 18592;
18598 -> 18594;
18598 -> 18592;
18599 -> 18592;
18600 -> 18597;
18600 -> 18599;
18601 -> 18598;
18601 -> 18599;
18602 -> 18599;
18603 -> 18590;
18603 -> 18602;
18603 -> 18599;
18604 -> 18601;
18604 -> 18599;
18605 -> 18600;
18605 -> 18599;
18606 -> 18601;
18606 -> 18599;
18607 -> 18599;
18608 -> 18605;
18608 -> 18607;
18609 -> 18606;
18609 -> 18607;
18610 -> 18607;
18611 -> 18607;
18612 -> 18608;
18612 -> 18611;
18613 -> 18610;
18613 -> 18611;
18614 -> 18613;
18614 -> 18611;
18615 -> 18612;
18615 -> 18614;
18616 -> 18608;
18616 -> 18610;
18616 -> 18607;
18617 -> 18609;
18617 -> 18610;
18617 -> 18607;
18618 -> 18616;
18618 -> 18617;
18618 -> 18607;
18619 -> 18599;
18620 -> 18599;
18621 -> 18620;
18622 -> 18621;
18623 -> 18622;
18624 -> 18623;
18625 -> 18624;
18626 -> 5280;
18626 -> 18625;
18627 -> 18625;
18628 -> 18625;
18629 -> 18628;
18630 -> 18590;
18630 -> 18629;
18631 -> 18629;
18632 -> 18629;
18633 -> 18629;
18634 -> 18632;
18634 -> 18633;
18635 -> 18632;
18635 -> 18628;
18636 -> 18628;
18637 -> 18628;
18638 -> 18635;
18638 -> 18628;
18639 -> 18636;
18639 -> 18628;
18640 -> 18628;
18641 -> 18590;
18641 -> 18640;
18642 -> 18590;
18642 -> 18640;
18643 -> 18642;
18643 -> 18590;
18643 -> 18641;
18643 -> 18640;
18644 -> 18623;
18645 -> 0;
18645 -> 18644;
18646 -> 18644;
18647 -> 18645;
18647 -> 18646;
18648 -> 0;
18648 -> 18573;
18649 -> 18573;
18650 -> 18648;
18650 -> 18649;
18651 -> 18542;
18651 -> 18649;
18652 -> 18649;
18653 -> 18651;
18653 -> 18652;
18653 -> 18649;
18654 -> 18649;
18655 -> 18649;
18656 -> 18651;
18656 -> 18655;
18657 -> 18654;
18657 -> 18655;
18658 -> 18655;
18659 -> 18657;
18659 -> 18658;
18660 -> 18659;
18660 -> 18658;
18661 -> 18659;
18661 -> 18658;
18662 -> 18659;
18662 -> 18658;
18663 -> 18659;
18663 -> 18658;
18664 -> 18659;
18664 -> 18658;
18665 -> 18658;
18666 -> 18643;
18666 -> 18665;
18666 -> 18658;
18667 -> 18643;
18667 -> 18658;
18668 -> 0;
18668 -> 18658;
18669 -> 18658;
18670 -> 18667;
18670 -> 18669;
18671 -> 18668;
18671 -> 18669;
18672 -> 18643;
18672 -> 18658;
18673 -> 0;
18673 -> 18658;
18674 -> 18658;
18675 -> 18672;
18675 -> 18674;
18676 -> 18673;
18676 -> 18674;
18677 -> 18657;
18677 -> 18655;
18678 -> 18655;
18679 -> 18655;
18680 -> 18656;
18680 -> 18679;
18681 -> 18678;
18681 -> 18679;
18682 -> 18681;
18682 -> 18679;
18683 -> 18680;
18683 -> 18682;
18684 -> 18656;
18684 -> 18678;
18684 -> 18655;
18685 -> 18656;
18685 -> 18657;
18685 -> 18655;
18686 -> 18654;
18686 -> 18573;
18687 -> 18573;
18688 -> 18573;
18689 -> 18688;
18690 -> 18643;
18691 -> 18643;
18692 -> 18690;
18692 -> 18643;
18693 -> 18691;
18693 -> 18643;
18694 -> 18643;
18695 -> 18692;
18695 -> 18693;
18695 -> 18643;
18696 -> 18692;
18696 -> 18643;
18697 -> 18695;
18697 -> 18643;
18698 -> 18643;
18699 -> 18696;
18699 -> 18643;
18700 -> 18690;
18700 -> 18694;
18700 -> 18643;
18701 -> 18699;
18701 -> 18693;
18701 -> 18643;
18702 -> 18701;
18702 -> 18643;
18703 -> 18692;
18704 -> 18703;
18704 -> 18692;
18705 -> 18703;
18705 -> 18692;
18706 -> 18705;
18706 -> 18692;
18707 -> 18704;
18707 -> 18692;
18708 -> 18692;
18708 -> 0;
18709 -> 18692;
18710 -> 18692;
18711 -> 18692;
18712 -> 18711;
18712 -> 18692;
18713 -> 18712;
18714 -> 18712;
18714 -> 18713;
18715 -> 18713;
18716 -> 18714;
18716 -> 18715;
18717 -> 18715;
18718 -> 18716;
18718 -> 18692;
18718 -> 18717;
18718 -> 18715;
18719 -> 18713;
18720 -> 18714;
18720 -> 18692;
18720 -> 18713;
18721 -> 18720;
18721 -> 18712;
18722 -> 18712;
18723 -> 18692;
18724 -> 18723;
18724 -> 18692;
18725 -> 18692;
18726 -> 18707;
18726 -> 18692;
18727 -> 18706;
18727 -> 18692;
18728 -> 18692;
18729 -> 18728;
18729 -> 18692;
18730 -> 18692;
18731 -> 18729;
18731 -> 18730;
18731 -> 18692;
18732 -> 18703;
18732 -> 18692;
18733 -> 18703;
18733 -> 18692;
18734 -> 18703;
18734 -> 0;
18734 -> 18692;
18735 -> 18703;
18735 -> 18692;
18736 -> 18703;
18736 -> 18735;
18737 -> 18735;
18738 -> 18736;
18738 -> 18737;
18739 -> 18703;
18739 -> 18692;
18740 -> 18739;
18740 -> 18692;
18741 -> 18703;
18741 -> 18740;
18742 -> 18740;
18743 -> 18741;
18743 -> 18742;
18744 -> 18703;
18744 -> 0;
18744 -> 18692;
18745 -> 18692;
18746 -> 18743;
18746 -> 18745;
18746 -> 18692;
18747 -> 18692;
18748 -> 18703;
18748 -> 18747;
18748 -> 18692;
18749 -> 18692;
18750 -> 18703;
18750 -> 18749;
18751 -> 18750;
18751 -> 18692;
18752 -> 18692;
18753 -> 18752;
18753 -> 18703;
18753 -> 18692;
18754 -> 18692;
18755 -> 18754;
18755 -> 18703;
18755 -> 18692;
18756 -> 18703;
18757 -> 18703;
18758 -> 18703;
18759 -> 18756;
18759 -> 18703;
18760 -> 18757;
18760 -> 18703;
18761 -> 18758;
18761 -> 18703;
18762 -> 18759;
18762 -> 18703;
18763 -> 18760;
18763 -> 18703;
18764 -> 18761;
18764 -> 18703;
18765 -> 18703;
18766 -> 18762;
18766 -> 18703;
18767 -> 18763;
18767 -> 18703;
18768 -> 18764;
18768 -> 18703;
18769 -> 18766;
18769 -> 18703;
18770 -> 18767;
18770 -> 18703;
18771 -> 18768;
18771 -> 18703;
18772 -> 18703;
18773 -> 18771;
18773 -> 18703;
18774 -> 18770;
18774 -> 18703;
18775 -> 18703;
18776 -> 18769;
18776 -> 18703;
18777 -> 18773;
18777 -> 18703;
18778 -> 18774;
18778 -> 18703;
18779 -> 18775;
18779 -> 18703;
18780 -> 18776;
18780 -> 18703;
18781 -> 18703;
18782 -> 18703;
18783 -> 18780;
18783 -> 18782;
18784 -> 18783;
18784 -> 18685;
18784 -> 18782;
18785 -> 18703;
18786 -> 18780;
18786 -> 18785;
18787 -> 18785;
18788 -> 18786;
18788 -> 18787;
18789 -> 18788;
18789 -> 18685;
18789 -> 18787;
18790 -> 18789;
18790 -> 18785;
18791 -> 18790;
18791 -> 18785;
18792 -> 18785;
18793 -> 18790;
18793 -> 18792;
18794 -> 0;
18794 -> 18792;
18795 -> 18794;
18795 -> 18785;
18796 -> 18791;
18796 -> 18795;
18796 -> 18785;
18797 -> 18790;
18797 -> 18785;
18798 -> 18797;
18799 -> 18798;
18799 -> 18797;
18800 -> 18777;
18800 -> 18703;
18801 -> 18778;
18801 -> 18703;
18802 -> 18779;
18802 -> 18703;
18803 -> 18784;
18803 -> 18703;
18804 -> 18799;
18804 -> 18703;
18805 -> 18780;
18805 -> 18703;
18806 -> 18703;
18807 -> 18703;
18807 -> 18806;
18808 -> 18806;
18808 -> 18703;
18809 -> 18703;
18810 -> 18703;
18810 -> 18809;
18811 -> 18809;
18811 -> 18703;
18812 -> 18804;
18812 -> 18703;
18813 -> 18802;
18813 -> 18703;
18814 -> 18813;
18814 -> 18703;
18815 -> 18800;
18815 -> 18703;
18816 -> 18801;
18816 -> 18703;
18817 -> 18803;
18817 -> 18703;
18818 -> 18805;
18818 -> 18703;
18819 -> 18703;
18820 -> 18815;
18820 -> 18819;
18820 -> 18703;
18821 -> 18817;
18821 -> 18703;
18822 -> 18703;
18823 -> 18703;
18823 -> 5646;
18824 -> 18703;
18825 -> 18703;
18825 -> 5646;
18826 -> 18703;
18826 -> 5646;
18827 -> 18703;
18828 -> 18703;
18828 -> 18827;
18829 -> 18827;
18829 -> 18703;
18830 -> 18703;
18831 -> 18830;
18831 -> 18703;
18832 -> 18703;
18833 -> 18831;
18833 -> 18832;
18833 -> 18703;
18834 -> 18833;
18834 -> 18703;
18835 -> 18834;
18835 -> 18703;
18836 -> 0;
18836 -> 18835;
18837 -> 18703;
18838 -> 18836;
18838 -> 18703;
18839 -> 18703;
18840 -> 18837;
18840 -> 18839;
18840 -> 18703;
18841 -> 18836;
18841 -> 18703;
18842 -> 18841;
18842 -> 18703;
18843 -> 18813;
18843 -> 18842;
18844 -> 18703;
18845 -> 18643;
18846 -> 18643;
18847 -> 18699;
18847 -> 18643;
18848 -> 18643;
18849 -> 18643;
18850 -> 18703;
18850 -> 18849;
18851 -> 18850;
18851 -> 18753;
18851 -> 18849;
18852 -> 18851;
18852 -> 0;
18852 -> 18849;
18853 -> 18852;
18853 -> 18643;
18854 -> 18643;
18855 -> 18703;
18855 -> 18854;
18856 -> 18855;
18856 -> 18703;
18856 -> 18854;
18857 -> 18854;
18858 -> 18856;
18858 -> 18857;
18859 -> 18855;
18859 -> 18703;
18859 -> 18857;
18860 -> 18857;
18861 -> 18858;
18861 -> 18860;
18862 -> 18861;
18862 -> 18703;
18862 -> 0;
18862 -> 18860;
18863 -> 18860;
18864 -> 18862;
18864 -> 18643;
18865 -> 18698;
18865 -> 18703;
18866 -> 18703;
18867 -> 18703;
18868 -> 18703;
18869 -> 18867;
18869 -> 18868;
18870 -> 18867;
18870 -> 18868;
18871 -> 18867;
18871 -> 18868;
18872 -> 18867;
18872 -> 18868;
18873 -> 18867;
18873 -> 18868;
18874 -> 18870;
18874 -> 18868;
18875 -> 18871;
18875 -> 18868;
18876 -> 18872;
18876 -> 18868;
18877 -> 18873;
18877 -> 18868;
18878 -> 0;
18878 -> 18868;
18879 -> 18868;
18880 -> 18878;
18880 -> 18879;
18881 -> 18869;
18881 -> 18879;
18882 -> 18879;
18883 -> 18881;
18883 -> 18882;
18884 -> 18883;
18884 -> 18879;
18885 -> 18884;
18886 -> 18884;
18886 -> 18885;
18887 -> 18885;
18888 -> 18886;
18888 -> 18887;
18889 -> 18887;
18890 -> 18888;
18890 -> 18703;
18890 -> 18889;
18890 -> 18887;
18891 -> 18885;
18892 -> 18886;
18892 -> 18703;
18892 -> 18885;
18893 -> 18892;
18893 -> 18884;
18894 -> 18884;
18895 -> 18881;
18895 -> 18703;
18895 -> 18880;
18895 -> 18879;
18896 -> 18881;
18896 -> 18703;
18896 -> 18880;
18896 -> 18879;
18897 -> 18868;
18898 -> 18874;
18898 -> 18897;
18899 -> 18875;
18899 -> 18897;
18900 -> 18876;
18900 -> 18897;
18901 -> 18877;
18901 -> 18897;
18902 -> 18896;
18902 -> 18897;
18903 -> 18900;
18903 -> 18867;
18903 -> 18901;
18903 -> 18897;
18904 -> 18898;
18904 -> 18903;
18905 -> 18899;
18905 -> 18903;
18906 -> 18902;
18906 -> 18903;
18907 -> 18903;
18908 -> 18903;
18909 -> 18904;
18909 -> 18908;
18910 -> 18905;
18910 -> 18908;
18911 -> 18906;
18911 -> 18908;
18912 -> 18907;
18912 -> 18908;
18913 -> 18909;
18913 -> 18908;
18914 -> 18910;
18914 -> 18908;
18915 -> 18911;
18915 -> 18908;
18916 -> 18908;
18917 -> 18913;
18917 -> 18916;
18918 -> 18914;
18918 -> 18916;
18919 -> 18915;
18919 -> 18916;
18920 -> 18912;
18920 -> 18916;
18921 -> 18917;
18921 -> 18916;
18922 -> 18919;
18922 -> 18916;
18923 -> 18916;
18924 -> 18921;
18924 -> 18923;
18925 -> 18922;
18925 -> 18923;
18926 -> 18920;
18926 -> 18923;
18927 -> 18923;
18928 -> 18924;
18928 -> 18927;
18929 -> 18928;
18929 -> 18923;
18930 -> 18923;
18931 -> 18925;
18931 -> 18930;
18931 -> 18923;
18932 -> 18920;
18932 -> 18916;
18933 -> 18916;
18934 -> 18918;
18934 -> 18933;
18934 -> 18916;
18935 -> 18918;
18935 -> 18920;
18935 -> 18916;
18936 -> 18907;
18936 -> 18703;
18937 -> 18907;
18937 -> 18703;
18938 -> 18703;
18938 -> 0;
18939 -> 18703;
18940 -> 18907;
18940 -> 18939;
18941 -> 18939;
18942 -> 18940;
18942 -> 18941;
18943 -> 18942;
18943 -> 18941;
18944 -> 18943;
18944 -> 18941;
18945 -> 18944;
18945 -> 18941;
18946 -> 18941;
18946 -> 18939;
18947 -> 18940;
18947 -> 18946;
18947 -> 18939;
18948 -> 18907;
18948 -> 18703;
18949 -> 18948;
18949 -> 18703;
18950 -> 18907;
18950 -> 18949;
18951 -> 18949;
18952 -> 18950;
18952 -> 18951;
18953 -> 18952;
18953 -> 18951;
18954 -> 18953;
18954 -> 18951;
18955 -> 18954;
18955 -> 18951;
18956 -> 18951;
18956 -> 18949;
18957 -> 18703;
18957 -> 0;
18958 -> 18703;
18959 -> 18956;
18959 -> 18958;
18959 -> 18703;
18960 -> 18703;
18961 -> 18643;
18962 -> 18703;
18962 -> 18961;
18963 -> 18962;
18963 -> 18907;
18963 -> 18961;
18964 -> 18963;
18964 -> 18643;
18965 -> 18643;
18966 -> 18965;
18966 -> 18643;
18967 -> 18643;
18968 -> 18967;
18968 -> 18643;
18969 -> 18907;
18970 -> 18907;
18971 -> 18907;
18972 -> 18969;
18972 -> 18907;
18973 -> 18970;
18973 -> 18907;
18974 -> 18971;
18974 -> 18907;
18975 -> 18972;
18975 -> 18907;
18976 -> 18973;
18976 -> 18907;
18977 -> 18974;
18977 -> 18907;
18978 -> 18907;
18978 -> 18703;
18979 -> 18975;
18979 -> 18907;
18980 -> 18976;
18980 -> 18907;
18981 -> 18977;
18981 -> 18907;
18982 -> 18979;
18982 -> 18907;
18983 -> 18980;
18983 -> 18907;
18984 -> 18981;
18984 -> 18907;
18985 -> 18907;
18985 -> 18703;
18986 -> 18984;
18986 -> 18907;
18987 -> 18983;
18987 -> 18907;
18988 -> 18907;
18989 -> 18982;
18989 -> 18907;
18990 -> 18986;
18990 -> 18907;
18991 -> 18987;
18991 -> 18907;
18992 -> 18988;
18992 -> 18907;
18993 -> 18989;
18993 -> 18907;
18994 -> 18907;
18995 -> 18907;
18996 -> 18690;
18996 -> 18643;
18997 -> 18907;
18997 -> 18849;
18998 -> 18997;
18998 -> 18966;
18998 -> 18849;
18999 -> 18998;
18999 -> 0;
18999 -> 18849;
19000 -> 18999;
19000 -> 18643;
19001 -> 18573;
19002 -> 18542;
19002 -> 19001;
19003 -> 19001;
19004 -> 19002;
19004 -> 19003;
19005 -> 19004;
19005 -> 18703;
19005 -> 19003;
19006 -> 19005;
19006 -> 0;
19006 -> 19001;
19007 -> 19001;
19008 -> 19006;
19008 -> 19007;
19008 -> 19001;
19009 -> 19008;
19009 -> 18573;
19010 -> 18545;
19011 -> 19010;
19012 -> 19011;
19013 -> 19011;
19014 -> 18545;
19015 -> 19014;
19016 -> 18907;
19016 -> 18703;
19016 -> 19015;
19017 -> 19015;
19018 -> 19017;
19019 -> 19017;
19020 -> 19017;
19021 -> 19019;
19021 -> 19020;
19022 -> 18907;
19022 -> 19020;
19023 -> 19022;
19023 -> 19020;
19024 -> 18907;
19024 -> 19023;
19025 -> 19023;
19026 -> 19024;
19026 -> 19025;
19027 -> 19026;
19027 -> 19025;
19028 -> 19027;
19028 -> 19025;
19029 -> 19028;
19029 -> 19025;
19030 -> 19025;
19030 -> 19023;
19031 -> 18907;
19031 -> 0;
19031 -> 19020;
19032 -> 19020;
19033 -> 19030;
19033 -> 19032;
19033 -> 19020;
19034 -> 19020;
19035 -> 18703;
19035 -> 19034;
19035 -> 19020;
19036 -> 19019;
19036 -> 19015;
19037 -> 19036;
19037 -> 18545;
19038 -> 18545;
19039 -> 18545;
19040 -> 19037;
19040 -> 19039;
19041 -> 19038;
19041 -> 19039;
19042 -> 19040;
19042 -> 19041;
19042 -> 19039;
19043 -> 18703;
19043 -> 19038;
19043 -> 19042;
19043 -> 18907;
19043 -> 18920;
19043 -> 18925;
19043 -> 18924;
19043 -> 18935;
19043 -> 18545;
19044 -> 19043;
19044 -> 18703;
19045 -> 19043;
19046 -> 19043;
19046 -> 19045;
19047 -> 19045;
19048 -> 19047;
19048 -> 19043;
19049 -> 19043;
19049 -> 19048;
19050 -> 19048;
19051 -> 19049;
19051 -> 19050;
19052 -> 19050;
19053 -> 19051;
19053 -> 19052;
19054 -> 19052;
19054 -> 19050;
19055 -> 19054;
19055 -> 19048;
19056 -> 19043;
19056 -> 19055;
19057 -> 19055;
19058 -> 19055;
19059 -> 19056;
19059 -> 19058;
19060 -> 19057;
19060 -> 19058;
19061 -> 19058;
19062 -> 19059;
19062 -> 19061;
19062 -> 19058;
19063 -> 19058;
19064 -> 19059;
19064 -> 19063;
19065 -> 19063;
19065 -> 19058;
19066 -> 19060;
19066 -> 19058;
19067 -> 19066;
19068 -> 19067;
19069 -> 19043;
19069 -> 19068;
19070 -> 19068;
19071 -> 19070;
19071 -> 19067;
19072 -> 19071;
19073 -> 19043;
19073 -> 19072;
19074 -> 19072;
19075 -> 19073;
19075 -> 19074;
19076 -> 19075;
19076 -> 0;
19076 -> 19072;
19077 -> 19072;
19078 -> 19076;
19078 -> 19077;
19078 -> 19072;
19079 -> 19078;
19079 -> 19071;
19080 -> 19079;
19081 -> 19080;
19081 -> 19079;
19082 -> 19043;
19083 -> 19043;
19084 -> 19043;
19085 -> 19084;
19085 -> 19043;
19086 -> 19043;
19087 -> 19043;
19088 -> 19083;
19088 -> 19087;
19088 -> 19043;
19089 -> 19043;
19090 -> 19043;
19090 -> 19089;
19091 -> 19089;
19091 -> 19043;
19092 -> 19084;
19093 -> 19084;
19094 -> 19043;
19095 -> 19094;
19095 -> 19043;
19096 -> 19043;
19097 -> 19084;
19097 -> 19043;
19098 -> 19084;
19098 -> 19089;
19099 -> 19098;
19099 -> 19043;
19100 -> 19099;
19101 -> 19100;
19101 -> 19099;
19102 -> 19099;
19103 -> 19101;
19103 -> 19102;
19103 -> 19099;
19104 -> 19092;
19104 -> 19084;
19105 -> 0;
19105 -> 19084;
19106 -> 19092;
19107 -> 19084;
19107 -> 19106;
19108 -> 0;
19108 -> 19106;
19109 -> 19108;
19109 -> 19092;
19110 -> 19109;
19110 -> 0;
19110 -> 19092;
19111 -> 19110;
19112 -> 19111;
19112 -> 19043;
19113 -> 19043;
19113 -> 19092;
19114 -> 19092;
19115 -> 18541;
19116 -> 19115;
19117 -> 19092;
19117 -> 19116;
19118 -> 0;
19118 -> 1;
19119 -> 1;
19120 -> 19092;
19120 -> 19119;
19121 -> 0;
19121 -> 19119;
19122 -> 19121;
19122 -> 1;
19123 -> 1;
19124 -> 19092;
19124 -> 1;
19125 -> 1;
19126 -> 19124;
19126 -> 19125;
19127 -> 19125;
19128 -> 19125;
19129 -> 19127;
19129 -> 19128;
19130 -> 19126;
19130 -> 19128;
19131 -> 8794;
19131 -> 19128;
19132 -> 19131;
19132 -> 19125;
19133 -> 19132;
19133 -> 1;
}