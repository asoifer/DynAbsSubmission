digraph G {
0 [label="EXTERNAL"];
1 [label="param InitializeTestModule(this) 429853"];
2 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 429854"];
3 [label="param TypeTests(this) 429855"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 429856"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 429857"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 429858"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 429859"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 429860"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 429861"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 429862"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 429863"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 429864"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 429865"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 429866"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 429867"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 429868"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 429869"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 429870"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 429871"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 429872"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 429873"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 429874"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 429875"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 429876"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 429877"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 429878"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 429879"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 429880"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 429881"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 429882"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 429883"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 429884"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 429885"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 429886"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 429887"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 429888"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 429889"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 429890"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 429891"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 429892"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 429893"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 429894"];
43 [label="LazyThreadSafetyMode.PublicationOnly 429895"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 429896"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 429897"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 429898"];
47 [label="LazyThreadSafetyMode.PublicationOnly 429899"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 429900"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 429901"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 429902"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 429903"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 429904"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 429905"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 429906"];
55 [label="LazyThreadSafetyMode.PublicationOnly 429907"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 429908"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 429909"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 429910"];
59 [label="LazyThreadSafetyMode.PublicationOnly 429911"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 429912"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 429913"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 429914"];
63 [label="LazyThreadSafetyMode.PublicationOnly 429915"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 429916"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 429917"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 429918"];
67 [label="LazyThreadSafetyMode.PublicationOnly 429919"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429920"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429921"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 429922"];
71 [label="LazyThreadSafetyMode.PublicationOnly 429923"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429924"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429925"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 429926"];
75 [label="LazyThreadSafetyMode.PublicationOnly 429927"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429928"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429929"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 429930"];
79 [label="LazyThreadSafetyMode.PublicationOnly 429931"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429932"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429933"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 429934"];
83 [label="LazyThreadSafetyMode.PublicationOnly 429935"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429936"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429937"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 429938"];
87 [label="LazyThreadSafetyMode.PublicationOnly 429939"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429940"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429941"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 429942"];
91 [label="LazyThreadSafetyMode.PublicationOnly 429943"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429944"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429945"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 429946"];
95 [label="LazyThreadSafetyMode.PublicationOnly 429947"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 429948"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 429949"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 429950"];
99 [label="LazyThreadSafetyMode.PublicationOnly 429951"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 429952"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 429953"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 429954"];
103 [label="LazyThreadSafetyMode.PublicationOnly 429955"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429956"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429957"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 429958"];
107 [label="LazyThreadSafetyMode.PublicationOnly 429959"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429960"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429961"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 429962"];
111 [label="LazyThreadSafetyMode.PublicationOnly 429963"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429964"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429965"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 429966"];
115 [label="LazyThreadSafetyMode.PublicationOnly 429967"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429968"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429969"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 429970"];
119 [label="LazyThreadSafetyMode.PublicationOnly 429971"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 429972"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 429973"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 429974"];
123 [label="LazyThreadSafetyMode.PublicationOnly 429975"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429976"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429977"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 429978"];
127 [label="LazyThreadSafetyMode.PublicationOnly 429979"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429980"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429981"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 429982"];
131 [label="LazyThreadSafetyMode.PublicationOnly 429983"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429984"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429985"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 429986"];
135 [label="LazyThreadSafetyMode.PublicationOnly 429987"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429988"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429989"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 429990"];
139 [label="LazyThreadSafetyMode.PublicationOnly 429991"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429992"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429993"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 429994"];
143 [label="LazyThreadSafetyMode.PublicationOnly 429995"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429996"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 429997"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 429998"];
147 [label="LazyThreadSafetyMode.PublicationOnly 429999"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430000"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430001"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 430002"];
151 [label="LazyThreadSafetyMode.PublicationOnly 430003"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430004"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430005"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 430006"];
155 [label="LazyThreadSafetyMode.PublicationOnly 430007"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430008"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430009"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 430010"];
159 [label="LazyThreadSafetyMode.PublicationOnly 430011"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430012"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430013"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 430014"];
163 [label="LazyThreadSafetyMode.PublicationOnly 430015"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430016"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430017"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 430018"];
167 [label="LazyThreadSafetyMode.PublicationOnly 430019"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430020"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430021"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 430022"];
171 [label="LazyThreadSafetyMode.PublicationOnly 430023"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430024"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 430025"];
174 [label="@'R:\\Invalid.dll' 430026"];
175 [label="fullPath: @'R:\\Invalid.dll' 430027"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 430028"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 430029"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 430030"];
179 [label="MscorlibRef_v4_0_30316_17626 430031"];
180 [label="Net451.mscorlib 430032"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 430033"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 430034"];
183 [label="'/*<bind>*/' 430035"];
184 [label="StartString = '/*<bind>*/' 430036"];
185 [label="'/*</bind>*/' 430037"];
186 [label="EndString = '/*</bind>*/' 430038"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 430039"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 430040"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 430041"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 430042"];
191 [label="param CSharpTestBase(this) 430043"];
192 [label="param CommonTestBase(this) 430044"];
193 [label="param TestBase(this) 430045"];
194 [label="_temp 430046"];
195 [label="param ImportedVersusSource(this) 430047"];
196 [label="var text = @'\nnamespace System\n{\n    public class String { }\n    public class MyString : String { }\n}'; 430048"];
197 [label="var tree = Parse(text); 430049"];
198 [label="var tree = Parse(text); 430050"];
199 [label="Parse(text) 430051"];
200 [label="param Parse(string text) 430052"];
201 [label="param Parse(string filename = '') 430053"];
202 [label="param Parse(CSharpParseOptions options = null) 430054"];
203 [label="param Parse(Encoding encoding = null) 430055"];
204 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 430056"];
205 [label="if ((object)options == null)\n            {\n                options = TestOptions.Regular;\n            } 430057"];
206 [label="kind: SourceCodeKind.Regular 430058"];
207 [label="documentationMode: DocumentationMode.Parse 430059"];
208 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 430060"];
209 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 430061"];
210 [label="Regular = new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.Parse) 430062"];
211 [label="SourceCodeKind.Script 430063"];
212 [label="Regular.WithKind(SourceCodeKind.Script) 430064"];
213 [label="Script = Regular.WithKind(SourceCodeKind.Script) 430065"];
214 [label="LanguageVersion.CSharp6 430066"];
215 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp6) 430067"];
216 [label="Regular6 = Regular.WithLanguageVersion(LanguageVersion.CSharp6) 430068"];
217 [label="LanguageVersion.CSharp7 430069"];
218 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7) 430070"];
219 [label="Regular7 = Regular.WithLanguageVersion(LanguageVersion.CSharp7) 430071"];
220 [label="LanguageVersion.CSharp7_1 430072"];
221 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 430073"];
222 [label="Regular7_1 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_1) 430074"];
223 [label="LanguageVersion.CSharp7_2 430075"];
224 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 430076"];
225 [label="Regular7_2 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_2) 430077"];
226 [label="LanguageVersion.CSharp7_3 430078"];
227 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 430079"];
228 [label="Regular7_3 = Regular.WithLanguageVersion(LanguageVersion.CSharp7_3) 430080"];
229 [label="LanguageVersion.Default 430081"];
230 [label="Regular.WithLanguageVersion(LanguageVersion.Default) 430082"];
231 [label="RegularDefault = Regular.WithLanguageVersion(LanguageVersion.Default) 430083"];
232 [label="LanguageVersion.Preview 430084"];
233 [label="Regular.WithLanguageVersion(LanguageVersion.Preview) 430085"];
234 [label="RegularPreview = Regular.WithLanguageVersion(LanguageVersion.Preview) 430086"];
235 [label="LanguageVersion.CSharp8 430087"];
236 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 430088"];
237 [label="Regular8 = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 430089"];
238 [label="LanguageVersion.CSharp9 430090"];
239 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp9) 430091"];
240 [label="Regular9 = Regular.WithLanguageVersion(LanguageVersion.CSharp9) 430092"];
241 [label="DocumentationMode.Diagnose 430093"];
242 [label="Regular.WithDocumentationMode(DocumentationMode.Diagnose) 430094"];
243 [label="RegularWithDocumentationComments = Regular.WithDocumentationMode(DocumentationMode.Diagnose) 430095"];
244 [label="Regular 430096"];
245 [label="'UseLegacyStrongNameProvider' 430097"];
246 [label="Regular.WithFeature('UseLegacyStrongNameProvider') 430098"];
247 [label="param WithFeature(this CSharpParseOptions options) 430099"];
248 [label="param WithFeature(string feature) 430100"];
249 [label="param WithFeature(string value = 'true') 430101"];
250 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430102"];
251 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430103"];
252 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430104"];
253 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430105"];
254 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430106"];
255 [label="new[] { new KeyValuePair<string, string>(feature, value) } 430107"];
256 [label="return options.WithFeatures(options.Features.Concat(new[] { new KeyValuePair<string, string>(feature, value) })); 430108"];
257 [label="RegularWithLegacyStrongName = Regular.WithFeature('UseLegacyStrongNameProvider') 430109"];
258 [label="MessageID.IDS_FeatureImprovedOverloadCandidates 430110"];
259 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() 430111"];
260 [label="1 430112"];
261 [label="MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1 430113"];
262 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 430114"];
263 [label="WithoutImprovedOverloadCandidates = Regular.WithLanguageVersion(MessageID.IDS_FeatureImprovedOverloadCandidates.RequiredVersion() - 1) 430115"];
264 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides 430116"];
265 [label="MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion() 430117"];
266 [label="Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 430118"];
267 [label="WithCovariantReturns = Regular.WithLanguageVersion(MessageID.IDS_FeatureCovariantReturnsForOverrides.RequiredVersion()) 430119"];
268 [label="LanguageVersion.CSharp8 430120"];
269 [label="Regular.WithLanguageVersion(LanguageVersion.CSharp8) 430121"];
270 [label="WithoutCovariantReturns = Regular.WithLanguageVersion(LanguageVersion.CSharp8) 430122"];
271 [label="RegularWithExtendedPartialMethods = RegularPreview 430123"];
272 [label="new SmallDictionary<string, string> { } 430124"];
273 [label="s_experimentalFeatures = new SmallDictionary<string, string> { } 430125"];
274 [label="kind: SourceCodeKind.Regular 430126"];
275 [label="documentationMode: DocumentationMode.None 430127"];
276 [label="languageVersion: LanguageVersion.Preview 430128"];
277 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 430129"];
278 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview) 430130"];
279 [label="s_experimentalFeatures 430131"];
280 [label="new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 430132"];
281 [label="ExperimentalParseOptions =\n            new CSharpParseOptions(kind: SourceCodeKind.Regular, documentationMode: DocumentationMode.None, languageVersion: LanguageVersion.Preview).WithFeatures(s_experimentalFeatures) 430133"];
282 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 430134"];
283 [label="'testV7SwitchBinder' 430135"];
284 [label="'true' 430136"];
285 [label="new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } } 430137"];
286 [label="Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 430138"];
287 [label="Regular6WithV7SwitchBinder = Regular6.WithFeatures(new Dictionary<string, string>() { { 'testV7SwitchBinder', 'true' } }) 430139"];
288 [label="RegularWithoutRecursivePatterns = Regular7_3 430140"];
289 [label="RegularWithRecursivePatterns = Regular8 430141"];
290 [label="RegularWithoutPatternCombinators = Regular8 430142"];
291 [label="RegularWithPatternCombinators = RegularPreview 430143"];
292 [label="OutputKind.DynamicallyLinkedLibrary 430144"];
293 [label="OptimizationLevel.Release 430145"];
294 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 430146"];
295 [label="param CreateTestOptions(OutputKind outputKind) 430147"];
296 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430148"];
297 [label="param CreateTestOptions(bool allowUnsafe = false) 430149"];
298 [label="outputKind 430150"];
299 [label="optimizationLevel: optimizationLevel 430151"];
300 [label="warningLevel: Diagnostic.MaxWarningLevel 430152"];
301 [label="allowUnsafe: allowUnsafe 430153"];
302 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430154"];
303 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430155"];
304 [label="ReleaseDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Release) 430156"];
305 [label="OutputKind.ConsoleApplication 430157"];
306 [label="OptimizationLevel.Release 430158"];
307 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 430159"];
308 [label="param CreateTestOptions(OutputKind outputKind) 430160"];
309 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430161"];
310 [label="param CreateTestOptions(bool allowUnsafe = false) 430162"];
311 [label="outputKind 430163"];
312 [label="optimizationLevel: optimizationLevel 430164"];
313 [label="warningLevel: Diagnostic.MaxWarningLevel 430165"];
314 [label="allowUnsafe: allowUnsafe 430166"];
315 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430167"];
316 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430168"];
317 [label="ReleaseExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Release) 430169"];
318 [label="true 430170"];
319 [label="ReleaseDll.WithDebugPlusMode(true) 430171"];
320 [label="ReleaseDebugDll = ReleaseDll.WithDebugPlusMode(true) 430172"];
321 [label="true 430173"];
322 [label="ReleaseExe.WithDebugPlusMode(true) 430174"];
323 [label="ReleaseDebugExe = ReleaseExe.WithDebugPlusMode(true) 430175"];
324 [label="OutputKind.DynamicallyLinkedLibrary 430176"];
325 [label="OptimizationLevel.Debug 430177"];
326 [label="CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 430178"];
327 [label="param CreateTestOptions(OutputKind outputKind) 430179"];
328 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430180"];
329 [label="param CreateTestOptions(bool allowUnsafe = false) 430181"];
330 [label="outputKind 430182"];
331 [label="optimizationLevel: optimizationLevel 430183"];
332 [label="warningLevel: Diagnostic.MaxWarningLevel 430184"];
333 [label="allowUnsafe: allowUnsafe 430185"];
334 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430186"];
335 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430187"];
336 [label="DebugDll = CreateTestOptions(OutputKind.DynamicallyLinkedLibrary, OptimizationLevel.Debug) 430188"];
337 [label="OutputKind.ConsoleApplication 430189"];
338 [label="OptimizationLevel.Debug 430190"];
339 [label="CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 430191"];
340 [label="param CreateTestOptions(OutputKind outputKind) 430192"];
341 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430193"];
342 [label="param CreateTestOptions(bool allowUnsafe = false) 430194"];
343 [label="outputKind 430195"];
344 [label="optimizationLevel: optimizationLevel 430196"];
345 [label="warningLevel: Diagnostic.MaxWarningLevel 430197"];
346 [label="allowUnsafe: allowUnsafe 430198"];
347 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430199"];
348 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430200"];
349 [label="DebugExe = CreateTestOptions(OutputKind.ConsoleApplication, OptimizationLevel.Debug) 430201"];
350 [label="OutputKind.WindowsRuntimeMetadata 430202"];
351 [label="OptimizationLevel.Release 430203"];
352 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 430204"];
353 [label="param CreateTestOptions(OutputKind outputKind) 430205"];
354 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430206"];
355 [label="param CreateTestOptions(bool allowUnsafe = false) 430207"];
356 [label="outputKind 430208"];
357 [label="optimizationLevel: optimizationLevel 430209"];
358 [label="warningLevel: Diagnostic.MaxWarningLevel 430210"];
359 [label="allowUnsafe: allowUnsafe 430211"];
360 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430212"];
361 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430213"];
362 [label="ReleaseWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Release) 430214"];
363 [label="OutputKind.WindowsRuntimeMetadata 430215"];
364 [label="OptimizationLevel.Debug 430216"];
365 [label="CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 430217"];
366 [label="param CreateTestOptions(OutputKind outputKind) 430218"];
367 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430219"];
368 [label="param CreateTestOptions(bool allowUnsafe = false) 430220"];
369 [label="outputKind 430221"];
370 [label="optimizationLevel: optimizationLevel 430222"];
371 [label="warningLevel: Diagnostic.MaxWarningLevel 430223"];
372 [label="allowUnsafe: allowUnsafe 430224"];
373 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430225"];
374 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430226"];
375 [label="DebugWinMD = CreateTestOptions(OutputKind.WindowsRuntimeMetadata, OptimizationLevel.Debug) 430227"];
376 [label="OutputKind.NetModule 430228"];
377 [label="OptimizationLevel.Release 430229"];
378 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 430230"];
379 [label="param CreateTestOptions(OutputKind outputKind) 430231"];
380 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430232"];
381 [label="param CreateTestOptions(bool allowUnsafe = false) 430233"];
382 [label="outputKind 430234"];
383 [label="optimizationLevel: optimizationLevel 430235"];
384 [label="warningLevel: Diagnostic.MaxWarningLevel 430236"];
385 [label="allowUnsafe: allowUnsafe 430237"];
386 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430238"];
387 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430239"];
388 [label="ReleaseModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Release) 430240"];
389 [label="OutputKind.NetModule 430241"];
390 [label="OptimizationLevel.Debug 430242"];
391 [label="CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 430243"];
392 [label="param CreateTestOptions(OutputKind outputKind) 430244"];
393 [label="param CreateTestOptions(OptimizationLevel optimizationLevel) 430245"];
394 [label="param CreateTestOptions(bool allowUnsafe = false) 430246"];
395 [label="outputKind 430247"];
396 [label="optimizationLevel: optimizationLevel 430248"];
397 [label="warningLevel: Diagnostic.MaxWarningLevel 430249"];
398 [label="allowUnsafe: allowUnsafe 430250"];
399 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430251"];
400 [label="new CSharpCompilationOptions(outputKind, optimizationLevel: optimizationLevel, warningLevel: Diagnostic.MaxWarningLevel, allowUnsafe: allowUnsafe) 430252"];
401 [label="DebugModule = CreateTestOptions(OutputKind.NetModule, OptimizationLevel.Debug) 430253"];
402 [label="true 430254"];
403 [label="ReleaseDll.WithAllowUnsafe(true) 430255"];
404 [label="UnsafeReleaseDll = ReleaseDll.WithAllowUnsafe(true) 430256"];
405 [label="true 430257"];
406 [label="ReleaseExe.WithAllowUnsafe(true) 430258"];
407 [label="UnsafeReleaseExe = ReleaseExe.WithAllowUnsafe(true) 430259"];
408 [label="true 430260"];
409 [label="DebugDll.WithAllowUnsafe(true) 430261"];
410 [label="UnsafeDebugDll = DebugDll.WithAllowUnsafe(true) 430262"];
411 [label="true 430263"];
412 [label="DebugExe.WithAllowUnsafe(true) 430264"];
413 [label="UnsafeDebugExe = DebugExe.WithAllowUnsafe(true) 430265"];
414 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 430266"];
415 [label="ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430267"];
416 [label="SigningReleaseDll = ReleaseDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430268"];
417 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 430269"];
418 [label="ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430270"];
419 [label="SigningReleaseExe = ReleaseExe.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430271"];
420 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 430272"];
421 [label="ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430273"];
422 [label="SigningReleaseModule = ReleaseModule.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430274"];
423 [label="SigningTestHelpers.DefaultDesktopStrongNameProvider 430275"];
424 [label="DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430276"];
425 [label="SigningDebugDll = DebugDll.WithStrongNameProvider(SigningTestHelpers.DefaultDesktopStrongNameProvider) 430277"];
426 [label="DebugInformationFormat.Pdb 430278"];
427 [label="EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 430279"];
428 [label="NativePdbEmit = EmitOptions.Default.WithDebugInformationFormat(DebugInformationFormat.Pdb) 430280"];
429 [label="options = TestOptions.Regular; 430281"];
430 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 430282"];
431 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 430283"];
432 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 430284"];
433 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 430285"];
434 [label="var stringText = StringText.From(text, encoding ?? Encoding.UTF8); 430286"];
435 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 430287"];
436 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 430288"];
437 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 430289"];
438 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 430290"];
439 [label="return CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)); 430291"];
440 [label="CheckSerializable(SyntaxFactory.ParseSyntaxTree(stringText, options, filename)) 430292"];
441 [label="param CheckSerializable(SyntaxTree tree) 430293"];
442 [label="var stream = new MemoryStream(); 430294"];
443 [label="var root = tree.GetRoot(); 430295"];
444 [label="var root = tree.GetRoot(); 430296"];
445 [label="root.SerializeTo(stream); 430297"];
446 [label="root.SerializeTo(stream); 430298"];
447 [label="root.SerializeTo(stream); 430299"];
448 [label="stream.Position = 0; 430300"];
449 [label="stream.Position 430301"];
450 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 430302"];
451 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 430303"];
452 [label="var deserializedRoot = CSharpSyntaxNode.DeserializeFrom(stream); 430304"];
453 [label="return tree; 430305"];
454 [label="var comp = CreateCompilation(tree); 430306"];
455 [label="tree 430307"];
456 [label="param operator(SyntaxTree source) 430308"];
457 [label="source 430309"];
458 [label="new CSharpTestSource(source) 430310"];
459 [label="param CSharpTestSource(object value) 430311"];
460 [label="param CSharpTestSource(this) 430312"];
461 [label="Value 430313"];
462 [label="var comp = CreateCompilation(tree); 430314"];
463 [label="var comp = CreateCompilation(tree); 430315"];
464 [label="CreateCompilation(tree) 430316"];
465 [label="param CreateCompilation(CSharpTestSource source) 430317"];
466 [label="param CreateCompilation(IEnumerable<MetadataReference> references = null) 430318"];
467 [label="param CreateCompilation(CSharpCompilationOptions options = null) 430319"];
468 [label="param CreateCompilation(CSharpParseOptions parseOptions = null) 430320"];
469 [label="param CreateCompilation(TargetFramework targetFramework = TargetFramework.Standard) 430321"];
470 [label="param CreateCompilation(string assemblyName = '') 430322"];
471 [label="param CreateCompilation(string sourceFileName = '') 430323"];
472 [label="param CreateCompilation(bool skipUsesIsNullable = false) 430324"];
473 [label="source 430325"];
474 [label="targetFramework 430326"];
475 [label="references 430327"];
476 [label="TargetFrameworkUtil.GetReferences(targetFramework, references) 430328"];
477 [label="param GetReferences(TargetFramework tf) 430329"];
478 [label="param GetReferences(IEnumerable<MetadataReference> additionalReferences) 430330"];
479 [label="var references = GetReferences(tf); 430331"];
480 [label="GetReferences(tf) 430332"];
481 [label="param GetReferences(TargetFramework targetFramework) 430333"];
482 [label="targetFramework switch\n        {\n            TargetFramework.Empty => ImmutableArray<MetadataReference>.Empty,\n            TargetFramework.Mscorlib40 => Mscorlib40References,\n            TargetFramework.Mscorlib40Extended => Mscorlib40ExtendedReferences,\n            TargetFramework.Mscorlib40AndSystemCore => Mscorlib40andSystemCoreReferences,\n            TargetFramework.Mscorlib40AndVBRuntime => Mscorlib40andVBRuntimeReferences,\n            TargetFramework.Mscorlib45 => Mscorlib45References,\n            TargetFramework.Mscorlib45Extended => Mscorlib45ExtendedReferences,\n            TargetFramework.Mscorlib45AndCSharp => Mscorlib45AndCSharpReferences,\n            TargetFramework.Mscorlib45AndVBRuntime => Mscorlib45AndVBRuntimeReferences,\n            TargetFramework.Mscorlib46 => Mscorlib46References,\n            TargetFramework.Mscorlib46Extended => Mscorlib46ExtendedReferences,\n            TargetFramework.Mscorlib461 => Mscorlib46References,\n            TargetFramework.Mscorlib461Extended => Mscorlib461ExtendedReferences,\n            TargetFramework.NetStandard20 => NetStandard20References,\n            TargetFramework.NetCoreApp => NetCoreAppReferences,\n            TargetFramework.WinRT => WinRTReferences,\n            TargetFramework.Standard => StandardReferences,\n            TargetFramework.StandardLatest => StandardLatestReferences,\n            TargetFramework.StandardAndCSharp => StandardAndCSharpReferences,\n            TargetFramework.StandardAndVBRuntime => StandardAndVBRuntimeReferences,\n            TargetFramework.StandardCompat => StandardCompatReferences,\n            TargetFramework.DefaultVb => DefaultVbReferences,\n            TargetFramework.Minimal => MinimalReferences,\n            TargetFramework.MinimalAsync => MinimalAsyncReferences,\n            _ => throw new InvalidOperationException($'Unexpected target framework {targetFramework}'),\n        } 430334"];
483 [label="StandardReferences 430335"];
484 [label="RuntimeUtilities.IsCoreClrRuntime 430336"];
485 [label="NetStandard20References 430337"];
486 [label="ImmutableArray.Create<MetadataReference>(NetStandard20.netstandard, NetStandard20.mscorlib, NetStandard20.SystemRuntime, NetStandard20.SystemCore, NetStandard20.SystemDynamicRuntime, NetStandard20.SystemLinq, NetStandard20.SystemLinqExpressions) 430338"];
487 [label="RuntimeUtilities.IsCoreClrRuntime ? NetStandard20References : Mscorlib46ExtendedReferences 430339"];
488 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 430340"];
489 [label="if (additionalReferences == null)\n            {\n                return references;\n            } 430341"];
490 [label="return references; 430342"];
491 [label="options 430343"];
492 [label="parseOptions 430344"];
493 [label="assemblyName 430345"];
494 [label="sourceFileName 430346"];
495 [label="skipUsesIsNullable 430347"];
496 [label="CreateEmptyCompilation(source, TargetFrameworkUtil.GetReferences(targetFramework, references), options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable) 430348"];
497 [label="param CreateEmptyCompilation(CSharpTestSource source) 430349"];
498 [label="param CreateEmptyCompilation(IEnumerable<MetadataReference> references = null) 430350"];
499 [label="param CreateEmptyCompilation(CSharpCompilationOptions options = null) 430351"];
500 [label="param CreateEmptyCompilation(CSharpParseOptions parseOptions = null) 430352"];
501 [label="param CreateEmptyCompilation(string assemblyName = '') 430353"];
502 [label="param CreateEmptyCompilation(string sourceFileName = '') 430354"];
503 [label="param CreateEmptyCompilation(bool skipUsesIsNullable = false) 430355"];
504 [label="source 430356"];
505 [label="references 430357"];
506 [label="options 430358"];
507 [label="parseOptions 430359"];
508 [label="assemblyName 430360"];
509 [label="sourceFileName 430361"];
510 [label="skipUsesIsNullable 430362"];
511 [label="null 430363"];
512 [label="experimentalFeature: null 430364"];
513 [label="CreateCompilationCore(source, references, options, parseOptions, assemblyName, sourceFileName, skipUsesIsNullable, experimentalFeature: null) 430365"];
514 [label="param CreateCompilationCore(CSharpTestSource source) 430366"];
515 [label="param CreateCompilationCore(IEnumerable<MetadataReference> references) 430367"];
516 [label="param CreateCompilationCore(CSharpCompilationOptions options) 430368"];
517 [label="param CreateCompilationCore(CSharpParseOptions parseOptions) 430369"];
518 [label="param CreateCompilationCore(string assemblyName) 430370"];
519 [label="param CreateCompilationCore(string sourceFileName) 430371"];
520 [label="param CreateCompilationCore(bool skipUsesIsNullable) 430372"];
521 [label="param CreateCompilationCore(MessageID? experimentalFeature) 430373"];
522 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 430374"];
523 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 430375"];
524 [label="source.GetSyntaxTrees(parseOptions, sourceFileName) 430376"];
525 [label="param GetSyntaxTrees(CSharpParseOptions parseOptions) 430377"];
526 [label="param GetSyntaxTrees(string sourceFileName = '') 430378"];
527 [label="param GetSyntaxTrees(this) 430379"];
528 [label="switch (Value)\n            {\n                case string source:\n                    return new[] { CSharpTestBase.Parse(source, filename: sourceFileName, parseOptions) };\n                case string[] sources:\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return CSharpTestBase.Parse(parseOptions, sources);\n                case SyntaxTree tree:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return new[] { tree };\n                case SyntaxTree[] trees:\n                    Debug.Assert(parseOptions == null);\n                    Debug.Assert(string.IsNullOrEmpty(sourceFileName));\n                    return trees;\n                case CSharpTestSource[] testSources:\n                    return testSources.SelectMany(s => s.GetSyntaxTrees(parseOptions, sourceFileName)).ToArray();\n                case null:\n                    return Array.Empty<SyntaxTree>();\n                default:\n                    throw new Exception($'Unexpected value: {Value}');\n            } 430380"];
529 [label="Debug.Assert(parseOptions == null); 430381"];
530 [label="Debug.Assert(parseOptions == null); 430382"];
531 [label="Debug.Assert(string.IsNullOrEmpty(sourceFileName)); 430383"];
532 [label="return new[] { tree }; 430384"];
533 [label="new[] { tree } 430385"];
534 [label="var syntaxTrees = source.GetSyntaxTrees(parseOptions, sourceFileName); 430386"];
535 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 430387"];
536 [label="if (options == null)\n            {\n                bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any());\n\n                options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll;\n            } 430388"];
537 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 430389"];
538 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 430390"];
539 [label="bool hasTopLevelStatements = syntaxTrees.Any(s => s.GetRoot().ChildNodes().OfType<GlobalStatementSyntax>().Any()); 430391"];
540 [label="hasTopLevelStatements 430392"];
541 [label="options = hasTopLevelStatements ? TestOptions.ReleaseExe : TestOptions.ReleaseDll; 430393"];
542 [label="if (Debugger.IsAttached)\n            {\n                options = options.WithConcurrentBuild(false);\n            } 430394"];
543 [label="if (experimentalFeature.HasValue)\n            {\n                parseOptions = (parseOptions ?? TestOptions.Regular).WithExperimental(experimentalFeature.Value);\n            } 430395"];
544 [label="Func<CSharpCompilation> createCompilationLambda = () => CSharpCompilation.Create(\n                assemblyName == '' ? GetUniqueName() : assemblyName,\n                syntaxTrees,\n                references,\n                options); 430396"];
545 [label="'ROSLYN_TEST_IOPERATION' 430397"];
546 [label="Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION') 430398"];
547 [label="string.IsNullOrEmpty(Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION')) 430399"];
548 [label="internal static bool EnableVerifyIOperation { get; } = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable('ROSLYN_TEST_IOPERATION')); 430400"];
549 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 430401"];
550 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda) 430402"];
551 [label="param ValidateIOperations(Func<Compilation> createCompilation) 430403"];
552 [label="if (!EnableVerifyIOperation)\n            {\n                return;\n            } 430404"];
553 [label="return; 430405"];
554 [label="CompilationExtensions.ValidateIOperations(createCompilationLambda); 430406"];
555 [label="var compilation = createCompilationLambda(); 430407"];
556 [label="var compilation = createCompilationLambda(); 430408"];
557 [label="return Guid.NewGuid().ToString('D'); 430409"];
558 [label="var compilation = createCompilationLambda(); 430410"];
559 [label="OutputKind.ConsoleApplication 430411"];
560 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 430412"];
561 [label="new CSharpCompilationOptions(OutputKind.ConsoleApplication) 430413"];
562 [label="s_defaultOptions = new CSharpCompilationOptions(OutputKind.ConsoleApplication) 430414"];
563 [label="OutputKind.DynamicallyLinkedLibrary 430415"];
564 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 430416"];
565 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary) 430417"];
566 [label="true 430418"];
567 [label="new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 430419"];
568 [label="s_defaultSubmissionOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true) 430420"];
569 [label="param Create(string? assemblyName) 430421"];
570 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees = null) 430422"];
571 [label="param Create(IEnumerable<MetadataReference>? references = null) 430423"];
572 [label="param Create(CSharpCompilationOptions? options = null) 430424"];
573 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 430425"];
574 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 430426"];
575 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 430427"];
576 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 430428"];
577 [label="return Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false); 430429"];
578 [label="Create(\n                assemblyName,\n                options ?? s_defaultOptions,\n                syntaxTrees,\n                references,\n                previousSubmission: null,\n                returnType: null,\n                hostObjectType: null,\n                isSubmission: false) 430430"];
579 [label="param Create(string? assemblyName) 430431"];
580 [label="param Create(CSharpCompilationOptions options) 430432"];
581 [label="param Create(IEnumerable<SyntaxTree>? syntaxTrees) 430433"];
582 [label="param Create(IEnumerable<MetadataReference>? references) 430434"];
583 [label="param Create(CSharpCompilation? previousSubmission) 430435"];
584 [label="param Create(Type? returnType) 430436"];
585 [label="param Create(Type? hostObjectType) 430437"];
586 [label="param Create(bool isSubmission) 430438"];
587 [label="RoslynDebug.Assert(options != null); 430439"];
588 [label="RoslynDebug.Assert(options != null); 430440"];
589 [label="Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions); 430441"];
590 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 430442"];
591 [label="var validatedReferences = ValidateReferences<CSharpCompilationReference>(references); 430443"];
592 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430444"];
593 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430445"];
594 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430446"];
595 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430447"];
596 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430448"];
597 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430449"];
598 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430450"];
599 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430451"];
600 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430452"];
601 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430453"];
602 [label="var compilation = new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null); 430454"];
603 [label="new CSharpCompilation(\n                assemblyName,\n                options,\n                validatedReferences,\n                previousSubmission,\n                returnType,\n                hostObjectType,\n                isSubmission,\n                referenceManager: null,\n                reuseReferenceManager: false,\n                syntaxAndDeclarations: new SyntaxAndDeclarationManager(\n                    ImmutableArray<SyntaxTree>.Empty,\n                    options.ScriptClassName,\n                    options.SourceReferenceResolver,\n                    CSharp.MessageProvider.Instance,\n                    isSubmission,\n                    state: null),\n                semanticModelProvider: null) 430455"];
604 [label="param CSharpCompilation(string? assemblyName) 430456"];
605 [label="param CSharpCompilation(CSharpCompilationOptions options) 430457"];
606 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 430458"];
607 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 430459"];
608 [label="param CSharpCompilation(Type? submissionReturnType) 430460"];
609 [label="param CSharpCompilation(Type? hostObjectType) 430461"];
610 [label="param CSharpCompilation(bool isSubmission) 430462"];
611 [label="param CSharpCompilation(ReferenceManager? referenceManager) 430463"];
612 [label="param CSharpCompilation(bool reuseReferenceManager) 430464"];
613 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 430465"];
614 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 430466"];
615 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 430467"];
616 [label="param CSharpCompilation(this) 430468"];
617 [label="assemblyName 430469"];
618 [label="options 430470"];
619 [label="references 430471"];
620 [label="previousSubmission 430472"];
621 [label="submissionReturnType 430473"];
622 [label="hostObjectType 430474"];
623 [label="isSubmission 430475"];
624 [label="referenceManager 430476"];
625 [label="reuseReferenceManager 430477"];
626 [label="syntaxAndDeclarations 430478"];
627 [label="syntaxAndDeclarations.ExternalSyntaxTrees 430479"];
628 [label="SyntaxTreeCommonFeatures(syntaxAndDeclarations.ExternalSyntaxTrees) 430480"];
629 [label="semanticModelProvider 430481"];
630 [label="eventQueue 430482"];
631 [label="param CSharpCompilation(this) 430483"];
632 [label="param CSharpCompilation(string? assemblyName) 430484"];
633 [label="param CSharpCompilation(CSharpCompilationOptions options) 430485"];
634 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 430486"];
635 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 430487"];
636 [label="param CSharpCompilation(Type? submissionReturnType) 430488"];
637 [label="param CSharpCompilation(Type? hostObjectType) 430489"];
638 [label="param CSharpCompilation(bool isSubmission) 430490"];
639 [label="param CSharpCompilation(ReferenceManager? referenceManager) 430491"];
640 [label="param CSharpCompilation(bool reuseReferenceManager) 430492"];
641 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 430493"];
642 [label="param CSharpCompilation(IReadOnlyDictionary<string, string> features) 430494"];
643 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 430495"];
644 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 430496"];
645 [label="param CSharpCompilation(this) 430497"];
646 [label="assemblyName 430498"];
647 [label="references 430499"];
648 [label="features 430500"];
649 [label="isSubmission 430501"];
650 [label="semanticModelProvider 430502"];
651 [label="eventQueue 430503"];
652 [label="param CSharpCompilation(this) 430504"];
653 [label="param CSharpCompilation(this) 430505"];
654 [label="_options 430506"];
655 [label="_globalImports 430507"];
656 [label="_previousSubmissionImports 430508"];
657 [label="_globalNamespaceAlias 430509"];
658 [label="_scriptClass 430510"];
659 [label="_lazyHostObjectTypeSymbol 430511"];
660 [label="_lazyImportInfos 430512"];
661 [label="_conversions 430513"];
662 [label="_anonymousTypeManager 430514"];
663 [label="_lazyGlobalNamespace 430515"];
664 [label="builtInOperators 430516"];
665 [label="_lazyAssemblySymbol 430517"];
666 [label="_referenceManager 430518"];
667 [label="_syntaxAndDeclarations 430519"];
668 [label="_lazyEntryPoint 430520"];
669 [label="_lazyEmitNullablePublicOnly 430521"];
670 [label="_lazyCompilationUnitCompletedTrees 430522"];
671 [label="NullableAnalysisData 430523"];
672 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 430524"];
673 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 430525"];
674 [label="_externAliasTargets 430526"];
675 [label="_moduleInitializerMethods 430527"];
676 [label="_binderFactories 430528"];
677 [label="_ignoreAccessibilityBinderFactories 430529"];
678 [label="_lazyDeclarationDiagnostics 430530"];
679 [label="_declarationDiagnosticsFrozen 430531"];
680 [label="new DiagnosticBag() 430532"];
681 [label="_additionalCodegenWarnings = new DiagnosticBag() 430533"];
682 [label="WellKnownMemberSignatureComparer 430534"];
683 [label="_lazyWellKnownTypes 430535"];
684 [label="_lazyWellKnownTypeMembers 430536"];
685 [label="_usesNullableAttributes 430537"];
686 [label="_needsGeneratedAttributes 430538"];
687 [label="_needsGeneratedAttributes_IsFrozen 430539"];
688 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 430540"];
689 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 430541"];
690 [label="new WellKnownMembersSignatureComparer(this) 430542"];
691 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 430543"];
692 [label="param WellKnownMembersSignatureComparer(this) 430544"];
693 [label="new SpecialMembersSignatureComparer() 430545"];
694 [label="param SpecialMembersSignatureComparer(this) 430546"];
695 [label="Instance = new SpecialMembersSignatureComparer() 430547"];
696 [label="param WellKnownMembersSignatureComparer(this) 430548"];
697 [label="param SpecialMembersSignatureComparer(this) 430549"];
698 [label="param SpecialMembersSignatureComparer(this) 430550"];
699 [label="_compilation 430551"];
700 [label="_compilation 430552"];
701 [label="WellKnownMemberSignatureComparer 430553"];
702 [label="_options 430554"];
703 [label="this.builtInOperators = new BuiltInOperators(this); 430555"];
704 [label="this.builtInOperators = new BuiltInOperators(this); 430556"];
705 [label="this.builtInOperators 430557"];
706 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 430558"];
707 [label="_scriptClass = new Lazy<ImplicitNamedTypeSymbol?>(BindScriptClass); 430559"];
708 [label="_scriptClass 430560"];
709 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 430561"];
710 [label="_globalImports = new Lazy<Imports>(BindGlobalImports); 430562"];
711 [label="_globalImports 430563"];
712 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 430564"];
713 [label="_previousSubmissionImports = new Lazy<Imports>(ExpandPreviousSubmissionImports); 430565"];
714 [label="_previousSubmissionImports 430566"];
715 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 430567"];
716 [label="_globalNamespaceAlias = new Lazy<AliasSymbol>(CreateGlobalNamespaceAlias); 430568"];
717 [label="_globalNamespaceAlias 430569"];
718 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 430570"];
719 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 430571"];
720 [label="new AnonymousTypeManager(this) 430572"];
721 [label="param AnonymousTypeManager(CSharpCompilation compilation) 430573"];
722 [label="param AnonymousTypeManager(this) 430574"];
723 [label="param AnonymousTypeManager(this) 430575"];
724 [label="public CSharpCompilation Compilation { get; } 430576"];
725 [label="_lazyAnonymousTypeTemplates 430577"];
726 [label="_lazySynthesizedDelegates 430578"];
727 [label="new ConcurrentDictionary<Location, bool>() 430579"];
728 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 430580"];
729 [label="Debug.Assert(compilation != null); 430581"];
730 [label="Debug.Assert(compilation != null); 430582"];
731 [label="this.Compilation 430583"];
732 [label="_anonymousTypeManager 430584"];
733 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 430585"];
734 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 430586"];
735 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 430587"];
736 [label="LanguageVersion? result = null; 430588"];
737 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 430589"];
738 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 430590"];
739 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 430591"];
740 [label="return result ?? LanguageVersion.Default.MapSpecifiedToEffectiveVersion(); 430592"];
741 [label="this.LanguageVersion = CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees); 430593"];
742 [label="this.LanguageVersion 430594"];
743 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 430595"];
744 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430596"];
745 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430597"];
746 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430598"];
747 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430599"];
748 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430600"];
749 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430601"];
750 [label="if (reuseReferenceManager)\n            {\n                if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                }\n\n                referenceManager.AssertCanReuseForCompilation(this);\n                _referenceManager = referenceManager;\n            }\n            else\n            {\n                _referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata);\n            } 430602"];
751 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 430603"];
752 [label="this.Options 430604"];
753 [label="get\n            {\n                return _options;\n            } 430605"];
754 [label="return _options; 430606"];
755 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 430607"];
756 [label="_referenceManager = new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata); 430608"];
757 [label="new ReferenceManager(\n                    MakeSourceAssemblySimpleName(),\n                    this.Options.AssemblyIdentityComparer,\n                    observedMetadata: referenceManager?.ObservedMetadata) 430609"];
758 [label="param ReferenceManager(string simpleAssemblyName) 430610"];
759 [label="param ReferenceManager(AssemblyIdentityComparer identityComparer) 430611"];
760 [label="param ReferenceManager(Dictionary<MetadataReference, MetadataOrDiagnostic>? observedMetadata) 430612"];
761 [label="param ReferenceManager(this) 430613"];
762 [label="simpleAssemblyName 430614"];
763 [label="identityComparer 430615"];
764 [label="observedMetadata 430616"];
765 [label="param ReferenceManager(this) 430617"];
766 [label="param ReferenceManager(this) 430618"];
767 [label="_referenceManager 430619"];
768 [label="_syntaxAndDeclarations 430620"];
769 [label="Debug.Assert(_lazyAssemblySymbol is null); 430621"];
770 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 430622"];
771 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 430623"];
772 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 430624"];
773 [label="if (syntaxTrees != null)\n            {\n                compilation = compilation.AddSyntaxTrees(syntaxTrees);\n            } 430625"];
774 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 430626"];
775 [label="compilation.AddSyntaxTrees(syntaxTrees) 430627"];
776 [label="param AddSyntaxTrees(IEnumerable<SyntaxTree> trees) 430628"];
777 [label="param AddSyntaxTrees(this) 430629"];
778 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 430630"];
779 [label="if (trees == null)\n            {\n                throw new ArgumentNullException(nameof(trees));\n            } 430631"];
780 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 430632"];
781 [label="if (trees.IsEmpty())\n            {\n                return this;\n            } 430633"];
782 [label="var externalSyntaxTrees = PooledHashSet<SyntaxTree>.GetInstance(); 430634"];
783 [label="var syntaxAndDeclarations = _syntaxAndDeclarations; 430635"];
784 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 430636"];
785 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 430637"];
786 [label="externalSyntaxTrees.AddAll(syntaxAndDeclarations.ExternalSyntaxTrees); 430638"];
787 [label="bool reuseReferenceManager = true; 430639"];
788 [label="int i = 0; 430640"];
789 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 430641"];
790 [label="foreach (var tree in trees.Cast<CSharpSyntaxTree>())\n            {\n                if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                }\n\n                if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                }\n\n                if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                }\n\n                if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                }\n\n                externalSyntaxTrees.Add(tree);\n                reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives;\n\n                i++;\n            } 430642"];
791 [label="if (tree == null)\n                {\n                    throw new ArgumentNullException($'{nameof(trees)}[{i}]');\n                } 430643"];
792 [label="if (!tree.HasCompilationUnitRoot)\n                {\n                    throw new ArgumentException(CSharpResources.TreeMustHaveARootNodeWith, $'{nameof(trees)}[{i}]');\n                } 430644"];
793 [label="if (externalSyntaxTrees.Contains(tree))\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeAlreadyPresent, $'{nameof(trees)}[{i}]');\n                } 430645"];
794 [label="if (this.IsSubmission && tree.Options.Kind == SourceCodeKind.Regular)\n                {\n                    throw new ArgumentException(CSharpResources.SubmissionCanOnlyInclude, $'{nameof(trees)}[{i}]');\n                } 430646"];
795 [label="externalSyntaxTrees.Add(tree); 430647"];
796 [label="externalSyntaxTrees.Add(tree); 430648"];
797 [label="reuseReferenceManager &= !tree.HasReferenceOrLoadDirectives; 430649"];
798 [label="i++; 430650"];
799 [label="externalSyntaxTrees.Free(); 430651"];
800 [label="if (this.IsSubmission && i > 1)\n            {\n                throw new ArgumentException(CSharpResources.SubmissionCanHaveAtMostOne, nameof(trees));\n            } 430652"];
801 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 430653"];
802 [label="syntaxAndDeclarations = syntaxAndDeclarations.AddSyntaxTrees(trees); 430654"];
803 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 430655"];
804 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 430656"];
805 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 430657"];
806 [label="Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations) 430658"];
807 [label="param Update(ReferenceManager referenceManager) 430659"];
808 [label="param Update(bool reuseReferenceManager) 430660"];
809 [label="param Update(SyntaxAndDeclarationManager syntaxAndDeclarations) 430661"];
810 [label="param Update(this) 430662"];
811 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430663"];
812 [label="this.PreviousSubmission 430664"];
813 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 430665"];
814 [label="ScriptCompilationInfo 430666"];
815 [label="ScriptCompilationInfo?.PreviousScriptCompilation 430667"];
816 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430668"];
817 [label="this.SubmissionReturnType 430669"];
818 [label="=> ScriptCompilationInfo 430670"];
819 [label="ScriptCompilationInfo 430671"];
820 [label="this.HostObjectType 430672"];
821 [label="=> ScriptCompilationInfo 430673"];
822 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430674"];
823 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430675"];
824 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430676"];
825 [label="return new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider); 430677"];
826 [label="new CSharpCompilation(\n                this.AssemblyName,\n                _options,\n                this.ExternalReferences,\n                this.PreviousSubmission,\n                this.SubmissionReturnType,\n                this.HostObjectType,\n                this.IsSubmission,\n                referenceManager,\n                reuseReferenceManager,\n                syntaxAndDeclarations,\n                this.SemanticModelProvider) 430678"];
827 [label="param CSharpCompilation(string? assemblyName) 430679"];
828 [label="param CSharpCompilation(CSharpCompilationOptions options) 430680"];
829 [label="param CSharpCompilation(ImmutableArray<MetadataReference> references) 430681"];
830 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 430682"];
831 [label="param CSharpCompilation(Type? submissionReturnType) 430683"];
832 [label="param CSharpCompilation(Type? hostObjectType) 430684"];
833 [label="param CSharpCompilation(bool isSubmission) 430685"];
834 [label="param CSharpCompilation(ReferenceManager? referenceManager) 430686"];
835 [label="param CSharpCompilation(bool reuseReferenceManager) 430687"];
836 [label="param CSharpCompilation(SyntaxAndDeclarationManager syntaxAndDeclarations) 430688"];
837 [label="param CSharpCompilation(SemanticModelProvider? semanticModelProvider) 430689"];
838 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 430690"];
839 [label="param CSharpCompilation(this) 430691"];
840 [label="previousSubmission 430692"];
841 [label="submissionReturnType 430693"];
842 [label="hostObjectType 430694"];
843 [label="syntaxAndDeclarations.ExternalSyntaxTrees 430695"];
844 [label="eventQueue 430696"];
845 [label="param CSharpCompilation(this) 430697"];
846 [label="param CSharpCompilation(CSharpCompilation? previousSubmission) 430698"];
847 [label="param CSharpCompilation(Type? submissionReturnType) 430699"];
848 [label="param CSharpCompilation(Type? hostObjectType) 430700"];
849 [label="param CSharpCompilation(AsyncQueue<CompilationEvent>? eventQueue = null) 430701"];
850 [label="param CSharpCompilation(this) 430702"];
851 [label="eventQueue 430703"];
852 [label="param CSharpCompilation(this) 430704"];
853 [label="_options 430705"];
854 [label="_globalImports 430706"];
855 [label="_previousSubmissionImports 430707"];
856 [label="_globalNamespaceAlias 430708"];
857 [label="_scriptClass 430709"];
858 [label="_lazyHostObjectTypeSymbol 430710"];
859 [label="_lazyImportInfos 430711"];
860 [label="_conversions 430712"];
861 [label="_anonymousTypeManager 430713"];
862 [label="_lazyGlobalNamespace 430714"];
863 [label="builtInOperators 430715"];
864 [label="_lazyAssemblySymbol 430716"];
865 [label="_referenceManager 430717"];
866 [label="_syntaxAndDeclarations 430718"];
867 [label="_lazyEntryPoint 430719"];
868 [label="_lazyEmitNullablePublicOnly 430720"];
869 [label="_lazyCompilationUnitCompletedTrees 430721"];
870 [label="NullableAnalysisData 430722"];
871 [label="public LanguageVersion LanguageVersion\n        {\n            get;\n        } 430723"];
872 [label="public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get; } 430724"];
873 [label="_externAliasTargets 430725"];
874 [label="_moduleInitializerMethods 430726"];
875 [label="_binderFactories 430727"];
876 [label="_ignoreAccessibilityBinderFactories 430728"];
877 [label="_lazyDeclarationDiagnostics 430729"];
878 [label="_declarationDiagnosticsFrozen 430730"];
879 [label="new DiagnosticBag() 430731"];
880 [label="_additionalCodegenWarnings = new DiagnosticBag() 430732"];
881 [label="WellKnownMemberSignatureComparer 430733"];
882 [label="_lazyWellKnownTypes 430734"];
883 [label="_lazyWellKnownTypeMembers 430735"];
884 [label="_usesNullableAttributes 430736"];
885 [label="_needsGeneratedAttributes 430737"];
886 [label="_needsGeneratedAttributes_IsFrozen 430738"];
887 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 430739"];
888 [label="WellKnownMemberSignatureComparer = new WellKnownMembersSignatureComparer(this); 430740"];
889 [label="new WellKnownMembersSignatureComparer(this) 430741"];
890 [label="param WellKnownMembersSignatureComparer(CSharpCompilation compilation) 430742"];
891 [label="param WellKnownMembersSignatureComparer(this) 430743"];
892 [label="param WellKnownMembersSignatureComparer(this) 430744"];
893 [label="param SpecialMembersSignatureComparer(this) 430745"];
894 [label="param SpecialMembersSignatureComparer(this) 430746"];
895 [label="_compilation 430747"];
896 [label="_compilation 430748"];
897 [label="WellKnownMemberSignatureComparer 430749"];
898 [label="this.builtInOperators = new BuiltInOperators(this); 430750"];
899 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 430751"];
900 [label="_anonymousTypeManager = new AnonymousTypeManager(this); 430752"];
901 [label="new AnonymousTypeManager(this) 430753"];
902 [label="param AnonymousTypeManager(CSharpCompilation compilation) 430754"];
903 [label="param AnonymousTypeManager(this) 430755"];
904 [label="param AnonymousTypeManager(this) 430756"];
905 [label="public CSharpCompilation Compilation { get; } 430757"];
906 [label="_lazyAnonymousTypeTemplates 430758"];
907 [label="_lazySynthesizedDelegates 430759"];
908 [label="new ConcurrentDictionary<Location, bool>() 430760"];
909 [label="_sourceLocationsSeen = new ConcurrentDictionary<Location, bool>() 430761"];
910 [label="Debug.Assert(compilation != null); 430762"];
911 [label="Debug.Assert(compilation != null); 430763"];
912 [label="this.Compilation 430764"];
913 [label="_anonymousTypeManager 430765"];
914 [label="CommonLanguageVersion(syntaxAndDeclarations.ExternalSyntaxTrees) 430766"];
915 [label="param CommonLanguageVersion(ImmutableArray<SyntaxTree> syntaxTrees) 430767"];
916 [label="LanguageVersion? result = null; 430768"];
917 [label="foreach (var tree in syntaxTrees)\n            {\n                var version = ((CSharpParseOptions)tree.Options).LanguageVersion;\n                if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                }\n            } 430769"];
918 [label="var version = ((CSharpParseOptions)tree.Options).LanguageVersion; 430770"];
919 [label="if (result == null)\n                {\n                    result = version;\n                }\n                else if (result != version)\n                {\n                    throw new ArgumentException(CodeAnalysisResources.InconsistentLanguageVersions, nameof(syntaxTrees));\n                } 430771"];
920 [label="result = version; 430772"];
921 [label="if (isSubmission)\n            {\n                Debug.Assert(previousSubmission == null || previousSubmission.HostObjectType == hostObjectType);\n                this.ScriptCompilationInfo = new CSharpScriptCompilationInfo(previousSubmission, submissionReturnType, hostObjectType);\n            }\n            else\n            {\n                Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null);\n            } 430773"];
922 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430774"];
923 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430775"];
924 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430776"];
925 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430777"];
926 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430778"];
927 [label="Debug.Assert(previousSubmission == null && submissionReturnType == null && hostObjectType == null); 430779"];
928 [label="if (referenceManager is null)\n                {\n                    throw new ArgumentNullException(nameof(referenceManager));\n                } 430780"];
929 [label="referenceManager.AssertCanReuseForCompilation(this); 430781"];
930 [label="referenceManager.AssertCanReuseForCompilation(this); 430782"];
931 [label="_referenceManager 430783"];
932 [label="Debug.Assert(_lazyAssemblySymbol is null); 430784"];
933 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 430785"];
934 [label="if (EventQueue != null) EventQueue.TryEnqueue(new CompilationStartedEvent(this)); 430786"];
935 [label="return Update(_referenceManager, reuseReferenceManager, syntaxAndDeclarations); 430787"];
936 [label="compilation = compilation.AddSyntaxTrees(syntaxTrees); 430788"];
937 [label="Debug.Assert(compilation._lazyAssemblySymbol is null); 430789"];
938 [label="return compilation; 430790"];
939 [label="var compilation = createCompilationLambda(); 430791"];
940 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 430792"];
941 [label="IsNullableEnabled(compilation) 430793"];
942 [label="param IsNullableEnabled(CSharpCompilation compilation) 430794"];
943 [label="compilation.SyntaxTrees 430795"];
944 [label="get { return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; } 430796"];
945 [label="return _syntaxAndDeclarations.GetLazyState().SyntaxTrees; 430797"];
946 [label="var trees = compilation.SyntaxTrees; 430798"];
947 [label="if (trees.IsDefaultOrEmpty)\n            {\n                return false;\n            } 430799"];
948 [label="var options = (CSharpParseOptions)trees[0].Options; 430800"];
949 [label="var options = (CSharpParseOptions)trees[0].Options; 430801"];
950 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 430802"];
951 [label="return options.IsFeatureEnabled(MessageID.IDS_FeatureNullableReferenceTypes); 430803"];
952 [label="if (!skipUsesIsNullable && !IsNullableEnabled(compilation))\n            {\n                VerifyUsesOfNullability(createCompilationLambda().SourceModule.GlobalNamespace, expectedUsesOfNullable: ImmutableArray<string>.Empty);\n            } 430804"];
953 [label="return compilation; 430805"];
954 [label="CustomAssert.Equal(0, comp.GetDeclarationDiagnostics().Count(e => e.Severity >= DiagnosticSeverity.Error)); 430806"];
955 [label="comp.GetDeclarationDiagnostics() 430807"];
956 [label="param GetDeclarationDiagnostics(CancellationToken cancellationToken = default) 430808"];
957 [label="param GetDeclarationDiagnostics(this) 430809"];
958 [label="return GetDiagnostics(CompilationStage.Declare, false, cancellationToken); 430810"];
959 [label="return GetDiagnostics(CompilationStage.Declare, false, cancellationToken); 430811"];
960 [label="return GetDiagnostics(CompilationStage.Declare, false, cancellationToken); 430812"];
961 [label="GetDiagnostics(CompilationStage.Declare, false, cancellationToken) 430813"];
962 [label="param GetDiagnostics(CompilationStage stage) 430814"];
963 [label="param GetDiagnostics(bool includeEarlierStages) 430815"];
964 [label="param GetDiagnostics(CancellationToken cancellationToken) 430816"];
965 [label="param GetDiagnostics(this) 430817"];
966 [label="var diagnostics = DiagnosticBag.GetInstance(); 430818"];
967 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 430819"];
968 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 430820"];
969 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 430821"];
970 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 430822"];
971 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken) 430823"];
972 [label="param GetDiagnostics(CompilationStage stage) 430824"];
973 [label="param GetDiagnostics(bool includeEarlierStages) 430825"];
974 [label="param GetDiagnostics(DiagnosticBag diagnostics) 430826"];
975 [label="param GetDiagnostics(CancellationToken cancellationToken = default) 430827"];
976 [label="param GetDiagnostics(this) 430828"];
977 [label="DiagnosticBag? builder = DiagnosticBag.GetInstance(); 430829"];
978 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 430830"];
979 [label="if (stage == CompilationStage.Parse || (stage > CompilationStage.Parse && includeEarlierStages))\n            {\n                var syntaxTrees = this.SyntaxTrees;\n                if (this.Options.ConcurrentBuild)\n                {\n                    RoslynParallel.For(\n                        0,\n                        syntaxTrees.Length,\n                        UICultureUtilities.WithCurrentUICulture<int>(i =>\n                        {\n                            var syntaxTree = syntaxTrees[i];\n                            AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n                            builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                        }),\n                        cancellationToken);\n                }\n                else\n                {\n                    foreach (var syntaxTree in syntaxTrees)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        AppendLoadDirectiveDiagnostics(builder, _syntaxAndDeclarations, syntaxTree);\n\n                        cancellationToken.ThrowIfCancellationRequested();\n                        builder.AddRange(syntaxTree.GetDiagnostics(cancellationToken));\n                    }\n                }\n\n                var parseOptionsReported = new HashSet<ParseOptions>();\n                foreach (var syntaxTree in syntaxTrees)\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    if (!syntaxTree.Options.Errors.IsDefaultOrEmpty && parseOptionsReported.Add(syntaxTree.Options))\n                    {\n                        var location = syntaxTree.GetLocation(TextSpan.FromBounds(0, 0));\n                        foreach (var error in syntaxTree.Options.Errors)\n                        {\n                            builder.Add(error.WithLocation(location));\n                        }\n                    }\n                }\n            } 430831"];
980 [label="if (stage == CompilationStage.Declare || stage > CompilationStage.Declare && includeEarlierStages)\n            {\n                CheckAssemblyName(builder);\n                builder.AddRange(Options.Errors);\n\n                if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                }\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                // the set of diagnostics related to establishing references.\n                builder.AddRange(GetBoundReferenceManager().Diagnostics);\n\n                cancellationToken.ThrowIfCancellationRequested();\n\n                builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken));\n\n                if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                }\n            } 430832"];
981 [label="CheckAssemblyName(builder); 430833"];
982 [label="CheckAssemblyName(builder); 430834"];
983 [label="CheckAssemblyName(builder); 430835"];
984 [label="get { return _syntaxAndDeclarations.MessageProvider; } 430836"];
985 [label="return _syntaxAndDeclarations.MessageProvider; 430837"];
986 [label="Options 430838"];
987 [label="get\n            {\n                return _options;\n            } 430839"];
988 [label="return _options; 430840"];
989 [label="builder.AddRange(Options.Errors); 430841"];
990 [label="Options 430842"];
991 [label="get\n            {\n                return _options;\n            } 430843"];
992 [label="return _options; 430844"];
993 [label="if (Options.NullableContextOptions != NullableContextOptions.Disable && LanguageVersion < MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion() &&\n                    _syntaxAndDeclarations.ExternalSyntaxTrees.Any())\n                {\n                    builder.Add(new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_NullableOptionNotAvailable,\n                                                 nameof(Options.NullableContextOptions), Options.NullableContextOptions, LanguageVersion.ToDisplayString(),\n                                                 new CSharpRequiredLanguageVersion(MessageID.IDS_FeatureNullableReferenceTypes.RequiredVersion())), Location.None));\n                } 430845"];
994 [label="cancellationToken.ThrowIfCancellationRequested(); 430846"];
995 [label="GetBoundReferenceManager() 430847"];
996 [label="param GetBoundReferenceManager(this) 430848"];
997 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 430849"];
998 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 430850"];
999 [label="_referenceManager.CreateSourceAssemblyForCompilation(this) 430851"];
1000 [label="param CreateSourceAssemblyForCompilation(CSharpCompilation compilation) 430852"];
1001 [label="param CreateSourceAssemblyForCompilation(this) 430853"];
1002 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 430854"];
1003 [label="CreateAndSetSourceAssemblyFullBind(compilation) 430855"];
1004 [label="param CreateAndSetSourceAssemblyFullBind(CSharpCompilation compilation) 430856"];
1005 [label="param CreateAndSetSourceAssemblyFullBind(this) 430857"];
1006 [label="var resolutionDiagnostics = DiagnosticBag.GetInstance(); 430858"];
1007 [label="var assemblyReferencesBySimpleName = PooledDictionary<string, List<ReferencedAssemblyIdentity>>.GetInstance(); 430859"];
1008 [label="compilation.Options 430860"];
1009 [label="get\n            {\n                return _options;\n            } 430861"];
1010 [label="bool supersedeLowerVersions = compilation.Options.ReferencesSupersedeLowerVersions; 430862"];
1011 [label="IDictionary<(string, string), MetadataReference>? boundReferenceDirectiveMap; 430863"];
1012 [label="ImmutableArray<MetadataReference> boundReferenceDirectives; 430864"];
1013 [label="boundReferenceDirectives 430865"];
1014 [label="ImmutableArray<AssemblyData> referencedAssemblies; 430866"];
1015 [label="referencedAssemblies 430867"];
1016 [label="ImmutableArray<PEModule> modules; 430868"];
1017 [label="modules 430869"];
1018 [label="ImmutableArray<MetadataReference> explicitReferences; 430870"];
1019 [label="explicitReferences 430871"];
1020 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430872"];
1021 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430873"];
1022 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430874"];
1023 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430875"];
1024 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430876"];
1025 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430877"];
1026 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430878"];
1027 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430879"];
1028 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430880"];
1029 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430881"];
1030 [label="get { return this.Declarations.ReferenceDirectives; } 430882"];
1031 [label="this.Declarations 430883"];
1032 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 430884"];
1033 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 430885"];
1034 [label="return this.Declarations.ReferenceDirectives; 430886"];
1035 [label="SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 430887"];
1036 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 430888"];
1037 [label="SymbolDisplayCompilerInternalOptions.None 430889"];
1038 [label="SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 430890"];
1039 [label="s_debuggerDisplayFormat =\n            SymbolDisplayFormat.TestFormat\n                .AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier\n                    | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier)\n                .WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.None) 430891"];
1040 [label="this.Declarations.ReferenceDirectives 430892"];
1041 [label="param ReportErrorIfHasConstraints(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) 430893"];
1042 [label="param ReportErrorIfHasConstraints(DiagnosticBag diagnostics) 430894"];
1043 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 430895"];
1044 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 430896"];
1045 [label="param ToDeclarationModifiers(this SyntaxTokenList modifiers) 430897"];
1046 [label="param ToDeclarationModifiers(DiagnosticBag diagnostics) 430898"];
1047 [label="var result = DeclarationModifiers.None; 430899"];
1048 [label="bool seenNoDuplicates = true; 430900"];
1049 [label="bool seenNoAccessibilityDuplicates = true; 430901"];
1050 [label="foreach (var modifier in modifiers)\n            {\n                DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind());\n\n                ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics);\n\n                result |= one;\n            } 430902"];
1051 [label="DeclarationModifiers one = ToDeclarationModifier(modifier.ContextualKind()); 430903"];
1052 [label="ToDeclarationModifier(modifier.ContextualKind()) 430904"];
1053 [label="param ToDeclarationModifier(SyntaxKind kind) 430905"];
1054 [label="switch (kind)\n            {\n                case SyntaxKind.AbstractKeyword:\n                    return DeclarationModifiers.Abstract;\n                case SyntaxKind.AsyncKeyword:\n                    return DeclarationModifiers.Async;\n                case SyntaxKind.SealedKeyword:\n                    return DeclarationModifiers.Sealed;\n                case SyntaxKind.StaticKeyword:\n                    return DeclarationModifiers.Static;\n                case SyntaxKind.NewKeyword:\n                    return DeclarationModifiers.New;\n                case SyntaxKind.PublicKeyword:\n                    return DeclarationModifiers.Public;\n                case SyntaxKind.ProtectedKeyword:\n                    return DeclarationModifiers.Protected;\n                case SyntaxKind.InternalKeyword:\n                    return DeclarationModifiers.Internal;\n                case SyntaxKind.PrivateKeyword:\n                    return DeclarationModifiers.Private;\n                case SyntaxKind.ExternKeyword:\n                    return DeclarationModifiers.Extern;\n                case SyntaxKind.ReadOnlyKeyword:\n                    return DeclarationModifiers.ReadOnly;\n                case SyntaxKind.PartialKeyword:\n                    return DeclarationModifiers.Partial;\n                case SyntaxKind.UnsafeKeyword:\n                    return DeclarationModifiers.Unsafe;\n                case SyntaxKind.VirtualKeyword:\n                    return DeclarationModifiers.Virtual;\n                case SyntaxKind.OverrideKeyword:\n                    return DeclarationModifiers.Override;\n                case SyntaxKind.ConstKeyword:\n                    return DeclarationModifiers.Const;\n                case SyntaxKind.FixedKeyword:\n                    return DeclarationModifiers.Fixed;\n                case SyntaxKind.VolatileKeyword:\n                    return DeclarationModifiers.Volatile;\n                case SyntaxKind.RefKeyword:\n                    return DeclarationModifiers.Ref;\n                case SyntaxKind.DataKeyword:\n                    return DeclarationModifiers.Data;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 430906"];
1055 [label="return DeclarationModifiers.Public; 430907"];
1056 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430908"];
1057 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430909"];
1058 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430910"];
1059 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430911"];
1060 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430912"];
1061 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430913"];
1062 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 430914"];
1063 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 430915"];
1064 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 430916"];
1065 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 430917"];
1066 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 430918"];
1067 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 430919"];
1068 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 430920"];
1069 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 430921"];
1070 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 430922"];
1071 [label="result |= one; 430923"];
1072 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 430924"];
1073 [label="return result; 430925"];
1074 [label="if (constraintClauses.Count > 0)\n            {\n                diagnostics.Add(\n                    ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl,\n                    constraintClauses[0].WhereKeyword.GetLocation());\n            } 430926"];
1075 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430927"];
1076 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430928"];
1077 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430929"];
1078 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430930"];
1079 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics); 430931"];
1080 [label="ReportDuplicateModifiers(\n                    modifier, one, result,\n                    ref seenNoDuplicates, ref seenNoAccessibilityDuplicates,\n                    diagnostics) 430932"];
1081 [label="param ReportDuplicateModifiers(SyntaxToken modifierToken) 430933"];
1082 [label="param ReportDuplicateModifiers(DeclarationModifiers modifierKind) 430934"];
1083 [label="param ReportDuplicateModifiers(DeclarationModifiers allModifiers) 430935"];
1084 [label="param ReportDuplicateModifiers(ref bool seenNoDuplicates) 430936"];
1085 [label="param ReportDuplicateModifiers(ref bool seenNoAccessibilityDuplicates) 430937"];
1086 [label="param ReportDuplicateModifiers(DiagnosticBag diagnostics) 430938"];
1087 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 430939"];
1088 [label="if ((allModifiers & modifierKind) != 0)\n            {\n                if (seenNoDuplicates)\n                {\n                    diagnostics.Add(\n                        ErrorCode.ERR_DuplicateModifier,\n                        modifierToken.GetLocation(),\n                        SyntaxFacts.GetText(modifierToken.Kind()));\n                    seenNoDuplicates = false;\n                }\n            } 430940"];
1089 [label="switch (result & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.Protected | DeclarationModifiers.Internal:\n                    // the two keywords 'protected' and 'internal' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.ProtectedInternal;\n                    break;\n\n                case DeclarationModifiers.Private | DeclarationModifiers.Protected:\n                    // the two keywords 'private' and 'protected' together are treated as one modifier.\n                    result &= ~DeclarationModifiers.AccessibilityMask;\n                    result |= DeclarationModifiers.PrivateProtected;\n                    break;\n            } 430941"];
1090 [label="get { return _options; } 430942"];
1091 [label="return _options; 430943"];
1092 [label="get { return CSharp.MessageProvider.Instance; } 430944"];
1093 [label="return CSharp.MessageProvider.Instance; 430945"];
1094 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 430946"];
1095 [label="param CreateAssemblyDataForFile(PEAssembly assembly) 430947"];
1096 [label="param CreateAssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 430948"];
1097 [label="param CreateAssemblyDataForFile(DocumentationProvider documentationProvider) 430949"];
1098 [label="param CreateAssemblyDataForFile(string sourceAssemblySimpleName) 430950"];
1099 [label="param CreateAssemblyDataForFile(MetadataImportOptions importOptions) 430951"];
1100 [label="param CreateAssemblyDataForFile(bool embedInteropTypes) 430952"];
1101 [label="param CreateAssemblyDataForFile(this) 430953"];
1102 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430954"];
1103 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430955"];
1104 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430956"];
1105 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430957"];
1106 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430958"];
1107 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430959"];
1108 [label="return new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions); 430960"];
1109 [label="new AssemblyDataForFile(\n                    assembly,\n                    cachedSymbols,\n                    embedInteropTypes,\n                    documentationProvider,\n                    sourceAssemblySimpleName,\n                    importOptions) 430961"];
1110 [label="param AssemblyDataForFile(PEAssembly assembly) 430962"];
1111 [label="param AssemblyDataForFile(WeakList<IAssemblySymbolInternal> cachedSymbols) 430963"];
1112 [label="param AssemblyDataForFile(bool embedInteropTypes) 430964"];
1113 [label="param AssemblyDataForFile(DocumentationProvider documentationProvider) 430965"];
1114 [label="param AssemblyDataForFile(string sourceAssemblySimpleName) 430966"];
1115 [label="param AssemblyDataForFile(MetadataImportOptions compilationImportOptions) 430967"];
1116 [label="param AssemblyDataForFile(this) 430968"];
1117 [label="assembly.Identity 430969"];
1118 [label="assembly.AssemblyReferences 430970"];
1119 [label="embedInteropTypes 430971"];
1120 [label="param AssemblyDataForFile(this) 430972"];
1121 [label="param AssemblyDataForMetadataOrCompilation(AssemblyIdentity identity) 430973"];
1122 [label="param AssemblyDataForMetadataOrCompilation(ImmutableArray<AssemblyIdentity> referencedAssemblies) 430974"];
1123 [label="param AssemblyDataForMetadataOrCompilation(bool embedInteropTypes) 430975"];
1124 [label="param AssemblyDataForMetadataOrCompilation(this) 430976"];
1125 [label="param AssemblyDataForMetadataOrCompilation(this) 430977"];
1126 [label="_assemblies 430978"];
1127 [label="_identity 430979"];
1128 [label="_embedInteropTypes 430980"];
1129 [label="RoslynDebug.Assert(identity != null); 430981"];
1130 [label="RoslynDebug.Assert(identity != null); 430982"];
1131 [label="Debug.Assert(!referencedAssemblies.IsDefault); 430983"];
1132 [label="_embedInteropTypes 430984"];
1133 [label="_identity 430985"];
1134 [label="_referencedAssemblies 430986"];
1135 [label="Assembly 430987"];
1136 [label="CachedSymbols 430988"];
1137 [label="DocumentationProvider 430989"];
1138 [label="_compilationImportOptions 430990"];
1139 [label="_sourceAssemblySimpleName 430991"];
1140 [label="_internalsVisibleComputed 430992"];
1141 [label="_internalsPotentiallyVisibleToCompilation 430993"];
1142 [label="RoslynDebug.Assert(documentationProvider != null); 430994"];
1143 [label="RoslynDebug.Assert(documentationProvider != null); 430995"];
1144 [label="RoslynDebug.Assert(cachedSymbols != null); 430996"];
1145 [label="RoslynDebug.Assert(cachedSymbols != null); 430997"];
1146 [label="CachedSymbols 430998"];
1147 [label="Assembly 430999"];
1148 [label="DocumentationProvider 431000"];
1149 [label="_compilationImportOptions 431001"];
1150 [label="_sourceAssemblySimpleName 431002"];
1151 [label="ImmutableArray<ResolvedReference> referenceMap = ResolveMetadataReferences(\n                        compilation,\n                        assemblyReferencesBySimpleName,\n                        out explicitReferences,\n                        out boundReferenceDirectiveMap,\n                        out boundReferenceDirectives,\n                        out referencedAssemblies,\n                        out modules,\n                        resolutionDiagnostics); 431003"];
1152 [label="RoslynDebug.Assert(identity != null); 431004"];
1153 [label="Debug.Assert(!referencedAssemblies.IsDefault); 431005"];
1154 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 431006"];
1155 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 431007"];
1156 [label="var assemblyBeingBuiltData = new AssemblyDataForAssemblyBeingBuilt(new AssemblyIdentity(name: SimpleAssemblyName, noThrow: true), referencedAssemblies, modules); 431008"];
1157 [label="get\n                    {\n                        return _identity;\n                    } 431009"];
1158 [label="return _identity; 431010"];
1159 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 431011"];
1160 [label="var explicitAssemblyData = referencedAssemblies.Insert(0, assemblyBeingBuiltData); 431012"];
1161 [label="bool hasCircularReference; 431013"];
1162 [label="int corLibraryIndex; 431014"];
1163 [label="ImmutableArray<MetadataReference> implicitlyResolvedReferences; 431015"];
1164 [label="implicitlyResolvedReferences 431016"];
1165 [label="ImmutableArray<ResolvedReference> implicitlyResolvedReferenceMap; 431017"];
1166 [label="implicitlyResolvedReferenceMap 431018"];
1167 [label="ImmutableArray<AssemblyData> allAssemblyData; 431019"];
1168 [label="allAssemblyData 431020"];
1169 [label="var temp1 = compilation.ScriptCompilationInfo; 431021"];
1170 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 431022"];
1171 [label="var temp2 = temp1 != null ? temp1.PreviousScriptCompilation : null; 431023"];
1172 [label="temp1 != null 431024"];
1173 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 431025"];
1174 [label="var temp3 = temp2 != null ? temp2.GetBoundReferenceManager() : null; 431026"];
1175 [label="temp2 != null 431027"];
1176 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 431028"];
1177 [label="var temp4 = temp3 != null ? temp3.ImplicitReferenceResolutions : null; 431029"];
1178 [label="temp3 != null 431030"];
1179 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 431031"];
1180 [label="var implicitReferenceResolutions = temp4 ?? ImmutableDictionary<AssemblyIdentity, PortableExecutableReference?>.Empty; 431032"];
1181 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431033"];
1182 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431034"];
1183 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431035"];
1184 [label="compilation.Options 431036"];
1185 [label="get\n            {\n                return _options;\n            } 431037"];
1186 [label="return _options; 431038"];
1187 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431039"];
1188 [label="compilation.Options 431040"];
1189 [label="get\n            {\n                return _options;\n            } 431041"];
1190 [label="return _options; 431042"];
1191 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431043"];
1192 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431044"];
1193 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431045"];
1194 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431046"];
1195 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431047"];
1196 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431048"];
1197 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431049"];
1198 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431050"];
1199 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431051"];
1200 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431052"];
1201 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431053"];
1202 [label="BoundInputAssembly[] bindingResult = Bind(\n                        compilation,\n                        explicitAssemblyData,\n                        modules,\n                        explicitReferences,\n                        referenceMap,\n                        compilation.Options.MetadataReferenceResolver,\n                        compilation.Options.MetadataImportOptions,\n                        supersedeLowerVersions,\n                        assemblyReferencesBySimpleName,\n                        out allAssemblyData,\n                        out implicitlyResolvedReferences,\n                        out implicitlyResolvedReferenceMap,\n                        ref implicitReferenceResolutions,\n                        resolutionDiagnostics,\n                        out hasCircularReference,\n                        out corLibraryIndex); 431054"];
1203 [label="param BindAssemblyReferences(ImmutableArray<AssemblyData> assemblies) 431055"];
1204 [label="param BindAssemblyReferences(AssemblyIdentityComparer assemblyIdentityComparer) 431056"];
1205 [label="param BindAssemblyReferences(this) 431057"];
1206 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 431058"];
1207 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 431059"];
1208 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 431060"];
1209 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 431061"];
1210 [label="return ResolveReferencedAssemblies(_referencedAssemblies, assemblies, definitionStartIndex: 0, assemblyIdentityComparer: assemblyIdentityComparer); 431062"];
1211 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431063"];
1212 [label="return _embedInteropTypes; 431064"];
1213 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 431065"];
1214 [label="return _referencedAssemblies; 431066"];
1215 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 431067"];
1216 [label="return Assembly.ContainsNoPiaLocalTypes(); 431068"];
1217 [label="get\n                    {\n                        return Assembly.DeclaresTheObjectClass;\n                    } 431069"];
1218 [label="return Assembly.DeclaresTheObjectClass; 431070"];
1219 [label="get\n                    {\n                        if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        }\n\n                        return _assemblies;\n                    } 431071"];
1220 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 431072"];
1221 [label="if (_assemblies == null)\n                        {\n                            _assemblies = new List<AssemblySymbol>();\n\n                            // This should be done lazy because while we creating\n                            // instances of this type, creation of new SourceAssembly symbols\n                            // might change the set of available AssemblySymbols.\n                            AddAvailableSymbols(_assemblies);\n                        } 431073"];
1222 [label="_assemblies = new List<AssemblySymbol>(); 431074"];
1223 [label="_assemblies 431075"];
1224 [label="AddAvailableSymbols(_assemblies); 431076"];
1225 [label="AddAvailableSymbols(_assemblies) 431077"];
1226 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 431078"];
1227 [label="param AddAvailableSymbols(this) 431079"];
1228 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 431080"];
1229 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 431081"];
1230 [label="AddAvailableSymbols(_assemblies); 431082"];
1231 [label="return _assemblies; 431083"];
1232 [label="AddAvailableSymbols(_assemblies); 431084"];
1233 [label="AddAvailableSymbols(_assemblies) 431085"];
1234 [label="param AddAvailableSymbols(List<AssemblySymbol> assemblies) 431086"];
1235 [label="param AddAvailableSymbols(this) 431087"];
1236 [label="foreach (var assembly in CachedSymbols)\n                        {\n                            var peAssembly = assembly as PEAssemblySymbol;\n                            if (IsMatchingAssembly(peAssembly))\n                            {\n                                assemblies.Add(peAssembly!);\n                            }\n                        } 431088"];
1237 [label="AddAvailableSymbols(_assemblies); 431089"];
1238 [label="Debug.Assert(bindingResult.Length == allAssemblyData.Length); 431090"];
1239 [label="var references = explicitReferences.AddRange(implicitlyResolvedReferences); 431091"];
1240 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 431092"];
1241 [label="referenceMap = referenceMap.AddRange(implicitlyResolvedReferenceMap); 431093"];
1242 [label="Dictionary<MetadataReference, int> referencedAssembliesMap, referencedModulesMap; 431094"];
1243 [label="ImmutableArray<ImmutableArray<string>> aliasesOfReferencedAssemblies; 431095"];
1244 [label="aliasesOfReferencedAssemblies 431096"];
1245 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431097"];
1246 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431098"];
1247 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431099"];
1248 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431100"];
1249 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431101"];
1250 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431102"];
1251 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431103"];
1252 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431104"];
1253 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431105"];
1254 [label="BuildReferencedAssembliesAndModulesMaps(\n                        bindingResult,\n                        references,\n                        referenceMap,\n                        modules.Length,\n                        referencedAssemblies.Length,\n                        assemblyReferencesBySimpleName,\n                        supersedeLowerVersions,\n                        out referencedAssembliesMap,\n                        out referencedModulesMap,\n                        out aliasesOfReferencedAssemblies); 431106"];
1255 [label="var newSymbols = new List<int>(); 431107"];
1256 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 431108"];
1257 [label="for (int i = 1; i < bindingResult.Length; i++)\n                    {\n                        ref BoundInputAssembly bound = ref bindingResult[i];\n                        if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        }\n\n                        Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked);\n                    } 431109"];
1258 [label="ref BoundInputAssembly bound = ref bindingResult[i]; 431110"];
1259 [label="if (bound.AssemblySymbol is null)\n                        {\n                            // symbol hasn't been found in the cache, create a new one\n                            bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol();\n                            newSymbols.Add(i);\n                        } 431111"];
1260 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 431112"];
1261 [label="((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol() 431113"];
1262 [label="param CreateAssemblySymbol(this) 431114"];
1263 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 431115"];
1264 [label="this.IsLinked 431116"];
1265 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431117"];
1266 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 431118"];
1267 [label="this.EffectiveImportOptions 431119"];
1268 [label="get\n                    {\n                        // We need to import internal members if they might be visible to the compilation being compiled:\n                        if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        }\n\n                        return _compilationImportOptions;\n                    } 431120"];
1269 [label="InternalsMayBeVisibleToCompilation 431121"];
1270 [label="get\n                    {\n                        if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        }\n\n                        return _internalsPotentiallyVisibleToCompilation;\n                    } 431122"];
1271 [label="if (!_internalsVisibleComputed)\n                        {\n                            _internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly);\n                            _internalsVisibleComputed = true;\n                        } 431123"];
1272 [label="_internalsPotentiallyVisibleToCompilation = InternalsMayBeVisibleToAssemblyBeingCompiled(_sourceAssemblySimpleName, Assembly); 431124"];
1273 [label="_internalsPotentiallyVisibleToCompilation 431125"];
1274 [label="_internalsVisibleComputed = true; 431126"];
1275 [label="_internalsVisibleComputed 431127"];
1276 [label="return _internalsPotentiallyVisibleToCompilation; 431128"];
1277 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 431129"];
1278 [label="return _compilationImportOptions; 431130"];
1279 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 431131"];
1280 [label="return new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions); 431132"];
1281 [label="new PEAssemblySymbol(Assembly, DocumentationProvider, this.IsLinked, this.EffectiveImportOptions) 431133"];
1282 [label="param PEAssemblySymbol(PEAssembly assembly) 431134"];
1283 [label="param PEAssemblySymbol(DocumentationProvider documentationProvider) 431135"];
1284 [label="param PEAssemblySymbol(bool isLinked) 431136"];
1285 [label="param PEAssemblySymbol(MetadataImportOptions importOptions) 431137"];
1286 [label="param PEAssemblySymbol(this) 431138"];
1287 [label="param PEAssemblySymbol(this) 431139"];
1288 [label="param MetadataOrSourceAssemblySymbol(this) 431140"];
1289 [label="param MetadataOrSourceAssemblySymbol(this) 431141"];
1290 [label="param NonMissingAssemblySymbol(this) 431142"];
1291 [label="new char[] { '+' } 431143"];
1292 [label="'+' 431144"];
1293 [label="new char[] { '+' } 431145"];
1294 [label="s_nestedTypeNameSeparators = new char[] { '+' } 431146"];
1295 [label="param NonMissingAssemblySymbol(this) 431147"];
1296 [label="param AssemblySymbol(this) 431148"];
1297 [label="param AssemblySymbol(this) 431149"];
1298 [label="param Symbol(this) 431150"];
1299 [label="_lazyISymbol 431151"];
1300 [label="_corLibrary 431152"];
1301 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 431153"];
1302 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 431154"];
1303 [label="_globalNamespace 431155"];
1304 [label="_lazySpecialTypes 431156"];
1305 [label="_cachedSpecialTypes 431157"];
1306 [label="_lazyNativeIntegerTypes 431158"];
1307 [label="_lazyTypeNames 431159"];
1308 [label="_lazyNamespaceNames 431160"];
1309 [label="_lazySpecialTypeMembers 431161"];
1310 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 431162"];
1311 [label="_assembly 431163"];
1312 [label="_documentationProvider 431164"];
1313 [label="_isLinked 431165"];
1314 [label="Debug.Assert(assembly != null); 431166"];
1315 [label="Debug.Assert(assembly != null); 431167"];
1316 [label="Debug.Assert(documentationProvider != null); 431168"];
1317 [label="Debug.Assert(documentationProvider != null); 431169"];
1318 [label="_assembly 431170"];
1319 [label="_documentationProvider 431171"];
1320 [label="var modules = new ModuleSymbol[assembly.Modules.Length]; 431172"];
1321 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 431173"];
1322 [label="for (int i = 0; i < assembly.Modules.Length; i++)\n            {\n                modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i);\n            } 431174"];
1323 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 431175"];
1324 [label="31 431176"];
1325 [label="DefaultTypeMapCapacity = 31 431177"];
1326 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 431178"];
1327 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 431179"];
1328 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 431180"];
1329 [label="modules[i] = new PEModuleSymbol(this, assembly.Modules[i], importOptions, i); 431181"];
1330 [label="new PEModuleSymbol(this, assembly.Modules[i], importOptions, i) 431182"];
1331 [label="param PEModuleSymbol(PEAssemblySymbol assemblySymbol) 431183"];
1332 [label="param PEModuleSymbol(PEModule module) 431184"];
1333 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 431185"];
1334 [label="param PEModuleSymbol(int ordinal) 431186"];
1335 [label="param PEModuleSymbol(this) 431187"];
1336 [label="assemblySymbol 431188"];
1337 [label="module 431189"];
1338 [label="importOptions 431190"];
1339 [label="ordinal 431191"];
1340 [label="param PEModuleSymbol(this) 431192"];
1341 [label="param PEModuleSymbol(AssemblySymbol assemblySymbol) 431193"];
1342 [label="param PEModuleSymbol(PEModule module) 431194"];
1343 [label="param PEModuleSymbol(MetadataImportOptions importOptions) 431195"];
1344 [label="param PEModuleSymbol(int ordinal) 431196"];
1345 [label="param PEModuleSymbol(this) 431197"];
1346 [label="param PEModuleSymbol(this) 431198"];
1347 [label="param NonMissingModuleSymbol(this) 431199"];
1348 [label="param NonMissingModuleSymbol(this) 431200"];
1349 [label="param ModuleSymbol(this) 431201"];
1350 [label="param ModuleSymbol(this) 431202"];
1351 [label="param Symbol(this) 431203"];
1352 [label="_lazyISymbol 431204"];
1353 [label="_moduleReferences 431205"];
1354 [label="_assemblySymbol 431206"];
1355 [label="_ordinal 431207"];
1356 [label="_module 431208"];
1357 [label="_globalNamespace 431209"];
1358 [label="_lazySystemTypeSymbol 431210"];
1359 [label="_lazyEventRegistrationTokenSymbol 431211"];
1360 [label="_lazyEventRegistrationTokenTableSymbol 431212"];
1361 [label="2 431213"];
1362 [label="concurrencyLevel: 2 431214"];
1363 [label="capacity: DefaultTypeMapCapacity 431215"];
1364 [label="new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 431216"];
1365 [label="TypeHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeDefinitionHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 431217"];
1366 [label="2 431218"];
1367 [label="concurrencyLevel: 2 431219"];
1368 [label="capacity: DefaultTypeMapCapacity 431220"];
1369 [label="new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 431221"];
1370 [label="TypeRefHandleToTypeMap =\n                                    new ConcurrentDictionary<TypeReferenceHandle, TypeSymbol>(concurrencyLevel: 2, capacity: DefaultTypeMapCapacity) 431222"];
1371 [label="ImportOptions 431223"];
1372 [label="_lazyTypeNames 431224"];
1373 [label="_lazyNamespaceNames 431225"];
1374 [label="_lazyNullableMemberMetadata 431226"];
1375 [label="Debug.Assert((object)assemblySymbol != null); 431227"];
1376 [label="Debug.Assert((object)assemblySymbol != null); 431228"];
1377 [label="Debug.Assert(module != null); 431229"];
1378 [label="Debug.Assert(module != null); 431230"];
1379 [label="_assemblySymbol 431231"];
1380 [label="_ordinal 431232"];
1381 [label="_module 431233"];
1382 [label="this.ImportOptions 431234"];
1383 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 431235"];
1384 [label="_globalNamespace = new PEGlobalNamespaceSymbol(this); 431236"];
1385 [label="new PEGlobalNamespaceSymbol(this) 431237"];
1386 [label="param PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol) 431238"];
1387 [label="param PEGlobalNamespaceSymbol(this) 431239"];
1388 [label="param PEGlobalNamespaceSymbol(this) 431240"];
1389 [label="param PENamespaceSymbol(this) 431241"];
1390 [label="param PENamespaceSymbol(this) 431242"];
1391 [label="param NamespaceSymbol(this) 431243"];
1392 [label="param NamespaceSymbol(this) 431244"];
1393 [label="param NamespaceOrTypeSymbol(this) 431245"];
1394 [label="param NamespaceOrTypeSymbol(this) 431246"];
1395 [label="param Symbol(this) 431247"];
1396 [label="_lazyISymbol 431248"];
1397 [label="_lazyAdapter 431249"];
1398 [label="_lazyQualifiedName 431250"];
1399 [label="lazyNamespaces 431251"];
1400 [label="lazyTypes 431252"];
1401 [label="_lazyNoPiaLocalTypes 431253"];
1402 [label="_moduleSymbol 431254"];
1403 [label="Debug.Assert((object)moduleSymbol != null); 431255"];
1404 [label="Debug.Assert((object)moduleSymbol != null); 431256"];
1405 [label="_moduleSymbol 431257"];
1406 [label="_globalNamespace 431258"];
1407 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 431259"];
1408 [label="this.MetadataLocation = ImmutableArray.Create<MetadataLocation>(new MetadataLocation(this)); 431260"];
1409 [label="this.MetadataLocation 431261"];
1410 [label="Debug.Assert(ordinal >= 0); 431262"];
1411 [label="Debug.Assert(ordinal >= 0); 431263"];
1412 [label="modules[i] 431264"];
1413 [label="_modules = modules.AsImmutableOrNull(); 431265"];
1414 [label="_modules = modules.AsImmutableOrNull(); 431266"];
1415 [label="_modules 431267"];
1416 [label="_isLinked 431268"];
1417 [label="bound.AssemblySymbol = ((AssemblyDataForMetadataOrCompilation)allAssemblyData[i]).CreateAssemblySymbol(); 431269"];
1418 [label="bound.AssemblySymbol 431270"];
1419 [label="newSymbols.Add(i); 431271"];
1420 [label="newSymbols.Add(i); 431272"];
1421 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 431273"];
1422 [label="allAssemblyData[i].IsLinked 431274"];
1423 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431275"];
1424 [label="bound.AssemblySymbol.IsLinked 431276"];
1425 [label="get\n            {\n                return _isLinked;\n            } 431277"];
1426 [label="return _isLinked; 431278"];
1427 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 431279"];
1428 [label="return _internalsPotentiallyVisibleToCompilation; 431280"];
1429 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 431281"];
1430 [label="_assembly 431282"];
1431 [label="_documentationProvider 431283"];
1432 [label="Debug.Assert(assembly != null); 431284"];
1433 [label="Debug.Assert(documentationProvider != null); 431285"];
1434 [label="_assemblySymbol 431286"];
1435 [label="_ordinal 431287"];
1436 [label="_module 431288"];
1437 [label="_globalNamespace 431289"];
1438 [label="ImportOptions 431290"];
1439 [label="Debug.Assert((object)assemblySymbol != null); 431291"];
1440 [label="Debug.Assert(module != null); 431292"];
1441 [label="_moduleSymbol 431293"];
1442 [label="Debug.Assert((object)moduleSymbol != null); 431294"];
1443 [label="Debug.Assert(ordinal >= 0); 431295"];
1444 [label="bound.AssemblySymbol 431296"];
1445 [label="newSymbols.Add(i); 431297"];
1446 [label="newSymbols.Add(i); 431298"];
1447 [label="allAssemblyData[i].IsLinked 431299"];
1448 [label="bound.AssemblySymbol.IsLinked 431300"];
1449 [label="get\n            {\n                return _isLinked;\n            } 431301"];
1450 [label="return _isLinked; 431302"];
1451 [label="Debug.Assert(allAssemblyData[i].IsLinked == bound.AssemblySymbol.IsLinked); 431303"];
1452 [label="_assembly 431304"];
1453 [label="_documentationProvider 431305"];
1454 [label="_assemblySymbol 431306"];
1455 [label="_ordinal 431307"];
1456 [label="_module 431308"];
1457 [label="_globalNamespace 431309"];
1458 [label="ImportOptions 431310"];
1459 [label="Debug.Assert((object)assemblySymbol != null); 431311"];
1460 [label="Debug.Assert(module != null); 431312"];
1461 [label="_moduleSymbol 431313"];
1462 [label="Debug.Assert((object)moduleSymbol != null); 431314"];
1463 [label="Debug.Assert(ordinal >= 0); 431315"];
1464 [label="bound.AssemblySymbol 431316"];
1465 [label="newSymbols.Add(i); 431317"];
1466 [label="get\n            {\n                return _isLinked;\n            } 431318"];
1467 [label="return _isLinked; 431319"];
1468 [label="return _internalsPotentiallyVisibleToCompilation; 431320"];
1469 [label="if (InternalsMayBeVisibleToCompilation && _compilationImportOptions == MetadataImportOptions.Public)\n                        {\n                            return MetadataImportOptions.Internal;\n                        } 431321"];
1470 [label="_assembly 431322"];
1471 [label="_documentationProvider 431323"];
1472 [label="Debug.Assert(assembly != null); 431324"];
1473 [label="Debug.Assert(documentationProvider != null); 431325"];
1474 [label="Debug.Assert(ordinal >= 0); 431326"];
1475 [label="bound.AssemblySymbol 431327"];
1476 [label="newSymbols.Add(i); 431328"];
1477 [label="newSymbols.Add(i); 431329"];
1478 [label="bound.AssemblySymbol.IsLinked 431330"];
1479 [label="get\n            {\n                return _isLinked;\n            } 431331"];
1480 [label="return _isLinked; 431332"];
1481 [label="newSymbols.Add(i); 431333"];
1482 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 431334"];
1483 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 431335"];
1484 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 431336"];
1485 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 431337"];
1486 [label="t_assemblyForWhichCurrentThreadIsComputingKeys 431338"];
1487 [label="var assemblySymbol = new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules); 431339"];
1488 [label="new SourceAssemblySymbol(compilation, SimpleAssemblyName, compilation.MakeSourceModuleName(), netModules: modules) 431340"];
1489 [label="param SourceAssemblySymbol(CSharpCompilation compilation) 431341"];
1490 [label="param SourceAssemblySymbol(string assemblySimpleName) 431342"];
1491 [label="param SourceAssemblySymbol(string moduleName) 431343"];
1492 [label="param SourceAssemblySymbol(ImmutableArray<PEModule> netModules) 431344"];
1493 [label="param SourceAssemblySymbol(this) 431345"];
1494 [label="param SourceAssemblySymbol(this) 431346"];
1495 [label="param MetadataOrSourceAssemblySymbol(this) 431347"];
1496 [label="param MetadataOrSourceAssemblySymbol(this) 431348"];
1497 [label="param NonMissingAssemblySymbol(this) 431349"];
1498 [label="param NonMissingAssemblySymbol(this) 431350"];
1499 [label="param AssemblySymbol(this) 431351"];
1500 [label="param AssemblySymbol(this) 431352"];
1501 [label="param Symbol(this) 431353"];
1502 [label="_lazyISymbol 431354"];
1503 [label="_corLibrary 431355"];
1504 [label="new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 431356"];
1505 [label="_emittedNameToTypeMap =\n            new ConcurrentDictionary<MetadataTypeName.Key, NamedTypeSymbol>() 431357"];
1506 [label="_globalNamespace 431358"];
1507 [label="_lazySpecialTypes 431359"];
1508 [label="_cachedSpecialTypes 431360"];
1509 [label="_lazyNativeIntegerTypes 431361"];
1510 [label="_lazyTypeNames 431362"];
1511 [label="_lazyNamespaceNames 431363"];
1512 [label="_lazySpecialTypeMembers 431364"];
1513 [label="_assembliesToWhichInternalAccessHasBeenAnalyzed 431365"];
1514 [label="_compilation 431366"];
1515 [label="lazyAssemblyIdentity 431367"];
1516 [label="_assemblySimpleName 431368"];
1517 [label="_lazyStrongNameKeys 431369"];
1518 [label="_lazySourceAttributesBag 431370"];
1519 [label="_lazyNetModuleAttributesBag 431371"];
1520 [label="_lazyForwardedTypesFromSource 431372"];
1521 [label="_lazyOmittedAttributeIndices 431373"];
1522 [label="_lazyContainsExtensionMethods 431374"];
1523 [label="new ConcurrentDictionary<FieldSymbol, bool>() 431375"];
1524 [label="_unassignedFieldsMap = new ConcurrentDictionary<FieldSymbol, bool>() 431376"];
1525 [label="new ConcurrentSet<FieldSymbol>() 431377"];
1526 [label="_unreadFields = new ConcurrentSet<FieldSymbol>() 431378"];
1527 [label="new ConcurrentSet<TypeSymbol>() 431379"];
1528 [label="TypesReferencedInExternalMethods = new ConcurrentSet<TypeSymbol>() 431380"];
1529 [label="_optimisticallyGrantedInternalsAccess 431381"];
1530 [label="_lazyInternalsVisibleToMap 431382"];
1531 [label="Debug.Assert(compilation != null); 431383"];
1532 [label="Debug.Assert(compilation != null); 431384"];
1533 [label="Debug.Assert(assemblySimpleName != null); 431385"];
1534 [label="Debug.Assert(assemblySimpleName != null); 431386"];
1535 [label="Debug.Assert(!String.IsNullOrWhiteSpace(moduleName)); 431387"];
1536 [label="Debug.Assert(!netModules.IsDefault); 431388"];
1537 [label="_compilation 431389"];
1538 [label="_assemblySimpleName 431390"];
1539 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 431391"];
1540 [label="ArrayBuilder<ModuleSymbol> moduleBuilder = new ArrayBuilder<ModuleSymbol>(1 + netModules.Length); 431392"];
1541 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 431393"];
1542 [label="compilation.Declarations 431394"];
1543 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 431395"];
1544 [label="return _syntaxAndDeclarations.GetLazyState().DeclarationTable; 431396"];
1545 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 431397"];
1546 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 431398"];
1547 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 431399"];
1548 [label="new SourceModuleSymbol(this, compilation.Declarations, moduleName) 431400"];
1549 [label="param SourceModuleSymbol(SourceAssemblySymbol assemblySymbol) 431401"];
1550 [label="param SourceModuleSymbol(DeclarationTable declarations) 431402"];
1551 [label="param SourceModuleSymbol(string moduleName) 431403"];
1552 [label="param SourceModuleSymbol(this) 431404"];
1553 [label="param SourceModuleSymbol(this) 431405"];
1554 [label="param NonMissingModuleSymbol(this) 431406"];
1555 [label="param NonMissingModuleSymbol(this) 431407"];
1556 [label="param ModuleSymbol(this) 431408"];
1557 [label="param ModuleSymbol(this) 431409"];
1558 [label="param Symbol(this) 431410"];
1559 [label="_lazyISymbol 431411"];
1560 [label="_moduleReferences 431412"];
1561 [label="_assemblySymbol 431413"];
1562 [label="_lazyContainsExplicitDefinitionOfNoPiaLocalTypes = ThreeState.Unknown 431414"];
1563 [label="_sources 431415"];
1564 [label="_lazyCustomAttributesBag 431416"];
1565 [label="_globalNamespace 431417"];
1566 [label="_hasBadAttributes 431418"];
1567 [label="_name 431419"];
1568 [label="Debug.Assert((object)assemblySymbol != null); 431420"];
1569 [label="Debug.Assert((object)assemblySymbol != null); 431421"];
1570 [label="_assemblySymbol 431422"];
1571 [label="_sources 431423"];
1572 [label="_name 431424"];
1573 [label="moduleBuilder.Add(new SourceModuleSymbol(this, compilation.Declarations, moduleName)); 431425"];
1574 [label="compilation.Options 431426"];
1575 [label="get\n            {\n                return _options;\n            } 431427"];
1576 [label="return _options; 431428"];
1577 [label="var importOptions = (compilation.Options.MetadataImportOptions == MetadataImportOptions.All) ?\n                MetadataImportOptions.All : MetadataImportOptions.Internal; 431429"];
1578 [label="(compilation.Options.MetadataImportOptions == MetadataImportOptions.All) 431430"];
1579 [label="foreach (PEModule netModule in netModules)\n            {\n                moduleBuilder.Add(new PEModuleSymbol(this, netModule, importOptions, moduleBuilder.Count));\n                // SetReferences will be called later by the ReferenceManager (in CreateSourceAssemblyFullBind for \n                // a fresh manager, in CreateSourceAssemblyReuseData for a reused one).\n            } 431431"];
1580 [label="_modules = moduleBuilder.ToImmutableAndFree(); 431432"];
1581 [label="_modules 431433"];
1582 [label="compilation.Options 431434"];
1583 [label="get\n            {\n                return _options;\n            } 431435"];
1584 [label="return _options; 431436"];
1585 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 431437"];
1586 [label="if (!compilation.Options.CryptoPublicKey.IsEmpty)\n            {\n                // Private key is not necessary for assembly identity, only when emitting.  For this reason, the private key can remain null.\n                _lazyStrongNameKeys = StrongNameKeys.Create(compilation.Options.CryptoPublicKey, privateKey: null, hasCounterSignature: false, MessageProvider.Instance);\n            } 431438"];
1587 [label="AssemblySymbol? corLibrary; 431439"];
1588 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 431440"];
1589 [label="if (corLibraryIndex == 0)\n                    {\n                        corLibrary = assemblySymbol;\n                    }\n                    else if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 431441"];
1590 [label="if (corLibraryIndex > 0)\n                    {\n                        corLibrary = bindingResult[corLibraryIndex].AssemblySymbol;\n                    }\n                    else\n                    {\n                        corLibrary = MissingCorLibrarySymbol.Instance;\n                    } 431442"];
1591 [label="corLibrary = bindingResult[corLibraryIndex].AssemblySymbol; 431443"];
1592 [label="assemblySymbol.SetCorLibrary(corLibrary); 431444"];
1593 [label="assemblySymbol.SetCorLibrary(corLibrary) 431445"];
1594 [label="param SetCorLibrary(AssemblySymbol corLibrary) 431446"];
1595 [label="param SetCorLibrary(this) 431447"];
1596 [label="Debug.Assert((object)_corLibrary == null); 431448"];
1597 [label="Debug.Assert((object)_corLibrary == null); 431449"];
1598 [label="_corLibrary 431450"];
1599 [label="assemblySymbol.SetCorLibrary(corLibrary); 431451"];
1600 [label="Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies = null; 431452"];
1601 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 431453"];
1602 [label="int totalReferencedAssemblyCount = allAssemblyData.Length - 1; 431454"];
1603 [label="ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences; 431455"];
1604 [label="moduleReferences 431456"];
1605 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431457"];
1606 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431458"];
1607 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431459"];
1608 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431460"];
1609 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431461"];
1610 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431462"];
1611 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences) 431463"];
1612 [label="param SetupReferencesForSourceAssembly(SourceAssemblySymbol sourceAssembly) 431464"];
1613 [label="param SetupReferencesForSourceAssembly(ImmutableArray<PEModule> modules) 431465"];
1614 [label="param SetupReferencesForSourceAssembly(int totalReferencedAssemblyCount) 431466"];
1615 [label="param SetupReferencesForSourceAssembly(BoundInputAssembly[] bindingResult) 431467"];
1616 [label="param SetupReferencesForSourceAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 431468"];
1617 [label="param SetupReferencesForSourceAssembly(out ImmutableArray<ModuleReferences<AssemblySymbol>> moduleReferences) 431469"];
1618 [label="sourceAssembly.Modules 431470"];
1619 [label="get\n            {\n                return _modules;\n            } 431471"];
1620 [label="return _modules; 431472"];
1621 [label="var moduleSymbols = sourceAssembly.Modules; 431473"];
1622 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 431474"];
1623 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 431475"];
1624 [label="Debug.Assert(moduleSymbols.Length == 1 + modules.Length); 431476"];
1625 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 431477"];
1626 [label="var moduleReferencesBuilder = (moduleSymbols.Length > 1) ? ArrayBuilder<ModuleReferences<AssemblySymbol>>.GetInstance() : null; 431478"];
1627 [label="(moduleSymbols.Length > 1) 431479"];
1628 [label="int refsUsed = 0; 431480"];
1629 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 431481"];
1630 [label="for (int moduleIndex = 0; moduleIndex < moduleSymbols.Length; moduleIndex++)\n                {\n                    int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length;\n\n                    var identities = new AssemblyIdentity[refsCount];\n                    var symbols = new AssemblySymbol[refsCount];\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n\n                    for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    }\n\n                    var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty());\n\n                    if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    }\n\n                    moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly);\n\n                    refsUsed += refsCount;\n                } 431482"];
1631 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 431483"];
1632 [label="(moduleIndex == 0) 431484"];
1633 [label="int refsCount = (moduleIndex == 0) ? totalReferencedAssemblyCount : modules[moduleIndex - 1].ReferencedAssemblies.Length; 431485"];
1634 [label="var identities = new AssemblyIdentity[refsCount]; 431486"];
1635 [label="var symbols = new AssemblySymbol[refsCount]; 431487"];
1636 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 431488"];
1637 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 431489"];
1638 [label="for (int k = 0; k < refsCount; k++)\n                    {\n                        Debug.Assert(bindingResult[0].ReferenceBinding is object);\n                        var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k];\n                        Debug.Assert(boundReference.ReferenceIdentity is object);\n\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        }\n\n                        identities[k] = boundReference.ReferenceIdentity;\n                    } 431490"];
1639 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 431491"];
1640 [label="Debug.Assert(bindingResult[0].ReferenceBinding is object); 431492"];
1641 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431493"];
1642 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431494"];
1643 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431495"];
1644 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431496"];
1645 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 431497"];
1646 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 431498"];
1647 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431499"];
1648 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431500"];
1649 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431501"];
1650 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 431502"];
1651 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 431503"];
1652 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 431504"];
1653 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 431505"];
1654 [label="Debug.Assert(referenceBinding.IsBound); 431506"];
1655 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 431507"];
1656 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 431508"];
1657 [label="Debug.Assert(assembly is object); 431509"];
1658 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431510"];
1659 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431511"];
1660 [label="return assembly; 431512"];
1661 [label="symbols[k] 431513"];
1662 [label="identities[k] 431514"];
1663 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431515"];
1664 [label="var boundReference = bindingResult[0].ReferenceBinding![refsUsed + k]; 431516"];
1665 [label="Debug.Assert(boundReference.ReferenceIdentity is object); 431517"];
1666 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(boundReference.ReferenceIdentity, ref missingAssemblies);\n                        } 431518"];
1667 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431519"];
1668 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431520"];
1669 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 431521"];
1670 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 431522"];
1671 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 431523"];
1672 [label="Debug.Assert(referenceBinding.IsBound); 431524"];
1673 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 431525"];
1674 [label="var assembly = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol; 431526"];
1675 [label="Debug.Assert(assembly is object); 431527"];
1676 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431528"];
1677 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431529"];
1678 [label="return assembly; 431530"];
1679 [label="symbols[k] 431531"];
1680 [label="identities[k] 431532"];
1681 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431533"];
1682 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431534"];
1683 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431535"];
1684 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431536"];
1685 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431537"];
1686 [label="var references = new ModuleReferences<AssemblySymbol>(\n                        identities.AsImmutableOrNull(),\n                        symbols.AsImmutableOrNull(),\n                        unifiedAssemblies.AsImmutableOrEmpty()); 431538"];
1687 [label="if (moduleIndex > 0)\n                    {\n                        moduleReferencesBuilder!.Add(references);\n                    } 431539"];
1688 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 431540"];
1689 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 431541"];
1690 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 431542"];
1691 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly) 431543"];
1692 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 431544"];
1693 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 431545"];
1694 [label="param SetReferences(this) 431546"];
1695 [label="Debug.Assert(moduleReferences != null); 431547"];
1696 [label="Debug.Assert(moduleReferences != null); 431548"];
1697 [label="AssertReferencesUninitialized() 431549"];
1698 [label="param AssertReferencesUninitialized(this) 431550"];
1699 [label="Debug.Assert(_moduleReferences == null); 431551"];
1700 [label="Debug.Assert(_moduleReferences == null); 431552"];
1701 [label="AssertReferencesUninitialized(); 431553"];
1702 [label="_moduleReferences 431554"];
1703 [label="moduleSymbols[moduleIndex].SetReferences(references, sourceAssembly); 431555"];
1704 [label="refsUsed += refsCount; 431556"];
1705 [label="moduleReferences = moduleReferencesBuilder.ToImmutableOrEmptyAndFree(); 431557"];
1706 [label="SetupReferencesForSourceAssembly(\n                        assemblySymbol,\n                        modules,\n                        totalReferencedAssemblyCount,\n                        bindingResult,\n                        ref missingAssemblies,\n                        out moduleReferences); 431558"];
1707 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 431559"];
1708 [label="if (newSymbols.Count > 0)\n                    {\n                        // Only if we detected that a referenced assembly refers to the assembly being built\n                        // we allow the references to get a hold of the assembly being built.\n                        if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        }\n\n                        InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies);\n                    } 431560"];
1709 [label="if (hasCircularReference)\n                        {\n                            bindingResult[0].AssemblySymbol = assemblySymbol;\n                        } 431561"];
1710 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 431562"];
1711 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 431563"];
1712 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 431564"];
1713 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 431565"];
1714 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies) 431566"];
1715 [label="param InitializeNewSymbols(List<int> newSymbols) 431567"];
1716 [label="param InitializeNewSymbols(SourceAssemblySymbol sourceAssembly) 431568"];
1717 [label="param InitializeNewSymbols(ImmutableArray<AssemblyData> assemblies) 431569"];
1718 [label="param InitializeNewSymbols(BoundInputAssembly[] bindingResult) 431570"];
1719 [label="param InitializeNewSymbols(Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 431571"];
1720 [label="Debug.Assert(newSymbols.Count > 0); 431572"];
1721 [label="Debug.Assert(newSymbols.Count > 0); 431573"];
1722 [label="sourceAssembly.CorLibrary 431574"];
1723 [label="get\n            {\n                return _corLibrary;\n            } 431575"];
1724 [label="return _corLibrary; 431576"];
1725 [label="var corLibrary = sourceAssembly.CorLibrary; 431577"];
1726 [label="RoslynDebug.Assert((object)corLibrary != null); 431578"];
1727 [label="RoslynDebug.Assert((object)corLibrary != null); 431579"];
1728 [label="foreach (int i in newSymbols)\n                {\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n\n                    if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                } 431580"];
1729 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 431581"];
1730 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 431582"];
1731 [label="if (compilationData != null)\n                    {\n                        SetupReferencesForRetargetingAssembly(bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly);\n                    } 431583"];
1732 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 431584"];
1733 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431585"];
1734 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431586"];
1735 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431587"];
1736 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431588"];
1737 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431589"];
1738 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly) 431590"];
1739 [label="param SetupReferencesForFileAssembly(AssemblyDataForFile fileData) 431591"];
1740 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 431592"];
1741 [label="param SetupReferencesForFileAssembly(ref BoundInputAssembly currentBindingResult) 431593"];
1742 [label="param SetupReferencesForFileAssembly(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 431594"];
1743 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 431595"];
1744 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431596"];
1745 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431597"];
1746 [label="var portableExecutableAssemblySymbol = (PEAssemblySymbol)currentBindingResult.AssemblySymbol; 431598"];
1747 [label="portableExecutableAssemblySymbol.Modules 431599"];
1748 [label="get\n            {\n                return _modules;\n            } 431600"];
1749 [label="return _modules; 431601"];
1750 [label="ImmutableArray<ModuleSymbol> modules = portableExecutableAssemblySymbol.Modules; 431602"];
1751 [label="int moduleCount = modules.Length; 431603"];
1752 [label="int refsUsed = 0; 431604"];
1753 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 431605"];
1754 [label="for (int j = 0; j < moduleCount; j++)\n                {\n                    int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j];\n                    var identities = new AssemblyIdentity[moduleReferenceCount];\n                    var symbols = new AssemblySymbol[moduleReferenceCount];\n\n                    fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount);\n\n                    ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null;\n                    for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    }\n\n                    var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty());\n                    modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly);\n\n                    refsUsed += moduleReferenceCount;\n                } 431606"];
1755 [label="int moduleReferenceCount = fileData.Assembly.ModuleReferenceCounts[j]; 431607"];
1756 [label="var identities = new AssemblyIdentity[moduleReferenceCount]; 431608"];
1757 [label="var symbols = new AssemblySymbol[moduleReferenceCount]; 431609"];
1758 [label="fileData.AssemblyReferences 431610"];
1759 [label="get\n                    {\n                        return _referencedAssemblies;\n                    } 431611"];
1760 [label="return _referencedAssemblies; 431612"];
1761 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431613"];
1762 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431614"];
1763 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431615"];
1764 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431616"];
1765 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431617"];
1766 [label="fileData.AssemblyReferences.CopyTo(refsUsed, identities, 0, moduleReferenceCount); 431618"];
1767 [label="ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies = null; 431619"];
1768 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 431620"];
1769 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 431621"];
1770 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431622"];
1771 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431623"];
1772 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431624"];
1773 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431625"];
1774 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431626"];
1775 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 431627"];
1776 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 431628"];
1777 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 431629"];
1778 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly) 431630"];
1779 [label="param SetReferences(ModuleReferences<AssemblySymbol> moduleReferences) 431631"];
1780 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 431632"];
1781 [label="param SetReferences(this) 431633"];
1782 [label="Debug.Assert(moduleReferences != null); 431634"];
1783 [label="Debug.Assert(moduleReferences != null); 431635"];
1784 [label="AssertReferencesUninitialized() 431636"];
1785 [label="param AssertReferencesUninitialized(this) 431637"];
1786 [label="Debug.Assert(_moduleReferences == null); 431638"];
1787 [label="Debug.Assert(_moduleReferences == null); 431639"];
1788 [label="AssertReferencesUninitialized(); 431640"];
1789 [label="modules[j].SetReferences(moduleReferences, sourceAssemblyDebugOnly); 431641"];
1790 [label="refsUsed += moduleReferenceCount; 431642"];
1791 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431643"];
1792 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431644"];
1793 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431645"];
1794 [label="param SetupReferencesForFileAssembly(BoundInputAssembly[] bindingResult) 431646"];
1795 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 431647"];
1796 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431648"];
1797 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431649"];
1798 [label="for (int k = 0; k < moduleReferenceCount; k++)\n                    {\n                        var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k];\n                        if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        }\n                    } 431650"];
1799 [label="var boundReference = currentBindingResult.ReferenceBinding[refsUsed + k]; 431651"];
1800 [label="if (boundReference.IsBound)\n                        {\n                            symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies);\n                        }\n                        else\n                        {\n                            symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies);\n                        } 431652"];
1801 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431653"];
1802 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431654"];
1803 [label="symbols[k] = GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies); 431655"];
1804 [label="GetAssemblyDefinitionSymbol(bindingResult, boundReference, ref unifiedAssemblies) 431656"];
1805 [label="param GetAssemblyDefinitionSymbol(BoundInputAssembly[] bindingResult) 431657"];
1806 [label="param GetAssemblyDefinitionSymbol(AssemblyReferenceBinding referenceBinding) 431658"];
1807 [label="param GetAssemblyDefinitionSymbol(ref ArrayBuilder<UnifiedAssembly<AssemblySymbol>>? unifiedAssemblies) 431659"];
1808 [label="Debug.Assert(referenceBinding.IsBound); 431660"];
1809 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 431661"];
1810 [label="Debug.Assert(assembly is object); 431662"];
1811 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431663"];
1812 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431664"];
1813 [label="symbols[k] 431665"];
1814 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 431666"];
1815 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 431667"];
1816 [label="GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies) 431668"];
1817 [label="param GetOrAddMissingAssemblySymbol(AssemblyIdentity assemblyIdentity) 431669"];
1818 [label="param GetOrAddMissingAssemblySymbol(ref Dictionary<AssemblyIdentity, MissingAssemblySymbol>? missingAssemblies) 431670"];
1819 [label="MissingAssemblySymbol? missingAssembly; 431671"];
1820 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 431672"];
1821 [label="if (missingAssemblies == null)\n                {\n                    missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>();\n                }\n                else if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 431673"];
1822 [label="missingAssemblies = new Dictionary<AssemblyIdentity, MissingAssemblySymbol>(); 431674"];
1823 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 431675"];
1824 [label="missingAssembly = new MissingAssemblySymbol(assemblyIdentity); 431676"];
1825 [label="new MissingAssemblySymbol(assemblyIdentity) 431677"];
1826 [label="param MissingAssemblySymbol(AssemblyIdentity identity) 431678"];
1827 [label="param MissingAssemblySymbol(this) 431679"];
1828 [label="param MissingAssemblySymbol(this) 431680"];
1829 [label="identity 431681"];
1830 [label="moduleSymbol 431682"];
1831 [label="Debug.Assert(identity != null); 431683"];
1832 [label="Debug.Assert(identity != null); 431684"];
1833 [label="this.identity 431685"];
1834 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 431686"];
1835 [label="moduleSymbol = new MissingModuleSymbol(this, 0); 431687"];
1836 [label="new MissingModuleSymbol(this, 0) 431688"];
1837 [label="param MissingModuleSymbol(AssemblySymbol assembly) 431689"];
1838 [label="param MissingModuleSymbol(int ordinal) 431690"];
1839 [label="param MissingModuleSymbol(this) 431691"];
1840 [label="param MissingModuleSymbol(this) 431692"];
1841 [label="assembly 431693"];
1842 [label="ordinal 431694"];
1843 [label="globalNamespace 431695"];
1844 [label="Debug.Assert((object)assembly != null); 431696"];
1845 [label="Debug.Assert((object)assembly != null); 431697"];
1846 [label="Debug.Assert(ordinal >= -1); 431698"];
1847 [label="Debug.Assert(ordinal >= -1); 431699"];
1848 [label="this.assembly 431700"];
1849 [label="this.ordinal 431701"];
1850 [label="globalNamespace = new MissingNamespaceSymbol(this); 431702"];
1851 [label="globalNamespace = new MissingNamespaceSymbol(this); 431703"];
1852 [label="new MissingNamespaceSymbol(this) 431704"];
1853 [label="param MissingNamespaceSymbol(MissingModuleSymbol containingModule) 431705"];
1854 [label="param MissingNamespaceSymbol(this) 431706"];
1855 [label="param MissingNamespaceSymbol(this) 431707"];
1856 [label="_name 431708"];
1857 [label="_containingSymbol 431709"];
1858 [label="Debug.Assert((object)containingModule != null); 431710"];
1859 [label="Debug.Assert((object)containingModule != null); 431711"];
1860 [label="_containingSymbol 431712"];
1861 [label="_name 431713"];
1862 [label="globalNamespace 431714"];
1863 [label="moduleSymbol 431715"];
1864 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 431716"];
1865 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 431717"];
1866 [label="missingAssemblies.Add(assemblyIdentity, missingAssembly); 431718"];
1867 [label="return missingAssembly; 431719"];
1868 [label="symbols[k] = GetOrAddMissingAssemblySymbol(identities[k], ref missingAssemblies); 431720"];
1869 [label="symbols[k] 431721"];
1870 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 431722"];
1871 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 431723"];
1872 [label="if (missingAssemblies.TryGetValue(assemblyIdentity, out missingAssembly))\n                {\n                    return missingAssembly;\n                } 431724"];
1873 [label="identity 431725"];
1874 [label="moduleSymbol 431726"];
1875 [label="Debug.Assert(identity != null); 431727"];
1876 [label="assembly 431728"];
1877 [label="ordinal 431729"];
1878 [label="globalNamespace 431730"];
1879 [label="Debug.Assert((object)assembly != null); 431731"];
1880 [label="Debug.Assert(ordinal >= -1); 431732"];
1881 [label="_name 431733"];
1882 [label="_containingSymbol 431734"];
1883 [label="Debug.Assert((object)containingModule != null); 431735"];
1884 [label="return missingAssembly; 431736"];
1885 [label="symbols[k] 431737"];
1886 [label="var moduleReferences = new ModuleReferences<AssemblySymbol>(identities.AsImmutableOrNull(), symbols.AsImmutableOrNull(), unifiedAssemblies.AsImmutableOrEmpty()); 431738"];
1887 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 431739"];
1888 [label="Debug.Assert(moduleReferences != null); 431740"];
1889 [label="Debug.Assert(moduleReferences != null); 431741"];
1890 [label="AssertReferencesUninitialized() 431742"];
1891 [label="param AssertReferencesUninitialized(this) 431743"];
1892 [label="Debug.Assert(_moduleReferences == null); 431744"];
1893 [label="Debug.Assert(_moduleReferences == null); 431745"];
1894 [label="AssertReferencesUninitialized(); 431746"];
1895 [label="refsUsed += moduleReferenceCount; 431747"];
1896 [label="SetupReferencesForFileAssembly(fileData, bindingResult, ref bindingResult[i], ref missingAssemblies, sourceAssemblyDebugOnly: sourceAssembly); 431748"];
1897 [label="param SetupReferencesForFileAssembly(SourceAssemblySymbol sourceAssemblyDebugOnly) 431749"];
1898 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431750"];
1899 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431751"];
1900 [label="Debug.Assert(referenceBinding.IsBound); 431752"];
1901 [label="Debug.Assert(referenceBinding.ReferenceIdentity is object); 431753"];
1902 [label="Debug.Assert(assembly is object); 431754"];
1903 [label="if (referenceBinding.VersionDifference != 0)\n                {\n                    if (unifiedAssemblies == null)\n                    {\n                        unifiedAssemblies = new ArrayBuilder<UnifiedAssembly<AssemblySymbol>>();\n                    }\n\n                    unifiedAssemblies.Add(new UnifiedAssembly<AssemblySymbol>(assembly, referenceBinding.ReferenceIdentity));\n                } 431755"];
1904 [label="param SetReferences(SourceAssemblySymbol originatingSourceAssemblyDebugOnly = null) 431756"];
1905 [label="Debug.Assert(moduleReferences != null); 431757"];
1906 [label="AssertReferencesUninitialized() 431758"];
1907 [label="param AssertReferencesUninitialized(this) 431759"];
1908 [label="Debug.Assert(_moduleReferences == null); 431760"];
1909 [label="Debug.Assert(_moduleReferences == null); 431761"];
1910 [label="AssertReferencesUninitialized(); 431762"];
1911 [label="refsUsed += moduleReferenceCount; 431763"];
1912 [label="var linkedReferencedAssembliesBuilder = ArrayBuilder<AssemblySymbol>.GetInstance(); 431764"];
1913 [label="sourceAssembly.Modules 431765"];
1914 [label="get\n            {\n                return _modules;\n            } 431766"];
1915 [label="return _modules; 431767"];
1916 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 431768"];
1917 [label="var noPiaResolutionAssemblies = sourceAssembly.Modules[0].GetReferencedAssemblySymbols(); 431769"];
1918 [label="sourceAssembly.Modules[0].GetReferencedAssemblySymbols() 431770"];
1919 [label="param GetReferencedAssemblySymbols(this) 431771"];
1920 [label="AssertReferencesInitialized() 431772"];
1921 [label="param AssertReferencesInitialized(this) 431773"];
1922 [label="Debug.Assert(_moduleReferences != null); 431774"];
1923 [label="Debug.Assert(_moduleReferences != null); 431775"];
1924 [label="AssertReferencesInitialized(); 431776"];
1925 [label="return _moduleReferences.Symbols; 431777"];
1926 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly currentBindingResult = ref bindingResult[i];\n                    Debug.Assert(currentBindingResult.AssemblySymbol is object);\n                    Debug.Assert(currentBindingResult.ReferenceBinding is object);\n\n                    if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    }\n\n                    // Setup linked referenced assemblies.\n                    linkedReferencedAssembliesBuilder.Clear();\n\n                    if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    }\n\n                    foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    }\n\n                    if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    }\n\n                    currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary);\n                } 431778"];
1927 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 431779"];
1928 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431780"];
1929 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431781"];
1930 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 431782"];
1931 [label="assemblies[i].ContainsNoPiaLocalTypes 431783"];
1932 [label="get\n                    {\n                        return Assembly.ContainsNoPiaLocalTypes();\n                    } 431784"];
1933 [label="linkedReferencedAssembliesBuilder.Clear(); 431785"];
1934 [label="if (assemblies[i].IsLinked)\n                    {\n                        linkedReferencedAssembliesBuilder.Add(currentBindingResult.AssemblySymbol);\n                    } 431786"];
1935 [label="assemblies[i].IsLinked 431787"];
1936 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431788"];
1937 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 431789"];
1938 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 431790"];
1939 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 431791"];
1940 [label="if (linkedReferencedAssembliesBuilder.Count > 0)\n                    {\n                        linkedReferencedAssembliesBuilder.RemoveDuplicates();\n                        currentBindingResult.AssemblySymbol.SetLinkedReferencedAssemblies(linkedReferencedAssembliesBuilder.ToImmutable());\n                    } 431792"];
1941 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 431793"];
1942 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary) 431794"];
1943 [label="param SetCorLibrary(AssemblySymbol corLibrary) 431795"];
1944 [label="param SetCorLibrary(this) 431796"];
1945 [label="Debug.Assert((object)_corLibrary == null); 431797"];
1946 [label="Debug.Assert((object)_corLibrary == null); 431798"];
1947 [label="_corLibrary 431799"];
1948 [label="currentBindingResult.AssemblySymbol.SetCorLibrary(corLibrary); 431800"];
1949 [label="ref BoundInputAssembly currentBindingResult = ref bindingResult[i]; 431801"];
1950 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431802"];
1951 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431803"];
1952 [label="if (assemblies[i].ContainsNoPiaLocalTypes)\n                    {\n                        currentBindingResult.AssemblySymbol.SetNoPiaResolutionAssemblies(noPiaResolutionAssemblies);\n                    } 431804"];
1953 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431805"];
1954 [label="foreach (var referenceBinding in currentBindingResult.ReferenceBinding)\n                    {\n                        if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        }\n                    } 431806"];
1955 [label="if (referenceBinding.IsBound &&\n                            assemblies[referenceBinding.DefinitionIndex].IsLinked)\n                        {\n                            var linkedAssemblySymbol = bindingResult[referenceBinding.DefinitionIndex].AssemblySymbol;\n                            Debug.Assert(linkedAssemblySymbol is object);\n                            linkedReferencedAssembliesBuilder.Add(linkedAssemblySymbol);\n                        } 431807"];
1956 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 431808"];
1957 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431809"];
1958 [label="Debug.Assert((object)_corLibrary == null); 431810"];
1959 [label="Debug.Assert(currentBindingResult.AssemblySymbol is object); 431811"];
1960 [label="Debug.Assert(currentBindingResult.ReferenceBinding is object); 431812"];
1961 [label="get\n                    {\n                        return _embedInteropTypes;\n                    } 431813"];
1962 [label="assemblies[referenceBinding.DefinitionIndex].IsLinked 431814"];
1963 [label="Debug.Assert((object)_corLibrary == null); 431815"];
1964 [label="linkedReferencedAssembliesBuilder.Free(); 431816"];
1965 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 431817"];
1966 [label="if (missingAssemblies != null)\n                {\n                    foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    }\n                } 431818"];
1967 [label="foreach (var missingAssembly in missingAssemblies.Values)\n                    {\n                        missingAssembly.SetCorLibrary(corLibrary);\n                    } 431819"];
1968 [label="missingAssembly.SetCorLibrary(corLibrary); 431820"];
1969 [label="missingAssembly.SetCorLibrary(corLibrary) 431821"];
1970 [label="param SetCorLibrary(AssemblySymbol corLibrary) 431822"];
1971 [label="Debug.Assert((object)_corLibrary == null); 431823"];
1972 [label="missingAssembly.SetCorLibrary(corLibrary); 431824"];
1973 [label="Debug.Assert((object)_corLibrary == null); 431825"];
1974 [label="InitializeNewSymbols(newSymbols, assemblySymbol, allAssemblyData, bindingResult, missingAssemblies); 431826"];
1975 [label="if (compilation._lazyAssemblySymbol is null)\n                    {\n                        lock (SymbolCacheAndReferenceManagerStateGuard)\n                        {\n                            if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            }\n                        }\n                    } 431827"];
1976 [label="if (compilation._lazyAssemblySymbol is null)\n                            {\n                                if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                }\n\n                                UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult);\n\n                                InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies());\n\n                                // Make sure that the given compilation holds on this instance of reference manager.\n                                Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference);\n                                compilation._referenceManager = this;\n\n                                // Finally, publish the source symbol after all data have been written.\n                                // Once lazyAssemblySymbol is non-null other readers might start reading the data written above.\n                                compilation._lazyAssemblySymbol = assemblySymbol;\n                            } 431828"];
1977 [label="if (IsBound)\n                                {\n                                    // Another thread has finished constructing AssemblySymbol for another compilation that shares this manager.\n                                    // Drop the results and reuse the symbols that were created for the other compilation.\n                                    return false;\n                                } 431829"];
1978 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 431830"];
1979 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 431831"];
1980 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult) 431832"];
1981 [label="param UpdateSymbolCacheNoLock(List<int> newSymbols) 431833"];
1982 [label="param UpdateSymbolCacheNoLock(ImmutableArray<AssemblyData> assemblies) 431834"];
1983 [label="param UpdateSymbolCacheNoLock(BoundInputAssembly[] bindingResult) 431835"];
1984 [label="foreach (int i in newSymbols)\n                {\n                    ref BoundInputAssembly current = ref bindingResult[i];\n                    Debug.Assert(current.AssemblySymbol is object);\n\n                    var compilationData = assemblies[i] as AssemblyDataForCompilation;\n                    if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    }\n                } 431836"];
1985 [label="ref BoundInputAssembly current = ref bindingResult[i]; 431837"];
1986 [label="Debug.Assert(current.AssemblySymbol is object); 431838"];
1987 [label="var compilationData = assemblies[i] as AssemblyDataForCompilation; 431839"];
1988 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 431840"];
1989 [label="if (compilationData != null)\n                    {\n                        compilationData.Compilation.CacheRetargetingAssemblySymbolNoLock(current.AssemblySymbol);\n                    }\n                    else\n                    {\n                        var fileData = (AssemblyDataForFile)assemblies[i];\n                        fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol);\n                    } 431841"];
1990 [label="var fileData = (AssemblyDataForFile)assemblies[i]; 431842"];
1991 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 431843"];
1992 [label="fileData.CachedSymbols.Add((PEAssemblySymbol)current.AssemblySymbol); 431844"];
1993 [label="Debug.Assert(current.AssemblySymbol is object); 431845"];
1994 [label="UpdateSymbolCacheNoLock(newSymbols, allAssemblyData, bindingResult); 431846"];
1995 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431847"];
1996 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431848"];
1997 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431849"];
1998 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431850"];
1999 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431851"];
2000 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431852"];
2001 [label="ReferenceEquals(corLibrary, assemblySymbol) 431853"];
2002 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431854"];
2003 [label="assemblySymbol.SourceModule 431855"];
2004 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 431856"];
2005 [label="this.Modules 431857"];
2006 [label="get\n            {\n                return _modules;\n            } 431858"];
2007 [label="return _modules; 431859"];
2008 [label="return (SourceModuleSymbol)this.Modules[0]; 431860"];
2009 [label="return (SourceModuleSymbol)this.Modules[0]; 431861"];
2010 [label="assemblySymbol.SourceModule.GetReferencedAssemblySymbols() 431862"];
2011 [label="param GetReferencedAssemblySymbols(this) 431863"];
2012 [label="AssertReferencesInitialized() 431864"];
2013 [label="param AssertReferencesInitialized(this) 431865"];
2014 [label="Debug.Assert(_moduleReferences != null); 431866"];
2015 [label="Debug.Assert(_moduleReferences != null); 431867"];
2016 [label="AssertReferencesInitialized(); 431868"];
2017 [label="return _moduleReferences.Symbols; 431869"];
2018 [label="assemblySymbol.SourceModule 431870"];
2019 [label="get { return (SourceModuleSymbol)this.Modules[0]; } 431871"];
2020 [label="this.Modules 431872"];
2021 [label="get\n            {\n                return _modules;\n            } 431873"];
2022 [label="return _modules; 431874"];
2023 [label="return (SourceModuleSymbol)this.Modules[0]; 431875"];
2024 [label="assemblySymbol.SourceModule.GetUnifiedAssemblies() 431876"];
2025 [label="param GetUnifiedAssemblies(this) 431877"];
2026 [label="AssertReferencesInitialized() 431878"];
2027 [label="param AssertReferencesInitialized(this) 431879"];
2028 [label="Debug.Assert(_moduleReferences != null); 431880"];
2029 [label="Debug.Assert(_moduleReferences != null); 431881"];
2030 [label="AssertReferencesInitialized(); 431882"];
2031 [label="return _moduleReferences.UnifiedAssemblies; 431883"];
2032 [label="InitializeNoLock(\n                                    referencedAssembliesMap,\n                                    referencedModulesMap,\n                                    boundReferenceDirectiveMap,\n                                    boundReferenceDirectives,\n                                    explicitReferences,\n                                    implicitReferenceResolutions,\n                                    hasCircularReference,\n                                    resolutionDiagnostics.ToReadOnly(),\n                                    ReferenceEquals(corLibrary, assemblySymbol) ? null! : corLibrary, // https://github.com/dotnet/roslyn/issues/40751 Unnecessary suppression\n                                    modules,\n                                    moduleReferences,\n                                    assemblySymbol.SourceModule.GetReferencedAssemblySymbols(),\n                                    aliasesOfReferencedAssemblies,\n                                    assemblySymbol.SourceModule.GetUnifiedAssemblies()); 431884"];
2033 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 431885"];
2034 [label="Debug.Assert(ReferenceEquals(compilation._referenceManager, this) || HasCircularReference); 431886"];
2035 [label="compilation._referenceManager 431887"];
2036 [label="compilation._lazyAssemblySymbol 431888"];
2037 [label="return true; 431889"];
2038 [label="resolutionDiagnostics.Free(); 431890"];
2039 [label="assemblyReferencesBySimpleName.Free(); 431891"];
2040 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 431892"];
2041 [label="if (!IsBound && CreateAndSetSourceAssemblyFullBind(compilation))\n                {\n                    // we have successfully bound the references for the compilation\n                }\n                else if (!HasCircularReference)\n                {\n                    // Another compilation that shares the manager with the given compilation\n                    // already bound its references and produced tables that we can use to construct \n                    // source assembly symbol faster. Unless we encountered a circular reference.\n                    CreateAndSetSourceAssemblyReuseData(compilation);\n                }\n                else\n                {\n                    // We encountered a circular reference while binding the previous compilation.\n                    // This compilation can't share bound references with other compilations. Create a new manager.\n\n                    // NOTE: The CreateSourceAssemblyFullBind is going to replace compilation's reference manager with newManager.\n\n                    var newManager = new ReferenceManager(this.SimpleAssemblyName, this.IdentityComparer, this.ObservedMetadata);\n                    var successful = newManager.CreateAndSetSourceAssemblyFullBind(compilation);\n\n                    // The new manager isn't shared with any other compilation so there is no other \n                    // thread but the current one could have initialized it.\n                    Debug.Assert(successful);\n\n                    newManager.AssertBound();\n                } 431893"];
2042 [label="AssertBound(); 431894"];
2043 [label="Debug.Assert(compilation._lazyAssemblySymbol is object); 431895"];
2044 [label="_referenceManager.CreateSourceAssemblyForCompilation(this); 431896"];
2045 [label="Debug.Assert(_lazyAssemblySymbol is object); 431897"];
2046 [label="return _referenceManager; 431898"];
2047 [label="builder.AddRange(GetBoundReferenceManager().Diagnostics); 431899"];
2048 [label="cancellationToken.ThrowIfCancellationRequested(); 431900"];
2049 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 431901"];
2050 [label="builder.AddRange(GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken)); 431902"];
2051 [label="GetSourceDeclarationDiagnostics(cancellationToken: cancellationToken) 431903"];
2052 [label="param GetSourceDeclarationDiagnostics(SyntaxTree? syntaxTree = null) 431904"];
2053 [label="param GetSourceDeclarationDiagnostics(TextSpan? filterSpanWithinTree = null) 431905"];
2054 [label="param GetSourceDeclarationDiagnostics(Func<IEnumerable<Diagnostic>, SyntaxTree, TextSpan?, IEnumerable<Diagnostic>>? locationFilterOpt = null) 431906"];
2055 [label="param GetSourceDeclarationDiagnostics(CancellationToken cancellationToken = default) 431907"];
2056 [label="param GetSourceDeclarationDiagnostics(this) 431908"];
2057 [label="GlobalImports 431909"];
2058 [label="=> _globalImports.Value 431910"];
2059 [label="_globalImports.Value 431911"];
2060 [label="_globalImports.Value 431912"];
2061 [label="=> Imports.FromGlobalUsings(this) 431913"];
2062 [label="null 431914"];
2063 [label="ImmutableDictionary<string, AliasAndUsingDirective>.Empty 431915"];
2064 [label="ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty 431916"];
2065 [label="ImmutableArray<AliasAndExternAliasDirective>.Empty 431917"];
2066 [label="null 431918"];
2067 [label="new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 431919"];
2068 [label="param Imports(CSharpCompilation compilation) 431920"];
2069 [label="param Imports(ImmutableDictionary<string, AliasAndUsingDirective> usingAliases) 431921"];
2070 [label="param Imports(ImmutableArray<NamespaceOrTypeAndUsingDirective> usings) 431922"];
2071 [label="param Imports(ImmutableArray<AliasAndExternAliasDirective> externs) 431923"];
2072 [label="param Imports(DiagnosticBag diagnostics) 431924"];
2073 [label="param Imports(this) 431925"];
2074 [label="_compilation 431926"];
2075 [label="_diagnostics 431927"];
2076 [label="UsingAliases 431928"];
2077 [label="Debug.Assert(usingAliases != null); 431929"];
2078 [label="Debug.Assert(usingAliases != null); 431930"];
2079 [label="Debug.Assert(!usings.IsDefault); 431931"];
2080 [label="Debug.Assert(!externs.IsDefault); 431932"];
2081 [label="_compilation 431933"];
2082 [label="this.UsingAliases 431934"];
2083 [label="this.Usings 431935"];
2084 [label="_diagnostics 431936"];
2085 [label="this.ExternAliases 431937"];
2086 [label="Empty = new Imports(\n            null,\n            ImmutableDictionary<string, AliasAndUsingDirective>.Empty,\n            ImmutableArray<NamespaceOrTypeAndUsingDirective>.Empty,\n            ImmutableArray<AliasAndExternAliasDirective>.Empty,\n            null) 431938"];
2087 [label="this 431939"];
2088 [label="Imports.FromGlobalUsings(this) 431940"];
2089 [label="param FromGlobalUsings(CSharpCompilation compilation) 431941"];
2090 [label="compilation.Options 431942"];
2091 [label="get\n            {\n                return _options;\n            } 431943"];
2092 [label="var usings = compilation.Options.Usings; 431944"];
2093 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 431945"];
2094 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 431946"];
2095 [label="compilation.PreviousSubmission 431947"];
2096 [label="=> ScriptCompilationInfo?.PreviousScriptCompilation 431948"];
2097 [label="ScriptCompilationInfo 431949"];
2098 [label="ScriptCompilationInfo?.PreviousScriptCompilation 431950"];
2099 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 431951"];
2100 [label="if (usings.Length == 0 && compilation.PreviousSubmission == null)\n            {\n                return Empty;\n            } 431952"];
2101 [label="return Empty; 431953"];
2102 [label="_globalImports.Value 431954"];
2103 [label="GlobalImports.Complete(cancellationToken); 431955"];
2104 [label="GlobalImports.Complete(cancellationToken); 431956"];
2105 [label="GlobalImports.Complete(cancellationToken) 431957"];
2106 [label="param Complete(CancellationToken cancellationToken) 431958"];
2107 [label="param Complete(this) 431959"];
2108 [label="while (true)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                var incompletePart = _state.NextIncompletePart;\n                switch (incompletePart)\n                {\n                    case CompletionPart.StartValidatingImports:\n                        {\n                            if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            }\n                        }\n                        break;\n\n                    case CompletionPart.FinishValidatingImports:\n                        // some other thread has started validating imports (otherwise we would be in the case above) so\n                        // we just wait for it to both finish and report the diagnostics.\n                        Debug.Assert(_state.HasComplete(CompletionPart.StartValidatingImports));\n                        _state.SpinWaitComplete(CompletionPart.FinishValidatingImports, cancellationToken);\n                        break;\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // any other values are completion parts intended for other kinds of symbols\n                        _state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll);\n                        break;\n                }\n\n                _state.SpinWaitComplete(incompletePart, cancellationToken);\n            } 431960"];
2109 [label="cancellationToken.ThrowIfCancellationRequested(); 431961"];
2110 [label="_state.NextIncompletePart 431962"];
2111 [label="get\n            {\n                // NOTE: It's very important to store this value in a local.\n                // If we were to inline the field access, the value of the\n                // field could change between the two accesses and the formula\n                // might not produce a result with a single 1-bit.\n                int incomplete = IncompleteParts;\n                int next = incomplete & ~(incomplete - 1);\n                Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.');\n                return (CompletionPart)next;\n            } 431963"];
2112 [label="IncompleteParts 431964"];
2113 [label="get\n            {\n                return ~_completeParts & (int)CompletionPart.All;\n            } 431965"];
2114 [label="return ~_completeParts & (int)CompletionPart.All; 431966"];
2115 [label="int incomplete = IncompleteParts; 431967"];
2116 [label="int next = incomplete & ~(incomplete - 1); 431968"];
2117 [label="int next = incomplete & ~(incomplete - 1); 431969"];
2118 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 431970"];
2119 [label="HasAtMostOneBitSet(next) 431971"];
2120 [label="param HasAtMostOneBitSet(int bits) 431972"];
2121 [label="return (bits & (bits - 1)) == 0; 431973"];
2122 [label="return (bits & (bits - 1)) == 0; 431974"];
2123 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 431975"];
2124 [label="return (CompletionPart)next; 431976"];
2125 [label="var incompletePart = _state.NextIncompletePart; 431977"];
2126 [label="switch (incompletePart)\n                {\n                    case CompletionPart.StartValidatingImports:\n                        {\n                            if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            }\n                        }\n                        break;\n\n                    case CompletionPart.FinishValidatingImports:\n                        // some other thread has started validating imports (otherwise we would be in the case above) so\n                        // we just wait for it to both finish and report the diagnostics.\n                        Debug.Assert(_state.HasComplete(CompletionPart.StartValidatingImports));\n                        _state.SpinWaitComplete(CompletionPart.FinishValidatingImports, cancellationToken);\n                        break;\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // any other values are completion parts intended for other kinds of symbols\n                        _state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll);\n                        break;\n                } 431978"];
2127 [label="_state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll); 431979"];
2128 [label="_state.NotePartComplete(CompletionPart.All & ~CompletionPart.ImportsAll) 431980"];
2129 [label="param NotePartComplete(CompletionPart part) 431981"];
2130 [label="param NotePartComplete(this) 431982"];
2131 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 431983"];
2132 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 431984"];
2133 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 431985"];
2134 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 431986"];
2135 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 431987"];
2136 [label="_state.SpinWaitComplete(incompletePart, cancellationToken) 431988"];
2137 [label="param SpinWaitComplete(CompletionPart part) 431989"];
2138 [label="param SpinWaitComplete(CancellationToken cancellationToken) 431990"];
2139 [label="param SpinWaitComplete(this) 431991"];
2140 [label="if (HasComplete(part))\n            {\n                return;\n            } 431992"];
2141 [label="HasComplete(part) 431993"];
2142 [label="param HasComplete(CompletionPart part) 431994"];
2143 [label="param HasComplete(this) 431995"];
2144 [label="return (_completeParts & (int)part) == (int)part; 431996"];
2145 [label="return; 431997"];
2146 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 431998"];
2147 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 431999"];
2148 [label="param HasAtMostOneBitSet(int bits) 432000"];
2149 [label="return (bits & (bits - 1)) == 0; 432001"];
2150 [label="if (_state.NotePartComplete(CompletionPart.StartValidatingImports))\n                            {\n                                Validate();\n                                _state.NotePartComplete(CompletionPart.FinishValidatingImports);\n                            } 432002"];
2151 [label="_state.NotePartComplete(CompletionPart.StartValidatingImports) 432003"];
2152 [label="param NotePartComplete(CompletionPart part) 432004"];
2153 [label="Validate() 432005"];
2154 [label="param Validate(this) 432006"];
2155 [label="if (this == Empty)\n            {\n                return;\n            } 432007"];
2156 [label="return; 432008"];
2157 [label="Validate(); 432009"];
2158 [label="_state.NotePartComplete(CompletionPart.FinishValidatingImports); 432010"];
2159 [label="_state.NotePartComplete(CompletionPart.FinishValidatingImports) 432011"];
2160 [label="param NotePartComplete(CompletionPart part) 432012"];
2161 [label="_state.SpinWaitComplete(incompletePart, cancellationToken); 432013"];
2162 [label="param SpinWaitComplete(CompletionPart part) 432014"];
2163 [label="if (HasComplete(part))\n            {\n                return;\n            } 432015"];
2164 [label="param HasComplete(CompletionPart part) 432016"];
2165 [label="return (_completeParts & (int)part) == (int)part; 432017"];
2166 [label="return; 432018"];
2167 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 432019"];
2168 [label="param HasAtMostOneBitSet(int bits) 432020"];
2169 [label="return (bits & (bits - 1)) == 0; 432021"];
2170 [label="return; 432022"];
2171 [label="GlobalImports.Complete(cancellationToken); 432023"];
2172 [label="SourceLocation? location = null; 432024"];
2173 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 432025"];
2174 [label="if (syntaxTree != null)\n            {\n                var root = syntaxTree.GetRoot(cancellationToken);\n                location = filterSpanWithinTree.HasValue ?\n                    new SourceLocation(syntaxTree, filterSpanWithinTree.Value) :\n                    new SourceLocation(root);\n            } 432026"];
2175 [label="Assembly 432027"];
2176 [label="get\n            {\n                return SourceAssembly;\n            } 432028"];
2177 [label="SourceAssembly 432029"];
2178 [label="get\n            {\n                GetBoundReferenceManager();\n                RoslynDebug.Assert(_lazyAssemblySymbol is object);\n                return _lazyAssemblySymbol;\n            } 432030"];
2179 [label="GetBoundReferenceManager() 432031"];
2180 [label="param GetBoundReferenceManager(this) 432032"];
2181 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 432033"];
2182 [label="return _referenceManager; 432034"];
2183 [label="GetBoundReferenceManager(); 432035"];
2184 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 432036"];
2185 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 432037"];
2186 [label="return _lazyAssemblySymbol; 432038"];
2187 [label="return SourceAssembly; 432039"];
2188 [label="Assembly.ForceComplete(location, cancellationToken); 432040"];
2189 [label="Assembly.ForceComplete(location, cancellationToken); 432041"];
2190 [label="Assembly.ForceComplete(location, cancellationToken); 432042"];
2191 [label="Assembly.ForceComplete(location, cancellationToken); 432043"];
2192 [label="Assembly.ForceComplete(location, cancellationToken); 432044"];
2193 [label="IncompleteParts 432045"];
2194 [label="int next = incomplete & ~(incomplete - 1); 432046"];
2195 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 432047"];
2196 [label="HasAtMostOneBitSet(next) 432048"];
2197 [label="param HasAtMostOneBitSet(int bits) 432049"];
2198 [label="return (bits & (bits - 1)) == 0; 432050"];
2199 [label="return (bits & (bits - 1)) == 0; 432051"];
2200 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 432052"];
2201 [label="param EnsureAttributesAreBound(this) 432053"];
2202 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432054"];
2203 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432055"];
2204 [label="GetAttributeDeclarations() 432056"];
2205 [label="param GetAttributeDeclarations(this) 432057"];
2206 [label="var builder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance(); 432058"];
2207 [label="DeclaringCompilation 432059"];
2208 [label="get\n            {\n                return _compilation;\n            } 432060"];
2209 [label="return _compilation; 432061"];
2210 [label="var declarations = DeclaringCompilation.MergedRootDeclaration.Declarations; 432062"];
2211 [label="DeclaringCompilation.MergedRootDeclaration 432063"];
2212 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 432064"];
2213 [label="Declarations 432065"];
2214 [label="get\n            {\n                return _syntaxAndDeclarations.GetLazyState().DeclarationTable;\n            } 432066"];
2215 [label="return Declarations.GetMergedRoot(this); 432067"];
2216 [label="return Declarations.GetMergedRoot(this); 432068"];
2217 [label="return Declarations.GetMergedRoot(this); 432069"];
2218 [label="foreach (RootSingleNamespaceDeclaration rootNs in declarations)\n            {\n                if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                }\n            } 432070"];
2219 [label="if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                } 432071"];
2220 [label="return builder.ToImmutableAndFree(); 432072"];
2221 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432073"];
2222 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432074"];
2223 [label="LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag) 432075"];
2224 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 432076"];
2225 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 432077"];
2226 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 432078"];
2227 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 432079"];
2228 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 432080"];
2229 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 432081"];
2230 [label="param LoadAndValidateAttributes(this) 432082"];
2231 [label="var diagnostics = DiagnosticBag.GetInstance(); 432083"];
2232 [label="this.DeclaringCompilation 432084"];
2233 [label="get\n            {\n                return _compilation;\n            } 432085"];
2234 [label="return _compilation; 432086"];
2235 [label="var compilation = this.DeclaringCompilation; 432087"];
2236 [label="ImmutableArray<Binder> binders; 432088"];
2237 [label="binders 432089"];
2238 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432090"];
2239 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432091"];
2240 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432092"];
2241 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432093"];
2242 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432094"];
2243 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432095"];
2244 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432096"];
2245 [label="this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders) 432097"];
2246 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 432098"];
2247 [label="param GetAttributesToBind(AttributeLocation symbolPart) 432099"];
2248 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 432100"];
2249 [label="param GetAttributesToBind(CSharpCompilation compilation) 432101"];
2250 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 432102"];
2251 [label="param GetAttributesToBind(Binder rootBinderOpt) 432103"];
2252 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 432104"];
2253 [label="param GetAttributesToBind(this) 432105"];
2254 [label="var attributeTarget = (IAttributeTargetSymbol)this; 432106"];
2255 [label="ArrayBuilder<AttributeSyntax> syntaxBuilder = null; 432107"];
2256 [label="ArrayBuilder<Binder> bindersBuilder = null; 432108"];
2257 [label="int attributesToBindCount = 0; 432109"];
2258 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 432110"];
2259 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 432111"];
2260 [label="if (syntaxBuilder != null)\n            {\n                binders = bindersBuilder.ToImmutableAndFree();\n                return syntaxBuilder.ToImmutableAndFree();\n            }\n            else\n            {\n                binders = ImmutableArray<Binder>.Empty;\n                return ImmutableArray<AttributeSyntax>.Empty;\n            } 432112"];
2261 [label="if (syntaxBuilder != null)\n            {\n                binders = bindersBuilder.ToImmutableAndFree();\n                return syntaxBuilder.ToImmutableAndFree();\n            }\n            else\n            {\n                binders = ImmutableArray<Binder>.Empty;\n                return ImmutableArray<AttributeSyntax>.Empty;\n            } 432113"];
2262 [label="binders = ImmutableArray<Binder>.Empty; 432114"];
2263 [label="return ImmutableArray<AttributeSyntax>.Empty; 432115"];
2264 [label="ImmutableArray<AttributeSyntax> attributesToBind = this.GetAttributesToBind(attributesSyntaxLists, symbolPart, diagnostics, compilation, attributeMatchesOpt, binderOpt, out binders); 432116"];
2265 [label="Debug.Assert(!attributesToBind.IsDefault); 432117"];
2266 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 432118"];
2267 [label="boundAttributes 432119"];
2268 [label="WellKnownAttributeData wellKnownAttributeData; 432120"];
2269 [label="if (attributesToBind.Any())\n            {\n                Debug.Assert(!binders.IsDefault);\n                Debug.Assert(binders.Length == attributesToBind.Length);\n\n                // Initialize the bag so that data decoded from early attributes can be stored onto it.\n                if (lazyCustomAttributesBag == null)\n                {\n                    Interlocked.CompareExchange(ref lazyCustomAttributesBag, new CustomAttributesBag<CSharpAttributeData>(), null);\n                }\n\n                // Bind the attribute types and then early decode them.\n                int totalAttributesCount = attributesToBind.Length;\n                var attributeTypesBuilder = new NamedTypeSymbol[totalAttributesCount];\n\n                Binder.BindAttributeTypes(binders, attributesToBind, this, attributeTypesBuilder, diagnostics);\n                ImmutableArray<NamedTypeSymbol> boundAttributeTypes = attributeTypesBuilder.AsImmutableOrNull();\n\n                this.EarlyDecodeWellKnownAttributeTypes(boundAttributeTypes, attributesToBind);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n\n                // Bind the attribute in two stages - early and normal.\n                var attributesBuilder = new CSharpAttributeData[totalAttributesCount];\n\n                // Early bind and decode some well-known attributes.\n                EarlyWellKnownAttributeData earlyData = this.EarlyDecodeWellKnownAttributes(binders, boundAttributeTypes, attributesToBind, symbolPart, attributesBuilder);\n                Debug.Assert(!attributesBuilder.Contains((attr) => attr != null && attr.HasErrors));\n\n                // Store data decoded from early bound well-known attributes.\n                // TODO: what if this succeeds on another thread, not ours?\n                lazyCustomAttributesBag.SetEarlyDecodedWellKnownAttributeData(earlyData);\n\n                if (earlyDecodingOnly)\n                {\n                    diagnostics.Free(); //NOTE: dropped.\n                    return false;\n                }\n\n                // Bind attributes.\n                Binder.GetAttributes(binders, attributesToBind, boundAttributeTypes, attributesBuilder, diagnostics);\n                boundAttributes = attributesBuilder.AsImmutableOrNull();\n\n                // All attributes must be bound by now.\n                Debug.Assert(!boundAttributes.Any((attr) => attr == null));\n\n                // Validate attribute usage and Decode remaining well-known attributes.\n                wellKnownAttributeData = this.ValidateAttributeUsageAndDecodeWellKnownAttributes(binders, attributesToBind, boundAttributes, diagnostics, symbolPart);\n\n                // Store data decoded from remaining well-known attributes.\n                // TODO: what if this succeeds on another thread but not this thread?\n                lazyCustomAttributesBag.SetDecodedWellKnownAttributeData(wellKnownAttributeData);\n            }\n            else if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 432121"];
2270 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 432122"];
2271 [label="boundAttributes = ImmutableArray<CSharpAttributeData>.Empty; 432123"];
2272 [label="wellKnownAttributeData = null; 432124"];
2273 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 432125"];
2274 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 432126"];
2275 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 432127"];
2276 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 432128"];
2277 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 432129"];
2278 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432130"];
2279 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432131"];
2280 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432132"];
2281 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432133"];
2282 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432134"];
2283 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 432135"];
2284 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 432136"];
2285 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 432137"];
2286 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 432138"];
2287 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 432139"];
2288 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 432140"];
2289 [label="param PostDecodeWellKnownAttributes(this) 432141"];
2290 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 432142"];
2291 [label="bool lazyAttributesStoredOnThisThread = false; 432143"];
2292 [label="if (lazyCustomAttributesBag.SetAttributes(boundAttributes))\n            {\n                if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                lazyAttributesStoredOnThisThread = true;\n                if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n            } 432144"];
2293 [label="if (lazyCustomAttributesBag.SetAttributes(boundAttributes))\n            {\n                if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                lazyAttributesStoredOnThisThread = true;\n                if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n            } 432145"];
2294 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 432146"];
2295 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 432147"];
2296 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 432148"];
2297 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 432149"];
2298 [label="param RecordPresenceOfBadAttributes(this) 432150"];
2299 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 432151"];
2300 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 432152"];
2301 [label="AddDeclarationDiagnostics(diagnostics); 432153"];
2302 [label="AddDeclarationDiagnostics(diagnostics) 432154"];
2303 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 432155"];
2304 [label="param AddDeclarationDiagnostics(this) 432156"];
2305 [label="ContainingSymbol 432157"];
2306 [label="get\n            {\n                return null;\n            } 432158"];
2307 [label="return null; 432159"];
2308 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 432160"];
2309 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 432161"];
2310 [label="AddDeclarationDiagnostics(diagnostics); 432162"];
2311 [label="lazyAttributesStoredOnThisThread = true; 432163"];
2312 [label="if (lazyCustomAttributesBag.IsEmpty) lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 432164"];
2313 [label="lazyCustomAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 432165"];
2314 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 432166"];
2315 [label="diagnostics.Free(); 432167"];
2316 [label="return lazyAttributesStoredOnThisThread; 432168"];
2317 [label="_state.NotePartComplete(CompletionPart.Attributes); 432169"];
2318 [label="_state.NotePartComplete(CompletionPart.Attributes) 432170"];
2319 [label="param NotePartComplete(CompletionPart part) 432171"];
2320 [label="param SpinWaitComplete(CompletionPart part) 432172"];
2321 [label="param SpinWaitComplete(CancellationToken cancellationToken) 432173"];
2322 [label="param SpinWaitComplete(this) 432174"];
2323 [label="if (HasComplete(part))\n            {\n                return;\n            } 432175"];
2324 [label="HasComplete(part) 432176"];
2325 [label="param HasComplete(CompletionPart part) 432177"];
2326 [label="param HasComplete(this) 432178"];
2327 [label="return (_completeParts & (int)part) == (int)part; 432179"];
2328 [label="return; 432180"];
2329 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 432181"];
2330 [label="param HasAtMostOneBitSet(int bits) 432182"];
2331 [label="return (bits & (bits - 1)) == 0; 432183"];
2332 [label="Assembly.ForceComplete(location, cancellationToken); 432184"];
2333 [label="return (_completeParts & (int)part) == (int)part; 432185"];
2334 [label="return; 432186"];
2335 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 432187"];
2336 [label="param HasAtMostOneBitSet(int bits) 432188"];
2337 [label="return (bits & (bits - 1)) == 0; 432189"];
2338 [label="param ValidateAttributeSemantics(DiagnosticBag diagnostics) 432190"];
2339 [label="param ValidateAttributeSemantics(this) 432191"];
2340 [label="StrongNameKeys 432192"];
2341 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 432193"];
2342 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 432194"];
2343 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 432195"];
2344 [label="t_assemblyForWhichCurrentThreadIsComputingKeys = this; 432196"];
2345 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 432197"];
2346 [label="ComputeStrongNameKeys() 432198"];
2347 [label="param ComputeStrongNameKeys(this) 432199"];
2348 [label="EnsureAttributesAreBound() 432200"];
2349 [label="param EnsureAttributesAreBound(this) 432201"];
2350 [label="EnsureAttributesAreBound(); 432202"];
2351 [label="_compilation.Options 432203"];
2352 [label="get\n            {\n                return _options;\n            } 432204"];
2353 [label="string keyFile = _compilation.Options.CryptoKeyFile; 432205"];
2354 [label="DeclaringCompilation 432206"];
2355 [label="get\n            {\n                return _compilation;\n            } 432207"];
2356 [label="if (DeclaringCompilation.Options.PublicSign)\n            {\n                // TODO(https://github.com/dotnet/roslyn/issues/9150):\n                // Provide better error message if keys are provided by\n                // the attributes. Right now we'll just fall through to the\n                // 'no key available' error.\n\n                if (!string.IsNullOrEmpty(keyFile) && !PathUtilities.IsAbsolute(keyFile))\n                {\n                    // If keyFile has a relative path then there should be a diagnostic\n                    // about it\n                    Debug.Assert(!DeclaringCompilation.Options.Errors.IsEmpty);\n                    return StrongNameKeys.None;\n                }\n\n                // If we're public signing, we don't need a strong name provider\n                return StrongNameKeys.Create(keyFile, MessageProvider.Instance);\n            } 432208"];
2357 [label="DeclaringCompilation.Options 432209"];
2358 [label="get\n            {\n                return _options;\n            } 432210"];
2359 [label="if (string.IsNullOrEmpty(keyFile))\n            {\n                keyFile = this.AssemblyKeyFileAttributeSetting;\n\n                if ((object)keyFile == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyFile = null;\n                }\n            } 432211"];
2360 [label="this.AssemblyKeyFileAttributeSetting 432212"];
2361 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue);\n            } 432213"];
2362 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue); 432214"];
2363 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue); 432215"];
2364 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyKeyFileAttributeSetting, WellKnownAttributeData.StringMissingValue) 432216"];
2365 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 432217"];
2366 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 432218"];
2367 [label="param GetWellKnownAttributeDataStringField(this) 432219"];
2368 [label="string fieldValue = missingValue; 432220"];
2369 [label="GetSourceDecodedWellKnownAttributeData() 432221"];
2370 [label="param GetSourceDecodedWellKnownAttributeData(this) 432222"];
2371 [label="var attributesBag = _lazySourceAttributesBag; 432223"];
2372 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432224"];
2373 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432225"];
2374 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432226"];
2375 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432227"];
2376 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432228"];
2377 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432229"];
2378 [label="if ((object)fieldValue == (object)missingValue)\n            {\n                data = GetNetModuleDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                }\n            } 432230"];
2379 [label="GetNetModuleDecodedWellKnownAttributeData() 432231"];
2380 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432232"];
2381 [label="this.GetNetModuleAttributesBag() 432233"];
2382 [label="param GetNetModuleAttributesBag(this) 432234"];
2383 [label="EnsureNetModuleAttributesAreBound() 432235"];
2384 [label="param EnsureNetModuleAttributesAreBound(this) 432236"];
2385 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432237"];
2386 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432238"];
2387 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag); 432239"];
2388 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag) 432240"];
2389 [label="param LoadAndValidateNetModuleAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyNetModuleAttributesBag) 432241"];
2390 [label="param LoadAndValidateNetModuleAttributes(this) 432242"];
2391 [label="_compilation.Options 432243"];
2392 [label="get\n            {\n                return _options;\n            } 432244"];
2393 [label="if (_compilation.Options.OutputKind.IsNetModule())\n            {\n                Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, CustomAttributesBag<CSharpAttributeData>.Empty, null);\n            }\n            else\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n\n                ImmutableArray<string> netModuleNames;\n                ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames);\n\n                WellKnownAttributeData wellKnownData = null;\n\n                if (attributesFromNetModules.Any())\n                {\n                    wellKnownData = ValidateAttributeUsageAndDecodeWellKnownAttributes(attributesFromNetModules, netModuleNames, diagnostics);\n                }\n                else\n                {\n                    // Compute duplicate source assembly attributes, i.e. attributes with same constructor and arguments, that must not be emitted.\n                    var unused = GetUniqueSourceAssemblyAttributes();\n                }\n\n                // Load type forwarders from modules\n                HashSet<NamedTypeSymbol> forwardedTypes = null;\n\n                // Similar to attributes, type forwarders from the second added module should override type forwarders from the first added module, etc. \n                // This affects only diagnostics.\n                for (int i = _modules.Length - 1; i > 0; i--)\n                {\n                    var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n\n                    foreach (NamedTypeSymbol forwarded in peModuleSymbol.GetForwardedTypes())\n                    {\n                        if (forwardedTypes == null)\n                        {\n                            if (wellKnownData == null)\n                            {\n                                wellKnownData = new CommonAssemblyWellKnownAttributeData();\n                            }\n\n                            forwardedTypes = ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes;\n                            if (forwardedTypes == null)\n                            {\n                                forwardedTypes = new HashSet<NamedTypeSymbol>();\n                                ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes = forwardedTypes;\n                            }\n                        }\n\n                        if (forwardedTypes.Add(forwarded))\n                        {\n                            if (forwarded.IsErrorType())\n                            {\n                                DiagnosticInfo info = forwarded.GetUseSiteDiagnostic() ?? ((ErrorTypeSymbol)forwarded).ErrorInfo;\n\n                                if ((object)info != null)\n                                {\n                                    diagnostics.Add(info, NoLocation.Singleton);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                CustomAttributesBag<CSharpAttributeData> netModuleAttributesBag;\n\n                if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n\n                if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                }\n\n                diagnostics.Free();\n            } 432245"];
2394 [label="var diagnostics = DiagnosticBag.GetInstance(); 432246"];
2395 [label="ImmutableArray<string> netModuleNames; 432247"];
2396 [label="netModuleNames 432248"];
2397 [label="ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames); 432249"];
2398 [label="GetNetModuleAttributes(out netModuleNames) 432250"];
2399 [label="param GetNetModuleAttributes(out ImmutableArray<string> netModuleNames) 432251"];
2400 [label="param GetNetModuleAttributes(this) 432252"];
2401 [label="ArrayBuilder<CSharpAttributeData> moduleAssemblyAttributesBuilder = null; 432253"];
2402 [label="ArrayBuilder<string> netModuleNameBuilder = null; 432254"];
2403 [label="for (int i = 1; i < _modules.Length; i++)\n            {\n                var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n                string netModuleName = peModuleSymbol.Name;\n                foreach (var attributeData in peModuleSymbol.GetAssemblyAttributes())\n                {\n                    if (netModuleNameBuilder == null)\n                    {\n                        netModuleNameBuilder = ArrayBuilder<string>.GetInstance();\n                        moduleAssemblyAttributesBuilder = ArrayBuilder<CSharpAttributeData>.GetInstance();\n                    }\n\n                    netModuleNameBuilder.Add(netModuleName);\n                    moduleAssemblyAttributesBuilder.Add(attributeData);\n                }\n            } 432255"];
2404 [label="for (int i = 1; i < _modules.Length; i++)\n            {\n                var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n                string netModuleName = peModuleSymbol.Name;\n                foreach (var attributeData in peModuleSymbol.GetAssemblyAttributes())\n                {\n                    if (netModuleNameBuilder == null)\n                    {\n                        netModuleNameBuilder = ArrayBuilder<string>.GetInstance();\n                        moduleAssemblyAttributesBuilder = ArrayBuilder<CSharpAttributeData>.GetInstance();\n                    }\n\n                    netModuleNameBuilder.Add(netModuleName);\n                    moduleAssemblyAttributesBuilder.Add(attributeData);\n                }\n            } 432256"];
2405 [label="if (netModuleNameBuilder == null)\n            {\n                netModuleNames = ImmutableArray<string>.Empty;\n                return ImmutableArray<CSharpAttributeData>.Empty;\n            } 432257"];
2406 [label="if (netModuleNameBuilder == null)\n            {\n                netModuleNames = ImmutableArray<string>.Empty;\n                return ImmutableArray<CSharpAttributeData>.Empty;\n            } 432258"];
2407 [label="netModuleNames = ImmutableArray<string>.Empty; 432259"];
2408 [label="return ImmutableArray<CSharpAttributeData>.Empty; 432260"];
2409 [label="ImmutableArray<CSharpAttributeData> attributesFromNetModules = GetNetModuleAttributes(out netModuleNames); 432261"];
2410 [label="WellKnownAttributeData wellKnownData = null; 432262"];
2411 [label="if (attributesFromNetModules.Any())\n                {\n                    wellKnownData = ValidateAttributeUsageAndDecodeWellKnownAttributes(attributesFromNetModules, netModuleNames, diagnostics);\n                }\n                else\n                {\n                    // Compute duplicate source assembly attributes, i.e. attributes with same constructor and arguments, that must not be emitted.\n                    var unused = GetUniqueSourceAssemblyAttributes();\n                } 432263"];
2412 [label="GetUniqueSourceAssemblyAttributes() 432264"];
2413 [label="param GetUniqueSourceAssemblyAttributes(this) 432265"];
2414 [label="this.GetSourceAttributesBag() 432266"];
2415 [label="param GetSourceAttributesBag(this) 432267"];
2416 [label="EnsureAttributesAreBound() 432268"];
2417 [label="param EnsureAttributesAreBound(this) 432269"];
2418 [label="EnsureAttributesAreBound(); 432270"];
2419 [label="return _lazySourceAttributesBag; 432271"];
2420 [label="ImmutableArray<CSharpAttributeData> appliedSourceAttributes = this.GetSourceAttributesBag().Attributes; 432272"];
2421 [label="HashSet<CSharpAttributeData> uniqueAttributes = null; 432273"];
2422 [label="for (int i = 0; i < appliedSourceAttributes.Length; i++)\n            {\n                CSharpAttributeData attribute = appliedSourceAttributes[i];\n                if (!attribute.HasErrors)\n                {\n                    if (!AddUniqueAssemblyAttribute(attribute, ref uniqueAttributes))\n                    {\n                        AddOmittedAttributeIndex(i);\n                    }\n                }\n            } 432274"];
2423 [label="for (int i = 0; i < appliedSourceAttributes.Length; i++)\n            {\n                CSharpAttributeData attribute = appliedSourceAttributes[i];\n                if (!attribute.HasErrors)\n                {\n                    if (!AddUniqueAssemblyAttribute(attribute, ref uniqueAttributes))\n                    {\n                        AddOmittedAttributeIndex(i);\n                    }\n                }\n            } 432275"];
2424 [label="return uniqueAttributes; 432276"];
2425 [label="var unused = GetUniqueSourceAssemblyAttributes(); 432277"];
2426 [label="HashSet<NamedTypeSymbol> forwardedTypes = null; 432278"];
2427 [label="for (int i = _modules.Length - 1; i > 0; i--)\n                {\n                    var peModuleSymbol = (Metadata.PE.PEModuleSymbol)_modules[i];\n\n                    foreach (NamedTypeSymbol forwarded in peModuleSymbol.GetForwardedTypes())\n                    {\n                        if (forwardedTypes == null)\n                        {\n                            if (wellKnownData == null)\n                            {\n                                wellKnownData = new CommonAssemblyWellKnownAttributeData();\n                            }\n\n                            forwardedTypes = ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes;\n                            if (forwardedTypes == null)\n                            {\n                                forwardedTypes = new HashSet<NamedTypeSymbol>();\n                                ((CommonAssemblyWellKnownAttributeData)wellKnownData).ForwardedTypes = forwardedTypes;\n                            }\n                        }\n\n                        if (forwardedTypes.Add(forwarded))\n                        {\n                            if (forwarded.IsErrorType())\n                            {\n                                DiagnosticInfo info = forwarded.GetUseSiteDiagnostic() ?? ((ErrorTypeSymbol)forwarded).ErrorInfo;\n\n                                if ((object)info != null)\n                                {\n                                    diagnostics.Add(info, NoLocation.Singleton);\n                                }\n                            }\n                        }\n                    }\n                } 432279"];
2428 [label="CustomAttributesBag<CSharpAttributeData> netModuleAttributesBag; 432280"];
2429 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 432281"];
2430 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 432282"];
2431 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 432283"];
2432 [label="if (wellKnownData != null || attributesFromNetModules.Any())\n                {\n                    netModuleAttributesBag = new CustomAttributesBag<CSharpAttributeData>();\n\n                    netModuleAttributesBag.SetEarlyDecodedWellKnownAttributeData(null);\n                    netModuleAttributesBag.SetDecodedWellKnownAttributeData(wellKnownData);\n                    netModuleAttributesBag.SetAttributes(attributesFromNetModules);\n                    if (netModuleAttributesBag.IsEmpty) netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                }\n                else\n                {\n                    netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty;\n                } 432284"];
2433 [label="netModuleAttributesBag = CustomAttributesBag<CSharpAttributeData>.Empty; 432285"];
2434 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 432286"];
2435 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 432287"];
2436 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 432288"];
2437 [label="if (Interlocked.CompareExchange(ref lazyNetModuleAttributesBag, netModuleAttributesBag, null) == null)\n                {\n                    this.AddDeclarationDiagnostics(diagnostics);\n                } 432289"];
2438 [label="this.AddDeclarationDiagnostics(diagnostics); 432290"];
2439 [label="this.AddDeclarationDiagnostics(diagnostics) 432291"];
2440 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 432292"];
2441 [label="param AddDeclarationDiagnostics(this) 432293"];
2442 [label="ContainingSymbol 432294"];
2443 [label="get\n            {\n                return null;\n            } 432295"];
2444 [label="return null; 432296"];
2445 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 432297"];
2446 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 432298"];
2447 [label="this.AddDeclarationDiagnostics(diagnostics); 432299"];
2448 [label="diagnostics.Free(); 432300"];
2449 [label="Debug.Assert(lazyNetModuleAttributesBag.IsSealed); 432301"];
2450 [label="LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag); 432302"];
2451 [label="EnsureNetModuleAttributesAreBound(); 432303"];
2452 [label="return _lazyNetModuleAttributesBag; 432304"];
2453 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432305"];
2454 [label="Debug.Assert(attributesBag.IsSealed); 432306"];
2455 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432307"];
2456 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432308"];
2457 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432309"];
2458 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432310"];
2459 [label="return fieldValue; 432311"];
2460 [label="keyFile = this.AssemblyKeyFileAttributeSetting; 432312"];
2461 [label="if ((object)keyFile == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyFile = null;\n                } 432313"];
2462 [label="keyFile = null; 432314"];
2463 [label="_compilation.Options 432315"];
2464 [label="get\n            {\n                return _options;\n            } 432316"];
2465 [label="string keyContainer = _compilation.Options.CryptoKeyContainer; 432317"];
2466 [label="if (string.IsNullOrEmpty(keyContainer))\n            {\n                keyContainer = this.AssemblyKeyContainerAttributeSetting;\n\n                if ((object)keyContainer == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyContainer = null;\n                }\n            } 432318"];
2467 [label="this.AssemblyKeyContainerAttributeSetting 432319"];
2468 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue);\n            } 432320"];
2469 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue); 432321"];
2470 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue); 432322"];
2471 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyKeyContainerAttributeSetting, WellKnownAttributeData.StringMissingValue) 432323"];
2472 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 432324"];
2473 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 432325"];
2474 [label="param GetWellKnownAttributeDataStringField(this) 432326"];
2475 [label="GetSourceDecodedWellKnownAttributeData() 432327"];
2476 [label="param GetSourceDecodedWellKnownAttributeData(this) 432328"];
2477 [label="var attributesBag = _lazySourceAttributesBag; 432329"];
2478 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432330"];
2479 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432331"];
2480 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432332"];
2481 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432333"];
2482 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432334"];
2483 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432335"];
2484 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432336"];
2485 [label="EnsureNetModuleAttributesAreBound(); 432337"];
2486 [label="return _lazyNetModuleAttributesBag; 432338"];
2487 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432339"];
2488 [label="Debug.Assert(attributesBag.IsSealed); 432340"];
2489 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432341"];
2490 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432342"];
2491 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432343"];
2492 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432344"];
2493 [label="return fieldValue; 432345"];
2494 [label="keyContainer = this.AssemblyKeyContainerAttributeSetting; 432346"];
2495 [label="if ((object)keyContainer == (object)WellKnownAttributeData.StringMissingValue)\n                {\n                    keyContainer = null;\n                } 432347"];
2496 [label="keyContainer = null; 432348"];
2497 [label="this.SignatureKey 432349"];
2498 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting);\n            } 432350"];
2499 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting); 432351"];
2500 [label="GetWellKnownAttributeDataStringField(data => data.AssemblySignatureKeyAttributeSetting) 432352"];
2501 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 432353"];
2502 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 432354"];
2503 [label="param GetWellKnownAttributeDataStringField(this) 432355"];
2504 [label="string fieldValue = missingValue; 432356"];
2505 [label="GetSourceDecodedWellKnownAttributeData() 432357"];
2506 [label="param GetSourceDecodedWellKnownAttributeData(this) 432358"];
2507 [label="var attributesBag = _lazySourceAttributesBag; 432359"];
2508 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432360"];
2509 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432361"];
2510 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432362"];
2511 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432363"];
2512 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432364"];
2513 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432365"];
2514 [label="if ((object)fieldValue == (object)missingValue)\n            {\n                data = GetNetModuleDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                }\n            } 432366"];
2515 [label="GetNetModuleDecodedWellKnownAttributeData() 432367"];
2516 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432368"];
2517 [label="this.GetNetModuleAttributesBag() 432369"];
2518 [label="param GetNetModuleAttributesBag(this) 432370"];
2519 [label="EnsureNetModuleAttributesAreBound() 432371"];
2520 [label="param EnsureNetModuleAttributesAreBound(this) 432372"];
2521 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432373"];
2522 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432374"];
2523 [label="EnsureNetModuleAttributesAreBound(); 432375"];
2524 [label="return _lazyNetModuleAttributesBag; 432376"];
2525 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432377"];
2526 [label="Debug.Assert(attributesBag.IsSealed); 432378"];
2527 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432379"];
2528 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432380"];
2529 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432381"];
2530 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432382"];
2531 [label="return fieldValue; 432383"];
2532 [label="var hasCounterSignature = !string.IsNullOrEmpty(this.SignatureKey); 432384"];
2533 [label="DeclaringCompilation 432385"];
2534 [label="get\n            {\n                return _compilation;\n            } 432386"];
2535 [label="return _compilation; 432387"];
2536 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432388"];
2537 [label="DeclaringCompilation.Options 432389"];
2538 [label="get\n            {\n                return _options;\n            } 432390"];
2539 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432391"];
2540 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432392"];
2541 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432393"];
2542 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432394"];
2543 [label="return StrongNameKeys.Create(DeclaringCompilation.Options.StrongNameProvider, keyFile, keyContainer, hasCounterSignature, MessageProvider.Instance); 432395"];
2544 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 432396"];
2545 [label="Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null); 432397"];
2546 [label="t_assemblyForWhichCurrentThreadIsComputingKeys = null; 432398"];
2547 [label="return _lazyStrongNameKeys; 432399"];
2548 [label="if (StrongNameKeys.DiagnosticOpt != null && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                diagnostics.Add(StrongNameKeys.DiagnosticOpt);\n            } 432400"];
2549 [label="if (StrongNameKeys.DiagnosticOpt != null && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                diagnostics.Add(StrongNameKeys.DiagnosticOpt);\n            } 432401"];
2550 [label="ValidateIVTPublicKeys(diagnostics); 432402"];
2551 [label="ValidateIVTPublicKeys(diagnostics) 432403"];
2552 [label="param ValidateIVTPublicKeys(DiagnosticBag diagnostics) 432404"];
2553 [label="param ValidateIVTPublicKeys(this) 432405"];
2554 [label="EnsureAttributesAreBound() 432406"];
2555 [label="param EnsureAttributesAreBound(this) 432407"];
2556 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432408"];
2557 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432409"];
2558 [label="EnsureAttributesAreBound(); 432410"];
2559 [label="this.Identity 432411"];
2560 [label="get\n            {\n                if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null);\n\n                return lazyAssemblyIdentity;\n            } 432412"];
2561 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432413"];
2562 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432414"];
2563 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432415"];
2564 [label="ComputeIdentity() 432416"];
2565 [label="param ComputeIdentity(this) 432417"];
2566 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432418"];
2567 [label="_compilation.Options 432419"];
2568 [label="get\n            {\n                return _options;\n            } 432420"];
2569 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432421"];
2570 [label="AssemblyVersionAttributeSetting 432422"];
2571 [label="get\n            {\n                var defaultValue = (Version)null;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 432423"];
2572 [label="var defaultValue = (Version)null; 432424"];
2573 [label="var fieldValue = defaultValue; 432425"];
2574 [label="GetSourceDecodedWellKnownAttributeData() 432426"];
2575 [label="param GetSourceDecodedWellKnownAttributeData(this) 432427"];
2576 [label="var attributesBag = _lazySourceAttributesBag; 432428"];
2577 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432429"];
2578 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432430"];
2579 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432431"];
2580 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432432"];
2581 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                } 432433"];
2582 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyVersionAttributeSetting;\n                } 432434"];
2583 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    }\n                } 432435"];
2584 [label="GetNetModuleDecodedWellKnownAttributeData() 432436"];
2585 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432437"];
2586 [label="EnsureNetModuleAttributesAreBound(); 432438"];
2587 [label="return _lazyNetModuleAttributesBag; 432439"];
2588 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432440"];
2589 [label="Debug.Assert(attributesBag.IsSealed); 432441"];
2590 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432442"];
2591 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432443"];
2592 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    } 432444"];
2593 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyVersionAttributeSetting;\n                    } 432445"];
2594 [label="return fieldValue; 432446"];
2595 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432447"];
2596 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432448"];
2597 [label="this.AssemblyCultureAttributeSetting 432449"];
2598 [label="get\n            {\n                return GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting);\n            } 432450"];
2599 [label="return GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting); 432451"];
2600 [label="GetWellKnownAttributeDataStringField(data => data.AssemblyCultureAttributeSetting) 432452"];
2601 [label="param GetWellKnownAttributeDataStringField(Func<CommonAssemblyWellKnownAttributeData, string> fieldGetter) 432453"];
2602 [label="param GetWellKnownAttributeDataStringField(string missingValue = null) 432454"];
2603 [label="param GetWellKnownAttributeDataStringField(this) 432455"];
2604 [label="GetSourceDecodedWellKnownAttributeData() 432456"];
2605 [label="param GetSourceDecodedWellKnownAttributeData(this) 432457"];
2606 [label="var attributesBag = _lazySourceAttributesBag; 432458"];
2607 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432459"];
2608 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432460"];
2609 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432461"];
2610 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432462"];
2611 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432463"];
2612 [label="if (data != null)\n            {\n                fieldValue = fieldGetter(data);\n            } 432464"];
2613 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432465"];
2614 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432466"];
2615 [label="EnsureNetModuleAttributesAreBound(); 432467"];
2616 [label="return _lazyNetModuleAttributesBag; 432468"];
2617 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432469"];
2618 [label="Debug.Assert(attributesBag.IsSealed); 432470"];
2619 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432471"];
2620 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432472"];
2621 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432473"];
2622 [label="if (data != null)\n                {\n                    fieldValue = fieldGetter(data);\n                } 432474"];
2623 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432475"];
2624 [label="StrongNameKeys 432476"];
2625 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 432477"];
2626 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 432478"];
2627 [label="return _lazyStrongNameKeys; 432479"];
2628 [label="StrongNameKeys 432480"];
2629 [label="get\n            {\n                if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                }\n\n                return _lazyStrongNameKeys;\n            } 432481"];
2630 [label="if (_lazyStrongNameKeys == null)\n                {\n                    try\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = this;\n                        Interlocked.CompareExchange(ref _lazyStrongNameKeys, ComputeStrongNameKeys(), null);\n                    }\n                    finally\n                    {\n                        t_assemblyForWhichCurrentThreadIsComputingKeys = null;\n                    }\n                } 432482"];
2631 [label="return _lazyStrongNameKeys; 432483"];
2632 [label="return new AssemblyIdentity(\n                _assemblySimpleName,\n                VersionHelper.GenerateVersionFromPatternAndCurrentTime(_compilation.Options.CurrentLocalTime, AssemblyVersionAttributeSetting),\n                this.AssemblyCultureAttributeSetting,\n                StrongNameKeys.PublicKey,\n                hasPublicKey: !StrongNameKeys.PublicKey.IsDefault); 432484"];
2633 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432485"];
2634 [label="Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432486"];
2635 [label="return lazyAssemblyIdentity; 432487"];
2636 [label="if (!this.Identity.IsStrongName)\n                return; 432488"];
2637 [label="return; 432489"];
2638 [label="ValidateIVTPublicKeys(diagnostics); 432490"];
2639 [label="CheckOptimisticIVTAccessGrants(diagnostics); 432491"];
2640 [label="CheckOptimisticIVTAccessGrants(diagnostics) 432492"];
2641 [label="param CheckOptimisticIVTAccessGrants(DiagnosticBag bag) 432493"];
2642 [label="param CheckOptimisticIVTAccessGrants(this) 432494"];
2643 [label="ConcurrentDictionary<AssemblySymbol, bool> haveGrantedAssemblies = _optimisticallyGrantedInternalsAccess; 432495"];
2644 [label="if (haveGrantedAssemblies != null)\n            {\n                foreach (var otherAssembly in haveGrantedAssemblies.Keys)\n                {\n                    IVTConclusion conclusion = MakeFinalIVTDetermination(otherAssembly);\n\n                    Debug.Assert(conclusion != IVTConclusion.NoRelationshipClaimed);\n\n                    if (conclusion == IVTConclusion.PublicKeyDoesntMatch)\n                        bag.Add(ErrorCode.ERR_FriendRefNotEqualToThis, NoLocation.Singleton,\n                                                                      otherAssembly.Identity, this.Identity);\n                    else if (conclusion == IVTConclusion.OneSignedOneNot)\n                        bag.Add(ErrorCode.ERR_FriendRefSigningMismatch, NoLocation.Singleton,\n                                                                      otherAssembly.Identity);\n                }\n            } 432496"];
2645 [label="if (haveGrantedAssemblies != null)\n            {\n                foreach (var otherAssembly in haveGrantedAssemblies.Keys)\n                {\n                    IVTConclusion conclusion = MakeFinalIVTDetermination(otherAssembly);\n\n                    Debug.Assert(conclusion != IVTConclusion.NoRelationshipClaimed);\n\n                    if (conclusion == IVTConclusion.PublicKeyDoesntMatch)\n                        bag.Add(ErrorCode.ERR_FriendRefNotEqualToThis, NoLocation.Singleton,\n                                                                      otherAssembly.Identity, this.Identity);\n                    else if (conclusion == IVTConclusion.OneSignedOneNot)\n                        bag.Add(ErrorCode.ERR_FriendRefSigningMismatch, NoLocation.Singleton,\n                                                                      otherAssembly.Identity);\n                }\n            } 432497"];
2646 [label="CheckOptimisticIVTAccessGrants(diagnostics); 432498"];
2647 [label="DetectAttributeAndOptionConflicts(diagnostics); 432499"];
2648 [label="DetectAttributeAndOptionConflicts(diagnostics) 432500"];
2649 [label="param DetectAttributeAndOptionConflicts(DiagnosticBag diagnostics) 432501"];
2650 [label="param DetectAttributeAndOptionConflicts(this) 432502"];
2651 [label="EnsureAttributesAreBound() 432503"];
2652 [label="param EnsureAttributesAreBound(this) 432504"];
2653 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432505"];
2654 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 432506"];
2655 [label="EnsureAttributesAreBound(); 432507"];
2656 [label="this.AssemblyDelaySignAttributeSetting 432508"];
2657 [label="get\n            {\n                var defaultValue = ThreeState.Unknown;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 432509"];
2658 [label="var defaultValue = ThreeState.Unknown; 432510"];
2659 [label="var fieldValue = defaultValue; 432511"];
2660 [label="GetSourceDecodedWellKnownAttributeData() 432512"];
2661 [label="param GetSourceDecodedWellKnownAttributeData(this) 432513"];
2662 [label="var attributesBag = _lazySourceAttributesBag; 432514"];
2663 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432515"];
2664 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432516"];
2665 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432517"];
2666 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432518"];
2667 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 432519"];
2668 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 432520"];
2669 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                } 432521"];
2670 [label="GetNetModuleDecodedWellKnownAttributeData() 432522"];
2671 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432523"];
2672 [label="this.GetNetModuleAttributesBag() 432524"];
2673 [label="param GetNetModuleAttributesBag(this) 432525"];
2674 [label="EnsureNetModuleAttributesAreBound() 432526"];
2675 [label="param EnsureNetModuleAttributesAreBound(this) 432527"];
2676 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432528"];
2677 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432529"];
2678 [label="EnsureNetModuleAttributesAreBound(); 432530"];
2679 [label="return _lazyNetModuleAttributesBag; 432531"];
2680 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432532"];
2681 [label="Debug.Assert(attributesBag.IsSealed); 432533"];
2682 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432534"];
2683 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432535"];
2684 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 432536"];
2685 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 432537"];
2686 [label="return fieldValue; 432538"];
2687 [label="ThreeState assemblyDelaySignAttributeSetting = this.AssemblyDelaySignAttributeSetting; 432539"];
2688 [label="_compilation.Options 432540"];
2689 [label="get\n            {\n                return _options;\n            } 432541"];
2690 [label="if (_compilation.Options.DelaySign.HasValue && (assemblyDelaySignAttributeSetting != ThreeState.Unknown) &&\n                (DeclaringCompilation.Options.DelaySign.Value != (assemblyDelaySignAttributeSetting == ThreeState.True)))\n            {\n                diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'DelaySign', AttributeDescription.AssemblyDelaySignAttribute.FullName);\n            } 432542"];
2691 [label="_compilation.Options 432543"];
2692 [label="get\n            {\n                return _options;\n            } 432544"];
2693 [label="if (_compilation.Options.PublicSign && assemblyDelaySignAttributeSetting == ThreeState.True)\n            {\n                diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton,\n                    nameof(_compilation.Options.PublicSign),\n                    AttributeDescription.AssemblyDelaySignAttribute.FullName);\n            } 432545"];
2694 [label="_compilation.Options 432546"];
2695 [label="get\n            {\n                return _options;\n            } 432547"];
2696 [label="if (!String.IsNullOrEmpty(_compilation.Options.CryptoKeyContainer))\n            {\n                string assemblyKeyContainerAttributeSetting = this.AssemblyKeyContainerAttributeSetting;\n\n                if ((object)assemblyKeyContainerAttributeSetting == (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n                {\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        // We need to synthesize this attribute for .NET module,\n                        // touch the constructor in order to generate proper use-site diagnostics\n                        Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(_compilation,\n                            WellKnownMember.System_Reflection_AssemblyKeyNameAttribute__ctor,\n                            diagnostics,\n                            NoLocation.Singleton);\n                    }\n                }\n                else if (String.Compare(_compilation.Options.CryptoKeyContainer, assemblyKeyContainerAttributeSetting, StringComparison.OrdinalIgnoreCase) != 0)\n                {\n                    // Native compiler reports a warning in this case, notifying the user that attribute value from source is ignored,\n                    // but it doesn't drop the attribute during emit. That might be fine if we produce an assembly because we actually sign it with correct\n                    // key (the one from compilation options) without relying on the emitted attribute.\n                    // If we are building a .NET module, things get more complicated. In particular, we don't sign the module, we emit an attribute with the key \n                    // information, which will be used to sign an assembly once the module is linked into it. If there is already an attribute like that in source,\n                    // native compiler emits both of them, synthetic attribute is emitted after the one from source. Incidentally, ALink picks the last attribute\n                    // for signing and things seem to work out. However, relying on the order of attributes feels fragile, especially given that Roslyn emits\n                    // synthetic attributes before attributes from source. The behavior we settled on for .NET modules is that, if the attribute in source has the\n                    // same value as the one in compilation options, we won't emit the synthetic attribute. If the value doesn't match, we report an error, which \n                    // is a breaking change. Bottom line, we will never produce a module or an assembly with two attributes, regardless whether values are the same\n                    // or not.\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource, NoLocation.Singleton, AttributeDescription.AssemblyKeyNameAttribute.FullName, 'CryptoKeyContainer');\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'CryptoKeyContainer', AttributeDescription.AssemblyKeyNameAttribute.FullName);\n                    }\n                }\n            } 432548"];
2697 [label="_compilation.Options 432549"];
2698 [label="get\n            {\n                return _options;\n            } 432550"];
2699 [label="if (_compilation.Options.PublicSign &&\n                !_compilation.Options.OutputKind.IsNetModule() &&\n                (object)this.AssemblyKeyContainerAttributeSetting != (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n            {\n                diagnostics.Add(ErrorCode.WRN_AttributeIgnoredWhenPublicSigning, NoLocation.Singleton, AttributeDescription.AssemblyKeyNameAttribute.FullName);\n            } 432551"];
2700 [label="_compilation.Options 432552"];
2701 [label="get\n            {\n                return _options;\n            } 432553"];
2702 [label="if (!String.IsNullOrEmpty(_compilation.Options.CryptoKeyFile))\n            {\n                string assemblyKeyFileAttributeSetting = this.AssemblyKeyFileAttributeSetting;\n\n                if ((object)assemblyKeyFileAttributeSetting == (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n                {\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        // We need to synthesize this attribute for .NET module,\n                        // touch the constructor in order to generate proper use-site diagnostics\n                        Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(_compilation,\n                            WellKnownMember.System_Reflection_AssemblyKeyFileAttribute__ctor,\n                            diagnostics,\n                            NoLocation.Singleton);\n                    }\n                }\n                else if (String.Compare(_compilation.Options.CryptoKeyFile, assemblyKeyFileAttributeSetting, StringComparison.OrdinalIgnoreCase) != 0)\n                {\n                    // Comment in similar section for CryptoKeyContainer is applicable here as well.\n                    if (_compilation.Options.OutputKind == OutputKind.NetModule)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_CmdOptionConflictsSource, NoLocation.Singleton, AttributeDescription.AssemblyKeyFileAttribute.FullName, 'CryptoKeyFile');\n                    }\n                    else\n                    {\n                        diagnostics.Add(ErrorCode.WRN_CmdOptionConflictsSource, NoLocation.Singleton, 'CryptoKeyFile', AttributeDescription.AssemblyKeyFileAttribute.FullName);\n                    }\n                }\n            } 432554"];
2703 [label="_compilation.Options 432555"];
2704 [label="get\n            {\n                return _options;\n            } 432556"];
2705 [label="if (_compilation.Options.PublicSign &&\n                !_compilation.Options.OutputKind.IsNetModule() &&\n                (object)this.AssemblyKeyFileAttributeSetting != (object)CommonAssemblyWellKnownAttributeData.StringMissingValue)\n            {\n                diagnostics.Add(ErrorCode.WRN_AttributeIgnoredWhenPublicSigning, NoLocation.Singleton, AttributeDescription.AssemblyKeyFileAttribute.FullName);\n            } 432557"];
2706 [label="DetectAttributeAndOptionConflicts(diagnostics); 432558"];
2707 [label="IsDelaySigned 432559"];
2708 [label="get\n            {\n                //commandline setting trumps attribute value. Warning assumed to be given elsewhere\n                if (_compilation.Options.DelaySign.HasValue)\n                {\n                    return _compilation.Options.DelaySign.Value;\n                }\n\n                // The public sign argument should also override the attribute\n                if (_compilation.Options.PublicSign)\n                {\n                    return false;\n                }\n\n                return (this.AssemblyDelaySignAttributeSetting == ThreeState.True);\n            } 432560"];
2709 [label="_compilation.Options 432561"];
2710 [label="get\n            {\n                return _options;\n            } 432562"];
2711 [label="if (_compilation.Options.DelaySign.HasValue)\n                {\n                    return _compilation.Options.DelaySign.Value;\n                } 432563"];
2712 [label="_compilation.Options 432564"];
2713 [label="get\n            {\n                return _options;\n            } 432565"];
2714 [label="if (_compilation.Options.PublicSign)\n                {\n                    return false;\n                } 432566"];
2715 [label="this.AssemblyDelaySignAttributeSetting 432567"];
2716 [label="get\n            {\n                var defaultValue = ThreeState.Unknown;\n                var fieldValue = defaultValue;\n\n                var data = GetSourceDecodedWellKnownAttributeData();\n                if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                }\n\n                if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                }\n\n                return fieldValue;\n            } 432568"];
2717 [label="var defaultValue = ThreeState.Unknown; 432569"];
2718 [label="var fieldValue = defaultValue; 432570"];
2719 [label="GetSourceDecodedWellKnownAttributeData() 432571"];
2720 [label="param GetSourceDecodedWellKnownAttributeData(this) 432572"];
2721 [label="var attributesBag = _lazySourceAttributesBag; 432573"];
2722 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432574"];
2723 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetSourceAttributesBag();\n            } 432575"];
2724 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432576"];
2725 [label="var data = GetSourceDecodedWellKnownAttributeData(); 432577"];
2726 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 432578"];
2727 [label="if (data != null)\n                {\n                    fieldValue = data.AssemblyDelaySignAttributeSetting;\n                } 432579"];
2728 [label="if (fieldValue == defaultValue)\n                {\n                    data = GetNetModuleDecodedWellKnownAttributeData();\n                    if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    }\n                } 432580"];
2729 [label="GetNetModuleDecodedWellKnownAttributeData() 432581"];
2730 [label="param GetNetModuleDecodedWellKnownAttributeData(this) 432582"];
2731 [label="this.GetNetModuleAttributesBag() 432583"];
2732 [label="param GetNetModuleAttributesBag(this) 432584"];
2733 [label="EnsureNetModuleAttributesAreBound() 432585"];
2734 [label="param EnsureNetModuleAttributesAreBound(this) 432586"];
2735 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432587"];
2736 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 432588"];
2737 [label="EnsureNetModuleAttributesAreBound(); 432589"];
2738 [label="return _lazyNetModuleAttributesBag; 432590"];
2739 [label="var attributesBag = this.GetNetModuleAttributesBag(); 432591"];
2740 [label="Debug.Assert(attributesBag.IsSealed); 432592"];
2741 [label="return (CommonAssemblyWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 432593"];
2742 [label="data = GetNetModuleDecodedWellKnownAttributeData(); 432594"];
2743 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 432595"];
2744 [label="if (data != null)\n                    {\n                        fieldValue = data.AssemblyDelaySignAttributeSetting;\n                    } 432596"];
2745 [label="return fieldValue; 432597"];
2746 [label="return (this.AssemblyDelaySignAttributeSetting == ThreeState.True); 432598"];
2747 [label="if (IsDelaySigned && !Identity.HasPublicKey)\n            {\n                diagnostics.Add(ErrorCode.WRN_DelaySignButNoKey, NoLocation.Singleton);\n            } 432599"];
2748 [label="DeclaringCompilation 432600"];
2749 [label="get\n            {\n                return _compilation;\n            } 432601"];
2750 [label="return _compilation; 432602"];
2751 [label="if (DeclaringCompilation.Options.PublicSign)\n            {\n                if (_compilation.Options.OutputKind.IsNetModule())\n                {\n                    diagnostics.Add(ErrorCode.ERR_PublicSignNetModule, NoLocation.Singleton);\n                }\n                else if (!Identity.HasPublicKey)\n                {\n                    diagnostics.Add(ErrorCode.ERR_PublicSignButNoKey, NoLocation.Singleton);\n                }\n            } 432603"];
2752 [label="DeclaringCompilation.Options 432604"];
2753 [label="get\n            {\n                return _options;\n            } 432605"];
2754 [label="DeclaringCompilation 432606"];
2755 [label="get\n            {\n                return _compilation;\n            } 432607"];
2756 [label="return _compilation; 432608"];
2757 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 432609"];
2758 [label="DeclaringCompilation.Options 432610"];
2759 [label="get\n            {\n                return _options;\n            } 432611"];
2760 [label="DeclaringCompilation 432612"];
2761 [label="get\n            {\n                return _compilation;\n            } 432613"];
2762 [label="return _compilation; 432614"];
2763 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 432615"];
2764 [label="DeclaringCompilation.Options 432616"];
2765 [label="get\n            {\n                return _options;\n            } 432617"];
2766 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 432618"];
2767 [label="Identity 432619"];
2768 [label="get\n            {\n                if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null);\n\n                return lazyAssemblyIdentity;\n            } 432620"];
2769 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432621"];
2770 [label="if (lazyAssemblyIdentity == null)\n                    Interlocked.CompareExchange(ref lazyAssemblyIdentity, ComputeIdentity(), null); 432622"];
2771 [label="return lazyAssemblyIdentity; 432623"];
2772 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 432624"];
2773 [label="if (DeclaringCompilation.Options.OutputKind != OutputKind.NetModule &&\n                DeclaringCompilation.Options.CryptoPublicKey.IsEmpty &&\n                Identity.HasPublicKey &&\n                !IsDelaySigned &&\n                !DeclaringCompilation.Options.PublicSign &&\n                !StrongNameKeys.CanSign &&\n                StrongNameKeys.DiagnosticOpt == null)\n            {\n                // Since the container always contains both keys, the problem is that the key file didn't contain private key.\n                diagnostics.Add(ErrorCode.ERR_SignButNoPrivateKey, NoLocation.Singleton, StrongNameKeys.KeyFilePath);\n            } 432625"];
2774 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 432626"];
2775 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 432627"];
2776 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics) 432628"];
2777 [label="param ReportDiagnosticsForSynthesizedAttributes(CSharpCompilation compilation) 432629"];
2778 [label="param ReportDiagnosticsForSynthesizedAttributes(DiagnosticBag diagnostics) 432630"];
2779 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 432631"];
2780 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 432632"];
2781 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics) 432633"];
2782 [label="param ReportDiagnosticsForUnsafeSynthesizedAttributes(CSharpCompilation compilation) 432634"];
2783 [label="param ReportDiagnosticsForUnsafeSynthesizedAttributes(DiagnosticBag diagnostics) 432635"];
2784 [label="compilation.Options 432636"];
2785 [label="get\n            {\n                return _options;\n            } 432637"];
2786 [label="CSharpCompilationOptions compilationOptions = compilation.Options; 432638"];
2787 [label="if (!compilationOptions.AllowUnsafe)\n            {\n                return;\n            } 432639"];
2788 [label="return; 432640"];
2789 [label="ReportDiagnosticsForUnsafeSynthesizedAttributes(compilation, diagnostics); 432641"];
2790 [label="compilation.Options 432642"];
2791 [label="get\n            {\n                return _options;\n            } 432643"];
2792 [label="CSharpCompilationOptions compilationOptions = compilation.Options; 432644"];
2793 [label="if (!compilationOptions.OutputKind.IsNetModule())\n            {\n                TypeSymbol compilationRelaxationsAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute);\n                Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null');\n                if (!(compilationRelaxationsAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if CompilationRelaxationsAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton);\n                }\n\n                TypeSymbol runtimeCompatibilityAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute);\n                Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null');\n                if (!(runtimeCompatibilityAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if RuntimeCompatibilityAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton);\n\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton);\n                }\n            } 432645"];
2794 [label="TypeSymbol compilationRelaxationsAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute); 432646"];
2795 [label="compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_CompilationRelaxationsAttribute) 432647"];
2796 [label="param GetWellKnownType(WellKnownType type) 432648"];
2797 [label="param GetWellKnownType(this) 432649"];
2798 [label="Debug.Assert(type.IsValid()); 432650"];
2799 [label="this.Options 432651"];
2800 [label="get\n            {\n                return _options;\n            } 432652"];
2801 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 432653"];
2802 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 432654"];
2803 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 432655"];
2804 [label="param Includes(this BinderFlags self) 432656"];
2805 [label="param Includes(BinderFlags other) 432657"];
2806 [label="return (self & other) == other; 432658"];
2807 [label="int index = (int)type - (int)WellKnownType.First; 432659"];
2808 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 432660"];
2809 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 432661"];
2810 [label="if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                } 432662"];
2811 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 432663"];
2812 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 432664"];
2813 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null); 432665"];
2814 [label="string mdName = type.GetMetadataName(); 432666"];
2815 [label="var warnings = DiagnosticBag.GetInstance(); 432667"];
2816 [label="NamedTypeSymbol? result; 432668"];
2817 [label="(AssemblySymbol, AssemblySymbol) conflicts = default; 432669"];
2818 [label="if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                } 432670"];
2819 [label="if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                } 432671"];
2820 [label="DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null; 432672"];
2821 [label="(type <= WellKnownType.CSharp7Sentinel) 432673"];
2822 [label="DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null; 432674"];
2823 [label="this.Assembly 432675"];
2824 [label="GetBoundReferenceManager() 432676"];
2825 [label="GetBoundReferenceManager(); 432677"];
2826 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432678"];
2827 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432679"];
2828 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432680"];
2829 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432681"];
2830 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432682"];
2831 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432683"];
2832 [label="this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes) 432684"];
2833 [label="param GetTypeByMetadataName(string metadataName) 432685"];
2834 [label="param GetTypeByMetadataName(bool includeReferences) 432686"];
2835 [label="param GetTypeByMetadataName(bool isWellKnownType) 432687"];
2836 [label="param GetTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 432688"];
2837 [label="param GetTypeByMetadataName(bool useCLSCompliantNameArityEncoding = false) 432689"];
2838 [label="param GetTypeByMetadataName(DiagnosticBag warnings = null) 432690"];
2839 [label="param GetTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 432691"];
2840 [label="param GetTypeByMetadataName(this) 432692"];
2841 [label="NamedTypeSymbol type; 432693"];
2842 [label="MetadataTypeName mdName; 432694"];
2843 [label="mdName 432695"];
2844 [label="if (metadataName.IndexOf('+') >= 0)\n            {\n                var parts = metadataName.Split(s_nestedTypeNameSeparators);\n                Debug.Assert(parts.Length > 0);\n                mdName = MetadataTypeName.FromFullName(parts[0], useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n\n                for (int i = 1; (object)type != null && !type.IsErrorType() && i < parts.Length; i++)\n                {\n                    mdName = MetadataTypeName.FromTypeName(parts[i]);\n                    NamedTypeSymbol temp = type.LookupMetadataType(ref mdName);\n                    type = (!isWellKnownType || IsValidWellKnownType(temp)) ? temp : null;\n                }\n            }\n            else\n            {\n                mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n            } 432696"];
2845 [label="if (metadataName.IndexOf('+') >= 0)\n            {\n                var parts = metadataName.Split(s_nestedTypeNameSeparators);\n                Debug.Assert(parts.Length > 0);\n                mdName = MetadataTypeName.FromFullName(parts[0], useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n\n                for (int i = 1; (object)type != null && !type.IsErrorType() && i < parts.Length; i++)\n                {\n                    mdName = MetadataTypeName.FromTypeName(parts[i]);\n                    NamedTypeSymbol temp = type.LookupMetadataType(ref mdName);\n                    type = (!isWellKnownType || IsValidWellKnownType(temp)) ? temp : null;\n                }\n            }\n            else\n            {\n                mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding);\n                type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n            } 432697"];
2846 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 432698"];
2847 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 432699"];
2848 [label="mdName = MetadataTypeName.FromFullName(metadataName, useCLSCompliantNameArityEncoding); 432700"];
2849 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432701"];
2850 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432702"];
2851 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432703"];
2852 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432704"];
2853 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432705"];
2854 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432706"];
2855 [label="type = GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 432707"];
2856 [label="GetTopLevelTypeByMetadataName(ref mdName, assemblyOpt: null, includeReferences: includeReferences, isWellKnownType: isWellKnownType,\n                    conflicts: out conflicts, warnings: warnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes) 432708"];
2857 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 432709"];
2858 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 432710"];
2859 [label="param GetTopLevelTypeByMetadataName(bool includeReferences) 432711"];
2860 [label="param GetTopLevelTypeByMetadataName(bool isWellKnownType) 432712"];
2861 [label="param GetTopLevelTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 432713"];
2862 [label="param GetTopLevelTypeByMetadataName(DiagnosticBag warnings = null) 432714"];
2863 [label="param GetTopLevelTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 432715"];
2864 [label="param GetTopLevelTypeByMetadataName(this) 432716"];
2865 [label="conflicts = default; 432717"];
2866 [label="NamedTypeSymbol result; 432718"];
2867 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 432719"];
2868 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 432720"];
2869 [label="result = GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt); 432721"];
2870 [label="GetTopLevelTypeByMetadataName(this, ref metadataName, assemblyOpt) 432722"];
2871 [label="param GetTopLevelTypeByMetadataName(AssemblySymbol assembly) 432723"];
2872 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 432724"];
2873 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 432725"];
2874 [label="var result = assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false); 432726"];
2875 [label="var result = assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false); 432727"];
2876 [label="assembly.LookupTopLevelMetadataType(ref metadataName, digThroughForwardedTypes: false) 432728"];
2877 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 432729"];
2878 [label="param LookupTopLevelMetadataType(bool digThroughForwardedTypes) 432730"];
2879 [label="param LookupTopLevelMetadataType(this) 432731"];
2880 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 432732"];
2881 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 432733"];
2882 [label="return LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes); 432734"];
2883 [label="LookupTopLevelMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies: null, digThroughForwardedTypes: digThroughForwardedTypes) 432735"];
2884 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ref MetadataTypeName emittedName) 432736"];
2885 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 432737"];
2886 [label="param LookupTopLevelMetadataTypeWithCycleDetection(bool digThroughForwardedTypes) 432738"];
2887 [label="param LookupTopLevelMetadataTypeWithCycleDetection(this) 432739"];
2888 [label="NamedTypeSymbol result = null; 432740"];
2889 [label="result = LookupTopLevelMetadataTypeInCache(ref emittedName); 432741"];
2890 [label="LookupTopLevelMetadataTypeInCache(ref emittedName) 432742"];
2891 [label="param LookupTopLevelMetadataTypeInCache(ref MetadataTypeName emittedName) 432743"];
2892 [label="param LookupTopLevelMetadataTypeInCache(this) 432744"];
2893 [label="NamedTypeSymbol result = null; 432745"];
2894 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 432746"];
2895 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 432747"];
2896 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 432748"];
2897 [label="return null; 432749"];
2898 [label="result = LookupTopLevelMetadataTypeInCache(ref emittedName); 432750"];
2899 [label="if ((object)result != null)\n            {\n                // We only cache result equivalent to digging through type forwarders, which\n                // might produce a forwarder specific ErrorTypeSymbol. We don't want to \n                // return that error symbol, unless digThroughForwardedTypes is true.\n                if (digThroughForwardedTypes || (!result.IsErrorType() && (object)result.ContainingAssembly == (object)this))\n                {\n                    return result;\n                }\n\n                // According to the cache, the type wasn't found, or isn't declared in this assembly (forwarded).\n                return new MissingMetadataTypeSymbol.TopLevel(this.Modules[0], ref emittedName);\n            }\n            else\n            {\n                // Now we will look for the type in each module of the assembly and pick the first type\n                // we find, this is what native VB compiler does.\n\n                var modules = this.Modules;\n                var count = modules.Length;\n                var i = 0;\n\n                result = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                }\n\n                bool foundMatchInThisAssembly = (i < count);\n\n                Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this);\n\n                if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                }\n\n                System.Diagnostics.Debug.Assert((object)result != null);\n\n                // Add result of the lookup into the cache\n                if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                }\n\n                return result;\n            } 432751"];
2900 [label="if ((object)result != null)\n            {\n                // We only cache result equivalent to digging through type forwarders, which\n                // might produce a forwarder specific ErrorTypeSymbol. We don't want to \n                // return that error symbol, unless digThroughForwardedTypes is true.\n                if (digThroughForwardedTypes || (!result.IsErrorType() && (object)result.ContainingAssembly == (object)this))\n                {\n                    return result;\n                }\n\n                // According to the cache, the type wasn't found, or isn't declared in this assembly (forwarded).\n                return new MissingMetadataTypeSymbol.TopLevel(this.Modules[0], ref emittedName);\n            }\n            else\n            {\n                // Now we will look for the type in each module of the assembly and pick the first type\n                // we find, this is what native VB compiler does.\n\n                var modules = this.Modules;\n                var count = modules.Length;\n                var i = 0;\n\n                result = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                }\n\n                bool foundMatchInThisAssembly = (i < count);\n\n                Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this);\n\n                if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                }\n\n                System.Diagnostics.Debug.Assert((object)result != null);\n\n                // Add result of the lookup into the cache\n                if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                }\n\n                return result;\n            } 432752"];
2901 [label="this.Modules 432753"];
2902 [label="get\n            {\n                return _modules;\n            } 432754"];
2903 [label="return _modules; 432755"];
2904 [label="var modules = this.Modules; 432756"];
2905 [label="var count = modules.Length; 432757"];
2906 [label="var i = 0; 432758"];
2907 [label="result = modules[i].LookupTopLevelMetadataType(ref emittedName); 432759"];
2908 [label="result = modules[i].LookupTopLevelMetadataType(ref emittedName); 432760"];
2909 [label="modules[i].LookupTopLevelMetadataType(ref emittedName) 432761"];
2910 [label="param LookupTopLevelMetadataType(ref MetadataTypeName emittedName) 432762"];
2911 [label="param LookupTopLevelMetadataType(this) 432763"];
2912 [label="NamedTypeSymbol result; 432764"];
2913 [label="this.GlobalNamespace 432765"];
2914 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 432766"];
2915 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 432767"];
2916 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 432768"];
2917 [label="var diagnostics = DiagnosticBag.GetInstance(); 432769"];
2918 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 432770"];
2919 [label="DeclaringCompilation 432771"];
2920 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 432772"];
2921 [label="_assemblySymbol.DeclaringCompilation 432773"];
2922 [label="get\n            {\n                return _compilation;\n            } 432774"];
2923 [label="return _assemblySymbol.DeclaringCompilation; 432775"];
2924 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 432776"];
2925 [label="DeclaringCompilation.MergedRootDeclaration 432777"];
2926 [label="get\n            {\n                return Declarations.GetMergedRoot(this);\n            } 432778"];
2927 [label="0x1 432779"];
2928 [label="LazyAllMembersIsSorted = 0x1 432780"];
2929 [label="d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 432781"];
2930 [label="s_declaringSyntaxReferencesSelector = d =>\n            new NamespaceDeclarationSyntaxReference(d.SyntaxReference) 432782"];
2931 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 432783"];
2932 [label="var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics); 432784"];
2933 [label="new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics) 432785"];
2934 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 432786"];
2935 [label="param SourceNamespaceSymbol(Symbol container) 432787"];
2936 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 432788"];
2937 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 432789"];
2938 [label="param SourceNamespaceSymbol(this) 432790"];
2939 [label="param SourceNamespaceSymbol(this) 432791"];
2940 [label="_module 432792"];
2941 [label="_container 432793"];
2942 [label="_mergedDeclaration 432794"];
2943 [label="_nameToMembersMap 432795"];
2944 [label="_nameToTypeMembersMap 432796"];
2945 [label="_flags 432797"];
2946 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 432798"];
2947 [label="1 432799"];
2948 [label="_treeOrdinal 432800"];
2949 [label="0 432801"];
2950 [label="_position 432802"];
2951 [label="NotInSource = new LexicalSortKey() { _treeOrdinal = -1, _position = 0 } 432803"];
2952 [label="new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 432804"];
2953 [label="1 432805"];
2954 [label="_treeOrdinal 432806"];
2955 [label="1 432807"];
2956 [label="_position 432808"];
2957 [label="NotInitialized = new LexicalSortKey() { _treeOrdinal = -1, _position = -1 } 432809"];
2958 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 432810"];
2959 [label="_treeOrdinal 432811"];
2960 [label="1 432812"];
2961 [label="int.MaxValue - 1 432813"];
2962 [label="_position 432814"];
2963 [label="SynthesizedCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue - 1 } 432815"];
2964 [label="new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 432816"];
2965 [label="_treeOrdinal 432817"];
2966 [label="_position 432818"];
2967 [label="SynthesizedCCtor = new LexicalSortKey() { _treeOrdinal = int.MaxValue, _position = int.MaxValue } 432819"];
2968 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 432820"];
2969 [label="Debug.Assert(mergedDeclaration != null); 432821"];
2970 [label="Debug.Assert(mergedDeclaration != null); 432822"];
2971 [label="_module 432823"];
2972 [label="_container 432824"];
2973 [label="_mergedDeclaration 432825"];
2974 [label="foreach (var singleDeclaration in mergedDeclaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 432826"];
2975 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 432827"];
2976 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 432828"];
2977 [label="Debug.Assert(diagnostics.IsEmptyWithoutResolution); 432829"];
2978 [label="diagnostics.Free(); 432830"];
2979 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 432831"];
2980 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 432832"];
2981 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 432833"];
2982 [label="Interlocked.CompareExchange(ref _globalNamespace, globalNS, null); 432834"];
2983 [label="return _globalNamespace; 432835"];
2984 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 432836"];
2985 [label="NamespaceSymbol scope = this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments); 432837"];
2986 [label="this.GlobalNamespace.LookupNestedNamespace(emittedName.NamespaceSegments) 432838"];
2987 [label="param LookupNestedNamespace(ImmutableArray<string> names) 432839"];
2988 [label="param LookupNestedNamespace(this) 432840"];
2989 [label="NamespaceSymbol scope = this; 432841"];
2990 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 432842"];
2991 [label="foreach (string name in names)\n            {\n                NamespaceSymbol nextScope = null;\n\n                foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                }\n\n                scope = nextScope;\n\n                if ((object)scope == null)\n                {\n                    break;\n                }\n            } 432843"];
2992 [label="NamespaceSymbol nextScope = null; 432844"];
2993 [label="foreach (NamespaceOrTypeSymbol symbol in scope.GetMembers(name))\n                {\n                    var ns = symbol as NamespaceSymbol;\n\n                    if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    }\n                } 432845"];
2994 [label="scope.GetMembers(name) 432846"];
2995 [label="param GetMembers(string name) 432847"];
2996 [label="param GetMembers(this) 432848"];
2997 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 432849"];
2998 [label="members 432850"];
2999 [label="this.GetNameToMembersMap() 432851"];
3000 [label="param GetNameToMembersMap(this) 432852"];
3001 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 432853"];
3002 [label="if (_nameToMembersMap == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                }\n\n                diagnostics.Free();\n            } 432854"];
3003 [label="var diagnostics = DiagnosticBag.GetInstance(); 432855"];
3004 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 432856"];
3005 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 432857"];
3006 [label="MakeNameToMembersMap(diagnostics) 432858"];
3007 [label="param MakeNameToMembersMap(DiagnosticBag diagnostics) 432859"];
3008 [label="param MakeNameToMembersMap(this) 432860"];
3009 [label="var builder = new NameToSymbolMapBuilder(_mergedDeclaration.Children.Length); 432861"];
3010 [label="_mergedDeclaration.Children 432862"];
3011 [label="param NameToSymbolMapBuilder(int capacity) 432863"];
3012 [label="param NameToSymbolMapBuilder(this) 432864"];
3013 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 432865"];
3014 [label="_dictionary = new Dictionary<string, object>(capacity, StringOrdinalComparer.Instance); 432866"];
3015 [label="_dictionary 432867"];
3016 [label="foreach (var declaration in _mergedDeclaration.Children)\n            {\n                builder.Add(BuildSymbol(declaration, diagnostics));\n            } 432868"];
3017 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 432869"];
3018 [label="builder.Add(BuildSymbol(declaration, diagnostics)); 432870"];
3019 [label="BuildSymbol(declaration, diagnostics) 432871"];
3020 [label="param BuildSymbol(MergedNamespaceOrTypeDeclaration declaration) 432872"];
3021 [label="param BuildSymbol(DiagnosticBag diagnostics) 432873"];
3022 [label="param BuildSymbol(this) 432874"];
3023 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Namespace:\n                    return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.Script:\n                case DeclarationKind.Submission:\n                case DeclarationKind.ImplicitClass:\n                    return new ImplicitNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                case DeclarationKind.SimpleProgram:\n                    return new SimpleProgramNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(declaration.Kind);\n            } 432875"];
3024 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 432876"];
3025 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 432877"];
3026 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 432878"];
3027 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 432879"];
3028 [label="return new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics); 432880"];
3029 [label="new SourceNamespaceSymbol(_module, this, (MergedNamespaceDeclaration)declaration, diagnostics) 432881"];
3030 [label="param SourceNamespaceSymbol(SourceModuleSymbol module) 432882"];
3031 [label="param SourceNamespaceSymbol(Symbol container) 432883"];
3032 [label="param SourceNamespaceSymbol(MergedNamespaceDeclaration mergedDeclaration) 432884"];
3033 [label="param SourceNamespaceSymbol(DiagnosticBag diagnostics) 432885"];
3034 [label="param SourceNamespaceSymbol(this) 432886"];
3035 [label="_module 432887"];
3036 [label="_container 432888"];
3037 [label="_mergedDeclaration 432889"];
3038 [label="Debug.Assert(mergedDeclaration != null); 432890"];
3039 [label="Debug.Assert(mergedDeclaration != null); 432891"];
3040 [label="builder.Add(BuildSymbol(declaration, diagnostics)) 432892"];
3041 [label="param Add(NamespaceOrTypeSymbol symbol) 432893"];
3042 [label="param Add(this) 432894"];
3043 [label="symbol.Name 432895"];
3044 [label="=> _mergedDeclaration.Name 432896"];
3045 [label="_mergedDeclaration.Name 432897"];
3046 [label="string name = symbol.Name; 432898"];
3047 [label="object item; 432899"];
3048 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 432900"];
3049 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 432901"];
3050 [label="if (_dictionary.TryGetValue(name, out item))\n                {\n                    var builder = item as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder == null)\n                    {\n                        builder = ArrayBuilder<NamespaceOrTypeSymbol>.GetInstance();\n                        builder.Add((NamespaceOrTypeSymbol)item);\n                        _dictionary[name] = builder;\n                    }\n                    builder.Add(symbol);\n                }\n                else\n                {\n                    _dictionary[name] = symbol;\n                } 432902"];
3051 [label="_dictionary 432903"];
3052 [label="builder.CreateMap() 432904"];
3053 [label="param CreateMap(this) 432905"];
3054 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 432906"];
3055 [label="var result = new Dictionary<String, ImmutableArray<NamespaceOrTypeSymbol>>(_dictionary.Count, StringOrdinalComparer.Instance); 432907"];
3056 [label="foreach (var kvp in _dictionary)\n                {\n                    object value = kvp.Value;\n                    ImmutableArray<NamespaceOrTypeSymbol> members;\n\n                    var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>;\n                    if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    }\n\n                    result.Add(kvp.Key, members);\n                } 432908"];
3057 [label="object value = kvp.Value; 432909"];
3058 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 432910"];
3059 [label="members 432911"];
3060 [label="var builder = value as ArrayBuilder<NamespaceOrTypeSymbol>; 432912"];
3061 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 432913"];
3062 [label="if (builder != null)\n                    {\n                        Debug.Assert(builder.Count > 1);\n                        bool hasNamespaces = false;\n                        for (int i = 0; (i < builder.Count) && !hasNamespaces; i++)\n                        {\n                            hasNamespaces |= (builder[i].Kind == SymbolKind.Namespace);\n                        }\n\n                        members = hasNamespaces\n                            ? builder.ToImmutable()\n                            : StaticCast<NamespaceOrTypeSymbol>.From(builder.ToDowncastedImmutable<NamedTypeSymbol>());\n\n                        builder.Free();\n                    }\n                    else\n                    {\n                        NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value;\n                        members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol));\n                    } 432914"];
3063 [label="NamespaceOrTypeSymbol symbol = (NamespaceOrTypeSymbol)value; 432915"];
3064 [label="symbol.Kind 432916"];
3065 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 432917"];
3066 [label="return SymbolKind.Namespace; 432918"];
3067 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 432919"];
3068 [label="symbol.Kind == SymbolKind.Namespace 432920"];
3069 [label="members = symbol.Kind == SymbolKind.Namespace\n                            ? ImmutableArray.Create<NamespaceOrTypeSymbol>(symbol)\n                            : StaticCast<NamespaceOrTypeSymbol>.From(ImmutableArray.Create<NamedTypeSymbol>((NamedTypeSymbol)symbol)); 432921"];
3070 [label="result.Add(kvp.Key, members); 432922"];
3071 [label="result.Add(kvp.Key, members); 432923"];
3072 [label="result.Add(kvp.Key, members); 432924"];
3073 [label="return result; 432925"];
3074 [label="var result = builder.CreateMap(); 432926"];
3075 [label="CheckMembers(this, result, diagnostics); 432927"];
3076 [label="CheckMembers(this, result, diagnostics); 432928"];
3077 [label="CheckMembers(this, result, diagnostics); 432929"];
3078 [label="CheckMembers(this, result, diagnostics) 432930"];
3079 [label="param CheckMembers(NamespaceSymbol @namespace) 432931"];
3080 [label="param CheckMembers(Dictionary<string, ImmutableArray<NamespaceOrTypeSymbol>> result) 432932"];
3081 [label="param CheckMembers(DiagnosticBag diagnostics) 432933"];
3082 [label="var memberOfArity = new Symbol[10]; 432934"];
3083 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 432935"];
3084 [label="@namespace.ContainingAssembly 432936"];
3085 [label="=> _module.ContainingAssembly 432937"];
3086 [label="_module.ContainingAssembly 432938"];
3087 [label="get\n            {\n                return _assemblySymbol;\n            } 432939"];
3088 [label="return _assemblySymbol; 432940"];
3089 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 432941"];
3090 [label="@namespace.ContainingAssembly.Modules 432942"];
3091 [label="get\n            {\n                return _modules;\n            } 432943"];
3092 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 432944"];
3093 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 432945"];
3094 [label="foreach (var name in result.Keys)\n            {\n                Array.Clear(memberOfArity, 0, memberOfArity.Length);\n                foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                }\n            } 432946"];
3095 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 432947"];
3096 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 432948"];
3097 [label="foreach (var symbol in result[name])\n                {\n                    var nts = symbol as NamedTypeSymbol;\n                    var arity = ((object)nts != null) ? nts.Arity : 0;\n                    if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    }\n\n                    var other = memberOfArity[arity];\n\n                    if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    }\n\n                    memberOfArity[arity] = symbol;\n\n                    if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    }\n                } 432949"];
3098 [label="var nts = symbol as NamedTypeSymbol; 432950"];
3099 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 432951"];
3100 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 432952"];
3101 [label="((object)nts != null) 432953"];
3102 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 432954"];
3103 [label="var other = memberOfArity[arity]; 432955"];
3104 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 432956"];
3105 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 432957"];
3106 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 432958"];
3107 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 432959"];
3108 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 432960"];
3109 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 432961"];
3110 [label="memberOfArity[arity] 432962"];
3111 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 432963"];
3112 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 432964"];
3113 [label="CheckMembers(this, result, diagnostics); 432965"];
3114 [label="return result; 432966"];
3115 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 432967"];
3116 [label="if (Interlocked.CompareExchange(ref _nameToMembersMap, MakeNameToMembersMap(diagnostics), null) == null)\n                {\n                    // NOTE: the following is not cancellable.  Once we've set the\n                    // members, we *must* do the following to make sure we're in a consistent state.\n                    this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics);\n                    RegisterDeclaredCorTypes();\n\n                    // We may produce a SymbolDeclaredEvent for the enclosing namespace before events for its contained members\n                    DeclaringCompilation.SymbolDeclaredEvent(this);\n                    var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap);\n                    Debug.Assert(wasSetThisThread);\n                } 432968"];
3117 [label="this.DeclaringCompilation 432969"];
3118 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 432970"];
3119 [label="this.Kind 432971"];
3120 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 432972"];
3121 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 432973"];
3122 [label="this.ContainingModule 432974"];
3123 [label="get\n            {\n                return _module;\n            } 432975"];
3124 [label="return _module; 432976"];
3125 [label="var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol; 432977"];
3126 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 432978"];
3127 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 432979"];
3128 [label="(object)sourceModuleSymbol == null 432980"];
3129 [label="sourceModuleSymbol.DeclaringCompilation 432981"];
3130 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 432982"];
3131 [label="this.DeclaringCompilation.DeclarationDiagnostics 432983"];
3132 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 432984"];
3133 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 432985"];
3134 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 432986"];
3135 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 432987"];
3136 [label="var diagnostics = new DiagnosticBag(); 432988"];
3137 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 432989"];
3138 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 432990"];
3139 [label="Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null); 432991"];
3140 [label="return _lazyDeclarationDiagnostics; 432992"];
3141 [label="this.DeclaringCompilation.DeclarationDiagnostics.AddRange(diagnostics); 432993"];
3142 [label="RegisterDeclaredCorTypes() 432994"];
3143 [label="param RegisterDeclaredCorTypes(this) 432995"];
3144 [label="ContainingAssembly 432996"];
3145 [label="=> _module.ContainingAssembly 432997"];
3146 [label="_module.ContainingAssembly 432998"];
3147 [label="get\n            {\n                return _assemblySymbol;\n            } 432999"];
3148 [label="return _assemblySymbol; 433000"];
3149 [label="AssemblySymbol containingAssembly = ContainingAssembly; 433001"];
3150 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 433002"];
3151 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 433003"];
3152 [label="this.CorLibrary 433004"];
3153 [label="get\n            {\n                return _corLibrary;\n            } 433005"];
3154 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 433006"];
3155 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 433007"];
3156 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 433008"];
3157 [label="RegisterDeclaredCorTypes(); 433009"];
3158 [label="DeclaringCompilation 433010"];
3159 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 433011"];
3160 [label="this.Kind 433012"];
3161 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 433013"];
3162 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 433014"];
3163 [label="this.ContainingModule 433015"];
3164 [label="get\n            {\n                return _module;\n            } 433016"];
3165 [label="return _module; 433017"];
3166 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 433018"];
3167 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 433019"];
3168 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 433020"];
3169 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 433021"];
3170 [label="param SymbolDeclaredEvent(Symbol symbol) 433022"];
3171 [label="param SymbolDeclaredEvent(this) 433023"];
3172 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 433024"];
3173 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 433025"];
3174 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 433026"];
3175 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 433027"];
3176 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 433028"];
3177 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 433029"];
3178 [label="var wasSetThisThread = _state.NotePartComplete(CompletionPart.NameToMembersMap); 433030"];
3179 [label="_state.NotePartComplete(CompletionPart.NameToMembersMap) 433031"];
3180 [label="param NotePartComplete(CompletionPart part) 433032"];
3181 [label="param NotePartComplete(this) 433033"];
3182 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 433034"];
3183 [label="Debug.Assert(wasSetThisThread); 433035"];
3184 [label="diagnostics.Free(); 433036"];
3185 [label="return _nameToMembersMap; 433037"];
3186 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 433038"];
3187 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 433039"];
3188 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 433040"];
3189 [label="return this.GetNameToMembersMap().TryGetValue(name, out members)\n                ? members.Cast<NamespaceOrTypeSymbol, Symbol>()\n                : ImmutableArray<Symbol>.Empty; 433041"];
3190 [label="this.GetNameToMembersMap().TryGetValue(name, out members) 433042"];
3191 [label="var ns = symbol as NamespaceSymbol; 433043"];
3192 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 433044"];
3193 [label="if ((object)ns != null)\n                    {\n                        if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        }\n\n                        nextScope = ns;\n                    } 433045"];
3194 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 433046"];
3195 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 433047"];
3196 [label="nextScope = ns; 433048"];
3197 [label="scope = nextScope; 433049"];
3198 [label="if ((object)scope == null)\n                {\n                    break;\n                } 433050"];
3199 [label="if ((object)scope == null)\n                {\n                    break;\n                } 433051"];
3200 [label="NamespaceSymbol nextScope = null; 433052"];
3201 [label="param BuildSymbol(this) 433053"];
3202 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 433054"];
3203 [label="return new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics); 433055"];
3204 [label="new SourceNamedTypeSymbol(this, (MergedTypeDeclaration)declaration, diagnostics) 433056"];
3205 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 433057"];
3206 [label="param SourceNamedTypeSymbol(MergedTypeDeclaration declaration) 433058"];
3207 [label="param SourceNamedTypeSymbol(DiagnosticBag diagnostics) 433059"];
3208 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 433060"];
3209 [label="param SourceNamedTypeSymbol(this) 433061"];
3210 [label="false 433062"];
3211 [label="considerName: false 433063"];
3212 [label="false 433064"];
3213 [label="considerExplicitlyImplementedInterfaces: false 433065"];
3214 [label="true 433066"];
3215 [label="considerReturnType: true 433067"];
3216 [label="false 433068"];
3217 [label="considerTypeConstraints: false 433069"];
3218 [label="true 433070"];
3219 [label="considerRefKindDifferences: true 433071"];
3220 [label="true 433072"];
3221 [label="considerCallingConvention: true 433073"];
3222 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433074"];
3223 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433075"];
3224 [label="param MemberSignatureComparer(bool considerName) 433076"];
3225 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433077"];
3226 [label="param MemberSignatureComparer(bool considerReturnType) 433078"];
3227 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433079"];
3228 [label="param MemberSignatureComparer(bool considerCallingConvention) 433080"];
3229 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433081"];
3230 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433082"];
3231 [label="param MemberSignatureComparer(this) 433083"];
3232 [label="_considerName 433084"];
3233 [label="_considerExplicitlyImplementedInterfaces 433085"];
3234 [label="_considerReturnType 433086"];
3235 [label="_considerTypeConstraints 433087"];
3236 [label="_considerCallingConvention 433088"];
3237 [label="_considerRefKindDifferences 433089"];
3238 [label="_typeComparison 433090"];
3239 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433091"];
3240 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433092"];
3241 [label="_considerName 433093"];
3242 [label="_considerExplicitlyImplementedInterfaces 433094"];
3243 [label="_considerReturnType 433095"];
3244 [label="_considerTypeConstraints 433096"];
3245 [label="_considerCallingConvention 433097"];
3246 [label="_considerRefKindDifferences 433098"];
3247 [label="_typeComparison 433099"];
3248 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433100"];
3249 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433101"];
3250 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433102"];
3251 [label="ExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerRefKindDifferences: true,\n            considerCallingConvention: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433103"];
3252 [label="true 433104"];
3253 [label="considerName: true 433105"];
3254 [label="true 433106"];
3255 [label="considerExplicitlyImplementedInterfaces: true 433107"];
3256 [label="true 433108"];
3257 [label="considerReturnType: true 433109"];
3258 [label="false 433110"];
3259 [label="considerTypeConstraints: false 433111"];
3260 [label="true 433112"];
3261 [label="considerCallingConvention: true 433113"];
3262 [label="true 433114"];
3263 [label="considerRefKindDifferences: true 433115"];
3264 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433116"];
3265 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433117"];
3266 [label="param MemberSignatureComparer(bool considerName) 433118"];
3267 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433119"];
3268 [label="param MemberSignatureComparer(bool considerReturnType) 433120"];
3269 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433121"];
3270 [label="param MemberSignatureComparer(bool considerCallingConvention) 433122"];
3271 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433123"];
3272 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433124"];
3273 [label="param MemberSignatureComparer(this) 433125"];
3274 [label="_considerName 433126"];
3275 [label="_considerExplicitlyImplementedInterfaces 433127"];
3276 [label="_considerReturnType 433128"];
3277 [label="_considerTypeConstraints 433129"];
3278 [label="_considerCallingConvention 433130"];
3279 [label="_considerRefKindDifferences 433131"];
3280 [label="_typeComparison 433132"];
3281 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433133"];
3282 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433134"];
3283 [label="_considerName 433135"];
3284 [label="_considerExplicitlyImplementedInterfaces 433136"];
3285 [label="_considerReturnType 433137"];
3286 [label="_considerTypeConstraints 433138"];
3287 [label="_considerCallingConvention 433139"];
3288 [label="_considerRefKindDifferences 433140"];
3289 [label="_typeComparison 433141"];
3290 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433142"];
3291 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433143"];
3292 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433144"];
3293 [label="CSharpImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433145"];
3294 [label="true 433146"];
3295 [label="considerName: true 433147"];
3296 [label="true 433148"];
3297 [label="considerExplicitlyImplementedInterfaces: true 433149"];
3298 [label="false 433150"];
3299 [label="considerReturnType: false 433151"];
3300 [label="false 433152"];
3301 [label="considerTypeConstraints: false 433153"];
3302 [label="false 433154"];
3303 [label="considerCallingConvention: false 433155"];
3304 [label="true 433156"];
3305 [label="considerRefKindDifferences: true 433157"];
3306 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433158"];
3307 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433159"];
3308 [label="param MemberSignatureComparer(bool considerName) 433160"];
3309 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433161"];
3310 [label="param MemberSignatureComparer(bool considerReturnType) 433162"];
3311 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433163"];
3312 [label="param MemberSignatureComparer(bool considerCallingConvention) 433164"];
3313 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433165"];
3314 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433166"];
3315 [label="param MemberSignatureComparer(this) 433167"];
3316 [label="_considerName 433168"];
3317 [label="_considerExplicitlyImplementedInterfaces 433169"];
3318 [label="_considerReturnType 433170"];
3319 [label="_considerTypeConstraints 433171"];
3320 [label="_considerCallingConvention 433172"];
3321 [label="_considerRefKindDifferences 433173"];
3322 [label="_typeComparison 433174"];
3323 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433175"];
3324 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433176"];
3325 [label="_considerName 433177"];
3326 [label="_considerExplicitlyImplementedInterfaces 433178"];
3327 [label="_considerReturnType 433179"];
3328 [label="_considerTypeConstraints 433180"];
3329 [label="_considerCallingConvention 433181"];
3330 [label="_considerRefKindDifferences 433182"];
3331 [label="_typeComparison 433183"];
3332 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433184"];
3333 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433185"];
3334 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433186"];
3335 [label="CSharpCloseImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433187"];
3336 [label="true 433188"];
3337 [label="considerName: true 433189"];
3338 [label="true 433190"];
3339 [label="considerExplicitlyImplementedInterfaces: true 433191"];
3340 [label="false 433192"];
3341 [label="considerReturnType: false 433193"];
3342 [label="false 433194"];
3343 [label="considerTypeConstraints: false 433195"];
3344 [label="false 433196"];
3345 [label="considerCallingConvention: false 433197"];
3346 [label="false 433198"];
3347 [label="considerRefKindDifferences: false 433199"];
3348 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433200"];
3349 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433201"];
3350 [label="param MemberSignatureComparer(bool considerName) 433202"];
3351 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433203"];
3352 [label="param MemberSignatureComparer(bool considerReturnType) 433204"];
3353 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433205"];
3354 [label="param MemberSignatureComparer(bool considerCallingConvention) 433206"];
3355 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433207"];
3356 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433208"];
3357 [label="param MemberSignatureComparer(this) 433209"];
3358 [label="_considerName 433210"];
3359 [label="_considerExplicitlyImplementedInterfaces 433211"];
3360 [label="_considerReturnType 433212"];
3361 [label="_considerTypeConstraints 433213"];
3362 [label="_considerCallingConvention 433214"];
3363 [label="_considerRefKindDifferences 433215"];
3364 [label="_typeComparison 433216"];
3365 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433217"];
3366 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433218"];
3367 [label="_considerName 433219"];
3368 [label="_considerExplicitlyImplementedInterfaces 433220"];
3369 [label="_considerReturnType 433221"];
3370 [label="_considerTypeConstraints 433222"];
3371 [label="_considerCallingConvention 433223"];
3372 [label="_considerRefKindDifferences 433224"];
3373 [label="_typeComparison 433225"];
3374 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433226"];
3375 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433227"];
3376 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433228"];
3377 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433229"];
3378 [label="_typeComparison 433230"];
3379 [label="DuplicateSourceComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433231"];
3380 [label="true 433232"];
3381 [label="considerName: true 433233"];
3382 [label="true 433234"];
3383 [label="considerExplicitlyImplementedInterfaces: true 433235"];
3384 [label="false 433236"];
3385 [label="considerReturnType: false 433237"];
3386 [label="false 433238"];
3387 [label="considerTypeConstraints: false 433239"];
3388 [label="false 433240"];
3389 [label="considerCallingConvention: false 433241"];
3390 [label="true 433242"];
3391 [label="considerRefKindDifferences: true 433243"];
3392 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433244"];
3393 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433245"];
3394 [label="param MemberSignatureComparer(bool considerName) 433246"];
3395 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433247"];
3396 [label="param MemberSignatureComparer(bool considerReturnType) 433248"];
3397 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433249"];
3398 [label="param MemberSignatureComparer(bool considerCallingConvention) 433250"];
3399 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433251"];
3400 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433252"];
3401 [label="param MemberSignatureComparer(this) 433253"];
3402 [label="_considerName 433254"];
3403 [label="_considerExplicitlyImplementedInterfaces 433255"];
3404 [label="_considerReturnType 433256"];
3405 [label="_considerTypeConstraints 433257"];
3406 [label="_considerCallingConvention 433258"];
3407 [label="_considerRefKindDifferences 433259"];
3408 [label="_typeComparison 433260"];
3409 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433261"];
3410 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433262"];
3411 [label="_considerName 433263"];
3412 [label="_considerExplicitlyImplementedInterfaces 433264"];
3413 [label="_considerReturnType 433265"];
3414 [label="_considerTypeConstraints 433266"];
3415 [label="_considerCallingConvention 433267"];
3416 [label="_considerRefKindDifferences 433268"];
3417 [label="_typeComparison 433269"];
3418 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433270"];
3419 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433271"];
3420 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433272"];
3421 [label="RecordAPISignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433273"];
3422 [label="true 433274"];
3423 [label="considerName: true 433275"];
3424 [label="true 433276"];
3425 [label="considerExplicitlyImplementedInterfaces: true 433277"];
3426 [label="false 433278"];
3427 [label="considerReturnType: false 433279"];
3428 [label="false 433280"];
3429 [label="considerTypeConstraints: false 433281"];
3430 [label="false 433282"];
3431 [label="considerCallingConvention: false 433283"];
3432 [label="true 433284"];
3433 [label="considerRefKindDifferences: true 433285"];
3434 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433286"];
3435 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433287"];
3436 [label="param MemberSignatureComparer(bool considerName) 433288"];
3437 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433289"];
3438 [label="param MemberSignatureComparer(bool considerReturnType) 433290"];
3439 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433291"];
3440 [label="param MemberSignatureComparer(bool considerCallingConvention) 433292"];
3441 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433293"];
3442 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433294"];
3443 [label="param MemberSignatureComparer(this) 433295"];
3444 [label="_considerName 433296"];
3445 [label="_considerExplicitlyImplementedInterfaces 433297"];
3446 [label="_considerReturnType 433298"];
3447 [label="_considerTypeConstraints 433299"];
3448 [label="_considerCallingConvention 433300"];
3449 [label="_considerRefKindDifferences 433301"];
3450 [label="_typeComparison 433302"];
3451 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433303"];
3452 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433304"];
3453 [label="_considerName 433305"];
3454 [label="_considerExplicitlyImplementedInterfaces 433306"];
3455 [label="_considerReturnType 433307"];
3456 [label="_considerTypeConstraints 433308"];
3457 [label="_considerCallingConvention 433309"];
3458 [label="_considerRefKindDifferences 433310"];
3459 [label="_typeComparison 433311"];
3460 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433312"];
3461 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433313"];
3462 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433314"];
3463 [label="PartialMethodsComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433315"];
3464 [label="true 433316"];
3465 [label="considerName: true 433317"];
3466 [label="false 433318"];
3467 [label="considerExplicitlyImplementedInterfaces: false 433319"];
3468 [label="false 433320"];
3469 [label="considerReturnType: false 433321"];
3470 [label="false 433322"];
3471 [label="considerTypeConstraints: false 433323"];
3472 [label="false 433324"];
3473 [label="considerCallingConvention: false 433325"];
3474 [label="true 433326"];
3475 [label="considerRefKindDifferences: true 433327"];
3476 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433328"];
3477 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433329"];
3478 [label="param MemberSignatureComparer(bool considerName) 433330"];
3479 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433331"];
3480 [label="param MemberSignatureComparer(bool considerReturnType) 433332"];
3481 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433333"];
3482 [label="param MemberSignatureComparer(bool considerCallingConvention) 433334"];
3483 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433335"];
3484 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433336"];
3485 [label="param MemberSignatureComparer(this) 433337"];
3486 [label="_considerName 433338"];
3487 [label="_considerExplicitlyImplementedInterfaces 433339"];
3488 [label="_considerReturnType 433340"];
3489 [label="_considerTypeConstraints 433341"];
3490 [label="_considerCallingConvention 433342"];
3491 [label="_considerRefKindDifferences 433343"];
3492 [label="_typeComparison 433344"];
3493 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433345"];
3494 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433346"];
3495 [label="_considerName 433347"];
3496 [label="_considerExplicitlyImplementedInterfaces 433348"];
3497 [label="_considerReturnType 433349"];
3498 [label="_considerTypeConstraints 433350"];
3499 [label="_considerCallingConvention 433351"];
3500 [label="_considerRefKindDifferences 433352"];
3501 [label="_typeComparison 433353"];
3502 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433354"];
3503 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433355"];
3504 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433356"];
3505 [label="CSharpOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433357"];
3506 [label="true 433358"];
3507 [label="considerName: true 433359"];
3508 [label="false 433360"];
3509 [label="considerExplicitlyImplementedInterfaces: false 433361"];
3510 [label="true 433362"];
3511 [label="considerReturnType: true 433363"];
3512 [label="false 433364"];
3513 [label="considerTypeConstraints: false 433365"];
3514 [label="false 433366"];
3515 [label="considerCallingConvention: false 433367"];
3516 [label="false 433368"];
3517 [label="considerRefKindDifferences: false 433369"];
3518 [label="TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 433370"];
3519 [label="typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames 433371"];
3520 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 433372"];
3521 [label="param MemberSignatureComparer(bool considerName) 433373"];
3522 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433374"];
3523 [label="param MemberSignatureComparer(bool considerReturnType) 433375"];
3524 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433376"];
3525 [label="param MemberSignatureComparer(bool considerCallingConvention) 433377"];
3526 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433378"];
3527 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433379"];
3528 [label="param MemberSignatureComparer(this) 433380"];
3529 [label="_considerName 433381"];
3530 [label="_considerExplicitlyImplementedInterfaces 433382"];
3531 [label="_considerReturnType 433383"];
3532 [label="_considerTypeConstraints 433384"];
3533 [label="_considerCallingConvention 433385"];
3534 [label="_considerRefKindDifferences 433386"];
3535 [label="_typeComparison 433387"];
3536 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433388"];
3537 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433389"];
3538 [label="_considerName 433390"];
3539 [label="_considerExplicitlyImplementedInterfaces 433391"];
3540 [label="_considerReturnType 433392"];
3541 [label="_considerTypeConstraints 433393"];
3542 [label="_considerCallingConvention 433394"];
3543 [label="_considerRefKindDifferences 433395"];
3544 [label="_typeComparison 433396"];
3545 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433397"];
3546 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433398"];
3547 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433399"];
3548 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433400"];
3549 [label="_typeComparison 433401"];
3550 [label="CSharpWithTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.IgnoreTupleNames) 433402"];
3551 [label="true 433403"];
3552 [label="considerName: true 433404"];
3553 [label="false 433405"];
3554 [label="considerExplicitlyImplementedInterfaces: false 433406"];
3555 [label="true 433407"];
3556 [label="considerReturnType: true 433408"];
3557 [label="false 433409"];
3558 [label="considerTypeConstraints: false 433410"];
3559 [label="false 433411"];
3560 [label="considerCallingConvention: false 433412"];
3561 [label="false 433413"];
3562 [label="considerRefKindDifferences: false 433414"];
3563 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433415"];
3564 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433416"];
3565 [label="param MemberSignatureComparer(bool considerName) 433417"];
3566 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433418"];
3567 [label="param MemberSignatureComparer(bool considerReturnType) 433419"];
3568 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433420"];
3569 [label="param MemberSignatureComparer(bool considerCallingConvention) 433421"];
3570 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433422"];
3571 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433423"];
3572 [label="param MemberSignatureComparer(this) 433424"];
3573 [label="_considerName 433425"];
3574 [label="_considerExplicitlyImplementedInterfaces 433426"];
3575 [label="_considerReturnType 433427"];
3576 [label="_considerTypeConstraints 433428"];
3577 [label="_considerCallingConvention 433429"];
3578 [label="_considerRefKindDifferences 433430"];
3579 [label="_typeComparison 433431"];
3580 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433432"];
3581 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433433"];
3582 [label="_considerName 433434"];
3583 [label="_considerExplicitlyImplementedInterfaces 433435"];
3584 [label="_considerReturnType 433436"];
3585 [label="_considerTypeConstraints 433437"];
3586 [label="_considerCallingConvention 433438"];
3587 [label="_considerRefKindDifferences 433439"];
3588 [label="_typeComparison 433440"];
3589 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433441"];
3590 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433442"];
3591 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433443"];
3592 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433444"];
3593 [label="_typeComparison 433445"];
3594 [label="CSharpWithoutTupleNamesComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433446"];
3595 [label="false 433447"];
3596 [label="considerName: false 433448"];
3597 [label="false 433449"];
3598 [label="considerExplicitlyImplementedInterfaces: false 433450"];
3599 [label="false 433451"];
3600 [label="considerReturnType: false 433452"];
3601 [label="false 433453"];
3602 [label="considerTypeConstraints: false 433454"];
3603 [label="false 433455"];
3604 [label="considerCallingConvention: false 433456"];
3605 [label="true 433457"];
3606 [label="considerRefKindDifferences: true 433458"];
3607 [label="typeComparison: TypeCompareKind.AllIgnoreOptions 433459"];
3608 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433460"];
3609 [label="param MemberSignatureComparer(bool considerName) 433461"];
3610 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433462"];
3611 [label="param MemberSignatureComparer(bool considerReturnType) 433463"];
3612 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433464"];
3613 [label="param MemberSignatureComparer(bool considerCallingConvention) 433465"];
3614 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433466"];
3615 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433467"];
3616 [label="param MemberSignatureComparer(this) 433468"];
3617 [label="_considerName 433469"];
3618 [label="_considerExplicitlyImplementedInterfaces 433470"];
3619 [label="_considerReturnType 433471"];
3620 [label="_considerTypeConstraints 433472"];
3621 [label="_considerCallingConvention 433473"];
3622 [label="_considerRefKindDifferences 433474"];
3623 [label="_typeComparison 433475"];
3624 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433476"];
3625 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433477"];
3626 [label="_considerName 433478"];
3627 [label="_considerExplicitlyImplementedInterfaces 433479"];
3628 [label="_considerReturnType 433480"];
3629 [label="_considerTypeConstraints 433481"];
3630 [label="_considerCallingConvention 433482"];
3631 [label="_considerRefKindDifferences 433483"];
3632 [label="_typeComparison 433484"];
3633 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433485"];
3634 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433486"];
3635 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433487"];
3636 [label="CSharpAccessorOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false, //Bug: DevDiv #15775\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.AllIgnoreOptions) 433488"];
3637 [label="true 433489"];
3638 [label="considerName: true 433490"];
3639 [label="false 433491"];
3640 [label="considerExplicitlyImplementedInterfaces: false 433492"];
3641 [label="true 433493"];
3642 [label="considerReturnType: true 433494"];
3643 [label="false 433495"];
3644 [label="considerTypeConstraints: false 433496"];
3645 [label="false 433497"];
3646 [label="considerCallingConvention: false 433498"];
3647 [label="true 433499"];
3648 [label="considerRefKindDifferences: true 433500"];
3649 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433501"];
3650 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433502"];
3651 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433503"];
3652 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433504"];
3653 [label="param MemberSignatureComparer(bool considerName) 433505"];
3654 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433506"];
3655 [label="param MemberSignatureComparer(bool considerReturnType) 433507"];
3656 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433508"];
3657 [label="param MemberSignatureComparer(bool considerCallingConvention) 433509"];
3658 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433510"];
3659 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433511"];
3660 [label="param MemberSignatureComparer(this) 433512"];
3661 [label="_considerName 433513"];
3662 [label="_considerExplicitlyImplementedInterfaces 433514"];
3663 [label="_considerReturnType 433515"];
3664 [label="_considerTypeConstraints 433516"];
3665 [label="_considerCallingConvention 433517"];
3666 [label="_considerRefKindDifferences 433518"];
3667 [label="_typeComparison 433519"];
3668 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433520"];
3669 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433521"];
3670 [label="_considerName 433522"];
3671 [label="_considerExplicitlyImplementedInterfaces 433523"];
3672 [label="_considerReturnType 433524"];
3673 [label="_considerTypeConstraints 433525"];
3674 [label="_considerCallingConvention 433526"];
3675 [label="_considerRefKindDifferences 433527"];
3676 [label="_typeComparison 433528"];
3677 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433529"];
3678 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433530"];
3679 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433531"];
3680 [label="CSharpCustomModifierOverrideComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433532"];
3681 [label="false 433533"];
3682 [label="considerName: false 433534"];
3683 [label="false 433535"];
3684 [label="considerExplicitlyImplementedInterfaces: false 433536"];
3685 [label="false 433537"];
3686 [label="considerReturnType: false 433538"];
3687 [label="false 433539"];
3688 [label="considerTypeConstraints: false 433540"];
3689 [label="false 433541"];
3690 [label="considerCallingConvention: false 433542"];
3691 [label="false 433543"];
3692 [label="considerRefKindDifferences: false 433544"];
3693 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433545"];
3694 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 433546"];
3695 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 433547"];
3696 [label="new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 433548"];
3697 [label="param MemberSignatureComparer(bool considerName) 433549"];
3698 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433550"];
3699 [label="param MemberSignatureComparer(bool considerReturnType) 433551"];
3700 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433552"];
3701 [label="param MemberSignatureComparer(bool considerCallingConvention) 433553"];
3702 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433554"];
3703 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433555"];
3704 [label="param MemberSignatureComparer(this) 433556"];
3705 [label="_considerName 433557"];
3706 [label="_considerExplicitlyImplementedInterfaces 433558"];
3707 [label="_considerReturnType 433559"];
3708 [label="_considerTypeConstraints 433560"];
3709 [label="_considerCallingConvention 433561"];
3710 [label="_considerRefKindDifferences 433562"];
3711 [label="_typeComparison 433563"];
3712 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433564"];
3713 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433565"];
3714 [label="_considerName 433566"];
3715 [label="_considerExplicitlyImplementedInterfaces 433567"];
3716 [label="_considerReturnType 433568"];
3717 [label="_considerTypeConstraints 433569"];
3718 [label="_considerCallingConvention 433570"];
3719 [label="_considerRefKindDifferences 433571"];
3720 [label="_typeComparison 433572"];
3721 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433573"];
3722 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433574"];
3723 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433575"];
3724 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433576"];
3725 [label="_typeComparison 433577"];
3726 [label="SloppyOverrideComparer = new MemberSignatureComparer(\n            considerName: false,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 433578"];
3727 [label="true 433579"];
3728 [label="considerName: true 433580"];
3729 [label="false 433581"];
3730 [label="considerExplicitlyImplementedInterfaces: false 433582"];
3731 [label="true 433583"];
3732 [label="considerReturnType: true 433584"];
3733 [label="false 433585"];
3734 [label="considerTypeConstraints: false 433586"];
3735 [label="true 433587"];
3736 [label="considerCallingConvention: true 433588"];
3737 [label="false 433589"];
3738 [label="considerRefKindDifferences: false 433590"];
3739 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433591"];
3740 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433592"];
3741 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433593"];
3742 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433594"];
3743 [label="param MemberSignatureComparer(bool considerName) 433595"];
3744 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433596"];
3745 [label="param MemberSignatureComparer(bool considerReturnType) 433597"];
3746 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433598"];
3747 [label="param MemberSignatureComparer(bool considerCallingConvention) 433599"];
3748 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433600"];
3749 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433601"];
3750 [label="param MemberSignatureComparer(this) 433602"];
3751 [label="_considerName 433603"];
3752 [label="_considerExplicitlyImplementedInterfaces 433604"];
3753 [label="_considerReturnType 433605"];
3754 [label="_considerTypeConstraints 433606"];
3755 [label="_considerCallingConvention 433607"];
3756 [label="_considerRefKindDifferences 433608"];
3757 [label="_typeComparison 433609"];
3758 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433610"];
3759 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433611"];
3760 [label="_considerName 433612"];
3761 [label="_considerExplicitlyImplementedInterfaces 433613"];
3762 [label="_considerReturnType 433614"];
3763 [label="_considerTypeConstraints 433615"];
3764 [label="_considerCallingConvention 433616"];
3765 [label="_considerRefKindDifferences 433617"];
3766 [label="_typeComparison 433618"];
3767 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433619"];
3768 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433620"];
3769 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433621"];
3770 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433622"];
3771 [label="_typeComparison 433623"];
3772 [label="RuntimeSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433624"];
3773 [label="true 433625"];
3774 [label="considerName: true 433626"];
3775 [label="false 433627"];
3776 [label="considerExplicitlyImplementedInterfaces: false 433628"];
3777 [label="true 433629"];
3778 [label="considerReturnType: true 433630"];
3779 [label="false 433631"];
3780 [label="considerTypeConstraints: false 433632"];
3781 [label="true 433633"];
3782 [label="considerCallingConvention: true 433634"];
3783 [label="true 433635"];
3784 [label="considerRefKindDifferences: true 433636"];
3785 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433637"];
3786 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433638"];
3787 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433639"];
3788 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433640"];
3789 [label="param MemberSignatureComparer(bool considerName) 433641"];
3790 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433642"];
3791 [label="param MemberSignatureComparer(bool considerReturnType) 433643"];
3792 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433644"];
3793 [label="param MemberSignatureComparer(bool considerCallingConvention) 433645"];
3794 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433646"];
3795 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433647"];
3796 [label="param MemberSignatureComparer(this) 433648"];
3797 [label="_considerName 433649"];
3798 [label="_considerExplicitlyImplementedInterfaces 433650"];
3799 [label="_considerReturnType 433651"];
3800 [label="_considerTypeConstraints 433652"];
3801 [label="_considerCallingConvention 433653"];
3802 [label="_considerRefKindDifferences 433654"];
3803 [label="_typeComparison 433655"];
3804 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433656"];
3805 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433657"];
3806 [label="_considerName 433658"];
3807 [label="_considerExplicitlyImplementedInterfaces 433659"];
3808 [label="_considerReturnType 433660"];
3809 [label="_considerTypeConstraints 433661"];
3810 [label="_considerCallingConvention 433662"];
3811 [label="_considerRefKindDifferences 433663"];
3812 [label="_typeComparison 433664"];
3813 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433665"];
3814 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433666"];
3815 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433667"];
3816 [label="RuntimePlusRefOutSignatureComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433668"];
3817 [label="true 433669"];
3818 [label="considerName: true 433670"];
3819 [label="true 433671"];
3820 [label="considerExplicitlyImplementedInterfaces: true 433672"];
3821 [label="true 433673"];
3822 [label="considerReturnType: true 433674"];
3823 [label="false 433675"];
3824 [label="considerTypeConstraints: false 433676"];
3825 [label="true 433677"];
3826 [label="considerCallingConvention: true 433678"];
3827 [label="false 433679"];
3828 [label="considerRefKindDifferences: false 433680"];
3829 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433681"];
3830 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433682"];
3831 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433683"];
3832 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433684"];
3833 [label="param MemberSignatureComparer(bool considerName) 433685"];
3834 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433686"];
3835 [label="param MemberSignatureComparer(bool considerReturnType) 433687"];
3836 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433688"];
3837 [label="param MemberSignatureComparer(bool considerCallingConvention) 433689"];
3838 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433690"];
3839 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433691"];
3840 [label="param MemberSignatureComparer(this) 433692"];
3841 [label="_considerName 433693"];
3842 [label="_considerExplicitlyImplementedInterfaces 433694"];
3843 [label="_considerReturnType 433695"];
3844 [label="_considerTypeConstraints 433696"];
3845 [label="_considerCallingConvention 433697"];
3846 [label="_considerRefKindDifferences 433698"];
3847 [label="_typeComparison 433699"];
3848 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433700"];
3849 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433701"];
3850 [label="_considerName 433702"];
3851 [label="_considerExplicitlyImplementedInterfaces 433703"];
3852 [label="_considerReturnType 433704"];
3853 [label="_considerTypeConstraints 433705"];
3854 [label="_considerCallingConvention 433706"];
3855 [label="_considerRefKindDifferences 433707"];
3856 [label="_typeComparison 433708"];
3857 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433709"];
3858 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433710"];
3859 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433711"];
3860 [label="_typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly; 433712"];
3861 [label="_typeComparison 433713"];
3862 [label="RuntimeImplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: false, // constraints are checked by caller instead\n            considerCallingConvention: true,\n            considerRefKindDifferences: false,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433714"];
3863 [label="true 433715"];
3864 [label="considerName: true 433716"];
3865 [label="true 433717"];
3866 [label="considerExplicitlyImplementedInterfaces: true 433718"];
3867 [label="true 433719"];
3868 [label="considerReturnType: true 433720"];
3869 [label="true 433721"];
3870 [label="considerTypeConstraints: true 433722"];
3871 [label="true 433723"];
3872 [label="considerCallingConvention: true 433724"];
3873 [label="true 433725"];
3874 [label="considerRefKindDifferences: true 433726"];
3875 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433727"];
3876 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433728"];
3877 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433729"];
3878 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433730"];
3879 [label="param MemberSignatureComparer(bool considerName) 433731"];
3880 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433732"];
3881 [label="param MemberSignatureComparer(bool considerReturnType) 433733"];
3882 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433734"];
3883 [label="param MemberSignatureComparer(bool considerCallingConvention) 433735"];
3884 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433736"];
3885 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433737"];
3886 [label="param MemberSignatureComparer(this) 433738"];
3887 [label="_considerName 433739"];
3888 [label="_considerExplicitlyImplementedInterfaces 433740"];
3889 [label="_considerReturnType 433741"];
3890 [label="_considerTypeConstraints 433742"];
3891 [label="_considerCallingConvention 433743"];
3892 [label="_considerRefKindDifferences 433744"];
3893 [label="_typeComparison 433745"];
3894 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433746"];
3895 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433747"];
3896 [label="_considerName 433748"];
3897 [label="_considerExplicitlyImplementedInterfaces 433749"];
3898 [label="_considerReturnType 433750"];
3899 [label="_considerTypeConstraints 433751"];
3900 [label="_considerCallingConvention 433752"];
3901 [label="_considerRefKindDifferences 433753"];
3902 [label="_typeComparison 433754"];
3903 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433755"];
3904 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433756"];
3905 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433757"];
3906 [label="CSharpSignatureAndConstraintsAndReturnTypeComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: true,\n            considerReturnType: true,\n            considerTypeConstraints: true,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433758"];
3907 [label="true 433759"];
3908 [label="considerName: true 433760"];
3909 [label="false 433761"];
3910 [label="considerExplicitlyImplementedInterfaces: false 433762"];
3911 [label="true 433763"];
3912 [label="considerReturnType: true 433764"];
3913 [label="false 433765"];
3914 [label="considerTypeConstraints: false 433766"];
3915 [label="true 433767"];
3916 [label="considerCallingConvention: true 433768"];
3917 [label="true 433769"];
3918 [label="considerRefKindDifferences: true 433770"];
3919 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433771"];
3920 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433772"];
3921 [label="typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers 433773"];
3922 [label="new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433774"];
3923 [label="param MemberSignatureComparer(bool considerName) 433775"];
3924 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433776"];
3925 [label="param MemberSignatureComparer(bool considerReturnType) 433777"];
3926 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433778"];
3927 [label="param MemberSignatureComparer(bool considerCallingConvention) 433779"];
3928 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433780"];
3929 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433781"];
3930 [label="param MemberSignatureComparer(this) 433782"];
3931 [label="_considerName 433783"];
3932 [label="_considerExplicitlyImplementedInterfaces 433784"];
3933 [label="_considerReturnType 433785"];
3934 [label="_considerTypeConstraints 433786"];
3935 [label="_considerCallingConvention 433787"];
3936 [label="_considerRefKindDifferences 433788"];
3937 [label="_typeComparison 433789"];
3938 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433790"];
3939 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433791"];
3940 [label="_considerName 433792"];
3941 [label="_considerExplicitlyImplementedInterfaces 433793"];
3942 [label="_considerReturnType 433794"];
3943 [label="_considerTypeConstraints 433795"];
3944 [label="_considerCallingConvention 433796"];
3945 [label="_considerRefKindDifferences 433797"];
3946 [label="_typeComparison 433798"];
3947 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433799"];
3948 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433800"];
3949 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433801"];
3950 [label="RetargetedExplicitImplementationComparer = new MemberSignatureComparer(\n            considerName: true,\n            considerExplicitlyImplementedInterfaces: false, //we'll be comparing interface members anyway\n            considerReturnType: true,\n            considerTypeConstraints: false,\n            considerCallingConvention: true,\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreNativeIntegers) 433802"];
3951 [label="false 433803"];
3952 [label="considerName: false 433804"];
3953 [label="false 433805"];
3954 [label="considerExplicitlyImplementedInterfaces: false 433806"];
3955 [label="false 433807"];
3956 [label="considerReturnType: false 433808"];
3957 [label="false 433809"];
3958 [label="considerTypeConstraints: false 433810"];
3959 [label="false 433811"];
3960 [label="considerCallingConvention: false 433812"];
3961 [label="true 433813"];
3962 [label="considerRefKindDifferences: true 433814"];
3963 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433815"];
3964 [label="TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 433816"];
3965 [label="typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames 433817"];
3966 [label="new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 433818"];
3967 [label="param MemberSignatureComparer(bool considerName) 433819"];
3968 [label="param MemberSignatureComparer(bool considerExplicitlyImplementedInterfaces) 433820"];
3969 [label="param MemberSignatureComparer(bool considerReturnType) 433821"];
3970 [label="param MemberSignatureComparer(bool considerTypeConstraints) 433822"];
3971 [label="param MemberSignatureComparer(bool considerCallingConvention) 433823"];
3972 [label="param MemberSignatureComparer(bool considerRefKindDifferences) 433824"];
3973 [label="param MemberSignatureComparer(TypeCompareKind typeComparison = TypeCompareKind.IgnoreDynamic | TypeCompareKind.IgnoreNativeIntegers) 433825"];
3974 [label="param MemberSignatureComparer(this) 433826"];
3975 [label="_considerName 433827"];
3976 [label="_considerExplicitlyImplementedInterfaces 433828"];
3977 [label="_considerReturnType 433829"];
3978 [label="_considerTypeConstraints 433830"];
3979 [label="_considerCallingConvention 433831"];
3980 [label="_considerRefKindDifferences 433832"];
3981 [label="_typeComparison 433833"];
3982 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433834"];
3983 [label="Debug.Assert(!considerExplicitlyImplementedInterfaces || considerName, 'Doesn't make sense to consider interfaces separately from name.'); 433835"];
3984 [label="_considerName 433836"];
3985 [label="_considerExplicitlyImplementedInterfaces 433837"];
3986 [label="_considerReturnType 433838"];
3987 [label="_considerTypeConstraints 433839"];
3988 [label="_considerCallingConvention 433840"];
3989 [label="_considerRefKindDifferences 433841"];
3990 [label="_typeComparison 433842"];
3991 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433843"];
3992 [label="Debug.Assert((_typeComparison & TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly) == 0,\n                         $'Rely on the {nameof(considerRefKindDifferences)} flag to set this to ensure all cases are handled.'); 433844"];
3993 [label="if (!considerRefKindDifferences)\n            {\n                _typeComparison |= TypeCompareKind.FunctionPointerRefMatchesOutInRefReadonly;\n            } 433845"];
3994 [label="CrefComparer = new MemberSignatureComparer(\n            considerName: false, //handled by lookup\n            considerExplicitlyImplementedInterfaces: false,\n            considerReturnType: false,\n            considerTypeConstraints: false,\n            considerCallingConvention: false, //ignore static-ness\n            considerRefKindDifferences: true,\n            typeComparison: TypeCompareKind.IgnoreCustomModifiersAndArraySizesAndLowerBounds | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes | TypeCompareKind.IgnoreDynamicAndTupleNames) 433846"];
3995 [label="MemberSignatureComparer.RecordAPISignatureComparer 433847"];
3996 [label="PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 433848"];
3997 [label="s_duplicateRecordMemberSignatureDictionary =\n            PooledDictionary<Symbol, Symbol>.CreatePool(MemberSignatureComparer.RecordAPISignatureComparer) 433849"];
3998 [label="EmptyComparer.Instance 433850"];
3999 [label="new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 433851"];
4000 [label="s_emptyTypeMembers = new Dictionary<string, ImmutableArray<NamedTypeSymbol>>(EmptyComparer.Instance) 433852"];
4001 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 433853"];
4002 [label="ReportBadReturn =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, bool topLevel, Location location)\n            => diagnostics.Add(topLevel ?\n                ErrorCode.WRN_TopLevelNullabilityMismatchInReturnTypeOnOverride :\n                ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride,\n                location) 433854"];
4003 [label="(DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 433855"];
4004 [label="ReportBadParameter =\n            (DiagnosticBag diagnostics, MethodSymbol overriddenMethod, MethodSymbol overridingMethod, ParameterSymbol overridingParameter, bool topLevel, Location location)\n            => diagnostics.Add(\n                topLevel ? ErrorCode.WRN_TopLevelNullabilityMismatchInParameterTypeOnOverride : ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride,\n                location,\n                new FormattedSymbol(overridingParameter, SymbolDisplayFormat.ShortFormat)) 433856"];
4005 [label="containingSymbol 433857"];
4006 [label="declaration 433858"];
4007 [label="diagnostics 433859"];
4008 [label="tupleData 433860"];
4009 [label="param SourceNamedTypeSymbol(this) 433861"];
4010 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 433862"];
4011 [label="param SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration) 433863"];
4012 [label="param SourceMemberContainerTypeSymbol(DiagnosticBag diagnostics) 433864"];
4013 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 433865"];
4014 [label="param SourceMemberContainerTypeSymbol(this) 433866"];
4015 [label="symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 433867"];
4016 [label="IsInstanceFieldOrEvent = symbol =>\n        {\n            if (!symbol.IsStatic)\n            {\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Field:\n                    case SymbolKind.Event:\n                        return true;\n                }\n            }\n            return false;\n        } 433868"];
4017 [label="type => !type.HasType 433869"];
4018 [label="TypeWithAnnotationsIsNullFunction = type => !type.HasType 433870"];
4019 [label="type => type.HasType && type.Type.IsErrorType() 433871"];
4020 [label="TypeWithAnnotationsIsErrorType = type => type.HasType && type.Type.IsErrorType() 433872"];
4021 [label="8 433873"];
4022 [label="ValueTupleRestPosition = 8 433874"];
4023 [label="1 433875"];
4024 [label="ValueTupleRestPosition - 1 433876"];
4025 [label="ValueTupleRestIndex = ValueTupleRestPosition - 1 433877"];
4026 [label="'ValueTuple' 433878"];
4027 [label="ValueTupleTypeName = 'ValueTuple' 433879"];
4028 [label="'Rest' 433880"];
4029 [label="ValueTupleRestFieldName = 'Rest' 433881"];
4030 [label="{\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 433882"];
4031 [label="tupleTypes = {\n                                                            WellKnownType.System_ValueTuple_T1,\n                                                            WellKnownType.System_ValueTuple_T2,\n                                                            WellKnownType.System_ValueTuple_T3,\n                                                            WellKnownType.System_ValueTuple_T4,\n                                                            WellKnownType.System_ValueTuple_T5,\n                                                            WellKnownType.System_ValueTuple_T6,\n                                                            WellKnownType.System_ValueTuple_T7,\n                                                            WellKnownType.System_ValueTuple_TRest } 433883"];
4032 [label="{\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 433884"];
4033 [label="tupleCtors = {\n                                                            WellKnownMember.System_ValueTuple_T1__ctor,\n                                                            WellKnownMember.System_ValueTuple_T2__ctor,\n                                                            WellKnownMember.System_ValueTuple_T3__ctor,\n                                                            WellKnownMember.System_ValueTuple_T4__ctor,\n                                                            WellKnownMember.System_ValueTuple_T5__ctor,\n                                                            WellKnownMember.System_ValueTuple_T6__ctor,\n                                                            WellKnownMember.System_ValueTuple_T7__ctor,\n                                                            WellKnownMember.System_ValueTuple_TRest__ctor } 433885"];
4034 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433886"];
4035 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 } 433887"];
4036 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 } 433888"];
4037 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 } 433889"];
4038 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 } 433890"];
4039 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 } 433891"];
4040 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 } 433892"];
4041 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 } 433893"];
4042 [label="new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest } 433894"];
4043 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433895"];
4044 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433896"];
4045 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433897"];
4046 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433898"];
4047 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433899"];
4048 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433900"];
4049 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433901"];
4050 [label="new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433902"];
4051 [label="tupleMembers = new[]{\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T1__Item1 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T2__Item1,\n                                                            WellKnownMember.System_ValueTuple_T2__Item2 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T3__Item1,\n                                                            WellKnownMember.System_ValueTuple_T3__Item2,\n                                                            WellKnownMember.System_ValueTuple_T3__Item3 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T4__Item1,\n                                                            WellKnownMember.System_ValueTuple_T4__Item2,\n                                                            WellKnownMember.System_ValueTuple_T4__Item3,\n                                                            WellKnownMember.System_ValueTuple_T4__Item4 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T5__Item1,\n                                                            WellKnownMember.System_ValueTuple_T5__Item2,\n                                                            WellKnownMember.System_ValueTuple_T5__Item3,\n                                                            WellKnownMember.System_ValueTuple_T5__Item4,\n                                                            WellKnownMember.System_ValueTuple_T5__Item5 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T6__Item1,\n                                                            WellKnownMember.System_ValueTuple_T6__Item2,\n                                                            WellKnownMember.System_ValueTuple_T6__Item3,\n                                                            WellKnownMember.System_ValueTuple_T6__Item4,\n                                                            WellKnownMember.System_ValueTuple_T6__Item5,\n                                                            WellKnownMember.System_ValueTuple_T6__Item6 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_T7__Item1,\n                                                            WellKnownMember.System_ValueTuple_T7__Item2,\n                                                            WellKnownMember.System_ValueTuple_T7__Item3,\n                                                            WellKnownMember.System_ValueTuple_T7__Item4,\n                                                            WellKnownMember.System_ValueTuple_T7__Item5,\n                                                            WellKnownMember.System_ValueTuple_T7__Item6,\n                                                            WellKnownMember.System_ValueTuple_T7__Item7 },\n\n                                                        new[]{\n                                                            WellKnownMember.System_ValueTuple_TRest__Item1,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item2,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item3,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item4,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item5,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item6,\n                                                            WellKnownMember.System_ValueTuple_TRest__Item7,\n                                                            WellKnownMember.System_ValueTuple_TRest__Rest }\n        } 433903"];
4052 [label="tupleData 433904"];
4053 [label="param SourceMemberContainerTypeSymbol(this) 433905"];
4054 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 433906"];
4055 [label="param NamedTypeSymbol(this) 433907"];
4056 [label="'<invalid-global-code>' 433908"];
4057 [label="ImplicitTypeName = '<invalid-global-code>' 433909"];
4058 [label="0 433910"];
4059 [label="TypeCompareKind.ConsiderEverything 433911"];
4060 [label="new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 433912"];
4061 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433913"];
4062 [label="param SymbolEqualityComparer(this) 433914"];
4063 [label="_comparison 433915"];
4064 [label="_comparison 433916"];
4065 [label="ConsiderEverything = new SymbolEqualityComparer(TypeCompareKind.ConsiderEverything) 433917"];
4066 [label="TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433918"];
4067 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433919"];
4068 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433920"];
4069 [label="param SymbolEqualityComparer(this) 433921"];
4070 [label="_comparison 433922"];
4071 [label="_comparison 433923"];
4072 [label="IgnoringTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433924"];
4073 [label="TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433925"];
4074 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433926"];
4075 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433927"];
4076 [label="param SymbolEqualityComparer(this) 433928"];
4077 [label="_comparison 433929"];
4078 [label="_comparison 433930"];
4079 [label="IgnoringDynamicTupleNamesAndNullability = new SymbolEqualityComparer(TypeCompareKind.IgnoreDynamicAndTupleNames | TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433931"];
4080 [label="TypeCompareKind.IgnoreNullableModifiersForReferenceTypes 433932"];
4081 [label="new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433933"];
4082 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433934"];
4083 [label="param SymbolEqualityComparer(this) 433935"];
4084 [label="_comparison 433936"];
4085 [label="_comparison 433937"];
4086 [label="IgnoringNullable = new SymbolEqualityComparer(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433938"];
4087 [label="TypeCompareKind.ObliviousNullableModifierMatchesAny 433939"];
4088 [label="new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 433940"];
4089 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433941"];
4090 [label="param SymbolEqualityComparer(this) 433942"];
4091 [label="_comparison 433943"];
4092 [label="_comparison 433944"];
4093 [label="ObliviousNullableModifierMatchesAny = new SymbolEqualityComparer(TypeCompareKind.ObliviousNullableModifierMatchesAny) 433945"];
4094 [label="TypeCompareKind.AllIgnoreOptions 433946"];
4095 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 433947"];
4096 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433948"];
4097 [label="param SymbolEqualityComparer(this) 433949"];
4098 [label="_comparison 433950"];
4099 [label="_comparison 433951"];
4100 [label="AllIgnoreOptions = new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions) 433952"];
4101 [label="TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes) 433953"];
4102 [label="new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 433954"];
4103 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433955"];
4104 [label="param SymbolEqualityComparer(this) 433956"];
4105 [label="_comparison 433957"];
4106 [label="_comparison 433958"];
4107 [label="AllIgnoreOptionsPlusNullableWithUnknownMatchesAny =\n                                                                  new SymbolEqualityComparer(TypeCompareKind.AllIgnoreOptions & ~(TypeCompareKind.IgnoreNullableModifiersForReferenceTypes)) 433959"];
4108 [label="TypeCompareKind.CLRSignatureCompareOptions 433960"];
4109 [label="new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 433961"];
4110 [label="param SymbolEqualityComparer(TypeCompareKind comparison) 433962"];
4111 [label="param SymbolEqualityComparer(this) 433963"];
4112 [label="_comparison 433964"];
4113 [label="_comparison 433965"];
4114 [label="CLRSignature = new SymbolEqualityComparer(TypeCompareKind.CLRSignatureCompareOptions) 433966"];
4115 [label="SymbolEqualityComparer.CLRSignature 433967"];
4116 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 433968"];
4117 [label="new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 433969"];
4118 [label="EmptyInterfacesAndTheirBaseInterfaces =\n                                                new MultiDictionary<NamedTypeSymbol, NamedTypeSymbol>(0, SymbolEqualityComparer.CLRSignature) 433970"];
4119 [label="new InterfaceInfo() 433971"];
4120 [label="param InterfaceInfo(this) 433972"];
4121 [label="interfacesAndTheirBaseInterfaces 433973"];
4122 [label="_implementationForInterfaceMemberMap 433974"];
4123 [label="explicitInterfaceImplementationMap 433975"];
4124 [label="s_noInterfaces = new InterfaceInfo() 433976"];
4125 [label="(type) => type.SetUnknownNullabilityForReferenceTypes() 433977"];
4126 [label="s_setUnknownNullability =\n            (type) => type.SetUnknownNullabilityForReferenceTypes() 433978"];
4127 [label="param NamedTypeSymbol(this) 433979"];
4128 [label="param TypeSymbol(this) 433980"];
4129 [label="param TypeSymbol(this) 433981"];
4130 [label="_lazyAbstractMembers 433982"];
4131 [label="_lazyInterfaceInfo 433983"];
4132 [label="_lazyAdapter 433984"];
4133 [label="_hasNoBaseCycles 433985"];
4134 [label="_lazyTupleData 433986"];
4135 [label="_lazyTupleData 433987"];
4136 [label="_declModifiers 433988"];
4137 [label="_containingSymbol 433989"];
4138 [label="declaration 433990"];
4139 [label="new DeclaredMembersAndInitializers() 433991"];
4140 [label="param DeclaredMembersAndInitializers(this) 433992"];
4141 [label="HaveIndexers 433993"];
4142 [label="RecordDeclarationWithParameters 433994"];
4143 [label="RecordPrimaryConstructor 433995"];
4144 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 433996"];
4145 [label="IsNullableEnabledForInstanceConstructorsAndFields 433997"];
4146 [label="IsNullableEnabledForStaticConstructorsAndFields 433998"];
4147 [label="UninitializedSentinel = new DeclaredMembersAndInitializers() 433999"];
4148 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 434000"];
4149 [label="_lazyMembersAndInitializers 434001"];
4150 [label="_lazyMembersDictionary 434002"];
4151 [label="_lazyEarlyAttributeDecodingMembersDictionary 434003"];
4152 [label="_lazyTypeMembers 434004"];
4153 [label="_lazyKnownCircularStruct 434005"];
4154 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 434006"];
4155 [label="_lazyContainsExtensionMethods 434007"];
4156 [label="_lazyAnyMemberHasAttributes 434008"];
4157 [label="_containingSymbol 434009"];
4158 [label="this.declaration 434010"];
4159 [label="TypeKind typeKind = declaration.Kind.ToTypeKind(); 434011"];
4160 [label="declaration.Kind.ToTypeKind() 434012"];
4161 [label="param ToTypeKind(this DeclarationKind kind) 434013"];
4162 [label="switch (kind)\n            {\n                case DeclarationKind.Class:\n                case DeclarationKind.Script:\n                case DeclarationKind.ImplicitClass:\n                case DeclarationKind.SimpleProgram:\n                case DeclarationKind.Record:\n                    return TypeKind.Class;\n\n                case DeclarationKind.Submission:\n                    return TypeKind.Submission;\n\n                case DeclarationKind.Delegate:\n                    return TypeKind.Delegate;\n\n                case DeclarationKind.Enum:\n                    return TypeKind.Enum;\n\n                case DeclarationKind.Interface:\n                    return TypeKind.Interface;\n\n                case DeclarationKind.Struct:\n                    return TypeKind.Struct;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 434014"];
4163 [label="return TypeKind.Class; 434015"];
4164 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 434016"];
4165 [label="var modifiers = MakeModifiers(typeKind, diagnostics); 434017"];
4166 [label="MakeModifiers(typeKind, diagnostics) 434018"];
4167 [label="param MakeModifiers(TypeKind typeKind) 434019"];
4168 [label="param MakeModifiers(DiagnosticBag diagnostics) 434020"];
4169 [label="param MakeModifiers(this) 434021"];
4170 [label="this.ContainingSymbol 434022"];
4171 [label="get\n            {\n                return _containingSymbol;\n            } 434023"];
4172 [label="return _containingSymbol; 434024"];
4173 [label="Symbol containingSymbol = this.ContainingSymbol; 434025"];
4174 [label="DeclarationModifiers defaultAccess; 434026"];
4175 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 434027"];
4176 [label="containingSymbol.Kind 434028"];
4177 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434029"];
4178 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 434030"];
4179 [label="defaultAccess = DeclarationModifiers.Internal; 434031"];
4180 [label="switch (typeKind)\n            {\n                case TypeKind.Class:\n                case TypeKind.Submission:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe;\n\n                    if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    }\n\n                    break;\n                case TypeKind.Struct:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Ref | DeclarationModifiers.ReadOnly | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Interface:\n                    allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Unsafe;\n                    break;\n                case TypeKind.Delegate:\n                    allowedModifiers |= DeclarationModifiers.Unsafe;\n                    break;\n            } 434032"];
4181 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 434033"];
4182 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 434034"];
4183 [label="this.IsRecord 434035"];
4184 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 434036"];
4185 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 434037"];
4186 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 434038"];
4187 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 434039"];
4188 [label="allowedModifiers |= DeclarationModifiers.Static; 434040"];
4189 [label="bool modifierErrors; 434041"];
4190 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434042"];
4191 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434043"];
4192 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434044"];
4193 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434045"];
4194 [label="MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors) 434046"];
4195 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 434047"];
4196 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 434048"];
4197 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 434049"];
4198 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 434050"];
4199 [label="param MakeAndCheckTypeModifiers(this) 434051"];
4200 [label="modifierErrors = false; 434052"];
4201 [label="var result = DeclarationModifiers.Unset; 434053"];
4202 [label="var partCount = declaration.Declarations.Length; 434054"];
4203 [label="var missingPartial = false; 434055"];
4204 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 434056"];
4205 [label="for (var i = 0; i < partCount; i++)\n            {\n                var decl = declaration.Declarations[i];\n                var mods = decl.Modifiers;\n\n                if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                }\n\n                if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n\n                if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                }\n\n            } 434057"];
4206 [label="var decl = declaration.Declarations[i]; 434058"];
4207 [label="var mods = decl.Modifiers; 434059"];
4208 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 434060"];
4209 [label="if (!modifierErrors)\n                {\n                    mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors);\n\n                    // It is an error for the same modifier to appear multiple times.\n                    if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    }\n                } 434061"];
4210 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434062"];
4211 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434063"];
4212 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434064"];
4213 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434065"];
4214 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434066"];
4215 [label="mods = ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors); 434067"];
4216 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 434068"];
4217 [label="param CheckModifiers(DeclarationModifiers modifiers) 434069"];
4218 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 434070"];
4219 [label="param CheckModifiers(Location errorLocation) 434071"];
4220 [label="param CheckModifiers(DiagnosticBag diagnostics) 434072"];
4221 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 434073"];
4222 [label="param CheckModifiers(out bool modifierErrors) 434074"];
4223 [label="modifierErrors = false; 434075"];
4224 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 434076"];
4225 [label="DeclarationModifiers result = modifiers & allowedModifiers; 434077"];
4226 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 434078"];
4227 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 434079"];
4228 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 434080"];
4229 [label="return result; 434081"];
4230 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 434082"];
4231 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434083"];
4232 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434084"];
4233 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434085"];
4234 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 434086"];
4235 [label="param CheckAccessibility(DeclarationModifiers modifiers) 434087"];
4236 [label="param CheckAccessibility(Symbol symbol) 434088"];
4237 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 434089"];
4238 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 434090"];
4239 [label="IsValidAccessibility(modifiers) 434091"];
4240 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 434092"];
4241 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 434093"];
4242 [label="return true; 434094"];
4243 [label="symbol.Kind 434095"];
4244 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 434096"];
4245 [label="return SymbolKind.NamedType; 434097"];
4246 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434098"];
4247 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434099"];
4248 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434100"];
4249 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434101"];
4250 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434102"];
4251 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 434103"];
4252 [label="return null; 434104"];
4253 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434105"];
4254 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 434106"];
4255 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 434107"];
4256 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 434108"];
4257 [label="result = mods; 434109"];
4258 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 434110"];
4259 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 434111"];
4260 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 434112"];
4261 [label="this.Name 434113"];
4262 [label="get\n            {\n                return declaration.Name;\n            } 434114"];
4263 [label="return declaration.Name; 434115"];
4264 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 434116"];
4265 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 434117"];
4266 [label="return result; 434118"];
4267 [label="(type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 434119"];
4268 [label="s_hasInvalidTypeParameterFunc =\n            (type, containingSymbol, unused) => HasInvalidTypeParameter(type, containingSymbol) 434120"];
4269 [label="this.CheckUnsafeModifier(mods, diagnostics); 434121"];
4270 [label="this.CheckUnsafeModifier(mods, diagnostics); 434122"];
4271 [label="this.CheckUnsafeModifier(mods, diagnostics); 434123"];
4272 [label="this.CheckUnsafeModifier(mods, diagnostics) 434124"];
4273 [label="param CheckUnsafeModifier(this Symbol symbol) 434125"];
4274 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 434126"];
4275 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 434127"];
4276 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 434128"];
4277 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 434129"];
4278 [label="symbol.Locations 434130"];
4279 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 434131"];
4280 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 434132"];
4281 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 434133"];
4282 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 434134"];
4283 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics); 434135"];
4284 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 434136"];
4285 [label="param CheckUnsafeModifier(this Symbol symbol) 434137"];
4286 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 434138"];
4287 [label="param CheckUnsafeModifier(Location errorLocation) 434139"];
4288 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 434140"];
4289 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 434141"];
4290 [label="this.CheckUnsafeModifier(mods, diagnostics); 434142"];
4291 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434143"];
4292 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434144"];
4293 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434145"];
4294 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434146"];
4295 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434147"];
4296 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434148"];
4297 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 434149"];
4298 [label="return mods; 434150"];
4299 [label="foreach (var singleDeclaration in declaration.Declarations)\n            {\n                diagnostics.AddRange(singleDeclaration.Diagnostics);\n            } 434151"];
4300 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 434152"];
4301 [label="diagnostics.AddRange(singleDeclaration.Diagnostics); 434153"];
4302 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 434154"];
4303 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 434155"];
4304 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 434156"];
4305 [label="_declModifiers 434157"];
4306 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 434158"];
4307 [label="access == (int)DeclarationModifiers.Public 434159"];
4308 [label="MakeSpecialType() 434160"];
4309 [label="param MakeSpecialType(this) 434161"];
4310 [label="ContainingSymbol 434162"];
4311 [label="get\n            {\n                return _containingSymbol;\n            } 434163"];
4312 [label="return _containingSymbol; 434164"];
4313 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434165"];
4314 [label="ContainingSymbol.Kind 434166"];
4315 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434167"];
4316 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434168"];
4317 [label="ContainingSymbol 434169"];
4318 [label="get\n            {\n                return _containingSymbol;\n            } 434170"];
4319 [label="return _containingSymbol; 434171"];
4320 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434172"];
4321 [label="ContainingSymbol.ContainingAssembly 434173"];
4322 [label="=> _module.ContainingAssembly 434174"];
4323 [label="_module.ContainingAssembly 434175"];
4324 [label="get\n            {\n                return _assemblySymbol;\n            } 434176"];
4325 [label="return _assemblySymbol; 434177"];
4326 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 434178"];
4327 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 434179"];
4328 [label="this.CorLibrary 434180"];
4329 [label="get\n            {\n                return _corLibrary;\n            } 434181"];
4330 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434182"];
4331 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434183"];
4332 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434184"];
4333 [label="return SpecialType.None; 434185"];
4334 [label="0 434186"];
4335 [label="SpecialTypeOffset = 0 434187"];
4336 [label="6 434188"];
4337 [label="SpecialTypeSize = 6 434189"];
4338 [label="SpecialTypeOffset + SpecialTypeSize 434190"];
4339 [label="ManagedKindOffset = SpecialTypeOffset + SpecialTypeSize 434191"];
4340 [label="2 434192"];
4341 [label="ManagedKindSize = 2 434193"];
4342 [label="ManagedKindOffset + ManagedKindSize 434194"];
4343 [label="FieldDefinitionsNotedOffset = ManagedKindOffset + ManagedKindSize 434195"];
4344 [label="1 434196"];
4345 [label="FieldDefinitionsNotedSize = 1 434197"];
4346 [label="FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 434198"];
4347 [label="FlattenedMembersIsSortedOffset = FieldDefinitionsNotedOffset + FieldDefinitionsNotedSize 434199"];
4348 [label="1 434200"];
4349 [label="FlattenedMembersIsSortedSize = 1 434201"];
4350 [label="FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 434202"];
4351 [label="TypeKindOffset = FlattenedMembersIsSortedOffset + FlattenedMembersIsSortedSize 434203"];
4352 [label="4 434204"];
4353 [label="TypeKindSize = 4 434205"];
4354 [label="TypeKindOffset + TypeKindSize 434206"];
4355 [label="NullableContextOffset = TypeKindOffset + TypeKindSize 434207"];
4356 [label="3 434208"];
4357 [label="NullableContextSize = 3 434209"];
4358 [label="1 434210"];
4359 [label="1 << SpecialTypeSize 434211"];
4360 [label="1 434212"];
4361 [label="(1 << SpecialTypeSize) - 1 434213"];
4362 [label="SpecialTypeMask = (1 << SpecialTypeSize) - 1 434214"];
4363 [label="1 434215"];
4364 [label="1 << ManagedKindSize 434216"];
4365 [label="1 434217"];
4366 [label="(1 << ManagedKindSize) - 1 434218"];
4367 [label="ManagedKindMask = (1 << ManagedKindSize) - 1 434219"];
4368 [label="1 434220"];
4369 [label="1 << TypeKindSize 434221"];
4370 [label="1 434222"];
4371 [label="(1 << TypeKindSize) - 1 434223"];
4372 [label="TypeKindMask = (1 << TypeKindSize) - 1 434224"];
4373 [label="1 434225"];
4374 [label="1 << NullableContextSize 434226"];
4375 [label="1 434227"];
4376 [label="(1 << NullableContextSize) - 1 434228"];
4377 [label="NullableContextMask = (1 << NullableContextSize) - 1 434229"];
4378 [label="1 434230"];
4379 [label="1 << FieldDefinitionsNotedOffset 434231"];
4380 [label="FieldDefinitionsNotedBit = 1 << FieldDefinitionsNotedOffset 434232"];
4381 [label="1 434233"];
4382 [label="1 << FlattenedMembersIsSortedOffset 434234"];
4383 [label="FlattenedMembersIsSortedBit = 1 << FlattenedMembersIsSortedOffset 434235"];
4384 [label="Debug.Assert(EnumUtilities.ContainsAllValues<SpecialType>(SpecialTypeMask)); 434236"];
4385 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 434237"];
4386 [label="_flags = new Flags(specialType, typeKind); 434238"];
4387 [label="_flags = new Flags(specialType, typeKind); 434239"];
4388 [label="_flags = new Flags(specialType, typeKind); 434240"];
4389 [label="new Flags(specialType, typeKind) 434241"];
4390 [label="param Flags(SpecialType specialType) 434242"];
4391 [label="param Flags(TypeKind typeKind) 434243"];
4392 [label="param Flags(this) 434244"];
4393 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 434245"];
4394 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 434246"];
4395 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 434247"];
4396 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 434248"];
4397 [label="_flags = specialTypeInt | typeKindInt; 434249"];
4398 [label="_flags 434250"];
4399 [label="_flags 434251"];
4400 [label="this.ContainingType 434252"];
4401 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 434253"];
4402 [label="return _containingSymbol as NamedTypeSymbol; 434254"];
4403 [label="var containingType = this.ContainingType; 434255"];
4404 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 434256"];
4405 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 434257"];
4406 [label="state.NotePartComplete(CompletionPart.TypeArguments); 434258"];
4407 [label="state.NotePartComplete(CompletionPart.TypeArguments) 434259"];
4408 [label="param NotePartComplete(CompletionPart part) 434260"];
4409 [label="param NotePartComplete(this) 434261"];
4410 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 434262"];
4411 [label="_lazyCustomAttributesBag 434263"];
4412 [label="_lazyDocComment 434264"];
4413 [label="_lazyExpandedDocComment 434265"];
4414 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 434266"];
4415 [label="_lazyDeclaredBases 434267"];
4416 [label="new UnsupportedMetadataTypeSymbol() 434268"];
4417 [label="param UnsupportedMetadataTypeSymbol(BadImageFormatException? mrEx = null) 434269"];
4418 [label="param UnsupportedMetadataTypeSymbol(this) 434270"];
4419 [label="param ErrorTypeSymbol(this) 434271"];
4420 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 434272"];
4421 [label="tupleData 434273"];
4422 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 434274"];
4423 [label="param NamedTypeSymbol(this) 434275"];
4424 [label="param TypeSymbol(this) 434276"];
4425 [label="param NamespaceOrTypeSymbol(this) 434277"];
4426 [label="param Symbol(this) 434278"];
4427 [label="_lazyISymbol 434279"];
4428 [label="_lazyAbstractMembers 434280"];
4429 [label="_lazyInterfaceInfo 434281"];
4430 [label="_lazyAdapter 434282"];
4431 [label="_hasNoBaseCycles 434283"];
4432 [label="_lazyTupleData 434284"];
4433 [label="_lazyTupleData 434285"];
4434 [label="_mrEx 434286"];
4435 [label="_mrEx 434287"];
4436 [label="UnknownResultType = new UnsupportedMetadataTypeSymbol() 434288"];
4437 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 434289"];
4438 [label="_lazyEnumValueField 434290"];
4439 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 434291"];
4440 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 434292"];
4441 [label="containingSymbol.Kind 434293"];
4442 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434294"];
4443 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 434295"];
4444 [label="get\n            {\n                return declaration.Name;\n            } 434296"];
4445 [label="return declaration.Name; 434297"];
4446 [label="param BuildSymbol(this) 434298"];
4447 [label="param SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 434299"];
4448 [label="param SourceNamedTypeSymbol(TupleExtraData tupleData = null) 434300"];
4449 [label="containingSymbol 434301"];
4450 [label="tupleData 434302"];
4451 [label="param SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol) 434303"];
4452 [label="param SourceMemberContainerTypeSymbol(TupleExtraData? tupleData = null) 434304"];
4453 [label="tupleData 434305"];
4454 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 434306"];
4455 [label="param NamedTypeSymbol(this) 434307"];
4456 [label="param TypeSymbol(this) 434308"];
4457 [label="_lazyAbstractMembers 434309"];
4458 [label="_lazyInterfaceInfo 434310"];
4459 [label="_lazyAdapter 434311"];
4460 [label="_hasNoBaseCycles 434312"];
4461 [label="_lazyTupleData 434313"];
4462 [label="_lazyTupleData 434314"];
4463 [label="_declModifiers 434315"];
4464 [label="_containingSymbol 434316"];
4465 [label="declaration 434317"];
4466 [label="_lazyDeclaredMembersAndInitializers = DeclaredMembersAndInitializers.UninitializedSentinel 434318"];
4467 [label="_lazyMembersAndInitializers 434319"];
4468 [label="_lazyMembersDictionary 434320"];
4469 [label="_lazyEarlyAttributeDecodingMembersDictionary 434321"];
4470 [label="_lazyTypeMembers 434322"];
4471 [label="_lazyKnownCircularStruct 434323"];
4472 [label="_lazyLexicalSortKey = LexicalSortKey.NotInitialized 434324"];
4473 [label="_lazyContainsExtensionMethods 434325"];
4474 [label="_lazyAnyMemberHasAttributes 434326"];
4475 [label="_containingSymbol 434327"];
4476 [label="param MakeModifiers(DiagnosticBag diagnostics) 434328"];
4477 [label="this.ContainingSymbol 434329"];
4478 [label="get\n            {\n                return _containingSymbol;\n            } 434330"];
4479 [label="return _containingSymbol; 434331"];
4480 [label="Symbol containingSymbol = this.ContainingSymbol; 434332"];
4481 [label="DeclarationModifiers defaultAccess; 434333"];
4482 [label="var allowedModifiers = DeclarationModifiers.AccessibilityMask; 434334"];
4483 [label="containingSymbol.Kind 434335"];
4484 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434336"];
4485 [label="if (containingSymbol.Kind == SymbolKind.Namespace)\n            {\n                defaultAccess = DeclarationModifiers.Internal;\n            }\n            else\n            {\n                allowedModifiers |= DeclarationModifiers.New;\n\n                if (((NamedTypeSymbol)containingSymbol).IsInterface)\n                {\n                    defaultAccess = DeclarationModifiers.Public;\n                }\n                else\n                {\n                    defaultAccess = DeclarationModifiers.Private;\n                }\n            } 434337"];
4486 [label="defaultAccess = DeclarationModifiers.Internal; 434338"];
4487 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 434339"];
4488 [label="allowedModifiers |= DeclarationModifiers.Partial | DeclarationModifiers.Sealed | DeclarationModifiers.Abstract\n                        | DeclarationModifiers.Unsafe; 434340"];
4489 [label="if (!this.IsRecord)\n                    {\n                        allowedModifiers |= DeclarationModifiers.Static;\n                    } 434341"];
4490 [label="allowedModifiers |= DeclarationModifiers.Static; 434342"];
4491 [label="bool modifierErrors; 434343"];
4492 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434344"];
4493 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434345"];
4494 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434346"];
4495 [label="var mods = MakeAndCheckTypeModifiers(\n                defaultAccess,\n                allowedModifiers,\n                diagnostics,\n                out modifierErrors); 434347"];
4496 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess) 434348"];
4497 [label="param MakeAndCheckTypeModifiers(DeclarationModifiers allowedModifiers) 434349"];
4498 [label="param MakeAndCheckTypeModifiers(DiagnosticBag diagnostics) 434350"];
4499 [label="param MakeAndCheckTypeModifiers(out bool modifierErrors) 434351"];
4500 [label="var result = DeclarationModifiers.Unset; 434352"];
4501 [label="var missingPartial = false; 434353"];
4502 [label="var mods = decl.Modifiers; 434354"];
4503 [label="if (partCount > 1 && (mods & DeclarationModifiers.Partial) == 0)\n                {\n                    missingPartial = true;\n                } 434355"];
4504 [label="ModifierUtils.CheckModifiers(\n                        mods, allowedModifiers, declaration.Declarations[i].NameLocation, diagnostics,\n                        modifierTokens: null, modifierErrors: out modifierErrors) 434356"];
4505 [label="param CheckModifiers(DeclarationModifiers modifiers) 434357"];
4506 [label="param CheckModifiers(DeclarationModifiers allowedModifiers) 434358"];
4507 [label="param CheckModifiers(Location errorLocation) 434359"];
4508 [label="param CheckModifiers(DiagnosticBag diagnostics) 434360"];
4509 [label="param CheckModifiers(SyntaxTokenList? modifierTokens) 434361"];
4510 [label="param CheckModifiers(out bool modifierErrors) 434362"];
4511 [label="modifierErrors = false; 434363"];
4512 [label="DeclarationModifiers errorModifiers = modifiers & ~allowedModifiers; 434364"];
4513 [label="DeclarationModifiers result = modifiers & allowedModifiers; 434365"];
4514 [label="while (errorModifiers != DeclarationModifiers.None)\n            {\n                DeclarationModifiers oneError = errorModifiers & ~(errorModifiers - 1);\n                Debug.Assert(oneError != DeclarationModifiers.None);\n                errorModifiers = errorModifiers & ~oneError;\n\n                switch (oneError)\n                {\n                    case DeclarationModifiers.Partial:\n                        // Provide a specialized error message in the case of partial.\n                        ReportPartialError(errorLocation, diagnostics, modifierTokens);\n                        break;\n\n                    default:\n                        diagnostics.Add(ErrorCode.ERR_BadMemberFlag, errorLocation, ConvertSingleModifierToSyntaxText(oneError));\n                        break;\n                }\n\n                modifierErrors = true;\n            } 434366"];
4515 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 434367"];
4516 [label="if ((result & DeclarationModifiers.PrivateProtected) != 0)\n            {\n                modifierErrors |= !Binder.CheckFeatureAvailability(errorLocation.SourceTree, MessageID.IDS_FeaturePrivateProtected, diagnostics, errorLocation);\n            } 434368"];
4517 [label="return result; 434369"];
4518 [label="if (!modifierErrors)\n                    {\n                        var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false);\n                        if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        }\n                    } 434370"];
4519 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434371"];
4520 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434372"];
4521 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434373"];
4522 [label="ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false) 434374"];
4523 [label="param CheckAccessibility(DeclarationModifiers modifiers) 434375"];
4524 [label="param CheckAccessibility(Symbol symbol) 434376"];
4525 [label="param CheckAccessibility(bool isExplicitInterfaceImplementation) 434377"];
4526 [label="if (!IsValidAccessibility(modifiers))\n            {\n                // error CS0107: More than one protection modifier\n                return new CSDiagnosticInfo(ErrorCode.ERR_BadMemberProtection);\n            } 434378"];
4527 [label="IsValidAccessibility(modifiers) 434379"];
4528 [label="param IsValidAccessibility(DeclarationModifiers modifiers) 434380"];
4529 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                case DeclarationModifiers.Private:\n                case DeclarationModifiers.Protected:\n                case DeclarationModifiers.Internal:\n                case DeclarationModifiers.Public:\n                case DeclarationModifiers.ProtectedInternal:\n                case DeclarationModifiers.PrivateProtected:\n                    return true;\n\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return false;\n            } 434381"];
4530 [label="return true; 434382"];
4531 [label="symbol.Kind 434383"];
4532 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 434384"];
4533 [label="return SymbolKind.NamedType; 434385"];
4534 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434386"];
4535 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434387"];
4536 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434388"];
4537 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434389"];
4538 [label="if (!isExplicitInterfaceImplementation &&\n                (symbol.Kind != SymbolKind.Method || (modifiers & DeclarationModifiers.Partial) == 0) &&\n                (modifiers & DeclarationModifiers.Static) == 0)\n            {\n                switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                }\n            } 434390"];
4539 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n                {\n                    case DeclarationModifiers.Protected:\n                    case DeclarationModifiers.ProtectedInternal:\n                    case DeclarationModifiers.PrivateProtected:\n\n                        if (symbol.ContainingType?.IsInterface == true && !symbol.ContainingAssembly.RuntimeSupportsDefaultInterfaceImplementation)\n                        {\n                            return new CSDiagnosticInfo(ErrorCode.ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember);\n                        }\n                        break;\n                } 434391"];
4540 [label="return null; 434392"];
4541 [label="var info = ModifierUtils.CheckAccessibility(mods, this, isExplicitInterfaceImplementation: false); 434393"];
4542 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 434394"];
4543 [label="if (info != null)\n                        {\n                            diagnostics.Add(info, this.Locations[0]);\n                            modifierErrors = true;\n                        } 434395"];
4544 [label="if (result == DeclarationModifiers.Unset)\n                {\n                    result = mods;\n                }\n                else\n                {\n                    result |= mods;\n                } 434396"];
4545 [label="result = mods; 434397"];
4546 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 434398"];
4547 [label="if ((result & DeclarationModifiers.AccessibilityMask) == 0)\n            {\n                result |= defaultAccess;\n            } 434399"];
4548 [label="if (missingPartial)\n            {\n                if ((result & DeclarationModifiers.Partial) == 0)\n                {\n                    // duplicate definitions\n                    switch (this.ContainingSymbol.Kind)\n                    {\n                        case SymbolKind.Namespace:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, declaration.Declarations[i].NameLocation, this.Name, this.ContainingSymbol);\n                                modifierErrors = true;\n                            }\n                            break;\n\n                        case SymbolKind.NamedType:\n                            for (var i = 1; i < partCount; i++)\n                            {\n                                if (ContainingType!.Locations.Length == 1 || ContainingType.IsPartial())\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, declaration.Declarations[i].NameLocation, this.ContainingSymbol, this.Name);\n                                modifierErrors = true;\n                            }\n                            break;\n                    }\n                }\n                else\n                {\n                    for (var i = 0; i < partCount; i++)\n                    {\n                        var singleDeclaration = declaration.Declarations[i];\n                        var mods = singleDeclaration.Modifiers;\n                        if ((mods & DeclarationModifiers.Partial) == 0)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_MissingPartial, singleDeclaration.NameLocation, this.Name);\n                            modifierErrors = true;\n                        }\n                    }\n                }\n            } 434400"];
4549 [label="this.Name 434401"];
4550 [label="get\n            {\n                return declaration.Name;\n            } 434402"];
4551 [label="return declaration.Name; 434403"];
4552 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 434404"];
4553 [label="if (this.Name == SyntaxFacts.GetText(SyntaxKind.RecordKeyword))\n            {\n                foreach (var syntaxRef in SyntaxReferences)\n                {\n                    SyntaxToken? identifier = syntaxRef.GetSyntax() switch\n                    {\n                        BaseTypeDeclarationSyntax typeDecl => typeDecl.Identifier,\n                        DelegateDeclarationSyntax delegateDecl => delegateDecl.Identifier,\n                        _ => null\n                    };\n\n                    // Lafhis\n                    ReportTypeNamedRecord(identifier != null ? identifier.Value.Text : null, this.DeclaringCompilation, diagnostics, (identifier != null ? identifier.Value.GetLocation() : null) ?? Location.None);\n                }\n            } 434405"];
4554 [label="return result; 434406"];
4555 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 434407"];
4556 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 434408"];
4557 [label="symbol.CheckUnsafeModifier(modifiers, symbol.Locations[0], diagnostics) 434409"];
4558 [label="param CheckUnsafeModifier(this Symbol symbol) 434410"];
4559 [label="param CheckUnsafeModifier(DeclarationModifiers modifiers) 434411"];
4560 [label="param CheckUnsafeModifier(Location errorLocation) 434412"];
4561 [label="param CheckUnsafeModifier(DiagnosticBag diagnostics) 434413"];
4562 [label="if (((modifiers & DeclarationModifiers.Unsafe) == DeclarationModifiers.Unsafe) && !symbol.CompilationAllowsUnsafe())\n            {\n                Debug.Assert(errorLocation != null);\n                diagnostics.Add(ErrorCode.ERR_IllegalUnsafe, errorLocation);\n            } 434414"];
4563 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434415"];
4564 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434416"];
4565 [label="if (!modifierErrors &&\n                (mods & DeclarationModifiers.Abstract) != 0 &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) != 0)\n            {\n                diagnostics.Add(ErrorCode.ERR_AbstractSealedStatic, Locations[0], this);\n            } 434417"];
4566 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434418"];
4567 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434419"];
4568 [label="if (!modifierErrors &&\n                (mods & (DeclarationModifiers.Sealed | DeclarationModifiers.Static)) == (DeclarationModifiers.Sealed | DeclarationModifiers.Static))\n            {\n                diagnostics.Add(ErrorCode.ERR_SealedStaticClass, Locations[0], this);\n            } 434420"];
4569 [label="switch (typeKind)\n            {\n                case TypeKind.Interface:\n                    mods |= DeclarationModifiers.Abstract;\n                    break;\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n                case TypeKind.Delegate:\n                    mods |= DeclarationModifiers.Sealed;\n                    break;\n            } 434421"];
4570 [label="return mods; 434422"];
4571 [label="int access = (int)(modifiers & DeclarationModifiers.AccessibilityMask); 434423"];
4572 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 434424"];
4573 [label="if ((access & (access - 1)) != 0)\n            {   // more than one access modifier\n                if ((modifiers & DeclarationModifiers.Partial) != 0)\n                    diagnostics.Add(ErrorCode.ERR_PartialModifierConflict, Locations[0], this);\n                access = access & ~(access - 1); // narrow down to one access modifier\n                modifiers &= ~DeclarationModifiers.AccessibilityMask; // remove them all\n                modifiers |= (DeclarationModifiers)access; // except the one\n            } 434425"];
4574 [label="_declModifiers 434426"];
4575 [label="var specialType = access == (int)DeclarationModifiers.Public\n                ? MakeSpecialType()\n                : SpecialType.None; 434427"];
4576 [label="access == (int)DeclarationModifiers.Public 434428"];
4577 [label="MakeSpecialType() 434429"];
4578 [label="param MakeSpecialType(this) 434430"];
4579 [label="ContainingSymbol 434431"];
4580 [label="get\n            {\n                return _containingSymbol;\n            } 434432"];
4581 [label="return _containingSymbol; 434433"];
4582 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434434"];
4583 [label="ContainingSymbol.Kind 434435"];
4584 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434436"];
4585 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434437"];
4586 [label="ContainingSymbol 434438"];
4587 [label="get\n            {\n                return _containingSymbol;\n            } 434439"];
4588 [label="return _containingSymbol; 434440"];
4589 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434441"];
4590 [label="ContainingSymbol.ContainingAssembly 434442"];
4591 [label="=> _module.ContainingAssembly 434443"];
4592 [label="_module.ContainingAssembly 434444"];
4593 [label="get\n            {\n                return _assemblySymbol;\n            } 434445"];
4594 [label="return _assemblySymbol; 434446"];
4595 [label="ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 434447"];
4596 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 434448"];
4597 [label="this.CorLibrary 434449"];
4598 [label="get\n            {\n                return _corLibrary;\n            } 434450"];
4599 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434451"];
4600 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434452"];
4601 [label="if (ContainingSymbol.Kind == SymbolKind.Namespace &&\n                ContainingSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                //for a namespace, the emitted name is a dot-separated list of containing namespaces\n                var emittedName = ContainingSymbol.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat);\n                emittedName = MetadataHelpers.BuildQualifiedName(emittedName, MetadataName);\n\n                return SpecialTypes.GetTypeFromMetadataName(emittedName);\n            }\n            else\n            {\n                return SpecialType.None;\n            } 434453"];
4602 [label="return SpecialType.None; 434454"];
4603 [label="_flags = new Flags(specialType, typeKind); 434455"];
4604 [label="_flags = new Flags(specialType, typeKind); 434456"];
4605 [label="new Flags(specialType, typeKind) 434457"];
4606 [label="param Flags(SpecialType specialType) 434458"];
4607 [label="param Flags(TypeKind typeKind) 434459"];
4608 [label="param Flags(this) 434460"];
4609 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 434461"];
4610 [label="int specialTypeInt = ((int)specialType & SpecialTypeMask) << SpecialTypeOffset; 434462"];
4611 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 434463"];
4612 [label="int typeKindInt = ((int)typeKind & TypeKindMask) << TypeKindOffset; 434464"];
4613 [label="_flags = specialTypeInt | typeKindInt; 434465"];
4614 [label="_flags 434466"];
4615 [label="_flags 434467"];
4616 [label="this.ContainingType 434468"];
4617 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 434469"];
4618 [label="return _containingSymbol as NamedTypeSymbol; 434470"];
4619 [label="var containingType = this.ContainingType; 434471"];
4620 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 434472"];
4621 [label="if (containingType?.IsSealed == true && this.DeclaredAccessibility.HasProtected())\n            {\n                diagnostics.Add(AccessCheck.GetProtectedMemberInSealedTypeError(ContainingType), Locations[0], this);\n            } 434473"];
4622 [label="state.NotePartComplete(CompletionPart.TypeArguments); 434474"];
4623 [label="state.NotePartComplete(CompletionPart.TypeArguments) 434475"];
4624 [label="param NotePartComplete(CompletionPart part) 434476"];
4625 [label="_lazyCustomAttributesBag 434477"];
4626 [label="_lazyDocComment 434478"];
4627 [label="_lazyExpandedDocComment 434479"];
4628 [label="_lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.Unknown 434480"];
4629 [label="_lazyDeclaredBases 434481"];
4630 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 434482"];
4631 [label="_lazyEnumValueField 434483"];
4632 [label="_lazyEnumUnderlyingType = ErrorTypeSymbol.UnknownResultType 434484"];
4633 [label="switch (declaration.Kind)\n            {\n                case DeclarationKind.Struct:\n                case DeclarationKind.Interface:\n                case DeclarationKind.Enum:\n                case DeclarationKind.Delegate:\n                case DeclarationKind.Class:\n                case DeclarationKind.Record:\n                    break;\n                default:\n                    Debug.Assert(false, 'bad declaration kind');\n                    break;\n            } 434485"];
4634 [label="containingSymbol.Kind 434486"];
4635 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434487"];
4636 [label="if (containingSymbol.Kind == SymbolKind.NamedType)\n            {\n                // Nested types are never unified.\n                _lazyIsExplicitDefinitionOfNoPiaLocalType = ThreeState.False;\n            } 434488"];
4637 [label="get\n            {\n                return declaration.Name;\n            } 434489"];
4638 [label="return declaration.Name; 434490"];
4639 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 434491"];
4640 [label="members 434492"];
4641 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 434493"];
4642 [label="return SymbolKind.NamedType; 434494"];
4643 [label="ImmutableArray<NamespaceOrTypeSymbol> members; 434495"];
4644 [label="members 434496"];
4645 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 434497"];
4646 [label="param CheckMembers(NamespaceSymbol @namespace) 434498"];
4647 [label="param CheckMembers(DiagnosticBag diagnostics) 434499"];
4648 [label="var memberOfArity = new Symbol[10]; 434500"];
4649 [label="MergedNamespaceSymbol mergedAssemblyNamespace = null; 434501"];
4650 [label="@namespace.ContainingAssembly 434502"];
4651 [label="=> _module.ContainingAssembly 434503"];
4652 [label="_module.ContainingAssembly 434504"];
4653 [label="get\n            {\n                return _assemblySymbol;\n            } 434505"];
4654 [label="return _assemblySymbol; 434506"];
4655 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 434507"];
4656 [label="@namespace.ContainingAssembly.Modules 434508"];
4657 [label="get\n            {\n                return _modules;\n            } 434509"];
4658 [label="if (@namespace.ContainingAssembly.Modules.Length > 1)\n            {\n                mergedAssemblyNamespace = @namespace.ContainingAssembly.GetAssemblyNamespace(@namespace) as MergedNamespaceSymbol;\n            } 434510"];
4659 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 434511"];
4660 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 434512"];
4661 [label="var nts = symbol as NamedTypeSymbol; 434513"];
4662 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 434514"];
4663 [label="var arity = ((object)nts != null) ? nts.Arity : 0; 434515"];
4664 [label="((object)nts != null) 434516"];
4665 [label="nts.Arity 434517"];
4666 [label="get\n            {\n                return declaration.Arity;\n            } 434518"];
4667 [label="return declaration.Arity; 434519"];
4668 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 434520"];
4669 [label="var other = memberOfArity[arity]; 434521"];
4670 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434522"];
4671 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434523"];
4672 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434524"];
4673 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434525"];
4674 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 434526"];
4675 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 434527"];
4676 [label="memberOfArity[arity] 434528"];
4677 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 434529"];
4678 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 434530"];
4679 [label="nts.DeclaredAccessibility 434531"];
4680 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 434532"];
4681 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 434533"];
4682 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 434534"];
4683 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 434535"];
4684 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 434536"];
4685 [label="return Accessibility.Public; 434537"];
4686 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 434538"];
4687 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 434539"];
4688 [label="Array.Clear(memberOfArity, 0, memberOfArity.Length); 434540"];
4689 [label="if (arity >= memberOfArity.Length)\n                    {\n                        Array.Resize(ref memberOfArity, arity + 1);\n                    } 434541"];
4690 [label="var other = memberOfArity[arity]; 434542"];
4691 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434543"];
4692 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434544"];
4693 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434545"];
4694 [label="if ((object)other == null && (object)mergedAssemblyNamespace != null)\n                    {\n                        // Check for collision with declarations from added modules.\n                        foreach (NamespaceSymbol constituent in mergedAssemblyNamespace.ConstituentNamespaces)\n                        {\n                            if ((object)constituent != (object)@namespace)\n                            {\n                                // For whatever reason native compiler only detects conflicts against types.\n                                // It doesn't complain when source declares a type with the same name as \n                                // a namespace in added module, but complains when source declares a namespace \n                                // with the same name as a type in added module.\n                                var types = constituent.GetTypeMembers(symbol.Name, arity);\n\n                                if (types.Length > 0)\n                                {\n                                    other = types[0];\n                                    // Since the error doesn't specify what added module this type belongs to, we can stop searching\n                                    // at the first match.\n                                    break;\n                                }\n                            }\n                        }\n                    } 434546"];
4695 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 434547"];
4696 [label="if ((object)other != null)\n                    {\n                        // Lafhis\n                        if (nts is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)nts).IsPartial == true &&\n                            other is SourceNamedTypeSymbol && ((SourceNamedTypeSymbol)other).IsPartial == true)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, symbol.Locations.FirstOrNone(), symbol);\n                        }\n                        else\n                        {\n                            diagnostics.Add(ErrorCode.ERR_DuplicateNameInNS, symbol.Locations.FirstOrNone(), name, @namespace);\n                        }\n                    } 434548"];
4697 [label="if ((object)nts != null)\n                    {\n                        //types declared at the namespace level may only have declared accessibility of public or internal (Section 3.5.1)\n                        Accessibility declaredAccessibility = nts.DeclaredAccessibility;\n                        if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        }\n                    } 434549"];
4698 [label="nts.DeclaredAccessibility 434550"];
4699 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 434551"];
4700 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 434552"];
4701 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 434553"];
4702 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 434554"];
4703 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 434555"];
4704 [label="return Accessibility.Public; 434556"];
4705 [label="Accessibility declaredAccessibility = nts.DeclaredAccessibility; 434557"];
4706 [label="if (declaredAccessibility != Accessibility.Public && declaredAccessibility != Accessibility.Internal)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_NoNamespacePrivate, symbol.Locations.FirstOrNone());\n                        } 434558"];
4707 [label="this.Kind 434559"];
4708 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 434560"];
4709 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 434561"];
4710 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 434562"];
4711 [label="RegisterDeclaredCorTypes() 434563"];
4712 [label="param RegisterDeclaredCorTypes(this) 434564"];
4713 [label="ContainingAssembly 434565"];
4714 [label="=> _module.ContainingAssembly 434566"];
4715 [label="_module.ContainingAssembly 434567"];
4716 [label="get\n            {\n                return _assemblySymbol;\n            } 434568"];
4717 [label="return _assemblySymbol; 434569"];
4718 [label="AssemblySymbol containingAssembly = ContainingAssembly; 434570"];
4719 [label="containingAssembly.KeepLookingForDeclaredSpecialTypes 434571"];
4720 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 434572"];
4721 [label="this.CorLibrary 434573"];
4722 [label="get\n            {\n                return _corLibrary;\n            } 434574"];
4723 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434575"];
4724 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 434576"];
4725 [label="if (containingAssembly.KeepLookingForDeclaredSpecialTypes)\n            {\n                // Register newly declared COR types\n                foreach (var array in _nameToMembersMap.Values)\n                {\n                    foreach (var member in array)\n                    {\n                        var type = member as NamedTypeSymbol;\n\n                        if ((object)type != null && type.SpecialType != SpecialType.None)\n                        {\n                            containingAssembly.RegisterDeclaredSpecialType(type);\n\n                            if (!containingAssembly.KeepLookingForDeclaredSpecialTypes)\n                            {\n                                return;\n                            }\n                        }\n                    }\n                }\n            } 434577"];
4726 [label="RegisterDeclaredCorTypes(); 434578"];
4727 [label="Debug.Assert(wasSetThisThread); 434579"];
4728 [label="scope = nextScope; 434580"];
4729 [label="if ((object)scope == null)\n                {\n                    break;\n                } 434581"];
4730 [label="if ((object)scope == null)\n                {\n                    break;\n                } 434582"];
4731 [label="return scope; 434583"];
4732 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 434584"];
4733 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 434585"];
4734 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 434586"];
4735 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 434587"];
4736 [label="result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName); 434588"];
4737 [label="new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName) 434589"];
4738 [label="param TopLevel(ModuleSymbol module) 434590"];
4739 [label="param TopLevel(ref MetadataTypeName fullName) 434591"];
4740 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 434592"];
4741 [label="param TopLevel(this) 434593"];
4742 [label="module 434594"];
4743 [label="fullName 434595"];
4744 [label="1 434596"];
4745 [label="errorInfo 434597"];
4746 [label="param TopLevel(this) 434598"];
4747 [label="param TopLevel(ModuleSymbol module) 434599"];
4748 [label="param TopLevel(ref MetadataTypeName fullName) 434600"];
4749 [label="param TopLevel(int typeId) 434601"];
4750 [label="param TopLevel(DiagnosticInfo? errorInfo) 434602"];
4751 [label="param TopLevel(this) 434603"];
4752 [label="module 434604"];
4753 [label="fullName 434605"];
4754 [label="1 434606"];
4755 [label="fullName.ForcedArity == -1 434607"];
4756 [label="fullName.ForcedArity == -1 || fullName.ForcedArity == fullName.InferredArity 434608"];
4757 [label="errorInfo 434609"];
4758 [label="typeId 434610"];
4759 [label="param TopLevel(this) 434611"];
4760 [label="param TopLevel(ModuleSymbol module) 434612"];
4761 [label="param TopLevel(ref MetadataTypeName fullName) 434613"];
4762 [label="param TopLevel(bool mangleName) 434614"];
4763 [label="param TopLevel(DiagnosticInfo? errorInfo) 434615"];
4764 [label="param TopLevel(int typeId) 434616"];
4765 [label="param TopLevel(this) 434617"];
4766 [label="module 434618"];
4767 [label="fullName.NamespaceName 434619"];
4768 [label="mangleName 434620"];
4769 [label="fullName.UnmangledTypeName 434621"];
4770 [label="mangleName 434622"];
4771 [label="fullName.InferredArity 434623"];
4772 [label="mangleName 434624"];
4773 [label="false 434625"];
4774 [label="errorInfo 434626"];
4775 [label="null 434627"];
4776 [label="typeId 434628"];
4777 [label="null 434629"];
4778 [label="param TopLevel(this) 434630"];
4779 [label="param TopLevel(ModuleSymbol module) 434631"];
4780 [label="param TopLevel(string @namespace) 434632"];
4781 [label="param TopLevel(string name) 434633"];
4782 [label="param TopLevel(int arity) 434634"];
4783 [label="param TopLevel(bool mangleName) 434635"];
4784 [label="param TopLevel(bool isNativeInt) 434636"];
4785 [label="param TopLevel(DiagnosticInfo? errorInfo) 434637"];
4786 [label="param TopLevel(NamespaceSymbol? containingNamespace) 434638"];
4787 [label="param TopLevel(int typeId) 434639"];
4788 [label="param TopLevel(TupleExtraData? tupleData) 434640"];
4789 [label="param TopLevel(this) 434641"];
4790 [label="name 434642"];
4791 [label="arity 434643"];
4792 [label="mangleName 434644"];
4793 [label="tupleData 434645"];
4794 [label="param TopLevel(this) 434646"];
4795 [label="param MissingMetadataTypeSymbol(string name) 434647"];
4796 [label="param MissingMetadataTypeSymbol(int arity) 434648"];
4797 [label="param MissingMetadataTypeSymbol(bool mangleName) 434649"];
4798 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 434650"];
4799 [label="param MissingMetadataTypeSymbol(this) 434651"];
4800 [label="tupleData 434652"];
4801 [label="param MissingMetadataTypeSymbol(this) 434653"];
4802 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 434654"];
4803 [label="param ErrorTypeSymbol(this) 434655"];
4804 [label="tupleData 434656"];
4805 [label="param ErrorTypeSymbol(this) 434657"];
4806 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 434658"];
4807 [label="param NamedTypeSymbol(this) 434659"];
4808 [label="param NamedTypeSymbol(this) 434660"];
4809 [label="param TypeSymbol(this) 434661"];
4810 [label="param TypeSymbol(this) 434662"];
4811 [label="_lazyAbstractMembers 434663"];
4812 [label="_lazyInterfaceInfo 434664"];
4813 [label="_lazyAdapter 434665"];
4814 [label="_hasNoBaseCycles 434666"];
4815 [label="_lazyTupleData 434667"];
4816 [label="_lazyTupleData 434668"];
4817 [label="name 434669"];
4818 [label="arity 434670"];
4819 [label="mangleName 434671"];
4820 [label="RoslynDebug.Assert(name != null); 434672"];
4821 [label="RoslynDebug.Assert(name != null); 434673"];
4822 [label="this.name 434674"];
4823 [label="this.arity 434675"];
4824 [label="this.mangleName = (mangleName && arity > 0); 434676"];
4825 [label="this.mangleName = (mangleName && arity > 0); 434677"];
4826 [label="this.mangleName = (mangleName && arity > 0); 434678"];
4827 [label="this.mangleName 434679"];
4828 [label="_namespaceName 434680"];
4829 [label="_containingModule 434681"];
4830 [label="_isNativeInt 434682"];
4831 [label="_lazyErrorInfo 434683"];
4832 [label="_lazyContainingNamespace 434684"];
4833 [label="_lazyTypeId 434685"];
4834 [label="RoslynDebug.Assert((object)module != null); 434686"];
4835 [label="RoslynDebug.Assert((object)module != null); 434687"];
4836 [label="RoslynDebug.Assert(@namespace != null); 434688"];
4837 [label="RoslynDebug.Assert(@namespace != null); 434689"];
4838 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 434690"];
4839 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 434691"];
4840 [label="_namespaceName 434692"];
4841 [label="_containingModule 434693"];
4842 [label="_isNativeInt 434694"];
4843 [label="_lazyErrorInfo 434695"];
4844 [label="_lazyContainingNamespace 434696"];
4845 [label="_lazyTypeId 434697"];
4846 [label="Debug.Assert((object)result != null); 434698"];
4847 [label="Debug.Assert((object)result != null); 434699"];
4848 [label="return result; 434700"];
4849 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 434701"];
4850 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 434702"];
4851 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 434703"];
4852 [label="bool foundMatchInThisAssembly = (i < count); 434704"];
4853 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 434705"];
4854 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 434706"];
4855 [label="System.Diagnostics.Debug.Assert((object)result != null); 434707"];
4856 [label="System.Diagnostics.Debug.Assert((object)result != null); 434708"];
4857 [label="if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                } 434709"];
4858 [label="return result; 434710"];
4859 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 434711"];
4860 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 434712"];
4861 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 434713"];
4862 [label="candidate.Kind 434714"];
4863 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 434715"];
4864 [label="return SymbolKind.ErrorType; 434716"];
4865 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 434717"];
4866 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 434718"];
4867 [label="return null; 434719"];
4868 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 434720"];
4869 [label="IsValidWellKnownType(result) 434721"];
4870 [label="param IsValidWellKnownType(NamedTypeSymbol result) 434722"];
4871 [label="param IsValidWellKnownType(this) 434723"];
4872 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 434724"];
4873 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 434725"];
4874 [label="return false; 434726"];
4875 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 434727"];
4876 [label="result = null; 434728"];
4877 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 434729"];
4878 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 434730"];
4879 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 434731"];
4880 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 434732"];
4881 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 434733"];
4882 [label="var assemblies = ArrayBuilder<AssemblySymbol>.GetInstance(); 434734"];
4883 [label="if (assemblyOpt != null)\n            {\n                assemblies.AddRange(DeclaringCompilation.GetBoundReferenceManager().ReferencedAssemblies);\n            }\n            else\n            {\n                DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies);\n            } 434735"];
4884 [label="if (assemblyOpt != null)\n            {\n                assemblies.AddRange(DeclaringCompilation.GetBoundReferenceManager().ReferencedAssemblies);\n            }\n            else\n            {\n                DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies);\n            } 434736"];
4885 [label="DeclaringCompilation 434737"];
4886 [label="get\n            {\n                return _compilation;\n            } 434738"];
4887 [label="return _compilation; 434739"];
4888 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 434740"];
4889 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 434741"];
4890 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies) 434742"];
4891 [label="param GetUnaliasedReferencedAssemblies(ArrayBuilder<AssemblySymbol> assemblies) 434743"];
4892 [label="param GetUnaliasedReferencedAssemblies(this) 434744"];
4893 [label="GetBoundReferenceManager() 434745"];
4894 [label="param GetBoundReferenceManager(this) 434746"];
4895 [label="var referenceManager = GetBoundReferenceManager(); 434747"];
4896 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 434748"];
4897 [label="for (int i = 0; i < referenceManager.ReferencedAssemblies.Length; i++)\n            {\n                if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                }\n            } 434749"];
4898 [label="if (referenceManager.DeclarationsAccessibleWithoutAlias(i))\n                {\n                    assemblies.Add(referenceManager.ReferencedAssemblies[i]);\n                } 434750"];
4899 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 434751"];
4900 [label="assemblies.Add(referenceManager.ReferencedAssemblies[i]); 434752"];
4901 [label="DeclaringCompilation.GetUnaliasedReferencedAssemblies(assemblies); 434753"];
4902 [label="foreach (var assembly in assemblies)\n            {\n                Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); // Non-source assemblies can have missing references\n\n                NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt);\n\n                if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                }\n\n                if ((object)candidate == null)\n                {\n                    continue;\n                }\n\n                if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                }\n\n                Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2));\n\n                if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                }\n\n                result = candidate;\n            } 434754"];
4903 [label="foreach (var assembly in assemblies)\n            {\n                Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); // Non-source assemblies can have missing references\n\n                NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt);\n\n                if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                }\n\n                if ((object)candidate == null)\n                {\n                    continue;\n                }\n\n                if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                }\n\n                Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2));\n\n                if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                }\n\n                result = candidate;\n            } 434755"];
4904 [label="assembly.IsMissing 434756"];
4905 [label="get\n            {\n                return false;\n            } 434757"];
4906 [label="return false; 434758"];
4907 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 434759"];
4908 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 434760"];
4909 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 434761"];
4910 [label="NamedTypeSymbol candidate = GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt); 434762"];
4911 [label="GetTopLevelTypeByMetadataName(assembly, ref metadataName, assemblyOpt) 434763"];
4912 [label="param GetTopLevelTypeByMetadataName(AssemblySymbol assembly) 434764"];
4913 [label="param GetTopLevelTypeByMetadataName(ref MetadataTypeName metadataName) 434765"];
4914 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 434766"];
4915 [label="param LookupTopLevelMetadataType(bool digThroughForwardedTypes) 434767"];
4916 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 434768"];
4917 [label="param LookupTopLevelMetadataTypeWithCycleDetection(bool digThroughForwardedTypes) 434769"];
4918 [label="NamedTypeSymbol result = null; 434770"];
4919 [label="if (_emittedNameToTypeMap.TryGetValue(emittedName.ToKey(), out result))\n            {\n                return result;\n            } 434771"];
4920 [label="var count = modules.Length; 434772"];
4921 [label="NamedTypeSymbol result; 434773"];
4922 [label="get { return _globalNamespace; } 434774"];
4923 [label="return _globalNamespace; 434775"];
4924 [label="param GetMembers(string name) 434776"];
4925 [label="param GetMembers(this) 434777"];
4926 [label="EnsureAllMembersLoaded() 434778"];
4927 [label="param EnsureAllMembersLoaded(this) 434779"];
4928 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 434780"];
4929 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups;\n\n                try\n                {\n                    groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal);\n                }\n                catch (BadImageFormatException)\n                {\n                    groups = SpecializedCollections.EmptyEnumerable<IGrouping<string, TypeDefinitionHandle>>();\n                }\n\n                LoadAllMembers(groups);\n            } 434781"];
4930 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 434782"];
4931 [label="_moduleSymbol.Module 434783"];
4932 [label="get\n            {\n                return _module;\n            } 434784"];
4933 [label="return _module; 434785"];
4934 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 434786"];
4935 [label="groups = _moduleSymbol.Module.GroupTypesByNamespaceOrThrow(System.StringComparer.Ordinal); 434787"];
4936 [label="LoadAllMembers(groups); 434788"];
4937 [label="LoadAllMembers(groups) 434789"];
4938 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 434790"];
4939 [label="param LoadAllMembers(this) 434791"];
4940 [label="Debug.Assert(typesByNS != null); 434792"];
4941 [label="Debug.Assert(typesByNS != null); 434793"];
4942 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> nestedTypes = null; 434794"];
4943 [label="IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> nestedNamespaces = null; 434795"];
4944 [label="this.IsGlobalNamespace 434796"];
4945 [label="get\n            {\n                return true;\n            } 434797"];
4946 [label="return true; 434798"];
4947 [label="bool isGlobalNamespace = this.IsGlobalNamespace; 434799"];
4948 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434800"];
4949 [label="isGlobalNamespace 434801"];
4950 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434802"];
4951 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434803"];
4952 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434804"];
4953 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434805"];
4954 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434806"];
4955 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 434807"];
4956 [label="LazyInitializeNamespaces(nestedNamespaces); 434808"];
4957 [label="LazyInitializeNamespaces(nestedNamespaces) 434809"];
4958 [label="param LazyInitializeNamespaces(IEnumerable<KeyValuePair<string, IEnumerable<IGrouping<string, TypeDefinitionHandle>>>> childNamespaces) 434810"];
4959 [label="param LazyInitializeNamespaces(this) 434811"];
4960 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 434812"];
4961 [label="if (this.lazyNamespaces == null)\n            {\n                var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance);\n\n                foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                }\n\n                Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null);\n            } 434813"];
4962 [label="var namespaces = new Dictionary<string, PENestedNamespaceSymbol>(StringOrdinalComparer.Instance); 434814"];
4963 [label="foreach (var child in childNamespaces)\n                {\n                    var c = new PENestedNamespaceSymbol(child.Key, this, child.Value);\n                    namespaces.Add(c.Name, c);\n                } 434815"];
4964 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 434816"];
4965 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 434817"];
4966 [label="var c = new PENestedNamespaceSymbol(child.Key, this, child.Value); 434818"];
4967 [label="new PENestedNamespaceSymbol(child.Key, this, child.Value) 434819"];
4968 [label="param PENestedNamespaceSymbol(string name) 434820"];
4969 [label="param PENestedNamespaceSymbol(PENamespaceSymbol containingNamespace) 434821"];
4970 [label="param PENestedNamespaceSymbol(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 434822"];
4971 [label="param PENestedNamespaceSymbol(this) 434823"];
4972 [label="param PENestedNamespaceSymbol(this) 434824"];
4973 [label="_containingNamespaceSymbol 434825"];
4974 [label="_name 434826"];
4975 [label="_typesByNS 434827"];
4976 [label="Debug.Assert(name != null); 434828"];
4977 [label="Debug.Assert(name != null); 434829"];
4978 [label="Debug.Assert((object)containingNamespace != null); 434830"];
4979 [label="Debug.Assert((object)containingNamespace != null); 434831"];
4980 [label="Debug.Assert(typesByNS != null); 434832"];
4981 [label="Debug.Assert(typesByNS != null); 434833"];
4982 [label="_containingNamespaceSymbol 434834"];
4983 [label="_name 434835"];
4984 [label="_typesByNS 434836"];
4985 [label="c.Name 434837"];
4986 [label="get\n            {\n                return _name;\n            } 434838"];
4987 [label="return _name; 434839"];
4988 [label="namespaces.Add(c.Name, c); 434840"];
4989 [label="namespaces.Add(c.Name, c); 434841"];
4990 [label="namespaces.Add(c.Name, c); 434842"];
4991 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 434843"];
4992 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 434844"];
4993 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 434845"];
4994 [label="Interlocked.CompareExchange(ref this.lazyNamespaces, namespaces, null); 434846"];
4995 [label="LazyInitializeNamespaces(nestedNamespaces); 434847"];
4996 [label="LazyInitializeTypes(nestedTypes); 434848"];
4997 [label="LazyInitializeTypes(nestedTypes) 434849"];
4998 [label="param LazyInitializeTypes(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typeGroups) 434850"];
4999 [label="param LazyInitializeTypes(this) 434851"];
5000 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 434852"];
5001 [label="if (this.lazyTypes == null)\n            {\n                var moduleSymbol = ContainingPEModule;\n\n                var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes();\n                Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null;\n\n                foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                }\n\n                var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance);\n                children.Free();\n\n                if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                }\n\n                var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null);\n\n                // Build cache of TypeDef Tokens\n                // Potentially this can be done in the background.\n                if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n            } 434853"];
5002 [label="ContainingPEModule 434854"];
5003 [label="get\n            {\n                return _moduleSymbol;\n            } 434855"];
5004 [label="return _moduleSymbol; 434856"];
5005 [label="var moduleSymbol = ContainingPEModule; 434857"];
5006 [label="var children = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 434858"];
5007 [label="moduleSymbol.Module 434859"];
5008 [label="get\n            {\n                return _module;\n            } 434860"];
5009 [label="var skipCheckForPiaType = !moduleSymbol.Module.ContainsNoPiaLocalTypes(); 434861"];
5010 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 434862"];
5011 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 434863"];
5012 [label="foreach (var g in typeGroups)\n                {\n                    foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    }\n                } 434864"];
5013 [label="foreach (var t in g)\n                    {\n                        if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        }\n                    } 434865"];
5014 [label="if (skipCheckForPiaType || !moduleSymbol.Module.IsNoPiaLocalType(t))\n                        {\n                            children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key));\n                        }\n                        else\n                        {\n                            try\n                            {\n                                string typeDefName = moduleSymbol.Module.GetTypeDefNameOrThrow(t);\n\n                                if (noPiaLocalTypes == null)\n                                {\n                                    noPiaLocalTypes = new Dictionary<string, TypeDefinitionHandle>(StringOrdinalComparer.Instance);\n                                }\n\n                                noPiaLocalTypes[typeDefName] = t;\n                            }\n                            catch (BadImageFormatException)\n                            { }\n                        } 434866"];
5015 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 434867"];
5016 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 434868"];
5017 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 434869"];
5018 [label="EmptyComparer.Instance 434870"];
5019 [label="new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 434871"];
5020 [label="s_emptyNestedTypes = new Dictionary<string, ImmutableArray<PENamedTypeSymbol>>(EmptyComparer.Instance) 434872"];
5021 [label="new UncommonProperties() 434873"];
5022 [label="param UncommonProperties(this) 434874"];
5023 [label="lazyEnumUnderlyingType 434875"];
5024 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 434876"];
5025 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 434877"];
5026 [label="lazyContainsExtensionMethods 434878"];
5027 [label="lazyIsByRefLike 434879"];
5028 [label="lazyIsReadOnly 434880"];
5029 [label="lazyDefaultMemberName 434881"];
5030 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 434882"];
5031 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 434883"];
5032 [label="s_noUncommonProperties = new UncommonProperties() 434884"];
5033 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 434885"];
5034 [label="PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key) 434886"];
5035 [label="param Create(PEModuleSymbol moduleSymbol) 434887"];
5036 [label="param Create(PENamespaceSymbol containingNamespace) 434888"];
5037 [label="param Create(TypeDefinitionHandle handle) 434889"];
5038 [label="param Create(string emittedNamespaceName) 434890"];
5039 [label="GenericParameterHandleCollection genericParameterHandles; 434891"];
5040 [label="genericParameterHandles 434892"];
5041 [label="ushort arity; 434893"];
5042 [label="BadImageFormatException mrEx = null; 434894"];
5043 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434895"];
5044 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434896"];
5045 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434897"];
5046 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434898"];
5047 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434899"];
5048 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx) 434900"];
5049 [label="param GetGenericInfo(PEModuleSymbol moduleSymbol) 434901"];
5050 [label="param GetGenericInfo(TypeDefinitionHandle handle) 434902"];
5051 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 434903"];
5052 [label="param GetGenericInfo(out ushort arity) 434904"];
5053 [label="param GetGenericInfo(out BadImageFormatException mrEx) 434905"];
5054 [label="moduleSymbol.Module 434906"];
5055 [label="get\n            {\n                return _module;\n            } 434907"];
5056 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 434908"];
5057 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 434909"];
5058 [label="genericParameterHandles = moduleSymbol.Module.GetTypeDefGenericParamsOrThrow(handle); 434910"];
5059 [label="arity = (ushort)genericParameterHandles.Count; 434911"];
5060 [label="mrEx = null; 434912"];
5061 [label="GetGenericInfo(moduleSymbol, handle, out genericParameterHandles, out arity, out mrEx); 434913"];
5062 [label="bool mangleName; 434914"];
5063 [label="PENamedTypeSymbol result; 434915"];
5064 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 434916"];
5065 [label="if (arity == 0)\n            {\n                result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName);\n            }\n            else\n            {\n                result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName);\n            } 434917"];
5066 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434918"];
5067 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434919"];
5068 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434920"];
5069 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434921"];
5070 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434922"];
5071 [label="result = new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName); 434923"];
5072 [label="new PENamedTypeSymbolNonGeneric(moduleSymbol, containingNamespace, handle, emittedNamespaceName, out mangleName) 434924"];
5073 [label="param PENamedTypeSymbolNonGeneric(PEModuleSymbol moduleSymbol) 434925"];
5074 [label="param PENamedTypeSymbolNonGeneric(NamespaceOrTypeSymbol container) 434926"];
5075 [label="param PENamedTypeSymbolNonGeneric(TypeDefinitionHandle handle) 434927"];
5076 [label="param PENamedTypeSymbolNonGeneric(string emittedNamespaceName) 434928"];
5077 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 434929"];
5078 [label="param PENamedTypeSymbolNonGeneric(this) 434930"];
5079 [label="moduleSymbol 434931"];
5080 [label="container 434932"];
5081 [label="handle 434933"];
5082 [label="emittedNamespaceName 434934"];
5083 [label="0 434935"];
5084 [label="mangleName 434936"];
5085 [label="param PENamedTypeSymbolNonGeneric(this) 434937"];
5086 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 434938"];
5087 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 434939"];
5088 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 434940"];
5089 [label="param PENamedTypeSymbol(string emittedNamespaceName) 434941"];
5090 [label="param PENamedTypeSymbol(ushort arity) 434942"];
5091 [label="param PENamedTypeSymbol(out bool mangleName) 434943"];
5092 [label="param PENamedTypeSymbol(this) 434944"];
5093 [label="param PENamedTypeSymbol(this) 434945"];
5094 [label="param NamedTypeSymbol(this) 434946"];
5095 [label="param NamedTypeSymbol(TupleExtraData tupleData = null) 434947"];
5096 [label="param NamedTypeSymbol(this) 434948"];
5097 [label="param TypeSymbol(this) 434949"];
5098 [label="param TypeSymbol(this) 434950"];
5099 [label="_lazyAbstractMembers 434951"];
5100 [label="_lazyInterfaceInfo 434952"];
5101 [label="_lazyAdapter 434953"];
5102 [label="_hasNoBaseCycles 434954"];
5103 [label="_lazyTupleData 434955"];
5104 [label="_lazyTupleData 434956"];
5105 [label="_container 434957"];
5106 [label="_name 434958"];
5107 [label="_flags 434959"];
5108 [label="_corTypeId 434960"];
5109 [label="_lazyMemberNames 434961"];
5110 [label="_lazyMembersByName 434962"];
5111 [label="_lazyNestedTypes 434963"];
5112 [label="_lazyKind 434964"];
5113 [label="_lazyNullableContextValue 434965"];
5114 [label="_lazyBaseType = ErrorTypeSymbol.UnknownResultType 434966"];
5115 [label="default(ImmutableArray<NamedTypeSymbol>) 434967"];
5116 [label="_lazyInterfaces = default(ImmutableArray<NamedTypeSymbol>) 434968"];
5117 [label="_lazyDeclaredBaseType = ErrorTypeSymbol.UnknownResultType 434969"];
5118 [label="default(ImmutableArray<NamedTypeSymbol>) 434970"];
5119 [label="_lazyDeclaredInterfaces = default(ImmutableArray<NamedTypeSymbol>) 434971"];
5120 [label="_lazyDocComment 434972"];
5121 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 434973"];
5122 [label="_lazyUncommonProperties 434974"];
5123 [label="public IEnumerable<object> fieldDefs { get; set; } 434975"];
5124 [label="Debug.Assert(!handle.IsNil); 434976"];
5125 [label="Debug.Assert((object)container != null); 434977"];
5126 [label="Debug.Assert((object)container != null); 434978"];
5127 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 434979"];
5128 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 434980"];
5129 [label="string metadataName; 434981"];
5130 [label="bool makeBad = false; 434982"];
5131 [label="moduleSymbol.Module 434983"];
5132 [label="get\n            {\n                return _module;\n            } 434984"];
5133 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 434985"];
5134 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 434986"];
5135 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 434987"];
5136 [label="_handle 434988"];
5137 [label="_container 434989"];
5138 [label="moduleSymbol.Module 434990"];
5139 [label="get\n            {\n                return _module;\n            } 434991"];
5140 [label="return _module; 434992"];
5141 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 434993"];
5142 [label="_flags = moduleSymbol.Module.GetTypeDefFlagsOrThrow(handle); 434994"];
5143 [label="_flags 434995"];
5144 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 434996"];
5145 [label="if (arity == 0)\n            {\n                _name = metadataName;\n                mangleName = false;\n            }\n            else\n            {\n                // Unmangle name for a generic type.\n                _name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity);\n                Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName));\n                mangleName = !ReferenceEquals(_name, metadataName);\n            } 434997"];
5146 [label="_name 434998"];
5147 [label="mangleName = false; 434999"];
5148 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435000"];
5149 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435001"];
5150 [label="moduleSymbol.ContainingAssembly 435002"];
5151 [label="get\n            {\n                return _assemblySymbol;\n            } 435003"];
5152 [label="return _assemblySymbol; 435004"];
5153 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435005"];
5154 [label="moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes 435006"];
5155 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 435007"];
5156 [label="this.CorLibrary 435008"];
5157 [label="get\n            {\n                return _corLibrary;\n            } 435009"];
5158 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 435010"];
5159 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 435011"];
5160 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 435012"];
5161 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435013"];
5162 [label="this.DeclaredAccessibility 435014"];
5163 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 435015"];
5164 [label="Accessibility access = Accessibility.Private; 435016"];
5165 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 435017"];
5166 [label="access = Accessibility.Internal; 435018"];
5167 [label="return access; 435019"];
5168 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435020"];
5169 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435021"];
5170 [label="_corTypeId 435022"];
5171 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435023"];
5172 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435024"];
5173 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435025"];
5174 [label="return result; 435026"];
5175 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 435027"];
5176 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 435028"];
5177 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 435029"];
5178 [label="var typesDict = children.ToDictionary(c => c.Name, StringOrdinalComparer.Instance); 435030"];
5179 [label="get\n            {\n                return _name;\n            } 435031"];
5180 [label="return _name; 435032"];
5181 [label="children.Free(); 435033"];
5182 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435034"];
5183 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435035"];
5184 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 435036"];
5185 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 435037"];
5186 [label="var original = Interlocked.CompareExchange(ref this.lazyTypes, typesDict, null); 435038"];
5187 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 435039"];
5188 [label="if (original == null)\n                {\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 435040"];
5189 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 435041"];
5190 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 435042"];
5191 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 435043"];
5192 [label="param OnNewTypeDeclarationsLoaded(this) 435044"];
5193 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 435045"];
5194 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 435046"];
5195 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 435047"];
5196 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 435048"];
5197 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 435049"];
5198 [label="foreach (var types in typesDict.Values)\n            {\n                foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                }\n            } 435050"];
5199 [label="foreach (var type in types)\n                {\n                    bool added;\n                    added = TypeHandleToTypeMap.TryAdd(type.Handle, type);\n                    Debug.Assert(added);\n\n                    // Register newly loaded COR types\n                    if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    }\n                } 435051"];
5200 [label="bool added; 435052"];
5201 [label="type.Handle 435053"];
5202 [label="get\n            {\n                return _handle;\n            } 435054"];
5203 [label="return _handle; 435055"];
5204 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 435056"];
5205 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 435057"];
5206 [label="added = TypeHandleToTypeMap.TryAdd(type.Handle, type); 435058"];
5207 [label="Debug.Assert(added); 435059"];
5208 [label="type.SpecialType 435060"];
5209 [label="get\n            {\n                return _corTypeId;\n            } 435061"];
5210 [label="return _corTypeId; 435062"];
5211 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 435063"];
5212 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 435064"];
5213 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 435065"];
5214 [label="LazyInitializeTypes(nestedTypes); 435066"];
5215 [label="LoadAllMembers(groups); 435067"];
5216 [label="EnsureAllMembersLoaded(); 435068"];
5217 [label="PENestedNamespaceSymbol ns = null; 435069"];
5218 [label="ImmutableArray<PENamedTypeSymbol> t; 435070"];
5219 [label="t 435071"];
5220 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 435072"];
5221 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 435073"];
5222 [label="if (lazyNamespaces.TryGetValue(name, out ns))\n            {\n                if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                }\n            }\n            else if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 435074"];
5223 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 435075"];
5224 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 435076"];
5225 [label="if (lazyTypes.TryGetValue(name, out t))\n                {\n                    // TODO - Eliminate the copy by storing all members and type members instead of non-type and type members?\n                    return StaticCast<Symbol>.From(t).Add(ns);\n                }\n                else\n                {\n                    return ImmutableArray.Create<Symbol>(ns);\n                } 435077"];
5226 [label="return ImmutableArray.Create<Symbol>(ns); 435078"];
5227 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 435079"];
5228 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435080"];
5229 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435081"];
5230 [label="param EnsureAllMembersLoaded(this) 435082"];
5231 [label="var typesByNS = _typesByNS; 435083"];
5232 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 435084"];
5233 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 435085"];
5234 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 435086"];
5235 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 435087"];
5236 [label="LoadAllMembers(typesByNS); 435088"];
5237 [label="LoadAllMembers(typesByNS) 435089"];
5238 [label="param LoadAllMembers(IEnumerable<IGrouping<string, TypeDefinitionHandle>> typesByNS) 435090"];
5239 [label="Debug.Assert(typesByNS != null); 435091"];
5240 [label="Debug.Assert(typesByNS != null); 435092"];
5241 [label="get\n            {\n                return false;\n            } 435093"];
5242 [label="return false; 435094"];
5243 [label="GetQualifiedNameLength() 435095"];
5244 [label="param GetQualifiedNameLength(this) 435096"];
5245 [label="this.Name 435097"];
5246 [label="get\n            {\n                return _name;\n            } 435098"];
5247 [label="int length = this.Name.Length; 435099"];
5248 [label="ContainingNamespace 435100"];
5249 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 435101"];
5250 [label="this.ContainingSymbol 435102"];
5251 [label="get { return _containingNamespaceSymbol; } 435103"];
5252 [label="return _containingNamespaceSymbol; 435104"];
5253 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 435105"];
5254 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 435106"];
5255 [label="var ns = container as NamespaceSymbol; 435107"];
5256 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 435108"];
5257 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 435109"];
5258 [label="return ns; 435110"];
5259 [label="var parent = ContainingNamespace; 435111"];
5260 [label=".IsGlobalNamespace 435112"];
5261 [label="get\n            {\n                return true;\n            } 435113"];
5262 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 435114"];
5263 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 435115"];
5264 [label="return length; 435116"];
5265 [label="MetadataHelpers.GetInfoForImmediateNamespaceMembers(\n                isGlobalNamespace,\n                isGlobalNamespace ? 0 : GetQualifiedNameLength(),\n                typesByNS,\n                StringComparer.Ordinal,\n                out nestedTypes, out nestedNamespaces); 435117"];
5266 [label="_containingNamespaceSymbol 435118"];
5267 [label="_name 435119"];
5268 [label="_typesByNS 435120"];
5269 [label="Debug.Assert(name != null); 435121"];
5270 [label="Debug.Assert((object)containingNamespace != null); 435122"];
5271 [label="Debug.Assert(typesByNS != null); 435123"];
5272 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435124"];
5273 [label="_containingNamespaceSymbol.ContainingPEModule 435125"];
5274 [label="get\n            {\n                return _moduleSymbol;\n            } 435126"];
5275 [label="return _containingNamespaceSymbol.ContainingPEModule; 435127"];
5276 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 435128"];
5277 [label="GenericParameterHandleCollection genericParameterHandles; 435129"];
5278 [label="genericParameterHandles 435130"];
5279 [label="ushort arity; 435131"];
5280 [label="BadImageFormatException mrEx = null; 435132"];
5281 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435133"];
5282 [label="param GetGenericInfo(out ushort arity) 435134"];
5283 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435135"];
5284 [label="mrEx = null; 435136"];
5285 [label="bool mangleName; 435137"];
5286 [label="PENamedTypeSymbol result; 435138"];
5287 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 435139"];
5288 [label="mangleName 435140"];
5289 [label="param PENamedTypeSymbol(out bool mangleName) 435141"];
5290 [label="_lazyTupleData 435142"];
5291 [label="_container 435143"];
5292 [label="_name 435144"];
5293 [label="_flags 435145"];
5294 [label="_corTypeId 435146"];
5295 [label="Debug.Assert(!handle.IsNil); 435147"];
5296 [label="Debug.Assert((object)container != null); 435148"];
5297 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435149"];
5298 [label="string metadataName; 435150"];
5299 [label="bool makeBad = false; 435151"];
5300 [label="mangleName = false; 435152"];
5301 [label="Accessibility access = Accessibility.Private; 435153"];
5302 [label="access = Accessibility.Public; 435154"];
5303 [label="_corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName)); 435155"];
5304 [label="_corTypeId 435156"];
5305 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435157"];
5306 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435158"];
5307 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435159"];
5308 [label="GenericParameterHandleCollection genericParameterHandles; 435160"];
5309 [label="genericParameterHandles 435161"];
5310 [label="ushort arity; 435162"];
5311 [label="BadImageFormatException mrEx = null; 435163"];
5312 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435164"];
5313 [label="param GetGenericInfo(out ushort arity) 435165"];
5314 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435166"];
5315 [label="mrEx = null; 435167"];
5316 [label="PENamedTypeSymbol result; 435168"];
5317 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 435169"];
5318 [label="mangleName 435170"];
5319 [label="param PENamedTypeSymbol(out bool mangleName) 435171"];
5320 [label="_lazyTupleData 435172"];
5321 [label="_container 435173"];
5322 [label="_name 435174"];
5323 [label="_flags 435175"];
5324 [label="_corTypeId 435176"];
5325 [label="Debug.Assert(!handle.IsNil); 435177"];
5326 [label="Debug.Assert((object)container != null); 435178"];
5327 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435179"];
5328 [label="string metadataName; 435180"];
5329 [label="bool makeBad = false; 435181"];
5330 [label="mangleName = false; 435182"];
5331 [label="Accessibility access = Accessibility.Private; 435183"];
5332 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435184"];
5333 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435185"];
5334 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435186"];
5335 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 435187"];
5336 [label="result = new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName); 435188"];
5337 [label="new PENamedTypeSymbolGeneric(\n                    moduleSymbol,\n                    containingNamespace,\n                    handle,\n                    emittedNamespaceName,\n                    genericParameterHandles,\n                    arity,\n                    out mangleName) 435189"];
5338 [label="param PENamedTypeSymbolGeneric(PEModuleSymbol moduleSymbol) 435190"];
5339 [label="param PENamedTypeSymbolGeneric(NamespaceOrTypeSymbol container) 435191"];
5340 [label="param PENamedTypeSymbolGeneric(TypeDefinitionHandle handle) 435192"];
5341 [label="param PENamedTypeSymbolGeneric(string emittedNamespaceName) 435193"];
5342 [label="param PENamedTypeSymbolGeneric(GenericParameterHandleCollection genericParameterHandles) 435194"];
5343 [label="param PENamedTypeSymbolGeneric(ushort arity) 435195"];
5344 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 435196"];
5345 [label="param PENamedTypeSymbolGeneric(this) 435197"];
5346 [label="moduleSymbol 435198"];
5347 [label="container 435199"];
5348 [label="handle 435200"];
5349 [label="emittedNamespaceName 435201"];
5350 [label="arity 435202"];
5351 [label="mangleName 435203"];
5352 [label="param PENamedTypeSymbolGeneric(this) 435204"];
5353 [label="param PENamedTypeSymbol(PEModuleSymbol moduleSymbol) 435205"];
5354 [label="param PENamedTypeSymbol(NamespaceOrTypeSymbol container) 435206"];
5355 [label="param PENamedTypeSymbol(TypeDefinitionHandle handle) 435207"];
5356 [label="param PENamedTypeSymbol(string emittedNamespaceName) 435208"];
5357 [label="param PENamedTypeSymbol(ushort arity) 435209"];
5358 [label="param PENamedTypeSymbol(out bool mangleName) 435210"];
5359 [label="_lazyTupleData 435211"];
5360 [label="_container 435212"];
5361 [label="_name 435213"];
5362 [label="_flags 435214"];
5363 [label="_corTypeId 435215"];
5364 [label="Debug.Assert(!handle.IsNil); 435216"];
5365 [label="Debug.Assert((object)container != null); 435217"];
5366 [label="Debug.Assert((object)container != null); 435218"];
5367 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435219"];
5368 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435220"];
5369 [label="string metadataName; 435221"];
5370 [label="bool makeBad = false; 435222"];
5371 [label="metadataName = moduleSymbol.Module.GetTypeDefNameOrThrow(handle); 435223"];
5372 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 435224"];
5373 [label="_name = MetadataHelpers.UnmangleMetadataNameForArity(metadataName, arity); 435225"];
5374 [label="_name 435226"];
5375 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435227"];
5376 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435228"];
5377 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435229"];
5378 [label="mangleName = !ReferenceEquals(_name, metadataName); 435230"];
5379 [label="mangleName = !ReferenceEquals(_name, metadataName); 435231"];
5380 [label="if (emittedNamespaceName != null &&\n                moduleSymbol.ContainingAssembly.KeepLookingForDeclaredSpecialTypes &&\n                this.DeclaredAccessibility == Accessibility.Public) // NB: this.flags was set above.\n            {\n                _corTypeId = SpecialTypes.GetTypeFromMetadataName(MetadataHelpers.BuildQualifiedName(emittedNamespaceName, metadataName));\n            }\n            else\n            {\n                _corTypeId = SpecialType.None;\n            } 435232"];
5381 [label="Accessibility access = Accessibility.Private; 435233"];
5382 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435234"];
5383 [label="_arity 435235"];
5384 [label="_mangleName 435236"];
5385 [label="Debug.Assert(genericParameterHandles.Count > 0); 435237"];
5386 [label="Debug.Assert(genericParameterHandles.Count > 0); 435238"];
5387 [label="_arity 435239"];
5388 [label="_genericParameterHandles 435240"];
5389 [label="_mangleName 435241"];
5390 [label="children.Add(PENamedTypeSymbol.Create(moduleSymbol, this, t, g.Key)); 435242"];
5391 [label="genericParameterHandles 435243"];
5392 [label="ushort arity; 435244"];
5393 [label="BadImageFormatException mrEx = null; 435245"];
5394 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435246"];
5395 [label="param GetGenericInfo(out ushort arity) 435247"];
5396 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435248"];
5397 [label="mrEx = null; 435249"];
5398 [label="PENamedTypeSymbol result; 435250"];
5399 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 435251"];
5400 [label="mangleName 435252"];
5401 [label="param PENamedTypeSymbol(out bool mangleName) 435253"];
5402 [label="_lazyTupleData 435254"];
5403 [label="_container 435255"];
5404 [label="_name 435256"];
5405 [label="_flags 435257"];
5406 [label="_corTypeId 435258"];
5407 [label="Debug.Assert(!handle.IsNil); 435259"];
5408 [label="Debug.Assert((object)container != null); 435260"];
5409 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435261"];
5410 [label="string metadataName; 435262"];
5411 [label="bool makeBad = false; 435263"];
5412 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435264"];
5413 [label="Accessibility access = Accessibility.Private; 435265"];
5414 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435266"];
5415 [label="_arity 435267"];
5416 [label="_mangleName 435268"];
5417 [label="Debug.Assert(genericParameterHandles.Count > 0); 435269"];
5418 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435270"];
5419 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435271"];
5420 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435272"];
5421 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 435273"];
5422 [label="mangleName 435274"];
5423 [label="param PENamedTypeSymbol(out bool mangleName) 435275"];
5424 [label="_lazyTupleData 435276"];
5425 [label="_container 435277"];
5426 [label="_name 435278"];
5427 [label="_flags 435279"];
5428 [label="_corTypeId 435280"];
5429 [label="Debug.Assert(!handle.IsNil); 435281"];
5430 [label="Debug.Assert((object)container != null); 435282"];
5431 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435283"];
5432 [label="string metadataName; 435284"];
5433 [label="bool makeBad = false; 435285"];
5434 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435286"];
5435 [label="Accessibility access = Accessibility.Private; 435287"];
5436 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435288"];
5437 [label="_arity 435289"];
5438 [label="_mangleName 435290"];
5439 [label="Debug.Assert(genericParameterHandles.Count > 0); 435291"];
5440 [label="genericParameterHandles 435292"];
5441 [label="BadImageFormatException mrEx = null; 435293"];
5442 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435294"];
5443 [label="param GetGenericInfo(out ushort arity) 435295"];
5444 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435296"];
5445 [label="mrEx = null; 435297"];
5446 [label="PENamedTypeSymbol result; 435298"];
5447 [label="Debug.Assert(!handle.IsNil); 435299"];
5448 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435300"];
5449 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435301"];
5450 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435302"];
5451 [label="param GetGenericInfo(out ushort arity) 435303"];
5452 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 435304"];
5453 [label="mangleName 435305"];
5454 [label="param PENamedTypeSymbol(out bool mangleName) 435306"];
5455 [label="_lazyTupleData 435307"];
5456 [label="_container 435308"];
5457 [label="_name 435309"];
5458 [label="_flags 435310"];
5459 [label="_corTypeId 435311"];
5460 [label="Debug.Assert(!handle.IsNil); 435312"];
5461 [label="Debug.Assert((object)container != null); 435313"];
5462 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435314"];
5463 [label="string metadataName; 435315"];
5464 [label="bool makeBad = false; 435316"];
5465 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435317"];
5466 [label="Accessibility access = Accessibility.Private; 435318"];
5467 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435319"];
5468 [label="_arity 435320"];
5469 [label="_mangleName 435321"];
5470 [label="Debug.Assert(genericParameterHandles.Count > 0); 435322"];
5471 [label="genericParameterHandles 435323"];
5472 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435324"];
5473 [label="param GetGenericInfo(out ushort arity) 435325"];
5474 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435326"];
5475 [label="mrEx = null; 435327"];
5476 [label="PENamedTypeSymbol result; 435328"];
5477 [label="Debug.Assert(!handle.IsNil); 435329"];
5478 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435330"];
5479 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435331"];
5480 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 435332"];
5481 [label="mangleName 435333"];
5482 [label="param PENamedTypeSymbol(out bool mangleName) 435334"];
5483 [label="mangleName = false; 435335"];
5484 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435336"];
5485 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435337"];
5486 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 435338"];
5487 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 435339"];
5488 [label="bool keepLookingForDeclaredCorTypes = (_ordinal == 0 && _assemblySymbol.KeepLookingForDeclaredSpecialTypes); 435340"];
5489 [label="bool added; 435341"];
5490 [label="Debug.Assert(added); 435342"];
5491 [label="type.SpecialType 435343"];
5492 [label="get\n            {\n                return _corTypeId;\n            } 435344"];
5493 [label="return _corTypeId; 435345"];
5494 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 435346"];
5495 [label="if (keepLookingForDeclaredCorTypes && type.SpecialType != SpecialType.None)\n                    {\n                        _assemblySymbol.RegisterDeclaredSpecialType(type);\n                        keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes;\n                    } 435347"];
5496 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 435348"];
5497 [label="_assemblySymbol.RegisterDeclaredSpecialType(type) 435349"];
5498 [label="param RegisterDeclaredSpecialType(NamedTypeSymbol corType) 435350"];
5499 [label="param RegisterDeclaredSpecialType(this) 435351"];
5500 [label="corType.SpecialType 435352"];
5501 [label="get\n            {\n                return _corTypeId;\n            } 435353"];
5502 [label="SpecialType typeId = corType.SpecialType; 435354"];
5503 [label="Debug.Assert(typeId != SpecialType.None); 435355"];
5504 [label="corType.ContainingAssembly 435356"];
5505 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 435357"];
5506 [label="this.ContainingSymbol 435358"];
5507 [label="get\n            {\n                return _container;\n            } 435359"];
5508 [label="return _container; 435360"];
5509 [label="var container = this.ContainingSymbol; 435361"];
5510 [label="return (object)container != null ? container.ContainingAssembly : null; 435362"];
5511 [label="return (object)container != null ? container.ContainingAssembly : null; 435363"];
5512 [label="(object)container != null 435364"];
5513 [label="container.ContainingAssembly 435365"];
5514 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 435366"];
5515 [label="ContainingPEModule 435367"];
5516 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435368"];
5517 [label="return ContainingPEModule.ContainingAssembly; 435369"];
5518 [label="ContainingPEModule.ContainingAssembly 435370"];
5519 [label="get\n            {\n                return _assemblySymbol;\n            } 435371"];
5520 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435372"];
5521 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435373"];
5522 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435374"];
5523 [label="corType.ContainingModule 435375"];
5524 [label="get\n            {\n                return ContainingPEModule;\n            } 435376"];
5525 [label="ContainingPEModule 435377"];
5526 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 435378"];
5527 [label="Symbol s = _container; 435379"];
5528 [label="s.Kind 435380"];
5529 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435381"];
5530 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 435382"];
5531 [label="((PENamespaceSymbol)s).ContainingPEModule 435383"];
5532 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435384"];
5533 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 435385"];
5534 [label="return ContainingPEModule; 435386"];
5535 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435387"];
5536 [label="corType.ContainingModule.Ordinal 435388"];
5537 [label="get\n            {\n                return _ordinal;\n            } 435389"];
5538 [label="return _ordinal; 435390"];
5539 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435391"];
5540 [label="this.CorLibrary 435392"];
5541 [label="get\n            {\n                return _corLibrary;\n            } 435393"];
5542 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 435394"];
5543 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 435395"];
5544 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 435396"];
5545 [label="if (_lazySpecialTypes == null)\n            {\n                Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null);\n            } 435397"];
5546 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 435398"];
5547 [label="Interlocked.CompareExchange(ref _lazySpecialTypes,\n                    new NamedTypeSymbol[(int)SpecialType.Count + 1], null); 435399"];
5548 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 435400"];
5549 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 435401"];
5550 [label="if ((object)Interlocked.CompareExchange(ref _lazySpecialTypes[(int)typeId], corType, null) != null)\n            {\n                Debug.Assert(ReferenceEquals(corType, _lazySpecialTypes[(int)typeId]) ||\n                                        (corType.Kind == SymbolKind.ErrorType &&\n                                        _lazySpecialTypes[(int)typeId].Kind == SymbolKind.ErrorType));\n            }\n            else\n            {\n                Interlocked.Increment(ref _cachedSpecialTypes);\n                Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count);\n            } 435402"];
5551 [label="Interlocked.Increment(ref _cachedSpecialTypes); 435403"];
5552 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435404"];
5553 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435405"];
5554 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435406"];
5555 [label="_assemblySymbol.RegisterDeclaredSpecialType(type); 435407"];
5556 [label="_assemblySymbol.KeepLookingForDeclaredSpecialTypes 435408"];
5557 [label="get\n            {\n                return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count;\n            } 435409"];
5558 [label="return ReferenceEquals(this.CorLibrary, this) && _cachedSpecialTypes < (int)SpecialType.Count; 435410"];
5559 [label="keepLookingForDeclaredCorTypes = _assemblySymbol.KeepLookingForDeclaredSpecialTypes; 435411"];
5560 [label="bool added; 435412"];
5561 [label="Debug.Assert(added); 435413"];
5562 [label="Debug.Assert(typeId != SpecialType.None); 435414"];
5563 [label="corType.ContainingAssembly 435415"];
5564 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 435416"];
5565 [label="this.ContainingSymbol 435417"];
5566 [label="get\n            {\n                return _container;\n            } 435418"];
5567 [label="return _container; 435419"];
5568 [label="var container = this.ContainingSymbol; 435420"];
5569 [label="return (object)container != null ? container.ContainingAssembly : null; 435421"];
5570 [label="return (object)container != null ? container.ContainingAssembly : null; 435422"];
5571 [label="(object)container != null 435423"];
5572 [label="container.ContainingAssembly 435424"];
5573 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 435425"];
5574 [label="ContainingPEModule 435426"];
5575 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435427"];
5576 [label="return ContainingPEModule.ContainingAssembly; 435428"];
5577 [label="ContainingPEModule.ContainingAssembly 435429"];
5578 [label="get\n            {\n                return _assemblySymbol;\n            } 435430"];
5579 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435431"];
5580 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435432"];
5581 [label="corType.ContainingModule 435433"];
5582 [label="get\n            {\n                return ContainingPEModule;\n            } 435434"];
5583 [label="ContainingPEModule 435435"];
5584 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 435436"];
5585 [label="Symbol s = _container; 435437"];
5586 [label="s.Kind 435438"];
5587 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435439"];
5588 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 435440"];
5589 [label="((PENamespaceSymbol)s).ContainingPEModule 435441"];
5590 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435442"];
5591 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 435443"];
5592 [label="return ContainingPEModule; 435444"];
5593 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435445"];
5594 [label="corType.ContainingModule.Ordinal 435446"];
5595 [label="get\n            {\n                return _ordinal;\n            } 435447"];
5596 [label="return _ordinal; 435448"];
5597 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435449"];
5598 [label="this.CorLibrary 435450"];
5599 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 435451"];
5600 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 435452"];
5601 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435453"];
5602 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435454"];
5603 [label="bool added; 435455"];
5604 [label="Debug.Assert(added); 435456"];
5605 [label="Debug.Assert(typeId != SpecialType.None); 435457"];
5606 [label="corType.ContainingAssembly 435458"];
5607 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 435459"];
5608 [label="this.ContainingSymbol 435460"];
5609 [label="get\n            {\n                return _container;\n            } 435461"];
5610 [label="return _container; 435462"];
5611 [label="var container = this.ContainingSymbol; 435463"];
5612 [label="return (object)container != null ? container.ContainingAssembly : null; 435464"];
5613 [label="return (object)container != null ? container.ContainingAssembly : null; 435465"];
5614 [label="(object)container != null 435466"];
5615 [label="container.ContainingAssembly 435467"];
5616 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 435468"];
5617 [label="ContainingPEModule 435469"];
5618 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435470"];
5619 [label="return ContainingPEModule.ContainingAssembly; 435471"];
5620 [label="ContainingPEModule.ContainingAssembly 435472"];
5621 [label="get\n            {\n                return _assemblySymbol;\n            } 435473"];
5622 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435474"];
5623 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435475"];
5624 [label="corType.ContainingModule 435476"];
5625 [label="get\n            {\n                return ContainingPEModule;\n            } 435477"];
5626 [label="ContainingPEModule 435478"];
5627 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 435479"];
5628 [label="Symbol s = _container; 435480"];
5629 [label="s.Kind 435481"];
5630 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435482"];
5631 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 435483"];
5632 [label="((PENamespaceSymbol)s).ContainingPEModule 435484"];
5633 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435485"];
5634 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 435486"];
5635 [label="return ContainingPEModule; 435487"];
5636 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435488"];
5637 [label="corType.ContainingModule.Ordinal 435489"];
5638 [label="get\n            {\n                return _ordinal;\n            } 435490"];
5639 [label="return _ordinal; 435491"];
5640 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435492"];
5641 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 435493"];
5642 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435494"];
5643 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 435495"];
5644 [label="bool added; 435496"];
5645 [label="Debug.Assert(added); 435497"];
5646 [label="return _container; 435498"];
5647 [label="var container = this.ContainingSymbol; 435499"];
5648 [label="return (object)container != null ? container.ContainingAssembly : null; 435500"];
5649 [label="(object)container != null 435501"];
5650 [label="container.ContainingAssembly 435502"];
5651 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 435503"];
5652 [label="ContainingPEModule 435504"];
5653 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435505"];
5654 [label="return ContainingPEModule.ContainingAssembly; 435506"];
5655 [label="ContainingPEModule.ContainingAssembly 435507"];
5656 [label="get\n            {\n                return _assemblySymbol;\n            } 435508"];
5657 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435509"];
5658 [label="Symbol s = _container; 435510"];
5659 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435511"];
5660 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435512"];
5661 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 435513"];
5662 [label="return ContainingPEModule; 435514"];
5663 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 435515"];
5664 [label="get\n            {\n                return _ordinal;\n            } 435516"];
5665 [label="return _ordinal; 435517"];
5666 [label="LoadAllMembers(typesByNS); 435518"];
5667 [label="Interlocked.Exchange(ref _typesByNS, null); 435519"];
5668 [label="Interlocked.Exchange(ref _typesByNS, null); 435520"];
5669 [label="EnsureAllMembersLoaded(); 435521"];
5670 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 435522"];
5671 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435523"];
5672 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435524"];
5673 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 435525"];
5674 [label="Debug.Assert(typesByNS != null); 435526"];
5675 [label="get\n            {\n                return false;\n            } 435527"];
5676 [label="ContainingNamespace 435528"];
5677 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 435529"];
5678 [label="this.ContainingSymbol 435530"];
5679 [label="get { return _containingNamespaceSymbol; } 435531"];
5680 [label="return _containingNamespaceSymbol; 435532"];
5681 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 435533"];
5682 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 435534"];
5683 [label="var ns = container as NamespaceSymbol; 435535"];
5684 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 435536"];
5685 [label="if ((object)ns != null)\n                    {\n                        return ns;\n                    } 435537"];
5686 [label="return ns; 435538"];
5687 [label="var parent = ContainingNamespace; 435539"];
5688 [label=".IsGlobalNamespace 435540"];
5689 [label="get\n            {\n                return false;\n            } 435541"];
5690 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 435542"];
5691 [label="while (parent?.IsGlobalNamespace == false)\n            {\n                // add name of the parent + '.'\n                length += parent.Name.Length + 1;\n                parent = parent.ContainingNamespace;\n            } 435543"];
5692 [label="parent.Name 435544"];
5693 [label="get\n            {\n                return _name;\n            } 435545"];
5694 [label="length += parent.Name.Length + 1; 435546"];
5695 [label="length += parent.Name.Length + 1; 435547"];
5696 [label="parent.ContainingNamespace 435548"];
5697 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 435549"];
5698 [label="this.ContainingSymbol 435550"];
5699 [label="for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                } 435551"];
5700 [label="parent = parent.ContainingNamespace; 435552"];
5701 [label="get\n            {\n                return true;\n            } 435553"];
5702 [label="_containingNamespaceSymbol 435554"];
5703 [label="_name 435555"];
5704 [label="_typesByNS 435556"];
5705 [label="Debug.Assert(name != null); 435557"];
5706 [label="Debug.Assert((object)containingNamespace != null); 435558"];
5707 [label="Debug.Assert(typesByNS != null); 435559"];
5708 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 435560"];
5709 [label="genericParameterHandles 435561"];
5710 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435562"];
5711 [label="param GetGenericInfo(out ushort arity) 435563"];
5712 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435564"];
5713 [label="mrEx = null; 435565"];
5714 [label="PENamedTypeSymbol result; 435566"];
5715 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 435567"];
5716 [label="mangleName 435568"];
5717 [label="param PENamedTypeSymbol(out bool mangleName) 435569"];
5718 [label="_lazyTupleData 435570"];
5719 [label="_container 435571"];
5720 [label="_name 435572"];
5721 [label="_flags 435573"];
5722 [label="_corTypeId 435574"];
5723 [label="Debug.Assert(!handle.IsNil); 435575"];
5724 [label="Debug.Assert((object)container != null); 435576"];
5725 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435577"];
5726 [label="string metadataName; 435578"];
5727 [label="bool makeBad = false; 435579"];
5728 [label="mangleName = false; 435580"];
5729 [label="Accessibility access = Accessibility.Private; 435581"];
5730 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435582"];
5731 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435583"];
5732 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435584"];
5733 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435585"];
5734 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435586"];
5735 [label="bool added; 435587"];
5736 [label="Debug.Assert(added); 435588"];
5737 [label="EnsureAllMembersLoaded(); 435589"];
5738 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 435590"];
5739 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435591"];
5740 [label="if ((object)scope == null)\n                {\n                    break;\n                } 435592"];
5741 [label="if ((object)scope == null)\n            {\n                // We failed to locate the namespace\n                result = new MissingMetadataTypeSymbol.TopLevel(this, ref emittedName);\n            }\n            else\n            {\n                result = scope.LookupMetadataType(ref emittedName);\n            } 435593"];
5742 [label="result = scope.LookupMetadataType(ref emittedName); 435594"];
5743 [label="scope.LookupMetadataType(ref emittedName) 435595"];
5744 [label="param LookupMetadataType(ref MetadataTypeName emittedTypeName) 435596"];
5745 [label="param LookupMetadataType(this) 435597"];
5746 [label="Debug.Assert(!emittedTypeName.IsNull); 435598"];
5747 [label="NamespaceOrTypeSymbol scope = this; 435599"];
5748 [label="scope.Kind 435600"];
5749 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435601"];
5750 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 435602"];
5751 [label="NamedTypeSymbol? namedType = null; 435603"];
5752 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 435604"];
5753 [label="namespaceOrTypeMembers 435605"];
5754 [label="scope.IsNamespace 435606"];
5755 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 435607"];
5756 [label="Kind 435608"];
5757 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 435609"];
5758 [label="return Kind == SymbolKind.Namespace; 435610"];
5759 [label="bool isTopLevel = scope.IsNamespace; 435611"];
5760 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 435612"];
5761 [label="scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) 435613"];
5762 [label="param ToDisplayString(SymbolDisplayFormat format = null) 435614"];
5763 [label="param ToDisplayString(this) 435615"];
5764 [label="ISymbol 435616"];
5765 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 435617"];
5766 [label="if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                } 435618"];
5767 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 435619"];
5768 [label="CreateISymbol() 435620"];
5769 [label="param CreateISymbol(this) 435621"];
5770 [label="return new PublicModel.NamespaceSymbol(this); 435622"];
5771 [label="return new PublicModel.NamespaceSymbol(this); 435623"];
5772 [label="new PublicModel.NamespaceSymbol(this) 435624"];
5773 [label="param NamespaceSymbol(Symbols.NamespaceSymbol underlying) 435625"];
5774 [label="param NamespaceSymbol(this) 435626"];
5775 [label="param NamespaceSymbol(this) 435627"];
5776 [label="param NamespaceOrTypeSymbol(this) 435628"];
5777 [label="param NamespaceOrTypeSymbol(this) 435629"];
5778 [label="param Symbol(this) 435630"];
5779 [label="_underlying 435631"];
5780 [label="Debug.Assert(underlying is object); 435632"];
5781 [label="_underlying 435633"];
5782 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 435634"];
5783 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 435635"];
5784 [label="Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null); 435636"];
5785 [label="return _lazyISymbol; 435637"];
5786 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 435638"];
5787 [label="return SymbolDisplay.ToDisplayString(ISymbol, format); 435639"];
5788 [label="SymbolDisplay.ToDisplayString(ISymbol, format) 435640"];
5789 [label="param ToDisplayString(ISymbol symbol) 435641"];
5790 [label="param ToDisplayString(SymbolDisplayFormat? format = null) 435642"];
5791 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 435643"];
5792 [label="return ToDisplayParts(symbol, format).ToDisplayString(); 435644"];
5793 [label="ToDisplayParts(symbol, format) 435645"];
5794 [label="param ToDisplayParts(ISymbol symbol) 435646"];
5795 [label="param ToDisplayParts(SymbolDisplayFormat? format = null) 435647"];
5796 [label="format = format ?? SymbolDisplayFormat.CSharpErrorMessageFormat; 435648"];
5797 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 435649"];
5798 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 435650"];
5799 [label="return ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false); 435651"];
5800 [label="ToDisplayParts(\n                symbol, semanticModelOpt: null, positionOpt: -1, format: format, minimal: false) 435652"];
5801 [label="param ToDisplayParts(ISymbol symbol) 435653"];
5802 [label="param ToDisplayParts(SemanticModel? semanticModelOpt) 435654"];
5803 [label="param ToDisplayParts(int positionOpt) 435655"];
5804 [label="param ToDisplayParts(SymbolDisplayFormat format) 435656"];
5805 [label="param ToDisplayParts(bool minimal) 435657"];
5806 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 435658"];
5807 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 435659"];
5808 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 435660"];
5809 [label="Debug.Assert(semanticModelOpt == null); 435661"];
5810 [label="Debug.Assert(semanticModelOpt == null); 435662"];
5811 [label="Debug.Assert(positionOpt < 0); 435663"];
5812 [label="Debug.Assert(positionOpt < 0); 435664"];
5813 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 435665"];
5814 [label="var builder = ArrayBuilder<SymbolDisplayPart>.GetInstance(); 435666"];
5815 [label="'modopt' 435667"];
5816 [label="IL_KEYWORD_MODOPT = 'modopt' 435668"];
5817 [label="'modreq' 435669"];
5818 [label="IL_KEYWORD_MODREQ = 'modreq' 435670"];
5819 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 435671"];
5820 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 435672"];
5821 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 435673"];
5822 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 435674"];
5823 [label="var visitor = new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt); 435675"];
5824 [label="new SymbolDisplayVisitor(builder, format, semanticModelOpt, positionOpt) 435676"];
5825 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 435677"];
5826 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 435678"];
5827 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 435679"];
5828 [label="param SymbolDisplayVisitor(int positionOpt) 435680"];
5829 [label="param SymbolDisplayVisitor(this) 435681"];
5830 [label="builder 435682"];
5831 [label="format 435683"];
5832 [label="true 435684"];
5833 [label="semanticModelOpt 435685"];
5834 [label="positionOpt 435686"];
5835 [label="param SymbolDisplayVisitor(this) 435687"];
5836 [label="param SymbolDisplayVisitor(this) 435688"];
5837 [label="_escapeKeywordIdentifiers 435689"];
5838 [label="_lazyAliasMap 435690"];
5839 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 435691"];
5840 [label="_escapeKeywordIdentifiers = format.MiscellaneousOptions.IncludesOption(SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers); 435692"];
5841 [label="_escapeKeywordIdentifiers 435693"];
5842 [label="symbol.Accept(visitor); 435694"];
5843 [label="symbol.Accept(visitor) 435695"];
5844 [label="param Accept(SymbolVisitor visitor) 435696"];
5845 [label="param Accept(this) 435697"];
5846 [label="Accept(visitor); 435698"];
5847 [label="Accept(visitor) 435699"];
5848 [label="param Accept(SymbolVisitor visitor) 435700"];
5849 [label="param Accept(this) 435701"];
5850 [label="visitor.VisitNamespace(this); 435702"];
5851 [label="visitor.VisitNamespace(this) 435703"];
5852 [label="param VisitNamespace(INamespaceSymbol symbol) 435704"];
5853 [label="param VisitNamespace(this) 435705"];
5854 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 435706"];
5855 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 435707"];
5856 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 435708"];
5857 [label="if (format.TypeQualificationStyle == SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                var containingNamespace = symbol.ContainingNamespace;\n                if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                }\n            } 435709"];
5858 [label="symbol.ContainingNamespace 435710"];
5859 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 435711"];
5860 [label="UnderlyingSymbol 435712"];
5861 [label="=> _underlying 435713"];
5862 [label="_underlying 435714"];
5863 [label="UnderlyingSymbol.ContainingNamespace 435715"];
5864 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 435716"];
5865 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 435717"];
5866 [label="param GetPublicSymbol(this NamespaceSymbol? symbol) 435718"];
5867 [label="return symbol.GetPublicSymbol<INamespaceSymbol>(); 435719"];
5868 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 435720"];
5869 [label="param GetPublicSymbol(this Symbol? symbol) 435721"];
5870 [label=".ISymbol 435722"];
5871 [label="get\n            {\n                if (_lazyISymbol is null)\n                {\n                    Interlocked.CompareExchange(ref _lazyISymbol, CreateISymbol(), null);\n                }\n\n                return _lazyISymbol;\n            } 435723"];
5872 [label="param NamespaceOrTypeSymbol(this) 435724"];
5873 [label="param Symbol(this) 435725"];
5874 [label="_underlying 435726"];
5875 [label="Debug.Assert(underlying is object); 435727"];
5876 [label="return (TISymbol?)symbol?.ISymbol; 435728"];
5877 [label="var containingNamespace = symbol.ContainingNamespace; 435729"];
5878 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 435730"];
5879 [label="ShouldVisitNamespace(containingNamespace) 435731"];
5880 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 435732"];
5881 [label="param ShouldVisitNamespace(this) 435733"];
5882 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 435734"];
5883 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 435735"];
5884 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 435736"];
5885 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 435737"];
5886 [label="namespaceSymbol.IsGlobalNamespace 435738"];
5887 [label="=> _underlying.IsGlobalNamespace 435739"];
5888 [label="_underlying.IsGlobalNamespace 435740"];
5889 [label="get\n            {\n                return false;\n            } 435741"];
5890 [label="return\n                !namespaceSymbol.IsGlobalNamespace ||\n                format.GlobalNamespaceStyle == SymbolDisplayGlobalNamespaceStyle.Included; 435742"];
5891 [label="if (ShouldVisitNamespace(containingNamespace))\n                {\n                    containingNamespace.Accept(this.NotFirstVisitor);\n                    AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken);\n                } 435743"];
5892 [label="containingNamespace.Accept(this.NotFirstVisitor); 435744"];
5893 [label="this.NotFirstVisitor 435745"];
5894 [label="param MakeNotFirstVisitor(bool inNamespaceOrType = false) 435746"];
5895 [label="param MakeNotFirstVisitor(this) 435747"];
5896 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 435748"];
5897 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 435749"];
5898 [label="return new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType); 435750"];
5899 [label="new SymbolDisplayVisitor(\n                this.builder,\n                this.format,\n                this.semanticModelOpt,\n                this.positionOpt,\n                _escapeKeywordIdentifiers,\n                _lazyAliasMap,\n                isFirstSymbolVisited: false,\n                inNamespaceOrType: inNamespaceOrType) 435751"];
5900 [label="param SymbolDisplayVisitor(ArrayBuilder<SymbolDisplayPart> builder) 435752"];
5901 [label="param SymbolDisplayVisitor(SymbolDisplayFormat format) 435753"];
5902 [label="param SymbolDisplayVisitor(SemanticModel semanticModelOpt) 435754"];
5903 [label="param SymbolDisplayVisitor(int positionOpt) 435755"];
5904 [label="param SymbolDisplayVisitor(bool escapeKeywordIdentifiers) 435756"];
5905 [label="param SymbolDisplayVisitor(IDictionary<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap) 435757"];
5906 [label="param SymbolDisplayVisitor(bool isFirstSymbolVisited) 435758"];
5907 [label="param SymbolDisplayVisitor(bool inNamespaceOrType = false) 435759"];
5908 [label="param SymbolDisplayVisitor(this) 435760"];
5909 [label="builder 435761"];
5910 [label="format 435762"];
5911 [label="isFirstSymbolVisited 435763"];
5912 [label="semanticModelOpt 435764"];
5913 [label="positionOpt 435765"];
5914 [label="inNamespaceOrType 435766"];
5915 [label="param SymbolDisplayVisitor(this) 435767"];
5916 [label="param SymbolDisplayVisitor(this) 435768"];
5917 [label="_escapeKeywordIdentifiers 435769"];
5918 [label="_lazyAliasMap 435770"];
5919 [label="containingNamespace.Accept(this.NotFirstVisitor); 435771"];
5920 [label="containingNamespace.Accept(this.NotFirstVisitor); 435772"];
5921 [label="containingNamespace.Accept(this.NotFirstVisitor) 435773"];
5922 [label="param Accept(SymbolVisitor visitor) 435774"];
5923 [label="param Accept(this) 435775"];
5924 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 435776"];
5925 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 435777"];
5926 [label="symbol.ContainingNamespace 435778"];
5927 [label="=> UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 435779"];
5928 [label="UnderlyingSymbol 435780"];
5929 [label="UnderlyingSymbol.ContainingNamespace 435781"];
5930 [label="UnderlyingSymbol.ContainingNamespace.GetPublicSymbol() 435782"];
5931 [label="symbol.GetPublicSymbol<INamespaceSymbol>() 435783"];
5932 [label=".ISymbol 435784"];
5933 [label="param NamespaceOrTypeSymbol(this) 435785"];
5934 [label="param Symbol(this) 435786"];
5935 [label="_underlying 435787"];
5936 [label="Debug.Assert(underlying is object); 435788"];
5937 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 435789"];
5938 [label="param ShouldVisitNamespace(this) 435790"];
5939 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 435791"];
5940 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 435792"];
5941 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 435793"];
5942 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 435794"];
5943 [label="=> _underlying.IsGlobalNamespace 435795"];
5944 [label="get\n            {\n                return false;\n            } 435796"];
5945 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 435797"];
5946 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 435798"];
5947 [label="get\n            {\n                return true;\n            } 435799"];
5948 [label="symbol.IsGlobalNamespace 435800"];
5949 [label="=> _underlying.IsGlobalNamespace 435801"];
5950 [label="get\n            {\n                return false;\n            } 435802"];
5951 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 435803"];
5952 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435804"];
5953 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435805"];
5954 [label="symbol.Name 435806"];
5955 [label="=> UnderlyingSymbol.Name 435807"];
5956 [label="UnderlyingSymbol 435808"];
5957 [label="=> _underlying 435809"];
5958 [label="UnderlyingSymbol.Name 435810"];
5959 [label="get\n            {\n                return _name;\n            } 435811"];
5960 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435812"];
5961 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 435813"];
5962 [label="param CreatePart(SymbolDisplayPartKind kind) 435814"];
5963 [label="param CreatePart(ISymbol symbol) 435815"];
5964 [label="param CreatePart(string text) 435816"];
5965 [label="param CreatePart(this) 435817"];
5966 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435818"];
5967 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435819"];
5968 [label="(text == null) 435820"];
5969 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435821"];
5970 [label="(_escapeKeywordIdentifiers && IsEscapable(kind)) 435822"];
5971 [label="return new SymbolDisplayPart(kind, symbol, text); 435823"];
5972 [label="return new SymbolDisplayPart(kind, symbol, text); 435824"];
5973 [label="return new SymbolDisplayPart(kind, symbol, text); 435825"];
5974 [label="return new SymbolDisplayPart(kind, symbol, text); 435826"];
5975 [label="visitor.VisitNamespace(this); 435827"];
5976 [label="containingNamespace.IsGlobalNamespace 435828"];
5977 [label="=> _underlying.IsGlobalNamespace 435829"];
5978 [label="get\n            {\n                return false;\n            } 435830"];
5979 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 435831"];
5980 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 435832"];
5981 [label="param AddPunctuation(SyntaxKind punctuationKind) 435833"];
5982 [label="param AddPunctuation(this) 435834"];
5983 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435835"];
5984 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435836"];
5985 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435837"];
5986 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 435838"];
5987 [label="param CreatePart(SymbolDisplayPartKind kind) 435839"];
5988 [label="param CreatePart(ISymbol symbol) 435840"];
5989 [label="param CreatePart(string text) 435841"];
5990 [label="param CreatePart(this) 435842"];
5991 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435843"];
5992 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435844"];
5993 [label="(text == null) 435845"];
5994 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435846"];
5995 [label="return new SymbolDisplayPart(kind, symbol, text); 435847"];
5996 [label="return new SymbolDisplayPart(kind, symbol, text); 435848"];
5997 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 435849"];
5998 [label="symbol.IsGlobalNamespace 435850"];
5999 [label="=> _underlying.IsGlobalNamespace 435851"];
6000 [label="get\n            {\n                return false;\n            } 435852"];
6001 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 435853"];
6002 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435854"];
6003 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435855"];
6004 [label="symbol.Name 435856"];
6005 [label="=> UnderlyingSymbol.Name 435857"];
6006 [label="UnderlyingSymbol 435858"];
6007 [label="=> _underlying 435859"];
6008 [label="UnderlyingSymbol.Name 435860"];
6009 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 435861"];
6010 [label="param CreatePart(SymbolDisplayPartKind kind) 435862"];
6011 [label="param CreatePart(ISymbol symbol) 435863"];
6012 [label="param CreatePart(this) 435864"];
6013 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435865"];
6014 [label="return new SymbolDisplayPart(kind, symbol, text); 435866"];
6015 [label="return new SymbolDisplayPart(kind, symbol, text); 435867"];
6016 [label="visitor.VisitNamespace(this); 435868"];
6017 [label="containingNamespace.Accept(this.NotFirstVisitor); 435869"];
6018 [label="containingNamespace.IsGlobalNamespace 435870"];
6019 [label="=> _underlying.IsGlobalNamespace 435871"];
6020 [label="get\n            {\n                return false;\n            } 435872"];
6021 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 435873"];
6022 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken) 435874"];
6023 [label="param AddPunctuation(SyntaxKind punctuationKind) 435875"];
6024 [label="param AddPunctuation(this) 435876"];
6025 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435877"];
6026 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435878"];
6027 [label="builder.Add(CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind))); 435879"];
6028 [label="CreatePart(SymbolDisplayPartKind.Punctuation, null, SyntaxFacts.GetText(punctuationKind)) 435880"];
6029 [label="param CreatePart(SymbolDisplayPartKind kind) 435881"];
6030 [label="param CreatePart(ISymbol symbol) 435882"];
6031 [label="param CreatePart(string text) 435883"];
6032 [label="param CreatePart(this) 435884"];
6033 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435885"];
6034 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435886"];
6035 [label="(text == null) 435887"];
6036 [label="return new SymbolDisplayPart(kind, symbol, text); 435888"];
6037 [label="return new SymbolDisplayPart(kind, symbol, text); 435889"];
6038 [label="AddPunctuation(containingNamespace.IsGlobalNamespace ? SyntaxKind.ColonColonToken : SyntaxKind.DotToken); 435890"];
6039 [label="symbol.IsGlobalNamespace 435891"];
6040 [label="=> _underlying.IsGlobalNamespace 435892"];
6041 [label="_underlying.IsGlobalNamespace 435893"];
6042 [label="get\n            {\n                return false;\n            } 435894"];
6043 [label="if (symbol.IsGlobalNamespace)\n            {\n                AddGlobalNamespace(symbol);\n            }\n            else\n            {\n                builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name));\n            } 435895"];
6044 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435896"];
6045 [label="builder.Add(CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name)); 435897"];
6046 [label="symbol.Name 435898"];
6047 [label="=> UnderlyingSymbol.Name 435899"];
6048 [label="UnderlyingSymbol 435900"];
6049 [label="=> _underlying 435901"];
6050 [label="UnderlyingSymbol.Name 435902"];
6051 [label="CreatePart(SymbolDisplayPartKind.NamespaceName, symbol, symbol.Name) 435903"];
6052 [label="param CreatePart(SymbolDisplayPartKind kind) 435904"];
6053 [label="param CreatePart(ISymbol symbol) 435905"];
6054 [label="param CreatePart(this) 435906"];
6055 [label="text = (text == null) ? '?' :\n                   (_escapeKeywordIdentifiers && IsEscapable(kind)) ? EscapeIdentifier(text) : text; 435907"];
6056 [label="return new SymbolDisplayPart(kind, symbol, text); 435908"];
6057 [label="return new SymbolDisplayPart(kind, symbol, text); 435909"];
6058 [label="visitor.VisitNamespace(this); 435910"];
6059 [label="Accept(visitor); 435911"];
6060 [label="symbol.Accept(visitor); 435912"];
6061 [label="return builder.ToImmutableAndFree(); 435913"];
6062 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 435914"];
6063 [label="Debug.Assert(!isTopLevel || scope.ToDisplayString(SymbolDisplayFormat.QualifiedNameOnlyFormat) == emittedTypeName.NamespaceName); 435915"];
6064 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 435916"];
6065 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 435917"];
6066 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 435918"];
6067 [label="int forcedArity = emittedTypeName.ForcedArity; 435919"];
6068 [label="if (emittedTypeName.UseCLSCompliantNameArityEncoding)\n            {\n                // Only types with arity 0 are acceptable, we already examined types with mangled names.\n                if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                }\n            } 435920"];
6069 [label="if (emittedTypeName.InferredArity > 0)\n                {\n                    goto Done;\n                }\n                else if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 435921"];
6070 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 435922"];
6071 [label="if (forcedArity == -1)\n                {\n                    forcedArity = 0;\n                }\n                else if (forcedArity != 0)\n                {\n                    goto Done;\n                }\n                else\n                {\n                    Debug.Assert(forcedArity == emittedTypeName.InferredArity);\n                } 435923"];
6072 [label="forcedArity = 0; 435924"];
6073 [label="namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.TypeName); 435925"];
6074 [label="scope.GetTypeMembers(emittedTypeName.TypeName) 435926"];
6075 [label="param GetTypeMembers(string name) 435927"];
6076 [label="param GetTypeMembers(this) 435928"];
6077 [label="EnsureAllMembersLoaded() 435929"];
6078 [label="param EnsureAllMembersLoaded(this) 435930"];
6079 [label="var typesByNS = _typesByNS; 435931"];
6080 [label="if (lazyTypes == null || lazyNamespaces == null)\n            {\n                System.Diagnostics.Debug.Assert(typesByNS != null);\n                LoadAllMembers(typesByNS);\n                Interlocked.Exchange(ref _typesByNS, null);\n            } 435932"];
6081 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 435933"];
6082 [label="Debug.Assert(typesByNS != null); 435934"];
6083 [label="get\n            {\n                return false;\n            } 435935"];
6084 [label="parent.ContainingNamespace 435936"];
6085 [label="parent = parent.ContainingNamespace; 435937"];
6086 [label="get\n            {\n                return false;\n            } 435938"];
6087 [label="get\n            {\n                return true;\n            } 435939"];
6088 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 435940"];
6089 [label="genericParameterHandles 435941"];
6090 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 435942"];
6091 [label="param GetGenericInfo(out ushort arity) 435943"];
6092 [label="param GetGenericInfo(out BadImageFormatException mrEx) 435944"];
6093 [label="mrEx = null; 435945"];
6094 [label="PENamedTypeSymbol result; 435946"];
6095 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 435947"];
6096 [label="mangleName 435948"];
6097 [label="param PENamedTypeSymbol(out bool mangleName) 435949"];
6098 [label="_lazyTupleData 435950"];
6099 [label="_container 435951"];
6100 [label="_name 435952"];
6101 [label="_flags 435953"];
6102 [label="_corTypeId 435954"];
6103 [label="Debug.Assert(!handle.IsNil); 435955"];
6104 [label="Debug.Assert((object)container != null); 435956"];
6105 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 435957"];
6106 [label="string metadataName; 435958"];
6107 [label="bool makeBad = false; 435959"];
6108 [label="mangleName = false; 435960"];
6109 [label="Accessibility access = Accessibility.Private; 435961"];
6110 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 435962"];
6111 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435963"];
6112 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 435964"];
6113 [label="param PENamedTypeSymbolGeneric(out bool mangleName) 435965"];
6114 [label="mangleName 435966"];
6115 [label="param PENamedTypeSymbol(out bool mangleName) 435967"];
6116 [label="Debug.Assert(ReferenceEquals(_name, metadataName) == (_name == metadataName)); 435968"];
6117 [label="_arity 435969"];
6118 [label="_mangleName 435970"];
6119 [label="Debug.Assert(genericParameterHandles.Count > 0); 435971"];
6120 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435972"];
6121 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 435973"];
6122 [label="bool added; 435974"];
6123 [label="Debug.Assert(added); 435975"];
6124 [label="Debug.Assert(typeId != SpecialType.None); 435976"];
6125 [label="corType.ContainingAssembly 435977"];
6126 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 435978"];
6127 [label="this.ContainingSymbol 435979"];
6128 [label="get\n            {\n                return _container;\n            } 435980"];
6129 [label="return _container; 435981"];
6130 [label="var container = this.ContainingSymbol; 435982"];
6131 [label="return (object)container != null ? container.ContainingAssembly : null; 435983"];
6132 [label="return (object)container != null ? container.ContainingAssembly : null; 435984"];
6133 [label="(object)container != null 435985"];
6134 [label="container.ContainingAssembly 435986"];
6135 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 435987"];
6136 [label="ContainingPEModule 435988"];
6137 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 435989"];
6138 [label="return ContainingPEModule.ContainingAssembly; 435990"];
6139 [label="ContainingPEModule.ContainingAssembly 435991"];
6140 [label="get\n            {\n                return _assemblySymbol;\n            } 435992"];
6141 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435993"];
6142 [label="Debug.Assert(ReferenceEquals(corType.ContainingAssembly, this)); 435994"];
6143 [label="corType.ContainingModule 435995"];
6144 [label="get\n            {\n                return ContainingPEModule;\n            } 435996"];
6145 [label="ContainingPEModule 435997"];
6146 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 435998"];
6147 [label="Symbol s = _container; 435999"];
6148 [label="s.Kind 436000"];
6149 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436001"];
6150 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 436002"];
6151 [label="((PENamespaceSymbol)s).ContainingPEModule 436003"];
6152 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436004"];
6153 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 436005"];
6154 [label="return ContainingPEModule; 436006"];
6155 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 436007"];
6156 [label="corType.ContainingModule.Ordinal 436008"];
6157 [label="get\n            {\n                return _ordinal;\n            } 436009"];
6158 [label="return _ordinal; 436010"];
6159 [label="Debug.Assert(corType.ContainingModule.Ordinal == 0); 436011"];
6160 [label="Debug.Assert(ReferenceEquals(this.CorLibrary, this)); 436012"];
6161 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 436013"];
6162 [label="Debug.Assert(_cachedSpecialTypes > 0 && _cachedSpecialTypes <= (int)SpecialType.Count); 436014"];
6163 [label="EnsureAllMembersLoaded(); 436015"];
6164 [label="ImmutableArray<PENamedTypeSymbol> t; 436016"];
6165 [label="t 436017"];
6166 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 436018"];
6167 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 436019"];
6168 [label="return lazyTypes.TryGetValue(name, out t)\n                ? StaticCast<NamedTypeSymbol>.From(t)\n                : ImmutableArray<NamedTypeSymbol>.Empty; 436020"];
6169 [label="lazyTypes.TryGetValue(name, out t) 436021"];
6170 [label="foreach (var named in namespaceOrTypeMembers)\n            {\n                if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                }\n            } 436022"];
6171 [label="named.MangleName 436023"];
6172 [label="get\n                {\n                    return false;\n                } 436024"];
6173 [label="return false; 436025"];
6174 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436026"];
6175 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436027"];
6176 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436028"];
6177 [label="named.Arity 436029"];
6178 [label="get\n                {\n                    return 0;\n                } 436030"];
6179 [label="return 0; 436031"];
6180 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436032"];
6181 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436033"];
6182 [label="if (!named.MangleName && (forcedArity == -1 || forcedArity == named.Arity))\n                {\n                    if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    }\n\n                    namedType = named;\n                } 436034"];
6183 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 436035"];
6184 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 436036"];
6185 [label="namedType = named; 436037"];
6186 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 436038"];
6187 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 436039"];
6188 [label="return namedType; 436040"];
6189 [label="Debug.Assert((object)result != null); 436041"];
6190 [label="Debug.Assert((object)result != null); 436042"];
6191 [label="return result; 436043"];
6192 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 436044"];
6193 [label="bool foundMatchInThisAssembly = (i < count); 436045"];
6194 [label="result.ContainingAssembly 436046"];
6195 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 436047"];
6196 [label="this.ContainingSymbol 436048"];
6197 [label="get\n            {\n                return _container;\n            } 436049"];
6198 [label="return _container; 436050"];
6199 [label="var container = this.ContainingSymbol; 436051"];
6200 [label="return (object)container != null ? container.ContainingAssembly : null; 436052"];
6201 [label="return (object)container != null ? container.ContainingAssembly : null; 436053"];
6202 [label="(object)container != null 436054"];
6203 [label="container.ContainingAssembly 436055"];
6204 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 436056"];
6205 [label="ContainingPEModule 436057"];
6206 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436058"];
6207 [label="return ContainingPEModule.ContainingAssembly; 436059"];
6208 [label="ContainingPEModule.ContainingAssembly 436060"];
6209 [label="get\n            {\n                return _assemblySymbol;\n            } 436061"];
6210 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436062"];
6211 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436063"];
6212 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 436064"];
6213 [label="System.Diagnostics.Debug.Assert((object)result != null); 436065"];
6214 [label="System.Diagnostics.Debug.Assert((object)result != null); 436066"];
6215 [label="if (digThroughForwardedTypes || foundMatchInThisAssembly)\n                {\n                    CacheTopLevelMetadataType(ref emittedName, result);\n                } 436067"];
6216 [label="CacheTopLevelMetadataType(ref emittedName, result); 436068"];
6217 [label="CacheTopLevelMetadataType(ref emittedName, result); 436069"];
6218 [label="CacheTopLevelMetadataType(ref emittedName, result) 436070"];
6219 [label="param CacheTopLevelMetadataType(ref MetadataTypeName emittedName) 436071"];
6220 [label="param CacheTopLevelMetadataType(NamedTypeSymbol result) 436072"];
6221 [label="param CacheTopLevelMetadataType(this) 436073"];
6222 [label="NamedTypeSymbol result1 = null; 436074"];
6223 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 436075"];
6224 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 436076"];
6225 [label="result1 = _emittedNameToTypeMap.GetOrAdd(emittedName.ToKey(), result); 436077"];
6226 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 436078"];
6227 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 436079"];
6228 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 436080"];
6229 [label="TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2) 436081"];
6230 [label="param Equals(TypeSymbol left) 436082"];
6231 [label="param Equals(TypeSymbol right) 436083"];
6232 [label="param Equals(TypeCompareKind comparison) 436084"];
6233 [label="if (left is null)\n            {\n                return right is null;\n            } 436085"];
6234 [label="return left.Equals(right, comparison); 436086"];
6235 [label="return left.Equals(right, comparison); 436087"];
6236 [label="left.Equals(right, comparison) 436088"];
6237 [label="param Equals(TypeSymbol t2) 436089"];
6238 [label="param Equals(TypeCompareKind comparison) 436090"];
6239 [label="param Equals(this) 436091"];
6240 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 436092"];
6241 [label="t2 is NativeIntegerTypeSymbol nativeInteger 436093"];
6242 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 436094"];
6243 [label="base.Equals(t2, comparison) 436095"];
6244 [label="param Equals(TypeSymbol t2) 436096"];
6245 [label="param Equals(TypeCompareKind comparison) 436097"];
6246 [label="param Equals(this) 436098"];
6247 [label="if ((object)t2 == this) return true; 436099"];
6248 [label="return true; 436100"];
6249 [label="CacheTopLevelMetadataType(ref emittedName, result); 436101"];
6250 [label="return result; 436102"];
6251 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436103"];
6252 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 436104"];
6253 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 436105"];
6254 [label="candidate.Kind 436106"];
6255 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 436107"];
6256 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436108"];
6257 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436109"];
6258 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 436110"];
6259 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 436111"];
6260 [label="return result; 436112"];
6261 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436113"];
6262 [label="IsValidWellKnownType(candidate) 436114"];
6263 [label="param IsValidWellKnownType(NamedTypeSymbol result) 436115"];
6264 [label="param IsValidWellKnownType(this) 436116"];
6265 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436117"];
6266 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436118"];
6267 [label="result.TypeKind 436119"];
6268 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 436120"];
6269 [label="TypeKind result = _lazyKind; 436121"];
6270 [label="if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                } 436122"];
6271 [label="if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    } 436123"];
6272 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 436124"];
6273 [label="GetDeclaredBaseType(skipTransformsIfNecessary: true) 436125"];
6274 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 436126"];
6275 [label="param GetDeclaredBaseType(this) 436127"];
6276 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 436128"];
6277 [label="if (ReferenceEquals(_lazyDeclaredBaseType, ErrorTypeSymbol.UnknownResultType))\n            {\n                var baseType = MakeDeclaredBaseType();\n                if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                }\n\n                Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType);\n            } 436129"];
6278 [label="MakeDeclaredBaseType() 436130"];
6279 [label="param MakeDeclaredBaseType(this) 436131"];
6280 [label="if (!_flags.IsInterface())\n            {\n                try\n                {\n                    var moduleSymbol = ContainingPEModule;\n                    EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle);\n                    if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    }\n                }\n                catch (BadImageFormatException mrEx)\n                {\n                    return new UnsupportedMetadataTypeSymbol(mrEx);\n                }\n            } 436132"];
6281 [label="ContainingPEModule 436133"];
6282 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 436134"];
6283 [label="Symbol s = _container; 436135"];
6284 [label="s.Kind 436136"];
6285 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436137"];
6286 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 436138"];
6287 [label="((PENamespaceSymbol)s).ContainingPEModule 436139"];
6288 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436140"];
6289 [label="return ((PENamespaceSymbol)s).ContainingPEModule; 436141"];
6290 [label="var moduleSymbol = ContainingPEModule; 436142"];
6291 [label="moduleSymbol.Module 436143"];
6292 [label="get\n            {\n                return _module;\n            } 436144"];
6293 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 436145"];
6294 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 436146"];
6295 [label="if (!token.IsNil)\n                    {\n                        return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token);\n                    } 436147"];
6296 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 436148"];
6297 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 436149"];
6298 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 436150"];
6299 [label="new MetadataDecoder(moduleSymbol, this) 436151"];
6300 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 436152"];
6301 [label="param MetadataDecoder(PENamedTypeSymbol context) 436153"];
6302 [label="param MetadataDecoder(this) 436154"];
6303 [label="moduleSymbol 436155"];
6304 [label="context 436156"];
6305 [label="null 436157"];
6306 [label="param MetadataDecoder(this) 436158"];
6307 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 436159"];
6308 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 436160"];
6309 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 436161"];
6310 [label="param MetadataDecoder(this) 436162"];
6311 [label="moduleSymbol.Module 436163"];
6312 [label="get\n            {\n                return _module;\n            } 436164"];
6313 [label="moduleSymbol.ContainingAssembly 436165"];
6314 [label="get\n            {\n                return _assemblySymbol;\n            } 436166"];
6315 [label="(moduleSymbol.ContainingAssembly is PEAssemblySymbol) 436167"];
6316 [label="moduleSymbol.ContainingAssembly 436168"];
6317 [label="moduleSymbol.ContainingAssembly.Identity 436169"];
6318 [label="get\n            {\n                return _assembly.Identity;\n            } 436170"];
6319 [label="return _assembly.Identity; 436171"];
6320 [label="new SymbolFactory() 436172"];
6321 [label="param SymbolFactory(this) 436173"];
6322 [label="Instance = new SymbolFactory() 436174"];
6323 [label="SymbolFactory.Instance 436175"];
6324 [label="moduleSymbol 436176"];
6325 [label="param MetadataDecoder(this) 436177"];
6326 [label="param MetadataDecoder(this) 436178"];
6327 [label="_typeContextOpt 436179"];
6328 [label="_methodContextOpt 436180"];
6329 [label="Debug.Assert((object)moduleSymbol != null); 436181"];
6330 [label="Debug.Assert((object)moduleSymbol != null); 436182"];
6331 [label="_typeContextOpt 436183"];
6332 [label="_methodContextOpt 436184"];
6333 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 436185"];
6334 [label="return (NamedTypeSymbol)new MetadataDecoder(moduleSymbol, this).GetTypeOfToken(token); 436186"];
6335 [label="param GetTypeHandleToTypeMap(this) 436187"];
6336 [label="return moduleSymbol.TypeHandleToTypeMap; 436188"];
6337 [label="var baseType = MakeDeclaredBaseType(); 436189"];
6338 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 436190"];
6339 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 436191"];
6340 [label="return baseType; 436192"];
6341 [label="result = TypeKind.Class; 436193"];
6342 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 436194"];
6343 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 436195"];
6344 [label="@base.SpecialType 436196"];
6345 [label="SpecialType baseCorTypeId = @base.SpecialType; 436197"];
6346 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 436198"];
6347 [label="_lazyKind 436199"];
6348 [label="return result; 436200"];
6349 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436201"];
6350 [label="result.ContainingType 436202"];
6351 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 436203"];
6352 [label="return _container as NamedTypeSymbol; 436204"];
6353 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 436205"];
6354 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 436206"];
6355 [label="result.DeclaredAccessibility 436207"];
6356 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 436208"];
6357 [label="Accessibility access = Accessibility.Private; 436209"];
6358 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 436210"];
6359 [label="return result.DeclaredAccessibility == Accessibility.Public || IsSymbolAccessible(result, this); 436211"];
6360 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436212"];
6361 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436213"];
6362 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436214"];
6363 [label="if (candidate.IsHiddenByCodeAnalysisEmbeddedAttribute())\n                {\n                    continue;\n                } 436215"];
6364 [label="candidate.IsHiddenByCodeAnalysisEmbeddedAttribute() 436216"];
6365 [label="param IsHiddenByCodeAnalysisEmbeddedAttribute(this Symbol symbol) 436217"];
6366 [label="symbol.Kind 436218"];
6367 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 436219"];
6368 [label="var upperLevelType = symbol.Kind == SymbolKind.NamedType ? (NamedTypeSymbol)symbol : symbol.ContainingType; 436220"];
6369 [label="symbol.Kind == SymbolKind.NamedType 436221"];
6370 [label="var upperLevelType = symbol.Kind == SymbolKind.NamedType ? (NamedTypeSymbol)symbol : symbol.ContainingType; 436222"];
6371 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 436223"];
6372 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 436224"];
6373 [label="upperLevelType.ContainingType 436225"];
6374 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 436226"];
6375 [label="return _container as NamedTypeSymbol; 436227"];
6376 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 436228"];
6377 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 436229"];
6378 [label="upperLevelType.HasCodeAnalysisEmbeddedAttribute 436230"];
6379 [label="get\n            {\n                var uncommon = GetUncommonProperties();\n                if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                }\n\n                if (!uncommon.lazyHasEmbeddedAttribute.HasValue())\n                {\n                    uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState();\n                }\n\n                return uncommon.lazyHasEmbeddedAttribute.Value();\n            } 436231"];
6380 [label="GetUncommonProperties() 436232"];
6381 [label="param GetUncommonProperties(this) 436233"];
6382 [label="var result = _lazyUncommonProperties; 436234"];
6383 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 436235"];
6384 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 436236"];
6385 [label="this.IsUncommon() 436237"];
6386 [label="param IsUncommon(this) 436238"];
6387 [label="this.ContainingPEModule 436239"];
6388 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 436240"];
6389 [label="Symbol s = _container; 436241"];
6390 [label="s.Kind 436242"];
6391 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436243"];
6392 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 436244"];
6393 [label="((PENamespaceSymbol)s).ContainingPEModule 436245"];
6394 [label="_containingNamespaceSymbol.ContainingPEModule 436246"];
6395 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 436247"];
6396 [label="if (this.ContainingPEModule.HasAnyCustomAttributes(_handle))\n            {\n                return true;\n            } 436248"];
6397 [label="this.ContainingPEModule.HasAnyCustomAttributes(_handle) 436249"];
6398 [label="param HasAnyCustomAttributes(EntityHandle token) 436250"];
6399 [label="param HasAnyCustomAttributes(this) 436251"];
6400 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 436252"];
6401 [label="foreach (var attr in _module.GetCustomAttributesOrThrow(token))\n                {\n                    return true;\n                } 436253"];
6402 [label="return true; 436254"];
6403 [label="return true; 436255"];
6404 [label="if (this.IsUncommon())\n            {\n                result = new UncommonProperties();\n                return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result;\n            } 436256"];
6405 [label="result = new UncommonProperties(); 436257"];
6406 [label="new UncommonProperties() 436258"];
6407 [label="param UncommonProperties(this) 436259"];
6408 [label="lazyEnumUnderlyingType 436260"];
6409 [label="lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 436261"];
6410 [label="lazyAttributeUsageInfo = AttributeUsageInfo.Null 436262"];
6411 [label="lazyContainsExtensionMethods 436263"];
6412 [label="lazyIsByRefLike 436264"];
6413 [label="lazyIsReadOnly 436265"];
6414 [label="lazyDefaultMemberName 436266"];
6415 [label="lazyComImportCoClassType = ErrorTypeSymbol.UnknownResultType 436267"];
6416 [label="lazyHasEmbeddedAttribute = ThreeState.Unknown 436268"];
6417 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 436269"];
6418 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 436270"];
6419 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 436271"];
6420 [label="return Interlocked.CompareExchange(ref _lazyUncommonProperties, result, null) ?? result; 436272"];
6421 [label="var uncommon = GetUncommonProperties(); 436273"];
6422 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 436274"];
6423 [label="if (!uncommon.lazyHasEmbeddedAttribute.HasValue())\n                {\n                    uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState();\n                } 436275"];
6424 [label="ContainingPEModule 436276"];
6425 [label="s.Kind 436277"];
6426 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436278"];
6427 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 436279"];
6428 [label="uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState(); 436280"];
6429 [label="ContainingPEModule.Module 436281"];
6430 [label="get\n            {\n                return _module;\n            } 436282"];
6431 [label="uncommon.lazyHasEmbeddedAttribute = ContainingPEModule.Module.HasCodeAnalysisEmbeddedAttribute(_handle).ToThreeState(); 436283"];
6432 [label="uncommon.lazyHasEmbeddedAttribute 436284"];
6433 [label="return uncommon.lazyHasEmbeddedAttribute.Value(); 436285"];
6434 [label="return upperLevelType.HasCodeAnalysisEmbeddedAttribute; 436286"];
6435 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 436287"];
6436 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 436288"];
6437 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 436289"];
6438 [label="TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2) 436290"];
6439 [label="param Equals(TypeSymbol left) 436291"];
6440 [label="param Equals(TypeSymbol right) 436292"];
6441 [label="param Equals(TypeCompareKind comparison) 436293"];
6442 [label="if (left is null)\n            {\n                return right is null;\n            } 436294"];
6443 [label="return left.Equals(right, comparison); 436295"];
6444 [label="return left.Equals(right, comparison); 436296"];
6445 [label="left.Equals(right, comparison) 436297"];
6446 [label="param Equals(TypeSymbol t2) 436298"];
6447 [label="param Equals(TypeCompareKind comparison) 436299"];
6448 [label="param Equals(this) 436300"];
6449 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 436301"];
6450 [label="t2 is NativeIntegerTypeSymbol nativeInteger 436302"];
6451 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 436303"];
6452 [label="base.Equals(t2, comparison) 436304"];
6453 [label="param Equals(TypeSymbol t2) 436305"];
6454 [label="param Equals(TypeCompareKind comparison) 436306"];
6455 [label="param Equals(this) 436307"];
6456 [label="if ((object)t2 == this) return true; 436308"];
6457 [label="if ((object)t2 == null) return false; 436309"];
6458 [label="if ((object)t2 == null) return false; 436310"];
6459 [label="return false; 436311"];
6460 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 436312"];
6461 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 436313"];
6462 [label="result = candidate; 436314"];
6463 [label="assembly.IsMissing 436315"];
6464 [label="get\n            {\n                return false;\n            } 436316"];
6465 [label="return false; 436317"];
6466 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 436318"];
6467 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 436319"];
6468 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 436320"];
6469 [label="NamedTypeSymbol result = null; 436321"];
6470 [label="NamedTypeSymbol result; 436322"];
6471 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 436323"];
6472 [label="Debug.Assert(typesByNS != null); 436324"];
6473 [label="get\n            {\n                return true;\n            } 436325"];
6474 [label="_containingNamespaceSymbol 436326"];
6475 [label="_name 436327"];
6476 [label="_typesByNS 436328"];
6477 [label="Debug.Assert(name != null); 436329"];
6478 [label="Debug.Assert((object)containingNamespace != null); 436330"];
6479 [label="Debug.Assert(typesByNS != null); 436331"];
6480 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 436332"];
6481 [label="genericParameterHandles 436333"];
6482 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 436334"];
6483 [label="param GetGenericInfo(out ushort arity) 436335"];
6484 [label="param GetGenericInfo(out BadImageFormatException mrEx) 436336"];
6485 [label="mrEx = null; 436337"];
6486 [label="PENamedTypeSymbol result; 436338"];
6487 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 436339"];
6488 [label="mangleName 436340"];
6489 [label="param PENamedTypeSymbol(out bool mangleName) 436341"];
6490 [label="_lazyTupleData 436342"];
6491 [label="_container 436343"];
6492 [label="_name 436344"];
6493 [label="_flags 436345"];
6494 [label="_corTypeId 436346"];
6495 [label="Debug.Assert(!handle.IsNil); 436347"];
6496 [label="Debug.Assert((object)container != null); 436348"];
6497 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 436349"];
6498 [label="string metadataName; 436350"];
6499 [label="bool makeBad = false; 436351"];
6500 [label="mangleName = false; 436352"];
6501 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 436353"];
6502 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436354"];
6503 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436355"];
6504 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436356"];
6505 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436357"];
6506 [label="bool added; 436358"];
6507 [label="Debug.Assert(added); 436359"];
6508 [label="EnsureAllMembersLoaded(); 436360"];
6509 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 436361"];
6510 [label="if ((object)scope == null)\n                {\n                    break;\n                } 436362"];
6511 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 436363"];
6512 [label="get\n            {\n                return false;\n            } 436364"];
6513 [label="Debug.Assert(!emittedTypeName.IsNull); 436365"];
6514 [label="scope.Kind 436366"];
6515 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436367"];
6516 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 436368"];
6517 [label="NamedTypeSymbol? namedType = null; 436369"];
6518 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 436370"];
6519 [label="namespaceOrTypeMembers 436371"];
6520 [label="scope.IsNamespace 436372"];
6521 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 436373"];
6522 [label="Kind 436374"];
6523 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436375"];
6524 [label="return Kind == SymbolKind.Namespace; 436376"];
6525 [label="bool isTopLevel = scope.IsNamespace; 436377"];
6526 [label="param NamespaceOrTypeSymbol(this) 436378"];
6527 [label="param Symbol(this) 436379"];
6528 [label="_underlying 436380"];
6529 [label="Debug.Assert(underlying is object); 436381"];
6530 [label="param ToDisplayParts(bool minimal) 436382"];
6531 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 436383"];
6532 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 436384"];
6533 [label="Debug.Assert(semanticModelOpt == null); 436385"];
6534 [label="Debug.Assert(positionOpt < 0); 436386"];
6535 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 436387"];
6536 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 436388"];
6537 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436389"];
6538 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436390"];
6539 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 436391"];
6540 [label="param ShouldVisitNamespace(this) 436392"];
6541 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 436393"];
6542 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436394"];
6543 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436395"];
6544 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 436396"];
6545 [label="=> _underlying.IsGlobalNamespace 436397"];
6546 [label="get\n            {\n                return false;\n            } 436398"];
6547 [label="get\n            {\n                return true;\n            } 436399"];
6548 [label="=> _underlying.IsGlobalNamespace 436400"];
6549 [label="get\n            {\n                return false;\n            } 436401"];
6550 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 436402"];
6551 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436403"];
6552 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436404"];
6553 [label="EnsureAllMembersLoaded(); 436405"];
6554 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 436406"];
6555 [label="if ((object?)namedType == null)\n            {\n                if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                }\n            } 436407"];
6556 [label="if (isTopLevel)\n                {\n                    return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName);\n                }\n                else\n                {\n                    return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n                } 436408"];
6557 [label="scope.ContainingModule 436409"];
6558 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 436410"];
6559 [label="_containingNamespaceSymbol.ContainingPEModule 436411"];
6560 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436412"];
6561 [label="return _containingNamespaceSymbol.ContainingPEModule; 436413"];
6562 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 436414"];
6563 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 436415"];
6564 [label="return new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName); 436416"];
6565 [label="new MissingMetadataTypeSymbol.TopLevel(scope.ContainingModule, ref emittedTypeName) 436417"];
6566 [label="param TopLevel(ModuleSymbol module) 436418"];
6567 [label="param TopLevel(ref MetadataTypeName fullName) 436419"];
6568 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 436420"];
6569 [label="param TopLevel(this) 436421"];
6570 [label="module 436422"];
6571 [label="1 436423"];
6572 [label="errorInfo 436424"];
6573 [label="param TopLevel(ModuleSymbol module) 436425"];
6574 [label="param TopLevel(int typeId) 436426"];
6575 [label="param TopLevel(DiagnosticInfo? errorInfo) 436427"];
6576 [label="module 436428"];
6577 [label="errorInfo 436429"];
6578 [label="typeId 436430"];
6579 [label="param TopLevel(ModuleSymbol module) 436431"];
6580 [label="param TopLevel(DiagnosticInfo? errorInfo) 436432"];
6581 [label="param TopLevel(int typeId) 436433"];
6582 [label="param TopLevel(this) 436434"];
6583 [label="module 436435"];
6584 [label="fullName.NamespaceName 436436"];
6585 [label="mangleName 436437"];
6586 [label="false 436438"];
6587 [label="errorInfo 436439"];
6588 [label="null 436440"];
6589 [label="typeId 436441"];
6590 [label="null 436442"];
6591 [label="param TopLevel(this) 436443"];
6592 [label="param TopLevel(ModuleSymbol module) 436444"];
6593 [label="param TopLevel(string @namespace) 436445"];
6594 [label="param TopLevel(string name) 436446"];
6595 [label="param TopLevel(int arity) 436447"];
6596 [label="param TopLevel(bool mangleName) 436448"];
6597 [label="param TopLevel(bool isNativeInt) 436449"];
6598 [label="param TopLevel(DiagnosticInfo? errorInfo) 436450"];
6599 [label="param TopLevel(NamespaceSymbol? containingNamespace) 436451"];
6600 [label="param TopLevel(int typeId) 436452"];
6601 [label="param TopLevel(TupleExtraData? tupleData) 436453"];
6602 [label="param TopLevel(this) 436454"];
6603 [label="name 436455"];
6604 [label="arity 436456"];
6605 [label="mangleName 436457"];
6606 [label="tupleData 436458"];
6607 [label="param TopLevel(this) 436459"];
6608 [label="param MissingMetadataTypeSymbol(string name) 436460"];
6609 [label="param MissingMetadataTypeSymbol(int arity) 436461"];
6610 [label="param MissingMetadataTypeSymbol(bool mangleName) 436462"];
6611 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 436463"];
6612 [label="param MissingMetadataTypeSymbol(this) 436464"];
6613 [label="tupleData 436465"];
6614 [label="param MissingMetadataTypeSymbol(this) 436466"];
6615 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 436467"];
6616 [label="_lazyTupleData 436468"];
6617 [label="_lazyTupleData 436469"];
6618 [label="name 436470"];
6619 [label="arity 436471"];
6620 [label="mangleName 436472"];
6621 [label="RoslynDebug.Assert(name != null); 436473"];
6622 [label="RoslynDebug.Assert(name != null); 436474"];
6623 [label="this.name 436475"];
6624 [label="this.arity 436476"];
6625 [label="this.mangleName = (mangleName && arity > 0); 436477"];
6626 [label="this.mangleName = (mangleName && arity > 0); 436478"];
6627 [label="this.mangleName = (mangleName && arity > 0); 436479"];
6628 [label="this.mangleName 436480"];
6629 [label="_namespaceName 436481"];
6630 [label="_containingModule 436482"];
6631 [label="_isNativeInt 436483"];
6632 [label="_lazyErrorInfo 436484"];
6633 [label="_lazyContainingNamespace 436485"];
6634 [label="_lazyTypeId 436486"];
6635 [label="RoslynDebug.Assert((object)module != null); 436487"];
6636 [label="RoslynDebug.Assert((object)module != null); 436488"];
6637 [label="RoslynDebug.Assert(@namespace != null); 436489"];
6638 [label="RoslynDebug.Assert(@namespace != null); 436490"];
6639 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436491"];
6640 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436492"];
6641 [label="_namespaceName 436493"];
6642 [label="_containingModule 436494"];
6643 [label="_isNativeInt 436495"];
6644 [label="_lazyErrorInfo 436496"];
6645 [label="_lazyContainingNamespace 436497"];
6646 [label="_lazyTypeId 436498"];
6647 [label="Debug.Assert((object)result != null); 436499"];
6648 [label="Debug.Assert((object)result != null); 436500"];
6649 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 436501"];
6650 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 436502"];
6651 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436503"];
6652 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 436504"];
6653 [label="System.Diagnostics.Debug.Assert((object)result != null); 436505"];
6654 [label="System.Diagnostics.Debug.Assert((object)result != null); 436506"];
6655 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436507"];
6656 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 436508"];
6657 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 436509"];
6658 [label="candidate.Kind 436510"];
6659 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 436511"];
6660 [label="return SymbolKind.ErrorType; 436512"];
6661 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436513"];
6662 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436514"];
6663 [label="return null; 436515"];
6664 [label="param IsValidWellKnownType(this) 436516"];
6665 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436517"];
6666 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436518"];
6667 [label="return false; 436519"];
6668 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436520"];
6669 [label="candidate = null; 436521"];
6670 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436522"];
6671 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436523"];
6672 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 436524"];
6673 [label="Debug.Assert(typesByNS != null); 436525"];
6674 [label="get\n            {\n                return true;\n            } 436526"];
6675 [label="_containingNamespaceSymbol 436527"];
6676 [label="_name 436528"];
6677 [label="_typesByNS 436529"];
6678 [label="Debug.Assert(name != null); 436530"];
6679 [label="Debug.Assert((object)containingNamespace != null); 436531"];
6680 [label="Debug.Assert(typesByNS != null); 436532"];
6681 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 436533"];
6682 [label="genericParameterHandles 436534"];
6683 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 436535"];
6684 [label="param GetGenericInfo(out ushort arity) 436536"];
6685 [label="param GetGenericInfo(out BadImageFormatException mrEx) 436537"];
6686 [label="mrEx = null; 436538"];
6687 [label="PENamedTypeSymbol result; 436539"];
6688 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 436540"];
6689 [label="mangleName 436541"];
6690 [label="param PENamedTypeSymbol(out bool mangleName) 436542"];
6691 [label="_lazyTupleData 436543"];
6692 [label="_container 436544"];
6693 [label="_name 436545"];
6694 [label="_flags 436546"];
6695 [label="_corTypeId 436547"];
6696 [label="Debug.Assert(!handle.IsNil); 436548"];
6697 [label="Debug.Assert((object)container != null); 436549"];
6698 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 436550"];
6699 [label="string metadataName; 436551"];
6700 [label="bool makeBad = false; 436552"];
6701 [label="mangleName = false; 436553"];
6702 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 436554"];
6703 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436555"];
6704 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436556"];
6705 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436557"];
6706 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436558"];
6707 [label="bool added; 436559"];
6708 [label="Debug.Assert(added); 436560"];
6709 [label="EnsureAllMembersLoaded(); 436561"];
6710 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 436562"];
6711 [label="if ((object)scope == null)\n                {\n                    break;\n                } 436563"];
6712 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 436564"];
6713 [label="get\n            {\n                return false;\n            } 436565"];
6714 [label="Debug.Assert(!emittedTypeName.IsNull); 436566"];
6715 [label="scope.Kind 436567"];
6716 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436568"];
6717 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 436569"];
6718 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 436570"];
6719 [label="namespaceOrTypeMembers 436571"];
6720 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 436572"];
6721 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436573"];
6722 [label="param NamespaceOrTypeSymbol(this) 436574"];
6723 [label="param Symbol(this) 436575"];
6724 [label="_underlying 436576"];
6725 [label="Debug.Assert(underlying is object); 436577"];
6726 [label="param ToDisplayParts(bool minimal) 436578"];
6727 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 436579"];
6728 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 436580"];
6729 [label="Debug.Assert(semanticModelOpt == null); 436581"];
6730 [label="Debug.Assert(positionOpt < 0); 436582"];
6731 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 436583"];
6732 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 436584"];
6733 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436585"];
6734 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436586"];
6735 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 436587"];
6736 [label="param ShouldVisitNamespace(this) 436588"];
6737 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 436589"];
6738 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436590"];
6739 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436591"];
6740 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 436592"];
6741 [label="=> _underlying.IsGlobalNamespace 436593"];
6742 [label="get\n            {\n                return false;\n            } 436594"];
6743 [label="get\n            {\n                return true;\n            } 436595"];
6744 [label="=> _underlying.IsGlobalNamespace 436596"];
6745 [label="get\n            {\n                return false;\n            } 436597"];
6746 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 436598"];
6747 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436599"];
6748 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436600"];
6749 [label="EnsureAllMembersLoaded(); 436601"];
6750 [label="scope.ContainingModule 436602"];
6751 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 436603"];
6752 [label="_containingNamespaceSymbol.ContainingPEModule 436604"];
6753 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436605"];
6754 [label="return _containingNamespaceSymbol.ContainingPEModule; 436606"];
6755 [label="param TopLevel(ModuleSymbol module) 436607"];
6756 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 436608"];
6757 [label="module 436609"];
6758 [label="1 436610"];
6759 [label="errorInfo 436611"];
6760 [label="param TopLevel(ModuleSymbol module) 436612"];
6761 [label="param TopLevel(int typeId) 436613"];
6762 [label="param TopLevel(DiagnosticInfo? errorInfo) 436614"];
6763 [label="module 436615"];
6764 [label="errorInfo 436616"];
6765 [label="typeId 436617"];
6766 [label="param TopLevel(ModuleSymbol module) 436618"];
6767 [label="param TopLevel(DiagnosticInfo? errorInfo) 436619"];
6768 [label="param TopLevel(int typeId) 436620"];
6769 [label="param TopLevel(this) 436621"];
6770 [label="module 436622"];
6771 [label="fullName.NamespaceName 436623"];
6772 [label="mangleName 436624"];
6773 [label="false 436625"];
6774 [label="errorInfo 436626"];
6775 [label="null 436627"];
6776 [label="typeId 436628"];
6777 [label="null 436629"];
6778 [label="param TopLevel(ModuleSymbol module) 436630"];
6779 [label="param TopLevel(string @namespace) 436631"];
6780 [label="param TopLevel(string name) 436632"];
6781 [label="param TopLevel(int arity) 436633"];
6782 [label="param TopLevel(bool mangleName) 436634"];
6783 [label="param TopLevel(bool isNativeInt) 436635"];
6784 [label="param TopLevel(DiagnosticInfo? errorInfo) 436636"];
6785 [label="param TopLevel(NamespaceSymbol? containingNamespace) 436637"];
6786 [label="param TopLevel(int typeId) 436638"];
6787 [label="param TopLevel(TupleExtraData? tupleData) 436639"];
6788 [label="param TopLevel(this) 436640"];
6789 [label="name 436641"];
6790 [label="arity 436642"];
6791 [label="mangleName 436643"];
6792 [label="tupleData 436644"];
6793 [label="param MissingMetadataTypeSymbol(string name) 436645"];
6794 [label="param MissingMetadataTypeSymbol(int arity) 436646"];
6795 [label="param MissingMetadataTypeSymbol(bool mangleName) 436647"];
6796 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 436648"];
6797 [label="param MissingMetadataTypeSymbol(this) 436649"];
6798 [label="tupleData 436650"];
6799 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 436651"];
6800 [label="_lazyTupleData 436652"];
6801 [label="name 436653"];
6802 [label="arity 436654"];
6803 [label="mangleName 436655"];
6804 [label="RoslynDebug.Assert(name != null); 436656"];
6805 [label="RoslynDebug.Assert(name != null); 436657"];
6806 [label="this.name 436658"];
6807 [label="this.arity 436659"];
6808 [label="this.mangleName = (mangleName && arity > 0); 436660"];
6809 [label="this.mangleName = (mangleName && arity > 0); 436661"];
6810 [label="this.mangleName = (mangleName && arity > 0); 436662"];
6811 [label="this.mangleName 436663"];
6812 [label="_namespaceName 436664"];
6813 [label="_containingModule 436665"];
6814 [label="_isNativeInt 436666"];
6815 [label="_lazyErrorInfo 436667"];
6816 [label="_lazyContainingNamespace 436668"];
6817 [label="_lazyTypeId 436669"];
6818 [label="RoslynDebug.Assert((object)module != null); 436670"];
6819 [label="RoslynDebug.Assert((object)module != null); 436671"];
6820 [label="RoslynDebug.Assert(@namespace != null); 436672"];
6821 [label="RoslynDebug.Assert(@namespace != null); 436673"];
6822 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436674"];
6823 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436675"];
6824 [label="_namespaceName 436676"];
6825 [label="_containingModule 436677"];
6826 [label="_isNativeInt 436678"];
6827 [label="_lazyErrorInfo 436679"];
6828 [label="_lazyContainingNamespace 436680"];
6829 [label="_lazyTypeId 436681"];
6830 [label="Debug.Assert((object)result != null); 436682"];
6831 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 436683"];
6832 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 436684"];
6833 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436685"];
6834 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 436686"];
6835 [label="System.Diagnostics.Debug.Assert((object)result != null); 436687"];
6836 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436688"];
6837 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 436689"];
6838 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 436690"];
6839 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436691"];
6840 [label="return null; 436692"];
6841 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436693"];
6842 [label="return false; 436694"];
6843 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436695"];
6844 [label="candidate = null; 436696"];
6845 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436697"];
6846 [label="assembly.IsMissing 436698"];
6847 [label="get\n            {\n                return false;\n            } 436699"];
6848 [label="return false; 436700"];
6849 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 436701"];
6850 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 436702"];
6851 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 436703"];
6852 [label="NamedTypeSymbol result = null; 436704"];
6853 [label="NamedTypeSymbol result; 436705"];
6854 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 436706"];
6855 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 436707"];
6856 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436708"];
6857 [label="=> _underlying.IsGlobalNamespace 436709"];
6858 [label="get\n            {\n                return false;\n            } 436710"];
6859 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 436711"];
6860 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436712"];
6861 [label="param NamespaceOrTypeSymbol(this) 436713"];
6862 [label="param Symbol(this) 436714"];
6863 [label="_underlying 436715"];
6864 [label="Debug.Assert(underlying is object); 436716"];
6865 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 436717"];
6866 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 436718"];
6867 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436719"];
6868 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 436720"];
6869 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 436721"];
6870 [label="=> _underlying.IsGlobalNamespace 436722"];
6871 [label="get\n            {\n                return false;\n            } 436723"];
6872 [label="get\n            {\n                return true;\n            } 436724"];
6873 [label="=> _underlying.IsGlobalNamespace 436725"];
6874 [label="get\n            {\n                return false;\n            } 436726"];
6875 [label="=> _underlying.IsGlobalNamespace 436727"];
6876 [label="get\n            {\n                return false;\n            } 436728"];
6877 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 436729"];
6878 [label="Debug.Assert(typesByNS != null); 436730"];
6879 [label="get\n            {\n                return false;\n            } 436731"];
6880 [label="get\n            {\n                return true;\n            } 436732"];
6881 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 436733"];
6882 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436734"];
6883 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436735"];
6884 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436736"];
6885 [label="return _containingNamespaceSymbol.ContainingPEModule; 436737"];
6886 [label="param TopLevel(ModuleSymbol module) 436738"];
6887 [label="module 436739"];
6888 [label="param TopLevel(ModuleSymbol module) 436740"];
6889 [label="module 436741"];
6890 [label="param TopLevel(ModuleSymbol module) 436742"];
6891 [label="module 436743"];
6892 [label="param TopLevel(ModuleSymbol module) 436744"];
6893 [label="RoslynDebug.Assert((object)module != null); 436745"];
6894 [label="_containingModule 436746"];
6895 [label="Debug.Assert((object)result != null); 436747"];
6896 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 436748"];
6897 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 436749"];
6898 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436750"];
6899 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 436751"];
6900 [label="System.Diagnostics.Debug.Assert((object)result != null); 436752"];
6901 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436753"];
6902 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 436754"];
6903 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 436755"];
6904 [label="candidate.Kind 436756"];
6905 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 436757"];
6906 [label="return SymbolKind.ErrorType; 436758"];
6907 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436759"];
6908 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436760"];
6909 [label="return null; 436761"];
6910 [label="param IsValidWellKnownType(this) 436762"];
6911 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436763"];
6912 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436764"];
6913 [label="return false; 436765"];
6914 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436766"];
6915 [label="candidate = null; 436767"];
6916 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436768"];
6917 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436769"];
6918 [label="assembly.IsMissing 436770"];
6919 [label="get\n            {\n                return false;\n            } 436771"];
6920 [label="return false; 436772"];
6921 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 436773"];
6922 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 436774"];
6923 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 436775"];
6924 [label="NamedTypeSymbol result = null; 436776"];
6925 [label="NamedTypeSymbol result; 436777"];
6926 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 436778"];
6927 [label="_containingNamespaceSymbol 436779"];
6928 [label="_name 436780"];
6929 [label="_typesByNS 436781"];
6930 [label="Debug.Assert(name != null); 436782"];
6931 [label="Debug.Assert((object)containingNamespace != null); 436783"];
6932 [label="Debug.Assert(typesByNS != null); 436784"];
6933 [label="genericParameterHandles 436785"];
6934 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 436786"];
6935 [label="param GetGenericInfo(out ushort arity) 436787"];
6936 [label="param GetGenericInfo(out BadImageFormatException mrEx) 436788"];
6937 [label="mrEx = null; 436789"];
6938 [label="PENamedTypeSymbol result; 436790"];
6939 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 436791"];
6940 [label="mangleName 436792"];
6941 [label="param PENamedTypeSymbol(out bool mangleName) 436793"];
6942 [label="_lazyTupleData 436794"];
6943 [label="_container 436795"];
6944 [label="_name 436796"];
6945 [label="_flags 436797"];
6946 [label="_corTypeId 436798"];
6947 [label="Debug.Assert(!handle.IsNil); 436799"];
6948 [label="Debug.Assert((object)container != null); 436800"];
6949 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 436801"];
6950 [label="string metadataName; 436802"];
6951 [label="bool makeBad = false; 436803"];
6952 [label="mangleName = false; 436804"];
6953 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 436805"];
6954 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436806"];
6955 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436807"];
6956 [label="bool added; 436808"];
6957 [label="Debug.Assert(added); 436809"];
6958 [label="EnsureAllMembersLoaded(); 436810"];
6959 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 436811"];
6960 [label="if ((object)scope == null)\n                {\n                    break;\n                } 436812"];
6961 [label="Debug.Assert(!emittedTypeName.IsNull); 436813"];
6962 [label="scope.Kind 436814"];
6963 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436815"];
6964 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 436816"];
6965 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 436817"];
6966 [label="namespaceOrTypeMembers 436818"];
6967 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 436819"];
6968 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 436820"];
6969 [label="param ToDisplayParts(bool minimal) 436821"];
6970 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 436822"];
6971 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 436823"];
6972 [label="Debug.Assert(semanticModelOpt == null); 436824"];
6973 [label="Debug.Assert(positionOpt < 0); 436825"];
6974 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 436826"];
6975 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 436827"];
6976 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 436828"];
6977 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436829"];
6978 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 436830"];
6979 [label="EnsureAllMembersLoaded(); 436831"];
6980 [label="scope.ContainingModule 436832"];
6981 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 436833"];
6982 [label="_containingNamespaceSymbol.ContainingPEModule 436834"];
6983 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 436835"];
6984 [label="return _containingNamespaceSymbol.ContainingPEModule; 436836"];
6985 [label="param TopLevel(ModuleSymbol module) 436837"];
6986 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 436838"];
6987 [label="module 436839"];
6988 [label="1 436840"];
6989 [label="errorInfo 436841"];
6990 [label="param TopLevel(ModuleSymbol module) 436842"];
6991 [label="param TopLevel(int typeId) 436843"];
6992 [label="param TopLevel(DiagnosticInfo? errorInfo) 436844"];
6993 [label="module 436845"];
6994 [label="errorInfo 436846"];
6995 [label="typeId 436847"];
6996 [label="param TopLevel(ModuleSymbol module) 436848"];
6997 [label="param TopLevel(DiagnosticInfo? errorInfo) 436849"];
6998 [label="param TopLevel(int typeId) 436850"];
6999 [label="param TopLevel(this) 436851"];
7000 [label="module 436852"];
7001 [label="fullName.NamespaceName 436853"];
7002 [label="mangleName 436854"];
7003 [label="false 436855"];
7004 [label="errorInfo 436856"];
7005 [label="null 436857"];
7006 [label="typeId 436858"];
7007 [label="null 436859"];
7008 [label="param TopLevel(ModuleSymbol module) 436860"];
7009 [label="param TopLevel(string @namespace) 436861"];
7010 [label="param TopLevel(string name) 436862"];
7011 [label="param TopLevel(int arity) 436863"];
7012 [label="param TopLevel(bool mangleName) 436864"];
7013 [label="param TopLevel(bool isNativeInt) 436865"];
7014 [label="param TopLevel(DiagnosticInfo? errorInfo) 436866"];
7015 [label="param TopLevel(NamespaceSymbol? containingNamespace) 436867"];
7016 [label="param TopLevel(int typeId) 436868"];
7017 [label="param TopLevel(TupleExtraData? tupleData) 436869"];
7018 [label="param TopLevel(this) 436870"];
7019 [label="name 436871"];
7020 [label="arity 436872"];
7021 [label="mangleName 436873"];
7022 [label="tupleData 436874"];
7023 [label="param MissingMetadataTypeSymbol(string name) 436875"];
7024 [label="param MissingMetadataTypeSymbol(int arity) 436876"];
7025 [label="param MissingMetadataTypeSymbol(bool mangleName) 436877"];
7026 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 436878"];
7027 [label="param MissingMetadataTypeSymbol(this) 436879"];
7028 [label="tupleData 436880"];
7029 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 436881"];
7030 [label="_lazyTupleData 436882"];
7031 [label="name 436883"];
7032 [label="arity 436884"];
7033 [label="mangleName 436885"];
7034 [label="RoslynDebug.Assert(name != null); 436886"];
7035 [label="RoslynDebug.Assert(name != null); 436887"];
7036 [label="this.name 436888"];
7037 [label="this.arity 436889"];
7038 [label="this.mangleName = (mangleName && arity > 0); 436890"];
7039 [label="this.mangleName = (mangleName && arity > 0); 436891"];
7040 [label="this.mangleName = (mangleName && arity > 0); 436892"];
7041 [label="this.mangleName 436893"];
7042 [label="_namespaceName 436894"];
7043 [label="_containingModule 436895"];
7044 [label="_isNativeInt 436896"];
7045 [label="_lazyErrorInfo 436897"];
7046 [label="_lazyContainingNamespace 436898"];
7047 [label="_lazyTypeId 436899"];
7048 [label="RoslynDebug.Assert((object)module != null); 436900"];
7049 [label="RoslynDebug.Assert((object)module != null); 436901"];
7050 [label="RoslynDebug.Assert(@namespace != null); 436902"];
7051 [label="RoslynDebug.Assert(@namespace != null); 436903"];
7052 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436904"];
7053 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 436905"];
7054 [label="_namespaceName 436906"];
7055 [label="_containingModule 436907"];
7056 [label="_isNativeInt 436908"];
7057 [label="_lazyErrorInfo 436909"];
7058 [label="_lazyContainingNamespace 436910"];
7059 [label="_lazyTypeId 436911"];
7060 [label="Debug.Assert((object)result != null); 436912"];
7061 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 436913"];
7062 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 436914"];
7063 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 436915"];
7064 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 436916"];
7065 [label="System.Diagnostics.Debug.Assert((object)result != null); 436917"];
7066 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 436918"];
7067 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 436919"];
7068 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 436920"];
7069 [label="candidate.Kind 436921"];
7070 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 436922"];
7071 [label="return SymbolKind.ErrorType; 436923"];
7072 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436924"];
7073 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 436925"];
7074 [label="return null; 436926"];
7075 [label="param IsValidWellKnownType(this) 436927"];
7076 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436928"];
7077 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 436929"];
7078 [label="return false; 436930"];
7079 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 436931"];
7080 [label="candidate = null; 436932"];
7081 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436933"];
7082 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 436934"];
7083 [label="if (lazyTypes.TryGetValue(name, out t))\n            {\n                return StaticCast<Symbol>.From(t);\n            } 436935"];
7084 [label="return ImmutableArray<Symbol>.Empty; 436936"];
7085 [label="param TopLevel(ModuleSymbol module) 436937"];
7086 [label="module 436938"];
7087 [label="param TopLevel(ModuleSymbol module) 436939"];
7088 [label="module 436940"];
7089 [label="param TopLevel(ModuleSymbol module) 436941"];
7090 [label="module 436942"];
7091 [label="param TopLevel(ModuleSymbol module) 436943"];
7092 [label="RoslynDebug.Assert((object)module != null); 436944"];
7093 [label="_containingModule 436945"];
7094 [label="assembly.IsMissing 436946"];
7095 [label="get\n            {\n                return false;\n            } 436947"];
7096 [label="return false; 436948"];
7097 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 436949"];
7098 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 436950"];
7099 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 436951"];
7100 [label="NamedTypeSymbol result = null; 436952"];
7101 [label="NamedTypeSymbol result; 436953"];
7102 [label="IEnumerable<IGrouping<string, TypeDefinitionHandle>> groups; 436954"];
7103 [label="Debug.Assert(typesByNS != null); 436955"];
7104 [label="get\n            {\n                return true;\n            } 436956"];
7105 [label="_containingNamespaceSymbol 436957"];
7106 [label="_name 436958"];
7107 [label="_typesByNS 436959"];
7108 [label="Debug.Assert(name != null); 436960"];
7109 [label="Debug.Assert((object)containingNamespace != null); 436961"];
7110 [label="Debug.Assert(typesByNS != null); 436962"];
7111 [label="Dictionary<string, TypeDefinitionHandle> noPiaLocalTypes = null; 436963"];
7112 [label="genericParameterHandles 436964"];
7113 [label="param GetGenericInfo(out GenericParameterHandleCollection genericParameterHandles) 436965"];
7114 [label="param GetGenericInfo(out ushort arity) 436966"];
7115 [label="param GetGenericInfo(out BadImageFormatException mrEx) 436967"];
7116 [label="mrEx = null; 436968"];
7117 [label="PENamedTypeSymbol result; 436969"];
7118 [label="param PENamedTypeSymbolNonGeneric(out bool mangleName) 436970"];
7119 [label="mangleName 436971"];
7120 [label="param PENamedTypeSymbol(out bool mangleName) 436972"];
7121 [label="_lazyTupleData 436973"];
7122 [label="_container 436974"];
7123 [label="_name 436975"];
7124 [label="_flags 436976"];
7125 [label="_corTypeId 436977"];
7126 [label="Debug.Assert(!handle.IsNil); 436978"];
7127 [label="Debug.Assert((object)container != null); 436979"];
7128 [label="Debug.Assert(arity == 0 || this is PENamedTypeSymbolGeneric); 436980"];
7129 [label="string metadataName; 436981"];
7130 [label="bool makeBad = false; 436982"];
7131 [label="mangleName = false; 436983"];
7132 [label="if (makeBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n            } 436984"];
7133 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436985"];
7134 [label="if (mrEx != null)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, result);\n            } 436986"];
7135 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436987"];
7136 [label="if (noPiaLocalTypes != null)\n                {\n                    Interlocked.CompareExchange(ref _lazyNoPiaLocalTypes, noPiaLocalTypes, null);\n                } 436988"];
7137 [label="bool added; 436989"];
7138 [label="Debug.Assert(added); 436990"];
7139 [label="EnsureAllMembersLoaded(); 436991"];
7140 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 436992"];
7141 [label="if ((object)scope == null)\n                {\n                    break;\n                } 436993"];
7142 [label="System.Diagnostics.Debug.Assert(typesByNS != null); 436994"];
7143 [label="get\n            {\n                return false;\n            } 436995"];
7144 [label="return ImmutableArray<Symbol>.Empty; 436996"];
7145 [label="param TopLevel(ModuleSymbol module) 436997"];
7146 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 436998"];
7147 [label="module 436999"];
7148 [label="1 437000"];
7149 [label="errorInfo 437001"];
7150 [label="param TopLevel(ModuleSymbol module) 437002"];
7151 [label="param TopLevel(int typeId) 437003"];
7152 [label="param TopLevel(DiagnosticInfo? errorInfo) 437004"];
7153 [label="module 437005"];
7154 [label="errorInfo 437006"];
7155 [label="typeId 437007"];
7156 [label="param TopLevel(ModuleSymbol module) 437008"];
7157 [label="param TopLevel(DiagnosticInfo? errorInfo) 437009"];
7158 [label="param TopLevel(int typeId) 437010"];
7159 [label="param TopLevel(this) 437011"];
7160 [label="module 437012"];
7161 [label="fullName.NamespaceName 437013"];
7162 [label="mangleName 437014"];
7163 [label="false 437015"];
7164 [label="errorInfo 437016"];
7165 [label="null 437017"];
7166 [label="typeId 437018"];
7167 [label="null 437019"];
7168 [label="param TopLevel(ModuleSymbol module) 437020"];
7169 [label="param TopLevel(string @namespace) 437021"];
7170 [label="param TopLevel(string name) 437022"];
7171 [label="param TopLevel(int arity) 437023"];
7172 [label="param TopLevel(bool mangleName) 437024"];
7173 [label="param TopLevel(bool isNativeInt) 437025"];
7174 [label="param TopLevel(DiagnosticInfo? errorInfo) 437026"];
7175 [label="param TopLevel(NamespaceSymbol? containingNamespace) 437027"];
7176 [label="param TopLevel(int typeId) 437028"];
7177 [label="param TopLevel(TupleExtraData? tupleData) 437029"];
7178 [label="param TopLevel(this) 437030"];
7179 [label="name 437031"];
7180 [label="arity 437032"];
7181 [label="mangleName 437033"];
7182 [label="tupleData 437034"];
7183 [label="param MissingMetadataTypeSymbol(string name) 437035"];
7184 [label="param MissingMetadataTypeSymbol(int arity) 437036"];
7185 [label="param MissingMetadataTypeSymbol(bool mangleName) 437037"];
7186 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 437038"];
7187 [label="param MissingMetadataTypeSymbol(this) 437039"];
7188 [label="tupleData 437040"];
7189 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 437041"];
7190 [label="_lazyTupleData 437042"];
7191 [label="name 437043"];
7192 [label="arity 437044"];
7193 [label="mangleName 437045"];
7194 [label="RoslynDebug.Assert(name != null); 437046"];
7195 [label="RoslynDebug.Assert(name != null); 437047"];
7196 [label="this.name 437048"];
7197 [label="this.arity 437049"];
7198 [label="this.mangleName = (mangleName && arity > 0); 437050"];
7199 [label="this.mangleName = (mangleName && arity > 0); 437051"];
7200 [label="this.mangleName = (mangleName && arity > 0); 437052"];
7201 [label="this.mangleName 437053"];
7202 [label="_namespaceName 437054"];
7203 [label="_containingModule 437055"];
7204 [label="_isNativeInt 437056"];
7205 [label="_lazyErrorInfo 437057"];
7206 [label="_lazyContainingNamespace 437058"];
7207 [label="_lazyTypeId 437059"];
7208 [label="RoslynDebug.Assert((object)module != null); 437060"];
7209 [label="RoslynDebug.Assert((object)module != null); 437061"];
7210 [label="RoslynDebug.Assert(@namespace != null); 437062"];
7211 [label="RoslynDebug.Assert(@namespace != null); 437063"];
7212 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 437064"];
7213 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 437065"];
7214 [label="_namespaceName 437066"];
7215 [label="_containingModule 437067"];
7216 [label="_isNativeInt 437068"];
7217 [label="_lazyErrorInfo 437069"];
7218 [label="_lazyContainingNamespace 437070"];
7219 [label="_lazyTypeId 437071"];
7220 [label="Debug.Assert((object)result != null); 437072"];
7221 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 437073"];
7222 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 437074"];
7223 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 437075"];
7224 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 437076"];
7225 [label="System.Diagnostics.Debug.Assert((object)result != null); 437077"];
7226 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 437078"];
7227 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 437079"];
7228 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 437080"];
7229 [label="candidate.Kind 437081"];
7230 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 437082"];
7231 [label="return SymbolKind.ErrorType; 437083"];
7232 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 437084"];
7233 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 437085"];
7234 [label="return null; 437086"];
7235 [label="param IsValidWellKnownType(this) 437087"];
7236 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 437088"];
7237 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 437089"];
7238 [label="return false; 437090"];
7239 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 437091"];
7240 [label="candidate = null; 437092"];
7241 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 437093"];
7242 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 437094"];
7243 [label="assemblies.Free(); 437095"];
7244 [label="return result; 437096"];
7245 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 437097"];
7246 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 437098"];
7247 [label="'Expressions' 437099"];
7248 [label="'Linq' 437100"];
7249 [label="'' 437101"];
7250 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 437102"];
7251 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 437103"];
7252 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 437104"];
7253 [label="{ 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 437105"];
7254 [label="s_expressionsNamespaceName = { 'Expressions', 'Linq', MetadataHelpers.SystemString, '' } 437106"];
7255 [label="(type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 437107"];
7256 [label="s_containsTypeParameterPredicate =\n            (type, parameter, unused) => type.TypeKind == TypeKind.TypeParameter && (parameter is null || TypeSymbol.Equals(type, parameter, TypeCompareKind.ConsiderEverything2)) 437108"];
7257 [label="(type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 437109"];
7258 [label="s_isTypeParameterWithSpecificContainerPredicate =\n             (type, parameterContainer, unused) => type.TypeKind == TypeKind.TypeParameter && (object)type.ContainingSymbol == (object)parameterContainer 437110"];
7259 [label="(type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 437111"];
7260 [label="s_containsTypeParametersPredicate =\n            (type, parameters, unused) => type.TypeKind == TypeKind.TypeParameter && parameters.Contains((TypeParameterSymbol)type) 437112"];
7261 [label="(type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 437113"];
7262 [label="s_containsDynamicPredicate = (type, unused1, unused2) => type.TypeKind == TypeKind.Dynamic 437114"];
7263 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 437115"];
7264 [label="type.IsErrorType() 437116"];
7265 [label="param IsErrorType(this TypeSymbol type) 437117"];
7266 [label="RoslynDebug.Assert((object)type != null); 437118"];
7267 [label="RoslynDebug.Assert((object)type != null); 437119"];
7268 [label="type.Kind 437120"];
7269 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 437121"];
7270 [label="return SymbolKind.NamedType; 437122"];
7271 [label="return type.Kind == SymbolKind.ErrorType; 437123"];
7272 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 437124"];
7273 [label="return ((object)type == null || type.IsErrorType()) ? null : type; 437125"];
7274 [label="((object)type == null || type.IsErrorType()) 437126"];
7275 [label="if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                } 437127"];
7276 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 437128"];
7277 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 437129"];
7278 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 437130"];
7279 [label="if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                } 437131"];
7280 [label="AdditionalCodegenWarnings 437132"];
7281 [label="get\n            {\n                return _additionalCodegenWarnings;\n            } 437133"];
7282 [label="return _additionalCodegenWarnings; 437134"];
7283 [label="AdditionalCodegenWarnings.AddRange(warnings); 437135"];
7284 [label="AdditionalCodegenWarnings.AddRange(warnings); 437136"];
7285 [label="AdditionalCodegenWarnings.AddRange(warnings); 437137"];
7286 [label="warnings.Free(); 437138"];
7287 [label="return _lazyWellKnownTypes[index]!; 437139"];
7288 [label="Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null'); 437140"];
7289 [label="Debug.Assert((object)compilationRelaxationsAttribute != null, 'GetWellKnownType unexpectedly returned null'); 437141"];
7290 [label="if (!(compilationRelaxationsAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if CompilationRelaxationsAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton);\n                } 437142"];
7291 [label="0 437143"];
7292 [label="ExternalScope = 0 437144"];
7293 [label="1 437145"];
7294 [label="TopLevelScope = 1 437146"];
7295 [label="2 437147"];
7296 [label="ValueKindInsignificantBits = 2 437148"];
7297 [label="ValueKindSignificantBitsMask = unchecked((BindValueKind)~((1 << ValueKindInsignificantBits) - 1)) 437149"];
7298 [label="property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 437150"];
7299 [label="s_isIndexedPropertyWithNonOptionalArguments = property =>\n            {\n                if (property.IsIndexer || !property.IsIndexedProperty)\n                {\n                    return false;\n                }\n\n                Debug.Assert(property.ParameterCount > 0);\n                var parameter = property.Parameters[0];\n                return !parameter.IsOptional && !parameter.IsParams;\n            } 437151"];
7300 [label="globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted 437152"];
7301 [label="memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType 437153"];
7302 [label="SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 437154"];
7303 [label="miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes 437155"];
7304 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 437156"];
7305 [label="new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 437157"];
7306 [label="s_propertyGroupFormat =\n            new SymbolDisplayFormat(\n                globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Omitted,\n                memberOptions:\n                    SymbolDisplayMemberOptions.IncludeContainingType,\n                miscellaneousOptions:\n                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers |\n                    SymbolDisplayMiscellaneousOptions.UseSpecialTypes) 437158"];
7307 [label="10 437159"];
7308 [label="MaxParameterListsForErrorRecovery = 10 437160"];
7309 [label="'<>h__TransparentIdentifier' 437161"];
7310 [label="transparentIdentifierPrefix = '<>h__TransparentIdentifier' 437162"];
7311 [label="s => (MethodSymbol)s 437163"];
7312 [label="s_toMethodSymbolFunc = s => (MethodSymbol)s 437164"];
7313 [label="s => (PropertySymbol)s 437165"];
7314 [label="s_toPropertySymbolFunc = s => (PropertySymbol)s 437166"];
7315 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 437167"];
7316 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 437168"];
7317 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 437169"];
7318 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton); 437170"];
7319 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32, diagnostics, NoLocation.Singleton) 437171"];
7320 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 437172"];
7321 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 437173"];
7322 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 437174"];
7323 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 437175"];
7324 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 437176"];
7325 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 437177"];
7326 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 437178"];
7327 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 437179"];
7328 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 437180"];
7329 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 437181"];
7330 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437182"];
7331 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437183"];
7332 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437184"];
7333 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437185"];
7334 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437186"];
7335 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional); 437187"];
7336 [label="GetWellKnownTypeMember(compilation, attributeMember, diagnostics, location, syntax, isOptional) 437188"];
7337 [label="param GetWellKnownTypeMember(CSharpCompilation compilation) 437189"];
7338 [label="param GetWellKnownTypeMember(WellKnownMember member) 437190"];
7339 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 437191"];
7340 [label="param GetWellKnownTypeMember(Location location = null) 437192"];
7341 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 437193"];
7342 [label="param GetWellKnownTypeMember(bool isOptional = false) 437194"];
7343 [label="Debug.Assert((syntax != null) ^ (location != null)); 437195"];
7344 [label="Debug.Assert((syntax != null) ^ (location != null)); 437196"];
7345 [label="Debug.Assert((syntax != null) ^ (location != null)); 437197"];
7346 [label="Debug.Assert((syntax != null) ^ (location != null)); 437198"];
7347 [label="DiagnosticInfo useSiteDiagnostic; 437199"];
7348 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 437200"];
7349 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 437201"];
7350 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 437202"];
7351 [label="Symbol memberSymbol = GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional); 437203"];
7352 [label="GetWellKnownTypeMember(compilation, member, out useSiteDiagnostic, isOptional) 437204"];
7353 [label="param GetWellKnownTypeMember(CSharpCompilation compilation) 437205"];
7354 [label="param GetWellKnownTypeMember(WellKnownMember member) 437206"];
7355 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 437207"];
7356 [label="param GetWellKnownTypeMember(bool isOptional = false) 437208"];
7357 [label="Symbol memberSymbol = compilation.GetWellKnownTypeMember(member); 437209"];
7358 [label="compilation.GetWellKnownTypeMember(member) 437210"];
7359 [label="param GetWellKnownTypeMember(WellKnownMember member) 437211"];
7360 [label="param GetWellKnownTypeMember(this) 437212"];
7361 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 437213"];
7362 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 437214"];
7363 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 437215"];
7364 [label="if (IsMemberMissing(member)) return null; 437216"];
7365 [label="if (IsMemberMissing(member)) return null; 437217"];
7366 [label="if (_lazyWellKnownTypeMembers == null || ReferenceEquals(_lazyWellKnownTypeMembers[(int)member], ErrorTypeSymbol.UnknownResultType))\n            {\n                if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                }\n\n                MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);\n                NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId);\n                Symbol? result = null;\n\n                if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                }\n\n                Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType);\n            } 437218"];
7367 [label="if (_lazyWellKnownTypeMembers == null || ReferenceEquals(_lazyWellKnownTypeMembers[(int)member], ErrorTypeSymbol.UnknownResultType))\n            {\n                if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                }\n\n                MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member);\n                NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId);\n                Symbol? result = null;\n\n                if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                }\n\n                Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType);\n            } 437219"];
7368 [label="if (_lazyWellKnownTypeMembers == null)\n                {\n                    var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count];\n\n                    for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    }\n\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null);\n                } 437220"];
7369 [label="var wellKnownTypeMembers = new Symbol[(int)WellKnownMember.Count]; 437221"];
7370 [label="for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    } 437222"];
7371 [label="for (int i = 0; i < wellKnownTypeMembers.Length; i++)\n                    {\n                        wellKnownTypeMembers[i] = ErrorTypeSymbol.UnknownResultType;\n                    } 437223"];
7372 [label="wellKnownTypeMembers[i] 437224"];
7373 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 437225"];
7374 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 437226"];
7375 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 437227"];
7376 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers, wellKnownTypeMembers, null); 437228"];
7377 [label="MemberDescriptor descriptor = WellKnownMembers.GetDescriptor(member); 437229"];
7378 [label="NamedTypeSymbol type = descriptor.DeclaringTypeId <= (int)SpecialType.Count\n                                            ? this.GetSpecialType((SpecialType)descriptor.DeclaringTypeId)\n                                            : this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId); 437230"];
7379 [label="descriptor.DeclaringTypeId <= (int)SpecialType.Count 437231"];
7380 [label="this.GetWellKnownType((WellKnownType)descriptor.DeclaringTypeId) 437232"];
7381 [label="Debug.Assert(type.IsValid()); 437233"];
7382 [label="this.Options 437234"];
7383 [label="return _options; 437235"];
7384 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 437236"];
7385 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 437237"];
7386 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 437238"];
7387 [label="param Includes(this BinderFlags self) 437239"];
7388 [label="param Includes(BinderFlags other) 437240"];
7389 [label="return (self & other) == other; 437241"];
7390 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 437242"];
7391 [label="return _lazyWellKnownTypes[index]!; 437243"];
7392 [label="Symbol? result = null; 437244"];
7393 [label="if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                } 437245"];
7394 [label="type.IsErrorType() 437246"];
7395 [label="param IsErrorType(this TypeSymbol type) 437247"];
7396 [label="RoslynDebug.Assert((object)type != null); 437248"];
7397 [label="RoslynDebug.Assert((object)type != null); 437249"];
7398 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 437250"];
7399 [label="if (!type.IsErrorType())\n                {\n                    result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly);\n                } 437251"];
7400 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 437252"];
7401 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 437253"];
7402 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 437254"];
7403 [label="this.Assembly 437255"];
7404 [label="GetBoundReferenceManager() 437256"];
7405 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 437257"];
7406 [label="return _referenceManager; 437258"];
7407 [label="GetBoundReferenceManager(); 437259"];
7408 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 437260"];
7409 [label="result = GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly); 437261"];
7410 [label="GetRuntimeMember(type, descriptor, WellKnownMemberSignatureComparer, accessWithinOpt: this.Assembly) 437262"];
7411 [label="param GetRuntimeMember(NamedTypeSymbol declaringType) 437263"];
7412 [label="param GetRuntimeMember(in MemberDescriptor descriptor) 437264"];
7413 [label="param GetRuntimeMember(SignatureComparer<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer) 437265"];
7414 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 437266"];
7415 [label="var members = declaringType.GetMembers(descriptor.Name); 437267"];
7416 [label="declaringType.GetMembers(descriptor.Name) 437268"];
7417 [label="param GetMembers(string name) 437269"];
7418 [label="param GetMembers(this) 437270"];
7419 [label="EnsureAllMembersAreLoaded() 437271"];
7420 [label="param EnsureAllMembersAreLoaded(this) 437272"];
7421 [label="if (_lazyMembersByName == null)\n            {\n                LoadMembers();\n            } 437273"];
7422 [label="if (_lazyMembersByName == null)\n            {\n                LoadMembers();\n            } 437274"];
7423 [label="LoadMembers() 437275"];
7424 [label="param LoadMembers(this) 437276"];
7425 [label="ArrayBuilder<Symbol> members = null; 437277"];
7426 [label="if (_lazyMembersInDeclarationOrder.IsDefault)\n            {\n                EnsureNestedTypesAreLoaded();\n\n                members = ArrayBuilder<Symbol>.GetInstance();\n\n                Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder());\n                Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder());\n                Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder());\n                Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder());\n\n                if (this.TypeKind == TypeKind.Enum)\n                {\n                    EnsureEnumUnderlyingTypeIsLoaded(this.GetUncommonProperties());\n\n                    var moduleSymbol = this.ContainingPEModule;\n                    var module = moduleSymbol.Module;\n\n                    try\n                    {\n                        foreach (var fieldDef in module.GetFieldsOfTypeOrThrow(_handle))\n                        {\n                            FieldAttributes fieldFlags;\n\n                            try\n                            {\n                                fieldFlags = module.GetFieldDefFlagsOrThrow(fieldDef);\n                                if ((fieldFlags & FieldAttributes.Static) == 0)\n                                {\n                                    continue;\n                                }\n                            }\n                            catch (BadImageFormatException)\n                            {\n                                fieldFlags = 0;\n                            }\n\n                            if (ModuleExtensions.ShouldImportField(fieldFlags, moduleSymbol.ImportOptions))\n                            {\n                                var field = new PEFieldSymbol(moduleSymbol, this, fieldDef);\n                                members.Add(field);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var syntheticCtor = new SynthesizedInstanceConstructor(this);\n                    members.Add(syntheticCtor);\n                }\n                else\n                {\n                    ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance();\n                    ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance();\n\n                    MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers);\n\n                    // A method may be referenced as an accessor by one or more properties. And,\n                    // any of those properties may be 'bogus' if one of the property accessors\n                    // does not match the property signature. If the method is referenced by at\n                    // least one non-bogus property, then the method is created as an accessor,\n                    // and (for purposes of error reporting if the method is referenced directly) the\n                    // associated property is set (arbitrarily) to the first non-bogus property found\n                    // in metadata. If the method is not referenced by any non-bogus properties,\n                    // then the method is created as a normal method rather than an accessor.\n\n                    // Create a dictionary of method symbols indexed by metadata handle\n                    // (to allow efficient lookup when matching property accessors).\n                    PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers);\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    }\n\n                    this.CreateProperties(methodHandleToSymbol, nonFieldMembers);\n                    this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers);\n\n                    foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    }\n\n                    members.AddRange(nonFieldMembers);\n\n                    nonFieldMembers.Free();\n                    fieldMembers.Free();\n\n                    methodHandleToSymbol.Free();\n                }\n\n                // Now add types to the end.\n                int membersCount = members.Count;\n\n                foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                }\n\n                // Sort the types based on row id.\n                members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance);\n\n#if DEBUG\n                Symbol previous = null;\n\n                foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                }\n#endif\n\n                if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                }\n\n                var membersInDeclarationOrder = members.ToImmutable();\n\n                if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                }\n            } 437278"];
7427 [label="EnsureNestedTypesAreLoaded() 437279"];
7428 [label="param EnsureNestedTypesAreLoaded(this) 437280"];
7429 [label="if (_lazyNestedTypes == null)\n            {\n                var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                types.AddRange(this.CreateNestedTypes());\n                var typesDict = GroupByName(types);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null);\n                if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n                types.Free();\n            } 437281"];
7430 [label="if (_lazyNestedTypes == null)\n            {\n                var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance();\n                types.AddRange(this.CreateNestedTypes());\n                var typesDict = GroupByName(types);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null);\n                if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                }\n                types.Free();\n            } 437282"];
7431 [label="var types = ArrayBuilder<PENamedTypeSymbol>.GetInstance(); 437283"];
7432 [label="this.CreateNestedTypes() 437284"];
7433 [label="param CreateNestedTypes(this) 437285"];
7434 [label="this.ContainingPEModule 437286"];
7435 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 437287"];
7436 [label="s.Kind 437288"];
7437 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437289"];
7438 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437290"];
7439 [label="var moduleSymbol = this.ContainingPEModule; 437291"];
7440 [label="moduleSymbol.Module 437292"];
7441 [label="get\n            {\n                return _module;\n            } 437293"];
7442 [label="var module = moduleSymbol.Module; 437294"];
7443 [label="ImmutableArray<TypeDefinitionHandle> nestedTypeDefs; 437295"];
7444 [label="nestedTypeDefs 437296"];
7445 [label="nestedTypeDefs = module.GetNestedTypeDefsOrThrow(_handle); 437297"];
7446 [label="nestedTypeDefs = module.GetNestedTypeDefsOrThrow(_handle); 437298"];
7447 [label="foreach (var typeRid in nestedTypeDefs)\n            {\n                if (module.ShouldImportNestedType(typeRid))\n                {\n                    yield return PENamedTypeSymbol.Create(moduleSymbol, this, typeRid);\n                }\n            } 437299"];
7448 [label="param CreateNestedTypes(this) 437300"];
7449 [label="types.AddRange(this.CreateNestedTypes()); 437301"];
7450 [label="types.AddRange(this.CreateNestedTypes()); 437302"];
7451 [label="var typesDict = GroupByName(types); 437303"];
7452 [label="GroupByName(types) 437304"];
7453 [label="param GroupByName(ArrayBuilder<PENamedTypeSymbol> symbols) 437305"];
7454 [label="if (symbols.Count == 0)\n            {\n                return s_emptyNestedTypes;\n            } 437306"];
7455 [label="if (symbols.Count == 0)\n            {\n                return s_emptyNestedTypes;\n            } 437307"];
7456 [label="return s_emptyNestedTypes; 437308"];
7457 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 437309"];
7458 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 437310"];
7459 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 437311"];
7460 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyNestedTypes, typesDict, null); 437312"];
7461 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 437313"];
7462 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 437314"];
7463 [label="this.ContainingPEModule 437315"];
7464 [label="s.Kind 437316"];
7465 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437317"];
7466 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437318"];
7467 [label="var moduleSymbol = this.ContainingPEModule; 437319"];
7468 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 437320"];
7469 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 437321"];
7470 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 437322"];
7471 [label="param OnNewTypeDeclarationsLoaded(this) 437323"];
7472 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 437324"];
7473 [label="types.Free(); 437325"];
7474 [label="EnsureNestedTypesAreLoaded(); 437326"];
7475 [label="members = ArrayBuilder<Symbol>.GetInstance(); 437327"];
7476 [label="Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder()); 437328"];
7477 [label="Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder()); 437329"];
7478 [label="Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder()); 437330"];
7479 [label="Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder()); 437331"];
7480 [label="this.TypeKind 437332"];
7481 [label="TypeKind result = _lazyKind; 437333"];
7482 [label="return result; 437334"];
7483 [label="if (this.TypeKind == TypeKind.Enum)\n                {\n                    EnsureEnumUnderlyingTypeIsLoaded(this.GetUncommonProperties());\n\n                    var moduleSymbol = this.ContainingPEModule;\n                    var module = moduleSymbol.Module;\n\n                    try\n                    {\n                        foreach (var fieldDef in module.GetFieldsOfTypeOrThrow(_handle))\n                        {\n                            FieldAttributes fieldFlags;\n\n                            try\n                            {\n                                fieldFlags = module.GetFieldDefFlagsOrThrow(fieldDef);\n                                if ((fieldFlags & FieldAttributes.Static) == 0)\n                                {\n                                    continue;\n                                }\n                            }\n                            catch (BadImageFormatException)\n                            {\n                                fieldFlags = 0;\n                            }\n\n                            if (ModuleExtensions.ShouldImportField(fieldFlags, moduleSymbol.ImportOptions))\n                            {\n                                var field = new PEFieldSymbol(moduleSymbol, this, fieldDef);\n                                members.Add(field);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var syntheticCtor = new SynthesizedInstanceConstructor(this);\n                    members.Add(syntheticCtor);\n                }\n                else\n                {\n                    ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance();\n                    ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance();\n\n                    MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers);\n\n                    // A method may be referenced as an accessor by one or more properties. And,\n                    // any of those properties may be 'bogus' if one of the property accessors\n                    // does not match the property signature. If the method is referenced by at\n                    // least one non-bogus property, then the method is created as an accessor,\n                    // and (for purposes of error reporting if the method is referenced directly) the\n                    // associated property is set (arbitrarily) to the first non-bogus property found\n                    // in metadata. If the method is not referenced by any non-bogus properties,\n                    // then the method is created as a normal method rather than an accessor.\n\n                    // Create a dictionary of method symbols indexed by metadata handle\n                    // (to allow efficient lookup when matching property accessors).\n                    PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers);\n\n                    if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    }\n\n                    this.CreateProperties(methodHandleToSymbol, nonFieldMembers);\n                    this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers);\n\n                    foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    }\n\n                    members.AddRange(nonFieldMembers);\n\n                    nonFieldMembers.Free();\n                    fieldMembers.Free();\n\n                    methodHandleToSymbol.Free();\n                } 437335"];
7484 [label="ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance(); 437336"];
7485 [label="ArrayBuilder<Symbol> nonFieldMembers = ArrayBuilder<Symbol>.GetInstance(); 437337"];
7486 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 437338"];
7487 [label="this.CreateFields(fieldMembers) 437339"];
7488 [label="param CreateFields(ArrayBuilder<PEFieldSymbol> fieldMembers) 437340"];
7489 [label="param CreateFields(this) 437341"];
7490 [label="var privateFieldNameToSymbols = new MultiDictionary<string, PEFieldSymbol>(); 437342"];
7491 [label="this.ContainingPEModule 437343"];
7492 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 437344"];
7493 [label="s.Kind 437345"];
7494 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437346"];
7495 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437347"];
7496 [label="var moduleSymbol = this.ContainingPEModule; 437348"];
7497 [label="moduleSymbol.Module 437349"];
7498 [label="get\n            {\n                return _module;\n            } 437350"];
7499 [label="var module = moduleSymbol.Module; 437351"];
7500 [label="var isOrdinaryStruct = false; 437352"];
7501 [label="var isOrdinaryEmbeddableStruct = false; 437353"];
7502 [label="this.TypeKind 437354"];
7503 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 437355"];
7504 [label="if (this.TypeKind == TypeKind.Struct)\n            {\n                if (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None)\n                {\n                    isOrdinaryStruct = true;\n                    isOrdinaryEmbeddableStruct = this.ContainingAssembly.IsLinked;\n                }\n                else\n                {\n                    isOrdinaryStruct = (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Nullable_T);\n                }\n            } 437356"];
7505 [label="foreach (var fieldRid in module.GetFieldsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        if (!(isOrdinaryEmbeddableStruct ||\n                            (isOrdinaryStruct && (module.GetFieldDefFlagsOrThrow(fieldRid) & FieldAttributes.Static) == 0) ||\n                            module.ShouldImportField(fieldRid, moduleSymbol.ImportOptions)))\n                        {\n                            continue;\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var symbol = new PEFieldSymbol(moduleSymbol, this, fieldRid);\n                    fieldMembers.Add(symbol);\n\n                    // Only private fields are potentially backing fields for field-like events.\n                    if (symbol.DeclaredAccessibility == Accessibility.Private)\n                    {\n                        var name = symbol.Name;\n                        if (name.Length > 0)\n                        {\n                            privateFieldNameToSymbols.Add(name, symbol);\n                        }\n                    }\n                } 437357"];
7506 [label="foreach (var fieldRid in module.GetFieldsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        if (!(isOrdinaryEmbeddableStruct ||\n                            (isOrdinaryStruct && (module.GetFieldDefFlagsOrThrow(fieldRid) & FieldAttributes.Static) == 0) ||\n                            module.ShouldImportField(fieldRid, moduleSymbol.ImportOptions)))\n                        {\n                            continue;\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n\n                    var symbol = new PEFieldSymbol(moduleSymbol, this, fieldRid);\n                    fieldMembers.Add(symbol);\n\n                    // Only private fields are potentially backing fields for field-like events.\n                    if (symbol.DeclaredAccessibility == Accessibility.Private)\n                    {\n                        var name = symbol.Name;\n                        if (name.Length > 0)\n                        {\n                            privateFieldNameToSymbols.Add(name, symbol);\n                        }\n                    }\n                } 437358"];
7507 [label="return privateFieldNameToSymbols; 437359"];
7508 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 437360"];
7509 [label="PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers); 437361"];
7510 [label="this.CreateMethods(nonFieldMembers) 437362"];
7511 [label="param CreateMethods(ArrayBuilder<Symbol> members) 437363"];
7512 [label="param CreateMethods(this) 437364"];
7513 [label="this.ContainingPEModule 437365"];
7514 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 437366"];
7515 [label="Symbol s = _container; 437367"];
7516 [label="s.Kind 437368"];
7517 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437369"];
7518 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437370"];
7519 [label="var moduleSymbol = this.ContainingPEModule; 437371"];
7520 [label="moduleSymbol.Module 437372"];
7521 [label="get\n            {\n                return _module;\n            } 437373"];
7522 [label="var module = moduleSymbol.Module; 437374"];
7523 [label="var map = PooledDictionary<MethodDefinitionHandle, PEMethodSymbol>.GetInstance(); 437375"];
7524 [label="this.TypeKind 437376"];
7525 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 437377"];
7526 [label="TypeKind result = _lazyKind; 437378"];
7527 [label="var isOrdinaryEmbeddableStruct = (this.TypeKind == TypeKind.Struct) && (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None) && this.ContainingAssembly.IsLinked; 437379"];
7528 [label="foreach (var methodHandle in module.GetMethodsOfTypeOrThrow(_handle))\n                {\n                    if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    }\n                } 437380"];
7529 [label="foreach (var methodHandle in module.GetMethodsOfTypeOrThrow(_handle))\n                {\n                    if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    }\n                } 437381"];
7530 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 437382"];
7531 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 437383"];
7532 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 437384"];
7533 [label="if (isOrdinaryEmbeddableStruct || module.ShouldImportMethod(methodHandle, moduleSymbol.ImportOptions))\n                    {\n                        var method = new PEMethodSymbol(moduleSymbol, this, methodHandle);\n                        members.Add(method);\n                        map.Add(methodHandle, method);\n                    } 437385"];
7534 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 437386"];
7535 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 437387"];
7536 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 437388"];
7537 [label="var method = new PEMethodSymbol(moduleSymbol, this, methodHandle); 437389"];
7538 [label="new PEMethodSymbol(moduleSymbol, this, methodHandle) 437390"];
7539 [label="param PEMethodSymbol(PEModuleSymbol moduleSymbol) 437391"];
7540 [label="param PEMethodSymbol(PENamedTypeSymbol containingType) 437392"];
7541 [label="param PEMethodSymbol(MethodDefinitionHandle methodDef) 437393"];
7542 [label="param PEMethodSymbol(this) 437394"];
7543 [label="null 437395"];
7544 [label="None = null 437396"];
7545 [label="param PEMethodSymbol(this) 437397"];
7546 [label="param MethodSymbol(this) 437398"];
7547 [label="param MethodSymbol(this) 437399"];
7548 [label="_lazyAdapter 437400"];
7549 [label="_lazyParameterSignature 437401"];
7550 [label="_name 437402"];
7551 [label="_containingType 437403"];
7552 [label="_associatedPropertyOrEventOpt 437404"];
7553 [label="_flags 437405"];
7554 [label="_implFlags 437406"];
7555 [label="_lazySignature 437407"];
7556 [label="_uncommonFields 437408"];
7557 [label="Debug.Assert((object)moduleSymbol != null); 437409"];
7558 [label="Debug.Assert((object)moduleSymbol != null); 437410"];
7559 [label="Debug.Assert((object)containingType != null); 437411"];
7560 [label="Debug.Assert((object)containingType != null); 437412"];
7561 [label="Debug.Assert(!methodDef.IsNil); 437413"];
7562 [label="_handle 437414"];
7563 [label="_containingType 437415"];
7564 [label="MethodAttributes localflags = 0; 437416"];
7565 [label="int rva; 437417"];
7566 [label="MethodImplAttributes implFlags; 437418"];
7567 [label="moduleSymbol.Module 437419"];
7568 [label="get\n            {\n                return _module;\n            } 437420"];
7569 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437421"];
7570 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437422"];
7571 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437423"];
7572 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437424"];
7573 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437425"];
7574 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437426"];
7575 [label="moduleSymbol.Module.GetMethodDefPropsOrThrow(methodDef, out _name, out implFlags, out localflags, out rva); 437427"];
7576 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 437428"];
7577 [label="_implFlags 437429"];
7578 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 437430"];
7579 [label="_flags 437431"];
7580 [label="members.Add(method); 437432"];
7581 [label="members.Add(method); 437433"];
7582 [label="map.Add(methodHandle, method); 437434"];
7583 [label="map.Add(methodHandle, method); 437435"];
7584 [label="map.Add(methodHandle, method); 437436"];
7585 [label="_containingType 437437"];
7586 [label="_flags 437438"];
7587 [label="_implFlags 437439"];
7588 [label="Debug.Assert((object)moduleSymbol != null); 437440"];
7589 [label="Debug.Assert((object)containingType != null); 437441"];
7590 [label="Debug.Assert(!methodDef.IsNil); 437442"];
7591 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 437443"];
7592 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 437444"];
7593 [label="map.Add(methodHandle, method); 437445"];
7594 [label="map.Add(methodHandle, method); 437446"];
7595 [label="return map; 437447"];
7596 [label="PooledDictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol = this.CreateMethods(nonFieldMembers); 437448"];
7597 [label="this.TypeKind 437449"];
7598 [label="TypeKind result = _lazyKind; 437450"];
7599 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    } 437451"];
7600 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 437452"];
7601 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 437453"];
7602 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers) 437454"];
7603 [label="param CreateProperties(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 437455"];
7604 [label="param CreateProperties(ArrayBuilder<Symbol> members) 437456"];
7605 [label="param CreateProperties(this) 437457"];
7606 [label="this.ContainingPEModule 437458"];
7607 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 437459"];
7608 [label="Symbol s = _container; 437460"];
7609 [label="s.Kind 437461"];
7610 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437462"];
7611 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437463"];
7612 [label="var moduleSymbol = this.ContainingPEModule; 437464"];
7613 [label="moduleSymbol.Module 437465"];
7614 [label="get\n            {\n                return _module;\n            } 437466"];
7615 [label="var module = moduleSymbol.Module; 437467"];
7616 [label="foreach (var propertyDef in module.GetPropertiesOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetPropertyMethodsOrThrow(propertyDef);\n\n                        PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter);\n                        PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter);\n\n                        if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 437468"];
7617 [label="foreach (var propertyDef in module.GetPropertiesOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetPropertyMethodsOrThrow(propertyDef);\n\n                        PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter);\n                        PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter);\n\n                        if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 437469"];
7618 [label="var methods = module.GetPropertyMethodsOrThrow(propertyDef); 437470"];
7619 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 437471"];
7620 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 437472"];
7621 [label="PEMethodSymbol getMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Getter); 437473"];
7622 [label="GetAccessorMethod(module, methodHandleToSymbol, methods.Getter) 437474"];
7623 [label="param GetAccessorMethod(PEModule module) 437475"];
7624 [label="param GetAccessorMethod(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 437476"];
7625 [label="param GetAccessorMethod(MethodDefinitionHandle methodDef) 437477"];
7626 [label="param GetAccessorMethod(this) 437478"];
7627 [label="if (methodDef.IsNil)\n            {\n                return null;\n            } 437479"];
7628 [label="PEMethodSymbol method; 437480"];
7629 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 437481"];
7630 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 437482"];
7631 [label="bool found = methodHandleToSymbol.TryGetValue(methodDef, out method); 437483"];
7632 [label="Debug.Assert(found || !module.ShouldImportMethod(methodDef, this.ContainingPEModule.ImportOptions)); 437484"];
7633 [label="return method; 437485"];
7634 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 437486"];
7635 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 437487"];
7636 [label="PEMethodSymbol setMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Setter); 437488"];
7637 [label="GetAccessorMethod(module, methodHandleToSymbol, methods.Setter) 437489"];
7638 [label="param GetAccessorMethod(PEModule module) 437490"];
7639 [label="param GetAccessorMethod(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 437491"];
7640 [label="param GetAccessorMethod(MethodDefinitionHandle methodDef) 437492"];
7641 [label="param GetAccessorMethod(this) 437493"];
7642 [label="if (methodDef.IsNil)\n            {\n                return null;\n            } 437494"];
7643 [label="return null; 437495"];
7644 [label="if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        } 437496"];
7645 [label="if (((object)getMethod != null) || ((object)setMethod != null))\n                        {\n                            members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod));\n                        } 437497"];
7646 [label="1 437498"];
7647 [label="UnsetAccessibility = -1 437499"];
7648 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 437500"];
7649 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 437501"];
7650 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 437502"];
7651 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 437503"];
7652 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 437504"];
7653 [label="PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod) 437505"];
7654 [label="param Create(PEModuleSymbol moduleSymbol) 437506"];
7655 [label="param Create(PENamedTypeSymbol containingType) 437507"];
7656 [label="param Create(PropertyDefinitionHandle handle) 437508"];
7657 [label="param Create(PEMethodSymbol getMethod) 437509"];
7658 [label="param Create(PEMethodSymbol setMethod) 437510"];
7659 [label="Debug.Assert((object)moduleSymbol != null); 437511"];
7660 [label="Debug.Assert((object)moduleSymbol != null); 437512"];
7661 [label="Debug.Assert((object)containingType != null); 437513"];
7662 [label="Debug.Assert((object)containingType != null); 437514"];
7663 [label="Debug.Assert(!handle.IsNil); 437515"];
7664 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 437516"];
7665 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 437517"];
7666 [label="var metadataDecoder = new MetadataDecoder(moduleSymbol, containingType); 437518"];
7667 [label="new MetadataDecoder(moduleSymbol, containingType) 437519"];
7668 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 437520"];
7669 [label="param MetadataDecoder(PENamedTypeSymbol context) 437521"];
7670 [label="param MetadataDecoder(this) 437522"];
7671 [label="Debug.Assert((object)moduleSymbol != null); 437523"];
7672 [label="Debug.Assert((object)moduleSymbol != null); 437524"];
7673 [label="SignatureHeader callingConvention; 437525"];
7674 [label="callingConvention 437526"];
7675 [label="BadImageFormatException propEx; 437527"];
7676 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 437528"];
7677 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 437529"];
7678 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 437530"];
7679 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 437531"];
7680 [label="var propertyParams = metadataDecoder.GetSignatureForProperty(handle, out callingConvention, out propEx); 437532"];
7681 [label="param GetSpecialType(PEModuleSymbol moduleSymbol) 437533"];
7682 [label="param GetSpecialType(SpecialType specialType) 437534"];
7683 [label="param GetSpecialType(this) 437535"];
7684 [label="moduleSymbol.ContainingAssembly 437536"];
7685 [label="get\n            {\n                return _assemblySymbol;\n            } 437537"];
7686 [label="return moduleSymbol.ContainingAssembly.GetSpecialType(specialType); 437538"];
7687 [label="return moduleSymbol.ContainingAssembly.GetSpecialType(specialType); 437539"];
7688 [label="moduleSymbol.ContainingAssembly.GetSpecialType(specialType) 437540"];
7689 [label="param GetSpecialType(SpecialType type) 437541"];
7690 [label="param GetSpecialType(this) 437542"];
7691 [label="CorLibrary 437543"];
7692 [label="get\n            {\n                return _corLibrary;\n            } 437544"];
7693 [label="return CorLibrary.GetDeclaredSpecialType(type); 437545"];
7694 [label="return CorLibrary.GetDeclaredSpecialType(type); 437546"];
7695 [label="CorLibrary.GetDeclaredSpecialType(type) 437547"];
7696 [label="param GetDeclaredSpecialType(SpecialType type) 437548"];
7697 [label="param GetDeclaredSpecialType(this) 437549"];
7698 [label="this.Modules 437550"];
7699 [label="get\n            {\n                return _modules;\n            } 437551"];
7700 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 437552"];
7701 [label="module.GetReferencedAssemblies() 437553"];
7702 [label="param GetReferencedAssemblies(this) 437554"];
7703 [label="AssertReferencesInitialized() 437555"];
7704 [label="param AssertReferencesInitialized(this) 437556"];
7705 [label="Debug.Assert(_moduleReferences != null); 437557"];
7706 [label="Debug.Assert(_moduleReferences != null); 437558"];
7707 [label="AssertReferencesInitialized(); 437559"];
7708 [label="return _moduleReferences.Identities; 437560"];
7709 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 437561"];
7710 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 437562"];
7711 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437563"];
7712 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437564"];
7713 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437565"];
7714 [label="return _lazySpecialTypes[(int)type]; 437566"];
7715 [label="Debug.Assert(propertyParams.Length > 0); 437567"];
7716 [label="Debug.Assert(propertyParams.Length > 0); 437568"];
7717 [label="var returnInfo = propertyParams[0]; 437569"];
7718 [label="var returnInfo = propertyParams[0]; 437570"];
7719 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 437571"];
7720 [label="returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty 437572"];
7721 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 437573"];
7722 [label="PEPropertySymbol result = returnInfo.CustomModifiers.IsDefaultOrEmpty && returnInfo.RefCustomModifiers.IsDefaultOrEmpty\n                ? new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder)\n                : new PEPropertySymbolWithCustomModifiers(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder); 437574"];
7723 [label="new PEPropertySymbol(moduleSymbol, containingType, handle, getMethod, setMethod, propertyParams, metadataDecoder) 437575"];
7724 [label="param PEPropertySymbol(PEModuleSymbol moduleSymbol) 437576"];
7725 [label="param PEPropertySymbol(PENamedTypeSymbol containingType) 437577"];
7726 [label="param PEPropertySymbol(PropertyDefinitionHandle handle) 437578"];
7727 [label="param PEPropertySymbol(PEMethodSymbol getMethod) 437579"];
7728 [label="param PEPropertySymbol(PEMethodSymbol setMethod) 437580"];
7729 [label="param PEPropertySymbol(ParamInfo<TypeSymbol>[] propertyParams) 437581"];
7730 [label="param PEPropertySymbol(MetadataDecoder metadataDecoder) 437582"];
7731 [label="param PEPropertySymbol(this) 437583"];
7732 [label="param PEPropertySymbol(this) 437584"];
7733 [label="param PropertySymbol(this) 437585"];
7734 [label="param PropertySymbol(this) 437586"];
7735 [label="_lazyAdapter 437587"];
7736 [label="_lazyParameterSignature 437588"];
7737 [label="_name 437589"];
7738 [label="_containingType 437590"];
7739 [label="_refKind 437591"];
7740 [label="_getMethod 437592"];
7741 [label="_setMethod 437593"];
7742 [label="_lazyDocComment 437594"];
7743 [label="_lazyUseSiteDiagnostic = CSDiagnosticInfo.EmptyErrorInfo 437595"];
7744 [label="_lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized 437596"];
7745 [label="_declaredAccessibility = UnsetAccessibility 437597"];
7746 [label="_flags 437598"];
7747 [label="_containingType 437599"];
7748 [label="moduleSymbol.Module 437600"];
7749 [label="get\n            {\n                return _module;\n            } 437601"];
7750 [label="var module = moduleSymbol.Module; 437602"];
7751 [label="PropertyAttributes mdFlags = 0; 437603"];
7752 [label="BadImageFormatException mrEx = null; 437604"];
7753 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 437605"];
7754 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 437606"];
7755 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 437607"];
7756 [label="module.GetPropertyDefPropsOrThrow(handle, out _name, out mdFlags); 437608"];
7757 [label="_getMethod 437609"];
7758 [label="_setMethod 437610"];
7759 [label="_handle 437611"];
7760 [label="SignatureHeader unusedCallingConvention; 437612"];
7761 [label="unusedCallingConvention 437613"];
7762 [label="BadImageFormatException getEx = null; 437614"];
7763 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 437615"];
7764 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 437616"];
7765 [label="(object)getMethod == null 437617"];
7766 [label="getMethod.Handle 437618"];
7767 [label="=> _handle 437619"];
7768 [label="_handle 437620"];
7769 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 437621"];
7770 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 437622"];
7771 [label="var getMethodParams = (object)getMethod == null ? null : metadataDecoder.GetSignatureForMethod(getMethod.Handle, out unusedCallingConvention, out getEx); 437623"];
7772 [label="param GetSpecialType(this) 437624"];
7773 [label="this.Modules 437625"];
7774 [label="get\n            {\n                return _modules;\n            } 437626"];
7775 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 437627"];
7776 [label="module.GetReferencedAssemblies() 437628"];
7777 [label="param GetReferencedAssemblies(this) 437629"];
7778 [label="AssertReferencesInitialized() 437630"];
7779 [label="param AssertReferencesInitialized(this) 437631"];
7780 [label="Debug.Assert(_moduleReferences != null); 437632"];
7781 [label="Debug.Assert(_moduleReferences != null); 437633"];
7782 [label="AssertReferencesInitialized(); 437634"];
7783 [label="return _moduleReferences.Identities; 437635"];
7784 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 437636"];
7785 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 437637"];
7786 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437638"];
7787 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437639"];
7788 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 437640"];
7789 [label="BadImageFormatException setEx = null; 437641"];
7790 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 437642"];
7791 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 437643"];
7792 [label="(object)setMethod == null 437644"];
7793 [label="bool isBad; 437645"];
7794 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437646"];
7795 [label="setMethodParams is null 437647"];
7796 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437648"];
7797 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437649"];
7798 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437650"];
7799 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437651"];
7800 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437652"];
7801 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 437653"];
7802 [label="GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad) 437654"];
7803 [label="param GetParameters(PEModuleSymbol moduleSymbol) 437655"];
7804 [label="param GetParameters(PEPropertySymbol property) 437656"];
7805 [label="param GetParameters(PEMethodSymbol accessor) 437657"];
7806 [label="param GetParameters(ParamInfo<TypeSymbol>[] propertyParams) 437658"];
7807 [label="param GetParameters(ParamInfo<TypeSymbol>[] accessorParams) 437659"];
7808 [label="param GetParameters(out bool anyParameterIsBad) 437660"];
7809 [label="anyParameterIsBad = false; 437661"];
7810 [label="if (propertyParams.Length < 2)\n            {\n                return ImmutableArray<ParameterSymbol>.Empty;\n            } 437662"];
7811 [label="if (propertyParams.Length < 2)\n            {\n                return ImmutableArray<ParameterSymbol>.Empty;\n            } 437663"];
7812 [label="return ImmutableArray<ParameterSymbol>.Empty; 437664"];
7813 [label="_parameters 437665"];
7814 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437666"];
7815 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437667"];
7816 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437668"];
7817 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437669"];
7818 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437670"];
7819 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437671"];
7820 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 437672"];
7821 [label="var returnInfo = propertyParams[0]; 437673"];
7822 [label="var returnInfo = propertyParams[0]; 437674"];
7823 [label="var typeCustomModifiers = CSharpCustomModifier.Convert(returnInfo.CustomModifiers); 437675"];
7824 [label="CSharpCustomModifier.Convert(returnInfo.CustomModifiers) 437676"];
7825 [label="param Convert(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 437677"];
7826 [label="if (customModifiers.IsDefault)\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 437678"];
7827 [label="return ImmutableArray<CustomModifier>.Empty; 437679"];
7828 [label="if (returnInfo.IsByRef)\n            {\n                if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                {\n                    _refKind = RefKind.RefReadOnly;\n                }\n                else\n                {\n                    _refKind = RefKind.Ref;\n                }\n            }\n            else\n            {\n                _refKind = RefKind.None;\n            } 437680"];
7829 [label="_refKind 437681"];
7830 [label="TypeSymbol originalPropertyType = returnInfo.Type; 437682"];
7831 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 437683"];
7832 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 437684"];
7833 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 437685"];
7834 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 437686"];
7835 [label="originalPropertyType = DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind); 437687"];
7836 [label="DynamicTypeDecoder.TransformType(originalPropertyType, typeCustomModifiers.Length, handle, moduleSymbol, _refKind) 437688"];
7837 [label="param TransformType(TypeSymbol metadataType) 437689"];
7838 [label="param TransformType(int targetSymbolCustomModifierCount) 437690"];
7839 [label="param TransformType(EntityHandle targetSymbolToken) 437691"];
7840 [label="param TransformType(PEModuleSymbol containingModule) 437692"];
7841 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 437693"];
7842 [label="Debug.Assert((object)metadataType != null); 437694"];
7843 [label="Debug.Assert((object)metadataType != null); 437695"];
7844 [label="ImmutableArray<bool> dynamicTransformFlags; 437696"];
7845 [label="dynamicTransformFlags 437697"];
7846 [label="containingModule.Module 437698"];
7847 [label="get\n            {\n                return _module;\n            } 437699"];
7848 [label="return _module; 437700"];
7849 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 437701"];
7850 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 437702"];
7851 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 437703"];
7852 [label="if (containingModule.Module.HasDynamicAttribute(targetSymbolToken, out dynamicTransformFlags))\n            {\n                return TransformTypeInternal(metadataType, containingModule.ContainingAssembly,\n                    targetSymbolCustomModifierCount, targetSymbolRefKind, dynamicTransformFlags,\n                    haveCustomModifierFlags: true,\n                    checkLength: true);\n            } 437704"];
7853 [label="return metadataType; 437705"];
7854 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 437706"];
7855 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 437707"];
7856 [label="originalPropertyType = NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol); 437708"];
7857 [label="NativeIntegerTypeDecoder.TransformType(originalPropertyType, handle, moduleSymbol) 437709"];
7858 [label="param TransformType(TypeSymbol type) 437710"];
7859 [label="param TransformType(EntityHandle handle) 437711"];
7860 [label="param TransformType(PEModuleSymbol containingModule) 437712"];
7861 [label="containingModule.Module 437713"];
7862 [label="get\n            {\n                return _module;\n            } 437714"];
7863 [label="return _module; 437715"];
7864 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 437716"];
7865 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 437717"];
7866 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 437718"];
7867 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 437719"];
7868 [label="containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) 437720"];
7869 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 437721"];
7870 [label="originalPropertyType = originalPropertyType.AsDynamicIfNoPia(_containingType); 437722"];
7871 [label="originalPropertyType = originalPropertyType.AsDynamicIfNoPia(_containingType); 437723"];
7872 [label="originalPropertyType.AsDynamicIfNoPia(_containingType) 437724"];
7873 [label="param AsDynamicIfNoPia(this TypeSymbol type) 437725"];
7874 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 437726"];
7875 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 437727"];
7876 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 437728"];
7877 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 437729"];
7878 [label="type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) 437730"];
7879 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 437731"];
7880 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 437732"];
7881 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 437733"];
7882 [label="type.SpecialType 437734"];
7883 [label="get\n            {\n                return _corTypeId;\n            } 437735"];
7884 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 437736"];
7885 [label="result = null; 437737"];
7886 [label="return false; 437738"];
7887 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 437739"];
7888 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 437740"];
7889 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 437741"];
7890 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 437742"];
7891 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 437743"];
7892 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 437744"];
7893 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 437745"];
7894 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 437746"];
7895 [label="DebuggerDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier) 437747"];
7896 [label="typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces 437748"];
7897 [label="genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters 437749"];
7898 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier 437750"];
7899 [label="SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 437751"];
7900 [label="miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier 437752"];
7901 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 437753"];
7902 [label="new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 437754"];
7903 [label="TestDisplayFormat = new SymbolDisplayFormat(\n            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,\n            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,\n            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier | SymbolDisplayMiscellaneousOptions.IncludeNotNullableReferenceTypeModifier) 437755"];
7904 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 437756"];
7905 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 437757"];
7906 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 437758"];
7907 [label="TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers) 437759"];
7908 [label="param Create(TypeSymbol typeSymbol) 437760"];
7909 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 437761"];
7910 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 437762"];
7911 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 437763"];
7912 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 437764"];
7913 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 437765"];
7914 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 437766"];
7915 [label="typeSymbol.IsNullableType() 437767"];
7916 [label="param IsNullableType(this TypeSymbol type) 437768"];
7917 [label="type.OriginalDefinition 437769"];
7918 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 437770"];
7919 [label="OriginalTypeSymbolDefinition 437771"];
7920 [label="get\n            {\n                return this.OriginalDefinition;\n            } 437772"];
7921 [label="this.OriginalDefinition 437773"];
7922 [label="get\n            {\n                return this;\n            } 437774"];
7923 [label="return this; 437775"];
7924 [label="return this.OriginalDefinition; 437776"];
7925 [label="return OriginalTypeSymbolDefinition; 437777"];
7926 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 437778"];
7927 [label="type.OriginalDefinition.SpecialType 437779"];
7928 [label="get\n            {\n                return _corTypeId;\n            } 437780"];
7929 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 437781"];
7930 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 437782"];
7931 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 437783"];
7932 [label="CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()) 437784"];
7933 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 437785"];
7934 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 437786"];
7935 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 437787"];
7936 [label="customModifiers: ImmutableArray<CustomModifier>.Empty 437788"];
7937 [label="new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 437789"];
7938 [label="param NonLazyType(ImmutableArray<CustomModifier> customModifiers) 437790"];
7939 [label="param NonLazyType(this) 437791"];
7940 [label="param Extensions(this) 437792"];
7941 [label="Debug.Assert(!customModifiers.IsDefault); 437793"];
7942 [label="_customModifiers 437794"];
7943 [label="Default = new NonLazyType(customModifiers: ImmutableArray<CustomModifier>.Empty) 437795"];
7944 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 437796"];
7945 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 437797"];
7946 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 437798"];
7947 [label="Extensions.Create(customModifiers) 437799"];
7948 [label="param Create(ImmutableArray<CustomModifier> customModifiers) 437800"];
7949 [label="if (customModifiers.IsEmpty)\n                {\n                    return Default;\n                } 437801"];
7950 [label="return Default; 437802"];
7951 [label="return new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)); 437803"];
7952 [label="new TypeWithAnnotations(typeSymbol, nullableAnnotation, Extensions.Create(customModifiers)) 437804"];
7953 [label="param TypeWithAnnotations(TypeSymbol defaultType) 437805"];
7954 [label="param TypeWithAnnotations(NullableAnnotation nullableAnnotation) 437806"];
7955 [label="param TypeWithAnnotations(Extensions extensions) 437807"];
7956 [label="param TypeWithAnnotations(this) 437808"];
7957 [label="var a1 = defaultType is null; 437809"];
7958 [label="!a1 437810"];
7959 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 437811"];
7960 [label="defaultType.IsNullableType() 437812"];
7961 [label="param IsNullableType(this TypeSymbol type) 437813"];
7962 [label="type.OriginalDefinition 437814"];
7963 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 437815"];
7964 [label="OriginalTypeSymbolDefinition 437816"];
7965 [label="get\n            {\n                return this.OriginalDefinition;\n            } 437817"];
7966 [label="this.OriginalDefinition 437818"];
7967 [label="get\n            {\n                return this;\n            } 437819"];
7968 [label="return this; 437820"];
7969 [label="return this.OriginalDefinition; 437821"];
7970 [label="return OriginalTypeSymbolDefinition; 437822"];
7971 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 437823"];
7972 [label="type.OriginalDefinition.SpecialType 437824"];
7973 [label="get\n            {\n                return _corTypeId;\n            } 437825"];
7974 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 437826"];
7975 [label="Debug.Assert(a1 || a2 != true || a3); 437827"];
7976 [label="Debug.Assert(a1 || a2 != true || a3); 437828"];
7977 [label="Debug.Assert(extensions != null); 437829"];
7978 [label="Debug.Assert(extensions != null); 437830"];
7979 [label="DefaultType 437831"];
7980 [label="NullableAnnotation 437832"];
7981 [label="_extensions 437833"];
7982 [label="return CreateNonLazyType(typeSymbol, nullableAnnotation, customModifiers.NullToEmpty()); 437834"];
7983 [label="var propertyTypeWithAnnotations = TypeWithAnnotations.Create(originalPropertyType, customModifiers: typeCustomModifiers); 437835"];
7984 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 437836"];
7985 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 437837"];
7986 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 437838"];
7987 [label="propertyTypeWithAnnotations = NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType); 437839"];
7988 [label="NullableTypeDecoder.TransformType(propertyTypeWithAnnotations, handle, moduleSymbol, accessSymbol: _containingType, nullableContext: _containingType) 437840"];
7989 [label="param TransformType(TypeWithAnnotations metadataType) 437841"];
7990 [label="param TransformType(EntityHandle targetSymbolToken) 437842"];
7991 [label="param TransformType(PEModuleSymbol containingModule) 437843"];
7992 [label="param TransformType(Symbol accessSymbol) 437844"];
7993 [label="param TransformType(Symbol nullableContext) 437845"];
7994 [label="metadataType.HasType 437846"];
7995 [label="=> !(DefaultType is null) 437847"];
7996 [label="DefaultType is null 437848"];
7997 [label="!(DefaultType is null) 437849"];
7998 [label="Debug.Assert(metadataType.HasType); 437850"];
7999 [label="accessSymbol.IsDefinition 437851"];
8000 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 437852"];
8001 [label="OriginalDefinition 437853"];
8002 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 437854"];
8003 [label="OriginalSymbolDefinition 437855"];
8004 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 437856"];
8005 [label="this.OriginalTypeSymbolDefinition 437857"];
8006 [label="get\n            {\n                return this.OriginalDefinition;\n            } 437858"];
8007 [label="this.OriginalDefinition 437859"];
8008 [label="get\n            {\n                return this;\n            } 437860"];
8009 [label="return this; 437861"];
8010 [label="return this.OriginalDefinition; 437862"];
8011 [label="return this.OriginalTypeSymbolDefinition; 437863"];
8012 [label="return OriginalSymbolDefinition; 437864"];
8013 [label="return (object)this == (object)OriginalDefinition; 437865"];
8014 [label="Debug.Assert(accessSymbol.IsDefinition); 437866"];
8015 [label="accessSymbol.ContainingModule 437867"];
8016 [label="get\n            {\n                return ContainingPEModule;\n            } 437868"];
8017 [label="ContainingPEModule 437869"];
8018 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 437870"];
8019 [label="Symbol s = _container; 437871"];
8020 [label="s.Kind 437872"];
8021 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437873"];
8022 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437874"];
8023 [label="return ContainingPEModule; 437875"];
8024 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 437876"];
8025 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 437877"];
8026 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 437878"];
8027 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 437879"];
8028 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 437880"];
8029 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 437881"];
8030 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 437882"];
8031 [label="Debug.Assert(symbol is object); 437883"];
8032 [label="symbol.Kind 437884"];
8033 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 437885"];
8034 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 437886"];
8035 [label="isInternal = false; 437887"];
8036 [label="symbol.DeclaredAccessibility 437888"];
8037 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 437889"];
8038 [label="Accessibility access = Accessibility.Private; 437890"];
8039 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 437891"];
8040 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 437892"];
8041 [label="symbol.ContainingType 437893"];
8042 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 437894"];
8043 [label="return _container as NamedTypeSymbol; 437895"];
8044 [label="symbol = symbol.ContainingType; 437896"];
8045 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 437897"];
8046 [label="return true; 437898"];
8047 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 437899"];
8048 [label="byte defaultTransformFlag; 437900"];
8049 [label="ImmutableArray<byte> nullableTransformFlags; 437901"];
8050 [label="nullableTransformFlags 437902"];
8051 [label="containingModule.Module 437903"];
8052 [label="get\n            {\n                return _module;\n            } 437904"];
8053 [label="return _module; 437905"];
8054 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 437906"];
8055 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 437907"];
8056 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 437908"];
8057 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 437909"];
8058 [label="if (!containingModule.Module.HasNullableAttribute(targetSymbolToken, out defaultTransformFlag, out nullableTransformFlags))\n            {\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value == null)\n                {\n                    return metadataType;\n                }\n                defaultTransformFlag = value.GetValueOrDefault();\n            } 437910"];
8059 [label="nullableContext.GetNullableContextValue() 437911"];
8060 [label="param GetNullableContextValue(this) 437912"];
8061 [label="byte? value; 437913"];
8062 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 437914"];
8063 [label="if (!_lazyNullableContextValue.TryGetByte(out value))\n            {\n                value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue();\n                _lazyNullableContextValue = value.ToNullableContextFlags();\n            } 437915"];
8064 [label="_lazyNullableContextValue.TryGetByte(out value) 437916"];
8065 [label="param TryGetByte(this NullableContextKind kind) 437917"];
8066 [label="param TryGetByte(out byte? value) 437918"];
8067 [label="switch (kind)\n            {\n                case NullableContextKind.Unknown:\n                    value = null;\n                    return false;\n                case NullableContextKind.None:\n                    value = null;\n                    return true;\n                case NullableContextKind.Oblivious:\n                    value = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    return true;\n                case NullableContextKind.NotAnnotated:\n                    value = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    return true;\n                case NullableContextKind.Annotated:\n                    value = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 437919"];
8068 [label="value = null; 437920"];
8069 [label="return false; 437921"];
8070 [label="ContainingPEModule 437922"];
8071 [label="s.Kind 437923"];
8072 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 437924"];
8073 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 437925"];
8074 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 437926"];
8075 [label="ContainingPEModule.Module 437927"];
8076 [label="get\n            {\n                return _module;\n            } 437928"];
8077 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 437929"];
8078 [label="value = ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _container.GetNullableContextValue(); 437930"];
8079 [label="ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 437931"];
8080 [label="_container.GetNullableContextValue() 437932"];
8081 [label="param GetNullableContextValue(this) 437933"];
8082 [label="GetLocalNullableContextValue() 437934"];
8083 [label="param GetLocalNullableContextValue(this) 437935"];
8084 [label="return null; 437936"];
8085 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 437937"];
8086 [label="ContainingSymbol 437938"];
8087 [label="get { return _containingNamespaceSymbol; } 437939"];
8088 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 437940"];
8089 [label=".GetNullableContextValue() 437941"];
8090 [label="param GetNullableContextValue(this) 437942"];
8091 [label="GetLocalNullableContextValue() 437943"];
8092 [label="param GetLocalNullableContextValue(this) 437944"];
8093 [label="return null; 437945"];
8094 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 437946"];
8095 [label="ContainingSymbol 437947"];
8096 [label="get\n            {\n                return _moduleSymbol;\n            } 437948"];
8097 [label="return _moduleSymbol; 437949"];
8098 [label="param GetLocalNullableContextValue(this) 437950"];
8099 [label="get\n            {\n                return _assemblySymbol;\n            } 437951"];
8100 [label="return _assemblySymbol; 437952"];
8101 [label="param GetLocalNullableContextValue(this) 437953"];
8102 [label="get\n            {\n                return null;\n            } 437954"];
8103 [label="return null; 437955"];
8104 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 437956"];
8105 [label="return GetLocalNullableContextValue() ?? ContainingSymbol?.GetNullableContextValue(); 437957"];
8106 [label="_lazyNullableContextValue = value.ToNullableContextFlags(); 437958"];
8107 [label="value.ToNullableContextFlags() 437959"];
8108 [label="param ToNullableContextFlags(this byte? value) 437960"];
8109 [label="switch (value)\n            {\n                case null:\n                    return NullableContextKind.None;\n                case NullableAnnotationExtensions.ObliviousAttributeValue:\n                    return NullableContextKind.Oblivious;\n                case NullableAnnotationExtensions.NotAnnotatedAttributeValue:\n                    return NullableContextKind.NotAnnotated;\n                case NullableAnnotationExtensions.AnnotatedAttributeValue:\n                    return NullableContextKind.Annotated;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(value);\n            } 437961"];
8110 [label="return NullableContextKind.None; 437962"];
8111 [label="_lazyNullableContextValue 437963"];
8112 [label="return value; 437964"];
8113 [label="byte? value = nullableContext.GetNullableContextValue(); 437965"];
8114 [label="if (value == null)\n                {\n                    return metadataType;\n                } 437966"];
8115 [label="if (value == null)\n                {\n                    return metadataType;\n                } 437967"];
8116 [label="return metadataType; 437968"];
8117 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 437969"];
8118 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 437970"];
8119 [label="propertyTypeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol); 437971"];
8120 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(propertyTypeWithAnnotations, handle, moduleSymbol) 437972"];
8121 [label="param DecodeTupleTypesIfApplicable(TypeWithAnnotations metadataType) 437973"];
8122 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 437974"];
8123 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 437975"];
8124 [label="ImmutableArray<string?> elementNames; 437976"];
8125 [label="elementNames 437977"];
8126 [label="containingModule\n                .Module 437978"];
8127 [label="get\n            {\n                return _module;\n            } 437979"];
8128 [label="return _module; 437980"];
8129 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 437981"];
8130 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 437982"];
8131 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 437983"];
8132 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 437984"];
8133 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 437985"];
8134 [label="metadataType.Type 437986"];
8135 [label="=> _extensions?.GetResolvedType(DefaultType) 437987"];
8136 [label="DefaultType 437988"];
8137 [label=".GetResolvedType(DefaultType) 437989"];
8138 [label="param GetResolvedType(TypeSymbol defaultType) 437990"];
8139 [label="=> defaultType 437991"];
8140 [label="defaultType 437992"];
8141 [label="_extensions?.GetResolvedType(DefaultType) 437993"];
8142 [label="TypeSymbol type = metadataType.Type; 437994"];
8143 [label="TypeSymbol decoded = DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute); 437995"];
8144 [label="TypeSymbol decoded = DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute); 437996"];
8145 [label="DecodeTupleTypesInternal(type, elementNames, hasTupleElementNamesAttribute) 437997"];
8146 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 437998"];
8147 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 437999"];
8148 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 438000"];
8149 [label="RoslynDebug.AssertNotNull(metadataType); 438001"];
8150 [label="RoslynDebug.AssertNotNull(metadataType); 438002"];
8151 [label="var decoder = new TupleTypeDecoder(elementNames); 438003"];
8152 [label="var decoder = new TupleTypeDecoder(elementNames); 438004"];
8153 [label="new TupleTypeDecoder(elementNames) 438005"];
8154 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 438006"];
8155 [label="param TupleTypeDecoder(this) 438007"];
8156 [label="_elementNames 438008"];
8157 [label="elementNames.IsDefault 438009"];
8158 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 438010"];
8159 [label="_namesIndex 438011"];
8160 [label="_decodingFailed = false; 438012"];
8161 [label="_decodingFailed 438013"];
8162 [label="_foundUsableErrorType = false; 438014"];
8163 [label="_foundUsableErrorType 438015"];
8164 [label="var decoded = decoder.DecodeType(metadataType); 438016"];
8165 [label="decoder.DecodeType(metadataType) 438017"];
8166 [label="param DecodeType(TypeSymbol type) 438018"];
8167 [label="param DecodeType(this) 438019"];
8168 [label="type.Kind 438020"];
8169 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 438021"];
8170 [label="switch (type.Kind)\n            {\n                case SymbolKind.ErrorType:\n                    _foundUsableErrorType = true;\n                    return type;\n\n                case SymbolKind.DynamicType:\n                case SymbolKind.TypeParameter:\n                    return type;\n\n                case SymbolKind.FunctionPointerType:\n                    return DecodeFunctionPointerType((FunctionPointerTypeSymbol)type);\n\n                case SymbolKind.PointerType:\n                    return DecodePointerType((PointerTypeSymbol)type);\n\n                case SymbolKind.NamedType:\n                    // We may have a tuple type from a substituted type symbol,\n                    // but it will be missing names from metadata, so we'll\n                    // need to re-create the type.\n                    //\n                    // Consider the declaration\n                    //\n                    //      class C : BaseType<(int x, int y)>\n                    //\n                    // The process for decoding tuples in C looks at the BaseType, calls\n                    // DecodeOrThrow, then passes the decoded type to the TupleTypeDecoder.\n                    // However, DecodeOrThrow uses the AbstractTypeMap to construct a\n                    // SubstitutedTypeSymbol, which eagerly converts tuple-compatible\n                    // types to TupleTypeSymbols. Thus, by the time we get to the Decoder\n                    // all metadata instances of System.ValueTuple will have been\n                    //  replaced with TupleTypeSymbols without names.\n                    // \n                    // Rather than fixing up after-the-fact it's possible that we could\n                    // flow up a SubstituteWith/Without tuple unification to the top level\n                    // of the type map and change DecodeOrThrow to call into the substitution\n                    // without unification instead.\n                    return DecodeNamedType((NamedTypeSymbol)type);\n\n                case SymbolKind.ArrayType:\n                    return DecodeArrayType((ArrayTypeSymbol)type);\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(type.TypeKind);\n            } 438022"];
8171 [label="return DecodeNamedType((NamedTypeSymbol)type); 438023"];
8172 [label="DecodeNamedType((NamedTypeSymbol)type) 438024"];
8173 [label="param DecodeNamedType(NamedTypeSymbol type) 438025"];
8174 [label="param DecodeNamedType(this) 438026"];
8175 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 438027"];
8176 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 438028"];
8177 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 438029"];
8178 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 438030"];
8179 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 438031"];
8180 [label="DecodeTypeArguments(typeArgs) 438032"];
8181 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 438033"];
8182 [label="param DecodeTypeArguments(this) 438034"];
8183 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 438035"];
8184 [label="return typeArgs; 438036"];
8185 [label="NamedTypeSymbol decodedType = type; 438037"];
8186 [label="type.ContainingType 438038"];
8187 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 438039"];
8188 [label="return _container as NamedTypeSymbol; 438040"];
8189 [label="NamedTypeSymbol containingType = type.ContainingType; 438041"];
8190 [label="NamedTypeSymbol? decodedContainingType; 438042"];
8191 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 438043"];
8192 [label="decodedContainingType = containingType; 438044"];
8193 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 438045"];
8194 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 438046"];
8195 [label="var typeArgsChanged = typeArgs != decodedArgs; 438047"];
8196 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 438048"];
8197 [label="decodedType.IsTupleType 438049"];
8198 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 438050"];
8199 [label="_ 438051"];
8200 [label="tupleCardinality: out _ 438052"];
8201 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 438053"];
8202 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 438054"];
8203 [label="param IsTupleTypeOfCardinality(this) 438055"];
8204 [label="IsUnboundGenericType 438056"];
8205 [label="get\n            {\n                return false;\n            } 438057"];
8206 [label="return false; 438058"];
8207 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438059"];
8208 [label="ContainingSymbol 438060"];
8209 [label="get\n            {\n                return _container;\n            } 438061"];
8210 [label="return _container; 438062"];
8211 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438063"];
8212 [label=".Kind 438064"];
8213 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 438065"];
8214 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438066"];
8215 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438067"];
8216 [label="ContainingNamespace 438068"];
8217 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 438069"];
8218 [label="get\n            {\n                return _container;\n            } 438070"];
8219 [label="return _container; 438071"];
8220 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438072"];
8221 [label="ContainingNamespace.ContainingNamespace 438073"];
8222 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 438074"];
8223 [label=".IsGlobalNamespace 438075"];
8224 [label="get\n            {\n                return true;\n            } 438076"];
8225 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438077"];
8226 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438078"];
8227 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438079"];
8228 [label="Name 438080"];
8229 [label="get\n            {\n                return _name;\n            } 438081"];
8230 [label="return _name; 438082"];
8231 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438083"];
8232 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438084"];
8233 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438085"];
8234 [label="tupleCardinality = 0; 438086"];
8235 [label="return false; 438087"];
8236 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 438088"];
8237 [label="return decodedType; 438089"];
8238 [label="if (!decoder._decodingFailed)\n            {\n                if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                }\n            } 438090"];
8239 [label="if (!hasTupleElementNamesAttribute || decoder._namesIndex == 0)\n                {\n                    return decoded;\n                } 438091"];
8240 [label="return decoded; 438092"];
8241 [label="return (object)decoded == (object)type ?\n                metadataType :\n                TypeWithAnnotations.Create(decoded, metadataType.NullableAnnotation, metadataType.CustomModifiers); 438093"];
8242 [label="(object)decoded == (object)type 438094"];
8243 [label="_propertyTypeWithAnnotations 438095"];
8244 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438096"];
8245 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438097"];
8246 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438098"];
8247 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438099"];
8248 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438100"];
8249 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438101"];
8250 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438102"];
8251 [label="DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) 438103"];
8252 [label="param DoSignaturesMatch(PEModule module) 438104"];
8253 [label="param DoSignaturesMatch(MetadataDecoder metadataDecoder) 438105"];
8254 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] propertyParams) 438106"];
8255 [label="param DoSignaturesMatch(PEMethodSymbol getMethod) 438107"];
8256 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] getMethodParams) 438108"];
8257 [label="param DoSignaturesMatch(PEMethodSymbol setMethod) 438109"];
8258 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] setMethodParams) 438110"];
8259 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 438111"];
8260 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 438112"];
8261 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 438113"];
8262 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 438114"];
8263 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 438115"];
8264 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 438116"];
8265 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 438117"];
8266 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 438118"];
8267 [label="bool hasGetMethod = getMethodParams != null; 438119"];
8268 [label="bool hasGetMethod = getMethodParams != null; 438120"];
8269 [label="bool hasSetMethod = setMethodParams != null; 438121"];
8270 [label="bool hasSetMethod = setMethodParams != null; 438122"];
8271 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438123"];
8272 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438124"];
8273 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438125"];
8274 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438126"];
8275 [label="param Equals(ISymbolInternal other) 438127"];
8276 [label="param Equals(TypeCompareKind compareKind) 438128"];
8277 [label="param Equals(this) 438129"];
8278 [label="return this.Equals(other as Symbol, compareKind); 438130"];
8279 [label="return this.Equals(other as Symbol, compareKind); 438131"];
8280 [label="this.Equals(other as Symbol, compareKind) 438132"];
8281 [label="param Equals(Symbol other) 438133"];
8282 [label="param Equals(TypeCompareKind compareKind) 438134"];
8283 [label="param Equals(this) 438135"];
8284 [label="var t2 = other as TypeSymbol; 438136"];
8285 [label="if (t2 is null)\n            {\n                return false;\n            } 438137"];
8286 [label="return this.Equals(t2, compareKind); 438138"];
8287 [label="return this.Equals(t2, compareKind); 438139"];
8288 [label="this.Equals(t2, compareKind) 438140"];
8289 [label="param Equals(TypeSymbol t2) 438141"];
8290 [label="param Equals(TypeCompareKind comparison) 438142"];
8291 [label="param Equals(this) 438143"];
8292 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 438144"];
8293 [label="t2 is NativeIntegerTypeSymbol nativeInteger 438145"];
8294 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 438146"];
8295 [label="base.Equals(t2, comparison) 438147"];
8296 [label="param Equals(TypeSymbol t2) 438148"];
8297 [label="param Equals(TypeCompareKind comparison) 438149"];
8298 [label="param Equals(this) 438150"];
8299 [label="if ((object)t2 == this) return true; 438151"];
8300 [label="return true; 438152"];
8301 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438153"];
8302 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 438154"];
8303 [label="if (hasGetMethod && hasSetMethod)\n            {\n                var lastPropertyParamIndex = propertyParams.Length - 1;\n                var getHandle = getMethodParams[lastPropertyParamIndex].Handle;\n                var setHandle = setMethodParams[lastPropertyParamIndex].Handle;\n                var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle);\n                var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle);\n                if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                }\n\n                if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                }\n            } 438155"];
8304 [label="return true; 438156"];
8305 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438157"];
8306 [label="MustCallMethodsDirectlyCore() 438158"];
8307 [label="param MustCallMethodsDirectlyCore(this) 438159"];
8308 [label="this.RefKind 438160"];
8309 [label="get { return _refKind; } 438161"];
8310 [label="return _refKind; 438162"];
8311 [label="if (this.RefKind != RefKind.None && _setMethod != null)\n            {\n                return true;\n            }\n            else if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 438163"];
8312 [label="this.ParameterCount 438164"];
8313 [label="get\n            {\n                return this.Parameters.Length;\n            } 438165"];
8314 [label="this.Parameters 438166"];
8315 [label="get { return _parameters; } 438167"];
8316 [label="return _parameters; 438168"];
8317 [label="return this.Parameters.Length; 438169"];
8318 [label="if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 438170"];
8319 [label="if (this.ParameterCount == 0)\n            {\n                return false;\n            }\n            else if (this.IsIndexedProperty)\n            {\n                return this.IsStatic;\n            }\n            else if (this.IsIndexer)\n            {\n                return this.HasRefOrOutParameter();\n            }\n            else\n            {\n                return true;\n            } 438171"];
8320 [label="return false; 438172"];
8321 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438173"];
8322 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438174"];
8323 [label="anyUnexpectedRequiredModifiers(propertyParams) 438175"];
8324 [label="static bool anyUnexpectedRequiredModifiers(ParamInfo<TypeSymbol>[] propertyParams)\n            {\n                return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired());\n            } 438176"];
8325 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 438177"];
8326 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 438178"];
8327 [label="return propertyParams.Any(p => (!p.RefCustomModifiers.IsDefaultOrEmpty && p.RefCustomModifiers.Any(m => !m.IsOptional && !m.Modifier.IsWellKnownTypeInAttribute())) ||\n                                               p.CustomModifiers.AnyRequired()); 438179"];
8328 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 438180"];
8329 [label="if (!callMethodsDirectly)\n            {\n                if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                }\n\n                if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                }\n            } 438181"];
8330 [label="if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                } 438182"];
8331 [label="if ((object)_getMethod != null)\n                {\n                    _getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet);\n                } 438183"];
8332 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 438184"];
8333 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 438185"];
8334 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet) 438186"];
8335 [label="param SetAssociatedProperty(PEPropertySymbol propertySymbol) 438187"];
8336 [label="param SetAssociatedProperty(MethodKind methodKind) 438188"];
8337 [label="param SetAssociatedProperty(this) 438189"];
8338 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 438190"];
8339 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 438191"];
8340 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 438192"];
8341 [label="this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind) 438193"];
8342 [label="param SetAssociatedPropertyOrEvent(Symbol propertyOrEventSymbol) 438194"];
8343 [label="param SetAssociatedPropertyOrEvent(MethodKind methodKind) 438195"];
8344 [label="param SetAssociatedPropertyOrEvent(this) 438196"];
8345 [label="if ((object)_associatedPropertyOrEventOpt == null)\n            {\n                Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2));\n\n                // No locking required since SetAssociatedProperty/SetAssociatedEvent will only be called\n                // by the thread that created the method symbol (and will be called before the method\n                // symbol is added to the containing type members and available to other threads).\n                _associatedPropertyOrEventOpt = propertyOrEventSymbol;\n\n                // NOTE: may be overwriting an existing value.\n                Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation);\n\n                _packedFlags.MethodKind = methodKind;\n                return true;\n            } 438197"];
8346 [label="if ((object)_associatedPropertyOrEventOpt == null)\n            {\n                Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2));\n\n                // No locking required since SetAssociatedProperty/SetAssociatedEvent will only be called\n                // by the thread that created the method symbol (and will be called before the method\n                // symbol is added to the containing type members and available to other threads).\n                _associatedPropertyOrEventOpt = propertyOrEventSymbol;\n\n                // NOTE: may be overwriting an existing value.\n                Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation);\n\n                _packedFlags.MethodKind = methodKind;\n                return true;\n            } 438198"];
8347 [label="propertyOrEventSymbol.ContainingType 438199"];
8348 [label="get\n            {\n                return _containingType;\n            } 438200"];
8349 [label="return _containingType; 438201"];
8350 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 438202"];
8351 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 438203"];
8352 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 438204"];
8353 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 438205"];
8354 [label="param Equals(TypeSymbol left) 438206"];
8355 [label="param Equals(TypeSymbol right) 438207"];
8356 [label="param Equals(TypeCompareKind comparison) 438208"];
8357 [label="if (left is null)\n            {\n                return right is null;\n            } 438209"];
8358 [label="return left.Equals(right, comparison); 438210"];
8359 [label="return left.Equals(right, comparison); 438211"];
8360 [label="left.Equals(right, comparison) 438212"];
8361 [label="param Equals(TypeSymbol t2) 438213"];
8362 [label="param Equals(TypeCompareKind comparison) 438214"];
8363 [label="param Equals(this) 438215"];
8364 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 438216"];
8365 [label="param Equals(TypeCompareKind comparison) 438217"];
8366 [label="param Equals(this) 438218"];
8367 [label="_associatedPropertyOrEventOpt 438219"];
8368 [label="0 438220"];
8369 [label="MethodKindOffset = 0 438221"];
8370 [label="0x1F 438222"];
8371 [label="MethodKindMask = 0x1F 438223"];
8372 [label="0x1 438224"];
8373 [label="5 438225"];
8374 [label="0x1 << 5 438226"];
8375 [label="MethodKindIsPopulatedBit = 0x1 << 5 438227"];
8376 [label="0x1 438228"];
8377 [label="6 438229"];
8378 [label="0x1 << 6 438230"];
8379 [label="IsExtensionMethodBit = 0x1 << 6 438231"];
8380 [label="0x1 438232"];
8381 [label="7 438233"];
8382 [label="0x1 << 7 438234"];
8383 [label="IsExtensionMethodIsPopulatedBit = 0x1 << 7 438235"];
8384 [label="0x1 438236"];
8385 [label="8 438237"];
8386 [label="0x1 << 8 438238"];
8387 [label="IsExplicitFinalizerOverrideBit = 0x1 << 8 438239"];
8388 [label="0x1 438240"];
8389 [label="9 438241"];
8390 [label="0x1 << 9 438242"];
8391 [label="IsExplicitClassOverrideBit = 0x1 << 9 438243"];
8392 [label="0x1 438244"];
8393 [label="10 438245"];
8394 [label="0x1 << 10 438246"];
8395 [label="IsExplicitOverrideIsPopulatedBit = 0x1 << 10 438247"];
8396 [label="0x1 438248"];
8397 [label="11 438249"];
8398 [label="0x1 << 11 438250"];
8399 [label="IsObsoleteAttributePopulatedBit = 0x1 << 11 438251"];
8400 [label="0x1 438252"];
8401 [label="12 438253"];
8402 [label="0x1 << 12 438254"];
8403 [label="IsCustomAttributesPopulatedBit = 0x1 << 12 438255"];
8404 [label="0x1 438256"];
8405 [label="13 438257"];
8406 [label="0x1 << 13 438258"];
8407 [label="IsUseSiteDiagnosticPopulatedBit = 0x1 << 13 438259"];
8408 [label="0x1 438260"];
8409 [label="14 438261"];
8410 [label="0x1 << 14 438262"];
8411 [label="IsConditionalPopulatedBit = 0x1 << 14 438263"];
8412 [label="0x1 438264"];
8413 [label="15 438265"];
8414 [label="0x1 << 15 438266"];
8415 [label="IsOverriddenOrHiddenMembersPopulatedBit = 0x1 << 15 438267"];
8416 [label="0x1 438268"];
8417 [label="16 438269"];
8418 [label="0x1 << 16 438270"];
8419 [label="IsReadOnlyBit = 0x1 << 16 438271"];
8420 [label="0x1 438272"];
8421 [label="17 438273"];
8422 [label="0x1 << 17 438274"];
8423 [label="IsReadOnlyPopulatedBit = 0x1 << 17 438275"];
8424 [label="18 438276"];
8425 [label="NullableContextOffset = 18 438277"];
8426 [label="0x7 438278"];
8427 [label="NullableContextMask = 0x7 438279"];
8428 [label="0x1 438280"];
8429 [label="21 438281"];
8430 [label="0x1 << 21 438282"];
8431 [label="DoesNotReturnBit = 0x1 << 21 438283"];
8432 [label="0x1 438284"];
8433 [label="22 438285"];
8434 [label="0x1 << 22 438286"];
8435 [label="IsDoesNotReturnPopulatedBit = 0x1 << 22 438287"];
8436 [label="0x1 438288"];
8437 [label="23 438289"];
8438 [label="0x1 << 23 438290"];
8439 [label="IsMemberNotNullPopulatedBit = 0x1 << 23 438291"];
8440 [label="0x1 438292"];
8441 [label="24 438293"];
8442 [label="0x1 << 24 438294"];
8443 [label="IsInitOnlyBit = 0x1 << 24 438295"];
8444 [label="0x1 438296"];
8445 [label="25 438297"];
8446 [label="0x1 << 25 438298"];
8447 [label="IsInitOnlyPopulatedBit = 0x1 << 25 438299"];
8448 [label="0x1 438300"];
8449 [label="26 438301"];
8450 [label="0x1 << 26 438302"];
8451 [label="IsUnmanagedCallersOnlyAttributePopulatedBit = 0x1 << 26 438303"];
8452 [label="Debug.Assert(EnumUtilities.ContainsAllValues<MethodKind>(MethodKindMask)); 438304"];
8453 [label="Debug.Assert(EnumUtilities.ContainsAllValues<NullableContextKind>(NullableContextMask)); 438305"];
8454 [label="_packedFlags.MethodKind 438306"];
8455 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 438307"];
8456 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 438308"];
8457 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 438309"];
8458 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 438310"];
8459 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 438311"];
8460 [label="_packedFlags.MethodKind = methodKind 438312"];
8461 [label="_packedFlags.MethodKind = methodKind; 438313"];
8462 [label="set\n                {\n                    Debug.Assert((int)value == ((int)value & MethodKindMask));\n                    _bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit;\n                } 438314"];
8463 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 438315"];
8464 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438316"];
8465 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438317"];
8466 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438318"];
8467 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438319"];
8468 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438320"];
8469 [label="_bits = (_bits & ~(MethodKindMask << MethodKindOffset)) | (((int)value & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 438321"];
8470 [label="_bits 438322"];
8471 [label="return true; 438323"];
8472 [label="return this.SetAssociatedPropertyOrEvent(propertySymbol, methodKind); 438324"];
8473 [label="_getMethod.SetAssociatedProperty(this, MethodKind.PropertyGet); 438325"];
8474 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 438326"];
8475 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 438327"];
8476 [label="if (callMethodsDirectly)\n            {\n                _flags |= Flags.CallMethodsDirectly;\n            } 438328"];
8477 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 438329"];
8478 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 438330"];
8479 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 438331"];
8480 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 438332"];
8481 [label="result.RefKind 438333"];
8482 [label="get { return _refKind; } 438334"];
8483 [label="return _refKind; 438335"];
8484 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 438336"];
8485 [label="result.RefCustomModifiers 438337"];
8486 [label="get { return ImmutableArray<CustomModifier>.Empty; } 438338"];
8487 [label="return ImmutableArray<CustomModifier>.Empty; 438339"];
8488 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 438340"];
8489 [label="result.RefCustomModifiers.HasInAttributeModifier() 438341"];
8490 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 438342"];
8491 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 438343"];
8492 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 438344"];
8493 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 438345"];
8494 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 438346"];
8495 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 438347"];
8496 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 438348"];
8497 [label="return result; 438349"];
8498 [label="members.Add(PEPropertySymbol.Create(moduleSymbol, this, propertyDef, getMethod, setMethod)); 438350"];
8499 [label="this.CreateProperties(methodHandleToSymbol, nonFieldMembers); 438351"];
8500 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 438352"];
8501 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 438353"];
8502 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 438354"];
8503 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers) 438355"];
8504 [label="param CreateEvents(MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols) 438356"];
8505 [label="param CreateEvents(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 438357"];
8506 [label="param CreateEvents(ArrayBuilder<Symbol> members) 438358"];
8507 [label="param CreateEvents(this) 438359"];
8508 [label="this.ContainingPEModule 438360"];
8509 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 438361"];
8510 [label="Symbol s = _container; 438362"];
8511 [label="s.Kind 438363"];
8512 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 438364"];
8513 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 438365"];
8514 [label="var moduleSymbol = this.ContainingPEModule; 438366"];
8515 [label="moduleSymbol.Module 438367"];
8516 [label="get\n            {\n                return _module;\n            } 438368"];
8517 [label="var module = moduleSymbol.Module; 438369"];
8518 [label="foreach (var eventRid in module.GetEventsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetEventMethodsOrThrow(eventRid);\n\n                        // NOTE: C# ignores all other accessors (most notably, raise/fire).\n                        PEMethodSymbol addMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Adder);\n                        PEMethodSymbol removeMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Remover);\n\n                        // NOTE: both accessors are required, but that will be reported separately.\n                        // Create the symbol unless both accessors are missing.\n                        if (((object)addMethod != null) || ((object)removeMethod != null))\n                        {\n                            members.Add(new PEEventSymbol(moduleSymbol, this, eventRid, addMethod, removeMethod, privateFieldNameToSymbols));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 438370"];
8519 [label="foreach (var eventRid in module.GetEventsOfTypeOrThrow(_handle))\n                {\n                    try\n                    {\n                        var methods = module.GetEventMethodsOrThrow(eventRid);\n\n                        // NOTE: C# ignores all other accessors (most notably, raise/fire).\n                        PEMethodSymbol addMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Adder);\n                        PEMethodSymbol removeMethod = GetAccessorMethod(module, methodHandleToSymbol, methods.Remover);\n\n                        // NOTE: both accessors are required, but that will be reported separately.\n                        // Create the symbol unless both accessors are missing.\n                        if (((object)addMethod != null) || ((object)removeMethod != null))\n                        {\n                            members.Add(new PEEventSymbol(moduleSymbol, this, eventRid, addMethod, removeMethod, privateFieldNameToSymbols));\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    { }\n                } 438371"];
8520 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 438372"];
8521 [label="foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    } 438373"];
8522 [label="members.AddRange(nonFieldMembers); 438374"];
8523 [label="members.AddRange(nonFieldMembers); 438375"];
8524 [label="nonFieldMembers.Free(); 438376"];
8525 [label="fieldMembers.Free(); 438377"];
8526 [label="methodHandleToSymbol.Free(); 438378"];
8527 [label="int membersCount = members.Count; 438379"];
8528 [label="foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                } 438380"];
8529 [label="new DeclarationOrderTypeSymbolComparer() 438381"];
8530 [label="param DeclarationOrderTypeSymbolComparer(this) 438382"];
8531 [label="Instance = new DeclarationOrderTypeSymbolComparer() 438383"];
8532 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 438384"];
8533 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 438385"];
8534 [label="members.Sort(membersCount, DeclarationOrderTypeSymbolComparer.Instance); 438386"];
8535 [label="Symbol previous = null; 438387"];
8536 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 438388"];
8537 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 438389"];
8538 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 438390"];
8539 [label="previous == null 438391"];
8540 [label="param ==(Symbol left) 438392"];
8541 [label="param ==(Symbol right) 438393"];
8542 [label="if (right is null)\n            {\n                return left is null;\n            } 438394"];
8543 [label="return left is null; 438395"];
8544 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 438396"];
8545 [label="previous = s; 438397"];
8546 [label="param ==(Symbol left) 438398"];
8547 [label="return left is null; 438399"];
8548 [label="Symbol current = s; 438400"];
8549 [label="previous.Kind 438401"];
8550 [label="get\n            {\n                return SymbolKind.Method;\n            } 438402"];
8551 [label="return SymbolKind.Method; 438403"];
8552 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438404"];
8553 [label="current.Kind 438405"];
8554 [label="get\n            {\n                return SymbolKind.Method;\n            } 438406"];
8555 [label="return SymbolKind.Method; 438407"];
8556 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438408"];
8557 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438409"];
8558 [label="previous = current; 438410"];
8559 [label="param ==(Symbol left) 438411"];
8560 [label="return left is null; 438412"];
8561 [label="previous.Kind 438413"];
8562 [label="get\n            {\n                return SymbolKind.Method;\n            } 438414"];
8563 [label="return SymbolKind.Method; 438415"];
8564 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438416"];
8565 [label="current.Kind 438417"];
8566 [label="get\n            {\n                return SymbolKind.Method;\n            } 438418"];
8567 [label="return SymbolKind.Method; 438419"];
8568 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438420"];
8569 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438421"];
8570 [label="get\n            {\n                return SymbolKind.Property;\n            } 438422"];
8571 [label="return SymbolKind.Property; 438423"];
8572 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438424"];
8573 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 438425"];
8574 [label="IsTupleType 438426"];
8575 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 438427"];
8576 [label="_ 438428"];
8577 [label="tupleCardinality: out _ 438429"];
8578 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 438430"];
8579 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 438431"];
8580 [label="param IsTupleTypeOfCardinality(this) 438432"];
8581 [label="IsUnboundGenericType 438433"];
8582 [label="get\n            {\n                return false;\n            } 438434"];
8583 [label="return false; 438435"];
8584 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438436"];
8585 [label="ContainingSymbol 438437"];
8586 [label="get\n            {\n                return _container;\n            } 438438"];
8587 [label="return _container; 438439"];
8588 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438440"];
8589 [label=".Kind 438441"];
8590 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 438442"];
8591 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438443"];
8592 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438444"];
8593 [label="ContainingNamespace 438445"];
8594 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 438446"];
8595 [label="get\n            {\n                return _container;\n            } 438447"];
8596 [label="return _container; 438448"];
8597 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438449"];
8598 [label="ContainingNamespace.ContainingNamespace 438450"];
8599 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 438451"];
8600 [label=".IsGlobalNamespace 438452"];
8601 [label="get\n            {\n                return false;\n            } 438453"];
8602 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438454"];
8603 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438455"];
8604 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 438456"];
8605 [label="tupleCardinality = 0; 438457"];
8606 [label="return false; 438458"];
8607 [label="if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                } 438459"];
8608 [label="var membersInDeclarationOrder = members.ToImmutable(); 438460"];
8609 [label="if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                } 438461"];
8610 [label="if (!ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersInDeclarationOrder, membersInDeclarationOrder))\n                {\n                    members.Free();\n                    members = null;\n                }\n                else\n                {\n                    // remove the types\n                    members.Clip(membersCount);\n                } 438462"];
8611 [label="members.Clip(membersCount); 438463"];
8612 [label="if (_lazyMembersByName == null)\n            {\n                if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                }\n\n                Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null);\n                if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                }\n            } 438464"];
8613 [label="if (_lazyMembersByName == null)\n            {\n                if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                }\n\n                Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members);\n\n                var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null);\n                if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                }\n            } 438465"];
8614 [label="if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                } 438466"];
8615 [label="Dictionary<string, ImmutableArray<Symbol>> membersDict = GroupByName(members); 438467"];
8616 [label="GroupByName(members) 438468"];
8617 [label="param GroupByName(ArrayBuilder<Symbol> symbols) 438469"];
8618 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 438470"];
8619 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 438471"];
8620 [label="return symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 438472"];
8621 [label="=> _name 438473"];
8622 [label="_name 438474"];
8623 [label="get { return this.IsIndexer ? WellKnownMemberNames.Indexer : _name; } 438475"];
8624 [label="this.IsIndexer 438476"];
8625 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 438477"];
8626 [label="this.ParameterCount 438478"];
8627 [label="get\n            {\n                return this.Parameters.Length;\n            } 438479"];
8628 [label="return _parameters; 438480"];
8629 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 438481"];
8630 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 438482"];
8631 [label="return false; 438483"];
8632 [label="return this.IsIndexer ? WellKnownMemberNames.Indexer : _name; 438484"];
8633 [label="_name 438485"];
8634 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 438486"];
8635 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 438487"];
8636 [label="var exchangeResult = Interlocked.CompareExchange(ref _lazyMembersByName, membersDict, null); 438488"];
8637 [label="if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                } 438489"];
8638 [label="if (exchangeResult == null)\n                {\n                    // we successfully swapped in the members dictionary.\n\n                    // Now, use these as the canonical member names.  This saves us memory by not having\n                    // two collections around at the same time with redundant data in them.\n                    //\n                    // NOTE(cyrusn): We must use an interlocked exchange here so that the full\n                    // construction of this object will be seen from 'MemberNames'.  Also, doing a\n                    // straight InterlockedExchange here is the right thing to do.  Consider the case\n                    // where one thread is calling in through 'MemberNames' while we are in the middle\n                    // of this method.  Either that thread will compute the member names and store it\n                    // first (in which case we overwrite it), or we will store first (in which case\n                    // their CompareExchange(..., ..., null) will fail.  Either way, this will be certain\n                    // to become the canonical set of member names.\n                    //\n                    // NOTE(cyrusn): This means that it is possible (and by design) for people to get a\n                    // different object back when they call MemberNames multiple times.  However, outside\n                    // of object identity, both collections should appear identical to the user.\n                    var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys);\n                    Interlocked.Exchange(ref _lazyMemberNames, memberNames);\n                } 438490"];
8639 [label="var memberNames = SpecializedCollections.ReadOnlyCollection(membersDict.Keys); 438491"];
8640 [label="Interlocked.Exchange(ref _lazyMemberNames, memberNames); 438492"];
8641 [label="Interlocked.Exchange(ref _lazyMemberNames, memberNames); 438493"];
8642 [label="if (members != null)\n            {\n                members.Free();\n            } 438494"];
8643 [label="if (members != null)\n            {\n                members.Free();\n            } 438495"];
8644 [label="members.Free(); 438496"];
8645 [label="LoadMembers(); 438497"];
8646 [label="EnsureAllMembersAreLoaded(); 438498"];
8647 [label="ImmutableArray<Symbol> m; 438499"];
8648 [label="m 438500"];
8649 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 438501"];
8650 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 438502"];
8651 [label="if (!_lazyMembersByName.TryGetValue(name, out m))\n            {\n                m = ImmutableArray<Symbol>.Empty;\n            } 438503"];
8652 [label="ImmutableArray<PENamedTypeSymbol> t; 438504"];
8653 [label="t 438505"];
8654 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 438506"];
8655 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 438507"];
8656 [label="if (_lazyNestedTypes.TryGetValue(name, out t))\n            {\n                m = m.Concat(StaticCast<Symbol>.From(t));\n            } 438508"];
8657 [label="return m; 438509"];
8658 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 438510"];
8659 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 438511"];
8660 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 438512"];
8661 [label="return GetRuntimeMember(members, descriptor, comparer, accessWithinOpt); 438513"];
8662 [label="GetRuntimeMember(members, descriptor, comparer, accessWithinOpt) 438514"];
8663 [label="param GetRuntimeMember(ImmutableArray<Symbol> members) 438515"];
8664 [label="param GetRuntimeMember(in MemberDescriptor descriptor) 438516"];
8665 [label="param GetRuntimeMember(SignatureComparer<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer) 438517"];
8666 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 438518"];
8667 [label="SymbolKind targetSymbolKind; 438519"];
8668 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 438520"];
8669 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 438521"];
8670 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 438522"];
8671 [label="Symbol? result = null; 438523"];
8672 [label="switch (descriptor.Flags & MemberFlags.KindMask)\n            {\n                case MemberFlags.Constructor:\n                    targetSymbolKind = SymbolKind.Method;\n                    targetMethodKind = MethodKind.Constructor;\n                    //  static constructors are never called explicitly\n                    Debug.Assert(!isStatic);\n                    break;\n\n                case MemberFlags.Method:\n                    targetSymbolKind = SymbolKind.Method;\n                    break;\n\n                case MemberFlags.PropertyGet:\n                    targetSymbolKind = SymbolKind.Method;\n                    targetMethodKind = MethodKind.PropertyGet;\n                    break;\n\n                case MemberFlags.Field:\n                    targetSymbolKind = SymbolKind.Field;\n                    break;\n\n                case MemberFlags.Property:\n                    targetSymbolKind = SymbolKind.Property;\n                    break;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(descriptor.Flags);\n            } 438524"];
8673 [label="targetSymbolKind = SymbolKind.Method; 438525"];
8674 [label="targetMethodKind = MethodKind.Constructor; 438526"];
8675 [label="Debug.Assert(!isStatic); 438527"];
8676 [label="foreach (var member in members)\n            {\n                if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                }\n\n                if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                }\n\n                switch (targetSymbolKind)\n                {\n                    case SymbolKind.Method:\n                        {\n                            MethodSymbol method = (MethodSymbol)member;\n                            MethodKind methodKind = method.MethodKind;\n                            // Treat user-defined conversions and operators as ordinary methods for the purpose\n                            // of matching them here.\n                            if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            }\n\n                            if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Property:\n                        {\n                            PropertySymbol property = (PropertySymbol)member;\n                            if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Field:\n                        if (!comparer.MatchFieldSignature((FieldSymbol)member, descriptor.Signature))\n                        {\n                            continue;\n                        }\n\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(targetSymbolKind);\n                }\n\n                // ambiguity\n                if (result is object)\n                {\n                    result = null;\n                    break;\n                }\n\n                result = member;\n            } 438528"];
8677 [label="member.Name 438529"];
8678 [label="_name 438530"];
8679 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 438531"];
8680 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 438532"];
8681 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 438533"];
8682 [label="member.Kind 438534"];
8683 [label="get\n            {\n                return SymbolKind.Method;\n            } 438535"];
8684 [label="return SymbolKind.Method; 438536"];
8685 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438537"];
8686 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438538"];
8687 [label="member.IsStatic 438539"];
8688 [label="=> HasFlag(MethodAttributes.Static) 438540"];
8689 [label="MethodAttributes.Static 438541"];
8690 [label="HasFlag(MethodAttributes.Static) 438542"];
8691 [label="param HasFlag(MethodAttributes flag) 438543"];
8692 [label="param HasFlag(this) 438544"];
8693 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438545"];
8694 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438546"];
8695 [label="return ((ushort)flag & _flags) != 0; 438547"];
8696 [label="return ((ushort)flag & _flags) != 0; 438548"];
8697 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438549"];
8698 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438550"];
8699 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438551"];
8700 [label="member.DeclaredAccessibility 438552"];
8701 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 438553"];
8702 [label="Flags 438554"];
8703 [label="=> (MethodAttributes)_flags 438555"];
8704 [label="(MethodAttributes)_flags 438556"];
8705 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 438557"];
8706 [label="return Accessibility.Public; 438558"];
8707 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438559"];
8708 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 438560"];
8709 [label="switch (targetSymbolKind)\n                {\n                    case SymbolKind.Method:\n                        {\n                            MethodSymbol method = (MethodSymbol)member;\n                            MethodKind methodKind = method.MethodKind;\n                            // Treat user-defined conversions and operators as ordinary methods for the purpose\n                            // of matching them here.\n                            if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            }\n\n                            if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Property:\n                        {\n                            PropertySymbol property = (PropertySymbol)member;\n                            if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            }\n\n                            if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            }\n                        }\n\n                        break;\n\n                    case SymbolKind.Field:\n                        if (!comparer.MatchFieldSignature((FieldSymbol)member, descriptor.Signature))\n                        {\n                            continue;\n                        }\n\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(targetSymbolKind);\n                } 438561"];
8710 [label="MethodSymbol method = (MethodSymbol)member; 438562"];
8711 [label="method.MethodKind 438563"];
8712 [label="get\n            {\n                if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                }\n                return _packedFlags.MethodKind;\n            } 438564"];
8713 [label="_packedFlags.MethodKindIsPopulated 438565"];
8714 [label="=> (_bits & MethodKindIsPopulatedBit) != 0 438566"];
8715 [label="_bits & MethodKindIsPopulatedBit 438567"];
8716 [label="0 438568"];
8717 [label="(_bits & MethodKindIsPopulatedBit) != 0 438569"];
8718 [label="if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                } 438570"];
8719 [label="this.ComputeMethodKind() 438571"];
8720 [label="param ComputeMethodKind(this) 438572"];
8721 [label="this.HasSpecialName 438573"];
8722 [label="=> HasFlag(MethodAttributes.SpecialName) 438574"];
8723 [label="MethodAttributes.SpecialName 438575"];
8724 [label="HasFlag(MethodAttributes.SpecialName) 438576"];
8725 [label="param HasFlag(MethodAttributes flag) 438577"];
8726 [label="param HasFlag(this) 438578"];
8727 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438579"];
8728 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438580"];
8729 [label="return ((ushort)flag & _flags) != 0; 438581"];
8730 [label="return ((ushort)flag & _flags) != 0; 438582"];
8731 [label="if (this.HasSpecialName)\n            {\n                if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (§15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (§15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                }\n\n                if (!this.HasRuntimeSpecialName && this.IsStatic && this.DeclaredAccessibility == Accessibility.Public)\n                {\n                    switch (_name)\n                    {\n                        case WellKnownMemberNames.AdditionOperatorName:\n                        case WellKnownMemberNames.BitwiseAndOperatorName:\n                        case WellKnownMemberNames.BitwiseOrOperatorName:\n                        case WellKnownMemberNames.DivisionOperatorName:\n                        case WellKnownMemberNames.EqualityOperatorName:\n                        case WellKnownMemberNames.ExclusiveOrOperatorName:\n                        case WellKnownMemberNames.GreaterThanOperatorName:\n                        case WellKnownMemberNames.GreaterThanOrEqualOperatorName:\n                        case WellKnownMemberNames.InequalityOperatorName:\n                        case WellKnownMemberNames.LeftShiftOperatorName:\n                        case WellKnownMemberNames.LessThanOperatorName:\n                        case WellKnownMemberNames.LessThanOrEqualOperatorName:\n                        case WellKnownMemberNames.ModulusOperatorName:\n                        case WellKnownMemberNames.MultiplyOperatorName:\n                        case WellKnownMemberNames.RightShiftOperatorName:\n                        case WellKnownMemberNames.SubtractionOperatorName:\n                            return IsValidUserDefinedOperatorSignature(2) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;\n                        case WellKnownMemberNames.DecrementOperatorName:\n                        case WellKnownMemberNames.FalseOperatorName:\n                        case WellKnownMemberNames.IncrementOperatorName:\n                        case WellKnownMemberNames.LogicalNotOperatorName:\n                        case WellKnownMemberNames.OnesComplementOperatorName:\n                        case WellKnownMemberNames.TrueOperatorName:\n                        case WellKnownMemberNames.UnaryNegationOperatorName:\n                        case WellKnownMemberNames.UnaryPlusOperatorName:\n                            return IsValidUserDefinedOperatorSignature(1) ? MethodKind.UserDefinedOperator : MethodKind.Ordinary;\n                        case WellKnownMemberNames.ImplicitConversionName:\n                        case WellKnownMemberNames.ExplicitConversionName:\n                            return IsValidUserDefinedOperatorSignature(1) ? MethodKind.Conversion : MethodKind.Ordinary;\n\n                            //case WellKnownMemberNames.ConcatenateOperatorName:\n                            //case WellKnownMemberNames.ExponentOperatorName:\n                            //case WellKnownMemberNames.IntegerDivisionOperatorName:\n                            //case WellKnownMemberNames.LikeOperatorName:\n                            //// Non-C#-supported overloaded operator\n                            //return MethodKind.Ordinary;\n                    }\n\n                    return MethodKind.Ordinary;\n                }\n            } 438583"];
8732 [label="if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (§15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (§15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                } 438584"];
8733 [label="if (_name.StartsWith('.', StringComparison.Ordinal))\n                {\n                    // 10.5.1 Instance constructor\n                    // An instance constructor shall be an instance (not static or virtual) method,\n                    // it shall be named .ctor, and marked instance, rtspecialname, and specialname (§15.4.2.6).\n                    // An instance constructor can have parameters, but shall not return a value.\n                    // An instance constructor cannot take generic type parameters.\n\n                    // 10.5.3 Type initializer\n                    // This method shall be static, take no parameters, return no value,\n                    // be marked with rtspecialname and specialname (§15.4.2.6), and be named .cctor.\n\n                    if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    }\n\n                    return MethodKind.Ordinary;\n                } 438585"];
8734 [label="Flags 438586"];
8735 [label="=> (MethodAttributes)_flags 438587"];
8736 [label="(MethodAttributes)_flags 438588"];
8737 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 438589"];
8738 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 438590"];
8739 [label="this.IsStatic 438591"];
8740 [label="=> HasFlag(MethodAttributes.Static) 438592"];
8741 [label="MethodAttributes.Static 438593"];
8742 [label="HasFlag(MethodAttributes.Static) 438594"];
8743 [label="param HasFlag(MethodAttributes flag) 438595"];
8744 [label="param HasFlag(this) 438596"];
8745 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438597"];
8746 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438598"];
8747 [label="return ((ushort)flag & _flags) != 0; 438599"];
8748 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 438600"];
8749 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 438601"];
8750 [label="this.ReturnsVoid 438602"];
8751 [label="=> this.ReturnType.IsVoidType() 438603"];
8752 [label="this.ReturnType 438604"];
8753 [label="=> ReturnTypeWithAnnotations.Type 438605"];
8754 [label="ReturnTypeWithAnnotations 438606"];
8755 [label="=> Signature.ReturnParam.TypeWithAnnotations 438607"];
8756 [label="Signature 438608"];
8757 [label="=> _lazySignature ?? LoadSignature() 438609"];
8758 [label="LoadSignature() 438610"];
8759 [label="param LoadSignature(this) 438611"];
8760 [label="_containingType.ContainingPEModule 438612"];
8761 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 438613"];
8762 [label="s.Kind 438614"];
8763 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 438615"];
8764 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 438616"];
8765 [label="var moduleSymbol = _containingType.ContainingPEModule; 438617"];
8766 [label="SignatureHeader signatureHeader; 438618"];
8767 [label="signatureHeader 438619"];
8768 [label="BadImageFormatException mrEx; 438620"];
8769 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438621"];
8770 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438622"];
8771 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438623"];
8772 [label="new MetadataDecoder(moduleSymbol, this) 438624"];
8773 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 438625"];
8774 [label="param MetadataDecoder(PEMethodSymbol context) 438626"];
8775 [label="param MetadataDecoder(this) 438627"];
8776 [label="moduleSymbol 438628"];
8777 [label="context.ContainingType 438629"];
8778 [label="=> _containingType 438630"];
8779 [label="_containingType 438631"];
8780 [label="context 438632"];
8781 [label="param MetadataDecoder(this) 438633"];
8782 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 438634"];
8783 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 438635"];
8784 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 438636"];
8785 [label="Debug.Assert((object)moduleSymbol != null); 438637"];
8786 [label="Debug.Assert((object)moduleSymbol != null); 438638"];
8787 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438639"];
8788 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438640"];
8789 [label="ParamInfo<TypeSymbol>[] paramInfo = new MetadataDecoder(moduleSymbol, this).GetSignatureForMethod(_handle, out signatureHeader, out mrEx); 438641"];
8790 [label="param GetSpecialType(this) 438642"];
8791 [label="this.Modules 438643"];
8792 [label="get\n            {\n                return _modules;\n            } 438644"];
8793 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 438645"];
8794 [label="module.GetReferencedAssemblies() 438646"];
8795 [label="param GetReferencedAssemblies(this) 438647"];
8796 [label="AssertReferencesInitialized() 438648"];
8797 [label="param AssertReferencesInitialized(this) 438649"];
8798 [label="Debug.Assert(_moduleReferences != null); 438650"];
8799 [label="Debug.Assert(_moduleReferences != null); 438651"];
8800 [label="AssertReferencesInitialized(); 438652"];
8801 [label="return _moduleReferences.Identities; 438653"];
8802 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 438654"];
8803 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 438655"];
8804 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 438656"];
8805 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 438657"];
8806 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 438658"];
8807 [label="bool makeBad = (mrEx != null); 438659"];
8808 [label="bool makeBad = (mrEx != null); 438660"];
8809 [label="if (!signatureHeader.IsGeneric &&\n                _lazyTypeParameters.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty);\n            } 438661"];
8810 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty); 438662"];
8811 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters,\n                    ImmutableArray<TypeParameterSymbol>.Empty); 438663"];
8812 [label="int count = paramInfo.Length - 1; 438664"];
8813 [label="int count = paramInfo.Length - 1; 438665"];
8814 [label="ImmutableArray<ParameterSymbol> @params; 438666"];
8815 [label="@params 438667"];
8816 [label="bool isBadParameter; 438668"];
8817 [label="if (count > 0)\n            {\n                var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count);\n                for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                }\n\n                @params = builder.ToImmutable();\n            }\n            else\n            {\n                @params = ImmutableArray<ParameterSymbol>.Empty;\n            } 438669"];
8818 [label="if (count > 0)\n            {\n                var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count);\n                for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                }\n\n                @params = builder.ToImmutable();\n            }\n            else\n            {\n                @params = ImmutableArray<ParameterSymbol>.Empty;\n            } 438670"];
8819 [label="var builder = ImmutableArray.CreateBuilder<ParameterSymbol>(count); 438671"];
8820 [label="for (int i = 0; i < count; i++)\n                {\n                    builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter));\n\n                    if (isBadParameter)\n                    {\n                        makeBad = true;\n                    }\n                } 438672"];
8821 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 438673"];
8822 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 438674"];
8823 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 438675"];
8824 [label="this.IsMetadataVirtual() 438676"];
8825 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 438677"];
8826 [label="=> HasFlag(MethodAttributes.Virtual) 438678"];
8827 [label="MethodAttributes.Virtual 438679"];
8828 [label="HasFlag(MethodAttributes.Virtual) 438680"];
8829 [label="param HasFlag(MethodAttributes flag) 438681"];
8830 [label="param HasFlag(this) 438682"];
8831 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438683"];
8832 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 438684"];
8833 [label="return ((ushort)flag & _flags) != 0; 438685"];
8834 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 438686"];
8835 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 438687"];
8836 [label="PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter) 438688"];
8837 [label="param Create(PEModuleSymbol moduleSymbol) 438689"];
8838 [label="param Create(PEMethodSymbol containingSymbol) 438690"];
8839 [label="param Create(bool isContainingSymbolVirtual) 438691"];
8840 [label="param Create(int ordinal) 438692"];
8841 [label="param Create(ParamInfo<TypeSymbol> parameterInfo) 438693"];
8842 [label="param Create(Symbol nullableContext) 438694"];
8843 [label="param Create(bool isReturn) 438695"];
8844 [label="param Create(out bool isBad) 438696"];
8845 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438697"];
8846 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438698"];
8847 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438699"];
8848 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438700"];
8849 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438701"];
8850 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438702"];
8851 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438703"];
8852 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 438704"];
8853 [label="Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad) 438705"];
8854 [label="param Create(PEModuleSymbol moduleSymbol) 438706"];
8855 [label="param Create(Symbol containingSymbol) 438707"];
8856 [label="param Create(bool isContainingSymbolVirtual) 438708"];
8857 [label="param Create(int ordinal) 438709"];
8858 [label="param Create(bool isByRef) 438710"];
8859 [label="param Create(ImmutableArray<ModifierInfo<TypeSymbol>> refCustomModifiers) 438711"];
8860 [label="param Create(TypeSymbol type) 438712"];
8861 [label="param Create(ParameterHandle handle) 438713"];
8862 [label="param Create(Symbol nullableContext) 438714"];
8863 [label="param Create(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 438715"];
8864 [label="param Create(bool isReturn) 438716"];
8865 [label="param Create(out bool isBad) 438717"];
8866 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 438718"];
8867 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 438719"];
8868 [label="CSharpCustomModifier.Convert(customModifiers) 438720"];
8869 [label="param Convert(ImmutableArray<ModifierInfo<TypeSymbol>> customModifiers) 438721"];
8870 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 438722"];
8871 [label="TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)) 438723"];
8872 [label="param Create(TypeSymbol typeSymbol) 438724"];
8873 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 438725"];
8874 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 438726"];
8875 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 438727"];
8876 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 438728"];
8877 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 438729"];
8878 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 438730"];
8879 [label="typeSymbol.IsNullableType() 438731"];
8880 [label="param IsNullableType(this TypeSymbol type) 438732"];
8881 [label="type.OriginalDefinition 438733"];
8882 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 438734"];
8883 [label="OriginalTypeSymbolDefinition 438735"];
8884 [label="get\n            {\n                return this.OriginalDefinition;\n            } 438736"];
8885 [label="this.OriginalDefinition 438737"];
8886 [label="get\n            {\n                return this;\n            } 438738"];
8887 [label="return this; 438739"];
8888 [label="return this.OriginalDefinition; 438740"];
8889 [label="return OriginalTypeSymbolDefinition; 438741"];
8890 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 438742"];
8891 [label="type.OriginalDefinition.SpecialType 438743"];
8892 [label="get\n            {\n                return _corTypeId;\n            } 438744"];
8893 [label="var a1 = defaultType is null; 438745"];
8894 [label="!a1 438746"];
8895 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 438747"];
8896 [label="defaultType.IsNullableType() 438748"];
8897 [label="param IsNullableType(this TypeSymbol type) 438749"];
8898 [label="type.OriginalDefinition 438750"];
8899 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 438751"];
8900 [label="OriginalTypeSymbolDefinition 438752"];
8901 [label="get\n            {\n                return this.OriginalDefinition;\n            } 438753"];
8902 [label="this.OriginalDefinition 438754"];
8903 [label="get\n            {\n                return this;\n            } 438755"];
8904 [label="return this; 438756"];
8905 [label="return this.OriginalDefinition; 438757"];
8906 [label="return OriginalTypeSymbolDefinition; 438758"];
8907 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 438759"];
8908 [label="type.OriginalDefinition.SpecialType 438760"];
8909 [label="get\n            {\n                return _corTypeId;\n            } 438761"];
8910 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 438762"];
8911 [label="Debug.Assert(a1 || a2 != true || a3); 438763"];
8912 [label="Debug.Assert(a1 || a2 != true || a3); 438764"];
8913 [label="Debug.Assert(extensions != null); 438765"];
8914 [label="Debug.Assert(extensions != null); 438766"];
8915 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 438767"];
8916 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438768"];
8917 [label="customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty 438769"];
8918 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438770"];
8919 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438771"];
8920 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438772"];
8921 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438773"];
8922 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438774"];
8923 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438775"];
8924 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438776"];
8925 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 438777"];
8926 [label="new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad) 438778"];
8927 [label="param PEParameterSymbol(PEModuleSymbol moduleSymbol) 438779"];
8928 [label="param PEParameterSymbol(Symbol containingSymbol) 438780"];
8929 [label="param PEParameterSymbol(int ordinal) 438781"];
8930 [label="param PEParameterSymbol(bool isByRef) 438782"];
8931 [label="param PEParameterSymbol(TypeWithAnnotations typeWithAnnotations) 438783"];
8932 [label="param PEParameterSymbol(ParameterHandle handle) 438784"];
8933 [label="param PEParameterSymbol(Symbol nullableContext) 438785"];
8934 [label="param PEParameterSymbol(int countOfCustomModifiers) 438786"];
8935 [label="param PEParameterSymbol(out bool isBad) 438787"];
8936 [label="param PEParameterSymbol(this) 438788"];
8937 [label="'value' 438789"];
8938 [label="ValueParameterName = 'value' 438790"];
8939 [label="param PEParameterSymbol(this) 438791"];
8940 [label="param ParameterSymbol(this) 438792"];
8941 [label="param ParameterSymbol(this) 438793"];
8942 [label="_lazyAdapter 438794"];
8943 [label="_containingSymbol 438795"];
8944 [label="_name 438796"];
8945 [label="_flags 438797"];
8946 [label="_moduleSymbol 438798"];
8947 [label="_lazyDefaultValue = ConstantValue.Unset 438799"];
8948 [label="_lazyIsParams 438800"];
8949 [label="_ordinal 438801"];
8950 [label="Debug.Assert((object)moduleSymbol != null); 438802"];
8951 [label="Debug.Assert((object)moduleSymbol != null); 438803"];
8952 [label="Debug.Assert((object)containingSymbol != null); 438804"];
8953 [label="Debug.Assert((object)containingSymbol != null); 438805"];
8954 [label="Debug.Assert(ordinal >= 0); 438806"];
8955 [label="Debug.Assert(ordinal >= 0); 438807"];
8956 [label="typeWithAnnotations.HasType 438808"];
8957 [label="=> !(DefaultType is null) 438809"];
8958 [label="DefaultType is null 438810"];
8959 [label="!(DefaultType is null) 438811"];
8960 [label="Debug.Assert(typeWithAnnotations.HasType); 438812"];
8961 [label="isBad = false; 438813"];
8962 [label="_moduleSymbol 438814"];
8963 [label="_containingSymbol 438815"];
8964 [label="_ordinal 438816"];
8965 [label="_handle 438817"];
8966 [label="RefKind refKind = RefKind.None; 438818"];
8967 [label="if (handle.IsNil)\n            {\n                refKind = isByRef ? RefKind.Ref : RefKind.None;\n                byte? value = nullableContext.GetNullableContextValue();\n                if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                }\n                _lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                _lazyHiddenAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                _lazyDefaultValue = ConstantValue.NotAvailable;\n                _lazyIsParams = ThreeState.False;\n            }\n            else\n            {\n                try\n                {\n                    moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags);\n                }\n                catch (BadImageFormatException)\n                {\n                    isBad = true;\n                }\n\n                if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                }\n\n                var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind);\n                typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol);\n                typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers);\n                // Decode nullable before tuple types to avoid converting between\n                // NamedTypeSymbol and TupleTypeSymbol unnecessarily.\n\n                // The containing type is passed to NullableTypeDecoder.TransformType to determine access\n                // for property parameters because the property does not have explicit accessibility in metadata.\n                var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol;\n                typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext);\n                typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol);\n            } 438819"];
8968 [label="moduleSymbol.Module 438820"];
8969 [label="get\n            {\n                return _module;\n            } 438821"];
8970 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 438822"];
8971 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 438823"];
8972 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 438824"];
8973 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 438825"];
8974 [label="moduleSymbol.Module.GetParamPropsOrThrow(handle, out _name, out _flags); 438826"];
8975 [label="if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                } 438827"];
8976 [label="typeWithAnnotations.Type 438828"];
8977 [label="=> _extensions?.GetResolvedType(DefaultType) 438829"];
8978 [label="DefaultType 438830"];
8979 [label="=> defaultType 438831"];
8980 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 438832"];
8981 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 438833"];
8982 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 438834"];
8983 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 438835"];
8984 [label="var typeSymbol = DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind); 438836"];
8985 [label="DynamicTypeDecoder.TransformType(typeWithAnnotations.Type, countOfCustomModifiers, handle, moduleSymbol, refKind) 438837"];
8986 [label="param TransformType(TypeSymbol metadataType) 438838"];
8987 [label="param TransformType(int targetSymbolCustomModifierCount) 438839"];
8988 [label="param TransformType(EntityHandle targetSymbolToken) 438840"];
8989 [label="param TransformType(PEModuleSymbol containingModule) 438841"];
8990 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 438842"];
8991 [label="Debug.Assert((object)metadataType != null); 438843"];
8992 [label="Debug.Assert((object)metadataType != null); 438844"];
8993 [label="return _module; 438845"];
8994 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 438846"];
8995 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 438847"];
8996 [label="typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol); 438848"];
8997 [label="NativeIntegerTypeDecoder.TransformType(typeSymbol, handle, moduleSymbol) 438849"];
8998 [label="param TransformType(TypeSymbol type) 438850"];
8999 [label="param TransformType(EntityHandle handle) 438851"];
9000 [label="param TransformType(PEModuleSymbol containingModule) 438852"];
9001 [label="return _module; 438853"];
9002 [label="return containingModule.Module.HasNativeIntegerAttribute(handle, out var transformFlags) ?\n                TransformType(type, transformFlags) :\n                type; 438854"];
9003 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 438855"];
9004 [label="typeWithAnnotations.CustomModifiers 438856"];
9005 [label="=> _extensions.CustomModifiers 438857"];
9006 [label="_extensions.CustomModifiers 438858"];
9007 [label="=> _customModifiers 438859"];
9008 [label="_customModifiers 438860"];
9009 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 438861"];
9010 [label="typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers) 438862"];
9011 [label="param WithTypeAndModifiers(TypeSymbol typeSymbol) 438863"];
9012 [label="param WithTypeAndModifiers(ImmutableArray<CustomModifier> customModifiers) 438864"];
9013 [label="=>\n            _extensions.WithTypeAndModifiers(this, typeSymbol, customModifiers) 438865"];
9014 [label="this 438866"];
9015 [label="typeSymbol 438867"];
9016 [label="customModifiers 438868"];
9017 [label="_extensions.WithTypeAndModifiers(this, typeSymbol, customModifiers) 438869"];
9018 [label="param WithTypeAndModifiers(TypeWithAnnotations type) 438870"];
9019 [label="param WithTypeAndModifiers(TypeSymbol typeSymbol) 438871"];
9020 [label="param WithTypeAndModifiers(ImmutableArray<CustomModifier> customModifiers) 438872"];
9021 [label="param WithTypeAndModifiers(this) 438873"];
9022 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 438874"];
9023 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 438875"];
9024 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 438876"];
9025 [label="CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers) 438877"];
9026 [label="param CreateNonLazyType(TypeSymbol typeSymbol) 438878"];
9027 [label="param CreateNonLazyType(NullableAnnotation nullableAnnotation) 438879"];
9028 [label="param CreateNonLazyType(ImmutableArray<CustomModifier> customModifiers) 438880"];
9029 [label="var a1 = defaultType is null; 438881"];
9030 [label="!a1 438882"];
9031 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 438883"];
9032 [label="defaultType.IsNullableType() 438884"];
9033 [label="param IsNullableType(this TypeSymbol type) 438885"];
9034 [label="type.OriginalDefinition 438886"];
9035 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 438887"];
9036 [label="OriginalTypeSymbolDefinition 438888"];
9037 [label="get\n            {\n                return this.OriginalDefinition;\n            } 438889"];
9038 [label="this.OriginalDefinition 438890"];
9039 [label="get\n            {\n                return this;\n            } 438891"];
9040 [label="return this; 438892"];
9041 [label="return this.OriginalDefinition; 438893"];
9042 [label="return OriginalTypeSymbolDefinition; 438894"];
9043 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 438895"];
9044 [label="type.OriginalDefinition.SpecialType 438896"];
9045 [label="get\n            {\n                return _corTypeId;\n            } 438897"];
9046 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 438898"];
9047 [label="Debug.Assert(a1 || a2 != true || a3); 438899"];
9048 [label="Debug.Assert(a1 || a2 != true || a3); 438900"];
9049 [label="Debug.Assert(extensions != null); 438901"];
9050 [label="Debug.Assert(extensions != null); 438902"];
9051 [label="return CreateNonLazyType(typeSymbol, type.NullableAnnotation, customModifiers); 438903"];
9052 [label="typeWithAnnotations = typeWithAnnotations.WithTypeAndModifiers(typeSymbol, typeWithAnnotations.CustomModifiers); 438904"];
9053 [label="containingSymbol.Kind 438905"];
9054 [label="get\n            {\n                return SymbolKind.Method;\n            } 438906"];
9055 [label="return SymbolKind.Method; 438907"];
9056 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 438908"];
9057 [label="containingSymbol.Kind == SymbolKind.Property 438909"];
9058 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 438910"];
9059 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 438911"];
9060 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 438912"];
9061 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 438913"];
9062 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 438914"];
9063 [label="typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext); 438915"];
9064 [label="NullableTypeDecoder.TransformType(typeWithAnnotations, handle, moduleSymbol, accessSymbol: accessSymbol, nullableContext: nullableContext) 438916"];
9065 [label="param TransformType(TypeWithAnnotations metadataType) 438917"];
9066 [label="param TransformType(EntityHandle targetSymbolToken) 438918"];
9067 [label="param TransformType(PEModuleSymbol containingModule) 438919"];
9068 [label="param TransformType(Symbol accessSymbol) 438920"];
9069 [label="param TransformType(Symbol nullableContext) 438921"];
9070 [label="metadataType.HasType 438922"];
9071 [label="=> !(DefaultType is null) 438923"];
9072 [label="DefaultType is null 438924"];
9073 [label="!(DefaultType is null) 438925"];
9074 [label="Debug.Assert(metadataType.HasType); 438926"];
9075 [label="accessSymbol.IsDefinition 438927"];
9076 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 438928"];
9077 [label="OriginalDefinition 438929"];
9078 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 438930"];
9079 [label="OriginalSymbolDefinition 438931"];
9080 [label="get\n            {\n                return this.OriginalDefinition;\n            } 438932"];
9081 [label="this.OriginalDefinition 438933"];
9082 [label="get\n            {\n                return this;\n            } 438934"];
9083 [label="return this; 438935"];
9084 [label="return this.OriginalDefinition; 438936"];
9085 [label="return OriginalSymbolDefinition; 438937"];
9086 [label="return (object)this == (object)OriginalDefinition; 438938"];
9087 [label="Debug.Assert(accessSymbol.IsDefinition); 438939"];
9088 [label="accessSymbol.ContainingModule 438940"];
9089 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 438941"];
9090 [label="this.ContainingSymbol 438942"];
9091 [label="=> _containingType 438943"];
9092 [label="_containingType 438944"];
9093 [label="var container = this.ContainingSymbol; 438945"];
9094 [label="return (object)container != null ? container.ContainingModule : null; 438946"];
9095 [label="return (object)container != null ? container.ContainingModule : null; 438947"];
9096 [label="(object)container != null 438948"];
9097 [label="container.ContainingModule 438949"];
9098 [label="get\n            {\n                return ContainingPEModule;\n            } 438950"];
9099 [label="ContainingPEModule 438951"];
9100 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 438952"];
9101 [label="s.Kind 438953"];
9102 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 438954"];
9103 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 438955"];
9104 [label="return ContainingPEModule; 438956"];
9105 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 438957"];
9106 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 438958"];
9107 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 438959"];
9108 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 438960"];
9109 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 438961"];
9110 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 438962"];
9111 [label="Debug.Assert(symbol is object); 438963"];
9112 [label="symbol.Kind 438964"];
9113 [label="get\n            {\n                return SymbolKind.Method;\n            } 438965"];
9114 [label="return SymbolKind.Method; 438966"];
9115 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 438967"];
9116 [label="isInternal = false; 438968"];
9117 [label="symbol.DeclaredAccessibility 438969"];
9118 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 438970"];
9119 [label="Flags 438971"];
9120 [label="=> (MethodAttributes)_flags 438972"];
9121 [label="(MethodAttributes)_flags 438973"];
9122 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 438974"];
9123 [label="return Accessibility.Public; 438975"];
9124 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 438976"];
9125 [label="symbol.ContainingType 438977"];
9126 [label="=> _containingType 438978"];
9127 [label="_containingType 438979"];
9128 [label="symbol = symbol.ContainingType; 438980"];
9129 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 438981"];
9130 [label="symbol.DeclaredAccessibility 438982"];
9131 [label="Accessibility access = Accessibility.Private; 438983"];
9132 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 438984"];
9133 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 438985"];
9134 [label="return _container as NamedTypeSymbol; 438986"];
9135 [label="return true; 438987"];
9136 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 438988"];
9137 [label="return _module; 438989"];
9138 [label="param GetNullableContextValue(this) 438990"];
9139 [label="byte? value; 438991"];
9140 [label="if (!_packedFlags.TryGetNullableContext(out value))\n            {\n                value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue();\n                _packedFlags.SetNullableContext(value);\n            } 438992"];
9141 [label="_packedFlags.TryGetNullableContext(out value) 438993"];
9142 [label="param TryGetNullableContext(out byte? value) 438994"];
9143 [label="param TryGetNullableContext(this) 438995"];
9144 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 438996"];
9145 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 438997"];
9146 [label="return ((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 438998"];
9147 [label="((NullableContextKind)((_bits >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value) 438999"];
9148 [label="param TryGetByte(this NullableContextKind kind) 439000"];
9149 [label="param TryGetByte(out byte? value) 439001"];
9150 [label="value = null; 439002"];
9151 [label="if (!_packedFlags.TryGetNullableContext(out value))\n            {\n                value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue();\n                _packedFlags.SetNullableContext(value);\n            } 439003"];
9152 [label="_containingType.ContainingPEModule 439004"];
9153 [label="s.Kind 439005"];
9154 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439006"];
9155 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 439007"];
9156 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 439008"];
9157 [label="_containingType.ContainingPEModule.Module 439009"];
9158 [label="get\n            {\n                return _module;\n            } 439010"];
9159 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 439011"];
9160 [label="value = _containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) ?\n                    arg :\n                    _containingType.GetNullableContextValue(); 439012"];
9161 [label="_containingType.ContainingPEModule.Module.HasNullableContextAttribute(_handle, out byte arg) 439013"];
9162 [label="_containingType.GetNullableContextValue() 439014"];
9163 [label="byte? value; 439015"];
9164 [label="param TryGetByte(out byte? value) 439016"];
9165 [label="value = null; 439017"];
9166 [label="return true; 439018"];
9167 [label="_packedFlags.SetNullableContext(value); 439019"];
9168 [label="_packedFlags.SetNullableContext(value) 439020"];
9169 [label="param SetNullableContext(byte? value) 439021"];
9170 [label="param SetNullableContext(this) 439022"];
9171 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 439023"];
9172 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 439024"];
9173 [label="value.ToNullableContextFlags() 439025"];
9174 [label="param ToNullableContextFlags(this byte? value) 439026"];
9175 [label="return ThreadSafeFlagOperations.Set(ref _bits, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 439027"];
9176 [label="return value; 439028"];
9177 [label="return metadataType; 439029"];
9178 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 439030"];
9179 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 439031"];
9180 [label="typeWithAnnotations = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol); 439032"];
9181 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeWithAnnotations, handle, moduleSymbol) 439033"];
9182 [label="param DecodeTupleTypesIfApplicable(TypeWithAnnotations metadataType) 439034"];
9183 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 439035"];
9184 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 439036"];
9185 [label="return _module; 439037"];
9186 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 439038"];
9187 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 439039"];
9188 [label="DefaultType 439040"];
9189 [label="=> defaultType 439041"];
9190 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 439042"];
9191 [label="RoslynDebug.AssertNotNull(metadataType); 439043"];
9192 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 439044"];
9193 [label="_elementNames 439045"];
9194 [label="elementNames.IsDefault 439046"];
9195 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 439047"];
9196 [label="_namesIndex 439048"];
9197 [label="_foundUsableErrorType = false; 439049"];
9198 [label="_foundUsableErrorType 439050"];
9199 [label="param DecodeType(this) 439051"];
9200 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 439052"];
9201 [label="param DecodeNamedType(this) 439053"];
9202 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 439054"];
9203 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 439055"];
9204 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 439056"];
9205 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 439057"];
9206 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 439058"];
9207 [label="DecodeTypeArguments(typeArgs) 439059"];
9208 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 439060"];
9209 [label="param DecodeTypeArguments(this) 439061"];
9210 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 439062"];
9211 [label="return typeArgs; 439063"];
9212 [label="type.ContainingType 439064"];
9213 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 439065"];
9214 [label="return _container as NamedTypeSymbol; 439066"];
9215 [label="NamedTypeSymbol containingType = type.ContainingType; 439067"];
9216 [label="NamedTypeSymbol? decodedContainingType; 439068"];
9217 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 439069"];
9218 [label="decodedContainingType = containingType; 439070"];
9219 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 439071"];
9220 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 439072"];
9221 [label="var typeArgsChanged = typeArgs != decodedArgs; 439073"];
9222 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 439074"];
9223 [label="decodedType.IsTupleType 439075"];
9224 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 439076"];
9225 [label="_ 439077"];
9226 [label="tupleCardinality: out _ 439078"];
9227 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 439079"];
9228 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 439080"];
9229 [label="param IsTupleTypeOfCardinality(this) 439081"];
9230 [label="IsUnboundGenericType 439082"];
9231 [label="get\n            {\n                return false;\n            } 439083"];
9232 [label="return false; 439084"];
9233 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439085"];
9234 [label="ContainingSymbol 439086"];
9235 [label="get\n            {\n                return _container;\n            } 439087"];
9236 [label="return _container; 439088"];
9237 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439089"];
9238 [label=".Kind 439090"];
9239 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439091"];
9240 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439092"];
9241 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439093"];
9242 [label="ContainingNamespace 439094"];
9243 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 439095"];
9244 [label="get\n            {\n                return _container;\n            } 439096"];
9245 [label="return _container; 439097"];
9246 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439098"];
9247 [label="ContainingNamespace.ContainingNamespace 439099"];
9248 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 439100"];
9249 [label=".IsGlobalNamespace 439101"];
9250 [label="get\n            {\n                return true;\n            } 439102"];
9251 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439103"];
9252 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439104"];
9253 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439105"];
9254 [label="Name 439106"];
9255 [label="get\n            {\n                return _name;\n            } 439107"];
9256 [label="return _name; 439108"];
9257 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439109"];
9258 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439110"];
9259 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439111"];
9260 [label="tupleCardinality = 0; 439112"];
9261 [label="return false; 439113"];
9262 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 439114"];
9263 [label="return decoded; 439115"];
9264 [label="_typeWithAnnotations 439116"];
9265 [label="bool hasNameInMetadata = !string.IsNullOrEmpty(_name); 439117"];
9266 [label="if (!hasNameInMetadata)\n            {\n                // As was done historically, if the parameter doesn't have a name, we give it the name 'value'.\n                _name = 'value';\n            } 439118"];
9267 [label="0 439119"];
9268 [label="WellKnownAttributeDataOffset = 0 439120"];
9269 [label="8 439121"];
9270 [label="WellKnownAttributeCompletionFlagOffset = 8 439122"];
9271 [label="16 439123"];
9272 [label="RefKindOffset = 16 439124"];
9273 [label="20 439125"];
9274 [label="FlowAnalysisAnnotationsOffset = 20 439126"];
9275 [label="0x3 439127"];
9276 [label="RefKindMask = 0x3 439128"];
9277 [label="0xFF 439129"];
9278 [label="WellKnownAttributeDataMask = 0xFF 439130"];
9279 [label="WellKnownAttributeCompletionFlagMask = WellKnownAttributeDataMask 439131"];
9280 [label="0xFF 439132"];
9281 [label="FlowAnalysisAnnotationsMask = 0xFF 439133"];
9282 [label="0x1 439134"];
9283 [label="18 439135"];
9284 [label="0x1 << 18 439136"];
9285 [label="HasNameInMetadataBit = 0x1 << 18 439137"];
9286 [label="0x1 439138"];
9287 [label="19 439139"];
9288 [label="0x1 << 19 439140"];
9289 [label="FlowAnalysisAnnotationsCompletionBit = 0x1 << 19 439141"];
9290 [label="WellKnownAttributeCompletionFlagMask << WellKnownAttributeCompletionFlagOffset 439142"];
9291 [label="AllWellKnownAttributesCompleteNoData = WellKnownAttributeCompletionFlagMask << WellKnownAttributeCompletionFlagOffset 439143"];
9292 [label="Debug.Assert(EnumUtilities.ContainsAllValues<WellKnownAttributeFlags>(WellKnownAttributeDataMask)); 439144"];
9293 [label="Debug.Assert(EnumUtilities.ContainsAllValues<RefKind>(RefKindMask)); 439145"];
9294 [label="Debug.Assert(EnumUtilities.ContainsAllValues<FlowAnalysisAnnotations>(FlowAnalysisAnnotationsMask)); 439146"];
9295 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 439147"];
9296 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 439148"];
9297 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 439149"];
9298 [label="_packedFlags = new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata); 439150"];
9299 [label="new PackedFlags(refKind, attributesAreComplete: handle.IsNil, hasNameInMetadata: hasNameInMetadata) 439151"];
9300 [label="param PackedFlags(RefKind refKind) 439152"];
9301 [label="param PackedFlags(bool attributesAreComplete) 439153"];
9302 [label="param PackedFlags(bool hasNameInMetadata) 439154"];
9303 [label="param PackedFlags(this) 439155"];
9304 [label="int refKindBits = ((int)refKind & RefKindMask) << RefKindOffset; 439156"];
9305 [label="int refKindBits = ((int)refKind & RefKindMask) << RefKindOffset; 439157"];
9306 [label="attributesAreComplete 439158"];
9307 [label="int attributeBits = attributesAreComplete ? AllWellKnownAttributesCompleteNoData : 0; 439159"];
9308 [label="hasNameInMetadata 439160"];
9309 [label="int hasNameInMetadataBits = hasNameInMetadata ? HasNameInMetadataBit : 0; 439161"];
9310 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 439162"];
9311 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 439163"];
9312 [label="_bits 439164"];
9313 [label="_packedFlags 439165"];
9314 [label="this.RefKind 439166"];
9315 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439167"];
9316 [label="_packedFlags.RefKind 439168"];
9317 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439169"];
9318 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 439170"];
9319 [label="return _packedFlags.RefKind; 439171"];
9320 [label="Debug.Assert(refKind == this.RefKind); 439172"];
9321 [label="this.HasNameInMetadata 439173"];
9322 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 439174"];
9323 [label="_packedFlags.HasNameInMetadata 439175"];
9324 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 439176"];
9325 [label="return (_bits & HasNameInMetadataBit) != 0; 439177"];
9326 [label="return (_bits & HasNameInMetadataBit) != 0; 439178"];
9327 [label="return _packedFlags.HasNameInMetadata; 439179"];
9328 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 439180"];
9329 [label="parameter.RefCustomModifiers 439181"];
9330 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 439182"];
9331 [label="return ImmutableArray<CustomModifier>.Empty; 439183"];
9332 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 439184"];
9333 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 439185"];
9334 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 439186"];
9335 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439187"];
9336 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439188"];
9337 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439189"];
9338 [label="parameter.RefKind 439190"];
9339 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439191"];
9340 [label="_packedFlags.RefKind 439192"];
9341 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439193"];
9342 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 439194"];
9343 [label="return _packedFlags.RefKind; 439195"];
9344 [label="if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439196"];
9345 [label="if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439197"];
9346 [label="return parameter; 439198"];
9347 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 439199"];
9348 [label="if (isBadParameter)\n                    {\n                        makeBad = true;\n                    } 439200"];
9349 [label="@params = builder.ToImmutable(); 439201"];
9350 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439202"];
9351 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439203"];
9352 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439204"];
9353 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 439205"];
9354 [label="param AsDynamicIfNoPia(this TypeSymbol type) 439206"];
9355 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 439207"];
9356 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 439208"];
9357 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 439209"];
9358 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 439210"];
9359 [label="type.SpecialType 439211"];
9360 [label="get\n            {\n                return _corTypeId;\n            } 439212"];
9361 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 439213"];
9362 [label="result = null; 439214"];
9363 [label="paramInfo[0].Type = returnType; 439215"];
9364 [label="paramInfo[0].Type = returnType; 439216"];
9365 [label="paramInfo[0].Type 439217"];
9366 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439218"];
9367 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439219"];
9368 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439220"];
9369 [label="this.IsMetadataVirtual() 439221"];
9370 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 439222"];
9371 [label="=> HasFlag(MethodAttributes.Virtual) 439223"];
9372 [label="MethodAttributes.Virtual 439224"];
9373 [label="HasFlag(MethodAttributes.Virtual) 439225"];
9374 [label="param HasFlag(MethodAttributes flag) 439226"];
9375 [label="param HasFlag(this) 439227"];
9376 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439228"];
9377 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439229"];
9378 [label="return ((ushort)flag & _flags) != 0; 439230"];
9379 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439231"];
9380 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439232"];
9381 [label="var returnParam = PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter); 439233"];
9382 [label="PEParameterSymbol.Create(\n                moduleSymbol, this, this.IsMetadataVirtual(), 0,\n                paramInfo[0], nullableContext: this, isReturn: true, out isBadParameter) 439234"];
9383 [label="param Create(PEModuleSymbol moduleSymbol) 439235"];
9384 [label="param Create(PEMethodSymbol containingSymbol) 439236"];
9385 [label="param Create(bool isContainingSymbolVirtual) 439237"];
9386 [label="param Create(int ordinal) 439238"];
9387 [label="param Create(ParamInfo<TypeSymbol> parameterInfo) 439239"];
9388 [label="param Create(Symbol nullableContext) 439240"];
9389 [label="param Create(bool isReturn) 439241"];
9390 [label="param Create(out bool isBad) 439242"];
9391 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 439243"];
9392 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 439244"];
9393 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 439245"];
9394 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 439246"];
9395 [label="return Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad); 439247"];
9396 [label="Create(\n                moduleSymbol, containingSymbol, isContainingSymbolVirtual, ordinal,\n                parameterInfo.IsByRef, parameterInfo.RefCustomModifiers, parameterInfo.Type,\n                parameterInfo.Handle, nullableContext, parameterInfo.CustomModifiers, isReturn, out isBad) 439248"];
9397 [label="param Create(PEModuleSymbol moduleSymbol) 439249"];
9398 [label="param Create(Symbol containingSymbol) 439250"];
9399 [label="param Create(bool isContainingSymbolVirtual) 439251"];
9400 [label="param Create(int ordinal) 439252"];
9401 [label="param Create(bool isByRef) 439253"];
9402 [label="param Create(Symbol nullableContext) 439254"];
9403 [label="param Create(bool isReturn) 439255"];
9404 [label="param Create(out bool isBad) 439256"];
9405 [label="CSharpCustomModifier.Convert(customModifiers) 439257"];
9406 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 439258"];
9407 [label="TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)) 439259"];
9408 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 439260"];
9409 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 439261"];
9410 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 439262"];
9411 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 439263"];
9412 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 439264"];
9413 [label="typeSymbol.IsNullableType() 439265"];
9414 [label="param IsNullableType(this TypeSymbol type) 439266"];
9415 [label="type.OriginalDefinition 439267"];
9416 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439268"];
9417 [label="OriginalTypeSymbolDefinition 439269"];
9418 [label="get\n            {\n                return this.OriginalDefinition;\n            } 439270"];
9419 [label="this.OriginalDefinition 439271"];
9420 [label="get\n            {\n                return this;\n            } 439272"];
9421 [label="return this; 439273"];
9422 [label="return this.OriginalDefinition; 439274"];
9423 [label="return OriginalTypeSymbolDefinition; 439275"];
9424 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439276"];
9425 [label="type.OriginalDefinition.SpecialType 439277"];
9426 [label="get\n            {\n                return _corTypeId;\n            } 439278"];
9427 [label="var a1 = defaultType is null; 439279"];
9428 [label="!a1 439280"];
9429 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 439281"];
9430 [label="defaultType.IsNullableType() 439282"];
9431 [label="param IsNullableType(this TypeSymbol type) 439283"];
9432 [label="type.OriginalDefinition 439284"];
9433 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439285"];
9434 [label="OriginalTypeSymbolDefinition 439286"];
9435 [label="get\n            {\n                return this.OriginalDefinition;\n            } 439287"];
9436 [label="this.OriginalDefinition 439288"];
9437 [label="get\n            {\n                return this;\n            } 439289"];
9438 [label="return this; 439290"];
9439 [label="return this.OriginalDefinition; 439291"];
9440 [label="return OriginalTypeSymbolDefinition; 439292"];
9441 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439293"];
9442 [label="type.OriginalDefinition.SpecialType 439294"];
9443 [label="get\n            {\n                return _corTypeId;\n            } 439295"];
9444 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 439296"];
9445 [label="Debug.Assert(a1 || a2 != true || a3); 439297"];
9446 [label="Debug.Assert(a1 || a2 != true || a3); 439298"];
9447 [label="Debug.Assert(extensions != null); 439299"];
9448 [label="Debug.Assert(extensions != null); 439300"];
9449 [label="var typeWithModifiers = TypeWithAnnotations.Create(type, customModifiers: CSharpCustomModifier.Convert(customModifiers)); 439301"];
9450 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 439302"];
9451 [label="param PEParameterSymbol(bool isByRef) 439303"];
9452 [label="param PEParameterSymbol(int countOfCustomModifiers) 439304"];
9453 [label="param PEParameterSymbol(out bool isBad) 439305"];
9454 [label="_containingSymbol 439306"];
9455 [label="_moduleSymbol 439307"];
9456 [label="_ordinal 439308"];
9457 [label="Debug.Assert((object)moduleSymbol != null); 439309"];
9458 [label="Debug.Assert((object)containingSymbol != null); 439310"];
9459 [label="Debug.Assert(ordinal >= 0); 439311"];
9460 [label="typeWithAnnotations.HasType 439312"];
9461 [label="=> !(DefaultType is null) 439313"];
9462 [label="DefaultType is null 439314"];
9463 [label="!(DefaultType is null) 439315"];
9464 [label="Debug.Assert(typeWithAnnotations.HasType); 439316"];
9465 [label="isBad = false; 439317"];
9466 [label="isByRef 439318"];
9467 [label="refKind = isByRef ? RefKind.Ref : RefKind.None; 439319"];
9468 [label="nullableContext.GetNullableContextValue() 439320"];
9469 [label="byte? value; 439321"];
9470 [label="param TryGetNullableContext(out byte? value) 439322"];
9471 [label="param TryGetByte(out byte? value) 439323"];
9472 [label="return true; 439324"];
9473 [label="byte? value = nullableContext.GetNullableContextValue(); 439325"];
9474 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 439326"];
9475 [label="_lazyCustomAttributes 439327"];
9476 [label="_lazyHiddenAttributes 439328"];
9477 [label="_lazyDefaultValue 439329"];
9478 [label="_lazyIsParams 439330"];
9479 [label="if (!hasNameInMetadata)\n            {\n                // As was done historically, if the parameter doesn't have a name, we give it the name 'value'.\n                _name = 'value';\n            } 439331"];
9480 [label="_name = 'value'; 439332"];
9481 [label="_name 439333"];
9482 [label="int attributeBits = attributesAreComplete ? AllWellKnownAttributesCompleteNoData : 0; 439334"];
9483 [label="_bits = refKindBits | attributeBits | hasNameInMetadataBits; 439335"];
9484 [label="this.RefKind 439336"];
9485 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439337"];
9486 [label="_packedFlags.RefKind 439338"];
9487 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439339"];
9488 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 439340"];
9489 [label="return _packedFlags.RefKind; 439341"];
9490 [label="Debug.Assert(refKind == this.RefKind); 439342"];
9491 [label="this.HasNameInMetadata 439343"];
9492 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 439344"];
9493 [label="_packedFlags.HasNameInMetadata 439345"];
9494 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 439346"];
9495 [label="return (_bits & HasNameInMetadataBit) != 0; 439347"];
9496 [label="return (_bits & HasNameInMetadataBit) != 0; 439348"];
9497 [label="return _packedFlags.HasNameInMetadata; 439349"];
9498 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 439350"];
9499 [label="parameter.RefCustomModifiers 439351"];
9500 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 439352"];
9501 [label="return ImmutableArray<CustomModifier>.Empty; 439353"];
9502 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 439354"];
9503 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 439355"];
9504 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 439356"];
9505 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439357"];
9506 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439358"];
9507 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439359"];
9508 [label="parameter.RefKind 439360"];
9509 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439361"];
9510 [label="_packedFlags.RefKind 439362"];
9511 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439363"];
9512 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 439364"];
9513 [label="return _packedFlags.RefKind; 439365"];
9514 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439366"];
9515 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439367"];
9516 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439368"];
9517 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 439369"];
9518 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 439370"];
9519 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 439371"];
9520 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 439372"];
9521 [label="var signature = new SignatureData(signatureHeader, @params, returnParam); 439373"];
9522 [label="new SignatureData(signatureHeader, @params, returnParam) 439374"];
9523 [label="param SignatureData(SignatureHeader header) 439375"];
9524 [label="param SignatureData(ImmutableArray<ParameterSymbol> parameters) 439376"];
9525 [label="param SignatureData(PEParameterSymbol returnParam) 439377"];
9526 [label="param SignatureData(this) 439378"];
9527 [label="ReturnParam 439379"];
9528 [label="this.Header 439380"];
9529 [label="this.Parameters 439381"];
9530 [label="this.ReturnParam 439382"];
9531 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 439383"];
9532 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 439384"];
9533 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 439385"];
9534 [label="_lazySignature ?? LoadSignature() 439386"];
9535 [label="Signature.ReturnParam.TypeWithAnnotations 439387"];
9536 [label="get\n            {\n                return _typeWithAnnotations;\n            } 439388"];
9537 [label="return _typeWithAnnotations; 439389"];
9538 [label="ReturnTypeWithAnnotations.Type 439390"];
9539 [label="=> _extensions?.GetResolvedType(DefaultType) 439391"];
9540 [label="=> defaultType 439392"];
9541 [label="this.ReturnType.IsVoidType() 439393"];
9542 [label="param IsVoidType(this TypeSymbol type) 439394"];
9543 [label="type.SpecialType 439395"];
9544 [label="get\n            {\n                return _corTypeId;\n            } 439396"];
9545 [label="return type.SpecialType == SpecialType.System_Void; 439397"];
9546 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 439398"];
9547 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 439399"];
9548 [label="this.Arity 439400"];
9549 [label="get\n            {\n                if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                }\n\n                try\n                {\n                    int parameterCount;\n                    int typeParameterCount;\n                    MetadataDecoder.GetSignatureCountsOrThrow(_containingType.ContainingPEModule.Module, _handle, out parameterCount, out typeParameterCount);\n                    return typeParameterCount;\n                }\n                catch (BadImageFormatException)\n                {\n                    return TypeParameters.Length;\n                }\n            } 439401"];
9550 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 439402"];
9551 [label="return _lazyTypeParameters.Length; 439403"];
9552 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 439404"];
9553 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 439405"];
9554 [label="if ((Flags & (MethodAttributes.RTSpecialName | MethodAttributes.Virtual)) == MethodAttributes.RTSpecialName &&\n                        _name.Equals(this.IsStatic ? WellKnownMemberNames.StaticConstructorName : WellKnownMemberNames.InstanceConstructorName) &&\n                        this.ReturnsVoid && this.Arity == 0)\n                    {\n                        if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        }\n                    } 439406"];
9555 [label="this.IsStatic 439407"];
9556 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439408"];
9557 [label="if (this.IsStatic)\n                        {\n                            if (Parameters.Length == 0)\n                            {\n                                return MethodKind.StaticConstructor;\n                            }\n                        }\n                        else\n                        {\n                            return MethodKind.Constructor;\n                        } 439409"];
9558 [label="return MethodKind.Constructor; 439410"];
9559 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()); 439411"];
9560 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()) 439412"];
9561 [label="param InitializeMethodKind(MethodKind methodKind) 439413"];
9562 [label="param InitializeMethodKind(this) 439414"];
9563 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 439415"];
9564 [label="int bitsToSet = (((int)methodKind & MethodKindMask) << MethodKindOffset) | MethodKindIsPopulatedBit; 439416"];
9565 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 439417"];
9566 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 439418"];
9567 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 439419"];
9568 [label="param BitsAreUnsetOrSame(int bits) 439420"];
9569 [label="param BitsAreUnsetOrSame(int mask) 439421"];
9570 [label="return (bits & mask) == 0 || (bits & mask) == mask; 439422"];
9571 [label="return (bits & mask) == 0 || (bits & mask) == mask; 439423"];
9572 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 439424"];
9573 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 439425"];
9574 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 439426"];
9575 [label="_packedFlags.InitializeMethodKind(this.ComputeMethodKind()); 439427"];
9576 [label="_packedFlags.MethodKind 439428"];
9577 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 439429"];
9578 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 439430"];
9579 [label="return _packedFlags.MethodKind; 439431"];
9580 [label="MethodKind methodKind = method.MethodKind; 439432"];
9581 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 439433"];
9582 [label="method.Arity 439434"];
9583 [label="get\n            {\n                if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                }\n\n                try\n                {\n                    int parameterCount;\n                    int typeParameterCount;\n                    MetadataDecoder.GetSignatureCountsOrThrow(_containingType.ContainingPEModule.Module, _handle, out parameterCount, out typeParameterCount);\n                    return typeParameterCount;\n                }\n                catch (BadImageFormatException)\n                {\n                    return TypeParameters.Length;\n                }\n            } 439435"];
9584 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 439436"];
9585 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439437"];
9586 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439438"];
9587 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439439"];
9588 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439440"];
9589 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439441"];
9590 [label="method.IsVirtual 439442"];
9591 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 439443"];
9592 [label="this.IsMetadataVirtual() 439444"];
9593 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 439445"];
9594 [label="=> HasFlag(MethodAttributes.Virtual) 439446"];
9595 [label="MethodAttributes.Virtual 439447"];
9596 [label="HasFlag(MethodAttributes.Virtual) 439448"];
9597 [label="param HasFlag(MethodAttributes flag) 439449"];
9598 [label="param HasFlag(this) 439450"];
9599 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439451"];
9600 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439452"];
9601 [label="return ((ushort)flag & _flags) != 0; 439453"];
9602 [label="return ((ushort)flag & _flags) != 0; 439454"];
9603 [label="this.IsMetadataVirtual() && !this.IsDestructor 439455"];
9604 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 439456"];
9605 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 439457"];
9606 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 439458"];
9607 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439459"];
9608 [label="method.IsOverride 439460"];
9609 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 439461"];
9610 [label="this._containingType.IsInterface 439462"];
9611 [label="get\n            {\n                return _flags.IsInterface();\n            } 439463"];
9612 [label="return _flags.IsInterface(); 439464"];
9613 [label="this.IsMetadataVirtual() 439465"];
9614 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 439466"];
9615 [label="=> HasFlag(MethodAttributes.Virtual) 439467"];
9616 [label="MethodAttributes.Virtual 439468"];
9617 [label="HasFlag(MethodAttributes.Virtual) 439469"];
9618 [label="param HasFlag(MethodAttributes flag) 439470"];
9619 [label="param HasFlag(this) 439471"];
9620 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439472"];
9621 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439473"];
9622 [label="return ((ushort)flag & _flags) != 0; 439474"];
9623 [label="return ((ushort)flag & _flags) != 0; 439475"];
9624 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 439476"];
9625 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 439477"];
9626 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 439478"];
9627 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439479"];
9628 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439480"];
9629 [label="method.IsAbstract 439481"];
9630 [label="=> HasFlag(MethodAttributes.Abstract) 439482"];
9631 [label="MethodAttributes.Abstract 439483"];
9632 [label="HasFlag(MethodAttributes.Abstract) 439484"];
9633 [label="param HasFlag(MethodAttributes flag) 439485"];
9634 [label="param HasFlag(this) 439486"];
9635 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439487"];
9636 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439488"];
9637 [label="return ((ushort)flag & _flags) != 0; 439489"];
9638 [label="return ((ushort)flag & _flags) != 0; 439490"];
9639 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439491"];
9640 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439492"];
9641 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 439493"];
9642 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 439494"];
9643 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 439495"];
9644 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 439496"];
9645 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 439497"];
9646 [label="param GetParameters(MethodSymbol method) 439498"];
9647 [label="param GetParameters(this) 439499"];
9648 [label="method.Parameters 439500"];
9649 [label="=> Signature.Parameters 439501"];
9650 [label="Signature 439502"];
9651 [label="=> _lazySignature ?? LoadSignature() 439503"];
9652 [label="Signature.Parameters 439504"];
9653 [label="return method.Parameters; 439505"];
9654 [label="param IsByRefMethod(MethodSymbol method) 439506"];
9655 [label="param IsByRefMethod(this) 439507"];
9656 [label="method.RefKind 439508"];
9657 [label="=> Signature.ReturnParam.RefKind 439509"];
9658 [label="Signature 439510"];
9659 [label="=> _lazySignature ?? LoadSignature() 439511"];
9660 [label="_lazySignature ?? LoadSignature() 439512"];
9661 [label="Signature.ReturnParam.RefKind 439513"];
9662 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439514"];
9663 [label="_packedFlags.RefKind 439515"];
9664 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439516"];
9665 [label="return (RefKind)((_bits >> RefKindOffset) & RefKindMask); 439517"];
9666 [label="return _packedFlags.RefKind; 439518"];
9667 [label="return method.RefKind != RefKind.None; 439519"];
9668 [label="param GetReturnType(MethodSymbol method) 439520"];
9669 [label="param GetReturnType(this) 439521"];
9670 [label="method.ReturnType 439522"];
9671 [label="=> ReturnTypeWithAnnotations.Type 439523"];
9672 [label="ReturnTypeWithAnnotations 439524"];
9673 [label="Signature 439525"];
9674 [label="_lazySignature ?? LoadSignature() 439526"];
9675 [label="Signature.ReturnParam.TypeWithAnnotations 439527"];
9676 [label="ReturnTypeWithAnnotations.Type 439528"];
9677 [label="=> defaultType 439529"];
9678 [label="return method.ReturnType; 439530"];
9679 [label="param MatchTypeToTypeId(TypeSymbol type) 439531"];
9680 [label="param MatchTypeToTypeId(int typeId) 439532"];
9681 [label="param MatchTypeToTypeId(this) 439533"];
9682 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 439534"];
9683 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 439535"];
9684 [label="return base.MatchTypeToTypeId(type, typeId); 439536"];
9685 [label="return base.MatchTypeToTypeId(type, typeId); 439537"];
9686 [label="base.MatchTypeToTypeId(type, typeId) 439538"];
9687 [label="param MatchTypeToTypeId(TypeSymbol type) 439539"];
9688 [label="param MatchTypeToTypeId(int typeId) 439540"];
9689 [label="param MatchTypeToTypeId(this) 439541"];
9690 [label="type.OriginalDefinition 439542"];
9691 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439543"];
9692 [label="OriginalTypeSymbolDefinition 439544"];
9693 [label="get\n            {\n                return this.OriginalDefinition;\n            } 439545"];
9694 [label="this.OriginalDefinition 439546"];
9695 [label="get\n            {\n                return this;\n            } 439547"];
9696 [label="return this; 439548"];
9697 [label="return this.OriginalDefinition; 439549"];
9698 [label="return OriginalTypeSymbolDefinition; 439550"];
9699 [label="if ((int)type.OriginalDefinition.SpecialType == typeId)\n                {\n                    if (type.IsDefinition)\n                    {\n                        return true;\n                    }\n\n                    return type.Equals(type.OriginalDefinition, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 439551"];
9700 [label="type.OriginalDefinition.SpecialType 439552"];
9701 [label="get\n            {\n                return _corTypeId;\n            } 439553"];
9702 [label="return _corTypeId; 439554"];
9703 [label="if ((int)type.OriginalDefinition.SpecialType == typeId)\n                {\n                    if (type.IsDefinition)\n                    {\n                        return true;\n                    }\n\n                    return type.Equals(type.OriginalDefinition, TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 439555"];
9704 [label="type.IsDefinition 439556"];
9705 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 439557"];
9706 [label="OriginalDefinition 439558"];
9707 [label="get\n            {\n                return OriginalSymbolDefinition;\n            } 439559"];
9708 [label="OriginalSymbolDefinition 439560"];
9709 [label="get\n            {\n                return this.OriginalTypeSymbolDefinition;\n            } 439561"];
9710 [label="this.OriginalTypeSymbolDefinition 439562"];
9711 [label="get\n            {\n                return this.OriginalDefinition;\n            } 439563"];
9712 [label="return this.OriginalTypeSymbolDefinition; 439564"];
9713 [label="return OriginalSymbolDefinition; 439565"];
9714 [label="return (object)this == (object)OriginalDefinition; 439566"];
9715 [label="if (type.IsDefinition)\n                    {\n                        return true;\n                    } 439567"];
9716 [label="return true; 439568"];
9717 [label="param IsByRefParam(ParameterSymbol parameter) 439569"];
9718 [label="param IsByRefParam(this) 439570"];
9719 [label="parameter.RefKind 439571"];
9720 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439572"];
9721 [label="_packedFlags.RefKind 439573"];
9722 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 439574"];
9723 [label="return parameter.RefKind != RefKind.None; 439575"];
9724 [label="param GetParamType(ParameterSymbol parameter) 439576"];
9725 [label="param GetParamType(this) 439577"];
9726 [label="parameter.Type 439578"];
9727 [label="=> TypeWithAnnotations.Type 439579"];
9728 [label="TypeWithAnnotations 439580"];
9729 [label="get\n            {\n                return _typeWithAnnotations;\n            } 439581"];
9730 [label="return _typeWithAnnotations; 439582"];
9731 [label="TypeWithAnnotations.Type 439583"];
9732 [label="=> _extensions?.GetResolvedType(DefaultType) 439584"];
9733 [label="=> defaultType 439585"];
9734 [label="return parameter.Type; 439586"];
9735 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 439587"];
9736 [label="result = member; 439588"];
9737 [label="member.Name 439589"];
9738 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 439590"];
9739 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 439591"];
9740 [label="member.Kind 439592"];
9741 [label="get\n            {\n                return SymbolKind.Method;\n            } 439593"];
9742 [label="return SymbolKind.Method; 439594"];
9743 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439595"];
9744 [label="member.IsStatic 439596"];
9745 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439597"];
9746 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439598"];
9747 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439599"];
9748 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439600"];
9749 [label="member.DeclaredAccessibility 439601"];
9750 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 439602"];
9751 [label="Flags 439603"];
9752 [label="=> (MethodAttributes)_flags 439604"];
9753 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 439605"];
9754 [label="return Accessibility.Public; 439606"];
9755 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439607"];
9756 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 439608"];
9757 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439609"];
9758 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439610"];
9759 [label="s.Kind 439611"];
9760 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439612"];
9761 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 439613"];
9762 [label="Debug.Assert((object)moduleSymbol != null); 439614"];
9763 [label="param GetSpecialType(this) 439615"];
9764 [label="this.Modules 439616"];
9765 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 439617"];
9766 [label="module.GetReferencedAssemblies() 439618"];
9767 [label="param GetReferencedAssemblies(this) 439619"];
9768 [label="AssertReferencesInitialized() 439620"];
9769 [label="param AssertReferencesInitialized(this) 439621"];
9770 [label="Debug.Assert(_moduleReferences != null); 439622"];
9771 [label="Debug.Assert(_moduleReferences != null); 439623"];
9772 [label="AssertReferencesInitialized(); 439624"];
9773 [label="return _moduleReferences.Identities; 439625"];
9774 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 439626"];
9775 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 439627"];
9776 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 439628"];
9777 [label="=> this.SpecialType 439629"];
9778 [label="this.SpecialType 439630"];
9779 [label="get\n            {\n                return _corTypeId;\n            } 439631"];
9780 [label="bool makeBad = (mrEx != null); 439632"];
9781 [label="bool makeBad = (mrEx != null); 439633"];
9782 [label="ImmutableArray<ParameterSymbol> @params; 439634"];
9783 [label="@params 439635"];
9784 [label="bool isBadParameter; 439636"];
9785 [label="this.IsMetadataVirtual() 439637"];
9786 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 439638"];
9787 [label="=> HasFlag(MethodAttributes.Virtual) 439639"];
9788 [label="MethodAttributes.Virtual 439640"];
9789 [label="HasFlag(MethodAttributes.Virtual) 439641"];
9790 [label="param HasFlag(MethodAttributes flag) 439642"];
9791 [label="param HasFlag(this) 439643"];
9792 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439644"];
9793 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439645"];
9794 [label="return ((ushort)flag & _flags) != 0; 439646"];
9795 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 439647"];
9796 [label="param Create(bool isContainingSymbolVirtual) 439648"];
9797 [label="param Create(bool isReturn) 439649"];
9798 [label="param Create(out bool isBad) 439650"];
9799 [label="param Create(bool isContainingSymbolVirtual) 439651"];
9800 [label="param Create(bool isReturn) 439652"];
9801 [label="param Create(out bool isBad) 439653"];
9802 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 439654"];
9803 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 439655"];
9804 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 439656"];
9805 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 439657"];
9806 [label="typeSymbol.IsNullableType() 439658"];
9807 [label="param IsNullableType(this TypeSymbol type) 439659"];
9808 [label="type.OriginalDefinition 439660"];
9809 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439661"];
9810 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439662"];
9811 [label="type.OriginalDefinition.SpecialType 439663"];
9812 [label="get\n            {\n                return _corTypeId;\n            } 439664"];
9813 [label="var a1 = defaultType is null; 439665"];
9814 [label="!a1 439666"];
9815 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 439667"];
9816 [label="defaultType.IsNullableType() 439668"];
9817 [label="param IsNullableType(this TypeSymbol type) 439669"];
9818 [label="type.OriginalDefinition 439670"];
9819 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439671"];
9820 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439672"];
9821 [label="type.OriginalDefinition.SpecialType 439673"];
9822 [label="get\n            {\n                return _corTypeId;\n            } 439674"];
9823 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 439675"];
9824 [label="Debug.Assert(a1 || a2 != true || a3); 439676"];
9825 [label="Debug.Assert(a1 || a2 != true || a3); 439677"];
9826 [label="Debug.Assert(extensions != null); 439678"];
9827 [label="param PEParameterSymbol(int countOfCustomModifiers) 439679"];
9828 [label="param PEParameterSymbol(out bool isBad) 439680"];
9829 [label="_containingSymbol 439681"];
9830 [label="_moduleSymbol 439682"];
9831 [label="_ordinal 439683"];
9832 [label="Debug.Assert((object)moduleSymbol != null); 439684"];
9833 [label="Debug.Assert((object)containingSymbol != null); 439685"];
9834 [label="Debug.Assert(ordinal >= 0); 439686"];
9835 [label="typeWithAnnotations.HasType 439687"];
9836 [label="=> !(DefaultType is null) 439688"];
9837 [label="DefaultType is null 439689"];
9838 [label="!(DefaultType is null) 439690"];
9839 [label="Debug.Assert(typeWithAnnotations.HasType); 439691"];
9840 [label="isBad = false; 439692"];
9841 [label="if (isByRef)\n                {\n                    ParameterAttributes inOutFlags = _flags & (ParameterAttributes.Out | ParameterAttributes.In);\n\n                    if (inOutFlags == ParameterAttributes.Out)\n                    {\n                        refKind = RefKind.Out;\n                    }\n                    else if (moduleSymbol.Module.HasIsReadOnlyAttribute(handle))\n                    {\n                        refKind = RefKind.In;\n                    }\n                    else\n                    {\n                        refKind = RefKind.Ref;\n                    }\n                } 439693"];
9842 [label="=> defaultType 439694"];
9843 [label="param TransformType(int targetSymbolCustomModifierCount) 439695"];
9844 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 439696"];
9845 [label="Debug.Assert((object)metadataType != null); 439697"];
9846 [label="param WithTypeAndModifiers(this) 439698"];
9847 [label="var a1 = defaultType is null; 439699"];
9848 [label="!a1 439700"];
9849 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 439701"];
9850 [label="defaultType.IsNullableType() 439702"];
9851 [label="param IsNullableType(this TypeSymbol type) 439703"];
9852 [label="type.OriginalDefinition 439704"];
9853 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439705"];
9854 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439706"];
9855 [label="type.OriginalDefinition.SpecialType 439707"];
9856 [label="get\n            {\n                return _corTypeId;\n            } 439708"];
9857 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 439709"];
9858 [label="Debug.Assert(a1 || a2 != true || a3); 439710"];
9859 [label="Debug.Assert(extensions != null); 439711"];
9860 [label="containingSymbol.Kind 439712"];
9861 [label="get\n            {\n                return SymbolKind.Method;\n            } 439713"];
9862 [label="return SymbolKind.Method; 439714"];
9863 [label="var accessSymbol = containingSymbol.Kind == SymbolKind.Property ? containingSymbol.ContainingSymbol : containingSymbol; 439715"];
9864 [label="containingSymbol.Kind == SymbolKind.Property 439716"];
9865 [label="param TransformType(Symbol accessSymbol) 439717"];
9866 [label="metadataType.HasType 439718"];
9867 [label="=> !(DefaultType is null) 439719"];
9868 [label="DefaultType is null 439720"];
9869 [label="!(DefaultType is null) 439721"];
9870 [label="Debug.Assert(metadataType.HasType); 439722"];
9871 [label="accessSymbol.IsDefinition 439723"];
9872 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 439724"];
9873 [label="get\n            {\n                return this.OriginalDefinition;\n            } 439725"];
9874 [label="this.OriginalDefinition 439726"];
9875 [label="get\n            {\n                return this;\n            } 439727"];
9876 [label="return this; 439728"];
9877 [label="return this.OriginalDefinition; 439729"];
9878 [label="Debug.Assert(accessSymbol.IsDefinition); 439730"];
9879 [label="accessSymbol.ContainingModule 439731"];
9880 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 439732"];
9881 [label="this.ContainingSymbol 439733"];
9882 [label="=> _containingType 439734"];
9883 [label="_containingType 439735"];
9884 [label="var container = this.ContainingSymbol; 439736"];
9885 [label="return (object)container != null ? container.ContainingModule : null; 439737"];
9886 [label="return (object)container != null ? container.ContainingModule : null; 439738"];
9887 [label="(object)container != null 439739"];
9888 [label="container.ContainingModule 439740"];
9889 [label="get\n            {\n                return ContainingPEModule;\n            } 439741"];
9890 [label="ContainingPEModule 439742"];
9891 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 439743"];
9892 [label="s.Kind 439744"];
9893 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439745"];
9894 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 439746"];
9895 [label="return ContainingPEModule; 439747"];
9896 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 439748"];
9897 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 439749"];
9898 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 439750"];
9899 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 439751"];
9900 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 439752"];
9901 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 439753"];
9902 [label="Debug.Assert(symbol is object); 439754"];
9903 [label="symbol.Kind 439755"];
9904 [label="get\n            {\n                return SymbolKind.Method;\n            } 439756"];
9905 [label="return SymbolKind.Method; 439757"];
9906 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 439758"];
9907 [label="isInternal = false; 439759"];
9908 [label="symbol.DeclaredAccessibility 439760"];
9909 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 439761"];
9910 [label="Flags 439762"];
9911 [label="=> (MethodAttributes)_flags 439763"];
9912 [label="(MethodAttributes)_flags 439764"];
9913 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 439765"];
9914 [label="return Accessibility.Public; 439766"];
9915 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 439767"];
9916 [label="symbol.ContainingType 439768"];
9917 [label="=> _containingType 439769"];
9918 [label="_containingType 439770"];
9919 [label="symbol = symbol.ContainingType; 439771"];
9920 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 439772"];
9921 [label="symbol.DeclaredAccessibility 439773"];
9922 [label="Accessibility access = Accessibility.Private; 439774"];
9923 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 439775"];
9924 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 439776"];
9925 [label="return _container as NamedTypeSymbol; 439777"];
9926 [label="return true; 439778"];
9927 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 439779"];
9928 [label="byte? value; 439780"];
9929 [label="param TryGetNullableContext(out byte? value) 439781"];
9930 [label="param TryGetByte(out byte? value) 439782"];
9931 [label="value = null; 439783"];
9932 [label="s.Kind 439784"];
9933 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439785"];
9934 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 439786"];
9935 [label="byte? value; 439787"];
9936 [label="param TryGetByte(out byte? value) 439788"];
9937 [label="return true; 439789"];
9938 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 439790"];
9939 [label="=> defaultType 439791"];
9940 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 439792"];
9941 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 439793"];
9942 [label="_elementNames 439794"];
9943 [label="elementNames.IsDefault 439795"];
9944 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 439796"];
9945 [label="_namesIndex 439797"];
9946 [label="_foundUsableErrorType = false; 439798"];
9947 [label="_foundUsableErrorType 439799"];
9948 [label="param DecodeType(this) 439800"];
9949 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 439801"];
9950 [label="param DecodeNamedType(this) 439802"];
9951 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 439803"];
9952 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 439804"];
9953 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 439805"];
9954 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 439806"];
9955 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 439807"];
9956 [label="DecodeTypeArguments(typeArgs) 439808"];
9957 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 439809"];
9958 [label="param DecodeTypeArguments(this) 439810"];
9959 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 439811"];
9960 [label="return typeArgs; 439812"];
9961 [label="type.ContainingType 439813"];
9962 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 439814"];
9963 [label="return _container as NamedTypeSymbol; 439815"];
9964 [label="NamedTypeSymbol containingType = type.ContainingType; 439816"];
9965 [label="NamedTypeSymbol? decodedContainingType; 439817"];
9966 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 439818"];
9967 [label="decodedContainingType = containingType; 439819"];
9968 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 439820"];
9969 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 439821"];
9970 [label="var typeArgsChanged = typeArgs != decodedArgs; 439822"];
9971 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 439823"];
9972 [label="decodedType.IsTupleType 439824"];
9973 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 439825"];
9974 [label="_ 439826"];
9975 [label="tupleCardinality: out _ 439827"];
9976 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 439828"];
9977 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 439829"];
9978 [label="param IsTupleTypeOfCardinality(this) 439830"];
9979 [label="IsUnboundGenericType 439831"];
9980 [label="get\n            {\n                return false;\n            } 439832"];
9981 [label="return false; 439833"];
9982 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439834"];
9983 [label="ContainingSymbol 439835"];
9984 [label="get\n            {\n                return _container;\n            } 439836"];
9985 [label="return _container; 439837"];
9986 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439838"];
9987 [label=".Kind 439839"];
9988 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 439840"];
9989 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439841"];
9990 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439842"];
9991 [label="ContainingNamespace 439843"];
9992 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 439844"];
9993 [label="get\n            {\n                return _container;\n            } 439845"];
9994 [label="return _container; 439846"];
9995 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439847"];
9996 [label="ContainingNamespace.ContainingNamespace 439848"];
9997 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 439849"];
9998 [label=".IsGlobalNamespace 439850"];
9999 [label="get\n            {\n                return false;\n            } 439851"];
10000 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439852"];
10001 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439853"];
10002 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 439854"];
10003 [label="tupleCardinality = 0; 439855"];
10004 [label="return false; 439856"];
10005 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 439857"];
10006 [label="this.RefKind 439858"];
10007 [label="Debug.Assert(refKind == this.RefKind); 439859"];
10008 [label="this.HasNameInMetadata 439860"];
10009 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 439861"];
10010 [label="_packedFlags.HasNameInMetadata 439862"];
10011 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 439863"];
10012 [label="return (_bits & HasNameInMetadataBit) != 0; 439864"];
10013 [label="return (_bits & HasNameInMetadataBit) != 0; 439865"];
10014 [label="return _packedFlags.HasNameInMetadata; 439866"];
10015 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 439867"];
10016 [label="parameter.RefCustomModifiers 439868"];
10017 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 439869"];
10018 [label="return ImmutableArray<CustomModifier>.Empty; 439870"];
10019 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 439871"];
10020 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 439872"];
10021 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 439873"];
10022 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439874"];
10023 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439875"];
10024 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439876"];
10025 [label="parameter.RefKind 439877"];
10026 [label="if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439878"];
10027 [label="if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439879"];
10028 [label="builder.Add(PEParameterSymbol.Create(\n                        moduleSymbol, this, this.IsMetadataVirtual(), i,\n                        paramInfo[i + 1], nullableContext: this, isReturn: false, out isBadParameter)); 439880"];
10029 [label="if (isBadParameter)\n                    {\n                        makeBad = true;\n                    } 439881"];
10030 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439882"];
10031 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439883"];
10032 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 439884"];
10033 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 439885"];
10034 [label="param AsDynamicIfNoPia(this TypeSymbol type) 439886"];
10035 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 439887"];
10036 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 439888"];
10037 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 439889"];
10038 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 439890"];
10039 [label="type.SpecialType 439891"];
10040 [label="get\n            {\n                return _corTypeId;\n            } 439892"];
10041 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 439893"];
10042 [label="result = null; 439894"];
10043 [label="paramInfo[0].Type = returnType; 439895"];
10044 [label="paramInfo[0].Type = returnType; 439896"];
10045 [label="paramInfo[0].Type 439897"];
10046 [label="this.IsMetadataVirtual() 439898"];
10047 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 439899"];
10048 [label="=> HasFlag(MethodAttributes.Virtual) 439900"];
10049 [label="MethodAttributes.Virtual 439901"];
10050 [label="HasFlag(MethodAttributes.Virtual) 439902"];
10051 [label="param HasFlag(MethodAttributes flag) 439903"];
10052 [label="param HasFlag(this) 439904"];
10053 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439905"];
10054 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439906"];
10055 [label="return ((ushort)flag & _flags) != 0; 439907"];
10056 [label="param Create(bool isContainingSymbolVirtual) 439908"];
10057 [label="param Create(bool isReturn) 439909"];
10058 [label="param Create(out bool isBad) 439910"];
10059 [label="param Create(bool isContainingSymbolVirtual) 439911"];
10060 [label="param Create(bool isReturn) 439912"];
10061 [label="param Create(out bool isBad) 439913"];
10062 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 439914"];
10063 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 439915"];
10064 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 439916"];
10065 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 439917"];
10066 [label="typeSymbol.IsNullableType() 439918"];
10067 [label="param IsNullableType(this TypeSymbol type) 439919"];
10068 [label="type.OriginalDefinition 439920"];
10069 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439921"];
10070 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439922"];
10071 [label="type.OriginalDefinition.SpecialType 439923"];
10072 [label="get\n            {\n                return _corTypeId;\n            } 439924"];
10073 [label="var a1 = defaultType is null; 439925"];
10074 [label="!a1 439926"];
10075 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 439927"];
10076 [label="defaultType.IsNullableType() 439928"];
10077 [label="param IsNullableType(this TypeSymbol type) 439929"];
10078 [label="type.OriginalDefinition 439930"];
10079 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 439931"];
10080 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 439932"];
10081 [label="type.OriginalDefinition.SpecialType 439933"];
10082 [label="get\n            {\n                return _corTypeId;\n            } 439934"];
10083 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 439935"];
10084 [label="Debug.Assert(a1 || a2 != true || a3); 439936"];
10085 [label="Debug.Assert(a1 || a2 != true || a3); 439937"];
10086 [label="Debug.Assert(extensions != null); 439938"];
10087 [label="Debug.Assert(extensions != null); 439939"];
10088 [label="PEParameterSymbol parameter = customModifiers.IsDefaultOrEmpty && refCustomModifiers.IsDefaultOrEmpty\n                ? new PEParameterSymbol(moduleSymbol, containingSymbol, ordinal, isByRef, typeWithModifiers, handle, nullableContext, 0, out isBad)\n                : new PEParameterSymbolWithCustomModifiers(moduleSymbol, containingSymbol, ordinal, isByRef, refCustomModifiers, typeWithModifiers, handle, nullableContext, out isBad); 439940"];
10089 [label="param PEParameterSymbol(out bool isBad) 439941"];
10090 [label="_containingSymbol 439942"];
10091 [label="_moduleSymbol 439943"];
10092 [label="_ordinal 439944"];
10093 [label="Debug.Assert((object)moduleSymbol != null); 439945"];
10094 [label="Debug.Assert((object)containingSymbol != null); 439946"];
10095 [label="Debug.Assert(ordinal >= 0); 439947"];
10096 [label="typeWithAnnotations.HasType 439948"];
10097 [label="=> !(DefaultType is null) 439949"];
10098 [label="DefaultType is null 439950"];
10099 [label="!(DefaultType is null) 439951"];
10100 [label="Debug.Assert(typeWithAnnotations.HasType); 439952"];
10101 [label="isBad = false; 439953"];
10102 [label="nullableContext.GetNullableContextValue() 439954"];
10103 [label="param TryGetNullableContext(out byte? value) 439955"];
10104 [label="param TryGetByte(out byte? value) 439956"];
10105 [label="return true; 439957"];
10106 [label="byte? value = nullableContext.GetNullableContextValue(); 439958"];
10107 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 439959"];
10108 [label="this.RefKind 439960"];
10109 [label="Debug.Assert(refKind == this.RefKind); 439961"];
10110 [label="this.HasNameInMetadata 439962"];
10111 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 439963"];
10112 [label="_packedFlags.HasNameInMetadata 439964"];
10113 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 439965"];
10114 [label="return (_bits & HasNameInMetadataBit) != 0; 439966"];
10115 [label="return (_bits & HasNameInMetadataBit) != 0; 439967"];
10116 [label="return _packedFlags.HasNameInMetadata; 439968"];
10117 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 439969"];
10118 [label="parameter.RefCustomModifiers 439970"];
10119 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 439971"];
10120 [label="return ImmutableArray<CustomModifier>.Empty; 439972"];
10121 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 439973"];
10122 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 439974"];
10123 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 439975"];
10124 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439976"];
10125 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 439977"];
10126 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 439978"];
10127 [label="parameter.RefKind 439979"];
10128 [label="get\n            {\n                return _packedFlags.RefKind;\n            } 439980"];
10129 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439981"];
10130 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439982"];
10131 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 439983"];
10132 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 439984"];
10133 [label="ReturnParam 439985"];
10134 [label="=> defaultType 439986"];
10135 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 439987"];
10136 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 439988"];
10137 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 439989"];
10138 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 439990"];
10139 [label="param BitsAreUnsetOrSame(int bits) 439991"];
10140 [label="param BitsAreUnsetOrSame(int mask) 439992"];
10141 [label="return (bits & mask) == 0 || (bits & mask) == mask; 439993"];
10142 [label="return (bits & mask) == 0 || (bits & mask) == mask; 439994"];
10143 [label="_packedFlags.MethodKind 439995"];
10144 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 439996"];
10145 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 439997"];
10146 [label="return _packedFlags.MethodKind; 439998"];
10147 [label="MethodKind methodKind = method.MethodKind; 439999"];
10148 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 440000"];
10149 [label="method.Arity 440001"];
10150 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 440002"];
10151 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440003"];
10152 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440004"];
10153 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440005"];
10154 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440006"];
10155 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440007"];
10156 [label="method.IsVirtual 440008"];
10157 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 440009"];
10158 [label="this.IsMetadataVirtual() 440010"];
10159 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 440011"];
10160 [label="=> HasFlag(MethodAttributes.Virtual) 440012"];
10161 [label="MethodAttributes.Virtual 440013"];
10162 [label="HasFlag(MethodAttributes.Virtual) 440014"];
10163 [label="param HasFlag(MethodAttributes flag) 440015"];
10164 [label="param HasFlag(this) 440016"];
10165 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440017"];
10166 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440018"];
10167 [label="return ((ushort)flag & _flags) != 0; 440019"];
10168 [label="this.IsMetadataVirtual() && !this.IsDestructor 440020"];
10169 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 440021"];
10170 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 440022"];
10171 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 440023"];
10172 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440024"];
10173 [label="method.IsOverride 440025"];
10174 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 440026"];
10175 [label="this._containingType.IsInterface 440027"];
10176 [label="get\n            {\n                return _flags.IsInterface();\n            } 440028"];
10177 [label="return _flags.IsInterface(); 440029"];
10178 [label="this.IsMetadataVirtual() 440030"];
10179 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 440031"];
10180 [label="=> HasFlag(MethodAttributes.Virtual) 440032"];
10181 [label="MethodAttributes.Virtual 440033"];
10182 [label="HasFlag(MethodAttributes.Virtual) 440034"];
10183 [label="param HasFlag(MethodAttributes flag) 440035"];
10184 [label="param HasFlag(this) 440036"];
10185 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440037"];
10186 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440038"];
10187 [label="return ((ushort)flag & _flags) != 0; 440039"];
10188 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 440040"];
10189 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 440041"];
10190 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 440042"];
10191 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440043"];
10192 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440044"];
10193 [label="method.IsAbstract 440045"];
10194 [label="=> HasFlag(MethodAttributes.Abstract) 440046"];
10195 [label="MethodAttributes.Abstract 440047"];
10196 [label="HasFlag(MethodAttributes.Abstract) 440048"];
10197 [label="param HasFlag(MethodAttributes flag) 440049"];
10198 [label="param HasFlag(this) 440050"];
10199 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440051"];
10200 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440052"];
10201 [label="return ((ushort)flag & _flags) != 0; 440053"];
10202 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440054"];
10203 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440055"];
10204 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 440056"];
10205 [label="param GetParameters(this) 440057"];
10206 [label="param IsByRefMethod(this) 440058"];
10207 [label="param GetReturnType(this) 440059"];
10208 [label="param MatchTypeToTypeId(this) 440060"];
10209 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 440061"];
10210 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 440062"];
10211 [label="param MatchTypeToTypeId(this) 440063"];
10212 [label="param IsByRefParam(this) 440064"];
10213 [label="param GetParamType(this) 440065"];
10214 [label="return false; 440066"];
10215 [label="if (!comparer.MatchMethodSignature(method, descriptor.Signature))\n                            {\n                                continue;\n                            } 440067"];
10216 [label="return result; 440068"];
10217 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 440069"];
10218 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 440070"];
10219 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 440071"];
10220 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 440072"];
10221 [label="return _lazyWellKnownTypeMembers[(int)member]; 440073"];
10222 [label="if ((object)memberSymbol != null)\n            {\n                diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType();\n                if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                }\n            }\n            else if (!isOptional)\n            {\n                // member is missing\n                MemberDescriptor memberDescriptor = WellKnownMembers.GetDescriptor(member);\n                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember, memberDescriptor.DeclaringTypeMetadataName, memberDescriptor.Name);\n            }\n            else\n            {\n                diagnosticInfo = null;\n            } 440074"];
10223 [label="if ((object)memberSymbol != null)\n            {\n                diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType();\n                if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                }\n            }\n            else if (!isOptional)\n            {\n                // member is missing\n                MemberDescriptor memberDescriptor = WellKnownMembers.GetDescriptor(member);\n                diagnosticInfo = new CSDiagnosticInfo(ErrorCode.ERR_MissingPredefinedMember, memberDescriptor.DeclaringTypeMetadataName, memberDescriptor.Name);\n            }\n            else\n            {\n                diagnosticInfo = null;\n            } 440075"];
10224 [label="memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType() 440076"];
10225 [label="param GetUseSiteDiagnosticForSymbolOrContainingType(this) 440077"];
10226 [label="this.GetUseSiteDiagnostic() 440078"];
10227 [label="param GetUseSiteDiagnostic(this) 440079"];
10228 [label="_packedFlags.IsUseSiteDiagnosticPopulated 440080"];
10229 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 440081"];
10230 [label="_bits & IsUseSiteDiagnosticPopulatedBit 440082"];
10231 [label="0 440083"];
10232 [label="(_bits & IsUseSiteDiagnosticPopulatedBit) != 0 440084"];
10233 [label="if (!_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                EnsureTypeParametersAreLoaded(ref result);\n                if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                }\n\n                return InitializeUseSiteDiagnostic(result);\n            } 440085"];
10234 [label="DiagnosticInfo result = null; 440086"];
10235 [label="CalculateUseSiteDiagnostic(ref result); 440087"];
10236 [label="CalculateUseSiteDiagnostic(ref result) 440088"];
10237 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 440089"];
10238 [label="param CalculateUseSiteDiagnostic(this) 440090"];
10239 [label="this.IsDefinition 440091"];
10240 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 440092"];
10241 [label="get\n            {\n                return this.OriginalDefinition;\n            } 440093"];
10242 [label="this.OriginalDefinition 440094"];
10243 [label="get\n            {\n                return this;\n            } 440095"];
10244 [label="return this; 440096"];
10245 [label="return this.OriginalDefinition; 440097"];
10246 [label="Debug.Assert(this.IsDefinition); 440098"];
10247 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440099"];
10248 [label="this.ReturnTypeWithAnnotations 440100"];
10249 [label="=> Signature.ReturnParam.TypeWithAnnotations 440101"];
10250 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440102"];
10251 [label="IsInitOnly 440103"];
10252 [label="get\n            {\n                if (!_packedFlags.IsInitOnlyPopulated)\n                {\n                    bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier();\n                    _packedFlags.InitializeIsInitOnly(isInitOnly);\n                }\n                return _packedFlags.IsInitOnly;\n            } 440104"];
10253 [label="_packedFlags.IsInitOnlyPopulated 440105"];
10254 [label="=> (_bits & IsInitOnlyPopulatedBit) != 0 440106"];
10255 [label="_bits & IsInitOnlyPopulatedBit 440107"];
10256 [label="0 440108"];
10257 [label="(_bits & IsInitOnlyPopulatedBit) != 0 440109"];
10258 [label="if (!_packedFlags.IsInitOnlyPopulated)\n                {\n                    bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier();\n                    _packedFlags.InitializeIsInitOnly(isInitOnly);\n                } 440110"];
10259 [label="this.IsStatic 440111"];
10260 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 440112"];
10261 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 440113"];
10262 [label="this.MethodKind 440114"];
10263 [label="_packedFlags.MethodKind 440115"];
10264 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 440116"];
10265 [label="return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask); 440117"];
10266 [label="return _packedFlags.MethodKind; 440118"];
10267 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 440119"];
10268 [label="bool isInitOnly = !this.IsStatic &&\n                        this.MethodKind == MethodKind.PropertySet &&\n                        ReturnTypeWithAnnotations.CustomModifiers.HasIsExternalInitModifier(); 440120"];
10269 [label="_packedFlags.InitializeIsInitOnly(isInitOnly); 440121"];
10270 [label="_packedFlags.InitializeIsInitOnly(isInitOnly) 440122"];
10271 [label="param InitializeIsInitOnly(bool isInitOnly) 440123"];
10272 [label="param InitializeIsInitOnly(this) 440124"];
10273 [label="isInitOnly 440125"];
10274 [label="int bitsToSet = (isInitOnly ? IsInitOnlyBit : 0) | IsInitOnlyPopulatedBit; 440126"];
10275 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 440127"];
10276 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 440128"];
10277 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 440129"];
10278 [label="param BitsAreUnsetOrSame(int bits) 440130"];
10279 [label="param BitsAreUnsetOrSame(int mask) 440131"];
10280 [label="return (bits & mask) == 0 || (bits & mask) == mask; 440132"];
10281 [label="return (bits & mask) == 0 || (bits & mask) == mask; 440133"];
10282 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 440134"];
10283 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 440135"];
10284 [label="ThreadSafeFlagOperations.Set(ref _bits, bitsToSet); 440136"];
10285 [label="_packedFlags.InitializeIsInitOnly(isInitOnly); 440137"];
10286 [label="_packedFlags.IsInitOnly 440138"];
10287 [label="=> (_bits & IsInitOnlyBit) != 0 440139"];
10288 [label="_bits & IsInitOnlyBit 440140"];
10289 [label="0 440141"];
10290 [label="(_bits & IsInitOnlyBit) != 0 440142"];
10291 [label="return _packedFlags.IsInitOnly; 440143"];
10292 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440144"];
10293 [label="DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) 440145"];
10294 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 440146"];
10295 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 440147"];
10296 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 440148"];
10297 [label="param DeriveUseSiteDiagnosticFromType(this) 440149"];
10298 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 440150"];
10299 [label="type.Type 440151"];
10300 [label="=> _extensions?.GetResolvedType(DefaultType) 440152"];
10301 [label="=> defaultType 440153"];
10302 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 440154"];
10303 [label="DeriveUseSiteDiagnosticFromType(ref result, type.Type) 440155"];
10304 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 440156"];
10305 [label="param DeriveUseSiteDiagnosticFromType(TypeSymbol type) 440157"];
10306 [label="param DeriveUseSiteDiagnosticFromType(this) 440158"];
10307 [label="type.GetUseSiteDiagnostic() 440159"];
10308 [label="param GetUseSiteDiagnostic(this) 440160"];
10309 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 440161"];
10310 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 440162"];
10311 [label="GetUseSiteDiagnosticImpl() 440163"];
10312 [label="param GetUseSiteDiagnosticImpl(this) 440164"];
10313 [label="DiagnosticInfo diagnostic = null; 440165"];
10314 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 440166"];
10315 [label="CalculateUseSiteDiagnostic() 440167"];
10316 [label="param CalculateUseSiteDiagnostic(this) 440168"];
10317 [label="DiagnosticInfo result = null; 440169"];
10318 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 440170"];
10319 [label="DeriveUseSiteDiagnosticFromBase() 440171"];
10320 [label="param DeriveUseSiteDiagnosticFromBase(this) 440172"];
10321 [label="this.BaseTypeNoUseSiteDiagnostics 440173"];
10322 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 440174"];
10323 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 440175"];
10324 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 440176"];
10325 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 440177"];
10326 [label="MakeAcyclicBaseType() 440178"];
10327 [label="param MakeAcyclicBaseType(this) 440179"];
10328 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 440180"];
10329 [label="GetDeclaredBaseType(null) 440181"];
10330 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440182"];
10331 [label="param GetDeclaredBaseType(this) 440183"];
10332 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 440184"];
10333 [label="GetDeclaredBaseType(skipTransformsIfNecessary: false) 440185"];
10334 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440186"];
10335 [label="param GetDeclaredBaseType(this) 440187"];
10336 [label="s.Kind 440188"];
10337 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440189"];
10338 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440190"];
10339 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 440191"];
10340 [label="Debug.Assert((object)moduleSymbol != null); 440192"];
10341 [label="var baseType = MakeDeclaredBaseType(); 440193"];
10342 [label="if (baseType is object)\n                {\n                    if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    }\n\n                    var moduleSymbol = ContainingPEModule;\n                    TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol);\n                    decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol);\n                    decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol);\n                    baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n                } 440194"];
10343 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 440195"];
10344 [label="ContainingPEModule 440196"];
10345 [label="s.Kind 440197"];
10346 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440198"];
10347 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440199"];
10348 [label="var moduleSymbol = ContainingPEModule; 440200"];
10349 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 440201"];
10350 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 440202"];
10351 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 440203"];
10352 [label="TypeSymbol decodedType = DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol); 440204"];
10353 [label="DynamicTypeDecoder.TransformType(baseType, 0, _handle, moduleSymbol) 440205"];
10354 [label="param TransformType(TypeSymbol metadataType) 440206"];
10355 [label="param TransformType(int targetSymbolCustomModifierCount) 440207"];
10356 [label="param TransformType(EntityHandle targetSymbolToken) 440208"];
10357 [label="param TransformType(PEModuleSymbol containingModule) 440209"];
10358 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 440210"];
10359 [label="Debug.Assert((object)metadataType != null); 440211"];
10360 [label="Debug.Assert((object)metadataType != null); 440212"];
10361 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 440213"];
10362 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 440214"];
10363 [label="decodedType = NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol); 440215"];
10364 [label="NativeIntegerTypeDecoder.TransformType(decodedType, _handle, moduleSymbol) 440216"];
10365 [label="param TransformType(TypeSymbol type) 440217"];
10366 [label="param TransformType(EntityHandle handle) 440218"];
10367 [label="param TransformType(PEModuleSymbol containingModule) 440219"];
10368 [label="return _module; 440220"];
10369 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 440221"];
10370 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 440222"];
10371 [label="decodedType = TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol); 440223"];
10372 [label="TupleTypeDecoder.DecodeTupleTypesIfApplicable(decodedType, _handle, moduleSymbol) 440224"];
10373 [label="param DecodeTupleTypesIfApplicable(TypeSymbol metadataType) 440225"];
10374 [label="param DecodeTupleTypesIfApplicable(EntityHandle targetHandle) 440226"];
10375 [label="param DecodeTupleTypesIfApplicable(PEModuleSymbol containingModule) 440227"];
10376 [label="ImmutableArray<string?> elementNames; 440228"];
10377 [label="elementNames 440229"];
10378 [label="containingModule\n                .Module 440230"];
10379 [label="get\n            {\n                return _module;\n            } 440231"];
10380 [label="return _module; 440232"];
10381 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 440233"];
10382 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 440234"];
10383 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 440235"];
10384 [label="var hasTupleElementNamesAttribute = containingModule\n                .Module\n                .HasTupleElementNamesAttribute(targetHandle, out elementNames); 440236"];
10385 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 440237"];
10386 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 440238"];
10387 [label="return DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute); 440239"];
10388 [label="DecodeTupleTypesInternal(metadataType, elementNames, hasTupleElementNamesAttribute) 440240"];
10389 [label="param DecodeTupleTypesInternal(TypeSymbol metadataType) 440241"];
10390 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 440242"];
10391 [label="param DecodeTupleTypesInternal(bool hasTupleElementNamesAttribute) 440243"];
10392 [label="RoslynDebug.AssertNotNull(metadataType); 440244"];
10393 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 440245"];
10394 [label="_elementNames 440246"];
10395 [label="elementNames.IsDefault 440247"];
10396 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 440248"];
10397 [label="_namesIndex 440249"];
10398 [label="_foundUsableErrorType = false; 440250"];
10399 [label="_foundUsableErrorType 440251"];
10400 [label="param DecodeType(this) 440252"];
10401 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440253"];
10402 [label="param DecodeNamedType(this) 440254"];
10403 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 440255"];
10404 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 440256"];
10405 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 440257"];
10406 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 440258"];
10407 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 440259"];
10408 [label="DecodeTypeArguments(typeArgs) 440260"];
10409 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 440261"];
10410 [label="param DecodeTypeArguments(this) 440262"];
10411 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 440263"];
10412 [label="return typeArgs; 440264"];
10413 [label="type.ContainingType 440265"];
10414 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 440266"];
10415 [label="return _container as NamedTypeSymbol; 440267"];
10416 [label="NamedTypeSymbol containingType = type.ContainingType; 440268"];
10417 [label="NamedTypeSymbol? decodedContainingType; 440269"];
10418 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 440270"];
10419 [label="decodedContainingType = containingType; 440271"];
10420 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440272"];
10421 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440273"];
10422 [label="var typeArgsChanged = typeArgs != decodedArgs; 440274"];
10423 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 440275"];
10424 [label="decodedType.IsTupleType 440276"];
10425 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 440277"];
10426 [label="_ 440278"];
10427 [label="tupleCardinality: out _ 440279"];
10428 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 440280"];
10429 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 440281"];
10430 [label="param IsTupleTypeOfCardinality(this) 440282"];
10431 [label="IsUnboundGenericType 440283"];
10432 [label="get\n            {\n                return false;\n            } 440284"];
10433 [label="return false; 440285"];
10434 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440286"];
10435 [label="ContainingSymbol 440287"];
10436 [label="get\n            {\n                return _container;\n            } 440288"];
10437 [label="return _container; 440289"];
10438 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440290"];
10439 [label=".Kind 440291"];
10440 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440292"];
10441 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440293"];
10442 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440294"];
10443 [label="ContainingNamespace 440295"];
10444 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440296"];
10445 [label="get\n            {\n                return _container;\n            } 440297"];
10446 [label="return _container; 440298"];
10447 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440299"];
10448 [label="ContainingNamespace.ContainingNamespace 440300"];
10449 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440301"];
10450 [label=".IsGlobalNamespace 440302"];
10451 [label="get\n            {\n                return true;\n            } 440303"];
10452 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440304"];
10453 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440305"];
10454 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440306"];
10455 [label="Name 440307"];
10456 [label="get\n            {\n                return _name;\n            } 440308"];
10457 [label="return _name; 440309"];
10458 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440310"];
10459 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440311"];
10460 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440312"];
10461 [label="tupleCardinality = 0; 440313"];
10462 [label="return false; 440314"];
10463 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 440315"];
10464 [label="return decoded; 440316"];
10465 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440317"];
10466 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440318"];
10467 [label="TypeWithAnnotations.Create(decodedType) 440319"];
10468 [label="param Create(TypeSymbol typeSymbol) 440320"];
10469 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 440321"];
10470 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 440322"];
10471 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 440323"];
10472 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 440324"];
10473 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 440325"];
10474 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 440326"];
10475 [label="typeSymbol.IsNullableType() 440327"];
10476 [label="param IsNullableType(this TypeSymbol type) 440328"];
10477 [label="type.OriginalDefinition 440329"];
10478 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440330"];
10479 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440331"];
10480 [label="type.OriginalDefinition.SpecialType 440332"];
10481 [label="get\n            {\n                return _corTypeId;\n            } 440333"];
10482 [label="var a1 = defaultType is null; 440334"];
10483 [label="!a1 440335"];
10484 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 440336"];
10485 [label="defaultType.IsNullableType() 440337"];
10486 [label="param IsNullableType(this TypeSymbol type) 440338"];
10487 [label="type.OriginalDefinition 440339"];
10488 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440340"];
10489 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440341"];
10490 [label="type.OriginalDefinition.SpecialType 440342"];
10491 [label="get\n            {\n                return _corTypeId;\n            } 440343"];
10492 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 440344"];
10493 [label="Debug.Assert(a1 || a2 != true || a3); 440345"];
10494 [label="Debug.Assert(a1 || a2 != true || a3); 440346"];
10495 [label="Debug.Assert(extensions != null); 440347"];
10496 [label="Debug.Assert(extensions != null); 440348"];
10497 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440349"];
10498 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440350"];
10499 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440351"];
10500 [label="baseType = (NamedTypeSymbol)NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type; 440352"];
10501 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this) 440353"];
10502 [label="param TransformType(TypeWithAnnotations metadataType) 440354"];
10503 [label="param TransformType(EntityHandle targetSymbolToken) 440355"];
10504 [label="param TransformType(PEModuleSymbol containingModule) 440356"];
10505 [label="param TransformType(Symbol accessSymbol) 440357"];
10506 [label="param TransformType(Symbol nullableContext) 440358"];
10507 [label="metadataType.HasType 440359"];
10508 [label="=> !(DefaultType is null) 440360"];
10509 [label="DefaultType is null 440361"];
10510 [label="!(DefaultType is null) 440362"];
10511 [label="Debug.Assert(metadataType.HasType); 440363"];
10512 [label="accessSymbol.IsDefinition 440364"];
10513 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 440365"];
10514 [label="Debug.Assert(accessSymbol.IsDefinition); 440366"];
10515 [label="accessSymbol.ContainingModule 440367"];
10516 [label="get\n            {\n                return ContainingPEModule;\n            } 440368"];
10517 [label="ContainingPEModule 440369"];
10518 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 440370"];
10519 [label="Symbol s = _container; 440371"];
10520 [label="s.Kind 440372"];
10521 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440373"];
10522 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440374"];
10523 [label="return ContainingPEModule; 440375"];
10524 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 440376"];
10525 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440377"];
10526 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440378"];
10527 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 440379"];
10528 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 440380"];
10529 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 440381"];
10530 [label="Debug.Assert(symbol is object); 440382"];
10531 [label="symbol.Kind 440383"];
10532 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440384"];
10533 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 440385"];
10534 [label="isInternal = false; 440386"];
10535 [label="symbol.DeclaredAccessibility 440387"];
10536 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 440388"];
10537 [label="Accessibility access = Accessibility.Private; 440389"];
10538 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 440390"];
10539 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 440391"];
10540 [label="symbol.ContainingType 440392"];
10541 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 440393"];
10542 [label="return _container as NamedTypeSymbol; 440394"];
10543 [label="symbol = symbol.ContainingType; 440395"];
10544 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 440396"];
10545 [label="return true; 440397"];
10546 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440398"];
10547 [label="return _module; 440399"];
10548 [label="byte? value; 440400"];
10549 [label="param TryGetByte(out byte? value) 440401"];
10550 [label="value = null; 440402"];
10551 [label="s.Kind 440403"];
10552 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440404"];
10553 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440405"];
10554 [label="param GetNullableContextValue(this) 440406"];
10555 [label="param GetLocalNullableContextValue(this) 440407"];
10556 [label="get\n            {\n                return _moduleSymbol;\n            } 440408"];
10557 [label="return _moduleSymbol; 440409"];
10558 [label="param GetLocalNullableContextValue(this) 440410"];
10559 [label="get\n            {\n                return _assemblySymbol;\n            } 440411"];
10560 [label="return _assemblySymbol; 440412"];
10561 [label="param GetLocalNullableContextValue(this) 440413"];
10562 [label="get\n            {\n                return null;\n            } 440414"];
10563 [label="return metadataType; 440415"];
10564 [label="NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(decodedType), _handle, moduleSymbol, accessSymbol: this, nullableContext: this).Type 440416"];
10565 [label="=> _extensions?.GetResolvedType(DefaultType) 440417"];
10566 [label="=> defaultType 440418"];
10567 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 440419"];
10568 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 440420"];
10569 [label="Interlocked.CompareExchange(ref _lazyDeclaredBaseType, baseType, ErrorTypeSymbol.UnknownResultType); 440421"];
10570 [label="return _lazyDeclaredBaseType; 440422"];
10571 [label="return GetDeclaredBaseType(skipTransformsIfNecessary: false); 440423"];
10572 [label="NamedTypeSymbol declaredBase = GetDeclaredBaseType(null); 440424"];
10573 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 440425"];
10574 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 440426"];
10575 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 440427"];
10576 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return CyclicInheritanceError(this, declaredBase);\n            } 440428"];
10577 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 440429"];
10578 [label="param TypeDependsOn(NamedTypeSymbol depends) 440430"];
10579 [label="param TypeDependsOn(NamedTypeSymbol on) 440431"];
10580 [label="Debug.Assert((object)depends != null); 440432"];
10581 [label="Debug.Assert((object)depends != null); 440433"];
10582 [label="Debug.Assert((object)on != null); 440434"];
10583 [label="Debug.Assert((object)on != null); 440435"];
10584 [label="on.IsDefinition 440436"];
10585 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 440437"];
10586 [label="Debug.Assert(on.IsDefinition); 440438"];
10587 [label="var hs = PooledHashSet<Symbol>.GetInstance(); 440439"];
10588 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 440440"];
10589 [label="depends.DeclaringCompilation 440441"];
10590 [label="get { return null; } 440442"];
10591 [label="return null; 440443"];
10592 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 440444"];
10593 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 440445"];
10594 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs) 440446"];
10595 [label="param TypeDependsClosure(NamedTypeSymbol type) 440447"];
10596 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 440448"];
10597 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 440449"];
10598 [label="if ((object)type == null)\n            {\n                return;\n            } 440450"];
10599 [label="if ((object)type == null)\n            {\n                return;\n            } 440451"];
10600 [label="type.OriginalDefinition 440452"];
10601 [label="get\n            {\n                return this;\n            } 440453"];
10602 [label="type = type.OriginalDefinition; 440454"];
10603 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 440455"];
10604 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 440456"];
10605 [label="if (partialClosure.Add(type))\n            {\n                if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                }\n\n                // containment is interesting only for the current compilation\n                if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                }\n            } 440457"];
10606 [label="param GetHashCode(this) 440458"];
10607 [label="this.SpecialType 440459"];
10608 [label="get\n            {\n                return _corTypeId;\n            } 440460"];
10609 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 440461"];
10610 [label="OriginalDefinition 440462"];
10611 [label="get\n            {\n                return this;\n            } 440463"];
10612 [label="return RuntimeHelpers.GetHashCode(OriginalDefinition); 440464"];
10613 [label="type.IsInterface 440465"];
10614 [label="get\n            {\n                return _flags.IsInterface();\n            } 440466"];
10615 [label="return _flags.IsInterface(); 440467"];
10616 [label="if (type.IsInterface)\n                {\n                    foreach (var bt in type.GetDeclaredInterfaces(null))\n                    {\n                        TypeDependsClosure(bt, currentCompilation, partialClosure);\n                    }\n                }\n                else\n                {\n                    TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure);\n                } 440468"];
10617 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440469"];
10618 [label="type.GetDeclaredBaseType(null) 440470"];
10619 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440471"];
10620 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440472"];
10621 [label="s.Kind 440473"];
10622 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440474"];
10623 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440475"];
10624 [label="Debug.Assert((object)moduleSymbol != null); 440476"];
10625 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 440477"];
10626 [label="param TransformType(int targetSymbolCustomModifierCount) 440478"];
10627 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 440479"];
10628 [label="Debug.Assert((object)metadataType != null); 440480"];
10629 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 440481"];
10630 [label="param DecodeTupleTypesInternal(ImmutableArray<string?> elementNames) 440482"];
10631 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 440483"];
10632 [label="_elementNames 440484"];
10633 [label="elementNames.IsDefault 440485"];
10634 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 440486"];
10635 [label="_namesIndex 440487"];
10636 [label="_foundUsableErrorType = false; 440488"];
10637 [label="_foundUsableErrorType 440489"];
10638 [label="param DecodeType(this) 440490"];
10639 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440491"];
10640 [label="param DecodeNamedType(this) 440492"];
10641 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 440493"];
10642 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 440494"];
10643 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 440495"];
10644 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 440496"];
10645 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 440497"];
10646 [label="DecodeTypeArguments(typeArgs) 440498"];
10647 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 440499"];
10648 [label="param DecodeTypeArguments(this) 440500"];
10649 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 440501"];
10650 [label="return typeArgs; 440502"];
10651 [label="type.ContainingType 440503"];
10652 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 440504"];
10653 [label="return _container as NamedTypeSymbol; 440505"];
10654 [label="NamedTypeSymbol containingType = type.ContainingType; 440506"];
10655 [label="NamedTypeSymbol? decodedContainingType; 440507"];
10656 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 440508"];
10657 [label="decodedContainingType = containingType; 440509"];
10658 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440510"];
10659 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440511"];
10660 [label="var typeArgsChanged = typeArgs != decodedArgs; 440512"];
10661 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 440513"];
10662 [label="decodedType.IsTupleType 440514"];
10663 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 440515"];
10664 [label="_ 440516"];
10665 [label="tupleCardinality: out _ 440517"];
10666 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 440518"];
10667 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 440519"];
10668 [label="param IsTupleTypeOfCardinality(this) 440520"];
10669 [label="IsUnboundGenericType 440521"];
10670 [label="get\n            {\n                return false;\n            } 440522"];
10671 [label="return false; 440523"];
10672 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440524"];
10673 [label="ContainingSymbol 440525"];
10674 [label="get\n            {\n                return _container;\n            } 440526"];
10675 [label="return _container; 440527"];
10676 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440528"];
10677 [label=".Kind 440529"];
10678 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440530"];
10679 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440531"];
10680 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440532"];
10681 [label="ContainingNamespace 440533"];
10682 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440534"];
10683 [label="get\n            {\n                return _container;\n            } 440535"];
10684 [label="return _container; 440536"];
10685 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440537"];
10686 [label="ContainingNamespace.ContainingNamespace 440538"];
10687 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440539"];
10688 [label=".IsGlobalNamespace 440540"];
10689 [label="get\n            {\n                return true;\n            } 440541"];
10690 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440542"];
10691 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440543"];
10692 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440544"];
10693 [label="Name 440545"];
10694 [label="get\n            {\n                return _name;\n            } 440546"];
10695 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440547"];
10696 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440548"];
10697 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440549"];
10698 [label="tupleCardinality = 0; 440550"];
10699 [label="return false; 440551"];
10700 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 440552"];
10701 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 440553"];
10702 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 440554"];
10703 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 440555"];
10704 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 440556"];
10705 [label="typeSymbol.IsNullableType() 440557"];
10706 [label="param IsNullableType(this TypeSymbol type) 440558"];
10707 [label="type.OriginalDefinition 440559"];
10708 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440560"];
10709 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440561"];
10710 [label="type.OriginalDefinition.SpecialType 440562"];
10711 [label="get\n            {\n                return _corTypeId;\n            } 440563"];
10712 [label="var a1 = defaultType is null; 440564"];
10713 [label="!a1 440565"];
10714 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 440566"];
10715 [label="defaultType.IsNullableType() 440567"];
10716 [label="param IsNullableType(this TypeSymbol type) 440568"];
10717 [label="type.OriginalDefinition 440569"];
10718 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440570"];
10719 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440571"];
10720 [label="type.OriginalDefinition.SpecialType 440572"];
10721 [label="get\n            {\n                return _corTypeId;\n            } 440573"];
10722 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 440574"];
10723 [label="Debug.Assert(a1 || a2 != true || a3); 440575"];
10724 [label="Debug.Assert(a1 || a2 != true || a3); 440576"];
10725 [label="Debug.Assert(extensions != null); 440577"];
10726 [label="Debug.Assert(extensions != null); 440578"];
10727 [label="param TransformType(Symbol accessSymbol) 440579"];
10728 [label="metadataType.HasType 440580"];
10729 [label="=> !(DefaultType is null) 440581"];
10730 [label="DefaultType is null 440582"];
10731 [label="!(DefaultType is null) 440583"];
10732 [label="Debug.Assert(metadataType.HasType); 440584"];
10733 [label="accessSymbol.IsDefinition 440585"];
10734 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 440586"];
10735 [label="Debug.Assert(accessSymbol.IsDefinition); 440587"];
10736 [label="accessSymbol.ContainingModule 440588"];
10737 [label="get\n            {\n                return ContainingPEModule;\n            } 440589"];
10738 [label="ContainingPEModule 440590"];
10739 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 440591"];
10740 [label="s.Kind 440592"];
10741 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440593"];
10742 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440594"];
10743 [label="return ContainingPEModule; 440595"];
10744 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 440596"];
10745 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440597"];
10746 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440598"];
10747 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 440599"];
10748 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 440600"];
10749 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 440601"];
10750 [label="Debug.Assert(symbol is object); 440602"];
10751 [label="symbol.Kind 440603"];
10752 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440604"];
10753 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 440605"];
10754 [label="isInternal = false; 440606"];
10755 [label="symbol.DeclaredAccessibility 440607"];
10756 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 440608"];
10757 [label="Accessibility access = Accessibility.Private; 440609"];
10758 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 440610"];
10759 [label="symbol.ContainingType 440611"];
10760 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 440612"];
10761 [label="return _container as NamedTypeSymbol; 440613"];
10762 [label="symbol = symbol.ContainingType; 440614"];
10763 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 440615"];
10764 [label="return true; 440616"];
10765 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440617"];
10766 [label="param TryGetByte(out byte? value) 440618"];
10767 [label="value = null; 440619"];
10768 [label="s.Kind 440620"];
10769 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440621"];
10770 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440622"];
10771 [label="param GetNullableContextValue(this) 440623"];
10772 [label="param GetLocalNullableContextValue(this) 440624"];
10773 [label="get\n            {\n                return _moduleSymbol;\n            } 440625"];
10774 [label="return _moduleSymbol; 440626"];
10775 [label="param GetLocalNullableContextValue(this) 440627"];
10776 [label="get\n            {\n                return _assemblySymbol;\n            } 440628"];
10777 [label="return _assemblySymbol; 440629"];
10778 [label="param GetLocalNullableContextValue(this) 440630"];
10779 [label="get\n            {\n                return null;\n            } 440631"];
10780 [label="=> defaultType 440632"];
10781 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440633"];
10782 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440634"];
10783 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440635"];
10784 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure) 440636"];
10785 [label="param TypeDependsClosure(NamedTypeSymbol type) 440637"];
10786 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 440638"];
10787 [label="param TypeDependsClosure(HashSet<Symbol> partialClosure) 440639"];
10788 [label="if ((object)type == null)\n            {\n                return;\n            } 440640"];
10789 [label="if ((object)type == null)\n            {\n                return;\n            } 440641"];
10790 [label="this.SpecialType 440642"];
10791 [label="get\n            {\n                return _corTypeId;\n            } 440643"];
10792 [label="if (this.SpecialType == SpecialType.System_Object)\n            {\n                return (int)SpecialType.System_Object;\n            } 440644"];
10793 [label="return (int)SpecialType.System_Object; 440645"];
10794 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440646"];
10795 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440647"];
10796 [label="s.Kind 440648"];
10797 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440649"];
10798 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440650"];
10799 [label="return null; 440651"];
10800 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440652"];
10801 [label="if ((object)type == null)\n            {\n                return;\n            } 440653"];
10802 [label="if ((object)type == null)\n            {\n                return;\n            } 440654"];
10803 [label="return; 440655"];
10804 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440656"];
10805 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440657"];
10806 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440658"];
10807 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440659"];
10808 [label="TypeDependsClosure(depends, depends.DeclaringCompilation, hs); 440660"];
10809 [label="var result = hs.Contains(on); 440661"];
10810 [label="var result = hs.Contains(on); 440662"];
10811 [label="var result = hs.Contains(on); 440663"];
10812 [label="this.SpecialType 440664"];
10813 [label="OriginalDefinition 440665"];
10814 [label="hs.Free(); 440666"];
10815 [label="return result; 440667"];
10816 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 440668"];
10817 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 440669"];
10818 [label="_hasNoBaseCycles = true; 440670"];
10819 [label="_hasNoBaseCycles 440671"];
10820 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 440672"];
10821 [label="return declaredBase; 440673"];
10822 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 440674"];
10823 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 440675"];
10824 [label="Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType); 440676"];
10825 [label="return _lazyBaseType; 440677"];
10826 [label="NamedTypeSymbol @base = this.BaseTypeNoUseSiteDiagnostics; 440678"];
10827 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 440679"];
10828 [label="while ((object)@base != null)\n            {\n                if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                }\n\n                @base = @base.BaseTypeNoUseSiteDiagnostics;\n            } 440680"];
10829 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 440681"];
10830 [label="@base.IsErrorType() 440682"];
10831 [label="param IsErrorType(this TypeSymbol type) 440683"];
10832 [label="RoslynDebug.Assert((object)type != null); 440684"];
10833 [label="RoslynDebug.Assert((object)type != null); 440685"];
10834 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440686"];
10835 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 440687"];
10836 [label="@base.BaseTypeNoUseSiteDiagnostics 440688"];
10837 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440689"];
10838 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440690"];
10839 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 440691"];
10840 [label="Debug.Assert((object)depends != null); 440692"];
10841 [label="Debug.Assert((object)on != null); 440693"];
10842 [label="on.IsDefinition 440694"];
10843 [label="Debug.Assert(on.IsDefinition); 440695"];
10844 [label="depends.DeclaringCompilation 440696"];
10845 [label="get { return null; } 440697"];
10846 [label="return null; 440698"];
10847 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 440699"];
10848 [label="if ((object)type == null)\n            {\n                return;\n            } 440700"];
10849 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440701"];
10850 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440702"];
10851 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 440703"];
10852 [label="if ((object)type == null)\n            {\n                return;\n            } 440704"];
10853 [label="return; 440705"];
10854 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440706"];
10855 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 440707"];
10856 [label="return result; 440708"];
10857 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 440709"];
10858 [label="@base = @base.BaseTypeNoUseSiteDiagnostics; 440710"];
10859 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 440711"];
10860 [label="@base.IsErrorType() 440712"];
10861 [label="param IsErrorType(this TypeSymbol type) 440713"];
10862 [label="RoslynDebug.Assert((object)type != null); 440714"];
10863 [label="RoslynDebug.Assert((object)type != null); 440715"];
10864 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440716"];
10865 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 440717"];
10866 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440718"];
10867 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440719"];
10868 [label="if ((object)declaredBase == null)\n            {\n                return null;\n            } 440720"];
10869 [label="return null; 440721"];
10870 [label="return null; 440722"];
10871 [label="if (MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()))\n            {\n                return result;\n            } 440723"];
10872 [label="MergeUseSiteDiagnostics(ref result, DeriveUseSiteDiagnosticFromBase()) 440724"];
10873 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 440725"];
10874 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 440726"];
10875 [label="param MergeUseSiteDiagnostics(this) 440727"];
10876 [label="if (info == null)\n            {\n                return false;\n            } 440728"];
10877 [label="if (info == null)\n            {\n                return false;\n            } 440729"];
10878 [label="return false; 440730"];
10879 [label="this.ContainingModule 440731"];
10880 [label="get\n            {\n                return ContainingPEModule;\n            } 440732"];
10881 [label="ContainingPEModule 440733"];
10882 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 440734"];
10883 [label="Symbol s = _container; 440735"];
10884 [label="s.Kind 440736"];
10885 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440737"];
10886 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440738"];
10887 [label="return ContainingPEModule; 440739"];
10888 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 440740"];
10889 [label="this.ContainingModule.HasUnifiedReferences 440741"];
10890 [label="get { return GetUnifiedAssemblies().Length > 0; } 440742"];
10891 [label="GetUnifiedAssemblies() 440743"];
10892 [label="param GetUnifiedAssemblies(this) 440744"];
10893 [label="AssertReferencesInitialized() 440745"];
10894 [label="param AssertReferencesInitialized(this) 440746"];
10895 [label="Debug.Assert(_moduleReferences != null); 440747"];
10896 [label="Debug.Assert(_moduleReferences != null); 440748"];
10897 [label="AssertReferencesInitialized(); 440749"];
10898 [label="return GetUnifiedAssemblies().Length > 0; 440750"];
10899 [label="return GetUnifiedAssemblies().Length > 0; 440751"];
10900 [label="return result; 440752"];
10901 [label="if (!MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()))\n            {\n                // Check if this type is marked by RequiredAttribute attribute.\n                // If so mark the type as bad, because it relies upon semantics that are not understood by the C# compiler.\n                if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                }\n            } 440753"];
10902 [label="MergeUseSiteDiagnostics(ref diagnostic, CalculateUseSiteDiagnostic()) 440754"];
10903 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 440755"];
10904 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 440756"];
10905 [label="param MergeUseSiteDiagnostics(this) 440757"];
10906 [label="if (info == null)\n            {\n                return false;\n            } 440758"];
10907 [label="if (info == null)\n            {\n                return false;\n            } 440759"];
10908 [label="return false; 440760"];
10909 [label="this.ContainingPEModule 440761"];
10910 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 440762"];
10911 [label="Symbol s = _container; 440763"];
10912 [label="s.Kind 440764"];
10913 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440765"];
10914 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440766"];
10915 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 440767"];
10916 [label="this.ContainingPEModule.Module 440768"];
10917 [label="get\n            {\n                return _module;\n            } 440769"];
10918 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 440770"];
10919 [label="TypeKind 440771"];
10920 [label="TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true); 440772"];
10921 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440773"];
10922 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 440774"];
10923 [label="if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        } 440775"];
10924 [label="@base.SpecialType 440776"];
10925 [label="SpecialType baseCorTypeId = @base.SpecialType; 440777"];
10926 [label="switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            } 440778"];
10927 [label="this.SpecialType 440779"];
10928 [label="if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    } 440780"];
10929 [label="result = TypeKind.Struct; 440781"];
10930 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 440782"];
10931 [label="return diagnostic; 440783"];
10932 [label="_lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl(); 440784"];
10933 [label="_lazyUseSiteDiagnostic 440785"];
10934 [label="return _lazyUseSiteDiagnostic; 440786"];
10935 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 440787"];
10936 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 440788"];
10937 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 440789"];
10938 [label="return MergeUseSiteDiagnostics(ref result, info); 440790"];
10939 [label="return MergeUseSiteDiagnostics(ref result, info); 440791"];
10940 [label="MergeUseSiteDiagnostics(ref result, info) 440792"];
10941 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 440793"];
10942 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 440794"];
10943 [label="param MergeUseSiteDiagnostics(this) 440795"];
10944 [label="if (info == null)\n            {\n                return false;\n            } 440796"];
10945 [label="type.CustomModifiers 440797"];
10946 [label="=> _extensions.CustomModifiers 440798"];
10947 [label="_customModifiers 440799"];
10948 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 440800"];
10949 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 440801"];
10950 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 440802"];
10951 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 440803"];
10952 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 440804"];
10953 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 440805"];
10954 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 440806"];
10955 [label="bool checkRequiredModifiers = true; 440807"];
10956 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 440808"];
10957 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 440809"];
10958 [label="return false; 440810"];
10959 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 440811"];
10960 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 440812"];
10961 [label="this.RefCustomModifiers 440813"];
10962 [label="=> Signature.ReturnParam.RefCustomModifiers 440814"];
10963 [label="Signature 440815"];
10964 [label="=> _lazySignature ?? LoadSignature() 440816"];
10965 [label="_lazySignature ?? LoadSignature() 440817"];
10966 [label="Signature.ReturnParam.RefCustomModifiers 440818"];
10967 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 440819"];
10968 [label="return ImmutableArray<CustomModifier>.Empty; 440820"];
10969 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440821"];
10970 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440822"];
10971 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 440823"];
10972 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 440824"];
10973 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 440825"];
10974 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 440826"];
10975 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 440827"];
10976 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 440828"];
10977 [label="bool checkRequiredModifiers = true; 440829"];
10978 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 440830"];
10979 [label="return false; 440831"];
10980 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440832"];
10981 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 440833"];
10982 [label="this.Parameters 440834"];
10983 [label="=> Signature.Parameters 440835"];
10984 [label="_lazySignature ?? LoadSignature() 440836"];
10985 [label="DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters) 440837"];
10986 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 440838"];
10987 [label="param DeriveUseSiteDiagnosticFromParameters(ImmutableArray<ParameterSymbol> parameters) 440839"];
10988 [label="param DeriveUseSiteDiagnosticFromParameters(this) 440840"];
10989 [label="foreach (ParameterSymbol param in parameters)\n            {\n                if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                }\n            } 440841"];
10990 [label="foreach (ParameterSymbol param in parameters)\n            {\n                if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                }\n            } 440842"];
10991 [label="if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                } 440843"];
10992 [label="if (DeriveUseSiteDiagnosticFromParameter(ref result, param))\n                {\n                    return true;\n                } 440844"];
10993 [label="DeriveUseSiteDiagnosticFromParameter(ref result, param) 440845"];
10994 [label="param DeriveUseSiteDiagnosticFromParameter(ref DiagnosticInfo result) 440846"];
10995 [label="param DeriveUseSiteDiagnosticFromParameter(ParameterSymbol param) 440847"];
10996 [label="param DeriveUseSiteDiagnosticFromParameter(this) 440848"];
10997 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 440849"];
10998 [label="param.TypeWithAnnotations 440850"];
10999 [label="get\n            {\n                return _typeWithAnnotations;\n            } 440851"];
11000 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 440852"];
11001 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 440853"];
11002 [label="DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) 440854"];
11003 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 440855"];
11004 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 440856"];
11005 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 440857"];
11006 [label="param DeriveUseSiteDiagnosticFromType(this) 440858"];
11007 [label="=> defaultType 440859"];
11008 [label="param DeriveUseSiteDiagnosticFromType(this) 440860"];
11009 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 440861"];
11010 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 440862"];
11011 [label="s.Kind 440863"];
11012 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440864"];
11013 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440865"];
11014 [label="Debug.Assert((object)moduleSymbol != null); 440866"];
11015 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 440867"];
11016 [label="param TransformType(int targetSymbolCustomModifierCount) 440868"];
11017 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 440869"];
11018 [label="Debug.Assert((object)metadataType != null); 440870"];
11019 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 440871"];
11020 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 440872"];
11021 [label="_elementNames 440873"];
11022 [label="elementNames.IsDefault 440874"];
11023 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 440875"];
11024 [label="_namesIndex 440876"];
11025 [label="_foundUsableErrorType = false; 440877"];
11026 [label="_foundUsableErrorType 440878"];
11027 [label="param DecodeType(this) 440879"];
11028 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440880"];
11029 [label="param DecodeNamedType(this) 440881"];
11030 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 440882"];
11031 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 440883"];
11032 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 440884"];
11033 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 440885"];
11034 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 440886"];
11035 [label="DecodeTypeArguments(typeArgs) 440887"];
11036 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 440888"];
11037 [label="param DecodeTypeArguments(this) 440889"];
11038 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 440890"];
11039 [label="return typeArgs; 440891"];
11040 [label="type.ContainingType 440892"];
11041 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 440893"];
11042 [label="return _container as NamedTypeSymbol; 440894"];
11043 [label="NamedTypeSymbol containingType = type.ContainingType; 440895"];
11044 [label="NamedTypeSymbol? decodedContainingType; 440896"];
11045 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 440897"];
11046 [label="decodedContainingType = containingType; 440898"];
11047 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440899"];
11048 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 440900"];
11049 [label="var typeArgsChanged = typeArgs != decodedArgs; 440901"];
11050 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 440902"];
11051 [label="decodedType.IsTupleType 440903"];
11052 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 440904"];
11053 [label="_ 440905"];
11054 [label="tupleCardinality: out _ 440906"];
11055 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 440907"];
11056 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 440908"];
11057 [label="param IsTupleTypeOfCardinality(this) 440909"];
11058 [label="IsUnboundGenericType 440910"];
11059 [label="get\n            {\n                return false;\n            } 440911"];
11060 [label="return false; 440912"];
11061 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440913"];
11062 [label="ContainingSymbol 440914"];
11063 [label="get\n            {\n                return _container;\n            } 440915"];
11064 [label="return _container; 440916"];
11065 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440917"];
11066 [label=".Kind 440918"];
11067 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440919"];
11068 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440920"];
11069 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440921"];
11070 [label="ContainingNamespace 440922"];
11071 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440923"];
11072 [label="get\n            {\n                return _container;\n            } 440924"];
11073 [label="return _container; 440925"];
11074 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440926"];
11075 [label="ContainingNamespace.ContainingNamespace 440927"];
11076 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 440928"];
11077 [label=".IsGlobalNamespace 440929"];
11078 [label="get\n            {\n                return true;\n            } 440930"];
11079 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440931"];
11080 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440932"];
11081 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440933"];
11082 [label="Name 440934"];
11083 [label="get\n            {\n                return _name;\n            } 440935"];
11084 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440936"];
11085 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440937"];
11086 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 440938"];
11087 [label="tupleCardinality = 0; 440939"];
11088 [label="return false; 440940"];
11089 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 440941"];
11090 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 440942"];
11091 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 440943"];
11092 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 440944"];
11093 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 440945"];
11094 [label="typeSymbol.IsNullableType() 440946"];
11095 [label="param IsNullableType(this TypeSymbol type) 440947"];
11096 [label="type.OriginalDefinition 440948"];
11097 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440949"];
11098 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440950"];
11099 [label="type.OriginalDefinition.SpecialType 440951"];
11100 [label="get\n            {\n                return _corTypeId;\n            } 440952"];
11101 [label="var a1 = defaultType is null; 440953"];
11102 [label="!a1 440954"];
11103 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 440955"];
11104 [label="defaultType.IsNullableType() 440956"];
11105 [label="param IsNullableType(this TypeSymbol type) 440957"];
11106 [label="type.OriginalDefinition 440958"];
11107 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 440959"];
11108 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 440960"];
11109 [label="type.OriginalDefinition.SpecialType 440961"];
11110 [label="get\n            {\n                return _corTypeId;\n            } 440962"];
11111 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 440963"];
11112 [label="Debug.Assert(a1 || a2 != true || a3); 440964"];
11113 [label="Debug.Assert(a1 || a2 != true || a3); 440965"];
11114 [label="Debug.Assert(extensions != null); 440966"];
11115 [label="param TransformType(Symbol accessSymbol) 440967"];
11116 [label="metadataType.HasType 440968"];
11117 [label="=> !(DefaultType is null) 440969"];
11118 [label="DefaultType is null 440970"];
11119 [label="!(DefaultType is null) 440971"];
11120 [label="Debug.Assert(metadataType.HasType); 440972"];
11121 [label="accessSymbol.IsDefinition 440973"];
11122 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 440974"];
11123 [label="Debug.Assert(accessSymbol.IsDefinition); 440975"];
11124 [label="accessSymbol.ContainingModule 440976"];
11125 [label="get\n            {\n                return ContainingPEModule;\n            } 440977"];
11126 [label="ContainingPEModule 440978"];
11127 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 440979"];
11128 [label="s.Kind 440980"];
11129 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 440981"];
11130 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 440982"];
11131 [label="return ContainingPEModule; 440983"];
11132 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 440984"];
11133 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440985"];
11134 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 440986"];
11135 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 440987"];
11136 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 440988"];
11137 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 440989"];
11138 [label="Debug.Assert(symbol is object); 440990"];
11139 [label="symbol.Kind 440991"];
11140 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 440992"];
11141 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 440993"];
11142 [label="isInternal = false; 440994"];
11143 [label="symbol.DeclaredAccessibility 440995"];
11144 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 440996"];
11145 [label="Accessibility access = Accessibility.Private; 440997"];
11146 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 440998"];
11147 [label="symbol.ContainingType 440999"];
11148 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441000"];
11149 [label="return _container as NamedTypeSymbol; 441001"];
11150 [label="symbol = symbol.ContainingType; 441002"];
11151 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 441003"];
11152 [label="return true; 441004"];
11153 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441005"];
11154 [label="param TryGetByte(out byte? value) 441006"];
11155 [label="value = null; 441007"];
11156 [label="param GetLocalNullableContextValue(this) 441008"];
11157 [label="get\n            {\n                return _moduleSymbol;\n            } 441009"];
11158 [label="return _moduleSymbol; 441010"];
11159 [label="param GetLocalNullableContextValue(this) 441011"];
11160 [label="get\n            {\n                return _assemblySymbol;\n            } 441012"];
11161 [label="return _assemblySymbol; 441013"];
11162 [label="param GetLocalNullableContextValue(this) 441014"];
11163 [label="get\n            {\n                return null;\n            } 441015"];
11164 [label="=> defaultType 441016"];
11165 [label="Debug.Assert((object)depends != null); 441017"];
11166 [label="Debug.Assert((object)on != null); 441018"];
11167 [label="Debug.Assert(on.IsDefinition); 441019"];
11168 [label="depends.DeclaringCompilation 441020"];
11169 [label="get { return null; } 441021"];
11170 [label="return null; 441022"];
11171 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 441023"];
11172 [label="if ((object)type == null)\n            {\n                return;\n            } 441024"];
11173 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 441025"];
11174 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441026"];
11175 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 441027"];
11176 [label="if ((object)type == null)\n            {\n                return;\n            } 441028"];
11177 [label="return; 441029"];
11178 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441030"];
11179 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441031"];
11180 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441032"];
11181 [label="return result; 441033"];
11182 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 441034"];
11183 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 441035"];
11184 [label="@base.IsErrorType() 441036"];
11185 [label="param IsErrorType(this TypeSymbol type) 441037"];
11186 [label="RoslynDebug.Assert((object)type != null); 441038"];
11187 [label="RoslynDebug.Assert((object)type != null); 441039"];
11188 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441040"];
11189 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 441041"];
11190 [label="return null; 441042"];
11191 [label="param MergeUseSiteDiagnostics(this) 441043"];
11192 [label="this.ContainingModule 441044"];
11193 [label="get\n            {\n                return ContainingPEModule;\n            } 441045"];
11194 [label="ContainingPEModule 441046"];
11195 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 441047"];
11196 [label="Symbol s = _container; 441048"];
11197 [label="s.Kind 441049"];
11198 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441050"];
11199 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441051"];
11200 [label="return ContainingPEModule; 441052"];
11201 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 441053"];
11202 [label="this.ContainingModule.HasUnifiedReferences 441054"];
11203 [label="get { return GetUnifiedAssemblies().Length > 0; } 441055"];
11204 [label="GetUnifiedAssemblies() 441056"];
11205 [label="param GetUnifiedAssemblies(this) 441057"];
11206 [label="AssertReferencesInitialized() 441058"];
11207 [label="param AssertReferencesInitialized(this) 441059"];
11208 [label="Debug.Assert(_moduleReferences != null); 441060"];
11209 [label="Debug.Assert(_moduleReferences != null); 441061"];
11210 [label="AssertReferencesInitialized(); 441062"];
11211 [label="return GetUnifiedAssemblies().Length > 0; 441063"];
11212 [label="return GetUnifiedAssemblies().Length > 0; 441064"];
11213 [label="Symbol s = _container; 441065"];
11214 [label="s.Kind 441066"];
11215 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441067"];
11216 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441068"];
11217 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 441069"];
11218 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441070"];
11219 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 441071"];
11220 [label="return _lazyUseSiteDiagnostic; 441072"];
11221 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 441073"];
11222 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 441074"];
11223 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 441075"];
11224 [label="return MergeUseSiteDiagnostics(ref result, info); 441076"];
11225 [label="MergeUseSiteDiagnostics(ref result, info) 441077"];
11226 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 441078"];
11227 [label="param MergeUseSiteDiagnostics(this) 441079"];
11228 [label="type.CustomModifiers 441080"];
11229 [label="=> _extensions.CustomModifiers 441081"];
11230 [label="_customModifiers 441082"];
11231 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 441083"];
11232 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 441084"];
11233 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 441085"];
11234 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 441086"];
11235 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 441087"];
11236 [label="bool checkRequiredModifiers = true; 441088"];
11237 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 441089"];
11238 [label="return false; 441090"];
11239 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 441091"];
11240 [label="param.RefCustomModifiers 441092"];
11241 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 441093"];
11242 [label="return ImmutableArray<CustomModifier>.Empty; 441094"];
11243 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 441095"];
11244 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 441096"];
11245 [label="method.MethodKind 441097"];
11246 [label="get\n            {\n                if (!_packedFlags.MethodKindIsPopulated)\n                {\n                    _packedFlags.InitializeMethodKind(this.ComputeMethodKind());\n                }\n                return _packedFlags.MethodKind;\n            } 441098"];
11247 [label="=> (_bits & MethodKindIsPopulatedBit) != 0 441099"];
11248 [label="get\n                {\n                    return (MethodKind)((_bits >> MethodKindOffset) & MethodKindMask);\n                } 441100"];
11249 [label="this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature 441101"];
11250 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 441102"];
11251 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 441103"];
11252 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 441104"];
11253 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 441105"];
11254 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 441106"];
11255 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 441107"];
11256 [label="bool checkRequiredModifiers = true; 441108"];
11257 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 441109"];
11258 [label="return false; 441110"];
11259 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 441111"];
11260 [label="return DeriveUseSiteDiagnosticFromType(ref result, param.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, param.RefCustomModifiers,\n                                                              this is MethodSymbol method && method.MethodKind == MethodKind.FunctionPointerSignature ?\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute | AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute :\n                                                                  AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute); 441112"];
11261 [label="return false; 441113"];
11262 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 441114"];
11263 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 441115"];
11264 [label="this.ContainingModule 441116"];
11265 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 441117"];
11266 [label="this.ContainingSymbol 441118"];
11267 [label="=> _containingType 441119"];
11268 [label="_containingType 441120"];
11269 [label="var container = this.ContainingSymbol; 441121"];
11270 [label="return (object)container != null ? container.ContainingModule : null; 441122"];
11271 [label="return (object)container != null ? container.ContainingModule : null; 441123"];
11272 [label="(object)container != null 441124"];
11273 [label="container.ContainingModule 441125"];
11274 [label="get\n            {\n                return ContainingPEModule;\n            } 441126"];
11275 [label="ContainingPEModule 441127"];
11276 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 441128"];
11277 [label="s.Kind 441129"];
11278 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441130"];
11279 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441131"];
11280 [label="return ContainingPEModule; 441132"];
11281 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 441133"];
11282 [label=".HasUnifiedReferences 441134"];
11283 [label="get { return GetUnifiedAssemblies().Length > 0; } 441135"];
11284 [label="GetUnifiedAssemblies() 441136"];
11285 [label="param GetUnifiedAssemblies(this) 441137"];
11286 [label="AssertReferencesInitialized() 441138"];
11287 [label="param AssertReferencesInitialized(this) 441139"];
11288 [label="Debug.Assert(_moduleReferences != null); 441140"];
11289 [label="Debug.Assert(_moduleReferences != null); 441141"];
11290 [label="AssertReferencesInitialized(); 441142"];
11291 [label="return GetUnifiedAssemblies().Length > 0; 441143"];
11292 [label="return GetUnifiedAssemblies().Length > 0; 441144"];
11293 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 441145"];
11294 [label="return false; 441146"];
11295 [label="CalculateUseSiteDiagnostic(ref result); 441147"];
11296 [label="EnsureTypeParametersAreLoaded(ref result); 441148"];
11297 [label="EnsureTypeParametersAreLoaded(ref result) 441149"];
11298 [label="param EnsureTypeParametersAreLoaded(ref DiagnosticInfo diagnosticInfo) 441150"];
11299 [label="param EnsureTypeParametersAreLoaded(this) 441151"];
11300 [label="var typeParams = _lazyTypeParameters; 441152"];
11301 [label="if (!typeParams.IsDefault)\n            {\n                return typeParams;\n            } 441153"];
11302 [label="return typeParams; 441154"];
11303 [label="EnsureTypeParametersAreLoaded(ref result); 441155"];
11304 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 441156"];
11305 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 441157"];
11306 [label="GetUnmanagedCallersOnlyAttributeData(forceComplete: true) 441158"];
11307 [label="param GetUnmanagedCallersOnlyAttributeData(bool forceComplete) 441159"];
11308 [label="param GetUnmanagedCallersOnlyAttributeData(this) 441160"];
11309 [label="_packedFlags.IsUnmanagedCallersOnlyAttributePopulated 441161"];
11310 [label="=> (_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 441162"];
11311 [label="_bits & IsUnmanagedCallersOnlyAttributePopulatedBit 441163"];
11312 [label="0 441164"];
11313 [label="(_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 441165"];
11314 [label="if (!_packedFlags.IsUnmanagedCallersOnlyAttributePopulated)\n            {\n                var containingModule = (PEModuleSymbol)ContainingModule;\n                var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null));\n\n                Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n\n                var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized);\n\n                _packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated();\n                return result;\n            } 441166"];
11315 [label="ContainingModule 441167"];
11316 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 441168"];
11317 [label="this.ContainingSymbol 441169"];
11318 [label="=> _containingType 441170"];
11319 [label="_containingType 441171"];
11320 [label="var container = this.ContainingSymbol; 441172"];
11321 [label="return (object)container != null ? container.ContainingModule : null; 441173"];
11322 [label="return (object)container != null ? container.ContainingModule : null; 441174"];
11323 [label="(object)container != null 441175"];
11324 [label="container.ContainingModule 441176"];
11325 [label="get\n            {\n                return ContainingPEModule;\n            } 441177"];
11326 [label="ContainingPEModule 441178"];
11327 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 441179"];
11328 [label="s.Kind 441180"];
11329 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441181"];
11330 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441182"];
11331 [label="return ContainingPEModule; 441183"];
11332 [label="var containingModule = (PEModuleSymbol)ContainingModule; 441184"];
11333 [label="containingModule.Module 441185"];
11334 [label="get\n            {\n                return _module;\n            } 441186"];
11335 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 441187"];
11336 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 441188"];
11337 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 441189"];
11338 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 441190"];
11339 [label="new MetadataDecoder(containingModule) 441191"];
11340 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 441192"];
11341 [label="param MetadataDecoder(this) 441193"];
11342 [label="moduleSymbol 441194"];
11343 [label="null 441195"];
11344 [label="null 441196"];
11345 [label="param MetadataDecoder(this) 441197"];
11346 [label="param MetadataDecoder(PEModuleSymbol moduleSymbol) 441198"];
11347 [label="param MetadataDecoder(PENamedTypeSymbol typeContextOpt) 441199"];
11348 [label="param MetadataDecoder(PEMethodSymbol methodContextOpt) 441200"];
11349 [label="Debug.Assert((object)moduleSymbol != null); 441201"];
11350 [label="Debug.Assert((object)moduleSymbol != null); 441202"];
11351 [label="var unmanagedCallersOnlyData = containingModule.Module.TryGetUnmanagedCallersOnlyAttribute(_handle, new MetadataDecoder(containingModule),\n                    static (name, value, isField) => MethodSymbol.TryDecodeUnmanagedCallersOnlyCallConvsField(name, value, isField, location: null, diagnostics: null)); 441203"];
11352 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 441204"];
11353 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 441205"];
11354 [label="AccessUncommonFields() 441206"];
11355 [label="param AccessUncommonFields(this) 441207"];
11356 [label="var retVal = _uncommonFields; 441208"];
11357 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 441209"];
11358 [label="CreateUncommonFields() 441210"];
11359 [label="param CreateUncommonFields(this) 441211"];
11360 [label="var retVal = new UncommonFields(); 441212"];
11361 [label="new UncommonFields() 441213"];
11362 [label="param UncommonFields(this) 441214"];
11363 [label="_lazyThisParameter 441215"];
11364 [label="_lazyDocComment 441216"];
11365 [label="_lazyOverriddenOrHiddenMembersResult 441217"];
11366 [label="_lazyObsoleteAttributeData 441218"];
11367 [label="_lazyUnmanagedCallersOnlyAttributeData 441219"];
11368 [label="_lazyUseSiteDiagnostic 441220"];
11369 [label="_lazyExplicitClassOverride 441221"];
11370 [label="_packedFlags.IsObsoleteAttributePopulated 441222"];
11371 [label="=> (_bits & IsObsoleteAttributePopulatedBit) != 0 441223"];
11372 [label="_bits & IsObsoleteAttributePopulatedBit 441224"];
11373 [label="0 441225"];
11374 [label="(_bits & IsObsoleteAttributePopulatedBit) != 0 441226"];
11375 [label="if (!_packedFlags.IsObsoleteAttributePopulated)\n            {\n                retVal._lazyObsoleteAttributeData = ObsoleteAttributeData.Uninitialized;\n            } 441227"];
11376 [label="retVal._lazyObsoleteAttributeData 441228"];
11377 [label="_packedFlags.IsUnmanagedCallersOnlyAttributePopulated 441229"];
11378 [label="=> (_bits & IsUnmanagedCallersOnlyAttributePopulatedBit) != 0 441230"];
11379 [label="if (!_packedFlags.IsUnmanagedCallersOnlyAttributePopulated)\n            {\n                retVal._lazyUnmanagedCallersOnlyAttributeData = UnmanagedCallersOnlyAttributeData.Uninitialized;\n            } 441231"];
11380 [label="retVal._lazyUnmanagedCallersOnlyAttributeData 441232"];
11381 [label="_packedFlags.IsCustomAttributesPopulated 441233"];
11382 [label="=> (_bits & IsCustomAttributesPopulatedBit) != 0 441234"];
11383 [label="_bits & IsCustomAttributesPopulatedBit 441235"];
11384 [label="0 441236"];
11385 [label="(_bits & IsCustomAttributesPopulatedBit) != 0 441237"];
11386 [label="if (_packedFlags.IsCustomAttributesPopulated)\n            {\n                retVal._lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n            } 441238"];
11387 [label="_packedFlags.IsConditionalPopulated 441239"];
11388 [label="=> (_bits & IsConditionalPopulatedBit) != 0 441240"];
11389 [label="_bits & IsConditionalPopulatedBit 441241"];
11390 [label="0 441242"];
11391 [label="(_bits & IsConditionalPopulatedBit) != 0 441243"];
11392 [label="if (_packedFlags.IsConditionalPopulated)\n            {\n                retVal._lazyConditionalAttributeSymbols = ImmutableArray<string>.Empty;\n            } 441244"];
11393 [label="_packedFlags.IsOverriddenOrHiddenMembersPopulated 441245"];
11394 [label="=> (_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 441246"];
11395 [label="_bits & IsOverriddenOrHiddenMembersPopulatedBit 441247"];
11396 [label="0 441248"];
11397 [label="(_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 441249"];
11398 [label="if (_packedFlags.IsOverriddenOrHiddenMembersPopulated)\n            {\n                retVal._lazyOverriddenOrHiddenMembersResult = OverriddenOrHiddenMembersResult.Empty;\n            } 441250"];
11399 [label="_packedFlags.IsMemberNotNullPopulated 441251"];
11400 [label="=> (_bits & IsMemberNotNullPopulatedBit) != 0 441252"];
11401 [label="_bits & IsMemberNotNullPopulatedBit 441253"];
11402 [label="0 441254"];
11403 [label="(_bits & IsMemberNotNullPopulatedBit) != 0 441255"];
11404 [label="if (_packedFlags.IsMemberNotNullPopulated)\n            {\n                retVal._lazyNotNullMembers = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenTrue = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenFalse = ImmutableArray<string>.Empty;\n            } 441256"];
11405 [label="_packedFlags.IsExplicitOverrideIsPopulated 441257"];
11406 [label="=> (_bits & IsExplicitOverrideIsPopulatedBit) != 0 441258"];
11407 [label="_bits & IsExplicitOverrideIsPopulatedBit 441259"];
11408 [label="0 441260"];
11409 [label="(_bits & IsExplicitOverrideIsPopulatedBit) != 0 441261"];
11410 [label="if (_packedFlags.IsExplicitOverrideIsPopulated)\n            {\n                retVal._lazyExplicitClassOverride = null;\n            } 441262"];
11411 [label="return retVal; 441263"];
11412 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 441264"];
11413 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 441265"];
11414 [label="return retVal ?? InterlockedOperations.Initialize(ref _uncommonFields, CreateUncommonFields()); 441266"];
11415 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 441267"];
11416 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 441268"];
11417 [label="var result = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUnmanagedCallersOnlyAttributeData,\n                                                              unmanagedCallersOnlyData,\n                                                              UnmanagedCallersOnlyAttributeData.Uninitialized); 441269"];
11418 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated() 441270"];
11419 [label="param SetIsUnmanagedCallersOnlyAttributePopulated(this) 441271"];
11420 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUnmanagedCallersOnlyAttributePopulatedBit); 441272"];
11421 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUnmanagedCallersOnlyAttributePopulatedBit); 441273"];
11422 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated(); 441274"];
11423 [label="return result; 441275"];
11424 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 441276"];
11425 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 441277"];
11426 [label="return InitializeUseSiteDiagnostic(result); 441278"];
11427 [label="InitializeUseSiteDiagnostic(result) 441279"];
11428 [label="param InitializeUseSiteDiagnostic(DiagnosticInfo diagnostic) 441280"];
11429 [label="param InitializeUseSiteDiagnostic(this) 441281"];
11430 [label="_packedFlags.IsUseSiteDiagnosticPopulated 441282"];
11431 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 441283"];
11432 [label="_bits & IsUseSiteDiagnosticPopulatedBit 441284"];
11433 [label="if (_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                return _uncommonFields?._lazyUseSiteDiagnostic;\n            } 441285"];
11434 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 441286"];
11435 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 441287"];
11436 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated() 441288"];
11437 [label="param SetIsUseSiteDiagnosticPopulated(this) 441289"];
11438 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUseSiteDiagnosticPopulatedBit); 441290"];
11439 [label="ThreadSafeFlagOperations.Set(ref _bits, IsUseSiteDiagnosticPopulatedBit); 441291"];
11440 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated(); 441292"];
11441 [label="return diagnostic; 441293"];
11442 [label="var info = this.GetUseSiteDiagnostic(); 441294"];
11443 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 441295"];
11444 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 441296"];
11445 [label="this.ContainingType 441297"];
11446 [label="=> _containingType 441298"];
11447 [label="_containingType 441299"];
11448 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 441300"];
11449 [label="this.ContainingType.GetUseSiteDiagnostic() 441301"];
11450 [label="param GetUseSiteDiagnostic(this) 441302"];
11451 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 441303"];
11452 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 441304"];
11453 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441305"];
11454 [label="s.Kind 441306"];
11455 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441307"];
11456 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441308"];
11457 [label="EntityHandle token = moduleSymbol.Module.GetBaseTypeOfTypeOrThrow(_handle); 441309"];
11458 [label="Debug.Assert((object)moduleSymbol != null); 441310"];
11459 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 441311"];
11460 [label="s.Kind 441312"];
11461 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441313"];
11462 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441314"];
11463 [label="param TransformType(int targetSymbolCustomModifierCount) 441315"];
11464 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 441316"];
11465 [label="Debug.Assert((object)metadataType != null); 441317"];
11466 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 441318"];
11467 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 441319"];
11468 [label="_elementNames 441320"];
11469 [label="elementNames.IsDefault 441321"];
11470 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 441322"];
11471 [label="_namesIndex 441323"];
11472 [label="_foundUsableErrorType = false; 441324"];
11473 [label="_foundUsableErrorType 441325"];
11474 [label="param DecodeType(this) 441326"];
11475 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441327"];
11476 [label="param DecodeNamedType(this) 441328"];
11477 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 441329"];
11478 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 441330"];
11479 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 441331"];
11480 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 441332"];
11481 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 441333"];
11482 [label="DecodeTypeArguments(typeArgs) 441334"];
11483 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 441335"];
11484 [label="param DecodeTypeArguments(this) 441336"];
11485 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 441337"];
11486 [label="return typeArgs; 441338"];
11487 [label="type.ContainingType 441339"];
11488 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441340"];
11489 [label="return _container as NamedTypeSymbol; 441341"];
11490 [label="NamedTypeSymbol containingType = type.ContainingType; 441342"];
11491 [label="NamedTypeSymbol? decodedContainingType; 441343"];
11492 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 441344"];
11493 [label="decodedContainingType = containingType; 441345"];
11494 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 441346"];
11495 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 441347"];
11496 [label="var typeArgsChanged = typeArgs != decodedArgs; 441348"];
11497 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 441349"];
11498 [label="decodedType.IsTupleType 441350"];
11499 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 441351"];
11500 [label="_ 441352"];
11501 [label="tupleCardinality: out _ 441353"];
11502 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 441354"];
11503 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 441355"];
11504 [label="param IsTupleTypeOfCardinality(this) 441356"];
11505 [label="IsUnboundGenericType 441357"];
11506 [label="get\n            {\n                return false;\n            } 441358"];
11507 [label="return false; 441359"];
11508 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441360"];
11509 [label="ContainingSymbol 441361"];
11510 [label="get\n            {\n                return _container;\n            } 441362"];
11511 [label="return _container; 441363"];
11512 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441364"];
11513 [label=".Kind 441365"];
11514 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441366"];
11515 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441367"];
11516 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441368"];
11517 [label="ContainingNamespace 441369"];
11518 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 441370"];
11519 [label="get\n            {\n                return _container;\n            } 441371"];
11520 [label="return _container; 441372"];
11521 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441373"];
11522 [label="ContainingNamespace.ContainingNamespace 441374"];
11523 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 441375"];
11524 [label=".IsGlobalNamespace 441376"];
11525 [label="get\n            {\n                return true;\n            } 441377"];
11526 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441378"];
11527 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441379"];
11528 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441380"];
11529 [label="Name 441381"];
11530 [label="get\n            {\n                return _name;\n            } 441382"];
11531 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441383"];
11532 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441384"];
11533 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441385"];
11534 [label="tupleCardinality = 0; 441386"];
11535 [label="return false; 441387"];
11536 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 441388"];
11537 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 441389"];
11538 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 441390"];
11539 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 441391"];
11540 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 441392"];
11541 [label="typeSymbol.IsNullableType() 441393"];
11542 [label="param IsNullableType(this TypeSymbol type) 441394"];
11543 [label="type.OriginalDefinition 441395"];
11544 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 441396"];
11545 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 441397"];
11546 [label="type.OriginalDefinition.SpecialType 441398"];
11547 [label="get\n            {\n                return _corTypeId;\n            } 441399"];
11548 [label="var a1 = defaultType is null; 441400"];
11549 [label="!a1 441401"];
11550 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 441402"];
11551 [label="defaultType.IsNullableType() 441403"];
11552 [label="param IsNullableType(this TypeSymbol type) 441404"];
11553 [label="type.OriginalDefinition 441405"];
11554 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 441406"];
11555 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 441407"];
11556 [label="type.OriginalDefinition.SpecialType 441408"];
11557 [label="get\n            {\n                return _corTypeId;\n            } 441409"];
11558 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 441410"];
11559 [label="Debug.Assert(a1 || a2 != true || a3); 441411"];
11560 [label="Debug.Assert(a1 || a2 != true || a3); 441412"];
11561 [label="Debug.Assert(extensions != null); 441413"];
11562 [label="param TransformType(Symbol accessSymbol) 441414"];
11563 [label="metadataType.HasType 441415"];
11564 [label="=> !(DefaultType is null) 441416"];
11565 [label="DefaultType is null 441417"];
11566 [label="!(DefaultType is null) 441418"];
11567 [label="Debug.Assert(metadataType.HasType); 441419"];
11568 [label="Debug.Assert(accessSymbol.IsDefinition); 441420"];
11569 [label="accessSymbol.ContainingModule 441421"];
11570 [label="get\n            {\n                return ContainingPEModule;\n            } 441422"];
11571 [label="s.Kind 441423"];
11572 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441424"];
11573 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441425"];
11574 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 441426"];
11575 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441427"];
11576 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441428"];
11577 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 441429"];
11578 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 441430"];
11579 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 441431"];
11580 [label="Debug.Assert(symbol is object); 441432"];
11581 [label="symbol.Kind 441433"];
11582 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441434"];
11583 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 441435"];
11584 [label="isInternal = false; 441436"];
11585 [label="symbol.DeclaredAccessibility 441437"];
11586 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 441438"];
11587 [label="Accessibility access = Accessibility.Private; 441439"];
11588 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 441440"];
11589 [label="symbol.ContainingType 441441"];
11590 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441442"];
11591 [label="return _container as NamedTypeSymbol; 441443"];
11592 [label="symbol = symbol.ContainingType; 441444"];
11593 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 441445"];
11594 [label="return true; 441446"];
11595 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441447"];
11596 [label="param TryGetByte(out byte? value) 441448"];
11597 [label="return true; 441449"];
11598 [label="=> defaultType 441450"];
11599 [label="Debug.Assert((object)depends != null); 441451"];
11600 [label="Debug.Assert((object)depends != null); 441452"];
11601 [label="Debug.Assert((object)on != null); 441453"];
11602 [label="Debug.Assert(on.IsDefinition); 441454"];
11603 [label="depends.DeclaringCompilation 441455"];
11604 [label="get { return null; } 441456"];
11605 [label="return null; 441457"];
11606 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 441458"];
11607 [label="if ((object)type == null)\n            {\n                return;\n            } 441459"];
11608 [label="if ((object)type == null)\n            {\n                return;\n            } 441460"];
11609 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 441461"];
11610 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441462"];
11611 [label="Debug.Assert((object)moduleSymbol != null); 441463"];
11612 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 441464"];
11613 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441465"];
11614 [label="param TransformType(int targetSymbolCustomModifierCount) 441466"];
11615 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 441467"];
11616 [label="Debug.Assert((object)metadataType != null); 441468"];
11617 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 441469"];
11618 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 441470"];
11619 [label="_elementNames 441471"];
11620 [label="elementNames.IsDefault 441472"];
11621 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 441473"];
11622 [label="_namesIndex 441474"];
11623 [label="_foundUsableErrorType = false; 441475"];
11624 [label="_foundUsableErrorType 441476"];
11625 [label="param DecodeType(this) 441477"];
11626 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441478"];
11627 [label="param DecodeNamedType(this) 441479"];
11628 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 441480"];
11629 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 441481"];
11630 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 441482"];
11631 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 441483"];
11632 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 441484"];
11633 [label="DecodeTypeArguments(typeArgs) 441485"];
11634 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 441486"];
11635 [label="param DecodeTypeArguments(this) 441487"];
11636 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 441488"];
11637 [label="return typeArgs; 441489"];
11638 [label="type.ContainingType 441490"];
11639 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441491"];
11640 [label="return _container as NamedTypeSymbol; 441492"];
11641 [label="NamedTypeSymbol containingType = type.ContainingType; 441493"];
11642 [label="NamedTypeSymbol? decodedContainingType; 441494"];
11643 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 441495"];
11644 [label="decodedContainingType = containingType; 441496"];
11645 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 441497"];
11646 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 441498"];
11647 [label="var typeArgsChanged = typeArgs != decodedArgs; 441499"];
11648 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 441500"];
11649 [label="decodedType.IsTupleType 441501"];
11650 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 441502"];
11651 [label="_ 441503"];
11652 [label="tupleCardinality: out _ 441504"];
11653 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 441505"];
11654 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 441506"];
11655 [label="param IsTupleTypeOfCardinality(this) 441507"];
11656 [label="IsUnboundGenericType 441508"];
11657 [label="get\n            {\n                return false;\n            } 441509"];
11658 [label="return false; 441510"];
11659 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441511"];
11660 [label="ContainingSymbol 441512"];
11661 [label="get\n            {\n                return _container;\n            } 441513"];
11662 [label="return _container; 441514"];
11663 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441515"];
11664 [label=".Kind 441516"];
11665 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441517"];
11666 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441518"];
11667 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441519"];
11668 [label="ContainingNamespace 441520"];
11669 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 441521"];
11670 [label="get\n            {\n                return _container;\n            } 441522"];
11671 [label="return _container; 441523"];
11672 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441524"];
11673 [label="ContainingNamespace.ContainingNamespace 441525"];
11674 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 441526"];
11675 [label=".IsGlobalNamespace 441527"];
11676 [label="get\n            {\n                return true;\n            } 441528"];
11677 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441529"];
11678 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441530"];
11679 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441531"];
11680 [label="Name 441532"];
11681 [label="get\n            {\n                return _name;\n            } 441533"];
11682 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441534"];
11683 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441535"];
11684 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 441536"];
11685 [label="tupleCardinality = 0; 441537"];
11686 [label="return false; 441538"];
11687 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 441539"];
11688 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 441540"];
11689 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 441541"];
11690 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 441542"];
11691 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 441543"];
11692 [label="typeSymbol.IsNullableType() 441544"];
11693 [label="param IsNullableType(this TypeSymbol type) 441545"];
11694 [label="type.OriginalDefinition 441546"];
11695 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 441547"];
11696 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 441548"];
11697 [label="type.OriginalDefinition.SpecialType 441549"];
11698 [label="get\n            {\n                return _corTypeId;\n            } 441550"];
11699 [label="var a1 = defaultType is null; 441551"];
11700 [label="!a1 441552"];
11701 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 441553"];
11702 [label="defaultType.IsNullableType() 441554"];
11703 [label="param IsNullableType(this TypeSymbol type) 441555"];
11704 [label="type.OriginalDefinition 441556"];
11705 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 441557"];
11706 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 441558"];
11707 [label="type.OriginalDefinition.SpecialType 441559"];
11708 [label="get\n            {\n                return _corTypeId;\n            } 441560"];
11709 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 441561"];
11710 [label="Debug.Assert(a1 || a2 != true || a3); 441562"];
11711 [label="Debug.Assert(a1 || a2 != true || a3); 441563"];
11712 [label="Debug.Assert(extensions != null); 441564"];
11713 [label="param TransformType(Symbol accessSymbol) 441565"];
11714 [label="metadataType.HasType 441566"];
11715 [label="=> !(DefaultType is null) 441567"];
11716 [label="DefaultType is null 441568"];
11717 [label="!(DefaultType is null) 441569"];
11718 [label="Debug.Assert(metadataType.HasType); 441570"];
11719 [label="Debug.Assert(accessSymbol.IsDefinition); 441571"];
11720 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441572"];
11721 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 441573"];
11722 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441574"];
11723 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441575"];
11724 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 441576"];
11725 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 441577"];
11726 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 441578"];
11727 [label="Debug.Assert(symbol is object); 441579"];
11728 [label="symbol.Kind 441580"];
11729 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441581"];
11730 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 441582"];
11731 [label="isInternal = false; 441583"];
11732 [label="symbol.DeclaredAccessibility 441584"];
11733 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 441585"];
11734 [label="Accessibility access = Accessibility.Private; 441586"];
11735 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 441587"];
11736 [label="symbol.ContainingType 441588"];
11737 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441589"];
11738 [label="return _container as NamedTypeSymbol; 441590"];
11739 [label="symbol = symbol.ContainingType; 441591"];
11740 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 441592"];
11741 [label="return true; 441593"];
11742 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 441594"];
11743 [label="param TryGetByte(out byte? value) 441595"];
11744 [label="value = null; 441596"];
11745 [label="param GetLocalNullableContextValue(this) 441597"];
11746 [label="get\n            {\n                return _moduleSymbol;\n            } 441598"];
11747 [label="return _moduleSymbol; 441599"];
11748 [label="param GetLocalNullableContextValue(this) 441600"];
11749 [label="get\n            {\n                return _assemblySymbol;\n            } 441601"];
11750 [label="return _assemblySymbol; 441602"];
11751 [label="param GetLocalNullableContextValue(this) 441603"];
11752 [label="get\n            {\n                return null;\n            } 441604"];
11753 [label="=> defaultType 441605"];
11754 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 441606"];
11755 [label="if ((object)type == null)\n            {\n                return;\n            } 441607"];
11756 [label="if ((object)type == null)\n            {\n                return;\n            } 441608"];
11757 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 441609"];
11758 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441610"];
11759 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 441611"];
11760 [label="if ((object)type == null)\n            {\n                return;\n            } 441612"];
11761 [label="return; 441613"];
11762 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441614"];
11763 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441615"];
11764 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441616"];
11765 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441617"];
11766 [label="return result; 441618"];
11767 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 441619"];
11768 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 441620"];
11769 [label="@base.IsErrorType() 441621"];
11770 [label="param IsErrorType(this TypeSymbol type) 441622"];
11771 [label="RoslynDebug.Assert((object)type != null); 441623"];
11772 [label="RoslynDebug.Assert((object)type != null); 441624"];
11773 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441625"];
11774 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 441626"];
11775 [label="Debug.Assert((object)depends != null); 441627"];
11776 [label="Debug.Assert((object)on != null); 441628"];
11777 [label="Debug.Assert(on.IsDefinition); 441629"];
11778 [label="depends.DeclaringCompilation 441630"];
11779 [label="get { return null; } 441631"];
11780 [label="return null; 441632"];
11781 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 441633"];
11782 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 441634"];
11783 [label="return result; 441635"];
11784 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 441636"];
11785 [label="param MergeUseSiteDiagnostics(this) 441637"];
11786 [label="this.ContainingModule 441638"];
11787 [label="Symbol s = _container; 441639"];
11788 [label="s.Kind 441640"];
11789 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441641"];
11790 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441642"];
11791 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 441643"];
11792 [label="this.ContainingModule.HasUnifiedReferences 441644"];
11793 [label="get { return GetUnifiedAssemblies().Length > 0; } 441645"];
11794 [label="GetUnifiedAssemblies() 441646"];
11795 [label="param GetUnifiedAssemblies(this) 441647"];
11796 [label="AssertReferencesInitialized() 441648"];
11797 [label="param AssertReferencesInitialized(this) 441649"];
11798 [label="Debug.Assert(_moduleReferences != null); 441650"];
11799 [label="Debug.Assert(_moduleReferences != null); 441651"];
11800 [label="AssertReferencesInitialized(); 441652"];
11801 [label="return GetUnifiedAssemblies().Length > 0; 441653"];
11802 [label="return GetUnifiedAssemblies().Length > 0; 441654"];
11803 [label="Symbol s = _container; 441655"];
11804 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441656"];
11805 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 441657"];
11806 [label="SpecialType 441658"];
11807 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 441659"];
11808 [label="TypeSymbol @base = GetDeclaredBaseType(null); 441660"];
11809 [label="GetDeclaredBaseType(null) 441661"];
11810 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 441662"];
11811 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441663"];
11812 [label="TypeSymbol @base = GetDeclaredBaseType(null); 441664"];
11813 [label=".SpecialType 441665"];
11814 [label="get\n            {\n                return _corTypeId;\n            } 441666"];
11815 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 441667"];
11816 [label="@base.ContainingAssembly 441668"];
11817 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 441669"];
11818 [label="this.ContainingSymbol 441670"];
11819 [label="get\n            {\n                return _container;\n            } 441671"];
11820 [label="return _container; 441672"];
11821 [label="var container = this.ContainingSymbol; 441673"];
11822 [label="return (object)container != null ? container.ContainingAssembly : null; 441674"];
11823 [label="return (object)container != null ? container.ContainingAssembly : null; 441675"];
11824 [label="(object)container != null 441676"];
11825 [label="container.ContainingAssembly 441677"];
11826 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 441678"];
11827 [label="ContainingPEModule 441679"];
11828 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 441680"];
11829 [label="return ContainingPEModule.ContainingAssembly; 441681"];
11830 [label="ContainingPEModule.ContainingAssembly 441682"];
11831 [label="get\n            {\n                return _assemblySymbol;\n            } 441683"];
11832 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 441684"];
11833 [label=".IsMissing 441685"];
11834 [label="get\n            {\n                return false;\n            } 441686"];
11835 [label="return false; 441687"];
11836 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 441688"];
11837 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 441689"];
11838 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 441690"];
11839 [label="return _lazyUseSiteDiagnostic; 441691"];
11840 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 441692"];
11841 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 441693"];
11842 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 441694"];
11843 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 441695"];
11844 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 441696"];
11845 [label="return memberSymbol; 441697"];
11846 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 441698"];
11847 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 441699"];
11848 [label="return memberSymbol; 441700"];
11849 [label="TypeSymbol runtimeCompatibilityAttribute = compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute); 441701"];
11850 [label="compilation.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute) 441702"];
11851 [label="param GetWellKnownType(WellKnownType type) 441703"];
11852 [label="param GetWellKnownType(this) 441704"];
11853 [label="Debug.Assert(type.IsValid()); 441705"];
11854 [label="this.Options 441706"];
11855 [label="get\n            {\n                return _options;\n            } 441707"];
11856 [label="return _options; 441708"];
11857 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 441709"];
11858 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 441710"];
11859 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 441711"];
11860 [label="param Includes(this BinderFlags self) 441712"];
11861 [label="param Includes(BinderFlags other) 441713"];
11862 [label="return (self & other) == other; 441714"];
11863 [label="int index = (int)type - (int)WellKnownType.First; 441715"];
11864 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 441716"];
11865 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 441717"];
11866 [label="if (_lazyWellKnownTypes == null || _lazyWellKnownTypes[index] is null)\n            {\n                if (_lazyWellKnownTypes == null)\n                {\n                    Interlocked.CompareExchange(ref _lazyWellKnownTypes, new NamedTypeSymbol[(int)WellKnownTypes.Count], null);\n                }\n\n                string mdName = type.GetMetadataName();\n                var warnings = DiagnosticBag.GetInstance();\n                NamedTypeSymbol? result;\n                (AssemblySymbol, AssemblySymbol) conflicts = default;\n\n                if (IsTypeMissing(type))\n                {\n                    result = null;\n                }\n                else\n                {\n                    // well-known types introduced before CSharp7 allow lookup ambiguity and report a warning\n                    DiagnosticBag? legacyWarnings = (type <= WellKnownType.CSharp7Sentinel) ? warnings : null;\n                    result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes);\n                }\n\n                if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                }\n\n                if (Interlocked.CompareExchange(ref _lazyWellKnownTypes[index], result, null) is object)\n                {\n                    Debug.Assert(\n                        TypeSymbol.Equals(result, _lazyWellKnownTypes[index], TypeCompareKind.ConsiderEverything2) || (_lazyWellKnownTypes[index]!.IsErrorType() && result.IsErrorType())\n                    );\n                }\n                else\n                {\n                    AdditionalCodegenWarnings.AddRange(warnings);\n                }\n\n                warnings.Free();\n            } 441718"];
11867 [label="NamedTypeSymbol? result; 441719"];
11868 [label="(AssemblySymbol, AssemblySymbol) conflicts = default; 441720"];
11869 [label="GetBoundReferenceManager() 441721"];
11870 [label="GetBoundReferenceManager(); 441722"];
11871 [label="result = this.Assembly.GetTypeByMetadataName(\n                        mdName, includeReferences: true, useCLSCompliantNameArityEncoding: true, isWellKnownType: true, conflicts: out conflicts,\n                        warnings: legacyWarnings, ignoreCorLibraryDuplicatedTypes: ignoreCorLibraryDuplicatedTypes); 441723"];
11872 [label="param GetTypeByMetadataName(bool includeReferences) 441724"];
11873 [label="param GetTypeByMetadataName(bool isWellKnownType) 441725"];
11874 [label="param GetTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 441726"];
11875 [label="param GetTypeByMetadataName(DiagnosticBag warnings = null) 441727"];
11876 [label="param GetTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 441728"];
11877 [label="NamedTypeSymbol type; 441729"];
11878 [label="MetadataTypeName mdName; 441730"];
11879 [label="mdName 441731"];
11880 [label="param GetTopLevelTypeByMetadataName(bool includeReferences) 441732"];
11881 [label="param GetTopLevelTypeByMetadataName(bool isWellKnownType) 441733"];
11882 [label="param GetTopLevelTypeByMetadataName(out (AssemblySymbol, AssemblySymbol) conflicts) 441734"];
11883 [label="param GetTopLevelTypeByMetadataName(DiagnosticBag warnings = null) 441735"];
11884 [label="param GetTopLevelTypeByMetadataName(bool ignoreCorLibraryDuplicatedTypes = false) 441736"];
11885 [label="conflicts = default; 441737"];
11886 [label="NamedTypeSymbol result; 441738"];
11887 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 441739"];
11888 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 441740"];
11889 [label="NamedTypeSymbol result = null; 441741"];
11890 [label="NamedTypeSymbol result; 441742"];
11891 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 441743"];
11892 [label="if ((object)scope == null)\n                {\n                    break;\n                } 441744"];
11893 [label="param TopLevel(ModuleSymbol module) 441745"];
11894 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 441746"];
11895 [label="module 441747"];
11896 [label="1 441748"];
11897 [label="errorInfo 441749"];
11898 [label="param TopLevel(ModuleSymbol module) 441750"];
11899 [label="param TopLevel(int typeId) 441751"];
11900 [label="param TopLevel(DiagnosticInfo? errorInfo) 441752"];
11901 [label="module 441753"];
11902 [label="errorInfo 441754"];
11903 [label="typeId 441755"];
11904 [label="param TopLevel(ModuleSymbol module) 441756"];
11905 [label="param TopLevel(DiagnosticInfo? errorInfo) 441757"];
11906 [label="param TopLevel(int typeId) 441758"];
11907 [label="param TopLevel(this) 441759"];
11908 [label="module 441760"];
11909 [label="fullName.NamespaceName 441761"];
11910 [label="mangleName 441762"];
11911 [label="false 441763"];
11912 [label="errorInfo 441764"];
11913 [label="null 441765"];
11914 [label="typeId 441766"];
11915 [label="null 441767"];
11916 [label="param TopLevel(ModuleSymbol module) 441768"];
11917 [label="param TopLevel(string @namespace) 441769"];
11918 [label="param TopLevel(string name) 441770"];
11919 [label="param TopLevel(int arity) 441771"];
11920 [label="param TopLevel(bool mangleName) 441772"];
11921 [label="param TopLevel(bool isNativeInt) 441773"];
11922 [label="param TopLevel(DiagnosticInfo? errorInfo) 441774"];
11923 [label="param TopLevel(NamespaceSymbol? containingNamespace) 441775"];
11924 [label="param TopLevel(int typeId) 441776"];
11925 [label="param TopLevel(TupleExtraData? tupleData) 441777"];
11926 [label="param TopLevel(this) 441778"];
11927 [label="name 441779"];
11928 [label="arity 441780"];
11929 [label="mangleName 441781"];
11930 [label="tupleData 441782"];
11931 [label="param MissingMetadataTypeSymbol(string name) 441783"];
11932 [label="param MissingMetadataTypeSymbol(int arity) 441784"];
11933 [label="param MissingMetadataTypeSymbol(bool mangleName) 441785"];
11934 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 441786"];
11935 [label="param MissingMetadataTypeSymbol(this) 441787"];
11936 [label="tupleData 441788"];
11937 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 441789"];
11938 [label="_lazyTupleData 441790"];
11939 [label="name 441791"];
11940 [label="arity 441792"];
11941 [label="mangleName 441793"];
11942 [label="RoslynDebug.Assert(name != null); 441794"];
11943 [label="RoslynDebug.Assert(name != null); 441795"];
11944 [label="this.name 441796"];
11945 [label="this.arity 441797"];
11946 [label="this.mangleName = (mangleName && arity > 0); 441798"];
11947 [label="this.mangleName = (mangleName && arity > 0); 441799"];
11948 [label="this.mangleName = (mangleName && arity > 0); 441800"];
11949 [label="this.mangleName 441801"];
11950 [label="_namespaceName 441802"];
11951 [label="_containingModule 441803"];
11952 [label="_isNativeInt 441804"];
11953 [label="_lazyErrorInfo 441805"];
11954 [label="_lazyContainingNamespace 441806"];
11955 [label="_lazyTypeId 441807"];
11956 [label="RoslynDebug.Assert((object)module != null); 441808"];
11957 [label="RoslynDebug.Assert((object)module != null); 441809"];
11958 [label="RoslynDebug.Assert(@namespace != null); 441810"];
11959 [label="RoslynDebug.Assert(@namespace != null); 441811"];
11960 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 441812"];
11961 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 441813"];
11962 [label="_namespaceName 441814"];
11963 [label="_containingModule 441815"];
11964 [label="_isNativeInt 441816"];
11965 [label="_lazyErrorInfo 441817"];
11966 [label="_lazyContainingNamespace 441818"];
11967 [label="_lazyTypeId 441819"];
11968 [label="Debug.Assert((object)result != null); 441820"];
11969 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 441821"];
11970 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 441822"];
11971 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 441823"];
11972 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 441824"];
11973 [label="System.Diagnostics.Debug.Assert((object)result != null); 441825"];
11974 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 441826"];
11975 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 441827"];
11976 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 441828"];
11977 [label="candidate.Kind 441829"];
11978 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 441830"];
11979 [label="return SymbolKind.ErrorType; 441831"];
11980 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 441832"];
11981 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 441833"];
11982 [label="return null; 441834"];
11983 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 441835"];
11984 [label="IsValidWellKnownType(result) 441836"];
11985 [label="param IsValidWellKnownType(NamedTypeSymbol result) 441837"];
11986 [label="param IsValidWellKnownType(this) 441838"];
11987 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 441839"];
11988 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 441840"];
11989 [label="return false; 441841"];
11990 [label="if (isWellKnownType && !IsValidWellKnownType(result))\n            {\n                result = null;\n            } 441842"];
11991 [label="result = null; 441843"];
11992 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 441844"];
11993 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 441845"];
11994 [label="if ((object)result != null || !includeReferences)\n            {\n                return result;\n            } 441846"];
11995 [label="Debug.Assert(this is SourceAssemblySymbol,\n                'Never include references for a non-source assembly, because they don't know about aliases.'); 441847"];
11996 [label="assembly.IsMissing 441848"];
11997 [label="get\n            {\n                return false;\n            } 441849"];
11998 [label="return false; 441850"];
11999 [label="Debug.Assert(!(this is SourceAssemblySymbol && assembly.IsMissing)); 441851"];
12000 [label="param GetTopLevelTypeByMetadataName(AssemblyIdentity assemblyOpt) 441852"];
12001 [label="param LookupTopLevelMetadataTypeWithCycleDetection(ConsList<AssemblySymbol> visitedAssemblies) 441853"];
12002 [label="NamedTypeSymbol result = null; 441854"];
12003 [label="NamedTypeSymbol result; 441855"];
12004 [label="EnsureAllMembersLoaded(); 441856"];
12005 [label="if ((object)nextScope != null)\n                        {\n                            Debug.Assert((object)nextScope == null, 'Why did we run into an unmerged namespace?');\n                            nextScope = null;\n                            break;\n                        } 441857"];
12006 [label="if ((object)scope == null)\n                {\n                    break;\n                } 441858"];
12007 [label="Debug.Assert(!emittedTypeName.IsNull); 441859"];
12008 [label="scope.Kind 441860"];
12009 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441861"];
12010 [label="if (scope.Kind == SymbolKind.ErrorType)\n            {\n                return new MissingMetadataTypeSymbol.Nested((NamedTypeSymbol)scope, ref emittedTypeName);\n            } 441862"];
12011 [label="ImmutableArray<NamedTypeSymbol> namespaceOrTypeMembers; 441863"];
12012 [label="namespaceOrTypeMembers 441864"];
12013 [label="get\n            {\n                return Kind == SymbolKind.Namespace;\n            } 441865"];
12014 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441866"];
12015 [label="param ToDisplayParts(bool minimal) 441867"];
12016 [label="if (symbol == null)\n            {\n                throw new ArgumentNullException(nameof(symbol));\n            } 441868"];
12017 [label="if (minimal)\n            {\n                if (semanticModelOpt == null)\n                {\n                    throw new ArgumentException(CSharpResources.SyntaxTreeSemanticModelMust);\n                }\n                else if (positionOpt < 0 || positionOpt > semanticModelOpt.SyntaxTree.Length) // Note: not >= since EOF is allowed.\n                {\n                    throw new ArgumentOutOfRangeException(CSharpResources.PositionNotWithinTree);\n                }\n            }\n            else\n            {\n                Debug.Assert(semanticModelOpt == null);\n                Debug.Assert(positionOpt < 0);\n            } 441869"];
12018 [label="Debug.Assert(semanticModelOpt == null); 441870"];
12019 [label="Debug.Assert(positionOpt < 0); 441871"];
12020 [label="if (symbol is Symbols.PublicModel.MethodSymbol && \n                ((Symbols.PublicModel.MethodSymbol)symbol).UnderlyingMethodSymbol is SynthesizedSimpleProgramEntryPointSymbol)\n            {\n                return ImmutableArray.Create<SymbolDisplayPart>(new SymbolDisplayPart(SymbolDisplayPartKind.MethodName, symbol, '<top-level-statements-entry-point>'));\n            } 441872"];
12021 [label="if (this.IsMinimizing)\n            {\n                if (TryAddAlias(symbol, builder))\n                {\n                    return;\n                }\n\n                MinimallyQualify(symbol);\n                return;\n            } 441873"];
12022 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 441874"];
12023 [label="if (isFirstSymbolVisited && format.KindOptions.IncludesOption(SymbolDisplayKindOptions.IncludeNamespaceKeyword))\n            {\n                AddKeyword(SyntaxKind.NamespaceKeyword);\n                AddSpace();\n            } 441875"];
12024 [label="param ShouldVisitNamespace(ISymbol containingSymbol) 441876"];
12025 [label="var namespaceSymbol = containingSymbol as INamespaceSymbol; 441877"];
12026 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 441878"];
12027 [label="if (namespaceSymbol == null)\n            {\n                return false;\n            } 441879"];
12028 [label="if (format.TypeQualificationStyle != SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces)\n            {\n                return false;\n            } 441880"];
12029 [label="=> _underlying.IsGlobalNamespace 441881"];
12030 [label="get\n            {\n                return false;\n            } 441882"];
12031 [label="get\n            {\n                return true;\n            } 441883"];
12032 [label="=> _underlying.IsGlobalNamespace 441884"];
12033 [label="get\n            {\n                return false;\n            } 441885"];
12034 [label="if (emittedTypeName.IsMangled)\n            {\n                Debug.Assert(!emittedTypeName.UnmangledTypeName.Equals(emittedTypeName.TypeName) && emittedTypeName.InferredArity > 0);\n\n                if (emittedTypeName.ForcedArity == -1 || emittedTypeName.ForcedArity == emittedTypeName.InferredArity)\n                {\n                    // Let's handle mangling case first.\n                    namespaceOrTypeMembers = scope.GetTypeMembers(emittedTypeName.UnmangledTypeName);\n\n                    foreach (var named in namespaceOrTypeMembers)\n                    {\n                        if (emittedTypeName.InferredArity == named.Arity && named.MangleName)\n                        {\n                            if ((object?)namedType != null)\n                            {\n                                namedType = null;\n                                break;\n                            }\n\n                            namedType = named;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0);\n            } 441886"];
12035 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 441887"];
12036 [label="Debug.Assert(ReferenceEquals(emittedTypeName.UnmangledTypeName, emittedTypeName.TypeName) && emittedTypeName.InferredArity == 0); 441888"];
12037 [label="EnsureAllMembersLoaded(); 441889"];
12038 [label="get\n                {\n                    return false;\n                } 441890"];
12039 [label="get\n                {\n                    return 0;\n                } 441891"];
12040 [label="if ((object?)namedType != null)\n                    {\n                        namedType = null;\n                        break;\n                    } 441892"];
12041 [label="Debug.Assert((object)result != null); 441893"];
12042 [label="if (result is MissingMetadataTypeSymbol)\n                {\n                    for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    }\n                } 441894"];
12043 [label="result.ContainingAssembly 441895"];
12044 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 441896"];
12045 [label="this.ContainingSymbol 441897"];
12046 [label="get\n            {\n                return _container;\n            } 441898"];
12047 [label="return _container; 441899"];
12048 [label="var container = this.ContainingSymbol; 441900"];
12049 [label="return (object)container != null ? container.ContainingAssembly : null; 441901"];
12050 [label="return (object)container != null ? container.ContainingAssembly : null; 441902"];
12051 [label="(object)container != null 441903"];
12052 [label="container.ContainingAssembly 441904"];
12053 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 441905"];
12054 [label="ContainingPEModule 441906"];
12055 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 441907"];
12056 [label="return ContainingPEModule.ContainingAssembly; 441908"];
12057 [label="ContainingPEModule.ContainingAssembly 441909"];
12058 [label="get\n            {\n                return _assemblySymbol;\n            } 441910"];
12059 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 441911"];
12060 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 441912"];
12061 [label="System.Diagnostics.Debug.Assert((object)result != null); 441913"];
12062 [label="NamedTypeSymbol result1 = null; 441914"];
12063 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 441915"];
12064 [label="System.Diagnostics.Debug.Assert(TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2)); 441916"];
12065 [label="TypeSymbol.Equals(result1, result, TypeCompareKind.ConsiderEverything2) 441917"];
12066 [label="param Equals(TypeSymbol left) 441918"];
12067 [label="param Equals(TypeSymbol right) 441919"];
12068 [label="param Equals(TypeCompareKind comparison) 441920"];
12069 [label="if (left is null)\n            {\n                return right is null;\n            } 441921"];
12070 [label="return left.Equals(right, comparison); 441922"];
12071 [label="return left.Equals(right, comparison); 441923"];
12072 [label="left.Equals(right, comparison) 441924"];
12073 [label="param Equals(TypeSymbol t2) 441925"];
12074 [label="param Equals(TypeCompareKind comparison) 441926"];
12075 [label="param Equals(this) 441927"];
12076 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 441928"];
12077 [label="param Equals(TypeCompareKind comparison) 441929"];
12078 [label="param Equals(this) 441930"];
12079 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 441931"];
12080 [label="IsAcceptableMatchForGetTypeByMetadataName(result) 441932"];
12081 [label="param IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate) 441933"];
12082 [label="candidate.Kind 441934"];
12083 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441935"];
12084 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 441936"];
12085 [label="if (!IsAcceptableMatchForGetTypeByMetadataName(result))\n            {\n                return null;\n            } 441937"];
12086 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 441938"];
12087 [label="if (assemblyOpt != null && !assemblyOpt.Equals(assembly.Identity))\n            {\n                return null;\n            } 441939"];
12088 [label="param IsValidWellKnownType(this) 441940"];
12089 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 441941"];
12090 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 441942"];
12091 [label="s.Kind 441943"];
12092 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 441944"];
12093 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 441945"];
12094 [label="Debug.Assert((object)moduleSymbol != null); 441946"];
12095 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 441947"];
12096 [label="return baseType; 441948"];
12097 [label="result.ContainingType 441949"];
12098 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441950"];
12099 [label="return _container as NamedTypeSymbol; 441951"];
12100 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 441952"];
12101 [label="Debug.Assert((object)result.ContainingType == null || IsValidWellKnownType(result.ContainingType),\n                'Checking the containing type is the caller's responsibility.'); 441953"];
12102 [label="result.DeclaredAccessibility 441954"];
12103 [label="Accessibility access = Accessibility.Private; 441955"];
12104 [label="return result.DeclaredAccessibility == Accessibility.Public || IsSymbolAccessible(result, this); 441956"];
12105 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 441957"];
12106 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 441958"];
12107 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 441959"];
12108 [label="if ((object?)upperLevelType == null)\n            {\n                return false;\n            } 441960"];
12109 [label="upperLevelType.ContainingType 441961"];
12110 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 441962"];
12111 [label="return _container as NamedTypeSymbol; 441963"];
12112 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 441964"];
12113 [label="while ((object?)upperLevelType.ContainingType != null)\n            {\n                upperLevelType = upperLevelType.ContainingType;\n            } 441965"];
12114 [label="var result = _lazyUncommonProperties; 441966"];
12115 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 441967"];
12116 [label="if (result != null)\n            {\n#if DEBUG\n                Debug.Assert(result != s_noUncommonProperties || result.IsDefaultValue(), 'default value was modified');\n#endif\n                return result;\n            } 441968"];
12117 [label="if (uncommon == s_noUncommonProperties)\n                {\n                    return false;\n                } 441969"];
12118 [label="return uncommon.lazyHasEmbeddedAttribute.Value(); 441970"];
12119 [label="return upperLevelType.HasCodeAnalysisEmbeddedAttribute; 441971"];
12120 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 441972"];
12121 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 441973"];
12122 [label="Debug.Assert(!TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2)); 441974"];
12123 [label="TypeSymbol.Equals(candidate, result, TypeCompareKind.ConsiderEverything2) 441975"];
12124 [label="param Equals(TypeSymbol left) 441976"];
12125 [label="param Equals(TypeSymbol right) 441977"];
12126 [label="param Equals(TypeCompareKind comparison) 441978"];
12127 [label="if (left is null)\n            {\n                return right is null;\n            } 441979"];
12128 [label="return left.Equals(right, comparison); 441980"];
12129 [label="return left.Equals(right, comparison); 441981"];
12130 [label="left.Equals(right, comparison) 441982"];
12131 [label="param Equals(TypeSymbol t2) 441983"];
12132 [label="param Equals(TypeCompareKind comparison) 441984"];
12133 [label="param Equals(this) 441985"];
12134 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 441986"];
12135 [label="param Equals(TypeCompareKind comparison) 441987"];
12136 [label="param Equals(this) 441988"];
12137 [label="if ((object)t2 == null) return false; 441989"];
12138 [label="return false; 441990"];
12139 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 441991"];
12140 [label="if ((object)result != null)\n                {\n                    // duplicate\n                    if (ignoreCorLibraryDuplicatedTypes)\n                    {\n                        if (IsInCorLib(candidate))\n                        {\n                            // ignore candidate\n                            continue;\n                        }\n                        if (IsInCorLib(result))\n                        {\n                            // drop previous result\n                            result = candidate;\n                            continue;\n                        }\n                    }\n\n                    if (warnings == null)\n                    {\n                        conflicts = (result.ContainingAssembly, candidate.ContainingAssembly);\n                        result = null;\n                    }\n                    else\n                    {\n                        // The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'\n                        warnings.Add(ErrorCode.WRN_MultiplePredefTypes, NoLocation.Singleton, result, result.ContainingAssembly);\n                    }\n\n                    break;\n                } 441992"];
12141 [label="scope.ContainingModule 441993"];
12142 [label="get\n            {\n                return _containingNamespaceSymbol.ContainingPEModule;\n            } 441994"];
12143 [label="_containingNamespaceSymbol.ContainingPEModule 441995"];
12144 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 441996"];
12145 [label="return _containingNamespaceSymbol.ContainingPEModule; 441997"];
12146 [label="param TopLevel(ModuleSymbol module) 441998"];
12147 [label="param TopLevel(DiagnosticInfo? errorInfo = null) 441999"];
12148 [label="module 442000"];
12149 [label="1 442001"];
12150 [label="errorInfo 442002"];
12151 [label="param TopLevel(ModuleSymbol module) 442003"];
12152 [label="param TopLevel(int typeId) 442004"];
12153 [label="param TopLevel(DiagnosticInfo? errorInfo) 442005"];
12154 [label="module 442006"];
12155 [label="errorInfo 442007"];
12156 [label="typeId 442008"];
12157 [label="param TopLevel(ModuleSymbol module) 442009"];
12158 [label="param TopLevel(DiagnosticInfo? errorInfo) 442010"];
12159 [label="param TopLevel(int typeId) 442011"];
12160 [label="param TopLevel(this) 442012"];
12161 [label="module 442013"];
12162 [label="fullName.NamespaceName 442014"];
12163 [label="mangleName 442015"];
12164 [label="false 442016"];
12165 [label="errorInfo 442017"];
12166 [label="null 442018"];
12167 [label="typeId 442019"];
12168 [label="null 442020"];
12169 [label="param TopLevel(ModuleSymbol module) 442021"];
12170 [label="param TopLevel(string @namespace) 442022"];
12171 [label="param TopLevel(string name) 442023"];
12172 [label="param TopLevel(int arity) 442024"];
12173 [label="param TopLevel(bool mangleName) 442025"];
12174 [label="param TopLevel(bool isNativeInt) 442026"];
12175 [label="param TopLevel(DiagnosticInfo? errorInfo) 442027"];
12176 [label="param TopLevel(NamespaceSymbol? containingNamespace) 442028"];
12177 [label="param TopLevel(int typeId) 442029"];
12178 [label="param TopLevel(TupleExtraData? tupleData) 442030"];
12179 [label="param TopLevel(this) 442031"];
12180 [label="name 442032"];
12181 [label="arity 442033"];
12182 [label="mangleName 442034"];
12183 [label="tupleData 442035"];
12184 [label="param MissingMetadataTypeSymbol(string name) 442036"];
12185 [label="param MissingMetadataTypeSymbol(int arity) 442037"];
12186 [label="param MissingMetadataTypeSymbol(bool mangleName) 442038"];
12187 [label="param MissingMetadataTypeSymbol(TupleExtraData? tupleData = null) 442039"];
12188 [label="param MissingMetadataTypeSymbol(this) 442040"];
12189 [label="tupleData 442041"];
12190 [label="param ErrorTypeSymbol(TupleExtraData? tupleData = null) 442042"];
12191 [label="_lazyTupleData 442043"];
12192 [label="name 442044"];
12193 [label="arity 442045"];
12194 [label="mangleName 442046"];
12195 [label="RoslynDebug.Assert(name != null); 442047"];
12196 [label="RoslynDebug.Assert(name != null); 442048"];
12197 [label="this.name 442049"];
12198 [label="this.arity 442050"];
12199 [label="this.mangleName = (mangleName && arity > 0); 442051"];
12200 [label="this.mangleName = (mangleName && arity > 0); 442052"];
12201 [label="this.mangleName = (mangleName && arity > 0); 442053"];
12202 [label="this.mangleName 442054"];
12203 [label="_namespaceName 442055"];
12204 [label="_containingModule 442056"];
12205 [label="_isNativeInt 442057"];
12206 [label="_lazyErrorInfo 442058"];
12207 [label="_lazyContainingNamespace 442059"];
12208 [label="_lazyTypeId 442060"];
12209 [label="RoslynDebug.Assert((object)module != null); 442061"];
12210 [label="RoslynDebug.Assert((object)module != null); 442062"];
12211 [label="RoslynDebug.Assert(@namespace != null); 442063"];
12212 [label="RoslynDebug.Assert(@namespace != null); 442064"];
12213 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 442065"];
12214 [label="RoslynDebug.Assert(typeId == -1 || typeId == (int)SpecialType.None || arity == 0 || mangleName); 442066"];
12215 [label="_namespaceName 442067"];
12216 [label="_containingModule 442068"];
12217 [label="_isNativeInt 442069"];
12218 [label="_lazyErrorInfo 442070"];
12219 [label="_lazyContainingNamespace 442071"];
12220 [label="_lazyTypeId 442072"];
12221 [label="for (i = 1; i < count; i++)\n                    {\n                        var newResult = modules[i].LookupTopLevelMetadataType(ref emittedName);\n\n                        // Hold on to the first missing type result, unless we found the type.\n                        if (!(newResult is MissingMetadataTypeSymbol))\n                        {\n                            result = newResult;\n                            break;\n                        }\n                    } 442073"];
12222 [label="Debug.Assert(!foundMatchInThisAssembly || (object)result.ContainingAssembly == (object)this); 442074"];
12223 [label="if (!foundMatchInThisAssembly && digThroughForwardedTypes)\n                {\n                    // We didn't find the type\n                    System.Diagnostics.Debug.Assert(result is MissingMetadataTypeSymbol);\n\n                    NamedTypeSymbol forwarded = TryLookupForwardedMetadataTypeWithCycleDetection(ref emittedName, visitedAssemblies);\n                    if ((object)forwarded != null)\n                    {\n                        result = forwarded;\n                    }\n                } 442075"];
12224 [label="get\n            {\n                return SymbolKind.ErrorType;\n            } 442076"];
12225 [label="return SymbolKind.ErrorType; 442077"];
12226 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 442078"];
12227 [label="return candidate.Kind != SymbolKind.ErrorType || !(candidate is MissingMetadataTypeSymbol); 442079"];
12228 [label="return null; 442080"];
12229 [label="if ((object)result == null || result.TypeKind == TypeKind.Error)\n            {\n                return false;\n            } 442081"];
12230 [label="return false; 442082"];
12231 [label="if (isWellKnownType && !IsValidWellKnownType(candidate))\n                {\n                    candidate = null;\n                } 442083"];
12232 [label="candidate = null; 442084"];
12233 [label="if ((object)candidate == null)\n                {\n                    continue;\n                } 442085"];
12234 [label="return ImmutableArray<Symbol>.Empty; 442086"];
12235 [label="param TopLevel(ModuleSymbol module) 442087"];
12236 [label="module 442088"];
12237 [label="param TopLevel(ModuleSymbol module) 442089"];
12238 [label="module 442090"];
12239 [label="param TopLevel(ModuleSymbol module) 442091"];
12240 [label="module 442092"];
12241 [label="param TopLevel(ModuleSymbol module) 442093"];
12242 [label="RoslynDebug.Assert((object)module != null); 442094"];
12243 [label="_containingModule 442095"];
12244 [label="param IsErrorType(this TypeSymbol type) 442096"];
12245 [label="RoslynDebug.Assert((object)type != null); 442097"];
12246 [label="RoslynDebug.Assert((object)type != null); 442098"];
12247 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 442099"];
12248 [label="if (result is null)\n                {\n                    // TODO: should GetTypeByMetadataName rather return a missing symbol?\n                    MetadataTypeName emittedName = MetadataTypeName.FromFullName(mdName, useCLSCompliantNameArityEncoding: true);\n                    if (type.IsValueTupleType())\n                    {\n                        CSDiagnosticInfo errorInfo;\n                        if (conflicts.Item1 is null)\n                        {\n                            Debug.Assert(conflicts.Item2 is null);\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, emittedName.FullName);\n                        }\n                        else\n                        {\n                            errorInfo = new CSDiagnosticInfo(ErrorCode.ERR_PredefinedValueTupleTypeAmbiguous3, emittedName.FullName, conflicts.Item1, conflicts.Item2);\n                        }\n\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type, errorInfo);\n                    }\n                    else\n                    {\n                        result = new MissingMetadataTypeSymbol.TopLevel(this.Assembly.Modules[0], ref emittedName, type);\n                    }\n                } 442100"];
12249 [label="Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null'); 442101"];
12250 [label="Debug.Assert((object)runtimeCompatibilityAttribute != null, 'GetWellKnownType unexpectedly returned null'); 442102"];
12251 [label="if (!(runtimeCompatibilityAttribute is MissingMetadataTypeSymbol))\n                {\n                    // As in Dev10 (see GlobalAttrBind::EmitCompilerGeneratedAttrs), we only synthesize this attribute if RuntimeCompatibilityAttribute is found.\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton);\n\n                    Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton);\n                } 442103"];
12252 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 442104"];
12253 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 442105"];
12254 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 442106"];
12255 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton); 442107"];
12256 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor, diagnostics, NoLocation.Singleton) 442108"];
12257 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 442109"];
12258 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 442110"];
12259 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 442111"];
12260 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 442112"];
12261 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 442113"];
12262 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 442114"];
12263 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 442115"];
12264 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 442116"];
12265 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 442117"];
12266 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 442118"];
12267 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 442119"];
12268 [label="param GetWellKnownTypeMember(Location location = null) 442120"];
12269 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 442121"];
12270 [label="param GetWellKnownTypeMember(bool isOptional = false) 442122"];
12271 [label="Debug.Assert((syntax != null) ^ (location != null)); 442123"];
12272 [label="Debug.Assert((syntax != null) ^ (location != null)); 442124"];
12273 [label="Debug.Assert((syntax != null) ^ (location != null)); 442125"];
12274 [label="Debug.Assert((syntax != null) ^ (location != null)); 442126"];
12275 [label="DiagnosticInfo useSiteDiagnostic; 442127"];
12276 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 442128"];
12277 [label="param GetWellKnownTypeMember(bool isOptional = false) 442129"];
12278 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 442130"];
12279 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 442131"];
12280 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 442132"];
12281 [label="Debug.Assert(type.IsValid()); 442133"];
12282 [label="this.Options 442134"];
12283 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 442135"];
12284 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 442136"];
12285 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 442137"];
12286 [label="param Includes(this BinderFlags self) 442138"];
12287 [label="param Includes(BinderFlags other) 442139"];
12288 [label="return (self & other) == other; 442140"];
12289 [label="Symbol? result = null; 442141"];
12290 [label="param IsErrorType(this TypeSymbol type) 442142"];
12291 [label="RoslynDebug.Assert((object)type != null); 442143"];
12292 [label="RoslynDebug.Assert((object)type != null); 442144"];
12293 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 442145"];
12294 [label="GetBoundReferenceManager(); 442146"];
12295 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 442147"];
12296 [label="ArrayBuilder<Symbol> members = null; 442148"];
12297 [label="s.Kind 442149"];
12298 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442150"];
12299 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442151"];
12300 [label="ImmutableArray<TypeDefinitionHandle> nestedTypeDefs; 442152"];
12301 [label="nestedTypeDefs 442153"];
12302 [label="foreach (var typeRid in nestedTypeDefs)\n            {\n                if (module.ShouldImportNestedType(typeRid))\n                {\n                    yield return PENamedTypeSymbol.Create(moduleSymbol, this, typeRid);\n                }\n            } 442154"];
12303 [label="if (exchangeResult == null)\n                {\n                    // Build cache of TypeDef Tokens\n                    // Potentially this can be done in the background.\n                    var moduleSymbol = this.ContainingPEModule;\n                    moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict);\n                } 442155"];
12304 [label="this.ContainingPEModule 442156"];
12305 [label="s.Kind 442157"];
12306 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442158"];
12307 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442159"];
12308 [label="var moduleSymbol = this.ContainingPEModule; 442160"];
12309 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 442161"];
12310 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict) 442162"];
12311 [label="param OnNewTypeDeclarationsLoaded(Dictionary<string, ImmutableArray<PENamedTypeSymbol>> typesDict) 442163"];
12312 [label="param OnNewTypeDeclarationsLoaded(this) 442164"];
12313 [label="moduleSymbol.OnNewTypeDeclarationsLoaded(typesDict); 442165"];
12314 [label="types.Free(); 442166"];
12315 [label="EnsureNestedTypesAreLoaded(); 442167"];
12316 [label="Debug.Assert(SymbolKind.Field.ToSortOrder() < SymbolKind.Method.ToSortOrder()); 442168"];
12317 [label="Debug.Assert(SymbolKind.Method.ToSortOrder() < SymbolKind.Property.ToSortOrder()); 442169"];
12318 [label="Debug.Assert(SymbolKind.Property.ToSortOrder() < SymbolKind.Event.ToSortOrder()); 442170"];
12319 [label="Debug.Assert(SymbolKind.Event.ToSortOrder() < SymbolKind.NamedType.ToSortOrder()); 442171"];
12320 [label="ArrayBuilder<PEFieldSymbol> fieldMembers = ArrayBuilder<PEFieldSymbol>.GetInstance(); 442172"];
12321 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 442173"];
12322 [label="param CreateFields(ArrayBuilder<PEFieldSymbol> fieldMembers) 442174"];
12323 [label="var privateFieldNameToSymbols = new MultiDictionary<string, PEFieldSymbol>(); 442175"];
12324 [label="var isOrdinaryStruct = false; 442176"];
12325 [label="var isOrdinaryEmbeddableStruct = false; 442177"];
12326 [label="this.TypeKind 442178"];
12327 [label="if (this.TypeKind == TypeKind.Struct)\n            {\n                if (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.None)\n                {\n                    isOrdinaryStruct = true;\n                    isOrdinaryEmbeddableStruct = this.ContainingAssembly.IsLinked;\n                }\n                else\n                {\n                    isOrdinaryStruct = (this.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Nullable_T);\n                }\n            } 442179"];
12328 [label="return privateFieldNameToSymbols; 442180"];
12329 [label="MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols = this.CreateFields(fieldMembers); 442181"];
12330 [label="_containingType 442182"];
12331 [label="_flags 442183"];
12332 [label="_implFlags 442184"];
12333 [label="Debug.Assert((object)moduleSymbol != null); 442185"];
12334 [label="Debug.Assert((object)containingType != null); 442186"];
12335 [label="Debug.Assert(!methodDef.IsNil); 442187"];
12336 [label="Debug.Assert((uint)implFlags <= ushort.MaxValue); 442188"];
12337 [label="Debug.Assert((uint)localflags <= ushort.MaxValue); 442189"];
12338 [label="map.Add(methodHandle, method); 442190"];
12339 [label="map.Add(methodHandle, method); 442191"];
12340 [label="Debug.Assert(!methodDef.IsNil); 442192"];
12341 [label="this.TypeKind 442193"];
12342 [label="TypeKind result = _lazyKind; 442194"];
12343 [label="if (this.TypeKind == TypeKind.Struct)\n                    {\n                        bool haveParameterlessConstructor = false;\n                        foreach (MethodSymbol method in nonFieldMembers)\n                        {\n                            if (method.IsParameterlessConstructor())\n                            {\n                                haveParameterlessConstructor = true;\n                                break;\n                            }\n                        }\n\n                        // Structs have an implicit parameterless constructor, even if it\n                        // does not appear in metadata (11.3.8)\n                        if (!haveParameterlessConstructor)\n                        {\n                            nonFieldMembers.Insert(0, new SynthesizedInstanceConstructor(this));\n                        }\n                    } 442195"];
12344 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442196"];
12345 [label="param GetAccessorMethod(PEModule module) 442197"];
12346 [label="param GetAccessorMethod(this) 442198"];
12347 [label="Debug.Assert(found || !module.ShouldImportMethod(methodDef, this.ContainingPEModule.ImportOptions)); 442199"];
12348 [label="Debug.Assert((object)moduleSymbol != null); 442200"];
12349 [label="Debug.Assert((object)containingType != null); 442201"];
12350 [label="Debug.Assert(!handle.IsNil); 442202"];
12351 [label="Debug.Assert((object)moduleSymbol != null); 442203"];
12352 [label="param GetSpecialType(this) 442204"];
12353 [label="this.Modules 442205"];
12354 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 442206"];
12355 [label="module.GetReferencedAssemblies() 442207"];
12356 [label="param GetReferencedAssemblies(this) 442208"];
12357 [label="AssertReferencesInitialized() 442209"];
12358 [label="param AssertReferencesInitialized(this) 442210"];
12359 [label="Debug.Assert(_moduleReferences != null); 442211"];
12360 [label="Debug.Assert(_moduleReferences != null); 442212"];
12361 [label="AssertReferencesInitialized(); 442213"];
12362 [label="return _moduleReferences.Identities; 442214"];
12363 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442215"];
12364 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442216"];
12365 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 442217"];
12366 [label="Debug.Assert(propertyParams.Length > 0); 442218"];
12367 [label="_containingType 442219"];
12368 [label="_refKind 442220"];
12369 [label="_getMethod 442221"];
12370 [label="_setMethod 442222"];
12371 [label="BadImageFormatException mrEx = null; 442223"];
12372 [label="BadImageFormatException setEx = null; 442224"];
12373 [label="setMethod.Handle 442225"];
12374 [label="var setMethodParams = (object)setMethod == null ? null : metadataDecoder.GetSignatureForMethod(setMethod.Handle, out unusedCallingConvention, out setEx); 442226"];
12375 [label="param GetSpecialType(this) 442227"];
12376 [label="this.Modules 442228"];
12377 [label="get\n            {\n                return _modules;\n            } 442229"];
12378 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 442230"];
12379 [label="module.GetReferencedAssemblies() 442231"];
12380 [label="param GetReferencedAssemblies(this) 442232"];
12381 [label="AssertReferencesInitialized() 442233"];
12382 [label="param AssertReferencesInitialized(this) 442234"];
12383 [label="Debug.Assert(_moduleReferences != null); 442235"];
12384 [label="Debug.Assert(_moduleReferences != null); 442236"];
12385 [label="AssertReferencesInitialized(); 442237"];
12386 [label="return _moduleReferences.Identities; 442238"];
12387 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442239"];
12388 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442240"];
12389 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 442241"];
12390 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 442242"];
12391 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 442243"];
12392 [label="bool isBad; 442244"];
12393 [label="_parameters = setMethodParams is null\n                ? GetParameters(moduleSymbol, this, getMethod, propertyParams, getMethodParams, out isBad)\n                : GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad); 442245"];
12394 [label="GetParameters(moduleSymbol, this, setMethod, propertyParams, setMethodParams, out isBad) 442246"];
12395 [label="param GetParameters(PEModuleSymbol moduleSymbol) 442247"];
12396 [label="param GetParameters(PEPropertySymbol property) 442248"];
12397 [label="param GetParameters(PEMethodSymbol accessor) 442249"];
12398 [label="param GetParameters(ParamInfo<TypeSymbol>[] accessorParams) 442250"];
12399 [label="param GetParameters(out bool anyParameterIsBad) 442251"];
12400 [label="anyParameterIsBad = false; 442252"];
12401 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 442253"];
12402 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 442254"];
12403 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 442255"];
12404 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 442256"];
12405 [label="if (getEx != null || setEx != null || mrEx != null || isBad)\n            {\n                _lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n            } 442257"];
12406 [label="param TransformType(int targetSymbolCustomModifierCount) 442258"];
12407 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 442259"];
12408 [label="Debug.Assert((object)metadataType != null); 442260"];
12409 [label="Debug.Assert((object)metadataType != null); 442261"];
12410 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 442262"];
12411 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 442263"];
12412 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 442264"];
12413 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 442265"];
12414 [label="type.SpecialType 442266"];
12415 [label="get\n            {\n                return _corTypeId;\n            } 442267"];
12416 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 442268"];
12417 [label="result = null; 442269"];
12418 [label="return type.TryAsDynamicIfNoPia(containingType, out TypeSymbol? result) ? result : type; 442270"];
12419 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 442271"];
12420 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 442272"];
12421 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 442273"];
12422 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 442274"];
12423 [label="typeSymbol.IsNullableType() 442275"];
12424 [label="param IsNullableType(this TypeSymbol type) 442276"];
12425 [label="type.OriginalDefinition 442277"];
12426 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 442278"];
12427 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 442279"];
12428 [label="type.OriginalDefinition.SpecialType 442280"];
12429 [label="get\n            {\n                return _corTypeId;\n            } 442281"];
12430 [label="var a1 = defaultType is null; 442282"];
12431 [label="!a1 442283"];
12432 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 442284"];
12433 [label="defaultType.IsNullableType() 442285"];
12434 [label="param IsNullableType(this TypeSymbol type) 442286"];
12435 [label="type.OriginalDefinition 442287"];
12436 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 442288"];
12437 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 442289"];
12438 [label="type.OriginalDefinition.SpecialType 442290"];
12439 [label="get\n            {\n                return _corTypeId;\n            } 442291"];
12440 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 442292"];
12441 [label="Debug.Assert(a1 || a2 != true || a3); 442293"];
12442 [label="Debug.Assert(a1 || a2 != true || a3); 442294"];
12443 [label="Debug.Assert(extensions != null); 442295"];
12444 [label="Debug.Assert(extensions != null); 442296"];
12445 [label="metadataType.HasType 442297"];
12446 [label="=> !(DefaultType is null) 442298"];
12447 [label="DefaultType is null 442299"];
12448 [label="!(DefaultType is null) 442300"];
12449 [label="Debug.Assert(metadataType.HasType); 442301"];
12450 [label="Debug.Assert(accessSymbol.IsDefinition); 442302"];
12451 [label="s.Kind 442303"];
12452 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442304"];
12453 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442305"];
12454 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 442306"];
12455 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 442307"];
12456 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 442308"];
12457 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 442309"];
12458 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 442310"];
12459 [label="Debug.Assert(symbol is object); 442311"];
12460 [label="symbol.Kind 442312"];
12461 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 442313"];
12462 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 442314"];
12463 [label="isInternal = false; 442315"];
12464 [label="symbol.DeclaredAccessibility 442316"];
12465 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 442317"];
12466 [label="Accessibility access = Accessibility.Private; 442318"];
12467 [label="switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                } 442319"];
12468 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 442320"];
12469 [label="symbol.ContainingType 442321"];
12470 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 442322"];
12471 [label="return _container as NamedTypeSymbol; 442323"];
12472 [label="symbol = symbol.ContainingType; 442324"];
12473 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 442325"];
12474 [label="return true; 442326"];
12475 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 442327"];
12476 [label="param TryGetByte(out byte? value) 442328"];
12477 [label="value = null; 442329"];
12478 [label="s.Kind 442330"];
12479 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442331"];
12480 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442332"];
12481 [label="param GetLocalNullableContextValue(this) 442333"];
12482 [label="get\n            {\n                return _moduleSymbol;\n            } 442334"];
12483 [label="return _moduleSymbol; 442335"];
12484 [label="param GetLocalNullableContextValue(this) 442336"];
12485 [label="get\n            {\n                return _assemblySymbol;\n            } 442337"];
12486 [label="return _assemblySymbol; 442338"];
12487 [label="param GetLocalNullableContextValue(this) 442339"];
12488 [label="get\n            {\n                return null;\n            } 442340"];
12489 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return TypeWithAnnotations.Create(new UnsupportedMetadataTypeSymbol());\n            } 442341"];
12490 [label="=> defaultType 442342"];
12491 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 442343"];
12492 [label="_elementNames 442344"];
12493 [label="elementNames.IsDefault 442345"];
12494 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 442346"];
12495 [label="_namesIndex 442347"];
12496 [label="_foundUsableErrorType = false; 442348"];
12497 [label="_foundUsableErrorType 442349"];
12498 [label="param DecodeType(this) 442350"];
12499 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 442351"];
12500 [label="param DecodeNamedType(this) 442352"];
12501 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 442353"];
12502 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 442354"];
12503 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 442355"];
12504 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 442356"];
12505 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 442357"];
12506 [label="DecodeTypeArguments(typeArgs) 442358"];
12507 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 442359"];
12508 [label="param DecodeTypeArguments(this) 442360"];
12509 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 442361"];
12510 [label="return typeArgs; 442362"];
12511 [label="type.ContainingType 442363"];
12512 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 442364"];
12513 [label="return _container as NamedTypeSymbol; 442365"];
12514 [label="NamedTypeSymbol containingType = type.ContainingType; 442366"];
12515 [label="NamedTypeSymbol? decodedContainingType; 442367"];
12516 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 442368"];
12517 [label="decodedContainingType = containingType; 442369"];
12518 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 442370"];
12519 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 442371"];
12520 [label="var typeArgsChanged = typeArgs != decodedArgs; 442372"];
12521 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 442373"];
12522 [label="decodedType.IsTupleType 442374"];
12523 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 442375"];
12524 [label="_ 442376"];
12525 [label="tupleCardinality: out _ 442377"];
12526 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 442378"];
12527 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 442379"];
12528 [label="param IsTupleTypeOfCardinality(this) 442380"];
12529 [label="IsUnboundGenericType 442381"];
12530 [label="get\n            {\n                return false;\n            } 442382"];
12531 [label="return false; 442383"];
12532 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442384"];
12533 [label="ContainingSymbol 442385"];
12534 [label="get\n            {\n                return _container;\n            } 442386"];
12535 [label="return _container; 442387"];
12536 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442388"];
12537 [label=".Kind 442389"];
12538 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442390"];
12539 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442391"];
12540 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442392"];
12541 [label="ContainingNamespace 442393"];
12542 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 442394"];
12543 [label="get\n            {\n                return _container;\n            } 442395"];
12544 [label="return _container; 442396"];
12545 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442397"];
12546 [label="ContainingNamespace.ContainingNamespace 442398"];
12547 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 442399"];
12548 [label=".IsGlobalNamespace 442400"];
12549 [label="get\n            {\n                return true;\n            } 442401"];
12550 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442402"];
12551 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442403"];
12552 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442404"];
12553 [label="Name 442405"];
12554 [label="get\n            {\n                return _name;\n            } 442406"];
12555 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442407"];
12556 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442408"];
12557 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442409"];
12558 [label="tupleCardinality = 0; 442410"];
12559 [label="return false; 442411"];
12560 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 442412"];
12561 [label="param DoSignaturesMatch(PEModule module) 442413"];
12562 [label="param DoSignaturesMatch(PEMethodSymbol getMethod) 442414"];
12563 [label="param DoSignaturesMatch(PEMethodSymbol setMethod) 442415"];
12564 [label="param DoSignaturesMatch(ParamInfo<TypeSymbol>[] setMethodParams) 442416"];
12565 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 442417"];
12566 [label="Debug.Assert((getMethodParams == null) == ((object)getMethod == null)); 442418"];
12567 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 442419"];
12568 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 442420"];
12569 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 442421"];
12570 [label="Debug.Assert((setMethodParams == null) == ((object)setMethod == null)); 442422"];
12571 [label="bool hasGetMethod = getMethodParams != null; 442423"];
12572 [label="bool hasSetMethod = setMethodParams != null; 442424"];
12573 [label="bool hasSetMethod = setMethodParams != null; 442425"];
12574 [label="param Equals(TypeCompareKind compareKind) 442426"];
12575 [label="param Equals(TypeCompareKind compareKind) 442427"];
12576 [label="if (t2 is null)\n            {\n                return false;\n            } 442428"];
12577 [label="param Equals(TypeCompareKind comparison) 442429"];
12578 [label="param Equals(TypeCompareKind comparison) 442430"];
12579 [label="if (hasGetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, getMethodParams, comparingToSetter: false, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442431"];
12580 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442432"];
12581 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442433"];
12582 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442434"];
12583 [label="param GetPrimitiveTypeCode(PEModuleSymbol moduleSymbol) 442435"];
12584 [label="param GetPrimitiveTypeCode(TypeSymbol type) 442436"];
12585 [label="param GetPrimitiveTypeCode(this) 442437"];
12586 [label="type.PrimitiveTypeCode 442438"];
12587 [label="=> TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 442439"];
12588 [label="TypeKind 442440"];
12589 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 442441"];
12590 [label="TypeKind switch\n            {\n                TypeKind.Pointer => Microsoft.Cci.PrimitiveTypeCode.Pointer,\n                TypeKind.FunctionPointer => Microsoft.Cci.PrimitiveTypeCode.FunctionPointer,\n                _ => SpecialTypes.GetTypeCode(SpecialType)\n            } 442442"];
12591 [label="SpecialType 442443"];
12592 [label="SpecialTypes.GetTypeCode(SpecialType) 442444"];
12593 [label="return type.PrimitiveTypeCode; 442445"];
12594 [label="param Equals(TypeCompareKind compareKind) 442446"];
12595 [label="if (t2 is null)\n            {\n                return false;\n            } 442447"];
12596 [label="param Equals(TypeCompareKind comparison) 442448"];
12597 [label="param Equals(TypeCompareKind comparison) 442449"];
12598 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442450"];
12599 [label="if (hasSetMethod && !metadataDecoder.DoPropertySignaturesMatch(propertyParams, setMethodParams, comparingToSetter: true, compareParamByRef: true, compareReturnType: true))\n            {\n                return false;\n            } 442451"];
12600 [label="if (hasGetMethod && hasSetMethod)\n            {\n                var lastPropertyParamIndex = propertyParams.Length - 1;\n                var getHandle = getMethodParams[lastPropertyParamIndex].Handle;\n                var setHandle = setMethodParams[lastPropertyParamIndex].Handle;\n                var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle);\n                var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle);\n                if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                }\n\n                if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                }\n            } 442452"];
12601 [label="var lastPropertyParamIndex = propertyParams.Length - 1; 442453"];
12602 [label="var lastPropertyParamIndex = propertyParams.Length - 1; 442454"];
12603 [label="var getHandle = getMethodParams[lastPropertyParamIndex].Handle; 442455"];
12604 [label="var setHandle = setMethodParams[lastPropertyParamIndex].Handle; 442456"];
12605 [label="var getterHasParamArray = !getHandle.IsNil && module.HasParamsAttribute(getHandle); 442457"];
12606 [label="var setterHasParamArray = !setHandle.IsNil && module.HasParamsAttribute(setHandle); 442458"];
12607 [label="if (getterHasParamArray != setterHasParamArray)\n                {\n                    return false;\n                } 442459"];
12608 [label="getMethod.IsExtern 442460"];
12609 [label="=> HasFlag(MethodAttributes.PinvokeImpl) 442461"];
12610 [label="MethodAttributes.PinvokeImpl 442462"];
12611 [label="HasFlag(MethodAttributes.PinvokeImpl) 442463"];
12612 [label="param HasFlag(MethodAttributes flag) 442464"];
12613 [label="param HasFlag(this) 442465"];
12614 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442466"];
12615 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442467"];
12616 [label="return ((ushort)flag & _flags) != 0; 442468"];
12617 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442469"];
12618 [label="setMethod.IsExtern 442470"];
12619 [label="=> HasFlag(MethodAttributes.PinvokeImpl) 442471"];
12620 [label="MethodAttributes.PinvokeImpl 442472"];
12621 [label="HasFlag(MethodAttributes.PinvokeImpl) 442473"];
12622 [label="param HasFlag(MethodAttributes flag) 442474"];
12623 [label="param HasFlag(this) 442475"];
12624 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442476"];
12625 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442477"];
12626 [label="return ((ushort)flag & _flags) != 0; 442478"];
12627 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442479"];
12628 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442480"];
12629 [label="getMethod.IsSealed 442481"];
12630 [label="=> this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 442482"];
12631 [label="this.IsMetadataFinal 442483"];
12632 [label="=> HasFlag(MethodAttributes.Final) 442484"];
12633 [label="MethodAttributes.Final 442485"];
12634 [label="HasFlag(MethodAttributes.Final) 442486"];
12635 [label="param HasFlag(MethodAttributes flag) 442487"];
12636 [label="param HasFlag(this) 442488"];
12637 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442489"];
12638 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442490"];
12639 [label="return ((ushort)flag & _flags) != 0; 442491"];
12640 [label="this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 442492"];
12641 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442493"];
12642 [label="setMethod.IsSealed 442494"];
12643 [label="=> this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 442495"];
12644 [label="this.IsMetadataFinal 442496"];
12645 [label="=> HasFlag(MethodAttributes.Final) 442497"];
12646 [label="MethodAttributes.Final 442498"];
12647 [label="HasFlag(MethodAttributes.Final) 442499"];
12648 [label="param HasFlag(MethodAttributes flag) 442500"];
12649 [label="param HasFlag(this) 442501"];
12650 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442502"];
12651 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442503"];
12652 [label="return ((ushort)flag & _flags) != 0; 442504"];
12653 [label="this.IsMetadataFinal &&\n                                         (this._containingType.IsInterface ?\n                                            this.IsAbstract && this.IsMetadataVirtual() && !this.IsMetadataNewSlot() :\n                                            !this.IsAbstract && this.IsOverride) 442505"];
12654 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442506"];
12655 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442507"];
12656 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442508"];
12657 [label="getMethod.IsOverride 442509"];
12658 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442510"];
12659 [label="this._containingType.IsInterface 442511"];
12660 [label="get\n            {\n                return _flags.IsInterface();\n            } 442512"];
12661 [label="this.IsMetadataVirtual() 442513"];
12662 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 442514"];
12663 [label="=> HasFlag(MethodAttributes.Virtual) 442515"];
12664 [label="MethodAttributes.Virtual 442516"];
12665 [label="HasFlag(MethodAttributes.Virtual) 442517"];
12666 [label="param HasFlag(MethodAttributes flag) 442518"];
12667 [label="param HasFlag(this) 442519"];
12668 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442520"];
12669 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442521"];
12670 [label="return ((ushort)flag & _flags) != 0; 442522"];
12671 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 442523"];
12672 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 442524"];
12673 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442525"];
12674 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442526"];
12675 [label="setMethod.IsOverride 442527"];
12676 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442528"];
12677 [label="this._containingType.IsInterface 442529"];
12678 [label="get\n            {\n                return _flags.IsInterface();\n            } 442530"];
12679 [label="this.IsMetadataVirtual() 442531"];
12680 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 442532"];
12681 [label="=> HasFlag(MethodAttributes.Virtual) 442533"];
12682 [label="MethodAttributes.Virtual 442534"];
12683 [label="HasFlag(MethodAttributes.Virtual) 442535"];
12684 [label="param HasFlag(MethodAttributes flag) 442536"];
12685 [label="param HasFlag(this) 442537"];
12686 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442538"];
12687 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442539"];
12688 [label="return ((ushort)flag & _flags) != 0; 442540"];
12689 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 442541"];
12690 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 442542"];
12691 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442543"];
12692 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442544"];
12693 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442545"];
12694 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442546"];
12695 [label="getMethod.IsStatic 442547"];
12696 [label="=> HasFlag(MethodAttributes.Static) 442548"];
12697 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442549"];
12698 [label="return ((ushort)flag & _flags) != 0; 442550"];
12699 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442551"];
12700 [label="setMethod.IsStatic 442552"];
12701 [label="=> HasFlag(MethodAttributes.Static) 442553"];
12702 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442554"];
12703 [label="return ((ushort)flag & _flags) != 0; 442555"];
12704 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442556"];
12705 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442557"];
12706 [label="if ((getMethod.IsExtern != setMethod.IsExtern) ||\n                    // (getMethod.IsAbstract != setMethod.IsAbstract) || // NOTE: Dev10 accepts one abstract accessor\n                    (getMethod.IsSealed != setMethod.IsSealed) ||\n                    (getMethod.IsOverride != setMethod.IsOverride) ||\n                    (getMethod.IsStatic != setMethod.IsStatic))\n                {\n                    return false;\n                } 442558"];
12707 [label="bool callMethodsDirectly = !DoSignaturesMatch(module, metadataDecoder, propertyParams, _getMethod, getMethodParams, _setMethod, setMethodParams) ||\n                MustCallMethodsDirectlyCore() ||\n                anyUnexpectedRequiredModifiers(propertyParams); 442559"];
12708 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 442560"];
12709 [label="propertyOrEventSymbol.ContainingType 442561"];
12710 [label="get\n            {\n                return _containingType;\n            } 442562"];
12711 [label="return _containingType; 442563"];
12712 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442564"];
12713 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442565"];
12714 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442566"];
12715 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 442567"];
12716 [label="param Equals(TypeSymbol left) 442568"];
12717 [label="param Equals(TypeSymbol right) 442569"];
12718 [label="param Equals(TypeCompareKind comparison) 442570"];
12719 [label="if (left is null)\n            {\n                return right is null;\n            } 442571"];
12720 [label="return left.Equals(right, comparison); 442572"];
12721 [label="return left.Equals(right, comparison); 442573"];
12722 [label="left.Equals(right, comparison) 442574"];
12723 [label="param Equals(TypeSymbol t2) 442575"];
12724 [label="param Equals(TypeCompareKind comparison) 442576"];
12725 [label="param Equals(this) 442577"];
12726 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 442578"];
12727 [label="param Equals(TypeCompareKind comparison) 442579"];
12728 [label="param Equals(this) 442580"];
12729 [label="_packedFlags.MethodKind 442581"];
12730 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 442582"];
12731 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 442583"];
12732 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 442584"];
12733 [label="return true; 442585"];
12734 [label="if ((object)_setMethod != null)\n                {\n                    _setMethod.SetAssociatedProperty(this, MethodKind.PropertySet);\n                } 442586"];
12735 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 442587"];
12736 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 442588"];
12737 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet) 442589"];
12738 [label="param SetAssociatedProperty(PEPropertySymbol propertySymbol) 442590"];
12739 [label="param SetAssociatedProperty(MethodKind methodKind) 442591"];
12740 [label="Debug.Assert((methodKind == MethodKind.PropertyGet) || (methodKind == MethodKind.PropertySet)); 442592"];
12741 [label="propertyOrEventSymbol.ContainingType 442593"];
12742 [label="get\n            {\n                return _containingType;\n            } 442594"];
12743 [label="return _containingType; 442595"];
12744 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442596"];
12745 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442597"];
12746 [label="Debug.Assert(TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2)); 442598"];
12747 [label="TypeSymbol.Equals(propertyOrEventSymbol.ContainingType, _containingType, TypeCompareKind.ConsiderEverything2) 442599"];
12748 [label="param Equals(TypeSymbol left) 442600"];
12749 [label="param Equals(TypeSymbol right) 442601"];
12750 [label="param Equals(TypeCompareKind comparison) 442602"];
12751 [label="if (left is null)\n            {\n                return right is null;\n            } 442603"];
12752 [label="return left.Equals(right, comparison); 442604"];
12753 [label="return left.Equals(right, comparison); 442605"];
12754 [label="left.Equals(right, comparison) 442606"];
12755 [label="param Equals(TypeSymbol t2) 442607"];
12756 [label="param Equals(TypeCompareKind comparison) 442608"];
12757 [label="param Equals(this) 442609"];
12758 [label="return t2 is NativeIntegerTypeSymbol nativeInteger ?\n                    nativeInteger.Equals(this, comparison) :\n                    base.Equals(t2, comparison); 442610"];
12759 [label="param Equals(TypeCompareKind comparison) 442611"];
12760 [label="param Equals(this) 442612"];
12761 [label="_packedFlags.MethodKind 442613"];
12762 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 442614"];
12763 [label="Debug.Assert(\n                    _packedFlags.MethodKind == default(MethodKind) ||\n                    _packedFlags.MethodKind == MethodKind.Ordinary ||\n                    _packedFlags.MethodKind == MethodKind.ExplicitInterfaceImplementation); 442615"];
12764 [label="Debug.Assert((int)value == ((int)value & MethodKindMask)); 442616"];
12765 [label="return true; 442617"];
12766 [label="_setMethod.SetAssociatedProperty(this, MethodKind.PropertySet); 442618"];
12767 [label="if (callMethodsDirectly)\n            {\n                _flags |= Flags.CallMethodsDirectly;\n            } 442619"];
12768 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 442620"];
12769 [label="if ((mdFlags & PropertyAttributes.SpecialName) != 0)\n            {\n                _flags |= Flags.IsSpecialName;\n            } 442621"];
12770 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 442622"];
12771 [label="if ((mdFlags & PropertyAttributes.RTSpecialName) != 0)\n            {\n                _flags |= Flags.IsRuntimeSpecialName;\n            } 442623"];
12772 [label="result.RefKind 442624"];
12773 [label="return _refKind; 442625"];
12774 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 442626"];
12775 [label="result.RefCustomModifiers 442627"];
12776 [label="get { return ImmutableArray<CustomModifier>.Empty; } 442628"];
12777 [label="return ImmutableArray<CustomModifier>.Empty; 442629"];
12778 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 442630"];
12779 [label="result.RefCustomModifiers.HasInAttributeModifier() 442631"];
12780 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 442632"];
12781 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 442633"];
12782 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 442634"];
12783 [label="var isBad = (result.RefKind == RefKind.In) != result.RefCustomModifiers.HasInAttributeModifier(); 442635"];
12784 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 442636"];
12785 [label="if (propEx != null || isBad)\n            {\n                result._lazyUseSiteDiagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, result);\n            } 442637"];
12786 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 442638"];
12787 [label="this.CreateEvents(privateFieldNameToSymbols, methodHandleToSymbol, nonFieldMembers); 442639"];
12788 [label="param CreateEvents(MultiDictionary<string, PEFieldSymbol> privateFieldNameToSymbols) 442640"];
12789 [label="param CreateEvents(Dictionary<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol) 442641"];
12790 [label="param CreateEvents(ArrayBuilder<Symbol> members) 442642"];
12791 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442643"];
12792 [label="foreach (PEFieldSymbol field in fieldMembers)\n                    {\n                        if ((object)field.AssociatedSymbol == null)\n                        {\n                            members.Add(field);\n                        }\n                        else\n                        {\n                            // As for source symbols, our public API presents the fiction that all\n                            // operations are performed on the event, rather than on the backing field.  \n                            // The backing field is not accessible through the API.  As an additional \n                            // bonus, lookup is easier when the names don't collide.\n                            Debug.Assert(field.AssociatedSymbol.Kind == SymbolKind.Event);\n                        }\n                    } 442644"];
12793 [label="fieldMembers.Free(); 442645"];
12794 [label="foreach (var typeArray in _lazyNestedTypes.Values)\n                {\n                    members.AddRange(typeArray);\n                } 442646"];
12795 [label="Symbol previous = null; 442647"];
12796 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 442648"];
12797 [label="foreach (var s in members)\n                {\n                    if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    }\n                } 442649"];
12798 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 442650"];
12799 [label="previous == null 442651"];
12800 [label="param ==(Symbol left) 442652"];
12801 [label="param ==(Symbol right) 442653"];
12802 [label="if (right is null)\n            {\n                return left is null;\n            } 442654"];
12803 [label="return left is null; 442655"];
12804 [label="if (previous == null)\n                    {\n                        previous = s;\n                    }\n                    else\n                    {\n                        Symbol current = s;\n                        Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder());\n                        previous = current;\n                    } 442656"];
12805 [label="previous = s; 442657"];
12806 [label="param ==(Symbol left) 442658"];
12807 [label="return left is null; 442659"];
12808 [label="Symbol current = s; 442660"];
12809 [label="previous.Kind 442661"];
12810 [label="get\n            {\n                return SymbolKind.Method;\n            } 442662"];
12811 [label="return SymbolKind.Method; 442663"];
12812 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442664"];
12813 [label="current.Kind 442665"];
12814 [label="get\n            {\n                return SymbolKind.Method;\n            } 442666"];
12815 [label="return SymbolKind.Method; 442667"];
12816 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442668"];
12817 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442669"];
12818 [label="previous = current; 442670"];
12819 [label="param ==(Symbol left) 442671"];
12820 [label="return left is null; 442672"];
12821 [label="previous.Kind 442673"];
12822 [label="get\n            {\n                return SymbolKind.Method;\n            } 442674"];
12823 [label="return SymbolKind.Method; 442675"];
12824 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442676"];
12825 [label="current.Kind 442677"];
12826 [label="get\n            {\n                return SymbolKind.Method;\n            } 442678"];
12827 [label="return SymbolKind.Method; 442679"];
12828 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442680"];
12829 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442681"];
12830 [label="get\n            {\n                return SymbolKind.Property;\n            } 442682"];
12831 [label="return SymbolKind.Property; 442683"];
12832 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442684"];
12833 [label="Debug.Assert(previous.Kind.ToSortOrder() <= current.Kind.ToSortOrder()); 442685"];
12834 [label="IsTupleType 442686"];
12835 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 442687"];
12836 [label="_ 442688"];
12837 [label="tupleCardinality: out _ 442689"];
12838 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 442690"];
12839 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 442691"];
12840 [label="param IsTupleTypeOfCardinality(this) 442692"];
12841 [label="IsUnboundGenericType 442693"];
12842 [label="get\n            {\n                return false;\n            } 442694"];
12843 [label="return false; 442695"];
12844 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442696"];
12845 [label="ContainingSymbol 442697"];
12846 [label="get\n            {\n                return _container;\n            } 442698"];
12847 [label="return _container; 442699"];
12848 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442700"];
12849 [label=".Kind 442701"];
12850 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442702"];
12851 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442703"];
12852 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442704"];
12853 [label="ContainingNamespace 442705"];
12854 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 442706"];
12855 [label="get\n            {\n                return _container;\n            } 442707"];
12856 [label="return _container; 442708"];
12857 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442709"];
12858 [label="ContainingNamespace.ContainingNamespace 442710"];
12859 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 442711"];
12860 [label=".IsGlobalNamespace 442712"];
12861 [label="get\n            {\n                return false;\n            } 442713"];
12862 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442714"];
12863 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442715"];
12864 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 442716"];
12865 [label="tupleCardinality = 0; 442717"];
12866 [label="return false; 442718"];
12867 [label="if (IsTupleType)\n                {\n                    members = AddOrWrapTupleMembers(members.ToImmutableAndFree());\n                    Debug.Assert(members is object);\n                } 442719"];
12868 [label="if (members == null)\n                {\n                    members = ArrayBuilder<Symbol>.GetInstance();\n                    foreach (var member in _lazyMembersInDeclarationOrder)\n                    {\n                        if (member.Kind == SymbolKind.NamedType)\n                        {\n                            break;\n                        }\n                        members.Add(member);\n                    }\n                } 442720"];
12869 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 442721"];
12870 [label="this.ParameterCount 442722"];
12871 [label="get\n            {\n                return this.Parameters.Length;\n            } 442723"];
12872 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 442724"];
12873 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 442725"];
12874 [label="LoadMembers(); 442726"];
12875 [label="EnsureAllMembersAreLoaded(); 442727"];
12876 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 442728"];
12877 [label="SymbolKind targetSymbolKind; 442729"];
12878 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 442730"];
12879 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 442731"];
12880 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 442732"];
12881 [label="Symbol? result = null; 442733"];
12882 [label="targetMethodKind = MethodKind.Constructor; 442734"];
12883 [label="Debug.Assert(!isStatic); 442735"];
12884 [label="member.Name 442736"];
12885 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 442737"];
12886 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 442738"];
12887 [label="member.Kind 442739"];
12888 [label="get\n            {\n                return SymbolKind.Method;\n            } 442740"];
12889 [label="return SymbolKind.Method; 442741"];
12890 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442742"];
12891 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442743"];
12892 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442744"];
12893 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442745"];
12894 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442746"];
12895 [label="member.DeclaredAccessibility 442747"];
12896 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 442748"];
12897 [label="Flags 442749"];
12898 [label="=> (MethodAttributes)_flags 442750"];
12899 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 442751"];
12900 [label="return Accessibility.Public; 442752"];
12901 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442753"];
12902 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 442754"];
12903 [label="s.Kind 442755"];
12904 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442756"];
12905 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442757"];
12906 [label="Debug.Assert((object)moduleSymbol != null); 442758"];
12907 [label="param GetSpecialType(this) 442759"];
12908 [label="this.Modules 442760"];
12909 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 442761"];
12910 [label="module.GetReferencedAssemblies() 442762"];
12911 [label="param GetReferencedAssemblies(this) 442763"];
12912 [label="AssertReferencesInitialized() 442764"];
12913 [label="param AssertReferencesInitialized(this) 442765"];
12914 [label="Debug.Assert(_moduleReferences != null); 442766"];
12915 [label="Debug.Assert(_moduleReferences != null); 442767"];
12916 [label="AssertReferencesInitialized(); 442768"];
12917 [label="return _moduleReferences.Identities; 442769"];
12918 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442770"];
12919 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 442771"];
12920 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 442772"];
12921 [label="bool makeBad = (mrEx != null); 442773"];
12922 [label="ImmutableArray<ParameterSymbol> @params; 442774"];
12923 [label="@params 442775"];
12924 [label="bool isBadParameter; 442776"];
12925 [label="@params = ImmutableArray<ParameterSymbol>.Empty; 442777"];
12926 [label="var returnType = paramInfo[0].Type.AsDynamicIfNoPia(_containingType); 442778"];
12927 [label="paramInfo[0].Type.AsDynamicIfNoPia(_containingType) 442779"];
12928 [label="param AsDynamicIfNoPia(this TypeSymbol type) 442780"];
12929 [label="param AsDynamicIfNoPia(NamedTypeSymbol containingType) 442781"];
12930 [label="param TryAsDynamicIfNoPia(this TypeSymbol type) 442782"];
12931 [label="param TryAsDynamicIfNoPia(NamedTypeSymbol containingType) 442783"];
12932 [label="param TryAsDynamicIfNoPia([NotNullWhen(true)] out TypeSymbol? result) 442784"];
12933 [label="type.SpecialType 442785"];
12934 [label="get\n            {\n                return _corTypeId;\n            } 442786"];
12935 [label="if (type.SpecialType == SpecialType.System_Object)\n            {\n                AssemblySymbol assembly = containingType.ContainingAssembly;\n                if ((object)assembly != null &&\n                    assembly.IsLinked &&\n                    containingType.IsComImport)\n                {\n                    result = DynamicTypeSymbol.Instance;\n                    return true;\n                }\n            } 442787"];
12936 [label="result = null; 442788"];
12937 [label="paramInfo[0].Type = returnType; 442789"];
12938 [label="paramInfo[0].Type 442790"];
12939 [label="this.IsMetadataVirtual() 442791"];
12940 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 442792"];
12941 [label="=> HasFlag(MethodAttributes.Virtual) 442793"];
12942 [label="MethodAttributes.Virtual 442794"];
12943 [label="HasFlag(MethodAttributes.Virtual) 442795"];
12944 [label="param HasFlag(MethodAttributes flag) 442796"];
12945 [label="param HasFlag(this) 442797"];
12946 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442798"];
12947 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442799"];
12948 [label="return ((ushort)flag & _flags) != 0; 442800"];
12949 [label="param Create(bool isContainingSymbolVirtual) 442801"];
12950 [label="param Create(out bool isBad) 442802"];
12951 [label="param Create(bool isContainingSymbolVirtual) 442803"];
12952 [label="param Create(bool isReturn) 442804"];
12953 [label="param Create(out bool isBad) 442805"];
12954 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 442806"];
12955 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 442807"];
12956 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 442808"];
12957 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 442809"];
12958 [label="typeSymbol.IsNullableType() 442810"];
12959 [label="param IsNullableType(this TypeSymbol type) 442811"];
12960 [label="type.OriginalDefinition 442812"];
12961 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 442813"];
12962 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 442814"];
12963 [label="type.OriginalDefinition.SpecialType 442815"];
12964 [label="get\n            {\n                return _corTypeId;\n            } 442816"];
12965 [label="var a1 = defaultType is null; 442817"];
12966 [label="!a1 442818"];
12967 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 442819"];
12968 [label="defaultType.IsNullableType() 442820"];
12969 [label="param IsNullableType(this TypeSymbol type) 442821"];
12970 [label="type.OriginalDefinition 442822"];
12971 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 442823"];
12972 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 442824"];
12973 [label="type.OriginalDefinition.SpecialType 442825"];
12974 [label="get\n            {\n                return _corTypeId;\n            } 442826"];
12975 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 442827"];
12976 [label="Debug.Assert(a1 || a2 != true || a3); 442828"];
12977 [label="Debug.Assert(a1 || a2 != true || a3); 442829"];
12978 [label="Debug.Assert(extensions != null); 442830"];
12979 [label="param PEParameterSymbol(out bool isBad) 442831"];
12980 [label="_containingSymbol 442832"];
12981 [label="_moduleSymbol 442833"];
12982 [label="_ordinal 442834"];
12983 [label="Debug.Assert((object)moduleSymbol != null); 442835"];
12984 [label="Debug.Assert((object)containingSymbol != null); 442836"];
12985 [label="Debug.Assert(ordinal >= 0); 442837"];
12986 [label="typeWithAnnotations.HasType 442838"];
12987 [label="=> !(DefaultType is null) 442839"];
12988 [label="DefaultType is null 442840"];
12989 [label="!(DefaultType is null) 442841"];
12990 [label="Debug.Assert(typeWithAnnotations.HasType); 442842"];
12991 [label="isBad = false; 442843"];
12992 [label="nullableContext.GetNullableContextValue() 442844"];
12993 [label="param TryGetNullableContext(out byte? value) 442845"];
12994 [label="param TryGetByte(out byte? value) 442846"];
12995 [label="value = null; 442847"];
12996 [label="s.Kind 442848"];
12997 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 442849"];
12998 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 442850"];
12999 [label="param TryGetByte(out byte? value) 442851"];
13000 [label="return true; 442852"];
13001 [label="byte? value = nullableContext.GetNullableContextValue(); 442853"];
13002 [label="if (value.HasValue)\n                {\n                    typeWithAnnotations = NullableTypeDecoder.TransformType(typeWithAnnotations, value.GetValueOrDefault(), default);\n                } 442854"];
13003 [label="this.RefKind 442855"];
13004 [label="Debug.Assert(refKind == this.RefKind); 442856"];
13005 [label="this.HasNameInMetadata 442857"];
13006 [label="get\n            {\n                return _packedFlags.HasNameInMetadata;\n            } 442858"];
13007 [label="_packedFlags.HasNameInMetadata 442859"];
13008 [label="get { return (_bits & HasNameInMetadataBit) != 0; } 442860"];
13009 [label="return (_bits & HasNameInMetadataBit) != 0; 442861"];
13010 [label="return (_bits & HasNameInMetadataBit) != 0; 442862"];
13011 [label="return _packedFlags.HasNameInMetadata; 442863"];
13012 [label="Debug.Assert(hasNameInMetadata == this.HasNameInMetadata); 442864"];
13013 [label="parameter.RefCustomModifiers 442865"];
13014 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 442866"];
13015 [label="return ImmutableArray<CustomModifier>.Empty; 442867"];
13016 [label="bool hasInAttributeModifier = parameter.RefCustomModifiers.HasInAttributeModifier(); 442868"];
13017 [label="parameter.RefCustomModifiers.HasInAttributeModifier() 442869"];
13018 [label="param HasInAttributeModifier(this ImmutableArray<CustomModifier> modifiers) 442870"];
13019 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 442871"];
13020 [label="return modifiers.Any(modifier => !modifier.IsOptional && ((CSharpCustomModifier)modifier).ModifierSymbol.IsWellKnownTypeInAttribute()); 442872"];
13021 [label="if (isReturn)\n            {\n                // A RefReadOnly return parameter should always have this modreq, and vice versa.\n                isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier;\n            }\n            else if (parameter.RefKind == RefKind.In)\n            {\n                // An in parameter should not have this modreq, unless the containing symbol was virtual or abstract.\n                isBad |= isContainingSymbolVirtual != hasInAttributeModifier;\n            }\n            else if (hasInAttributeModifier)\n            {\n                // This modreq should not exist on non-in parameters.\n                isBad = true;\n            } 442873"];
13022 [label="parameter.RefKind 442874"];
13023 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 442875"];
13024 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 442876"];
13025 [label="isBad |= (parameter.RefKind == RefKind.RefReadOnly) != hasInAttributeModifier; 442877"];
13026 [label="if (makeBad || isBadParameter)\n            {\n                InitializeUseSiteDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this));\n            } 442878"];
13027 [label="ReturnParam 442879"];
13028 [label="this.Parameters 442880"];
13029 [label="return InterlockedOperations.Initialize(ref _lazySignature, signature); 442881"];
13030 [label="=> defaultType 442882"];
13031 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442883"];
13032 [label="Debug.Assert((int)methodKind == ((int)methodKind & MethodKindMask)); 442884"];
13033 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 442885"];
13034 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 442886"];
13035 [label="param BitsAreUnsetOrSame(int bits) 442887"];
13036 [label="param BitsAreUnsetOrSame(int mask) 442888"];
13037 [label="return (bits & mask) == 0 || (bits & mask) == mask; 442889"];
13038 [label="return (bits & mask) == 0 || (bits & mask) == mask; 442890"];
13039 [label="MethodKind methodKind = method.MethodKind; 442891"];
13040 [label="if (methodKind == MethodKind.Conversion || methodKind == MethodKind.UserDefinedOperator)\n                            {\n                                methodKind = MethodKind.Ordinary;\n                            } 442892"];
13041 [label="method.Arity 442893"];
13042 [label="if (!_lazyTypeParameters.IsDefault)\n                {\n                    return _lazyTypeParameters.Length;\n                } 442894"];
13043 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442895"];
13044 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442896"];
13045 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442897"];
13046 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442898"];
13047 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442899"];
13048 [label="method.IsVirtual 442900"];
13049 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 442901"];
13050 [label="this.IsMetadataVirtual() 442902"];
13051 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 442903"];
13052 [label="=> HasFlag(MethodAttributes.Virtual) 442904"];
13053 [label="MethodAttributes.Virtual 442905"];
13054 [label="HasFlag(MethodAttributes.Virtual) 442906"];
13055 [label="param HasFlag(MethodAttributes flag) 442907"];
13056 [label="param HasFlag(this) 442908"];
13057 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442909"];
13058 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442910"];
13059 [label="return ((ushort)flag & _flags) != 0; 442911"];
13060 [label="this.IsMetadataVirtual() && !this.IsDestructor 442912"];
13061 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 442913"];
13062 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 442914"];
13063 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 442915"];
13064 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442916"];
13065 [label="method.IsOverride 442917"];
13066 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442918"];
13067 [label="this._containingType.IsInterface 442919"];
13068 [label="get\n            {\n                return _flags.IsInterface();\n            } 442920"];
13069 [label="this.IsMetadataVirtual() 442921"];
13070 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 442922"];
13071 [label="=> HasFlag(MethodAttributes.Virtual) 442923"];
13072 [label="MethodAttributes.Virtual 442924"];
13073 [label="HasFlag(MethodAttributes.Virtual) 442925"];
13074 [label="param HasFlag(MethodAttributes flag) 442926"];
13075 [label="param HasFlag(this) 442927"];
13076 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442928"];
13077 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442929"];
13078 [label="return ((ushort)flag & _flags) != 0; 442930"];
13079 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 442931"];
13080 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 442932"];
13081 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 442933"];
13082 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442934"];
13083 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442935"];
13084 [label="method.IsAbstract 442936"];
13085 [label="=> HasFlag(MethodAttributes.Abstract) 442937"];
13086 [label="MethodAttributes.Abstract 442938"];
13087 [label="HasFlag(MethodAttributes.Abstract) 442939"];
13088 [label="param HasFlag(MethodAttributes flag) 442940"];
13089 [label="param HasFlag(this) 442941"];
13090 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442942"];
13091 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442943"];
13092 [label="return ((ushort)flag & _flags) != 0; 442944"];
13093 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442945"];
13094 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442946"];
13095 [label="if (method.Arity != descriptor.Arity || methodKind != targetMethodKind ||\n                                ((descriptor.Flags & MemberFlags.Virtual) != 0) != (method.IsVirtual || method.IsOverride || method.IsAbstract))\n                            {\n                                continue;\n                            } 442947"];
13096 [label="param GetParameters(this) 442948"];
13097 [label="param IsByRefMethod(this) 442949"];
13098 [label="get { return (RefKind)((_bits >> RefKindOffset) & RefKindMask); } 442950"];
13099 [label="param GetReturnType(this) 442951"];
13100 [label="=> defaultType 442952"];
13101 [label="param MatchTypeToTypeId(this) 442953"];
13102 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 442954"];
13103 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 442955"];
13104 [label="param MatchTypeToTypeId(this) 442956"];
13105 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 442957"];
13106 [label="DiagnosticInfo result = null; 442958"];
13107 [label="CalculateUseSiteDiagnostic(ref result); 442959"];
13108 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 442960"];
13109 [label="this.IsDefinition 442961"];
13110 [label="get\n            {\n                return this.OriginalDefinition;\n            } 442962"];
13111 [label="this.OriginalDefinition 442963"];
13112 [label="get\n            {\n                return this;\n            } 442964"];
13113 [label="return this; 442965"];
13114 [label="return this.OriginalDefinition; 442966"];
13115 [label="Debug.Assert(this.IsDefinition); 442967"];
13116 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 442968"];
13117 [label="Debug.Assert(BitsAreUnsetOrSame(_bits, bitsToSet)); 442969"];
13118 [label="BitsAreUnsetOrSame(_bits, bitsToSet) 442970"];
13119 [label="param BitsAreUnsetOrSame(int bits) 442971"];
13120 [label="param BitsAreUnsetOrSame(int mask) 442972"];
13121 [label="return (bits & mask) == 0 || (bits & mask) == mask; 442973"];
13122 [label="return (bits & mask) == 0 || (bits & mask) == mask; 442974"];
13123 [label="_packedFlags.IsInitOnly 442975"];
13124 [label="=> (_bits & IsInitOnlyBit) != 0 442976"];
13125 [label="_bits & IsInitOnlyBit 442977"];
13126 [label="0 442978"];
13127 [label="(_bits & IsInitOnlyBit) != 0 442979"];
13128 [label="return _packedFlags.IsInitOnly; 442980"];
13129 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 442981"];
13130 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 442982"];
13131 [label="param DeriveUseSiteDiagnosticFromType(this) 442983"];
13132 [label="=> defaultType 442984"];
13133 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 442985"];
13134 [label="param DeriveUseSiteDiagnosticFromType(this) 442986"];
13135 [label="return _lazyUseSiteDiagnostic; 442987"];
13136 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 442988"];
13137 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 442989"];
13138 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 442990"];
13139 [label="return MergeUseSiteDiagnostics(ref result, info); 442991"];
13140 [label="return MergeUseSiteDiagnostics(ref result, info); 442992"];
13141 [label="MergeUseSiteDiagnostics(ref result, info) 442993"];
13142 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 442994"];
13143 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 442995"];
13144 [label="param MergeUseSiteDiagnostics(this) 442996"];
13145 [label="type.CustomModifiers 442997"];
13146 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 442998"];
13147 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 442999"];
13148 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 443000"];
13149 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 443001"];
13150 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 443002"];
13151 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 443003"];
13152 [label="bool checkRequiredModifiers = true; 443004"];
13153 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 443005"];
13154 [label="return false; 443006"];
13155 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 443007"];
13156 [label="this.RefCustomModifiers 443008"];
13157 [label="=> Signature.ReturnParam.RefCustomModifiers 443009"];
13158 [label="Signature 443010"];
13159 [label="=> _lazySignature ?? LoadSignature() 443011"];
13160 [label="Signature.ReturnParam.RefCustomModifiers 443012"];
13161 [label="get\n            {\n                return ImmutableArray<CustomModifier>.Empty;\n            } 443013"];
13162 [label="return ImmutableArray<CustomModifier>.Empty; 443014"];
13163 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443015"];
13164 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 443016"];
13165 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 443017"];
13166 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 443018"];
13167 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 443019"];
13168 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 443020"];
13169 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 443021"];
13170 [label="bool checkRequiredModifiers = true; 443022"];
13171 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 443023"];
13172 [label="return false; 443024"];
13173 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443025"];
13174 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 443026"];
13175 [label="param DeriveUseSiteDiagnosticFromParameters(this) 443027"];
13176 [label="return false; 443028"];
13177 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.ReturnTypeWithAnnotations,\n                                                IsInitOnly ?\n                                                    AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit :\n                                                    AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443029"];
13178 [label="this.ContainingModule 443030"];
13179 [label="s.Kind 443031"];
13180 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 443032"];
13181 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 443033"];
13182 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 443034"];
13183 [label=".HasUnifiedReferences 443035"];
13184 [label="get { return GetUnifiedAssemblies().Length > 0; } 443036"];
13185 [label="GetUnifiedAssemblies() 443037"];
13186 [label="param GetUnifiedAssemblies(this) 443038"];
13187 [label="AssertReferencesInitialized() 443039"];
13188 [label="param AssertReferencesInitialized(this) 443040"];
13189 [label="Debug.Assert(_moduleReferences != null); 443041"];
13190 [label="Debug.Assert(_moduleReferences != null); 443042"];
13191 [label="AssertReferencesInitialized(); 443043"];
13192 [label="return GetUnifiedAssemblies().Length > 0; 443044"];
13193 [label="return GetUnifiedAssemblies().Length > 0; 443045"];
13194 [label="if (this.ContainingModule?.HasUnifiedReferences == true)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n\n                if (this.ReturnTypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.TypeParameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 443046"];
13195 [label="return false; 443047"];
13196 [label="CalculateUseSiteDiagnostic(ref result); 443048"];
13197 [label="EnsureTypeParametersAreLoaded(ref result); 443049"];
13198 [label="EnsureTypeParametersAreLoaded(ref result) 443050"];
13199 [label="param EnsureTypeParametersAreLoaded(ref DiagnosticInfo diagnosticInfo) 443051"];
13200 [label="param EnsureTypeParametersAreLoaded(this) 443052"];
13201 [label="var typeParams = _lazyTypeParameters; 443053"];
13202 [label="if (!typeParams.IsDefault)\n            {\n                return typeParams;\n            } 443054"];
13203 [label="return typeParams; 443055"];
13204 [label="EnsureTypeParametersAreLoaded(ref result); 443056"];
13205 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 443057"];
13206 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 443058"];
13207 [label="param GetUnmanagedCallersOnlyAttributeData(bool forceComplete) 443059"];
13208 [label="Debug.Assert((object)moduleSymbol != null); 443060"];
13209 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 443061"];
13210 [label="Debug.Assert(!ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.Uninitialized)\n                             && !ReferenceEquals(unmanagedCallersOnlyData, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound)); 443062"];
13211 [label="_lazyObsoleteAttributeData 443063"];
13212 [label="_lazyUnmanagedCallersOnlyAttributeData 443064"];
13213 [label="_packedFlags.IsCustomAttributesPopulated 443065"];
13214 [label="=> (_bits & IsCustomAttributesPopulatedBit) != 0 443066"];
13215 [label="_bits & IsCustomAttributesPopulatedBit 443067"];
13216 [label="0 443068"];
13217 [label="(_bits & IsCustomAttributesPopulatedBit) != 0 443069"];
13218 [label="if (_packedFlags.IsCustomAttributesPopulated)\n            {\n                retVal._lazyCustomAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n            } 443070"];
13219 [label="_packedFlags.IsConditionalPopulated 443071"];
13220 [label="=> (_bits & IsConditionalPopulatedBit) != 0 443072"];
13221 [label="_bits & IsConditionalPopulatedBit 443073"];
13222 [label="0 443074"];
13223 [label="(_bits & IsConditionalPopulatedBit) != 0 443075"];
13224 [label="if (_packedFlags.IsConditionalPopulated)\n            {\n                retVal._lazyConditionalAttributeSymbols = ImmutableArray<string>.Empty;\n            } 443076"];
13225 [label="_packedFlags.IsOverriddenOrHiddenMembersPopulated 443077"];
13226 [label="=> (_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 443078"];
13227 [label="_bits & IsOverriddenOrHiddenMembersPopulatedBit 443079"];
13228 [label="0 443080"];
13229 [label="(_bits & IsOverriddenOrHiddenMembersPopulatedBit) != 0 443081"];
13230 [label="if (_packedFlags.IsOverriddenOrHiddenMembersPopulated)\n            {\n                retVal._lazyOverriddenOrHiddenMembersResult = OverriddenOrHiddenMembersResult.Empty;\n            } 443082"];
13231 [label="_packedFlags.IsMemberNotNullPopulated 443083"];
13232 [label="=> (_bits & IsMemberNotNullPopulatedBit) != 0 443084"];
13233 [label="_bits & IsMemberNotNullPopulatedBit 443085"];
13234 [label="0 443086"];
13235 [label="(_bits & IsMemberNotNullPopulatedBit) != 0 443087"];
13236 [label="if (_packedFlags.IsMemberNotNullPopulated)\n            {\n                retVal._lazyNotNullMembers = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenTrue = ImmutableArray<string>.Empty;\n                retVal._lazyNotNullMembersWhenFalse = ImmutableArray<string>.Empty;\n            } 443088"];
13237 [label="_packedFlags.IsExplicitOverrideIsPopulated 443089"];
13238 [label="=> (_bits & IsExplicitOverrideIsPopulatedBit) != 0 443090"];
13239 [label="_bits & IsExplicitOverrideIsPopulatedBit 443091"];
13240 [label="0 443092"];
13241 [label="(_bits & IsExplicitOverrideIsPopulatedBit) != 0 443093"];
13242 [label="if (_packedFlags.IsExplicitOverrideIsPopulated)\n            {\n                retVal._lazyExplicitClassOverride = null;\n            } 443094"];
13243 [label="_packedFlags.SetIsUnmanagedCallersOnlyAttributePopulated(); 443095"];
13244 [label="return result; 443096"];
13245 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 443097"];
13246 [label="if (result == null && GetUnmanagedCallersOnlyAttributeData(forceComplete: true) is UnmanagedCallersOnlyAttributeData data)\n                {\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.Uninitialized));\n                    Debug.Assert(!ReferenceEquals(data, UnmanagedCallersOnlyAttributeData.AttributePresentDataNotBound));\n                    if (CheckAndReportValidUnmanagedCallersOnlyTarget(location: null, diagnostics: null))\n                    {\n                        result = new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, this);\n                    }\n                } 443098"];
13247 [label="return InitializeUseSiteDiagnostic(result); 443099"];
13248 [label="param InitializeUseSiteDiagnostic(DiagnosticInfo diagnostic) 443100"];
13249 [label="_packedFlags.IsUseSiteDiagnosticPopulated 443101"];
13250 [label="=> (_bits & IsUseSiteDiagnosticPopulatedBit) != 0 443102"];
13251 [label="if (_packedFlags.IsUseSiteDiagnosticPopulated)\n            {\n                return _uncommonFields?._lazyUseSiteDiagnostic;\n            } 443103"];
13252 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 443104"];
13253 [label="if (diagnostic != null)\n            {\n                Debug.Assert(!CSDiagnosticInfo.IsEmpty(diagnostic));\n                diagnostic = InterlockedOperations.Initialize(ref AccessUncommonFields()._lazyUseSiteDiagnostic, diagnostic);\n            } 443105"];
13254 [label="_packedFlags.SetIsUseSiteDiagnosticPopulated(); 443106"];
13255 [label="return diagnostic; 443107"];
13256 [label="var info = this.GetUseSiteDiagnostic(); 443108"];
13257 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 443109"];
13258 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 443110"];
13259 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 443111"];
13260 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 443112"];
13261 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 443113"];
13262 [label="param TransformType(int targetSymbolCustomModifierCount) 443114"];
13263 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 443115"];
13264 [label="Debug.Assert((object)metadataType != null); 443116"];
13265 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 443117"];
13266 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 443118"];
13267 [label="_elementNames 443119"];
13268 [label="elementNames.IsDefault 443120"];
13269 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 443121"];
13270 [label="_namesIndex 443122"];
13271 [label="_foundUsableErrorType = false; 443123"];
13272 [label="_foundUsableErrorType 443124"];
13273 [label="param DecodeType(this) 443125"];
13274 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443126"];
13275 [label="param DecodeNamedType(this) 443127"];
13276 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 443128"];
13277 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 443129"];
13278 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 443130"];
13279 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 443131"];
13280 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 443132"];
13281 [label="DecodeTypeArguments(typeArgs) 443133"];
13282 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 443134"];
13283 [label="param DecodeTypeArguments(this) 443135"];
13284 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 443136"];
13285 [label="return typeArgs; 443137"];
13286 [label="type.ContainingType 443138"];
13287 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 443139"];
13288 [label="return _container as NamedTypeSymbol; 443140"];
13289 [label="NamedTypeSymbol containingType = type.ContainingType; 443141"];
13290 [label="NamedTypeSymbol? decodedContainingType; 443142"];
13291 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 443143"];
13292 [label="decodedContainingType = containingType; 443144"];
13293 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 443145"];
13294 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 443146"];
13295 [label="var typeArgsChanged = typeArgs != decodedArgs; 443147"];
13296 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 443148"];
13297 [label="decodedType.IsTupleType 443149"];
13298 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 443150"];
13299 [label="_ 443151"];
13300 [label="tupleCardinality: out _ 443152"];
13301 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 443153"];
13302 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 443154"];
13303 [label="param IsTupleTypeOfCardinality(this) 443155"];
13304 [label="IsUnboundGenericType 443156"];
13305 [label="get\n            {\n                return false;\n            } 443157"];
13306 [label="return false; 443158"];
13307 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443159"];
13308 [label="ContainingSymbol 443160"];
13309 [label="get\n            {\n                return _container;\n            } 443161"];
13310 [label="return _container; 443162"];
13311 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443163"];
13312 [label=".Kind 443164"];
13313 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 443165"];
13314 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443166"];
13315 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443167"];
13316 [label="ContainingNamespace 443168"];
13317 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 443169"];
13318 [label="get\n            {\n                return _container;\n            } 443170"];
13319 [label="return _container; 443171"];
13320 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443172"];
13321 [label="ContainingNamespace.ContainingNamespace 443173"];
13322 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 443174"];
13323 [label=".IsGlobalNamespace 443175"];
13324 [label="get\n            {\n                return true;\n            } 443176"];
13325 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443177"];
13326 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443178"];
13327 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443179"];
13328 [label="Name 443180"];
13329 [label="get\n            {\n                return _name;\n            } 443181"];
13330 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443182"];
13331 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443183"];
13332 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443184"];
13333 [label="tupleCardinality = 0; 443185"];
13334 [label="return false; 443186"];
13335 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 443187"];
13336 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 443188"];
13337 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 443189"];
13338 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 443190"];
13339 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 443191"];
13340 [label="typeSymbol.IsNullableType() 443192"];
13341 [label="param IsNullableType(this TypeSymbol type) 443193"];
13342 [label="type.OriginalDefinition 443194"];
13343 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 443195"];
13344 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 443196"];
13345 [label="type.OriginalDefinition.SpecialType 443197"];
13346 [label="get\n            {\n                return _corTypeId;\n            } 443198"];
13347 [label="var a1 = defaultType is null; 443199"];
13348 [label="!a1 443200"];
13349 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 443201"];
13350 [label="defaultType.IsNullableType() 443202"];
13351 [label="param IsNullableType(this TypeSymbol type) 443203"];
13352 [label="type.OriginalDefinition 443204"];
13353 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 443205"];
13354 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 443206"];
13355 [label="type.OriginalDefinition.SpecialType 443207"];
13356 [label="get\n            {\n                return _corTypeId;\n            } 443208"];
13357 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 443209"];
13358 [label="Debug.Assert(a1 || a2 != true || a3); 443210"];
13359 [label="Debug.Assert(a1 || a2 != true || a3); 443211"];
13360 [label="Debug.Assert(extensions != null); 443212"];
13361 [label="metadataType.HasType 443213"];
13362 [label="=> !(DefaultType is null) 443214"];
13363 [label="DefaultType is null 443215"];
13364 [label="!(DefaultType is null) 443216"];
13365 [label="Debug.Assert(metadataType.HasType); 443217"];
13366 [label="Debug.Assert(accessSymbol.IsDefinition); 443218"];
13367 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 443219"];
13368 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 443220"];
13369 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 443221"];
13370 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 443222"];
13371 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 443223"];
13372 [label="Debug.Assert(symbol is object); 443224"];
13373 [label="symbol.Kind 443225"];
13374 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443226"];
13375 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 443227"];
13376 [label="isInternal = false; 443228"];
13377 [label="symbol.DeclaredAccessibility 443229"];
13378 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 443230"];
13379 [label="Accessibility access = Accessibility.Private; 443231"];
13380 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 443232"];
13381 [label="symbol.ContainingType 443233"];
13382 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 443234"];
13383 [label="return _container as NamedTypeSymbol; 443235"];
13384 [label="symbol = symbol.ContainingType; 443236"];
13385 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 443237"];
13386 [label="return true; 443238"];
13387 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 443239"];
13388 [label="param TryGetByte(out byte? value) 443240"];
13389 [label="return true; 443241"];
13390 [label="=> defaultType 443242"];
13391 [label="Debug.Assert((object)depends != null); 443243"];
13392 [label="Debug.Assert((object)on != null); 443244"];
13393 [label="Debug.Assert(on.IsDefinition); 443245"];
13394 [label="depends.DeclaringCompilation 443246"];
13395 [label="get { return null; } 443247"];
13396 [label="return null; 443248"];
13397 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 443249"];
13398 [label="if ((object)type == null)\n            {\n                return;\n            } 443250"];
13399 [label="return; 443251"];
13400 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 443252"];
13401 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 443253"];
13402 [label="return result; 443254"];
13403 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 443255"];
13404 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 443256"];
13405 [label="@base.IsErrorType() 443257"];
13406 [label="param IsErrorType(this TypeSymbol type) 443258"];
13407 [label="RoslynDebug.Assert((object)type != null); 443259"];
13408 [label="RoslynDebug.Assert((object)type != null); 443260"];
13409 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443261"];
13410 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 443262"];
13411 [label="param MergeUseSiteDiagnostics(this) 443263"];
13412 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 443264"];
13413 [label="this.ContainingModule.HasUnifiedReferences 443265"];
13414 [label="get { return GetUnifiedAssemblies().Length > 0; } 443266"];
13415 [label="GetUnifiedAssemblies() 443267"];
13416 [label="param GetUnifiedAssemblies(this) 443268"];
13417 [label="AssertReferencesInitialized() 443269"];
13418 [label="param AssertReferencesInitialized(this) 443270"];
13419 [label="Debug.Assert(_moduleReferences != null); 443271"];
13420 [label="Debug.Assert(_moduleReferences != null); 443272"];
13421 [label="AssertReferencesInitialized(); 443273"];
13422 [label="return GetUnifiedAssemblies().Length > 0; 443274"];
13423 [label="return GetUnifiedAssemblies().Length > 0; 443275"];
13424 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 443276"];
13425 [label="SpecialType 443277"];
13426 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 443278"];
13427 [label="TypeSymbol @base = GetDeclaredBaseType(null); 443279"];
13428 [label="GetDeclaredBaseType(null) 443280"];
13429 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 443281"];
13430 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 443282"];
13431 [label="TypeSymbol @base = GetDeclaredBaseType(null); 443283"];
13432 [label=".SpecialType 443284"];
13433 [label="get\n            {\n                return _corTypeId;\n            } 443285"];
13434 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 443286"];
13435 [label="@base.ContainingAssembly 443287"];
13436 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 443288"];
13437 [label="this.ContainingSymbol 443289"];
13438 [label="get\n            {\n                return _container;\n            } 443290"];
13439 [label="return _container; 443291"];
13440 [label="var container = this.ContainingSymbol; 443292"];
13441 [label="return (object)container != null ? container.ContainingAssembly : null; 443293"];
13442 [label="return (object)container != null ? container.ContainingAssembly : null; 443294"];
13443 [label="(object)container != null 443295"];
13444 [label="container.ContainingAssembly 443296"];
13445 [label="get\n            {\n                return ContainingPEModule.ContainingAssembly;\n            } 443297"];
13446 [label="ContainingPEModule 443298"];
13447 [label="get { return _containingNamespaceSymbol.ContainingPEModule; } 443299"];
13448 [label="return ContainingPEModule.ContainingAssembly; 443300"];
13449 [label="ContainingPEModule.ContainingAssembly 443301"];
13450 [label="get\n            {\n                return _assemblySymbol;\n            } 443302"];
13451 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 443303"];
13452 [label=".IsMissing 443304"];
13453 [label="get\n            {\n                return false;\n            } 443305"];
13454 [label="return false; 443306"];
13455 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 443307"];
13456 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 443308"];
13457 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 443309"];
13458 [label="return _lazyUseSiteDiagnostic; 443310"];
13459 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 443311"];
13460 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 443312"];
13461 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 443313"];
13462 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 443314"];
13463 [label="return memberSymbol; 443315"];
13464 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 443316"];
13465 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 443317"];
13466 [label="return memberSymbol; 443318"];
13467 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 443319"];
13468 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 443320"];
13469 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 443321"];
13470 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton); 443322"];
13471 [label="Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(compilation,\n                        WellKnownMember.System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows, diagnostics, NoLocation.Singleton) 443323"];
13472 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation) 443324"];
13473 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(WellKnownMember attributeMember) 443325"];
13474 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(DiagnosticBag diagnostics) 443326"];
13475 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(Location? location = null) 443327"];
13476 [label="param ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpSyntaxNode? syntax = null) 443328"];
13477 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 443329"];
13478 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 443330"];
13479 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 443331"];
13480 [label="RoslynDebug.Assert((location != null) ^ (syntax != null)); 443332"];
13481 [label="bool isOptional = WellKnownMembers.IsSynthesizedAttributeOptional(attributeMember); 443333"];
13482 [label="param GetWellKnownTypeMember(DiagnosticBag diagnostics) 443334"];
13483 [label="param GetWellKnownTypeMember(Location location = null) 443335"];
13484 [label="param GetWellKnownTypeMember(SyntaxNode syntax = null) 443336"];
13485 [label="param GetWellKnownTypeMember(bool isOptional = false) 443337"];
13486 [label="Debug.Assert((syntax != null) ^ (location != null)); 443338"];
13487 [label="Debug.Assert((syntax != null) ^ (location != null)); 443339"];
13488 [label="Debug.Assert((syntax != null) ^ (location != null)); 443340"];
13489 [label="Debug.Assert((syntax != null) ^ (location != null)); 443341"];
13490 [label="DiagnosticInfo useSiteDiagnostic; 443342"];
13491 [label="param GetWellKnownTypeMember(out DiagnosticInfo diagnosticInfo) 443343"];
13492 [label="param GetWellKnownTypeMember(bool isOptional = false) 443344"];
13493 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 443345"];
13494 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 443346"];
13495 [label="Debug.Assert(member >= 0 && member < WellKnownMember.Count); 443347"];
13496 [label="if (IsMemberMissing(member)) return null; 443348"];
13497 [label="Debug.Assert(type.IsValid()); 443349"];
13498 [label="this.Options 443350"];
13499 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 443351"];
13500 [label="bool ignoreCorLibraryDuplicatedTypes = this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes); 443352"];
13501 [label="this.Options.TopLevelBinderFlags.Includes(BinderFlags.IgnoreCorLibraryDuplicatedTypes) 443353"];
13502 [label="param Includes(this BinderFlags self) 443354"];
13503 [label="param Includes(BinderFlags other) 443355"];
13504 [label="return (self & other) == other; 443356"];
13505 [label="Symbol? result = null; 443357"];
13506 [label="param IsErrorType(this TypeSymbol type) 443358"];
13507 [label="RoslynDebug.Assert((object)type != null); 443359"];
13508 [label="RoslynDebug.Assert((object)type != null); 443360"];
13509 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443361"];
13510 [label="GetBoundReferenceManager(); 443362"];
13511 [label="param GetRuntimeMember(AssemblySymbol accessWithinOpt) 443363"];
13512 [label="EnsureAllMembersAreLoaded(); 443364"];
13513 [label="param GetRuntimeMember(AssemblySymbol? accessWithinOpt) 443365"];
13514 [label="SymbolKind targetSymbolKind; 443366"];
13515 [label="MethodKind targetMethodKind = MethodKind.Ordinary; 443367"];
13516 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 443368"];
13517 [label="bool isStatic = (descriptor.Flags & MemberFlags.Static) != 0; 443369"];
13518 [label="Symbol? result = null; 443370"];
13519 [label="targetSymbolKind = SymbolKind.Property; 443371"];
13520 [label="member.Name 443372"];
13521 [label="get\n            {\n                // NOTE: Dev10 appears to include static indexers in overload resolution \n                // for an array access expression, so it stands to reason that it considers\n                // them indexers.\n                if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                }\n                return false;\n            } 443373"];
13522 [label="this.ParameterCount 443374"];
13523 [label="get\n            {\n                return this.Parameters.Length;\n            } 443375"];
13524 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 443376"];
13525 [label="if (this.ParameterCount > 0)\n                {\n                    string defaultMemberName = _containingType.DefaultMemberName;\n                    return _name == defaultMemberName || //NB: not Name property (break mutual recursion)\n                        ((object)this.GetMethod != null && this.GetMethod.Name == defaultMemberName) ||\n                        ((object)this.SetMethod != null && this.SetMethod.Name == defaultMemberName);\n                } 443377"];
13526 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 443378"];
13527 [label="if (!member.Name.Equals(descriptor.Name))\n                {\n                    continue;\n                } 443379"];
13528 [label="member.Kind 443380"];
13529 [label="get\n            {\n                return SymbolKind.Property;\n            } 443381"];
13530 [label="return SymbolKind.Property; 443382"];
13531 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443383"];
13532 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443384"];
13533 [label="get\n            {\n                // All accessors static.\n                return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic);\n            } 443385"];
13534 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 443386"];
13535 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 443387"];
13536 [label="_getMethod.IsStatic 443388"];
13537 [label="=> HasFlag(MethodAttributes.Static) 443389"];
13538 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443390"];
13539 [label="return\n                    ((object)_getMethod == null || _getMethod.IsStatic) &&\n                    ((object)_setMethod == null || _setMethod.IsStatic); 443391"];
13540 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443392"];
13541 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443393"];
13542 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443394"];
13543 [label="member.DeclaredAccessibility 443395"];
13544 [label="get\n            {\n                if (_declaredAccessibility == UnsetAccessibility)\n                {\n                    Accessibility accessibility;\n                    if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    }\n\n                    Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility);\n                }\n\n                return (Accessibility)_declaredAccessibility;\n            } 443396"];
13545 [label="if (_declaredAccessibility == UnsetAccessibility)\n                {\n                    Accessibility accessibility;\n                    if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    }\n\n                    Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility);\n                } 443397"];
13546 [label="Accessibility accessibility; 443398"];
13547 [label="this.IsOverride 443399"];
13548 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 443400"];
13549 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443401"];
13550 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443402"];
13551 [label="_getMethod.IsOverride 443403"];
13552 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443404"];
13553 [label="this._containingType.IsInterface 443405"];
13554 [label="get\n            {\n                return _flags.IsInterface();\n            } 443406"];
13555 [label="this.IsMetadataVirtual() 443407"];
13556 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443408"];
13557 [label="=> HasFlag(MethodAttributes.Virtual) 443409"];
13558 [label="MethodAttributes.Virtual 443410"];
13559 [label="HasFlag(MethodAttributes.Virtual) 443411"];
13560 [label="param HasFlag(MethodAttributes flag) 443412"];
13561 [label="param HasFlag(this) 443413"];
13562 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443414"];
13563 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443415"];
13564 [label="return ((ushort)flag & _flags) != 0; 443416"];
13565 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443417"];
13566 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443418"];
13567 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443419"];
13568 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443420"];
13569 [label="_setMethod.IsOverride 443421"];
13570 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443422"];
13571 [label="this._containingType.IsInterface 443423"];
13572 [label="get\n            {\n                return _flags.IsInterface();\n            } 443424"];
13573 [label="this.IsMetadataVirtual() 443425"];
13574 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443426"];
13575 [label="=> HasFlag(MethodAttributes.Virtual) 443427"];
13576 [label="MethodAttributes.Virtual 443428"];
13577 [label="HasFlag(MethodAttributes.Virtual) 443429"];
13578 [label="param HasFlag(MethodAttributes flag) 443430"];
13579 [label="param HasFlag(this) 443431"];
13580 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443432"];
13581 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443433"];
13582 [label="return ((ushort)flag & _flags) != 0; 443434"];
13583 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443435"];
13584 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443436"];
13585 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443437"];
13586 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443438"];
13587 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443439"];
13588 [label="if (this.IsOverride)\n                    {\n                        // Determining the accessibility of an overriding property is tricky.  It should be\n                        // based on the accessibilities of the accessors, but the overriding property need\n                        // not override both accessors.  As a result, we may need to look at the accessors\n                        // of an overridden method.\n                        //\n                        // One might assume that we could just go straight to the least-derived \n                        // property (i.e. the original virtual property) and check its accessors, but\n                        // that can yield incorrect results if the least-derived property is in a\n                        // different assembly.  For any overridden and (directly) overriding members, M and M',\n                        // in different assemblies, A1 and A2, if M is protected internal, then M' must be \n                        // protected internal if the internals of A1 are visible to A2 and protected otherwise.\n                        //\n                        // Therefore, if we cross an assembly boundary in the course of walking up the\n                        // override chain, and if the overriding assembly cannot see the internals of the\n                        // overridden assembly, then any protected internal accessors we find should be \n                        // treated as protected, for the purposes of determining property accessibility.\n                        //\n                        // NOTE: This process has no effect on accessor accessibility - a protected internal\n                        // accessor in another assembly will still have declared accessibility protected internal.\n                        // The difference between the accessibilities of the overriding and overridden accessors\n                        // will be accommodated later, when we check for CS0507 (ERR_CantChangeAccessOnOverride).\n\n                        bool crossedAssemblyBoundaryWithoutInternalsVisibleTo = false;\n                        Accessibility getAccessibility = Accessibility.NotApplicable;\n                        Accessibility setAccessibility = Accessibility.NotApplicable;\n                        PropertySymbol curr = this;\n                        while (true)\n                        {\n                            if (getAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol getMethod = curr.GetMethod;\n                                if ((object)getMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = getMethod.DeclaredAccessibility;\n                                    getAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (setAccessibility == Accessibility.NotApplicable)\n                            {\n                                MethodSymbol setMethod = curr.SetMethod;\n                                if ((object)setMethod != null)\n                                {\n                                    Accessibility overriddenAccessibility = setMethod.DeclaredAccessibility;\n                                    setAccessibility = overriddenAccessibility == Accessibility.ProtectedOrInternal && crossedAssemblyBoundaryWithoutInternalsVisibleTo\n                                        ? Accessibility.Protected\n                                        : overriddenAccessibility;\n                                }\n                            }\n\n                            if (getAccessibility != Accessibility.NotApplicable && setAccessibility != Accessibility.NotApplicable)\n                            {\n                                break;\n                            }\n\n                            PropertySymbol next = curr.OverriddenProperty;\n\n                            if ((object)next == null)\n                            {\n                                break;\n                            }\n\n                            if (!crossedAssemblyBoundaryWithoutInternalsVisibleTo && !curr.ContainingAssembly.HasInternalAccessTo(next.ContainingAssembly))\n                            {\n                                crossedAssemblyBoundaryWithoutInternalsVisibleTo = true;\n                            }\n\n                            curr = next;\n                        }\n\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(getAccessibility, setAccessibility);\n                    }\n                    else\n                    {\n                        accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod);\n                    } 443440"];
13589 [label="this.GetMethod 443441"];
13590 [label="get { return _getMethod; } 443442"];
13591 [label="return _getMethod; 443443"];
13592 [label="accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod); 443444"];
13593 [label="this.SetMethod 443445"];
13594 [label="get { return _setMethod; } 443446"];
13595 [label="return _setMethod; 443447"];
13596 [label="accessibility = PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod); 443448"];
13597 [label="PEPropertyOrEventHelpers.GetDeclaredAccessibilityFromAccessors(this.GetMethod, this.SetMethod) 443449"];
13598 [label="param GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor1) 443450"];
13599 [label="param GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor2) 443451"];
13600 [label="if ((object)accessor1 == null)\n            {\n                return ((object)accessor2 == null) ? Accessibility.NotApplicable : accessor2.DeclaredAccessibility;\n            }\n            else if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 443452"];
13601 [label="if ((object)accessor1 == null)\n            {\n                return ((object)accessor2 == null) ? Accessibility.NotApplicable : accessor2.DeclaredAccessibility;\n            }\n            else if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 443453"];
13602 [label="if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 443454"];
13603 [label="if ((object)accessor2 == null)\n            {\n                return accessor1.DeclaredAccessibility;\n            } 443455"];
13604 [label="accessor1.DeclaredAccessibility 443456"];
13605 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 443457"];
13606 [label="Flags 443458"];
13607 [label="=> (MethodAttributes)_flags 443459"];
13608 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 443460"];
13609 [label="return Accessibility.Public; 443461"];
13610 [label="return GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility); 443462"];
13611 [label="accessor2.DeclaredAccessibility 443463"];
13612 [label="get\n            {\n                switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                }\n            } 443464"];
13613 [label="Flags 443465"];
13614 [label="=> (MethodAttributes)_flags 443466"];
13615 [label="switch (Flags & MethodAttributes.MemberAccessMask)\n                {\n                    case MethodAttributes.Assembly:\n                        return Accessibility.Internal;\n\n                    case MethodAttributes.FamORAssem:\n                        return Accessibility.ProtectedOrInternal;\n\n                    case MethodAttributes.FamANDAssem:\n                        return Accessibility.ProtectedAndInternal;\n\n                    case MethodAttributes.Private:\n                    case MethodAttributes.PrivateScope:\n                        return Accessibility.Private;\n\n                    case MethodAttributes.Public:\n                        return Accessibility.Public;\n\n                    case MethodAttributes.Family:\n                        return Accessibility.Protected;\n\n                    default:\n                        return Accessibility.Private;\n                } 443467"];
13616 [label="return Accessibility.Public; 443468"];
13617 [label="return GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility); 443469"];
13618 [label="GetDeclaredAccessibilityFromAccessors(accessor1.DeclaredAccessibility, accessor2.DeclaredAccessibility) 443470"];
13619 [label="param GetDeclaredAccessibilityFromAccessors(Accessibility accessibility1) 443471"];
13620 [label="param GetDeclaredAccessibilityFromAccessors(Accessibility accessibility2) 443472"];
13621 [label="var minAccessibility = (accessibility1 > accessibility2) ? accessibility2 : accessibility1; 443473"];
13622 [label="(accessibility1 > accessibility2) 443474"];
13623 [label="var maxAccessibility = (accessibility1 > accessibility2) ? accessibility1 : accessibility2; 443475"];
13624 [label="(accessibility1 > accessibility2) 443476"];
13625 [label="return ((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal))\n                ? Accessibility.ProtectedOrInternal\n                : maxAccessibility; 443477"];
13626 [label="((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal)) 443478"];
13627 [label="return ((minAccessibility == Accessibility.Protected) && (maxAccessibility == Accessibility.Internal))\n                ? Accessibility.ProtectedOrInternal\n                : maxAccessibility; 443479"];
13628 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 443480"];
13629 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 443481"];
13630 [label="Interlocked.CompareExchange(ref _declaredAccessibility, (int)accessibility, UnsetAccessibility); 443482"];
13631 [label="return (Accessibility)_declaredAccessibility; 443483"];
13632 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443484"];
13633 [label="if (member.Kind != targetSymbolKind || member.IsStatic != isStatic ||\n                    !(member.DeclaredAccessibility == Accessibility.Public || (accessWithinOpt is object && Symbol.IsSymbolAccessible(member, accessWithinOpt))))\n                {\n                    continue;\n                } 443485"];
13634 [label="PropertySymbol property = (PropertySymbol)member; 443486"];
13635 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443487"];
13636 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443488"];
13637 [label="property.IsVirtual 443489"];
13638 [label="get\n            {\n                // Some accessor virtual (as long as another isn't override or abstract).\n                return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual));\n            } 443490"];
13639 [label="IsOverride 443491"];
13640 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 443492"];
13641 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443493"];
13642 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443494"];
13643 [label="_getMethod.IsOverride 443495"];
13644 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443496"];
13645 [label="this._containingType.IsInterface 443497"];
13646 [label="get\n            {\n                return _flags.IsInterface();\n            } 443498"];
13647 [label="this.IsMetadataVirtual() 443499"];
13648 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443500"];
13649 [label="=> HasFlag(MethodAttributes.Virtual) 443501"];
13650 [label="MethodAttributes.Virtual 443502"];
13651 [label="HasFlag(MethodAttributes.Virtual) 443503"];
13652 [label="param HasFlag(MethodAttributes flag) 443504"];
13653 [label="param HasFlag(this) 443505"];
13654 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443506"];
13655 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443507"];
13656 [label="return ((ushort)flag & _flags) != 0; 443508"];
13657 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443509"];
13658 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443510"];
13659 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443511"];
13660 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443512"];
13661 [label="_setMethod.IsOverride 443513"];
13662 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443514"];
13663 [label="this._containingType.IsInterface 443515"];
13664 [label="get\n            {\n                return _flags.IsInterface();\n            } 443516"];
13665 [label="this.IsMetadataVirtual() 443517"];
13666 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443518"];
13667 [label="=> HasFlag(MethodAttributes.Virtual) 443519"];
13668 [label="MethodAttributes.Virtual 443520"];
13669 [label="HasFlag(MethodAttributes.Virtual) 443521"];
13670 [label="param HasFlag(MethodAttributes flag) 443522"];
13671 [label="param HasFlag(this) 443523"];
13672 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443524"];
13673 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443525"];
13674 [label="return ((ushort)flag & _flags) != 0; 443526"];
13675 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443527"];
13676 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443528"];
13677 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443529"];
13678 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443530"];
13679 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443531"];
13680 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443532"];
13681 [label="IsAbstract 443533"];
13682 [label="get\n            {\n                // Some accessor abstract.\n                return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract);\n            } 443534"];
13683 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443535"];
13684 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443536"];
13685 [label="_getMethod.IsAbstract 443537"];
13686 [label="=> HasFlag(MethodAttributes.Abstract) 443538"];
13687 [label="MethodAttributes.Abstract 443539"];
13688 [label="HasFlag(MethodAttributes.Abstract) 443540"];
13689 [label="param HasFlag(MethodAttributes flag) 443541"];
13690 [label="param HasFlag(this) 443542"];
13691 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443543"];
13692 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443544"];
13693 [label="return ((ushort)flag & _flags) != 0; 443545"];
13694 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443546"];
13695 [label="_setMethod.IsAbstract 443547"];
13696 [label="=> HasFlag(MethodAttributes.Abstract) 443548"];
13697 [label="MethodAttributes.Abstract 443549"];
13698 [label="HasFlag(MethodAttributes.Abstract) 443550"];
13699 [label="param HasFlag(MethodAttributes flag) 443551"];
13700 [label="param HasFlag(this) 443552"];
13701 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443553"];
13702 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443554"];
13703 [label="return ((ushort)flag & _flags) != 0; 443555"];
13704 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443556"];
13705 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443557"];
13706 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443558"];
13707 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443559"];
13708 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443560"];
13709 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443561"];
13710 [label="_getMethod.IsVirtual 443562"];
13711 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 443563"];
13712 [label="this.IsMetadataVirtual() 443564"];
13713 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443565"];
13714 [label="=> HasFlag(MethodAttributes.Virtual) 443566"];
13715 [label="MethodAttributes.Virtual 443567"];
13716 [label="HasFlag(MethodAttributes.Virtual) 443568"];
13717 [label="param HasFlag(MethodAttributes flag) 443569"];
13718 [label="param HasFlag(this) 443570"];
13719 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443571"];
13720 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443572"];
13721 [label="return ((ushort)flag & _flags) != 0; 443573"];
13722 [label="this.IsMetadataVirtual() && !this.IsDestructor 443574"];
13723 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 443575"];
13724 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 443576"];
13725 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 443577"];
13726 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443578"];
13727 [label="_setMethod.IsVirtual 443579"];
13728 [label="=> this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 443580"];
13729 [label="this.IsMetadataVirtual() 443581"];
13730 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443582"];
13731 [label="=> HasFlag(MethodAttributes.Virtual) 443583"];
13732 [label="MethodAttributes.Virtual 443584"];
13733 [label="HasFlag(MethodAttributes.Virtual) 443585"];
13734 [label="param HasFlag(MethodAttributes flag) 443586"];
13735 [label="param HasFlag(this) 443587"];
13736 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443588"];
13737 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443589"];
13738 [label="return ((ushort)flag & _flags) != 0; 443590"];
13739 [label="this.IsMetadataVirtual() && !this.IsDestructor 443591"];
13740 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal 443592"];
13741 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract 443593"];
13742 [label="this.IsMetadataVirtual() && !this.IsDestructor && !this.IsMetadataFinal && !this.IsAbstract &&\n                                          (this._containingType.IsInterface ? this.IsMetadataNewSlot() : !this.IsOverride) 443594"];
13743 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443595"];
13744 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443596"];
13745 [label="return !IsOverride && !IsAbstract &&\n                    (((object)_getMethod != null && _getMethod.IsVirtual) ||\n                     ((object)_setMethod != null && _setMethod.IsVirtual)); 443597"];
13746 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443598"];
13747 [label="property.IsOverride 443599"];
13748 [label="get\n            {\n                // Some accessor override.\n                return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride);\n            } 443600"];
13749 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443601"];
13750 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443602"];
13751 [label="_getMethod.IsOverride 443603"];
13752 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443604"];
13753 [label="this._containingType.IsInterface 443605"];
13754 [label="get\n            {\n                return _flags.IsInterface();\n            } 443606"];
13755 [label="this.IsMetadataVirtual() 443607"];
13756 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443608"];
13757 [label="=> HasFlag(MethodAttributes.Virtual) 443609"];
13758 [label="MethodAttributes.Virtual 443610"];
13759 [label="HasFlag(MethodAttributes.Virtual) 443611"];
13760 [label="param HasFlag(MethodAttributes flag) 443612"];
13761 [label="param HasFlag(this) 443613"];
13762 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443614"];
13763 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443615"];
13764 [label="return ((ushort)flag & _flags) != 0; 443616"];
13765 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443617"];
13766 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443618"];
13767 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443619"];
13768 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443620"];
13769 [label="_setMethod.IsOverride 443621"];
13770 [label="=>\n            !this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443622"];
13771 [label="this._containingType.IsInterface 443623"];
13772 [label="get\n            {\n                return _flags.IsInterface();\n            } 443624"];
13773 [label="this.IsMetadataVirtual() 443625"];
13774 [label="param IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false) 443626"];
13775 [label="=> HasFlag(MethodAttributes.Virtual) 443627"];
13776 [label="MethodAttributes.Virtual 443628"];
13777 [label="HasFlag(MethodAttributes.Virtual) 443629"];
13778 [label="param HasFlag(MethodAttributes flag) 443630"];
13779 [label="param HasFlag(this) 443631"];
13780 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443632"];
13781 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443633"];
13782 [label="return ((ushort)flag & _flags) != 0; 443634"];
13783 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() 443635"];
13784 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor 443636"];
13785 [label="!this._containingType.IsInterface &&\n            this.IsMetadataVirtual() && !this.IsDestructor &&\n            ((!this.IsMetadataNewSlot() && (object)_containingType.BaseTypeNoUseSiteDiagnostics != null) || this.IsExplicitClassOverride) 443637"];
13786 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443638"];
13787 [label="return\n                    ((object)_getMethod != null && _getMethod.IsOverride) ||\n                    ((object)_setMethod != null && _setMethod.IsOverride); 443639"];
13788 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443640"];
13789 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443641"];
13790 [label="property.IsAbstract 443642"];
13791 [label="get\n            {\n                // Some accessor abstract.\n                return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract);\n            } 443643"];
13792 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443644"];
13793 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443645"];
13794 [label="_getMethod.IsAbstract 443646"];
13795 [label="=> HasFlag(MethodAttributes.Abstract) 443647"];
13796 [label="MethodAttributes.Abstract 443648"];
13797 [label="HasFlag(MethodAttributes.Abstract) 443649"];
13798 [label="param HasFlag(MethodAttributes flag) 443650"];
13799 [label="param HasFlag(this) 443651"];
13800 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443652"];
13801 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443653"];
13802 [label="return ((ushort)flag & _flags) != 0; 443654"];
13803 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443655"];
13804 [label="_setMethod.IsAbstract 443656"];
13805 [label="=> HasFlag(MethodAttributes.Abstract) 443657"];
13806 [label="MethodAttributes.Abstract 443658"];
13807 [label="HasFlag(MethodAttributes.Abstract) 443659"];
13808 [label="param HasFlag(MethodAttributes flag) 443660"];
13809 [label="param HasFlag(this) 443661"];
13810 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443662"];
13811 [label="Debug.Assert(flag != 0 && ((ushort)flag & ((ushort)flag - 1)) == 0); 443663"];
13812 [label="return ((ushort)flag & _flags) != 0; 443664"];
13813 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443665"];
13814 [label="return\n                    ((object)_getMethod != null && _getMethod.IsAbstract) ||\n                    ((object)_setMethod != null && _setMethod.IsAbstract); 443666"];
13815 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443667"];
13816 [label="if (((descriptor.Flags & MemberFlags.Virtual) != 0) != (property.IsVirtual || property.IsOverride || property.IsAbstract))\n                            {\n                                continue;\n                            } 443668"];
13817 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 443669"];
13818 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 443670"];
13819 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 443671"];
13820 [label="if (!comparer.MatchPropertySignature(property, descriptor.Signature))\n                            {\n                                continue;\n                            } 443672"];
13821 [label="param GetParameters(PropertySymbol property) 443673"];
13822 [label="param GetParameters(this) 443674"];
13823 [label="property.Parameters 443675"];
13824 [label="get { return _parameters; } 443676"];
13825 [label="return property.Parameters; 443677"];
13826 [label="param IsByRefProperty(PropertySymbol property) 443678"];
13827 [label="param IsByRefProperty(this) 443679"];
13828 [label="property.RefKind 443680"];
13829 [label="get { return _refKind; } 443681"];
13830 [label="return _refKind; 443682"];
13831 [label="return property.RefKind != RefKind.None; 443683"];
13832 [label="param GetPropertyType(PropertySymbol property) 443684"];
13833 [label="param GetPropertyType(this) 443685"];
13834 [label="property.Type 443686"];
13835 [label="=> TypeWithAnnotations.Type 443687"];
13836 [label="TypeWithAnnotations 443688"];
13837 [label="get { return _propertyTypeWithAnnotations; } 443689"];
13838 [label="return _propertyTypeWithAnnotations; 443690"];
13839 [label="TypeWithAnnotations.Type 443691"];
13840 [label="=> _extensions?.GetResolvedType(DefaultType) 443692"];
13841 [label="=> defaultType 443693"];
13842 [label="return property.Type; 443694"];
13843 [label="param MatchTypeToTypeId(this) 443695"];
13844 [label="WellKnownType wellKnownId = (WellKnownType)typeId; 443696"];
13845 [label="if (wellKnownId.IsWellKnownType())\n                {\n                    return type.Equals(_compilation.GetWellKnownType(wellKnownId), TypeCompareKind.IgnoreNullableModifiersForReferenceTypes);\n                } 443697"];
13846 [label="param MatchTypeToTypeId(this) 443698"];
13847 [label="if (result is object)\n                {\n                    result = null;\n                    break;\n                } 443699"];
13848 [label="Interlocked.CompareExchange(ref _lazyWellKnownTypeMembers[(int)member], result, ErrorTypeSymbol.UnknownResultType); 443700"];
13849 [label="param GetUseSiteDiagnostic(this) 443701"];
13850 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                _lazyUseSiteDiagnostic = result;\n            } 443702"];
13851 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                DiagnosticInfo result = null;\n                CalculateUseSiteDiagnostic(ref result);\n                _lazyUseSiteDiagnostic = result;\n            } 443703"];
13852 [label="DiagnosticInfo result = null; 443704"];
13853 [label="CalculateUseSiteDiagnostic(ref result); 443705"];
13854 [label="CalculateUseSiteDiagnostic(ref result) 443706"];
13855 [label="param CalculateUseSiteDiagnostic(ref DiagnosticInfo result) 443707"];
13856 [label="param CalculateUseSiteDiagnostic(this) 443708"];
13857 [label="this.IsDefinition 443709"];
13858 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 443710"];
13859 [label="get\n            {\n                return this.OriginalDefinition;\n            } 443711"];
13860 [label="this.OriginalDefinition 443712"];
13861 [label="get\n            {\n                return this;\n            } 443713"];
13862 [label="return this; 443714"];
13863 [label="return this.OriginalDefinition; 443715"];
13864 [label="Debug.Assert(this.IsDefinition); 443716"];
13865 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443717"];
13866 [label="this.TypeWithAnnotations 443718"];
13867 [label="get { return _propertyTypeWithAnnotations; } 443719"];
13868 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443720"];
13869 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443721"];
13870 [label="DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) 443722"];
13871 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 443723"];
13872 [label="param DeriveUseSiteDiagnosticFromType(TypeWithAnnotations type) 443724"];
13873 [label="param DeriveUseSiteDiagnosticFromType(AllowedRequiredModifierType allowedRequiredModifierType) 443725"];
13874 [label="param DeriveUseSiteDiagnosticFromType(this) 443726"];
13875 [label="=> defaultType 443727"];
13876 [label="param DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result) 443728"];
13877 [label="param DeriveUseSiteDiagnosticFromType(this) 443729"];
13878 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 443730"];
13879 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 443731"];
13880 [label="s.Kind 443732"];
13881 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 443733"];
13882 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 443734"];
13883 [label="Debug.Assert((object)moduleSymbol != null); 443735"];
13884 [label="if (skipTransformsIfNecessary)\n                    {\n                        // If the transforms are not necessary, return early without updating the\n                        // base type field. This avoids cycles decoding nullability in particular.\n                        return baseType;\n                    } 443736"];
13885 [label="param TransformType(int targetSymbolCustomModifierCount) 443737"];
13886 [label="param TransformType(RefKind targetSymbolRefKind = RefKind.None) 443738"];
13887 [label="Debug.Assert((object)metadataType != null); 443739"];
13888 [label="if (hasTupleElementNamesAttribute && elementNames.IsDefaultOrEmpty)\n            {\n                return new UnsupportedMetadataTypeSymbol();\n            } 443740"];
13889 [label="param TupleTypeDecoder(ImmutableArray<string?> elementNames) 443741"];
13890 [label="_elementNames 443742"];
13891 [label="elementNames.IsDefault 443743"];
13892 [label="_namesIndex = elementNames.IsDefault ? 0 : elementNames.Length; 443744"];
13893 [label="_namesIndex 443745"];
13894 [label="_foundUsableErrorType = false; 443746"];
13895 [label="_foundUsableErrorType 443747"];
13896 [label="param DecodeType(this) 443748"];
13897 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443749"];
13898 [label="param DecodeNamedType(this) 443750"];
13899 [label="type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 443751"];
13900 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 443752"];
13901 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 443753"];
13902 [label="var typeArgs = type.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 443754"];
13903 [label="var decodedArgs = DecodeTypeArguments(typeArgs); 443755"];
13904 [label="DecodeTypeArguments(typeArgs) 443756"];
13905 [label="param DecodeTypeArguments(ImmutableArray<TypeWithAnnotations> typeArgs) 443757"];
13906 [label="param DecodeTypeArguments(this) 443758"];
13907 [label="if (typeArgs.IsEmpty)\n            {\n                return typeArgs;\n            } 443759"];
13908 [label="return typeArgs; 443760"];
13909 [label="type.ContainingType 443761"];
13910 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 443762"];
13911 [label="return _container as NamedTypeSymbol; 443763"];
13912 [label="NamedTypeSymbol containingType = type.ContainingType; 443764"];
13913 [label="NamedTypeSymbol? decodedContainingType; 443765"];
13914 [label="if (containingType is object && containingType.IsGenericType)\n            {\n                decodedContainingType = DecodeNamedType(containingType);\n                Debug.Assert(decodedContainingType.IsGenericType);\n            }\n            else\n            {\n                decodedContainingType = containingType;\n            } 443766"];
13915 [label="decodedContainingType = containingType; 443767"];
13916 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 443768"];
13917 [label="var containerChanged = !ReferenceEquals(decodedContainingType, containingType); 443769"];
13918 [label="var typeArgsChanged = typeArgs != decodedArgs; 443770"];
13919 [label="if (typeArgsChanged || containerChanged)\n            {\n                if (containerChanged)\n                {\n                    decodedType = decodedType.OriginalDefinition.AsMember(decodedContainingType);\n                    // If the type is nested, e.g. Outer<T>.Inner<V>, then Inner is definitely\n                    // not a tuple, since we know all tuple-compatible types (System.ValueTuple)\n                    // are not nested types. Thus, it is safe to return without checking if\n                    // Inner is a tuple.\n                    return decodedType.ConstructIfGeneric(decodedArgs);\n                }\n\n                decodedType = type.ConstructedFrom.Construct(decodedArgs, unbound: false);\n            } 443771"];
13920 [label="decodedType.IsTupleType 443772"];
13921 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 443773"];
13922 [label="_ 443774"];
13923 [label="tupleCardinality: out _ 443775"];
13924 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 443776"];
13925 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 443777"];
13926 [label="param IsTupleTypeOfCardinality(this) 443778"];
13927 [label="IsUnboundGenericType 443779"];
13928 [label="get\n            {\n                return false;\n            } 443780"];
13929 [label="return false; 443781"];
13930 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443782"];
13931 [label="ContainingSymbol 443783"];
13932 [label="get\n            {\n                return _container;\n            } 443784"];
13933 [label="return _container; 443785"];
13934 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443786"];
13935 [label=".Kind 443787"];
13936 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 443788"];
13937 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443789"];
13938 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443790"];
13939 [label="ContainingNamespace 443791"];
13940 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 443792"];
13941 [label="get\n            {\n                return _container;\n            } 443793"];
13942 [label="return _container; 443794"];
13943 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443795"];
13944 [label="ContainingNamespace.ContainingNamespace 443796"];
13945 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 443797"];
13946 [label=".IsGlobalNamespace 443798"];
13947 [label="get\n            {\n                return true;\n            } 443799"];
13948 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443800"];
13949 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443801"];
13950 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443802"];
13951 [label="Name 443803"];
13952 [label="get\n            {\n                return _name;\n            } 443804"];
13953 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443805"];
13954 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443806"];
13955 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 443807"];
13956 [label="tupleCardinality = 0; 443808"];
13957 [label="return false; 443809"];
13958 [label="if (decodedType.IsTupleType)\n            {\n                int tupleCardinality = decodedType.TupleElementTypesWithAnnotations.Length;\n                if (tupleCardinality > 0)\n                {\n                    var elementNames = EatElementNamesIfAvailable(tupleCardinality);\n\n                    Debug.Assert(elementNames.IsDefault || elementNames.Length == tupleCardinality);\n\n                    decodedType = NamedTypeSymbol.CreateTuple(decodedType, elementNames);\n                }\n            } 443810"];
13959 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 443811"];
13960 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 443812"];
13961 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 443813"];
13962 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 443814"];
13963 [label="typeSymbol.IsNullableType() 443815"];
13964 [label="param IsNullableType(this TypeSymbol type) 443816"];
13965 [label="type.OriginalDefinition 443817"];
13966 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 443818"];
13967 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 443819"];
13968 [label="type.OriginalDefinition.SpecialType 443820"];
13969 [label="get\n            {\n                return _corTypeId;\n            } 443821"];
13970 [label="var a1 = defaultType is null; 443822"];
13971 [label="!a1 443823"];
13972 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 443824"];
13973 [label="defaultType.IsNullableType() 443825"];
13974 [label="param IsNullableType(this TypeSymbol type) 443826"];
13975 [label="type.OriginalDefinition 443827"];
13976 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 443828"];
13977 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 443829"];
13978 [label="type.OriginalDefinition.SpecialType 443830"];
13979 [label="get\n            {\n                return _corTypeId;\n            } 443831"];
13980 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 443832"];
13981 [label="Debug.Assert(a1 || a2 != true || a3); 443833"];
13982 [label="Debug.Assert(a1 || a2 != true || a3); 443834"];
13983 [label="Debug.Assert(extensions != null); 443835"];
13984 [label="metadataType.HasType 443836"];
13985 [label="=> !(DefaultType is null) 443837"];
13986 [label="DefaultType is null 443838"];
13987 [label="!(DefaultType is null) 443839"];
13988 [label="Debug.Assert(metadataType.HasType); 443840"];
13989 [label="Debug.Assert(accessSymbol.IsDefinition); 443841"];
13990 [label="Debug.Assert((object)accessSymbol.ContainingModule == containingModule); 443842"];
13991 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 443843"];
13992 [label="AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _) 443844"];
13993 [label="param IsEffectivelyPublicOrInternal(Symbol symbol) 443845"];
13994 [label="param IsEffectivelyPublicOrInternal(out bool isInternal) 443846"];
13995 [label="Debug.Assert(symbol is object); 443847"];
13996 [label="symbol.Kind 443848"];
13997 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443849"];
13998 [label="switch (symbol.Kind)\n            {\n                case SymbolKind.NamedType:\n                case SymbolKind.Event:\n                case SymbolKind.Field:\n                case SymbolKind.Method:\n                case SymbolKind.Property:\n                    break;\n                case SymbolKind.TypeParameter:\n                    symbol = symbol.ContainingSymbol;\n                    break;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(symbol.Kind);\n            } 443850"];
13999 [label="isInternal = false; 443851"];
14000 [label="symbol.DeclaredAccessibility 443852"];
14001 [label="get\n            {\n                Accessibility access = Accessibility.Private;\n\n                switch (_flags & TypeAttributes.VisibilityMask)\n                {\n                    case TypeAttributes.NestedAssembly:\n                        access = Accessibility.Internal;\n                        break;\n\n                    case TypeAttributes.NestedFamORAssem:\n                        access = Accessibility.ProtectedOrInternal;\n                        break;\n\n                    case TypeAttributes.NestedFamANDAssem:\n                        access = Accessibility.ProtectedAndInternal;\n                        break;\n\n                    case TypeAttributes.NestedPrivate:\n                        access = Accessibility.Private;\n                        break;\n\n                    case TypeAttributes.Public:\n                    case TypeAttributes.NestedPublic:\n                        access = Accessibility.Public;\n                        break;\n\n                    case TypeAttributes.NestedFamily:\n                        access = Accessibility.Protected;\n                        break;\n\n                    case TypeAttributes.NotPublic:\n                        access = Accessibility.Internal;\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(_flags & TypeAttributes.VisibilityMask);\n                }\n\n                return access;\n            } 443853"];
14002 [label="Accessibility access = Accessibility.Private; 443854"];
14003 [label="switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                } 443855"];
14004 [label="symbol.ContainingType 443856"];
14005 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 443857"];
14006 [label="return _container as NamedTypeSymbol; 443858"];
14007 [label="symbol = symbol.ContainingType; 443859"];
14008 [label="do\n            {\n                switch (symbol.DeclaredAccessibility)\n                {\n                    case Accessibility.Public:\n                    case Accessibility.Protected:\n                    case Accessibility.ProtectedOrInternal:\n                        break;\n                    case Accessibility.Internal:\n                    case Accessibility.ProtectedAndInternal:\n                        isInternal = true;\n                        break;\n                    case Accessibility.Private:\n                        return false;\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(symbol.DeclaredAccessibility);\n                }\n\n                symbol = symbol.ContainingType;\n            }\n            while (symbol is object); 443860"];
14009 [label="return true; 443861"];
14010 [label="_ = AccessCheck.IsEffectivelyPublicOrInternal(accessSymbol, out _); 443862"];
14011 [label="param TryGetByte(out byte? value) 443863"];
14012 [label="value = null; 443864"];
14013 [label="param GetLocalNullableContextValue(this) 443865"];
14014 [label="get\n            {\n                return _moduleSymbol;\n            } 443866"];
14015 [label="return _moduleSymbol; 443867"];
14016 [label="param GetLocalNullableContextValue(this) 443868"];
14017 [label="get\n            {\n                return _assemblySymbol;\n            } 443869"];
14018 [label="return _assemblySymbol; 443870"];
14019 [label="param GetLocalNullableContextValue(this) 443871"];
14020 [label="get\n            {\n                return null;\n            } 443872"];
14021 [label="=> defaultType 443873"];
14022 [label="Debug.Assert((object)depends != null); 443874"];
14023 [label="Debug.Assert((object)on != null); 443875"];
14024 [label="Debug.Assert(on.IsDefinition); 443876"];
14025 [label="depends.DeclaringCompilation 443877"];
14026 [label="get { return null; } 443878"];
14027 [label="return null; 443879"];
14028 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 443880"];
14029 [label="if ((object)type == null)\n            {\n                return;\n            } 443881"];
14030 [label="return; 443882"];
14031 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 443883"];
14032 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 443884"];
14033 [label="return result; 443885"];
14034 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 443886"];
14035 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 443887"];
14036 [label="@base.IsErrorType() 443888"];
14037 [label="param IsErrorType(this TypeSymbol type) 443889"];
14038 [label="RoslynDebug.Assert((object)type != null); 443890"];
14039 [label="RoslynDebug.Assert((object)type != null); 443891"];
14040 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 443892"];
14041 [label="if (@base.IsErrorType() && @base is NoPiaIllegalGenericInstantiationSymbol)\n                {\n                    return @base.GetUseSiteDiagnostic();\n                } 443893"];
14042 [label="param MergeUseSiteDiagnostics(this) 443894"];
14043 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 443895"];
14044 [label="this.ContainingModule.HasUnifiedReferences 443896"];
14045 [label="get { return GetUnifiedAssemblies().Length > 0; } 443897"];
14046 [label="GetUnifiedAssemblies() 443898"];
14047 [label="param GetUnifiedAssemblies(this) 443899"];
14048 [label="AssertReferencesInitialized() 443900"];
14049 [label="param AssertReferencesInitialized(this) 443901"];
14050 [label="Debug.Assert(_moduleReferences != null); 443902"];
14051 [label="Debug.Assert(_moduleReferences != null); 443903"];
14052 [label="AssertReferencesInitialized(); 443904"];
14053 [label="return GetUnifiedAssemblies().Length > 0; 443905"];
14054 [label="return GetUnifiedAssemblies().Length > 0; 443906"];
14055 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 443907"];
14056 [label="return _lazyUseSiteDiagnostic; 443908"];
14057 [label="DiagnosticInfo info = type.GetUseSiteDiagnostic(); 443909"];
14058 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 443910"];
14059 [label="if (info != null)\n            {\n                if (info.Code == (int)ErrorCode.ERR_BogusType)\n                {\n                    info = GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? info;\n                }\n            } 443911"];
14060 [label="return MergeUseSiteDiagnostics(ref result, info); 443912"];
14061 [label="return MergeUseSiteDiagnostics(ref result, info); 443913"];
14062 [label="MergeUseSiteDiagnostics(ref result, info) 443914"];
14063 [label="param MergeUseSiteDiagnostics(ref DiagnosticInfo result) 443915"];
14064 [label="param MergeUseSiteDiagnostics(DiagnosticInfo info) 443916"];
14065 [label="param MergeUseSiteDiagnostics(this) 443917"];
14066 [label="type.CustomModifiers 443918"];
14067 [label="=> _extensions.CustomModifiers 443919"];
14068 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType) 443920"];
14069 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 443921"];
14070 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 443922"];
14071 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 443923"];
14072 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 443924"];
14073 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 443925"];
14074 [label="bool checkRequiredModifiers = true; 443926"];
14075 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 443927"];
14076 [label="return false; 443928"];
14077 [label="return DeriveUseSiteDiagnosticFromType(ref result, type.Type) ||\n                   DeriveUseSiteDiagnosticFromCustomModifiers(ref result, type.CustomModifiers, allowedRequiredModifierType); 443929"];
14078 [label="this.RefCustomModifiers 443930"];
14079 [label="get { return ImmutableArray<CustomModifier>.Empty; } 443931"];
14080 [label="return ImmutableArray<CustomModifier>.Empty; 443932"];
14081 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443933"];
14082 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443934"];
14083 [label="DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) 443935"];
14084 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result) 443936"];
14085 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(ImmutableArray<CustomModifier> customModifiers) 443937"];
14086 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(AllowedRequiredModifierType allowedRequiredModifierType) 443938"];
14087 [label="param DeriveUseSiteDiagnosticFromCustomModifiers(this) 443939"];
14088 [label="AllowedRequiredModifierType requiredModifiersFound = AllowedRequiredModifierType.None; 443940"];
14089 [label="bool checkRequiredModifiers = true; 443941"];
14090 [label="foreach (CustomModifier modifier in customModifiers)\n            {\n                NamedTypeSymbol modifierType = ((CSharpCustomModifier)modifier).ModifierSymbol;\n\n                if (checkRequiredModifiers && !modifier.IsOptional)\n                {\n                    AllowedRequiredModifierType current = AllowedRequiredModifierType.None;\n\n                    if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeInAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile) != 0 &&\n                        modifierType.SpecialType == SpecialType.System_Runtime_CompilerServices_IsVolatile)\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_Volatile;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit) != 0 &&\n                        modifierType.IsWellKnownTypeIsExternalInit())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_IsExternalInit;\n                    }\n                    else if ((allowedRequiredModifierType & AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute) != 0 &&\n                        modifierType.IsWellKnownTypeOutAttribute())\n                    {\n                        current = AllowedRequiredModifierType.System_Runtime_CompilerServices_OutAttribute;\n                    }\n\n                    if (current == AllowedRequiredModifierType.None ||\n                        (current != requiredModifiersFound && requiredModifiersFound != AllowedRequiredModifierType.None)) // At the moment we don't support applying different allowed modreqs to the same target.\n                    {\n                        if (MergeUseSiteDiagnostics(ref result, GetSymbolSpecificUnsupportedMetadataUseSiteErrorInfo() ?? new CSDiagnosticInfo(ErrorCode.ERR_BogusType, string.Empty)))\n                        {\n                            return true;\n                        }\n\n                        checkRequiredModifiers = false;\n                    }\n\n                    requiredModifiersFound |= current;\n                }\n\n                // Unbound generic type is valid as a modifier, let's not report any use site diagnostics because of that.\n                if (modifierType.IsUnboundGenericType)\n                {\n                    modifierType = modifierType.OriginalDefinition;\n                }\n\n                if (DeriveUseSiteDiagnosticFromType(ref result, modifierType))\n                {\n                    return true;\n                }\n            } 443942"];
14091 [label="return false; 443943"];
14092 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443944"];
14093 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443945"];
14094 [label="this.Parameters 443946"];
14095 [label="get { return _parameters; } 443947"];
14096 [label="return _parameters; 443948"];
14097 [label="DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters) 443949"];
14098 [label="param DeriveUseSiteDiagnosticFromParameters(ref DiagnosticInfo result) 443950"];
14099 [label="param DeriveUseSiteDiagnosticFromParameters(ImmutableArray<ParameterSymbol> parameters) 443951"];
14100 [label="param DeriveUseSiteDiagnosticFromParameters(this) 443952"];
14101 [label="return false; 443953"];
14102 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443954"];
14103 [label="if (DeriveUseSiteDiagnosticFromType(ref result, this.TypeWithAnnotations, AllowedRequiredModifierType.None) ||\n                DeriveUseSiteDiagnosticFromCustomModifiers(ref result, this.RefCustomModifiers, AllowedRequiredModifierType.System_Runtime_InteropServices_InAttribute) ||\n                DeriveUseSiteDiagnosticFromParameters(ref result, this.Parameters))\n            {\n                return true;\n            } 443955"];
14104 [label="this.ContainingModule 443956"];
14105 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 443957"];
14106 [label="get\n            {\n                return _containingType;\n            } 443958"];
14107 [label="return _containingType; 443959"];
14108 [label="s.Kind 443960"];
14109 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 443961"];
14110 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 443962"];
14111 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (this.TypeWithAnnotations.GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.RefCustomModifiers, this, ref unificationCheckedTypes) ||\n                    GetUnificationUseSiteDiagnosticRecursive(ref result, this.Parameters, this, ref unificationCheckedTypes))\n                {\n                    return true;\n                }\n            } 443963"];
14112 [label="this.ContainingModule.HasUnifiedReferences 443964"];
14113 [label="get { return GetUnifiedAssemblies().Length > 0; } 443965"];
14114 [label="GetUnifiedAssemblies() 443966"];
14115 [label="param GetUnifiedAssemblies(this) 443967"];
14116 [label="AssertReferencesInitialized() 443968"];
14117 [label="param AssertReferencesInitialized(this) 443969"];
14118 [label="Debug.Assert(_moduleReferences != null); 443970"];
14119 [label="Debug.Assert(_moduleReferences != null); 443971"];
14120 [label="AssertReferencesInitialized(); 443972"];
14121 [label="return GetUnifiedAssemblies().Length > 0; 443973"];
14122 [label="return GetUnifiedAssemblies().Length > 0; 443974"];
14123 [label="return false; 443975"];
14124 [label="CalculateUseSiteDiagnostic(ref result); 443976"];
14125 [label="_lazyUseSiteDiagnostic 443977"];
14126 [label="return _lazyUseSiteDiagnostic; 443978"];
14127 [label="var info = this.GetUseSiteDiagnostic(); 443979"];
14128 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 443980"];
14129 [label="if (info != null && info.Severity == DiagnosticSeverity.Error)\n            {\n                return info;\n            } 443981"];
14130 [label="get\n            {\n                return _containingType;\n            } 443982"];
14131 [label="return _containingType; 443983"];
14132 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 443984"];
14133 [label="return _lazyUseSiteDiagnostic; 443985"];
14134 [label="return this.ContainingType.GetUseSiteDiagnostic() ?? info; 443986"];
14135 [label="diagnosticInfo = memberSymbol.GetUseSiteDiagnosticForSymbolOrContainingType(); 443987"];
14136 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 443988"];
14137 [label="if (diagnosticInfo != null)\n                {\n                    // Dev11 reports use-site diagnostics even for optional symbols that are found.\n                    // We decided to silently ignore bad optional symbols.\n\n                    // Report errors only for non-optional members:\n                    if (isOptional)\n                    {\n                        var severity = diagnosticInfo.Severity;\n\n                        // ignore warnings:\n                        diagnosticInfo = null;\n\n                        // if the member is optional and bad for whatever reason ignore it:\n                        if (severity == DiagnosticSeverity.Error)\n                        {\n                            return null;\n                        }\n                    }\n                } 443989"];
14138 [label="return memberSymbol; 443990"];
14139 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 443991"];
14140 [label="if (useSiteDiagnostic != null)\n            {\n                // report the diagnostic only for non-optional members:\n                Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location ?? syntax.Location);\n            } 443992"];
14141 [label="return memberSymbol; 443993"];
14142 [label="ReportDiagnosticsForSynthesizedAttributes(_compilation, diagnostics); 443994"];
14143 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 443995"];
14144 [label="param AddDeclarationDiagnostics(this) 443996"];
14145 [label="ContainingSymbol 443997"];
14146 [label="get\n            {\n                return null;\n            } 443998"];
14147 [label="return null; 443999"];
14148 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444000"];
14149 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444001"];
14150 [label="Assembly.ForceComplete(location, cancellationToken); 444002"];
14151 [label="return (_completeParts & (int)part) == (int)part; 444003"];
14152 [label="return; 444004"];
14153 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444005"];
14154 [label="param HasAtMostOneBitSet(int bits) 444006"];
14155 [label="return (bits & (bits - 1)) == 0; 444007"];
14156 [label="this.Modules 444008"];
14157 [label="return (SourceModuleSymbol)this.Modules[0]; 444009"];
14158 [label="param GetAttributes(this) 444010"];
14159 [label="this.GetAttributesBag() 444011"];
14160 [label="param GetAttributesBag(this) 444012"];
14161 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations();\n                if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                }\n            } 444013"];
14162 [label="if (_lazyCustomAttributesBag == null || !_lazyCustomAttributesBag.IsSealed)\n            {\n                var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations();\n                if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                }\n            } 444014"];
14163 [label="this.ContainingAssembly 444015"];
14164 [label="get\n            {\n                return _assemblySymbol;\n            } 444016"];
14165 [label="return _assemblySymbol; 444017"];
14166 [label="var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations(); 444018"];
14167 [label="((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations() 444019"];
14168 [label="param GetAttributeDeclarations(this) 444020"];
14169 [label="var builder = ArrayBuilder<SyntaxList<AttributeListSyntax>>.GetInstance(); 444021"];
14170 [label="foreach (RootSingleNamespaceDeclaration rootNs in declarations)\n            {\n                if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                }\n            } 444022"];
14171 [label="if (rootNs.HasAssemblyAttributes)\n                {\n                    var tree = rootNs.Location.SourceTree;\n                    var root = (CompilationUnitSyntax)tree.GetRoot();\n                    builder.Add(root.AttributeLists);\n                } 444023"];
14172 [label="return builder.ToImmutableAndFree(); 444024"];
14173 [label="var mergedAttributes = ((SourceAssemblySymbol)this.ContainingAssembly).GetAttributeDeclarations(); 444025"];
14174 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 444026"];
14175 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 444027"];
14176 [label="if (LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag))\n                {\n                    var completed = _state.NotePartComplete(CompletionPart.Attributes);\n                    Debug.Assert(completed);\n                } 444028"];
14177 [label="LoadAndValidateAttributes(OneOrMany.Create(mergedAttributes), ref _lazyCustomAttributesBag) 444029"];
14178 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 444030"];
14179 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 444031"];
14180 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 444032"];
14181 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 444033"];
14182 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 444034"];
14183 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 444035"];
14184 [label="param LoadAndValidateAttributes(this) 444036"];
14185 [label="var diagnostics = DiagnosticBag.GetInstance(); 444037"];
14186 [label="this.DeclaringCompilation 444038"];
14187 [label="get\n            {\n                return _assemblySymbol.DeclaringCompilation;\n            } 444039"];
14188 [label="get\n            {\n                return _compilation;\n            } 444040"];
14189 [label="var compilation = this.DeclaringCompilation; 444041"];
14190 [label="ImmutableArray<Binder> binders; 444042"];
14191 [label="binders 444043"];
14192 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 444044"];
14193 [label="param GetAttributesToBind(AttributeLocation symbolPart) 444045"];
14194 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 444046"];
14195 [label="param GetAttributesToBind(CSharpCompilation compilation) 444047"];
14196 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 444048"];
14197 [label="param GetAttributesToBind(Binder rootBinderOpt) 444049"];
14198 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 444050"];
14199 [label="param GetAttributesToBind(this) 444051"];
14200 [label="var attributeTarget = (IAttributeTargetSymbol)this; 444052"];
14201 [label="ArrayBuilder<Binder> bindersBuilder = null; 444053"];
14202 [label="int attributesToBindCount = 0; 444054"];
14203 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 444055"];
14204 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 444056"];
14205 [label="binders = ImmutableArray<Binder>.Empty; 444057"];
14206 [label="Debug.Assert(!attributesToBind.IsDefault); 444058"];
14207 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 444059"];
14208 [label="boundAttributes 444060"];
14209 [label="WellKnownAttributeData wellKnownAttributeData; 444061"];
14210 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 444062"];
14211 [label="wellKnownAttributeData = null; 444063"];
14212 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 444064"];
14213 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 444065"];
14214 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 444066"];
14215 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 444067"];
14216 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444068"];
14217 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444069"];
14218 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444070"];
14219 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444071"];
14220 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 444072"];
14221 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 444073"];
14222 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 444074"];
14223 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 444075"];
14224 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 444076"];
14225 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 444077"];
14226 [label="param PostDecodeWellKnownAttributes(this) 444078"];
14227 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444079"];
14228 [label="bool lazyAttributesStoredOnThisThread = false; 444080"];
14229 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444081"];
14230 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 444082"];
14231 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 444083"];
14232 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 444084"];
14233 [label="param RecordPresenceOfBadAttributes(this) 444085"];
14234 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 444086"];
14235 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 444087"];
14236 [label="AddDeclarationDiagnostics(diagnostics); 444088"];
14237 [label="AddDeclarationDiagnostics(diagnostics) 444089"];
14238 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 444090"];
14239 [label="param AddDeclarationDiagnostics(this) 444091"];
14240 [label="ContainingSymbol 444092"];
14241 [label="get\n            {\n                return _assemblySymbol;\n            } 444093"];
14242 [label="return _assemblySymbol; 444094"];
14243 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444095"];
14244 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444096"];
14245 [label="AddDeclarationDiagnostics(diagnostics); 444097"];
14246 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 444098"];
14247 [label="diagnostics.Free(); 444099"];
14248 [label="var completed = _state.NotePartComplete(CompletionPart.Attributes); 444100"];
14249 [label="_state.NotePartComplete(CompletionPart.Attributes) 444101"];
14250 [label="param NotePartComplete(CompletionPart part) 444102"];
14251 [label="Debug.Assert(completed); 444103"];
14252 [label="return _lazyCustomAttributesBag; 444104"];
14253 [label="return this.GetAttributesBag().Attributes; 444105"];
14254 [label="Assembly.ForceComplete(location, cancellationToken); 444106"];
14255 [label="return (_completeParts & (int)part) == (int)part; 444107"];
14256 [label="return; 444108"];
14257 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444109"];
14258 [label="param HasAtMostOneBitSet(int bits) 444110"];
14259 [label="return (bits & (bits - 1)) == 0; 444111"];
14260 [label="get\n            {\n                return GetAssembliesToEmbedTypesFrom().Length > 0;\n            } 444112"];
14261 [label="GetAssembliesToEmbedTypesFrom() 444113"];
14262 [label="param GetAssembliesToEmbedTypesFrom(this) 444114"];
14263 [label="if (_lazyAssembliesToEmbedTypesFrom.IsDefault)\n            {\n                AssertReferencesInitialized();\n                var buffer = ArrayBuilder<AssemblySymbol>.GetInstance();\n\n                foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                }\n\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>));\n            } 444115"];
14264 [label="AssertReferencesInitialized() 444116"];
14265 [label="param AssertReferencesInitialized(this) 444117"];
14266 [label="Debug.Assert(_moduleReferences != null); 444118"];
14267 [label="Debug.Assert(_moduleReferences != null); 444119"];
14268 [label="AssertReferencesInitialized(); 444120"];
14269 [label="var buffer = ArrayBuilder<AssemblySymbol>.GetInstance(); 444121"];
14270 [label="this.GetReferencedAssemblySymbols() 444122"];
14271 [label="AssertReferencesInitialized() 444123"];
14272 [label="param AssertReferencesInitialized(this) 444124"];
14273 [label="Debug.Assert(_moduleReferences != null); 444125"];
14274 [label="Debug.Assert(_moduleReferences != null); 444126"];
14275 [label="AssertReferencesInitialized(); 444127"];
14276 [label="foreach (AssemblySymbol asm in this.GetReferencedAssemblySymbols())\n                {\n                    if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    }\n                } 444128"];
14277 [label="asm.IsLinked 444129"];
14278 [label="get\n            {\n                return _isLinked;\n            } 444130"];
14279 [label="return _isLinked; 444131"];
14280 [label="if (asm.IsLinked)\n                    {\n                        buffer.Add(asm);\n                    } 444132"];
14281 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 444133"];
14282 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 444134"];
14283 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyAssembliesToEmbedTypesFrom,\n                                                    buffer.ToImmutableAndFree(),\n                                                    default(ImmutableArray<AssemblySymbol>)); 444135"];
14284 [label="Debug.Assert(!_lazyAssembliesToEmbedTypesFrom.IsDefault); 444136"];
14285 [label="return _lazyAssembliesToEmbedTypesFrom; 444137"];
14286 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 444138"];
14287 [label="return GetAssembliesToEmbedTypesFrom().Length > 0; 444139"];
14288 [label="return (_completeParts & (int)part) == (int)part; 444140"];
14289 [label="return; 444141"];
14290 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444142"];
14291 [label="param HasAtMostOneBitSet(int bits) 444143"];
14292 [label="return (bits & (bits - 1)) == 0; 444144"];
14293 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                }\n\n                return _globalNamespace;\n            } 444145"];
14294 [label="if ((object)_globalNamespace == null)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var globalNS = new SourceNamespaceSymbol(\n                        this, this, DeclaringCompilation.MergedRootDeclaration, diagnostics);\n                    Debug.Assert(diagnostics.IsEmptyWithoutResolution);\n                    diagnostics.Free();\n                    Interlocked.CompareExchange(ref _globalNamespace, globalNS, null);\n                } 444146"];
14295 [label="param GetMembers(this) 444147"];
14296 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 444148"];
14297 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 444149"];
14298 [label="this.GetMembersUnordered() 444150"];
14299 [label="param GetMembersUnordered(this) 444151"];
14300 [label="var result = _lazyAllMembers; 444152"];
14301 [label="if (result.IsDefault)\n            {\n                var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null));  // don't sort.\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members);\n                result = _lazyAllMembers;\n            } 444153"];
14302 [label="this.GetNameToMembersMap() 444154"];
14303 [label="var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null)); 444155"];
14304 [label="var members = StaticCast<Symbol>.From(this.GetNameToMembersMap().Flatten(null)); 444156"];
14305 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members); 444157"];
14306 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyAllMembers, members); 444158"];
14307 [label="result = _lazyAllMembers; 444159"];
14308 [label="return result.ConditionallyDeOrder(); 444160"];
14309 [label="var allMembers = this.GetMembersUnordered(); 444161"];
14310 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 444162"];
14311 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 444163"];
14312 [label="ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted); 444164"];
14313 [label="ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted); 444165"];
14314 [label="return allMembers; 444166"];
14315 [label="Assembly.ForceComplete(location, cancellationToken); 444167"];
14316 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 444168"];
14317 [label="this.Kind 444169"];
14318 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 444170"];
14319 [label="return SymbolKind.Namespace; 444171"];
14320 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444172"];
14321 [label="this.ContainingModule 444173"];
14322 [label="get\n            {\n                return _module;\n            } 444174"];
14323 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 444175"];
14324 [label="param ForceCompleteMemberByLocation(SourceLocation locationOpt) 444176"];
14325 [label="param ForceCompleteMemberByLocation(Symbol member) 444177"];
14326 [label="param ForceCompleteMemberByLocation(CancellationToken cancellationToken) 444178"];
14327 [label="if (locationOpt == null || member.IsDefinedInSourceTree(locationOpt.SourceTree, locationOpt.SourceSpan, cancellationToken))\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                member.ForceComplete(locationOpt, cancellationToken);\n            } 444179"];
14328 [label="if (locationOpt == null || member.IsDefinedInSourceTree(locationOpt.SourceTree, locationOpt.SourceSpan, cancellationToken))\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n                member.ForceComplete(locationOpt, cancellationToken);\n            } 444180"];
14329 [label="cancellationToken.ThrowIfCancellationRequested(); 444181"];
14330 [label="member.ForceComplete(locationOpt, cancellationToken); 444182"];
14331 [label="member.ForceComplete(locationOpt, cancellationToken); 444183"];
14332 [label="member.ForceComplete(locationOpt, cancellationToken); 444184"];
14333 [label="member.ForceComplete(locationOpt, cancellationToken); 444185"];
14334 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444186"];
14335 [label="HasAtMostOneBitSet(next) 444187"];
14336 [label="param HasAtMostOneBitSet(int bits) 444188"];
14337 [label="return (bits & (bits - 1)) == 0; 444189"];
14338 [label="return (bits & (bits - 1)) == 0; 444190"];
14339 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444191"];
14340 [label="param SpinWaitComplete(CompletionPart part) 444192"];
14341 [label="param SpinWaitComplete(CancellationToken cancellationToken) 444193"];
14342 [label="param SpinWaitComplete(this) 444194"];
14343 [label="if (HasComplete(part))\n            {\n                return;\n            } 444195"];
14344 [label="HasComplete(part) 444196"];
14345 [label="param HasComplete(CompletionPart part) 444197"];
14346 [label="param HasComplete(this) 444198"];
14347 [label="return (_completeParts & (int)part) == (int)part; 444199"];
14348 [label="return; 444200"];
14349 [label="if ((_flags & LazyAllMembersIsSorted) != 0)\n            {\n                return _lazyAllMembers;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                }\n\n                ThreadSafeFlagOperations.Set(ref _flags, LazyAllMembersIsSorted);\n                return allMembers;\n            } 444201"];
14350 [label="if (allMembers.Length >= 2)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers);\n                } 444202"];
14351 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 444203"];
14352 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 444204"];
14353 [label="param ==(Symbol left) 444205"];
14354 [label="param ==(Symbol right) 444206"];
14355 [label="if (right is null)\n            {\n                return left is null;\n            } 444207"];
14356 [label="return (object)left == (object)right || right.Equals(left); 444208"];
14357 [label="return (object)left == (object)right || right.Equals(left); 444209"];
14358 [label="right.Equals(left) 444210"];
14359 [label="param Equals(object obj) 444211"];
14360 [label="param Equals(this) 444212"];
14361 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 444213"];
14362 [label="return this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind); 444214"];
14363 [label="this.Equals(obj as Symbol, SymbolEqualityComparer.Default.CompareKind) 444215"];
14364 [label="param Equals(Symbol other) 444216"];
14365 [label="param Equals(TypeCompareKind compareKind) 444217"];
14366 [label="param Equals(this) 444218"];
14367 [label="if (t2 is null)\n            {\n                return false;\n            } 444219"];
14368 [label="param Equals(TypeSymbol t2) 444220"];
14369 [label="param Equals(TypeCompareKind comparison) 444221"];
14370 [label="param Equals(this) 444222"];
14371 [label="t2 is NativeIntegerTypeSymbol 444223"];
14372 [label="return t2 is NativeIntegerTypeSymbol ?\n                ((NativeIntegerTypeSymbol)t2).Equals(this, comparison) :\n                base.Equals(t2, comparison); 444224"];
14373 [label="return t2 is NativeIntegerTypeSymbol ?\n                ((NativeIntegerTypeSymbol)t2).Equals(this, comparison) :\n                base.Equals(t2, comparison); 444225"];
14374 [label="base.Equals(t2, comparison) 444226"];
14375 [label="param Equals(TypeSymbol t2) 444227"];
14376 [label="param Equals(TypeCompareKind comparison) 444228"];
14377 [label="param Equals(this) 444229"];
14378 [label="if ((object)t2 == this) return true; 444230"];
14379 [label="if ((object)t2 == null) return false; 444231"];
14380 [label="if ((object)t2 == null) return false; 444232"];
14381 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 444233"];
14382 [label="if ((comparison & TypeCompareKind.IgnoreDynamic) != 0)\n            {\n                if (t2.TypeKind == TypeKind.Dynamic)\n                {\n                    // if ignoring dynamic, then treat dynamic the same as the type 'object'\n                    if (this.SpecialType == SpecialType.System_Object)\n                    {\n                        return true;\n                    }\n                }\n            } 444234"];
14383 [label="NamedTypeSymbol other = t2 as NamedTypeSymbol; 444235"];
14384 [label="if ((object)other == null) return false; 444236"];
14385 [label="if ((object)other == null) return false; 444237"];
14386 [label="this.OriginalDefinition 444238"];
14387 [label="get\n            {\n                return this;\n            } 444239"];
14388 [label="var thisOriginalDefinition = this.OriginalDefinition; 444240"];
14389 [label="other.OriginalDefinition 444241"];
14390 [label="get\n            {\n                return this;\n            } 444242"];
14391 [label="var otherOriginalDefinition = other.OriginalDefinition; 444243"];
14392 [label="bool thisIsOriginalDefinition = ((object)this == (object)thisOriginalDefinition); 444244"];
14393 [label="bool otherIsOriginalDefinition = ((object)other == (object)otherOriginalDefinition); 444245"];
14394 [label="if (thisIsOriginalDefinition && otherIsOriginalDefinition)\n            {\n                // If we continue, we either return false, or get into a cycle.\n                return false;\n            } 444246"];
14395 [label="return false; 444247"];
14396 [label="param GetLexicalSortKey(this) 444248"];
14397 [label="_lazyLexicalSortKey.IsInitialized 444249"];
14398 [label="get\n            {\n                return Volatile.Read(ref _position) >= 0;\n            } 444250"];
14399 [label="return Volatile.Read(ref _position) >= 0; 444251"];
14400 [label="return Volatile.Read(ref _position) >= 0; 444252"];
14401 [label="if (!_lazyLexicalSortKey.IsInitialized)\n            {\n                _lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation));\n            } 444253"];
14402 [label="this.DeclaringCompilation 444254"];
14403 [label="this.Kind 444255"];
14404 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444256"];
14405 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444257"];
14406 [label="get\n            {\n                return _containingSymbol;\n            } 444258"];
14407 [label="return _containingSymbol; 444259"];
14408 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 444260"];
14409 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 444261"];
14410 [label="param LexicalSortKey(Location location) 444262"];
14411 [label="param LexicalSortKey(CSharpCompilation compilation) 444263"];
14412 [label="param LexicalSortKey(this) 444264"];
14413 [label="location.SourceTree 444265"];
14414 [label="location.SourceSpan.Start 444266"];
14415 [label="compilation 444267"];
14416 [label="param LexicalSortKey(this) 444268"];
14417 [label="param LexicalSortKey(SyntaxTree tree) 444269"];
14418 [label="param LexicalSortKey(int position) 444270"];
14419 [label="param LexicalSortKey(CSharpCompilation compilation) 444271"];
14420 [label="param LexicalSortKey(this) 444272"];
14421 [label="null 444273"];
14422 [label="tree == null 444274"];
14423 [label="tree 444275"];
14424 [label="compilation.GetSyntaxTreeOrdinal(tree) 444276"];
14425 [label="param GetSyntaxTreeOrdinal(SyntaxTree tree) 444277"];
14426 [label="param GetSyntaxTreeOrdinal(this) 444278"];
14427 [label="Debug.Assert(this.ContainsSyntaxTree(tree)); 444279"];
14428 [label="this.ContainsSyntaxTree(tree) 444280"];
14429 [label="param ContainsSyntaxTree(SyntaxTree? syntaxTree) 444281"];
14430 [label="param ContainsSyntaxTree(this) 444282"];
14431 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 444283"];
14432 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 444284"];
14433 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 444285"];
14434 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 444286"];
14435 [label="return syntaxTree != null && _syntaxAndDeclarations.GetLazyState().RootNamespaces.ContainsKey(syntaxTree); 444287"];
14436 [label="return _syntaxAndDeclarations.GetLazyState().OrdinalMap[tree]; 444288"];
14437 [label="position 444289"];
14438 [label="param LexicalSortKey(int treeOrdinal) 444290"];
14439 [label="param LexicalSortKey(int position) 444291"];
14440 [label="param LexicalSortKey(this) 444292"];
14441 [label="Debug.Assert(position >= 0); 444293"];
14442 [label="Debug.Assert(position >= 0); 444294"];
14443 [label="Debug.Assert(treeOrdinal >= 0); 444295"];
14444 [label="Debug.Assert(treeOrdinal >= 0); 444296"];
14445 [label="_treeOrdinal 444297"];
14446 [label="_position 444298"];
14447 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)); 444299"];
14448 [label="_lazyLexicalSortKey.SetFrom(declaration.GetLexicalSortKey(this.DeclaringCompilation)) 444300"];
14449 [label="param SetFrom(LexicalSortKey other) 444301"];
14450 [label="param SetFrom(this) 444302"];
14451 [label="other.IsInitialized 444303"];
14452 [label="get\n            {\n                return Volatile.Read(ref _position) >= 0;\n            } 444304"];
14453 [label="Debug.Assert(other.IsInitialized); 444305"];
14454 [label="_treeOrdinal 444306"];
14455 [label="Volatile.Write(ref _position, other._position); 444307"];
14456 [label="Volatile.Write(ref _position, other._position); 444308"];
14457 [label="Volatile.Write(ref _position, other._position); 444309"];
14458 [label="return _lazyLexicalSortKey; 444310"];
14459 [label="allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance); 444311"];
14460 [label="this.Kind 444312"];
14461 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444313"];
14462 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444314"];
14463 [label="Debug.Assert(position >= 0); 444315"];
14464 [label="Debug.Assert(treeOrdinal >= 0); 444316"];
14465 [label="Debug.Assert(other.IsInitialized); 444317"];
14466 [label="this.Kind 444318"];
14467 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444319"];
14468 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444320"];
14469 [label="get\n            {\n                return _containingSymbol;\n            } 444321"];
14470 [label="param Compare(LexicalSortKey xSortKey) 444322"];
14471 [label="param Compare(LexicalSortKey ySortKey) 444323"];
14472 [label="int comparison; 444324"];
14473 [label="xSortKey.TreeOrdinal 444325"];
14474 [label="get { return _treeOrdinal; } 444326"];
14475 [label="return _treeOrdinal; 444327"];
14476 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444328"];
14477 [label="ySortKey.TreeOrdinal 444329"];
14478 [label="get { return _treeOrdinal; } 444330"];
14479 [label="return _treeOrdinal; 444331"];
14480 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444332"];
14481 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444333"];
14482 [label="xSortKey.Position 444334"];
14483 [label="get { return _position; } 444335"];
14484 [label="return _position; 444336"];
14485 [label="return xSortKey.Position - ySortKey.Position; 444337"];
14486 [label="ySortKey.Position 444338"];
14487 [label="get { return _position; } 444339"];
14488 [label="return _position; 444340"];
14489 [label="return xSortKey.Position - ySortKey.Position; 444341"];
14490 [label="return xSortKey.Position - ySortKey.Position; 444342"];
14491 [label="return _treeOrdinal; 444343"];
14492 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444344"];
14493 [label="return _treeOrdinal; 444345"];
14494 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444346"];
14495 [label="if (xSortKey.TreeOrdinal != ySortKey.TreeOrdinal)\n            {\n                if (xSortKey.TreeOrdinal < 0)\n                {\n                    return 1;\n                }\n                else if (ySortKey.TreeOrdinal < 0)\n                {\n                    return -1;\n                }\n\n                comparison = xSortKey.TreeOrdinal - ySortKey.TreeOrdinal;\n                Debug.Assert(comparison != 0);\n                return comparison;\n            } 444347"];
14496 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers); 444348"];
14497 [label="ImmutableInterlocked.InterlockedExchange(ref _lazyAllMembers, allMembers); 444349"];
14498 [label="this.Kind 444350"];
14499 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 444351"];
14500 [label="return SymbolKind.Namespace; 444352"];
14501 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444353"];
14502 [label="this.ContainingModule 444354"];
14503 [label="return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation; 444355"];
14504 [label="member.ForceComplete(locationOpt, cancellationToken) 444356"];
14505 [label="param ForceComplete(SourceLocation? locationOpt) 444357"];
14506 [label="param ForceComplete(CancellationToken cancellationToken) 444358"];
14507 [label="param ForceComplete(this) 444359"];
14508 [label="while (true)\n            {\n                // NOTE: cases that depend on GetMembers[ByName] should call RequireCompletionPartMembers.\n                cancellationToken.ThrowIfCancellationRequested();\n                var incompletePart = state.NextIncompletePart;\n                switch (incompletePart)\n                {\n                    case CompletionPart.Attributes:\n                        GetAttributes();\n                        break;\n\n                    case CompletionPart.StartBaseType:\n                    case CompletionPart.FinishBaseType:\n                        if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.StartInterfaces:\n                    case CompletionPart.FinishInterfaces:\n                        if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.EnumUnderlyingType:\n                        var discarded = this.EnumUnderlyingType;\n                        break;\n\n                    case CompletionPart.TypeArguments:\n                        {\n                            var tmp = this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; // force type arguments\n                        }\n                        break;\n\n                    case CompletionPart.TypeParameters:\n                        // force type parameters\n                        foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        }\n\n                        state.NotePartComplete(CompletionPart.TypeParameters);\n                        break;\n\n                    case CompletionPart.Members:\n                        this.GetMembersByName();\n                        break;\n\n                    case CompletionPart.TypeMembers:\n                        this.GetTypeMembersUnordered();\n                        break;\n\n                    case CompletionPart.SynthesizedExplicitImplementations:\n                        this.GetSynthesizedExplicitImplementations(cancellationToken); //force interface and base class errors to be checked\n                        break;\n\n                    case CompletionPart.StartMemberChecks:\n                    case CompletionPart.FinishMemberChecks:\n                        if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.MembersCompleted:\n                        {\n                            ImmutableArray<Symbol> members = this.GetMembersUnordered();\n\n                            bool allCompleted = true;\n\n                            if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            }\n\n                            if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            }\n\n                            EnsureFieldDefinitionsNoted();\n\n                            // We've completed all members, so we're ready for the PointedAtManagedTypeChecks;\n                            // proceed to the next iteration.\n                            state.NotePartComplete(CompletionPart.MembersCompleted);\n                            break;\n                        }\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // This assert will trigger if we forgot to handle any of the completion parts\n                        Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0);\n                        // any other values are completion parts intended for other kinds of symbols\n                        state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll);\n                        break;\n                }\n\n                state.SpinWaitComplete(incompletePart, cancellationToken);\n            } 444360"];
14509 [label="cancellationToken.ThrowIfCancellationRequested(); 444361"];
14510 [label="state.NextIncompletePart 444362"];
14511 [label="get\n            {\n                // NOTE: It's very important to store this value in a local.\n                // If we were to inline the field access, the value of the\n                // field could change between the two accesses and the formula\n                // might not produce a result with a single 1-bit.\n                int incomplete = IncompleteParts;\n                int next = incomplete & ~(incomplete - 1);\n                Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.');\n                return (CompletionPart)next;\n            } 444363"];
14512 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444364"];
14513 [label="HasAtMostOneBitSet(next) 444365"];
14514 [label="param HasAtMostOneBitSet(int bits) 444366"];
14515 [label="return (bits & (bits - 1)) == 0; 444367"];
14516 [label="return (bits & (bits - 1)) == 0; 444368"];
14517 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444369"];
14518 [label="var incompletePart = state.NextIncompletePart; 444370"];
14519 [label="switch (incompletePart)\n                {\n                    case CompletionPart.Attributes:\n                        GetAttributes();\n                        break;\n\n                    case CompletionPart.StartBaseType:\n                    case CompletionPart.FinishBaseType:\n                        if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.StartInterfaces:\n                    case CompletionPart.FinishInterfaces:\n                        if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.EnumUnderlyingType:\n                        var discarded = this.EnumUnderlyingType;\n                        break;\n\n                    case CompletionPart.TypeArguments:\n                        {\n                            var tmp = this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; // force type arguments\n                        }\n                        break;\n\n                    case CompletionPart.TypeParameters:\n                        // force type parameters\n                        foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        }\n\n                        state.NotePartComplete(CompletionPart.TypeParameters);\n                        break;\n\n                    case CompletionPart.Members:\n                        this.GetMembersByName();\n                        break;\n\n                    case CompletionPart.TypeMembers:\n                        this.GetTypeMembersUnordered();\n                        break;\n\n                    case CompletionPart.SynthesizedExplicitImplementations:\n                        this.GetSynthesizedExplicitImplementations(cancellationToken); //force interface and base class errors to be checked\n                        break;\n\n                    case CompletionPart.StartMemberChecks:\n                    case CompletionPart.FinishMemberChecks:\n                        if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        }\n                        break;\n\n                    case CompletionPart.MembersCompleted:\n                        {\n                            ImmutableArray<Symbol> members = this.GetMembersUnordered();\n\n                            bool allCompleted = true;\n\n                            if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            }\n\n                            if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            }\n\n                            EnsureFieldDefinitionsNoted();\n\n                            // We've completed all members, so we're ready for the PointedAtManagedTypeChecks;\n                            // proceed to the next iteration.\n                            state.NotePartComplete(CompletionPart.MembersCompleted);\n                            break;\n                        }\n\n                    case CompletionPart.None:\n                        return;\n\n                    default:\n                        // This assert will trigger if we forgot to handle any of the completion parts\n                        Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0);\n                        // any other values are completion parts intended for other kinds of symbols\n                        state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll);\n                        break;\n                } 444371"];
14520 [label="GetAttributes() 444372"];
14521 [label="param GetAttributes(this) 444373"];
14522 [label="this.GetAttributesBag() 444374"];
14523 [label="param GetAttributesBag(this) 444375"];
14524 [label="var bag = _lazyCustomAttributesBag; 444376"];
14525 [label="if (bag != null && bag.IsSealed)\n            {\n                return bag;\n            } 444377"];
14526 [label="if (bag != null && bag.IsSealed)\n            {\n                return bag;\n            } 444378"];
14527 [label="this.GetAttributeDeclarations() 444379"];
14528 [label="param GetAttributeDeclarations(this) 444380"];
14529 [label="return declaration.GetAttributeDeclarations(); 444381"];
14530 [label="if (LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag))\n            {\n                var completed = state.NotePartComplete(CompletionPart.Attributes);\n                Debug.Assert(completed);\n            } 444382"];
14531 [label="if (LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag))\n            {\n                var completed = state.NotePartComplete(CompletionPart.Attributes);\n                Debug.Assert(completed);\n            } 444383"];
14532 [label="LoadAndValidateAttributes(OneOrMany.Create(this.GetAttributeDeclarations()), ref _lazyCustomAttributesBag) 444384"];
14533 [label="param LoadAndValidateAttributes(OneOrMany<SyntaxList<AttributeListSyntax>> attributesSyntaxLists) 444385"];
14534 [label="param LoadAndValidateAttributes(ref CustomAttributesBag<CSharpAttributeData> lazyCustomAttributesBag) 444386"];
14535 [label="param LoadAndValidateAttributes(AttributeLocation symbolPart = AttributeLocation.None) 444387"];
14536 [label="param LoadAndValidateAttributes(bool earlyDecodingOnly = false) 444388"];
14537 [label="param LoadAndValidateAttributes(Binder binderOpt = null) 444389"];
14538 [label="param LoadAndValidateAttributes(Func<AttributeSyntax, bool> attributeMatchesOpt = null) 444390"];
14539 [label="param LoadAndValidateAttributes(this) 444391"];
14540 [label="this.DeclaringCompilation 444392"];
14541 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 444393"];
14542 [label="this.Kind 444394"];
14543 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444395"];
14544 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444396"];
14545 [label="return _containingSymbol; 444397"];
14546 [label="var compilation = this.DeclaringCompilation; 444398"];
14547 [label="ImmutableArray<Binder> binders; 444399"];
14548 [label="binders 444400"];
14549 [label="param GetAttributesToBind(OneOrMany<SyntaxList<AttributeListSyntax>> attributeDeclarationSyntaxLists) 444401"];
14550 [label="param GetAttributesToBind(AttributeLocation symbolPart) 444402"];
14551 [label="param GetAttributesToBind(DiagnosticBag diagnostics) 444403"];
14552 [label="param GetAttributesToBind(CSharpCompilation compilation) 444404"];
14553 [label="param GetAttributesToBind(Func<AttributeSyntax, bool> attributeMatchesOpt) 444405"];
14554 [label="param GetAttributesToBind(Binder rootBinderOpt) 444406"];
14555 [label="param GetAttributesToBind(out ImmutableArray<Binder> binders) 444407"];
14556 [label="param GetAttributesToBind(this) 444408"];
14557 [label="var attributeTarget = (IAttributeTargetSymbol)this; 444409"];
14558 [label="ArrayBuilder<Binder> bindersBuilder = null; 444410"];
14559 [label="int attributesToBindCount = 0; 444411"];
14560 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 444412"];
14561 [label="for (int listIndex = 0; listIndex < attributeDeclarationSyntaxLists.Count; listIndex++)\n            {\n                var attributeDeclarationSyntaxList = attributeDeclarationSyntaxLists[listIndex];\n                if (attributeDeclarationSyntaxList.Any())\n                {\n                    int prevCount = attributesToBindCount;\n                    foreach (var attributeDeclarationSyntax in attributeDeclarationSyntaxList)\n                    {\n                        // We bind the attribute only if it has a matching target for the given ownerSymbol and attributeLocation.\n                        if (MatchAttributeTarget(attributeTarget, symbolPart, attributeDeclarationSyntax.Target, diagnostics))\n                        {\n                            if (syntaxBuilder == null)\n                            {\n                                syntaxBuilder = new ArrayBuilder<AttributeSyntax>();\n                                bindersBuilder = new ArrayBuilder<Binder>();\n                            }\n\n                            var attributesToBind = attributeDeclarationSyntax.Attributes;\n                            if (attributeMatchesOpt is null)\n                            {\n                                syntaxBuilder.AddRange(attributesToBind);\n                                attributesToBindCount += attributesToBind.Count;\n                            }\n                            else\n                            {\n                                foreach (var attribute in attributesToBind)\n                                {\n                                    if (attributeMatchesOpt(attribute))\n                                    {\n                                        syntaxBuilder.Add(attribute);\n                                        attributesToBindCount++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (attributesToBindCount != prevCount)\n                    {\n                        Debug.Assert(attributeDeclarationSyntaxList.Node != null);\n                        Debug.Assert(bindersBuilder != null);\n\n                        var syntaxTree = attributeDeclarationSyntaxList.Node.SyntaxTree;\n                        var binder = rootBinderOpt ?? compilation.GetBinderFactory(syntaxTree).GetBinder(attributeDeclarationSyntaxList.Node);\n\n                        binder = new ContextualAttributeBinder(binder, this);\n                        Debug.Assert(!binder.InAttributeArgument, 'Possible cycle in attribute binding');\n\n                        for (int i = 0; i < attributesToBindCount - prevCount; i++)\n                        {\n                            bindersBuilder.Add(binder);\n                        }\n                    }\n                }\n            } 444413"];
14562 [label="binders = ImmutableArray<Binder>.Empty; 444414"];
14563 [label="Debug.Assert(!attributesToBind.IsDefault); 444415"];
14564 [label="ImmutableArray<CSharpAttributeData> boundAttributes; 444416"];
14565 [label="boundAttributes 444417"];
14566 [label="WellKnownAttributeData wellKnownAttributeData; 444418"];
14567 [label="if (earlyDecodingOnly)\n            {\n                diagnostics.Free(); //NOTE: dropped.\n                return false;\n            }\n            else\n            {\n                boundAttributes = ImmutableArray<CSharpAttributeData>.Empty;\n                wellKnownAttributeData = null;\n                Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null);\n                this.PostEarlyDecodeWellKnownAttributeTypes();\n            } 444419"];
14568 [label="wellKnownAttributeData = null; 444420"];
14569 [label="Interlocked.CompareExchange(ref lazyCustomAttributesBag, CustomAttributesBag<CSharpAttributeData>.WithEmptyData(), null); 444421"];
14570 [label="this.PostEarlyDecodeWellKnownAttributeTypes() 444422"];
14571 [label="param PostEarlyDecodeWellKnownAttributeTypes(this) 444423"];
14572 [label="this.PostEarlyDecodeWellKnownAttributeTypes(); 444424"];
14573 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444425"];
14574 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444426"];
14575 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444427"];
14576 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444428"];
14577 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData); 444429"];
14578 [label="this.PostDecodeWellKnownAttributes(boundAttributes, attributesToBind, diagnostics, symbolPart, wellKnownAttributeData) 444430"];
14579 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 444431"];
14580 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 444432"];
14581 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 444433"];
14582 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 444434"];
14583 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 444435"];
14584 [label="param PostDecodeWellKnownAttributes(this) 444436"];
14585 [label="Debug.Assert(!boundAttributes.IsDefault); 444437"];
14586 [label="Debug.Assert(!allAttributeSyntaxNodes.IsDefault); 444438"];
14587 [label="Debug.Assert(boundAttributes.Length == allAttributeSyntaxNodes.Length); 444439"];
14588 [label="Debug.Assert(_lazyCustomAttributesBag != null); 444440"];
14589 [label="Debug.Assert(_lazyCustomAttributesBag != null); 444441"];
14590 [label="Debug.Assert(_lazyCustomAttributesBag.IsDecodedWellKnownAttributeDataComputed); 444442"];
14591 [label="Debug.Assert(symbolPart == AttributeLocation.None); 444443"];
14592 [label="var data = (TypeWellKnownAttributeData)decodedData; 444444"];
14593 [label="this.IsComImport 444445"];
14594 [label="get\n            {\n                CommonTypeEarlyWellKnownAttributeData data = this.GetEarlyDecodedWellKnownAttributeData();\n                return data != null && data.HasComImportAttribute;\n            } 444446"];
14595 [label="this.GetEarlyDecodedWellKnownAttributeData() 444447"];
14596 [label="param GetEarlyDecodedWellKnownAttributeData(this) 444448"];
14597 [label="var attributesBag = _lazyCustomAttributesBag; 444449"];
14598 [label="if (attributesBag == null || !attributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 444450"];
14599 [label="if (attributesBag == null || !attributesBag.IsEarlyDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 444451"];
14600 [label="return (CommonTypeEarlyWellKnownAttributeData)attributesBag.EarlyDecodedWellKnownAttributeData; 444452"];
14601 [label="CommonTypeEarlyWellKnownAttributeData data = this.GetEarlyDecodedWellKnownAttributeData(); 444453"];
14602 [label="return data != null && data.HasComImportAttribute; 444454"];
14603 [label="return data != null && data.HasComImportAttribute; 444455"];
14604 [label="if (this.IsComImport)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with ComImportAttribute must have a GuidAttribute\n                if (data == null || data.GuidString == null)\n                {\n                    int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.ComImportAttribute);\n                    diagnostics.Add(ErrorCode.ERR_ComImportWithoutUuidAttribute, allAttributeSyntaxNodes[index].Name.Location, this.Name);\n                }\n\n                if (this.TypeKind == TypeKind.Class)\n                {\n                    var baseType = this.BaseTypeNoUseSiteDiagnostics;\n                    if ((object)baseType != null && baseType.SpecialType != SpecialType.System_Object)\n                    {\n                        // CS0424: '{0}': a class with the ComImport attribute cannot specify a base class\n                        diagnostics.Add(ErrorCode.ERR_ComImportWithBase, this.Locations[0], this.Name);\n                    }\n\n                    var initializers = this.StaticInitializers;\n                    if (!initializers.IsDefaultOrEmpty)\n                    {\n                        foreach (var initializerGroup in initializers)\n                        {\n                            foreach (var singleInitializer in initializerGroup)\n                            {\n                                if (!singleInitializer.FieldOpt.IsMetadataConstant)\n                                {\n                                    // CS8028: '{0}': a class with the ComImport attribute cannot specify field initializers.\n                                    diagnostics.Add(ErrorCode.ERR_ComImportWithInitializers, singleInitializer.Syntax.GetLocation(), this.Name);\n                                }\n                            }\n                        }\n                    }\n\n                    initializers = this.InstanceInitializers;\n                    if (!initializers.IsDefaultOrEmpty)\n                    {\n                        foreach (var initializerGroup in initializers)\n                        {\n                            foreach (var singleInitializer in initializerGroup)\n                            {\n                                // CS8028: '{0}': a class with the ComImport attribute cannot specify field initializers.\n                                diagnostics.Add(ErrorCode.ERR_ComImportWithInitializers, singleInitializer.Syntax.GetLocation(), this.Name);\n                            }\n                        }\n                    }\n                }\n            }\n            else if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 444456"];
14605 [label="this.ComImportCoClass 444457"];
14606 [label="get\n            {\n                TypeWellKnownAttributeData data = this.GetDecodedWellKnownAttributeData();\n                return data != null ? data.ComImportCoClass : null;\n            } 444458"];
14607 [label="this.GetDecodedWellKnownAttributeData() 444459"];
14608 [label="param GetDecodedWellKnownAttributeData(this) 444460"];
14609 [label="var attributesBag = _lazyCustomAttributesBag; 444461"];
14610 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 444462"];
14611 [label="if (attributesBag == null || !attributesBag.IsDecodedWellKnownAttributeDataComputed)\n            {\n                attributesBag = this.GetAttributesBag();\n            } 444463"];
14612 [label="return (TypeWellKnownAttributeData)attributesBag.DecodedWellKnownAttributeData; 444464"];
14613 [label="TypeWellKnownAttributeData data = this.GetDecodedWellKnownAttributeData(); 444465"];
14614 [label="return data != null ? data.ComImportCoClass : null; 444466"];
14615 [label="return data != null ? data.ComImportCoClass : null; 444467"];
14616 [label="data != null 444468"];
14617 [label="if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 444469"];
14618 [label="if ((object)this.ComImportCoClass != null)\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                // Symbol with CoClassAttribute must have a ComImportAttribute\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.CoClassAttribute);\n                diagnostics.Add(ErrorCode.WRN_CoClassWithoutComImport, allAttributeSyntaxNodes[index].Location, this.Name);\n            } 444470"];
14619 [label="if (data != null && data.HasDefaultMemberAttribute && this.Indexers.Any())\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.DefaultMemberAttribute);\n                diagnostics.Add(ErrorCode.ERR_DefaultMemberOnIndexedType, allAttributeSyntaxNodes[index].Name.Location);\n            } 444471"];
14620 [label="if (data != null && data.HasDefaultMemberAttribute && this.Indexers.Any())\n            {\n                Debug.Assert(boundAttributes.Any());\n\n                int index = boundAttributes.IndexOfAttribute(this, AttributeDescription.DefaultMemberAttribute);\n                diagnostics.Add(ErrorCode.ERR_DefaultMemberOnIndexedType, allAttributeSyntaxNodes[index].Name.Location);\n            } 444472"];
14621 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444473"];
14622 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444474"];
14623 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444475"];
14624 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444476"];
14625 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444477"];
14626 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData) 444478"];
14627 [label="param PostDecodeWellKnownAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 444479"];
14628 [label="param PostDecodeWellKnownAttributes(ImmutableArray<AttributeSyntax> allAttributeSyntaxNodes) 444480"];
14629 [label="param PostDecodeWellKnownAttributes(DiagnosticBag diagnostics) 444481"];
14630 [label="param PostDecodeWellKnownAttributes(AttributeLocation symbolPart) 444482"];
14631 [label="param PostDecodeWellKnownAttributes(WellKnownAttributeData decodedData) 444483"];
14632 [label="param PostDecodeWellKnownAttributes(this) 444484"];
14633 [label="base.PostDecodeWellKnownAttributes(boundAttributes, allAttributeSyntaxNodes, diagnostics, symbolPart, decodedData); 444485"];
14634 [label="bool lazyAttributesStoredOnThisThread = false; 444486"];
14635 [label="if (attributeMatchesOpt is null)\n                {\n                    this.RecordPresenceOfBadAttributes(boundAttributes);\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444487"];
14636 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 444488"];
14637 [label="this.RecordPresenceOfBadAttributes(boundAttributes) 444489"];
14638 [label="param RecordPresenceOfBadAttributes(ImmutableArray<CSharpAttributeData> boundAttributes) 444490"];
14639 [label="param RecordPresenceOfBadAttributes(this) 444491"];
14640 [label="foreach (var attribute in boundAttributes)\n            {\n                if (attribute.HasErrors)\n                {\n                    CSharpCompilation compilation = this.DeclaringCompilation;\n                    Debug.Assert(compilation != null);\n                    ((SourceModuleSymbol)compilation.SourceModule).RecordPresenceOfBadAttributes();\n                    break;\n                }\n            } 444492"];
14641 [label="this.RecordPresenceOfBadAttributes(boundAttributes); 444493"];
14642 [label="AddDeclarationDiagnostics(diagnostics); 444494"];
14643 [label="AddDeclarationDiagnostics(diagnostics) 444495"];
14644 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 444496"];
14645 [label="param AddDeclarationDiagnostics(this) 444497"];
14646 [label="ContainingSymbol 444498"];
14647 [label="get\n            {\n                return _containingSymbol;\n            } 444499"];
14648 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444500"];
14649 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444501"];
14650 [label="AddDeclarationDiagnostics(diagnostics); 444502"];
14651 [label="Debug.Assert(lazyCustomAttributesBag.IsSealed); 444503"];
14652 [label="diagnostics.Free(); 444504"];
14653 [label="var completed = state.NotePartComplete(CompletionPart.Attributes); 444505"];
14654 [label="state.NotePartComplete(CompletionPart.Attributes) 444506"];
14655 [label="param NotePartComplete(CompletionPart part) 444507"];
14656 [label="Debug.Assert(completed); 444508"];
14657 [label="Debug.Assert(_lazyCustomAttributesBag.IsSealed); 444509"];
14658 [label="return _lazyCustomAttributesBag; 444510"];
14659 [label="return this.GetAttributesBag().Attributes; 444511"];
14660 [label="GetAttributes(); 444512"];
14661 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 444513"];
14662 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 444514"];
14663 [label="state.SpinWaitComplete(incompletePart, cancellationToken) 444515"];
14664 [label="param SpinWaitComplete(CompletionPart part) 444516"];
14665 [label="param SpinWaitComplete(CancellationToken cancellationToken) 444517"];
14666 [label="param SpinWaitComplete(this) 444518"];
14667 [label="if (HasComplete(part))\n            {\n                return;\n            } 444519"];
14668 [label="HasComplete(part) 444520"];
14669 [label="param HasComplete(CompletionPart part) 444521"];
14670 [label="param HasComplete(this) 444522"];
14671 [label="return (_completeParts & (int)part) == (int)part; 444523"];
14672 [label="return; 444524"];
14673 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 444525"];
14674 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444526"];
14675 [label="param HasAtMostOneBitSet(int bits) 444527"];
14676 [label="return (bits & (bits - 1)) == 0; 444528"];
14677 [label="Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0); 444529"];
14678 [label="Debug.Assert((incompletePart & CompletionPart.NamedTypeSymbolAll) == 0); 444530"];
14679 [label="state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll); 444531"];
14680 [label="state.NotePartComplete(CompletionPart.All & ~CompletionPart.NamedTypeSymbolAll) 444532"];
14681 [label="param NotePartComplete(CompletionPart part) 444533"];
14682 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 444534"];
14683 [label="param SpinWaitComplete(CompletionPart part) 444535"];
14684 [label="param SpinWaitComplete(this) 444536"];
14685 [label="if (HasComplete(part))\n            {\n                return;\n            } 444537"];
14686 [label="param HasComplete(CompletionPart part) 444538"];
14687 [label="param HasComplete(this) 444539"];
14688 [label="return (_completeParts & (int)part) == (int)part; 444540"];
14689 [label="return; 444541"];
14690 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 444542"];
14691 [label="param HasAtMostOneBitSet(int bits) 444543"];
14692 [label="return (bits & (bits - 1)) == 0; 444544"];
14693 [label="if (state.NotePartComplete(CompletionPart.StartBaseType))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckBase(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishBaseType);\n                            diagnostics.Free();\n                        } 444545"];
14694 [label="state.NotePartComplete(CompletionPart.StartBaseType) 444546"];
14695 [label="param NotePartComplete(CompletionPart part) 444547"];
14696 [label="var diagnostics = DiagnosticBag.GetInstance(); 444548"];
14697 [label="CheckBase(diagnostics); 444549"];
14698 [label="CheckBase(diagnostics) 444550"];
14699 [label="param CheckBase(DiagnosticBag diagnostics) 444551"];
14700 [label="param CheckBase(this) 444552"];
14701 [label="this.BaseTypeNoUseSiteDiagnostics 444553"];
14702 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 444554"];
14703 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 444555"];
14704 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 444556"];
14705 [label="ContainingType 444557"];
14706 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 444558"];
14707 [label="return _containingSymbol as NamedTypeSymbol; 444559"];
14708 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 444560"];
14709 [label="if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    } 444561"];
14710 [label="var diagnostics = DiagnosticBag.GetInstance(); 444562"];
14711 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 444563"];
14712 [label="this.MakeAcyclicBaseType(diagnostics) 444564"];
14713 [label="param MakeAcyclicBaseType(DiagnosticBag diagnostics) 444565"];
14714 [label="param MakeAcyclicBaseType(this) 444566"];
14715 [label="this.TypeKind 444567"];
14716 [label="get\n            {\n                return _flags.TypeKind;\n            } 444568"];
14717 [label="_flags.TypeKind 444569"];
14718 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 444570"];
14719 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 444571"];
14720 [label="return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); 444572"];
14721 [label="return _flags.TypeKind; 444573"];
14722 [label="var typeKind = this.TypeKind; 444574"];
14723 [label="this.DeclaringCompilation 444575"];
14724 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 444576"];
14725 [label="this.Kind 444577"];
14726 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444578"];
14727 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444579"];
14728 [label="var compilation = this.DeclaringCompilation; 444580"];
14729 [label="NamedTypeSymbol declaredBase; 444581"];
14730 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert((object)GetDeclaredBaseType(basesBeingResolved: null) == null, 'Computation skipped for enums');\n                declaredBase = compilation.GetSpecialType(SpecialType.System_Enum);\n            }\n            else\n            {\n                declaredBase = GetDeclaredBaseType(basesBeingResolved: null);\n            } 444582"];
14731 [label="declaredBase = GetDeclaredBaseType(basesBeingResolved: null); 444583"];
14732 [label="GetDeclaredBaseType(basesBeingResolved: null) 444584"];
14733 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 444585"];
14734 [label="param GetDeclaredBaseType(this) 444586"];
14735 [label="return GetDeclaredBases(basesBeingResolved).Item1; 444587"];
14736 [label="GetDeclaredBases(basesBeingResolved) 444588"];
14737 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 444589"];
14738 [label="param GetDeclaredBases(this) 444590"];
14739 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 444591"];
14740 [label="if (ReferenceEquals(_lazyDeclaredBases, null))\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 444592"];
14741 [label="var diagnostics = DiagnosticBag.GetInstance(); 444593"];
14742 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444594"];
14743 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444595"];
14744 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444596"];
14745 [label="MakeDeclaredBases(basesBeingResolved, diagnostics) 444597"];
14746 [label="param MakeDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 444598"];
14747 [label="param MakeDeclaredBases(DiagnosticBag diagnostics) 444599"];
14748 [label="param MakeDeclaredBases(this) 444600"];
14749 [label="this.TypeKind 444601"];
14750 [label="get\n            {\n                return _flags.TypeKind;\n            } 444602"];
14751 [label="if (this.TypeKind == TypeKind.Enum)\n            {\n                // Handled by GetEnumUnderlyingType().\n                return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(null, ImmutableArray<NamedTypeSymbol>.Empty);\n            } 444603"];
14752 [label="var reportedPartialConflict = false; 444604"];
14753 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 444605"];
14754 [label="Debug.Assert(basesBeingResolved == null || !basesBeingResolved.ContainsReference(this.OriginalDefinition)); 444606"];
14755 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 444607"];
14756 [label="this.OriginalDefinition 444608"];
14757 [label="get\n            {\n                return this;\n            } 444609"];
14758 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 444610"];
14759 [label="var newBasesBeingResolved = basesBeingResolved.Prepend(this.OriginalDefinition); 444611"];
14760 [label="var baseInterfaces = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 444612"];
14761 [label="NamedTypeSymbol baseType = null; 444613"];
14762 [label="SourceLocation baseTypeLocation = null; 444614"];
14763 [label="SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>() 444615"];
14764 [label="var instance = PooledSymbolDictionary<KSymbol, V>.s_poolInstance.Allocate(); 444616"];
14765 [label="Debug.Assert(instance.Count == 0); 444617"];
14766 [label="Debug.Assert(instance.Count == 0); 444618"];
14767 [label="return instance; 444619"];
14768 [label="var interfaceLocations = SpecializedSymbolCollections.GetPooledSymbolDictionaryInstance<NamedTypeSymbol, SourceLocation>(); 444620"];
14769 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics);\n                if ((object)one == null) continue;\n\n                var partBase = one.Item1;\n                var partInterfaces = one.Item2;\n                if (!reportedPartialConflict)\n                {\n                    if ((object)baseType == null)\n                    {\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if (baseType.TypeKind == TypeKind.Error && (object)partBase != null)\n                    {\n                        // if the old base was an error symbol, copy it to the interfaces list so it doesn't get lost\n                        partInterfaces = partInterfaces.Add(baseType);\n                        baseType = partBase;\n                        baseTypeLocation = decl.NameLocation;\n                    }\n                    else if ((object)partBase != null && !TypeSymbol.Equals(partBase, baseType, TypeCompareKind.ConsiderEverything2) && partBase.TypeKind != TypeKind.Error)\n                    {\n                        // the parts do not agree\n                        var info = diagnostics.Add(ErrorCode.ERR_PartialMultipleBases, Locations[0], this);\n                        baseType = new ExtendedErrorTypeSymbol(baseType, LookupResultKind.Ambiguous, info);\n                        baseTypeLocation = decl.NameLocation;\n                        reportedPartialConflict = true;\n                    }\n                }\n\n                foreach (var t in partInterfaces)\n                {\n                    if (!interfaceLocations.ContainsKey(t))\n                    {\n                        baseInterfaces.Add(t);\n                        interfaceLocations.Add(t, decl.NameLocation);\n                    }\n                }\n            } 444621"];
14770 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 444622"];
14771 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 444623"];
14772 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 444624"];
14773 [label="MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics) 444625"];
14774 [label="param MakeOneDeclaredBases(ConsList<TypeSymbol> newBasesBeingResolved) 444626"];
14775 [label="param MakeOneDeclaredBases(SingleTypeDeclaration decl) 444627"];
14776 [label="param MakeOneDeclaredBases(DiagnosticBag diagnostics) 444628"];
14777 [label="param MakeOneDeclaredBases(this) 444629"];
14778 [label="BaseListSyntax bases = GetBaseListOpt(decl); 444630"];
14779 [label="GetBaseListOpt(decl) 444631"];
14780 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 444632"];
14781 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 444633"];
14782 [label="return null; 444634"];
14783 [label="BaseListSyntax bases = GetBaseListOpt(decl); 444635"];
14784 [label="if (bases == null)\n            {\n                return null;\n            } 444636"];
14785 [label="if (bases == null)\n            {\n                return null;\n            } 444637"];
14786 [label="return null; 444638"];
14787 [label="Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>> one = MakeOneDeclaredBases(newBasesBeingResolved, decl, diagnostics); 444639"];
14788 [label="if ((object)one == null) continue; 444640"];
14789 [label="if ((object)one == null) continue; 444641"];
14790 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 444642"];
14791 [label="if (declaration.Kind == DeclarationKind.Record)\n            {\n                var type = DeclaringCompilation.GetWellKnownType(WellKnownType.System_IEquatable_T).Construct(this);\n                if (baseInterfaces.IndexOf(type, SymbolEqualityComparer.AllIgnoreOptions) < 0)\n                {\n                    baseInterfaces.Add(type);\n                    type.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                }\n            } 444643"];
14792 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 444644"];
14793 [label="if ((object)baseType != null)\n            {\n                Debug.Assert(baseTypeLocation != null);\n                if (baseType.IsStatic)\n                {\n                    // '{1}': cannot derive from static class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_StaticBaseClass, baseTypeLocation, baseType, this);\n                }\n\n                if (!this.IsNoMoreVisibleThan(baseType, ref useSiteDiagnostics))\n                {\n                    // Inconsistent accessibility: base class '{1}' is less accessible than class '{0}'\n                    diagnostics.Add(ErrorCode.ERR_BadVisBaseClass, baseTypeLocation, this, baseType);\n                }\n            } 444645"];
14794 [label="var baseInterfacesRO = baseInterfaces.ToImmutableAndFree(); 444646"];
14795 [label="DeclaredAccessibility 444647"];
14796 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 444648"];
14797 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 444649"];
14798 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 444650"];
14799 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 444651"];
14800 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 444652"];
14801 [label="return Accessibility.Public; 444653"];
14802 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 444654"];
14803 [label="IsInterface 444655"];
14804 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 444656"];
14805 [label="this.TypeKind 444657"];
14806 [label="get\n            {\n                return _flags.TypeKind;\n            } 444658"];
14807 [label="return this.TypeKind == TypeKind.Interface; 444659"];
14808 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 444660"];
14809 [label="if (DeclaredAccessibility != Accessibility.Private && IsInterface)\n            {\n                foreach (var i in baseInterfacesRO)\n                {\n                    if (!i.IsAtLeastAsVisibleAs(this, ref useSiteDiagnostics))\n                    {\n                        // Inconsistent accessibility: base interface '{1}' is less accessible than interface '{0}'\n                        diagnostics.Add(ErrorCode.ERR_BadVisBaseInterface, interfaceLocations[i], this, i);\n                    }\n                }\n            } 444661"];
14810 [label="interfaceLocations.Free(); 444662"];
14811 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 444663"];
14812 [label="Locations 444664"];
14813 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 444665"];
14814 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 444666"];
14815 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 444667"];
14816 [label="diagnostics.Add(Locations[0], useSiteDiagnostics); 444668"];
14817 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 444669"];
14818 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 444670"];
14819 [label="return new Tuple<NamedTypeSymbol, ImmutableArray<NamedTypeSymbol>>(baseType, baseInterfacesRO); 444671"];
14820 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444672"];
14821 [label="if (Interlocked.CompareExchange(ref _lazyDeclaredBases, MakeDeclaredBases(basesBeingResolved, diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 444673"];
14822 [label="AddDeclarationDiagnostics(diagnostics); 444674"];
14823 [label="AddDeclarationDiagnostics(diagnostics) 444675"];
14824 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 444676"];
14825 [label="param AddDeclarationDiagnostics(this) 444677"];
14826 [label="ContainingSymbol 444678"];
14827 [label="get\n            {\n                return _containingSymbol;\n            } 444679"];
14828 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444680"];
14829 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444681"];
14830 [label="AddDeclarationDiagnostics(diagnostics); 444682"];
14831 [label="diagnostics.Free(); 444683"];
14832 [label="return _lazyDeclaredBases; 444684"];
14833 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 444685"];
14834 [label="if ((object)declaredBase == null)\n            {\n                switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                }\n            } 444686"];
14835 [label="switch (typeKind)\n                {\n                    case TypeKind.Class:\n\n                        if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        }\n\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_Object);\n                        break;\n\n                    case TypeKind.Struct:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_ValueType);\n                        break;\n\n                    case TypeKind.Interface:\n                        return null;\n\n                    case TypeKind.Delegate:\n                        declaredBase = compilation.GetSpecialType(SpecialType.System_MulticastDelegate);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(typeKind);\n                } 444687"];
14836 [label="this.SpecialType 444688"];
14837 [label="get\n            {\n                return _flags.SpecialType;\n            } 444689"];
14838 [label="_flags.SpecialType 444690"];
14839 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 444691"];
14840 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 444692"];
14841 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 444693"];
14842 [label="return _flags.SpecialType; 444694"];
14843 [label="if (this.SpecialType == SpecialType.System_Object)\n                        {\n                            return null;\n                        } 444695"];
14844 [label="declaredBase = compilation.GetSpecialType(SpecialType.System_Object); 444696"];
14845 [label="compilation.GetSpecialType(SpecialType.System_Object) 444697"];
14846 [label="param GetSpecialType(SpecialType specialType) 444698"];
14847 [label="param GetSpecialType(this) 444699"];
14848 [label="if (specialType <= SpecialType.None || specialType > SpecialType.Count)\n            {\n                throw new ArgumentOutOfRangeException(nameof(specialType), $'Unexpected SpecialType: '{(int)specialType}'.');\n            } 444700"];
14849 [label="NamedTypeSymbol result; 444701"];
14850 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 444702"];
14851 [label="if (IsTypeMissing(specialType))\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(specialType.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                result = new MissingMetadataTypeSymbol.TopLevel(Assembly.CorLibrary.Modules[0], ref emittedName, specialType);\n            }\n            else\n            {\n                result = Assembly.GetSpecialType(specialType);\n            } 444703"];
14852 [label="Assembly 444704"];
14853 [label="GetBoundReferenceManager(); 444705"];
14854 [label="result = Assembly.GetSpecialType(specialType); 444706"];
14855 [label="result = Assembly.GetSpecialType(specialType); 444707"];
14856 [label="Assembly.GetSpecialType(specialType) 444708"];
14857 [label="param GetSpecialType(SpecialType type) 444709"];
14858 [label="param GetSpecialType(this) 444710"];
14859 [label="this.Modules 444711"];
14860 [label="get\n            {\n                return _modules;\n            } 444712"];
14861 [label="foreach (var module in this.Modules)\n            {\n                Debug.Assert(module.GetReferencedAssemblies().Length == 0);\n            } 444713"];
14862 [label="module.GetReferencedAssemblies() 444714"];
14863 [label="param GetReferencedAssemblies(this) 444715"];
14864 [label="AssertReferencesInitialized() 444716"];
14865 [label="param AssertReferencesInitialized(this) 444717"];
14866 [label="Debug.Assert(_moduleReferences != null); 444718"];
14867 [label="Debug.Assert(_moduleReferences != null); 444719"];
14868 [label="AssertReferencesInitialized(); 444720"];
14869 [label="return _moduleReferences.Identities; 444721"];
14870 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 444722"];
14871 [label="Debug.Assert(module.GetReferencedAssemblies().Length == 0); 444723"];
14872 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 444724"];
14873 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 444725"];
14874 [label="if (_lazySpecialTypes == null || (object)_lazySpecialTypes[(int)type] == null)\n            {\n                MetadataTypeName emittedName = MetadataTypeName.FromFullName(type.GetMetadataName(), useCLSCompliantNameArityEncoding: true);\n                ModuleSymbol module = this.Modules[0];\n                NamedTypeSymbol result = module.LookupTopLevelMetadataType(ref emittedName);\n                if (result.Kind != SymbolKind.ErrorType && result.DeclaredAccessibility != Accessibility.Public)\n                {\n                    result = new MissingMetadataTypeSymbol.TopLevel(module, ref emittedName, type);\n                }\n                RegisterDeclaredSpecialType(result);\n            } 444726"];
14875 [label="result.SpecialType 444727"];
14876 [label="get\n            {\n                return _corTypeId;\n            } 444728"];
14877 [label="Debug.Assert(result.SpecialType == specialType); 444729"];
14878 [label="return result; 444730"];
14879 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 444731"];
14880 [label="if (BaseTypeAnalysis.TypeDependsOn(declaredBase, this))\n            {\n                return new ExtendedErrorTypeSymbol(declaredBase, LookupResultKind.NotReferencable,\n                    diagnostics.Add(ErrorCode.ERR_CircularBase, Locations[0], declaredBase, this));\n            } 444732"];
14881 [label="BaseTypeAnalysis.TypeDependsOn(declaredBase, this) 444733"];
14882 [label="param TypeDependsOn(NamedTypeSymbol depends) 444734"];
14883 [label="param TypeDependsOn(NamedTypeSymbol on) 444735"];
14884 [label="Debug.Assert((object)depends != null); 444736"];
14885 [label="Debug.Assert((object)depends != null); 444737"];
14886 [label="Debug.Assert((object)on != null); 444738"];
14887 [label="Debug.Assert((object)on != null); 444739"];
14888 [label="Debug.Assert(on.IsDefinition); 444740"];
14889 [label="depends.DeclaringCompilation 444741"];
14890 [label="get { return null; } 444742"];
14891 [label="return null; 444743"];
14892 [label="param TypeDependsClosure(CSharpCompilation currentCompilation) 444744"];
14893 [label="if ((object)type == null)\n            {\n                return;\n            } 444745"];
14894 [label="if ((object)type == null)\n            {\n                return;\n            } 444746"];
14895 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 444747"];
14896 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 444748"];
14897 [label="TypeDependsClosure(type.GetDeclaredBaseType(null), currentCompilation, partialClosure); 444749"];
14898 [label="if ((object)type == null)\n            {\n                return;\n            } 444750"];
14899 [label="return; 444751"];
14900 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 444752"];
14901 [label="if (currentCompilation != null && type.IsFromCompilation(currentCompilation))\n                {\n                    TypeDependsClosure(type.ContainingType, currentCompilation, partialClosure);\n                } 444753"];
14902 [label="get\n            {\n                return _flags.SpecialType;\n            } 444754"];
14903 [label="_flags.SpecialType 444755"];
14904 [label="get { return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); } 444756"];
14905 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 444757"];
14906 [label="return (SpecialType)((_flags >> SpecialTypeOffset) & SpecialTypeMask); 444758"];
14907 [label="return _flags.SpecialType; 444759"];
14908 [label="return result; 444760"];
14909 [label="this.SetKnownToHaveNoDeclaredBaseCycles() 444761"];
14910 [label="param SetKnownToHaveNoDeclaredBaseCycles(this) 444762"];
14911 [label="this.SetKnownToHaveNoDeclaredBaseCycles(); 444763"];
14912 [label="HashSet<DiagnosticInfo> useSiteDiagnostics = null; 444764"];
14913 [label="NamedTypeSymbol current = declaredBase; 444765"];
14914 [label="current.DeclaringCompilation 444766"];
14915 [label="get { return null; } 444767"];
14916 [label="return null; 444768"];
14917 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 444769"];
14918 [label="this.DeclaringCompilation 444770"];
14919 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 444771"];
14920 [label="this.Kind 444772"];
14921 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444773"];
14922 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 444774"];
14923 [label="return _containingSymbol; 444775"];
14924 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 444776"];
14925 [label="if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                } 444777"];
14926 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 444778"];
14927 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 444779"];
14928 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics) 444780"];
14929 [label="param AddUseSiteDiagnostics(this TypeSymbol type) 444781"];
14930 [label="param AddUseSiteDiagnostics(ref HashSet<DiagnosticInfo> useSiteDiagnostics) 444782"];
14931 [label="type.GetUseSiteDiagnostic() 444783"];
14932 [label="param GetUseSiteDiagnostic(this) 444784"];
14933 [label="if (ReferenceEquals(_lazyUseSiteDiagnostic, CSDiagnosticInfo.EmptyErrorInfo))\n            {\n                _lazyUseSiteDiagnostic = GetUseSiteDiagnosticImpl();\n            } 444785"];
14934 [label="param MergeUseSiteDiagnostics(this) 444786"];
14935 [label="s.Kind 444787"];
14936 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 444788"];
14937 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 444789"];
14938 [label="if (this.ContainingModule.HasUnifiedReferences)\n            {\n                HashSet<TypeSymbol> unificationCheckedTypes = null;\n                if (GetUnificationUseSiteDiagnosticRecursive(ref result, this, ref unificationCheckedTypes))\n                {\n                    return result;\n                }\n            } 444790"];
14939 [label="this.ContainingModule.HasUnifiedReferences 444791"];
14940 [label="get { return GetUnifiedAssemblies().Length > 0; } 444792"];
14941 [label="GetUnifiedAssemblies() 444793"];
14942 [label="param GetUnifiedAssemblies(this) 444794"];
14943 [label="AssertReferencesInitialized() 444795"];
14944 [label="param AssertReferencesInitialized(this) 444796"];
14945 [label="Debug.Assert(_moduleReferences != null); 444797"];
14946 [label="Debug.Assert(_moduleReferences != null); 444798"];
14947 [label="AssertReferencesInitialized(); 444799"];
14948 [label="return _moduleReferences.UnifiedAssemblies; 444800"];
14949 [label="return GetUnifiedAssemblies().Length > 0; 444801"];
14950 [label="return GetUnifiedAssemblies().Length > 0; 444802"];
14951 [label="if (this.ContainingPEModule.Module.HasRequiredAttributeAttribute(_handle))\n                {\n                    diagnostic = new CSDiagnosticInfo(ErrorCode.ERR_BogusType, this);\n                }\n                else if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 444803"];
14952 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 444804"];
14953 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 444805"];
14954 [label="SpecialType 444806"];
14955 [label="if (TypeKind == TypeKind.Class && SpecialType != SpecialType.System_Enum)\n                {\n                    TypeSymbol @base = GetDeclaredBaseType(null);\n                    if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    }\n                } 444807"];
14956 [label="TypeSymbol @base = GetDeclaredBaseType(null); 444808"];
14957 [label="GetDeclaredBaseType(null) 444809"];
14958 [label="param GetDeclaredBaseType(ConsList<TypeSymbol> basesBeingResolved) 444810"];
14959 [label="param GetDeclaredBaseType(bool skipTransformsIfNecessary) 444811"];
14960 [label="TypeSymbol @base = GetDeclaredBaseType(null); 444812"];
14961 [label="if (@base?.SpecialType == SpecialType.None && @base.ContainingAssembly?.IsMissing == true)\n                    {\n                        var missingType = @base as MissingMetadataTypeSymbol.TopLevel;\n                        if ((object)missingType != null && missingType.Arity == 0)\n                        {\n                            string emittedName = MetadataHelpers.BuildQualifiedName(missingType.NamespaceName, missingType.MetadataName);\n                            switch (SpecialTypes.GetTypeFromMetadataName(emittedName))\n                            {\n                                case SpecialType.System_Enum:\n                                case SpecialType.System_MulticastDelegate:\n                                case SpecialType.System_ValueType:\n                                    // This might be a structure, an enum, or a delegate\n                                    diagnostic = missingType.GetUseSiteDiagnostic();\n                                    break;\n                            }\n                        }\n                    } 444813"];
14962 [label="return _lazyUseSiteDiagnostic; 444814"];
14963 [label="DiagnosticInfo errorInfo = type.GetUseSiteDiagnostic(); 444815"];
14964 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 444816"];
14965 [label="if ((object)errorInfo != null)\n            {\n                if (useSiteDiagnostics == null)\n                {\n                    useSiteDiagnostics = new HashSet<DiagnosticInfo>();\n                }\n\n                useSiteDiagnostics.Add(errorInfo);\n            } 444817"];
14966 [label="current.AddUseSiteDiagnostics(ref useSiteDiagnostics); 444818"];
14967 [label="current.BaseTypeNoUseSiteDiagnostics 444819"];
14968 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                }\n\n                return _lazyBaseType;\n            } 444820"];
14969 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    Interlocked.CompareExchange(ref _lazyBaseType, MakeAcyclicBaseType(), ErrorTypeSymbol.UnknownResultType);\n                } 444821"];
14970 [label="return _lazyBaseType; 444822"];
14971 [label="current = current.BaseTypeNoUseSiteDiagnostics; 444823"];
14972 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 444824"];
14973 [label="do\n            {\n                if (current.DeclaringCompilation == this.DeclaringCompilation)\n                {\n                    break;\n                }\n\n                current.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                current = current.BaseTypeNoUseSiteDiagnostics;\n            }\n            while ((object)current != null); 444825"];
14974 [label="if (!useSiteDiagnostics.IsNullOrEmpty())\n            {\n                diagnostics.Add(FindBaseRefSyntax(declaredBase) ?? Locations[0], useSiteDiagnostics);\n            } 444826"];
14975 [label="return declaredBase; 444827"];
14976 [label="var acyclicBase = this.MakeAcyclicBaseType(diagnostics); 444828"];
14977 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444829"];
14978 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444830"];
14979 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444831"];
14980 [label="if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444832"];
14981 [label="AddDeclarationDiagnostics(diagnostics); 444833"];
14982 [label="AddDeclarationDiagnostics(diagnostics) 444834"];
14983 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 444835"];
14984 [label="param AddDeclarationDiagnostics(this) 444836"];
14985 [label="ContainingSymbol 444837"];
14986 [label="get\n            {\n                return _containingSymbol;\n            } 444838"];
14987 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444839"];
14988 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444840"];
14989 [label="AddDeclarationDiagnostics(diagnostics); 444841"];
14990 [label="diagnostics.Free(); 444842"];
14991 [label="return _lazyBaseType; 444843"];
14992 [label="var localBase = this.BaseTypeNoUseSiteDiagnostics; 444844"];
14993 [label="if ((object)localBase == null)\n            {\n                // nothing to verify\n                return;\n            } 444845"];
14994 [label="if ((object)localBase == null)\n            {\n                // nothing to verify\n                return;\n            } 444846"];
14995 [label="Location baseLocation = null; 444847"];
14996 [label="bool baseContainsErrorTypes = localBase.ContainsErrorType(); 444848"];
14997 [label="localBase.ContainsErrorType() 444849"];
14998 [label="param ContainsErrorType(this TypeSymbol type) 444850"];
14999 [label="var result = type.VisitType((type, unused1, unused2) => type.IsErrorType(), (object?)null, canDigThroughNullable: true); 444851"];
15000 [label="var result = type.VisitType((type, unused1, unused2) => type.IsErrorType(), (object?)null, canDigThroughNullable: true); 444852"];
15001 [label="type.VisitType((type, unused1, unused2) => type.IsErrorType(), (object?)null, canDigThroughNullable: true) 444853"];
15002 [label="param VisitType(this TypeSymbol type) 444854"];
15003 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 444855"];
15004 [label="param VisitType(T arg) 444856"];
15005 [label="param VisitType(bool canDigThroughNullable = false) 444857"];
15006 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 444858"];
15007 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 444859"];
15008 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 444860"];
15009 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 444861"];
15010 [label="return VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable); 444862"];
15011 [label="VisitType(\n                typeWithAnnotationsOpt: default,\n                type: type,\n                typeWithAnnotationsPredicate: null,\n                typePredicate: predicate,\n                arg,\n                canDigThroughNullable) 444863"];
15012 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 444864"];
15013 [label="param VisitType(TypeSymbol? type) 444865"];
15014 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 444866"];
15015 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 444867"];
15016 [label="param VisitType(T arg) 444868"];
15017 [label="param VisitType(bool canDigThroughNullable = false) 444869"];
15018 [label="param VisitType(bool useDefaultType = false) 444870"];
15019 [label="typeWithAnnotationsOpt.HasType 444871"];
15020 [label="=> !(DefaultType is null) 444872"];
15021 [label="DefaultType is null 444873"];
15022 [label="!(DefaultType is null) 444874"];
15023 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 444875"];
15024 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 444876"];
15025 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 444877"];
15026 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 444878"];
15027 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 444879"];
15028 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 444880"];
15029 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 444881"];
15030 [label="while (true)\n            {\n                TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type);\n                bool isNestedNamedType = false;\n\n                // Visit containing types from outer-most to inner-most.\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                }\n\n                if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n\n                TypeWithAnnotations next;\n\n                switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                }\n\n                // Let's try to avoid early resolution of nullable types\n                typeWithAnnotationsOpt = canDigThroughNullable ? default : next;\n                type = canDigThroughNullable ? next.NullableUnderlyingTypeOrSelf : null;\n            } 444882"];
15031 [label="TypeSymbol current = type ?? (useDefaultType ? typeWithAnnotationsOpt.DefaultType : typeWithAnnotationsOpt.Type); 444883"];
15032 [label="bool isNestedNamedType = false; 444884"];
15033 [label="current.TypeKind 444885"];
15034 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 444886"];
15035 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 444887"];
15036 [label="current.ContainingType 444888"];
15037 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 444889"];
15038 [label="return _container as NamedTypeSymbol; 444890"];
15039 [label="var containingType = current.ContainingType; 444891"];
15040 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 444892"];
15041 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 444893"];
15042 [label="typeWithAnnotationsOpt.HasType 444894"];
15043 [label="=> !(DefaultType is null) 444895"];
15044 [label="DefaultType is null 444896"];
15045 [label="!(DefaultType is null) 444897"];
15046 [label="if (typeWithAnnotationsOpt.HasType && typeWithAnnotationsPredicate != null)\n                {\n                    if (typeWithAnnotationsPredicate(typeWithAnnotationsOpt, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                }\n                else if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 444898"];
15047 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 444899"];
15048 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 444900"];
15049 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 444901"];
15050 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 444902"];
15051 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 444903"];
15052 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 444904"];
15053 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 444905"];
15054 [label="param IsErrorType(this TypeSymbol type) 444906"];
15055 [label="RoslynDebug.Assert((object)type != null); 444907"];
15056 [label="RoslynDebug.Assert((object)type != null); 444908"];
15057 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 444909"];
15058 [label="TypeWithAnnotations next; 444910"];
15059 [label="next 444911"];
15060 [label="current.TypeKind 444912"];
15061 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 444913"];
15062 [label="TypeKind result = _lazyKind; 444914"];
15063 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 444915"];
15064 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 444916"];
15065 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 444917"];
15066 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 444918"];
15067 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 444919"];
15068 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 444920"];
15069 [label="return null; 444921"];
15070 [label="return result is object; 444922"];
15071 [label="if (!baseContainsErrorTypes)\n            {\n                baseLocation = FindBaseRefSyntax(localBase);\n                Debug.Assert(!this.IsClassType() || localBase.IsObjectType() || baseLocation != null);\n            } 444923"];
15072 [label="baseLocation = FindBaseRefSyntax(localBase); 444924"];
15073 [label="FindBaseRefSyntax(localBase) 444925"];
15074 [label="param FindBaseRefSyntax(NamedTypeSymbol baseSym) 444926"];
15075 [label="param FindBaseRefSyntax(this) 444927"];
15076 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                BaseListSyntax bases = GetBaseListOpt(decl);\n                if (bases != null)\n                {\n                    var baseBinder = this.DeclaringCompilation.GetBinder(bases);\n                    // Wrap base binder in a location-specific binder that will avoid generic constraint checks.\n                    baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n\n                    foreach (var baseTypeSyntax in bases.Types)\n                    {\n                        var b = baseTypeSyntax.Type;\n                        var tmpDiag = DiagnosticBag.GetInstance();\n                        var curBaseSym = baseBinder.BindType(b, tmpDiag).Type;\n                        tmpDiag.Free();\n\n                        if (baseSym.Equals(curBaseSym))\n                        {\n                            return new SourceLocation(b);\n                        }\n                    }\n                }\n            } 444928"];
15077 [label="BaseListSyntax bases = GetBaseListOpt(decl); 444929"];
15078 [label="GetBaseListOpt(decl) 444930"];
15079 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 444931"];
15080 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 444932"];
15081 [label="return null; 444933"];
15082 [label="BaseListSyntax bases = GetBaseListOpt(decl); 444934"];
15083 [label="if (bases != null)\n                {\n                    var baseBinder = this.DeclaringCompilation.GetBinder(bases);\n                    // Wrap base binder in a location-specific binder that will avoid generic constraint checks.\n                    baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n\n                    foreach (var baseTypeSyntax in bases.Types)\n                    {\n                        var b = baseTypeSyntax.Type;\n                        var tmpDiag = DiagnosticBag.GetInstance();\n                        var curBaseSym = baseBinder.BindType(b, tmpDiag).Type;\n                        tmpDiag.Free();\n\n                        if (baseSym.Equals(curBaseSym))\n                        {\n                            return new SourceLocation(b);\n                        }\n                    }\n                } 444935"];
15084 [label="if (bases != null)\n                {\n                    var baseBinder = this.DeclaringCompilation.GetBinder(bases);\n                    // Wrap base binder in a location-specific binder that will avoid generic constraint checks.\n                    baseBinder = baseBinder.WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags.SuppressConstraintChecks, this);\n\n                    foreach (var baseTypeSyntax in bases.Types)\n                    {\n                        var b = baseTypeSyntax.Type;\n                        var tmpDiag = DiagnosticBag.GetInstance();\n                        var curBaseSym = baseBinder.BindType(b, tmpDiag).Type;\n                        tmpDiag.Free();\n\n                        if (baseSym.Equals(curBaseSym))\n                        {\n                            return new SourceLocation(b);\n                        }\n                    }\n                } 444936"];
15085 [label="return null; 444937"];
15086 [label="baseLocation = FindBaseRefSyntax(localBase); 444938"];
15087 [label="Debug.Assert(!this.IsClassType() || localBase.IsObjectType() || baseLocation != null); 444939"];
15088 [label="this.IsClassType() 444940"];
15089 [label="param IsClassType(this TypeSymbol type) 444941"];
15090 [label="RoslynDebug.Assert((object)type != null); 444942"];
15091 [label="RoslynDebug.Assert((object)type != null); 444943"];
15092 [label="type.TypeKind 444944"];
15093 [label="get\n            {\n                return _flags.TypeKind;\n            } 444945"];
15094 [label="return type.TypeKind == TypeKind.Class; 444946"];
15095 [label="Debug.Assert(!this.IsClassType() || localBase.IsObjectType() || baseLocation != null); 444947"];
15096 [label="localBase.IsObjectType() 444948"];
15097 [label="param IsObjectType(this TypeSymbol type) 444949"];
15098 [label="type.SpecialType 444950"];
15099 [label="get\n            {\n                return _corTypeId;\n            } 444951"];
15100 [label="return type.SpecialType == SpecialType.System_Object; 444952"];
15101 [label="Debug.Assert(!this.IsClassType() || localBase.IsObjectType() || baseLocation != null); 444953"];
15102 [label="this.IsGenericType 444954"];
15103 [label="get\n            {\n                for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            } 444955"];
15104 [label="for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                } 444956"];
15105 [label="for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                } 444957"];
15106 [label="current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 444958"];
15107 [label="get\n            {\n                return GetTypeParametersAsTypeArguments();\n            } 444959"];
15108 [label="GetTypeParametersAsTypeArguments() 444960"];
15109 [label="param GetTypeParametersAsTypeArguments(this) 444961"];
15110 [label="this.TypeParameters 444962"];
15111 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 444963"];
15112 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 444964"];
15113 [label="var diagnostics = DiagnosticBag.GetInstance(); 444965"];
15114 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444966"];
15115 [label="if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    } 444967"];
15116 [label="AddDeclarationDiagnostics(diagnostics); 444968"];
15117 [label="AddDeclarationDiagnostics(diagnostics) 444969"];
15118 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 444970"];
15119 [label="param AddDeclarationDiagnostics(this) 444971"];
15120 [label="ContainingSymbol 444972"];
15121 [label="get\n            {\n                return _containingSymbol;\n            } 444973"];
15122 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 444974"];
15123 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 444975"];
15124 [label="AddDeclarationDiagnostics(diagnostics); 444976"];
15125 [label="diagnostics.Free(); 444977"];
15126 [label="return _lazyTypeParameters; 444978"];
15127 [label="return TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters); 444979"];
15128 [label="t => t.Type 444980"];
15129 [label="AsTypeSymbol = t => t.Type 444981"];
15130 [label="ReferenceEqualityComparer.Instance 444982"];
15131 [label="new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 444983"];
15132 [label="s_emptyDictionary =\n            new SmallDictionary<TypeParameterSymbol, TypeWithAnnotations>(ReferenceEqualityComparer.Instance) 444984"];
15133 [label="new TypeMap() 444985"];
15134 [label="param TypeMap(this) 444986"];
15135 [label="s_emptyDictionary 444987"];
15136 [label="param AbstractTypeParameterMap(SmallDictionary<TypeParameterSymbol, TypeWithAnnotations> mapping) 444988"];
15137 [label="param AbstractTypeParameterMap(this) 444989"];
15138 [label="param AbstractTypeMap(this) 444990"];
15139 [label="Mapping 444991"];
15140 [label="this.Mapping 444992"];
15141 [label="Debug.Assert(s_emptyDictionary.IsEmpty()); 444993"];
15142 [label="s_emptyTypeMap = new TypeMap() 444994"];
15143 [label="TypeMap.TypeParametersAsTypeSymbolsWithAnnotations(this.TypeParameters) 444995"];
15144 [label="param TypeParametersAsTypeSymbolsWithAnnotations(ImmutableArray<TypeParameterSymbol> typeParameters) 444996"];
15145 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 444997"];
15146 [label="return typeParameters.SelectAsArray(static (tp) => TypeWithAnnotations.Create(tp)); 444998"];
15147 [label="return GetTypeParametersAsTypeArguments(); 444999"];
15148 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 445000"];
15149 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 445001"];
15150 [label="current.ContainingType 445002"];
15151 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 445003"];
15152 [label="return _containingSymbol as NamedTypeSymbol; 445004"];
15153 [label="return false; 445005"];
15154 [label="if (this.IsGenericType && !baseContainsErrorTypes && this.DeclaringCompilation.IsAttributeType(localBase))\n            {\n                // A generic type cannot derive from '{0}' because it is an attribute class\n                diagnostics.Add(ErrorCode.ERR_GenericDerivingFromAttribute, baseLocation, localBase);\n            } 445006"];
15155 [label="this.FirstDeclarationWithExplicitBases() 445007"];
15156 [label="param FirstDeclarationWithExplicitBases(this) 445008"];
15157 [label="foreach (var singleDeclaration in this.declaration.Declarations)\n            {\n                var bases = GetBaseListOpt(singleDeclaration);\n                if (bases != null)\n                {\n                    return singleDeclaration;\n                }\n            } 445009"];
15158 [label="var bases = GetBaseListOpt(singleDeclaration); 445010"];
15159 [label="GetBaseListOpt(singleDeclaration) 445011"];
15160 [label="param GetBaseListOpt(SingleTypeDeclaration decl) 445012"];
15161 [label="if (decl.HasBaseDeclarations)\n            {\n                var typeDeclaration = (BaseTypeDeclarationSyntax)decl.SyntaxReference.GetSyntax();\n                return typeDeclaration.BaseList;\n            } 445013"];
15162 [label="return null; 445014"];
15163 [label="var bases = GetBaseListOpt(singleDeclaration); 445015"];
15164 [label="if (bases != null)\n                {\n                    return singleDeclaration;\n                } 445016"];
15165 [label="if (bases != null)\n                {\n                    return singleDeclaration;\n                } 445017"];
15166 [label="return null; 445018"];
15167 [label="var singleDeclaration = this.FirstDeclarationWithExplicitBases(); 445019"];
15168 [label="if (singleDeclaration != null)\n            {\n                var corLibrary = this.ContainingAssembly.CorLibrary;\n                var conversions = new TypeConversions(corLibrary);\n                var location = singleDeclaration.NameLocation;\n\n                localBase.CheckAllConstraints(DeclaringCompilation, conversions, location, diagnostics);\n            } 445020"];
15169 [label="if (singleDeclaration != null)\n            {\n                var corLibrary = this.ContainingAssembly.CorLibrary;\n                var conversions = new TypeConversions(corLibrary);\n                var location = singleDeclaration.NameLocation;\n\n                localBase.CheckAllConstraints(DeclaringCompilation, conversions, location, diagnostics);\n            } 445021"];
15170 [label="if (this.IsClassType() && !localBase.IsObjectType() && !baseContainsErrorTypes)\n            {\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                if (declaration.Kind == DeclarationKind.Record)\n                {\n                    if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is null ||\n                        SynthesizedRecordPrintMembers.FindValidPrintMembersMethod(localBase, DeclaringCompilation) is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_BadRecordBase, baseLocation);\n                    }\n                }\n                else if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is object)\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadInheritanceFromRecord, baseLocation);\n                }\n\n                diagnostics.Add(baseLocation, useSiteDiagnostics);\n            } 445022"];
15171 [label="this.IsClassType() 445023"];
15172 [label="param IsClassType(this TypeSymbol type) 445024"];
15173 [label="RoslynDebug.Assert((object)type != null); 445025"];
15174 [label="RoslynDebug.Assert((object)type != null); 445026"];
15175 [label="type.TypeKind 445027"];
15176 [label="get\n            {\n                return _flags.TypeKind;\n            } 445028"];
15177 [label="_flags.TypeKind 445029"];
15178 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 445030"];
15179 [label="return type.TypeKind == TypeKind.Class; 445031"];
15180 [label="if (this.IsClassType() && !localBase.IsObjectType() && !baseContainsErrorTypes)\n            {\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                if (declaration.Kind == DeclarationKind.Record)\n                {\n                    if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is null ||\n                        SynthesizedRecordPrintMembers.FindValidPrintMembersMethod(localBase, DeclaringCompilation) is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_BadRecordBase, baseLocation);\n                    }\n                }\n                else if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is object)\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadInheritanceFromRecord, baseLocation);\n                }\n\n                diagnostics.Add(baseLocation, useSiteDiagnostics);\n            } 445032"];
15181 [label="localBase.IsObjectType() 445033"];
15182 [label="param IsObjectType(this TypeSymbol type) 445034"];
15183 [label="type.SpecialType 445035"];
15184 [label="get\n            {\n                return _corTypeId;\n            } 445036"];
15185 [label="return _corTypeId; 445037"];
15186 [label="return type.SpecialType == SpecialType.System_Object; 445038"];
15187 [label="if (this.IsClassType() && !localBase.IsObjectType() && !baseContainsErrorTypes)\n            {\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                if (declaration.Kind == DeclarationKind.Record)\n                {\n                    if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is null ||\n                        SynthesizedRecordPrintMembers.FindValidPrintMembersMethod(localBase, DeclaringCompilation) is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_BadRecordBase, baseLocation);\n                    }\n                }\n                else if (SynthesizedRecordClone.FindValidCloneMethod(localBase, ref useSiteDiagnostics) is object)\n                {\n                    diagnostics.Add(ErrorCode.ERR_BadInheritanceFromRecord, baseLocation);\n                }\n\n                diagnostics.Add(baseLocation, useSiteDiagnostics);\n            } 445039"];
15188 [label="CheckBase(diagnostics); 445040"];
15189 [label="AddDeclarationDiagnostics(diagnostics); 445041"];
15190 [label="AddDeclarationDiagnostics(diagnostics) 445042"];
15191 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445043"];
15192 [label="param AddDeclarationDiagnostics(this) 445044"];
15193 [label="ContainingSymbol 445045"];
15194 [label="get\n            {\n                return _containingSymbol;\n            } 445046"];
15195 [label="return _containingSymbol; 445047"];
15196 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445048"];
15197 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445049"];
15198 [label="AddDeclarationDiagnostics(diagnostics); 445050"];
15199 [label="state.NotePartComplete(CompletionPart.FinishBaseType); 445051"];
15200 [label="state.NotePartComplete(CompletionPart.FinishBaseType) 445052"];
15201 [label="param NotePartComplete(CompletionPart part) 445053"];
15202 [label="param NotePartComplete(this) 445054"];
15203 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 445055"];
15204 [label="diagnostics.Free(); 445056"];
15205 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 445057"];
15206 [label="param SpinWaitComplete(CompletionPart part) 445058"];
15207 [label="param SpinWaitComplete(this) 445059"];
15208 [label="if (HasComplete(part))\n            {\n                return;\n            } 445060"];
15209 [label="param HasComplete(CompletionPart part) 445061"];
15210 [label="param HasComplete(this) 445062"];
15211 [label="return (_completeParts & (int)part) == (int)part; 445063"];
15212 [label="return; 445064"];
15213 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 445065"];
15214 [label="param HasAtMostOneBitSet(int bits) 445066"];
15215 [label="return (bits & (bits - 1)) == 0; 445067"];
15216 [label="if (state.NotePartComplete(CompletionPart.StartInterfaces))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            CheckInterfaces(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n                            state.NotePartComplete(CompletionPart.FinishInterfaces);\n                            diagnostics.Free();\n                        } 445068"];
15217 [label="state.NotePartComplete(CompletionPart.StartInterfaces) 445069"];
15218 [label="param NotePartComplete(CompletionPart part) 445070"];
15219 [label="var diagnostics = DiagnosticBag.GetInstance(); 445071"];
15220 [label="CheckInterfaces(diagnostics); 445072"];
15221 [label="CheckInterfaces(diagnostics) 445073"];
15222 [label="param CheckInterfaces(DiagnosticBag diagnostics) 445074"];
15223 [label="param CheckInterfaces(this) 445075"];
15224 [label="this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics 445076"];
15225 [label="get\n            {\n                var info = this.GetInterfaceInfo();\n                if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                }\n\n                if (info.interfacesAndTheirBaseInterfaces == null)\n                {\n                    Interlocked.CompareExchange(ref info.interfacesAndTheirBaseInterfaces, MakeInterfacesAndTheirBaseInterfaces(this.InterfacesNoUseSiteDiagnostics()), null);\n                }\n\n                return info.interfacesAndTheirBaseInterfaces;\n            } 445077"];
15226 [label="this.GetInterfaceInfo() 445078"];
15227 [label="param GetInterfaceInfo(this) 445079"];
15228 [label="var info = _lazyInterfaceInfo; 445080"];
15229 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445081"];
15230 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445082"];
15231 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 445083"];
15232 [label="for (var baseType = this; !ReferenceEquals(baseType, null); baseType = baseType.BaseTypeNoUseSiteDiagnostics)\n            {\n                var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics();\n                if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                }\n            } 445084"];
15233 [label="baseType.TypeKind 445085"];
15234 [label="var interfaces = (baseType.TypeKind == TypeKind.TypeParameter) ? ((TypeParameterSymbol)baseType).EffectiveInterfacesNoUseSiteDiagnostics : baseType.InterfacesNoUseSiteDiagnostics(); 445086"];
15235 [label="(baseType.TypeKind == TypeKind.TypeParameter) 445087"];
15236 [label="baseType.InterfacesNoUseSiteDiagnostics() 445088"];
15237 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 445089"];
15238 [label="param InterfacesNoUseSiteDiagnostics(this) 445090"];
15239 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 445091"];
15240 [label="if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                } 445092"];
15241 [label="if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                } 445093"];
15242 [label="var diagnostics = DiagnosticBag.GetInstance(); 445094"];
15243 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 445095"];
15244 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 445096"];
15245 [label="MakeAcyclicInterfaces(basesBeingResolved, diagnostics) 445097"];
15246 [label="param MakeAcyclicInterfaces(ConsList<TypeSymbol> basesBeingResolved) 445098"];
15247 [label="param MakeAcyclicInterfaces(DiagnosticBag diagnostics) 445099"];
15248 [label="param MakeAcyclicInterfaces(this) 445100"];
15249 [label="this.TypeKind 445101"];
15250 [label="get\n            {\n                return _flags.TypeKind;\n            } 445102"];
15251 [label="var typeKind = this.TypeKind; 445103"];
15252 [label="if (typeKind == TypeKind.Enum)\n            {\n                Debug.Assert(GetDeclaredInterfaces(basesBeingResolved: null).IsEmpty, 'Computation skipped for enums');\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 445104"];
15253 [label="var declaredInterfaces = GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved); 445105"];
15254 [label="GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved) 445106"];
15255 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 445107"];
15256 [label="param GetDeclaredInterfaces(this) 445108"];
15257 [label="return GetDeclaredBases(basesBeingResolved).Item2; 445109"];
15258 [label="GetDeclaredBases(basesBeingResolved) 445110"];
15259 [label="param GetDeclaredBases(ConsList<TypeSymbol> basesBeingResolved) 445111"];
15260 [label="param GetDeclaredBases(this) 445112"];
15261 [label="return GetDeclaredBases(basesBeingResolved).Item2; 445113"];
15262 [label="var declaredInterfaces = GetDeclaredInterfaces(basesBeingResolved: basesBeingResolved); 445114"];
15263 [label="bool isInterface = (typeKind == TypeKind.Interface); 445115"];
15264 [label="isInterface 445116"];
15265 [label="ArrayBuilder<NamedTypeSymbol> result = isInterface ? ArrayBuilder<NamedTypeSymbol>.GetInstance() : null; 445117"];
15266 [label="foreach (var t in declaredInterfaces)\n            {\n                if (isInterface)\n                {\n                    if (BaseTypeAnalysis.TypeDependsOn(depends: t, on: this))\n                    {\n                        result.Add(new ExtendedErrorTypeSymbol(t, LookupResultKind.NotReferencable,\n                            diagnostics.Add(ErrorCode.ERR_CycleInInterfaceInheritance, Locations[0], this, t)));\n                        continue;\n                    }\n                    else\n                    {\n                        result.Add(t);\n                    }\n                }\n\n                HashSet<DiagnosticInfo> useSiteDiagnostics = null;\n\n                if (t.DeclaringCompilation != this.DeclaringCompilation)\n                {\n                    t.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n\n                    foreach (var @interface in t.AllInterfacesNoUseSiteDiagnostics)\n                    {\n                        if (@interface.DeclaringCompilation != this.DeclaringCompilation)\n                        {\n                            @interface.AddUseSiteDiagnostics(ref useSiteDiagnostics);\n                        }\n                    }\n                }\n\n                if (!useSiteDiagnostics.IsNullOrEmpty())\n                {\n                    diagnostics.Add(Locations[0], useSiteDiagnostics);\n                }\n            } 445118"];
15267 [label="isInterface 445119"];
15268 [label="return isInterface ? result.ToImmutableAndFree() : declaredInterfaces; 445120"];
15269 [label="var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics); 445121"];
15270 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 445122"];
15271 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 445123"];
15272 [label="if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                } 445124"];
15273 [label="AddDeclarationDiagnostics(diagnostics); 445125"];
15274 [label="AddDeclarationDiagnostics(diagnostics) 445126"];
15275 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445127"];
15276 [label="param AddDeclarationDiagnostics(this) 445128"];
15277 [label="ContainingSymbol 445129"];
15278 [label="get\n            {\n                return _containingSymbol;\n            } 445130"];
15279 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445131"];
15280 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445132"];
15281 [label="AddDeclarationDiagnostics(diagnostics); 445133"];
15282 [label="diagnostics.Free(); 445134"];
15283 [label="return _lazyInterfaces; 445135"];
15284 [label="if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                } 445136"];
15285 [label="baseType.BaseTypeNoUseSiteDiagnostics 445137"];
15286 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 445138"];
15287 [label="return _lazyBaseType; 445139"];
15288 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved = null) 445140"];
15289 [label="param InterfacesNoUseSiteDiagnostics(this) 445141"];
15290 [label="if (_lazyInterfaces.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>));\n            } 445142"];
15291 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445143"];
15292 [label="MakeAcyclicInterfaces() 445144"];
15293 [label="param MakeAcyclicInterfaces(this) 445145"];
15294 [label="var declaredInterfaces = GetDeclaredInterfaces(null); 445146"];
15295 [label="GetDeclaredInterfaces(null) 445147"];
15296 [label="param GetDeclaredInterfaces(ConsList<TypeSymbol> basesBeingResolved) 445148"];
15297 [label="param GetDeclaredInterfaces(this) 445149"];
15298 [label="if (_lazyDeclaredInterfaces.IsDefault)\n            {\n                ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>));\n            } 445150"];
15299 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445151"];
15300 [label="MakeDeclaredInterfaces() 445152"];
15301 [label="param MakeDeclaredInterfaces(this) 445153"];
15302 [label="ContainingPEModule 445154"];
15303 [label="get\n            {\n                Symbol s = _container;\n\n                while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                }\n\n                return ((PENamespaceSymbol)s).ContainingPEModule;\n            } 445155"];
15304 [label="s.Kind 445156"];
15305 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 445157"];
15306 [label="while (s.Kind != SymbolKind.Namespace)\n                {\n                    s = s.ContainingSymbol;\n                } 445158"];
15307 [label="var moduleSymbol = ContainingPEModule; 445159"];
15308 [label="moduleSymbol.Module 445160"];
15309 [label="get\n            {\n                return _module;\n            } 445161"];
15310 [label="var interfaceImpls = moduleSymbol.Module.GetInterfaceImplementationsOrThrow(_handle); 445162"];
15311 [label="var interfaceImpls = moduleSymbol.Module.GetInterfaceImplementationsOrThrow(_handle); 445163"];
15312 [label="if (interfaceImpls.Count > 0)\n                {\n                    var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(interfaceImpls.Count);\n                    var tokenDecoder = new MetadataDecoder(moduleSymbol, this);\n\n                    foreach (var interfaceImpl in interfaceImpls)\n                    {\n                        EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface;\n                        TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle);\n\n                        typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n\n                        var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); // interface list contains a bad type\n                        symbols.Add(namedTypeSymbol);\n                    }\n\n                    return symbols.ToImmutableAndFree();\n                } 445164"];
15313 [label="if (interfaceImpls.Count > 0)\n                {\n                    var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(interfaceImpls.Count);\n                    var tokenDecoder = new MetadataDecoder(moduleSymbol, this);\n\n                    foreach (var interfaceImpl in interfaceImpls)\n                    {\n                        EntityHandle interfaceHandle = moduleSymbol.Module.MetadataReader.GetInterfaceImplementation(interfaceImpl).Interface;\n                        TypeSymbol typeSymbol = tokenDecoder.GetTypeOfToken(interfaceHandle);\n\n                        typeSymbol = NativeIntegerTypeDecoder.TransformType(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = TupleTypeDecoder.DecodeTupleTypesIfApplicable(typeSymbol, interfaceImpl, moduleSymbol);\n                        typeSymbol = NullableTypeDecoder.TransformType(TypeWithAnnotations.Create(typeSymbol), interfaceImpl, moduleSymbol, accessSymbol: this, nullableContext: this).Type;\n\n                        var namedTypeSymbol = typeSymbol as NamedTypeSymbol ?? new UnsupportedMetadataTypeSymbol(); // interface list contains a bad type\n                        symbols.Add(namedTypeSymbol);\n                    }\n\n                    return symbols.ToImmutableAndFree();\n                } 445165"];
15314 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 445166"];
15315 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445167"];
15316 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445168"];
15317 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyDeclaredInterfaces, MakeDeclaredInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445169"];
15318 [label="return _lazyDeclaredInterfaces; 445170"];
15319 [label="var declaredInterfaces = GetDeclaredInterfaces(null); 445171"];
15320 [label="IsInterface 445172"];
15321 [label="get\n            {\n                return _flags.IsInterface();\n            } 445173"];
15322 [label="return _flags.IsInterface(); 445174"];
15323 [label="if (!IsInterface)\n            {\n                // only interfaces needs to check for inheritance cycles via interfaces.\n                return declaredInterfaces;\n            } 445175"];
15324 [label="return declaredInterfaces; 445176"];
15325 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445177"];
15326 [label="ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, MakeAcyclicInterfaces(), default(ImmutableArray<NamedTypeSymbol>)); 445178"];
15327 [label="return _lazyInterfaces; 445179"];
15328 [label="if (!interfaces.IsEmpty)\n                {\n                    // it looks like we or one of our bases implements something.\n                    info = new InterfaceInfo();\n\n                    // NOTE: we are assigning lazyInterfaceInfo via interlocked not for correctness, \n                    // we just do not want to override an existing info that could be partially filled.\n                    return Interlocked.CompareExchange(ref _lazyInterfaceInfo, info, null) ?? info;\n                } 445180"];
15329 [label="_lazyInterfaceInfo = info = s_noInterfaces; 445181"];
15330 [label="_lazyInterfaceInfo 445182"];
15331 [label="return info; 445183"];
15332 [label="var info = this.GetInterfaceInfo(); 445184"];
15333 [label="if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                } 445185"];
15334 [label="Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty); 445186"];
15335 [label="return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces; 445187"];
15336 [label="var interfaces = this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics; 445188"];
15337 [label="if (interfaces.IsEmpty)\n            {\n                // nothing to verify\n                return;\n            } 445189"];
15338 [label="return; 445190"];
15339 [label="CheckInterfaces(diagnostics); 445191"];
15340 [label="AddDeclarationDiagnostics(diagnostics); 445192"];
15341 [label="AddDeclarationDiagnostics(diagnostics) 445193"];
15342 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445194"];
15343 [label="param AddDeclarationDiagnostics(this) 445195"];
15344 [label="ContainingSymbol 445196"];
15345 [label="get\n            {\n                return _containingSymbol;\n            } 445197"];
15346 [label="return _containingSymbol; 445198"];
15347 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445199"];
15348 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445200"];
15349 [label="AddDeclarationDiagnostics(diagnostics); 445201"];
15350 [label="state.NotePartComplete(CompletionPart.FinishInterfaces); 445202"];
15351 [label="state.NotePartComplete(CompletionPart.FinishInterfaces) 445203"];
15352 [label="param NotePartComplete(CompletionPart part) 445204"];
15353 [label="param NotePartComplete(this) 445205"];
15354 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 445206"];
15355 [label="diagnostics.Free(); 445207"];
15356 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 445208"];
15357 [label="param SpinWaitComplete(CompletionPart part) 445209"];
15358 [label="param SpinWaitComplete(this) 445210"];
15359 [label="if (HasComplete(part))\n            {\n                return;\n            } 445211"];
15360 [label="param HasComplete(CompletionPart part) 445212"];
15361 [label="param HasComplete(this) 445213"];
15362 [label="return (_completeParts & (int)part) == (int)part; 445214"];
15363 [label="return; 445215"];
15364 [label="cancellationToken.ThrowIfCancellationRequested(); 445216"];
15365 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 445217"];
15366 [label="param HasAtMostOneBitSet(int bits) 445218"];
15367 [label="return (bits & (bits - 1)) == 0; 445219"];
15368 [label="this.EnumUnderlyingType 445220"];
15369 [label="get\n            {\n                if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyEnumUnderlyingType;\n            } 445221"];
15370 [label="if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                } 445222"];
15371 [label="if (ReferenceEquals(_lazyEnumUnderlyingType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    DiagnosticBag diagnostics = DiagnosticBag.GetInstance();\n                    if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    }\n                    diagnostics.Free();\n                } 445223"];
15372 [label="DiagnosticBag diagnostics = DiagnosticBag.GetInstance(); 445224"];
15373 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 445225"];
15374 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 445226"];
15375 [label="this.GetEnumUnderlyingType(diagnostics) 445227"];
15376 [label="param GetEnumUnderlyingType(DiagnosticBag diagnostics) 445228"];
15377 [label="param GetEnumUnderlyingType(this) 445229"];
15378 [label="this.TypeKind 445230"];
15379 [label="get\n            {\n                return _flags.TypeKind;\n            } 445231"];
15380 [label="if (this.TypeKind != TypeKind.Enum)\n            {\n                return null;\n            } 445232"];
15381 [label="return null; 445233"];
15382 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 445234"];
15383 [label="if ((object)Interlocked.CompareExchange(ref _lazyEnumUnderlyingType, this.GetEnumUnderlyingType(diagnostics), ErrorTypeSymbol.UnknownResultType) ==\n                        (object)ErrorTypeSymbol.UnknownResultType)\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                        this.state.NotePartComplete(CompletionPart.EnumUnderlyingType);\n                    } 445235"];
15384 [label="AddDeclarationDiagnostics(diagnostics); 445236"];
15385 [label="AddDeclarationDiagnostics(diagnostics) 445237"];
15386 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445238"];
15387 [label="param AddDeclarationDiagnostics(this) 445239"];
15388 [label="ContainingSymbol 445240"];
15389 [label="get\n            {\n                return _containingSymbol;\n            } 445241"];
15390 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445242"];
15391 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445243"];
15392 [label="AddDeclarationDiagnostics(diagnostics); 445244"];
15393 [label="this.state.NotePartComplete(CompletionPart.EnumUnderlyingType); 445245"];
15394 [label="this.state.NotePartComplete(CompletionPart.EnumUnderlyingType) 445246"];
15395 [label="param NotePartComplete(CompletionPart part) 445247"];
15396 [label="diagnostics.Free(); 445248"];
15397 [label="return _lazyEnumUnderlyingType; 445249"];
15398 [label="var discarded = this.EnumUnderlyingType; 445250"];
15399 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 445251"];
15400 [label="param SpinWaitComplete(CompletionPart part) 445252"];
15401 [label="param SpinWaitComplete(this) 445253"];
15402 [label="if (HasComplete(part))\n            {\n                return;\n            } 445254"];
15403 [label="param HasComplete(CompletionPart part) 445255"];
15404 [label="param HasComplete(this) 445256"];
15405 [label="return (_completeParts & (int)part) == (int)part; 445257"];
15406 [label="return; 445258"];
15407 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 445259"];
15408 [label="param HasAtMostOneBitSet(int bits) 445260"];
15409 [label="return (bits & (bits - 1)) == 0; 445261"];
15410 [label="this.TypeParameters 445262"];
15411 [label="foreach (var typeParameter in this.TypeParameters)\n                        {\n                            typeParameter.ForceComplete(locationOpt, cancellationToken);\n                        } 445263"];
15412 [label="state.NotePartComplete(CompletionPart.TypeParameters); 445264"];
15413 [label="state.NotePartComplete(CompletionPart.TypeParameters) 445265"];
15414 [label="param NotePartComplete(CompletionPart part) 445266"];
15415 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 445267"];
15416 [label="param SpinWaitComplete(CompletionPart part) 445268"];
15417 [label="param SpinWaitComplete(this) 445269"];
15418 [label="if (HasComplete(part))\n            {\n                return;\n            } 445270"];
15419 [label="param HasComplete(CompletionPart part) 445271"];
15420 [label="param HasComplete(this) 445272"];
15421 [label="return (_completeParts & (int)part) == (int)part; 445273"];
15422 [label="return; 445274"];
15423 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 445275"];
15424 [label="param HasAtMostOneBitSet(int bits) 445276"];
15425 [label="return (bits & (bits - 1)) == 0; 445277"];
15426 [label="this.GetMembersByName() 445278"];
15427 [label="param GetMembersByName(this) 445279"];
15428 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 445280"];
15429 [label="this.state.HasComplete(CompletionPart.Members) 445281"];
15430 [label="param HasComplete(CompletionPart part) 445282"];
15431 [label="param HasComplete(this) 445283"];
15432 [label="return (_completeParts & (int)part) == (int)part; 445284"];
15433 [label="GetMembersByNameSlow() 445285"];
15434 [label="param GetMembersByNameSlow(this) 445286"];
15435 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 445287"];
15436 [label="if (_lazyMembersDictionary == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                var membersDictionary = MakeAllMembers(diagnostics);\n\n                if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                }\n\n                diagnostics.Free();\n            } 445288"];
15437 [label="var diagnostics = DiagnosticBag.GetInstance(); 445289"];
15438 [label="var membersDictionary = MakeAllMembers(diagnostics); 445290"];
15439 [label="MakeAllMembers(diagnostics) 445291"];
15440 [label="param MakeAllMembers(DiagnosticBag diagnostics) 445292"];
15441 [label="param MakeAllMembers(this) 445293"];
15442 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName; 445294"];
15443 [label="GetMembersAndInitializers() 445295"];
15444 [label="param GetMembersAndInitializers(this) 445296"];
15445 [label="var membersAndInitializers = _lazyMembersAndInitializers; 445297"];
15446 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 445298"];
15447 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 445299"];
15448 [label="var diagnostics = DiagnosticBag.GetInstance(); 445300"];
15449 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 445301"];
15450 [label="BuildMembersAndInitializers(diagnostics) 445302"];
15451 [label="param BuildMembersAndInitializers(DiagnosticBag diagnostics) 445303"];
15452 [label="param BuildMembersAndInitializers(this) 445304"];
15453 [label="getDeclaredMembersAndInitializers() 445305"];
15454 [label="DeclaredMembersAndInitializers? getDeclaredMembersAndInitializers()\n            {\n                var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers;\n                if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                }\n\n                if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics);\n\n                var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel);\n                if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                }\n\n                AddDeclarationDiagnostics(diagnostics);\n                diagnostics.Free();\n\n                return declaredMembersAndInitializers!;\n            } 445306"];
15455 [label="var declaredMembersAndInitializers = _lazyDeclaredMembersAndInitializers; 445307"];
15456 [label="if (declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    return declaredMembersAndInitializers;\n                } 445308"];
15457 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) is not null)\n                {\n                    // We're previously computed declared members and already cleared them out\n                    // No need to compute them again\n                    return null;\n                } 445309"];
15458 [label="var diagnostics = DiagnosticBag.GetInstance(); 445310"];
15459 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 445311"];
15460 [label="buildDeclaredMembersAndInitializers(diagnostics) 445312"];
15461 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 445313"];
15462 [label="DeclaredMembersAndInitializers? buildDeclaredMembersAndInitializers(DiagnosticBag diagnostics)\n            {\n                var builder = new DeclaredMembersAndInitializersBuilder();\n                AddDeclaredNontypeMembers(builder, diagnostics);\n\n                switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                }\n\n                if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                }\n\n                if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                }\n\n                return builder.ToReadOnlyAndFree();\n            } 445314"];
15463 [label="var builder = new DeclaredMembersAndInitializersBuilder(); 445315"];
15464 [label="new DeclaredMembersAndInitializersBuilder() 445316"];
15465 [label="param DeclaredMembersAndInitializersBuilder(this) 445317"];
15466 [label="ArrayBuilder<Symbol>.GetInstance() 445318"];
15467 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance() 445319"];
15468 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 445320"];
15469 [label="StaticInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 445321"];
15470 [label="ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 445322"];
15471 [label="InstanceInitializers = ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>>.GetInstance() 445323"];
15472 [label="HaveIndexers 445324"];
15473 [label="RecordDeclarationWithParameters 445325"];
15474 [label="RecordPrimaryConstructor 445326"];
15475 [label="1 445327"];
15476 [label="InstanceInitializersIndexForRecordDeclarationWithParameters = -1 445328"];
15477 [label="IsNullableEnabledForInstanceConstructorsAndFields 445329"];
15478 [label="IsNullableEnabledForStaticConstructorsAndFields 445330"];
15479 [label="AddDeclaredNontypeMembers(builder, diagnostics); 445331"];
15480 [label="AddDeclaredNontypeMembers(builder, diagnostics); 445332"];
15481 [label="AddDeclaredNontypeMembers(builder, diagnostics) 445333"];
15482 [label="param AddDeclaredNontypeMembers(DeclaredMembersAndInitializersBuilder builder) 445334"];
15483 [label="param AddDeclaredNontypeMembers(DiagnosticBag diagnostics) 445335"];
15484 [label="param AddDeclaredNontypeMembers(this) 445336"];
15485 [label="foreach (var decl in this.declaration.Declarations)\n            {\n                if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                }\n\n                if (_lazyMembersAndInitializers != null)\n                {\n                    // membersAndInitializers is already computed. no point to continue.\n                    return;\n                }\n\n                var syntax = decl.SyntaxReference.GetSyntax();\n\n                switch (syntax.Kind())\n                {\n                    case SyntaxKind.EnumDeclaration:\n                        AddEnumMembers(builder, (EnumDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.DelegateDeclaration:\n                        SourceDelegateMethodSymbol.AddDelegateMembers(this, builder.NonTypeMembers, (DelegateDeclarationSyntax)syntax, diagnostics);\n                        break;\n\n                    case SyntaxKind.NamespaceDeclaration:\n                        // The members of a global anonymous type is in a syntax tree of a namespace declaration or a compilation unit.\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((NamespaceDeclarationSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.CompilationUnit:\n                        AddNonTypeMembers(builder, instanceInitializers: null, ((CompilationUnitSyntax)syntax).Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.ClassDeclaration:\n                    case SyntaxKind.InterfaceDeclaration:\n                    case SyntaxKind.StructDeclaration:\n                        var typeDecl = (TypeDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder, instanceInitializers: null, typeDecl.Members, diagnostics);\n                        break;\n\n                    case SyntaxKind.RecordDeclaration:\n                        var recordDecl = (RecordDeclarationSyntax)syntax;\n                        AddNonTypeMembers(builder,\n                            instanceInitializers: noteRecordParameters(recordDecl, builder, diagnostics),\n                            recordDecl.Members,\n                            diagnostics);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(syntax.Kind());\n                }\n            } 445337"];
15486 [label="if (!decl.HasAnyNontypeMembers)\n                {\n                    continue;\n                } 445338"];
15487 [label="AddDeclaredNontypeMembers(builder, diagnostics); 445339"];
15488 [label="TypeKind 445340"];
15489 [label="get\n            {\n                return _flags.TypeKind;\n            } 445341"];
15490 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 445342"];
15491 [label="switch (TypeKind)\n                {\n                    case TypeKind.Struct:\n                        CheckForStructBadInitializers(builder, diagnostics);\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: false, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Enum:\n                        CheckForStructDefaultConstructors(builder.NonTypeMembers, isEnum: true, diagnostics: diagnostics);\n                        break;\n\n                    case TypeKind.Class:\n                    case TypeKind.Interface:\n                    case TypeKind.Submission:\n                        // No additional checking required.\n                        break;\n\n                    default:\n                        break;\n                } 445343"];
15492 [label="IsTupleType 445344"];
15493 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 445345"];
15494 [label="_ 445346"];
15495 [label="tupleCardinality: out _ 445347"];
15496 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 445348"];
15497 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 445349"];
15498 [label="param IsTupleTypeOfCardinality(this) 445350"];
15499 [label="IsUnboundGenericType 445351"];
15500 [label="get\n            {\n                return false;\n            } 445352"];
15501 [label="return false; 445353"];
15502 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445354"];
15503 [label="ContainingSymbol 445355"];
15504 [label="get\n            {\n                return _containingSymbol;\n            } 445356"];
15505 [label="return _containingSymbol; 445357"];
15506 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445358"];
15507 [label=".Kind 445359"];
15508 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 445360"];
15509 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445361"];
15510 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445362"];
15511 [label="ContainingNamespace 445363"];
15512 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445364"];
15513 [label="return _containingSymbol; 445365"];
15514 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445366"];
15515 [label="ContainingNamespace.ContainingNamespace 445367"];
15516 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445368"];
15517 [label="=> _container 445369"];
15518 [label="_container 445370"];
15519 [label=".IsGlobalNamespace 445371"];
15520 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 445372"];
15521 [label="ContainingNamespace 445373"];
15522 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445374"];
15523 [label="container.ContainingSymbol 445375"];
15524 [label="get\n            {\n                return _assemblySymbol;\n            } 445376"];
15525 [label="return _assemblySymbol; 445377"];
15526 [label="get\n            {\n                return null;\n            } 445378"];
15527 [label="return null; 445379"];
15528 [label="return (object)ContainingNamespace == null; 445380"];
15529 [label="return (object)ContainingNamespace == null; 445381"];
15530 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445382"];
15531 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445383"];
15532 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445384"];
15533 [label="Name 445385"];
15534 [label="get\n            {\n                return declaration.Name;\n            } 445386"];
15535 [label="return declaration.Name; 445387"];
15536 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445388"];
15537 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445389"];
15538 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445390"];
15539 [label="tupleCardinality = 0; 445391"];
15540 [label="return false; 445392"];
15541 [label="if (IsTupleType)\n                {\n                    builder.AddOrWrapTupleMembers(this);\n                } 445393"];
15542 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 445394"];
15543 [label="if (Volatile.Read(ref _lazyDeclaredMembersAndInitializers) != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    // _lazyDeclaredMembersAndInitializers is already computed. no point to continue.\n                    builder.Free();\n                    return null;\n                } 445395"];
15544 [label="builder.ToReadOnlyAndFree() 445396"];
15545 [label="param ToReadOnlyAndFree(this) 445397"];
15546 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445398"];
15547 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445399"];
15548 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers) 445400"];
15549 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 445401"];
15550 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 445402"];
15551 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 445403"];
15552 [label="initializers.Free(); 445404"];
15553 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 445405"];
15554 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445406"];
15555 [label="MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers) 445407"];
15556 [label="param ToReadOnlyAndFree(ArrayBuilder<ArrayBuilder<FieldOrPropertyInitializer>> initializers) 445408"];
15557 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 445409"];
15558 [label="if (initializers.Count == 0)\n                {\n                    initializers.Free();\n                    return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty;\n                } 445410"];
15559 [label="initializers.Free(); 445411"];
15560 [label="return ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>>.Empty; 445412"];
15561 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445413"];
15562 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445414"];
15563 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445415"];
15564 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445416"];
15565 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445417"];
15566 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445418"];
15567 [label="return new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445419"];
15568 [label="new DeclaredMembersAndInitializers(\n                    NonTypeMembers.ToImmutableAndFree(),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(StaticInitializers),\n                    MembersAndInitializersBuilder.ToReadOnlyAndFree(InstanceInitializers),\n                    HaveIndexers,\n                    RecordDeclarationWithParameters,\n                    RecordPrimaryConstructor,\n                    InstanceInitializersIndexForRecordDeclarationWithParameters,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 445420"];
15569 [label="param DeclaredMembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 445421"];
15570 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 445422"];
15571 [label="param DeclaredMembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 445423"];
15572 [label="param DeclaredMembersAndInitializers(bool haveIndexers) 445424"];
15573 [label="param DeclaredMembersAndInitializers(RecordDeclarationSyntax? recordDeclarationWithParameters) 445425"];
15574 [label="param DeclaredMembersAndInitializers(SynthesizedRecordConstructor? recordPrimaryConstructor) 445426"];
15575 [label="param DeclaredMembersAndInitializers(int instanceInitializersIndexForRecordDeclarationWithParameters) 445427"];
15576 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 445428"];
15577 [label="param DeclaredMembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 445429"];
15578 [label="param DeclaredMembersAndInitializers(this) 445430"];
15579 [label="HaveIndexers 445431"];
15580 [label="RecordDeclarationWithParameters 445432"];
15581 [label="RecordPrimaryConstructor 445433"];
15582 [label="InstanceInitializersIndexForRecordDeclarationWithParameters 445434"];
15583 [label="IsNullableEnabledForInstanceConstructorsAndFields 445435"];
15584 [label="IsNullableEnabledForStaticConstructorsAndFields 445436"];
15585 [label="Debug.Assert(!nonTypeMembers.IsDefault); 445437"];
15586 [label="Debug.Assert(!staticInitializers.IsDefault); 445438"];
15587 [label="Debug.Assert(!instanceInitializers.IsDefault); 445439"];
15588 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 445440"];
15589 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 445441"];
15590 [label="Debug.Assert(recordDeclarationWithParameters is object == recordPrimaryConstructor is object); 445442"];
15591 [label="this.NonTypeMembers 445443"];
15592 [label="this.StaticInitializers 445444"];
15593 [label="this.InstanceInitializers 445445"];
15594 [label="this.HaveIndexers 445446"];
15595 [label="this.RecordDeclarationWithParameters 445447"];
15596 [label="this.RecordPrimaryConstructor 445448"];
15597 [label="this.InstanceInitializersIndexForRecordDeclarationWithParameters 445449"];
15598 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 445450"];
15599 [label="this.IsNullableEnabledForStaticConstructorsAndFields 445451"];
15600 [label="return builder.ToReadOnlyAndFree(); 445452"];
15601 [label="declaredMembersAndInitializers = buildDeclaredMembersAndInitializers(diagnostics); 445453"];
15602 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 445454"];
15603 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 445455"];
15604 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 445456"];
15605 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyDeclaredMembersAndInitializers, declaredMembersAndInitializers, DeclaredMembersAndInitializers.UninitializedSentinel); 445457"];
15606 [label="if (alreadyKnown != DeclaredMembersAndInitializers.UninitializedSentinel)\n                {\n                    diagnostics.Free();\n                    return alreadyKnown;\n                } 445458"];
15607 [label="AddDeclarationDiagnostics(diagnostics); 445459"];
15608 [label="AddDeclarationDiagnostics(diagnostics) 445460"];
15609 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445461"];
15610 [label="param AddDeclarationDiagnostics(this) 445462"];
15611 [label="ContainingSymbol 445463"];
15612 [label="get\n            {\n                return _containingSymbol;\n            } 445464"];
15613 [label="return _containingSymbol; 445465"];
15614 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445466"];
15615 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445467"];
15616 [label="AddDeclarationDiagnostics(diagnostics); 445468"];
15617 [label="diagnostics.Free(); 445469"];
15618 [label="return declaredMembersAndInitializers!; 445470"];
15619 [label="var declaredMembersAndInitializers = getDeclaredMembersAndInitializers(); 445471"];
15620 [label="if (declaredMembersAndInitializers is null)\n            {\n                // Another thread completed the work before this one\n                return null;\n            } 445472"];
15621 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 445473"];
15622 [label="var membersAndInitializersBuilder = new MembersAndInitializersBuilder(declaredMembersAndInitializers); 445474"];
15623 [label="new MembersAndInitializersBuilder(declaredMembersAndInitializers) 445475"];
15624 [label="param MembersAndInitializersBuilder(DeclaredMembersAndInitializers declaredMembersAndInitializers) 445476"];
15625 [label="param MembersAndInitializersBuilder(this) 445477"];
15626 [label="NonTypeMembers 445478"];
15627 [label="InstanceInitializersForPositionalMembers 445479"];
15628 [label="IsNullableEnabledForInstanceConstructorsAndFields 445480"];
15629 [label="IsNullableEnabledForStaticConstructorsAndFields 445481"];
15630 [label="Debug.Assert(declaredMembersAndInitializers != DeclaredMembersAndInitializers.UninitializedSentinel); 445482"];
15631 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 445483"];
15632 [label="this.IsNullableEnabledForStaticConstructorsAndFields 445484"];
15633 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 445485"];
15634 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 445486"];
15635 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 445487"];
15636 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics) 445488"];
15637 [label="param AddSynthesizedMembers(MembersAndInitializersBuilder builder) 445489"];
15638 [label="param AddSynthesizedMembers(DeclaredMembersAndInitializers declaredMembersAndInitializers) 445490"];
15639 [label="param AddSynthesizedMembers(DiagnosticBag diagnostics) 445491"];
15640 [label="param AddSynthesizedMembers(this) 445492"];
15641 [label="TypeKind 445493"];
15642 [label="get\n            {\n                return _flags.TypeKind;\n            } 445494"];
15643 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 445495"];
15644 [label="switch (TypeKind)\n            {\n                case TypeKind.Struct:\n                case TypeKind.Enum:\n                case TypeKind.Class:\n                case TypeKind.Interface:\n                case TypeKind.Submission:\n                    AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics);\n                    break;\n\n                default:\n                    break;\n            } 445496"];
15645 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445497"];
15646 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445498"];
15647 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445499"];
15648 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 445500"];
15649 [label="param AddSynthesizedRecordMembersIfNecessary(MembersAndInitializersBuilder builder) 445501"];
15650 [label="param AddSynthesizedRecordMembersIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 445502"];
15651 [label="param AddSynthesizedRecordMembersIfNecessary(DiagnosticBag diagnostics) 445503"];
15652 [label="param AddSynthesizedRecordMembersIfNecessary(this) 445504"];
15653 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 445505"];
15654 [label="return; 445506"];
15655 [label="AddSynthesizedRecordMembersIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445507"];
15656 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445508"];
15657 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445509"];
15658 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445510"];
15659 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics) 445511"];
15660 [label="param AddSynthesizedConstructorsIfNecessary(MembersAndInitializersBuilder builder) 445512"];
15661 [label="param AddSynthesizedConstructorsIfNecessary(DeclaredMembersAndInitializers declaredMembersAndInitializers) 445513"];
15662 [label="param AddSynthesizedConstructorsIfNecessary(DiagnosticBag diagnostics) 445514"];
15663 [label="param AddSynthesizedConstructorsIfNecessary(this) 445515"];
15664 [label="var hasInstanceConstructor = false; 445516"];
15665 [label="var hasParameterlessInstanceConstructor = false; 445517"];
15666 [label="var hasStaticConstructor = false; 445518"];
15667 [label="var membersSoFar = builder.GetNonTypeMembers(declaredMembersAndInitializers); 445519"];
15668 [label="builder.GetNonTypeMembers(declaredMembersAndInitializers) 445520"];
15669 [label="param GetNonTypeMembers(DeclaredMembersAndInitializers declaredMembers) 445521"];
15670 [label="param GetNonTypeMembers(this) 445522"];
15671 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 445523"];
15672 [label="return NonTypeMembers ?? (IReadOnlyCollection<Symbol>)declaredMembers.NonTypeMembers; 445524"];
15673 [label="foreach (var member in membersSoFar)\n            {\n                if (member.Kind == SymbolKind.Method)\n                {\n                    var method = (MethodSymbol)member;\n                    switch (method.MethodKind)\n                    {\n                        case MethodKind.Constructor:\n                            // Ignore the record copy constructor\n                            if (!IsRecord ||\n                                !(SynthesizedRecordCopyCtor.HasCopyConstructorSignature(method) && method is not SynthesizedRecordConstructor))\n                            {\n                                hasInstanceConstructor = true;\n                                hasParameterlessInstanceConstructor = hasParameterlessInstanceConstructor || method.ParameterCount == 0;\n                            }\n                            break;\n\n                        case MethodKind.StaticConstructor:\n                            hasStaticConstructor = true;\n                            break;\n                    }\n                }\n\n                //kick out early if we've seen everything we're looking for\n                if (hasInstanceConstructor && hasStaticConstructor)\n                {\n                    break;\n                }\n            } 445525"];
15674 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445526"];
15675 [label="this.IsStructType() 445527"];
15676 [label="param IsStructType(this TypeSymbol type) 445528"];
15677 [label="RoslynDebug.Assert((object)type != null); 445529"];
15678 [label="RoslynDebug.Assert((object)type != null); 445530"];
15679 [label="type.TypeKind 445531"];
15680 [label="get\n            {\n                return _flags.TypeKind;\n            } 445532"];
15681 [label="return type.TypeKind == TypeKind.Struct; 445533"];
15682 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445534"];
15683 [label="this.IsStatic 445535"];
15684 [label="=> HasFlag(DeclarationModifiers.Static) 445536"];
15685 [label="DeclarationModifiers.Static 445537"];
15686 [label="HasFlag(DeclarationModifiers.Static) 445538"];
15687 [label="param HasFlag(DeclarationModifiers flag) 445539"];
15688 [label="=> (_declModifiers & flag) != 0 445540"];
15689 [label="_declModifiers & flag 445541"];
15690 [label="0 445542"];
15691 [label="(_declModifiers & flag) != 0 445543"];
15692 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445544"];
15693 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445545"];
15694 [label="this.IsInterface 445546"];
15695 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 445547"];
15696 [label="this.TypeKind 445548"];
15697 [label="get\n            {\n                return _flags.TypeKind;\n            } 445549"];
15698 [label="return this.TypeKind == TypeKind.Interface; 445550"];
15699 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445551"];
15700 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445552"];
15701 [label="if ((!hasParameterlessInstanceConstructor && this.IsStructType()) ||\n                (!hasInstanceConstructor && !this.IsStatic && !this.IsInterface))\n            {\n                builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers);\n            } 445553"];
15702 [label="this.TypeKind 445554"];
15703 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 445555"];
15704 [label="(this.TypeKind == TypeKind.Submission) 445556"];
15705 [label="new SynthesizedInstanceConstructor(this) 445557"];
15706 [label="param SynthesizedInstanceConstructor(NamedTypeSymbol containingType) 445558"];
15707 [label="param SynthesizedInstanceConstructor(this) 445559"];
15708 [label="param SynthesizedInstanceConstructor(this) 445560"];
15709 [label="param SynthesizedInstanceMethodSymbol(this) 445561"];
15710 [label="param SynthesizedInstanceMethodSymbol(this) 445562"];
15711 [label="_lazyThisParameter 445563"];
15712 [label="_containingType 445564"];
15713 [label="Debug.Assert((object)containingType != null); 445565"];
15714 [label="Debug.Assert((object)containingType != null); 445566"];
15715 [label="_containingType 445567"];
15716 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 445568"];
15717 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers) 445569"];
15718 [label="param AddNonTypeMember(Symbol member) 445570"];
15719 [label="param AddNonTypeMember(DeclaredMembersAndInitializers declaredMembers) 445571"];
15720 [label="param AddNonTypeMember(this) 445572"];
15721 [label="if (NonTypeMembers is null)\n                {\n                    NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1);\n                    NonTypeMembers.AddRange(declaredMembers.NonTypeMembers);\n                } 445573"];
15722 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 445574"];
15723 [label="NonTypeMembers = ArrayBuilder<Symbol>.GetInstance(declaredMembers.NonTypeMembers.Length + 1); 445575"];
15724 [label="NonTypeMembers 445576"];
15725 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 445577"];
15726 [label="NonTypeMembers.AddRange(declaredMembers.NonTypeMembers); 445578"];
15727 [label="NonTypeMembers.Add(member); 445579"];
15728 [label="NonTypeMembers.Add(member); 445580"];
15729 [label="builder.AddNonTypeMember((this.TypeKind == TypeKind.Submission) ?\n                    new SynthesizedSubmissionConstructor(this, diagnostics) :\n                    new SynthesizedInstanceConstructor(this),\n                    declaredMembersAndInitializers); 445581"];
15730 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 445582"];
15731 [label="hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers) 445583"];
15732 [label="static bool hasNonConstantInitializer(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> initializers)\n            {\n                return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst));\n            } 445584"];
15733 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 445585"];
15734 [label="return initializers.Any(siblings => siblings.Any(initializer => !initializer.FieldOpt.IsConst)); 445586"];
15735 [label="if (!hasStaticConstructor && hasNonConstantInitializer(declaredMembersAndInitializers.StaticInitializers))\n            {\n                // Note: we don't have to put anything in the method - the binder will\n                // do that when processing field initializers.\n                builder.AddNonTypeMember(new SynthesizedStaticConstructor(this), declaredMembersAndInitializers);\n            } 445587"];
15736 [label="this.IsScriptClass 445588"];
15737 [label="get\n            {\n                var kind = this.declaration.Declarations[0].Kind;\n                return kind == DeclarationKind.Script || kind == DeclarationKind.Submission;\n            } 445589"];
15738 [label="var kind = this.declaration.Declarations[0].Kind; 445590"];
15739 [label="var kind = this.declaration.Declarations[0].Kind; 445591"];
15740 [label="return kind == DeclarationKind.Script || kind == DeclarationKind.Submission; 445592"];
15741 [label="if (this.IsScriptClass)\n            {\n                var scriptInitializer = new SynthesizedInteractiveInitializerMethod(this, diagnostics);\n                builder.AddNonTypeMember(scriptInitializer, declaredMembersAndInitializers);\n                var scriptEntryPoint = SynthesizedEntryPointSymbol.Create(scriptInitializer, diagnostics);\n                builder.AddNonTypeMember(scriptEntryPoint, declaredMembersAndInitializers);\n            } 445593"];
15742 [label="AddSynthesizedConstructorsIfNecessary(builder, declaredMembersAndInitializers, diagnostics); 445594"];
15743 [label="AddSynthesizedMembers(membersAndInitializersBuilder, declaredMembersAndInitializers, diagnostics); 445595"];
15744 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 445596"];
15745 [label="if (Volatile.Read(ref _lazyMembersAndInitializers) != null)\n            {\n                // Another thread completed the work before this one\n                membersAndInitializersBuilder.Free();\n                return null;\n            } 445597"];
15746 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 445598"];
15747 [label="membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers) 445599"];
15748 [label="param ToReadOnlyAndFree(DeclaredMembersAndInitializers declaredMembers) 445600"];
15749 [label="param ToReadOnlyAndFree(this) 445601"];
15750 [label="var nonTypeMembers = NonTypeMembers?.ToImmutableAndFree() ?? declaredMembers.NonTypeMembers; 445602"];
15751 [label="var instanceInitializers = InstanceInitializersForPositionalMembers is null\n                    ? declaredMembers.InstanceInitializers\n                    : mergeInitializers(); 445603"];
15752 [label="InstanceInitializersForPositionalMembers is null 445604"];
15753 [label="declaredMembers.InstanceInitializers 445605"];
15754 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445606"];
15755 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445607"];
15756 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445608"];
15757 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445609"];
15758 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445610"];
15759 [label="return new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields); 445611"];
15760 [label="new MembersAndInitializers(\n                    nonTypeMembers,\n                    declaredMembers.StaticInitializers,\n                    instanceInitializers,\n                    declaredMembers.HaveIndexers,\n                    isNullableEnabledForInstanceConstructorsAndFields: IsNullableEnabledForInstanceConstructorsAndFields,\n                    isNullableEnabledForStaticConstructorsAndFields: IsNullableEnabledForStaticConstructorsAndFields) 445612"];
15761 [label="param MembersAndInitializers(ImmutableArray<Symbol> nonTypeMembers) 445613"];
15762 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> staticInitializers) 445614"];
15763 [label="param MembersAndInitializers(ImmutableArray<ImmutableArray<FieldOrPropertyInitializer>> instanceInitializers) 445615"];
15764 [label="param MembersAndInitializers(bool haveIndexers) 445616"];
15765 [label="param MembersAndInitializers(bool isNullableEnabledForInstanceConstructorsAndFields) 445617"];
15766 [label="param MembersAndInitializers(bool isNullableEnabledForStaticConstructorsAndFields) 445618"];
15767 [label="param MembersAndInitializers(this) 445619"];
15768 [label="HaveIndexers 445620"];
15769 [label="IsNullableEnabledForInstanceConstructorsAndFields 445621"];
15770 [label="IsNullableEnabledForStaticConstructorsAndFields 445622"];
15771 [label="Debug.Assert(!nonTypeMembers.IsDefault); 445623"];
15772 [label="Debug.Assert(!staticInitializers.IsDefault); 445624"];
15773 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 445625"];
15774 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 445626"];
15775 [label="Debug.Assert(staticInitializers.All(g => !g.IsDefault)); 445627"];
15776 [label="Debug.Assert(!instanceInitializers.IsDefault); 445628"];
15777 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 445629"];
15778 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 445630"];
15779 [label="Debug.Assert(instanceInitializers.All(g => !g.IsDefault)); 445631"];
15780 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 445632"];
15781 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 445633"];
15782 [label="Debug.Assert(!nonTypeMembers.Any(s => s is TypeSymbol)); 445634"];
15783 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 445635"];
15784 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 445636"];
15785 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 445637"];
15786 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 445638"];
15787 [label="param IsIndexer(this Symbol symbol) 445639"];
15788 [label="symbol.Kind 445640"];
15789 [label="get\n            {\n                return SymbolKind.Method;\n            } 445641"];
15790 [label="return SymbolKind.Method; 445642"];
15791 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 445643"];
15792 [label="Debug.Assert(haveIndexers == nonTypeMembers.Any(s => s.IsIndexer())); 445644"];
15793 [label="this.NonTypeMembers 445645"];
15794 [label="this.StaticInitializers 445646"];
15795 [label="this.InstanceInitializers 445647"];
15796 [label="this.HaveIndexers 445648"];
15797 [label="this.IsNullableEnabledForInstanceConstructorsAndFields 445649"];
15798 [label="this.IsNullableEnabledForStaticConstructorsAndFields 445650"];
15799 [label="return membersAndInitializersBuilder.ToReadOnlyAndFree(declaredMembersAndInitializers); 445651"];
15800 [label="membersAndInitializers = BuildMembersAndInitializers(diagnostics); 445652"];
15801 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 445653"];
15802 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 445654"];
15803 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 445655"];
15804 [label="var alreadyKnown = Interlocked.CompareExchange(ref _lazyMembersAndInitializers, membersAndInitializers, null); 445656"];
15805 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 445657"];
15806 [label="if (alreadyKnown != null)\n            {\n                diagnostics.Free();\n                return alreadyKnown;\n            } 445658"];
15807 [label="AddDeclarationDiagnostics(diagnostics); 445659"];
15808 [label="AddDeclarationDiagnostics(diagnostics) 445660"];
15809 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445661"];
15810 [label="param AddDeclarationDiagnostics(this) 445662"];
15811 [label="ContainingSymbol 445663"];
15812 [label="get\n            {\n                return _containingSymbol;\n            } 445664"];
15813 [label="return _containingSymbol; 445665"];
15814 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445666"];
15815 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445667"];
15816 [label="AddDeclarationDiagnostics(diagnostics); 445668"];
15817 [label="diagnostics.Free(); 445669"];
15818 [label="_lazyDeclaredMembersAndInitializers = null; 445670"];
15819 [label="_lazyDeclaredMembersAndInitializers 445671"];
15820 [label="return membersAndInitializers!; 445672"];
15821 [label="var membersAndInitializers = GetMembersAndInitializers(); 445673"];
15822 [label="this.IsTupleType 445674"];
15823 [label="=> IsTupleTypeOfCardinality(tupleCardinality: out _) 445675"];
15824 [label="_ 445676"];
15825 [label="tupleCardinality: out _ 445677"];
15826 [label="IsTupleTypeOfCardinality(tupleCardinality: out _) 445678"];
15827 [label="param IsTupleTypeOfCardinality(out int tupleCardinality) 445679"];
15828 [label="param IsTupleTypeOfCardinality(this) 445680"];
15829 [label="IsUnboundGenericType 445681"];
15830 [label="get\n            {\n                return false;\n            } 445682"];
15831 [label="return false; 445683"];
15832 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445684"];
15833 [label="ContainingSymbol 445685"];
15834 [label="get\n            {\n                return _containingSymbol;\n            } 445686"];
15835 [label="return _containingSymbol; 445687"];
15836 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445688"];
15837 [label=".Kind 445689"];
15838 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 445690"];
15839 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445691"];
15840 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445692"];
15841 [label="ContainingNamespace 445693"];
15842 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445694"];
15843 [label="return _containingSymbol; 445695"];
15844 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445696"];
15845 [label="ContainingNamespace.ContainingNamespace 445697"];
15846 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445698"];
15847 [label="=> _container 445699"];
15848 [label="_container 445700"];
15849 [label=".IsGlobalNamespace 445701"];
15850 [label="get\n            {\n                return (object)ContainingNamespace == null;\n            } 445702"];
15851 [label="ContainingNamespace 445703"];
15852 [label="get\n            {\n                for (var container = this.ContainingSymbol; (object)container != null; container = container.ContainingSymbol)\n                {\n                    var ns = container as NamespaceSymbol;\n                    if ((object)ns != null)\n                    {\n                        return ns;\n                    }\n                }\n\n                return null;\n            } 445704"];
15853 [label="container.ContainingSymbol 445705"];
15854 [label="get\n            {\n                return _assemblySymbol;\n            } 445706"];
15855 [label="return _assemblySymbol; 445707"];
15856 [label="get\n            {\n                return null;\n            } 445708"];
15857 [label="return null; 445709"];
15858 [label="return (object)ContainingNamespace == null; 445710"];
15859 [label="return (object)ContainingNamespace == null; 445711"];
15860 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445712"];
15861 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445713"];
15862 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445714"];
15863 [label="Name 445715"];
15864 [label="get\n            {\n                return declaration.Name;\n            } 445716"];
15865 [label="return declaration.Name; 445717"];
15866 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445718"];
15867 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445719"];
15868 [label="if (!IsUnboundGenericType &&\n                ContainingSymbol?.Kind == SymbolKind.Namespace &&\n                ContainingNamespace.ContainingNamespace?.IsGlobalNamespace == true &&\n                Name == ValueTupleTypeName &&\n                ContainingNamespace.Name == MetadataHelpers.SystemString)\n            {\n                int arity = Arity;\n\n                if (arity >= 0 && arity < ValueTupleRestPosition)\n                {\n                    tupleCardinality = arity;\n                    return true;\n                }\n                else if (arity == ValueTupleRestPosition && !IsDefinition)\n                {\n                    // Skip through 'Rest' extensions\n                    TypeSymbol typeToCheck = this;\n                    int levelsOfNesting = 0;\n\n                    do\n                    {\n                        levelsOfNesting++;\n                        typeToCheck = ((NamedTypeSymbol)typeToCheck).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics[ValueTupleRestPosition - 1].Type;\n                    }\n                    while (Equals(typeToCheck.OriginalDefinition, this.OriginalDefinition, TypeCompareKind.ConsiderEverything) && !typeToCheck.IsDefinition);\n\n                    arity = typeToCheck is NamedTypeSymbol ? ((NamedTypeSymbol)typeToCheck).Arity : 0;\n\n                    if (arity > 0 && arity < ValueTupleRestPosition && ((NamedTypeSymbol)typeToCheck).IsTupleTypeOfCardinality(out tupleCardinality))\n                    {\n                        Debug.Assert(tupleCardinality < ValueTupleRestPosition);\n                        tupleCardinality += (ValueTupleRestPosition - 1) * levelsOfNesting;\n                        return true;\n                    }\n                }\n            } 445720"];
15869 [label="tupleCardinality = 0; 445721"];
15870 [label="return false; 445722"];
15871 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 445723"];
15872 [label="if (!membersAndInitializers.HaveIndexers && !this.IsTupleType && _lazyEarlyAttributeDecodingMembersDictionary is object)\n            {\n                membersByName = _lazyEarlyAttributeDecodingMembersDictionary;\n            }\n            else\n            {\n                membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance);\n\n                // Merge types into the member dictionary\n                AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary());\n            } 445724"];
15873 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 445725"];
15874 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 445726"];
15875 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 445727"];
15876 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 445728"];
15877 [label="get { return WellKnownMemberNames.InstanceConstructorName; } 445729"];
15878 [label="return WellKnownMemberNames.InstanceConstructorName; 445730"];
15879 [label="membersByName = membersAndInitializers.NonTypeMembers.ToDictionary(s => s.Name, StringOrdinalComparer.Instance); 445731"];
15880 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 445732"];
15881 [label="GetTypeMembersDictionary() 445733"];
15882 [label="param GetTypeMembersDictionary(this) 445734"];
15883 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 445735"];
15884 [label="if (_lazyTypeMembers == null)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                }\n\n                diagnostics.Free();\n            } 445736"];
15885 [label="var diagnostics = DiagnosticBag.GetInstance(); 445737"];
15886 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 445738"];
15887 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 445739"];
15888 [label="MakeTypeMembers(diagnostics) 445740"];
15889 [label="param MakeTypeMembers(DiagnosticBag diagnostics) 445741"];
15890 [label="param MakeTypeMembers(this) 445742"];
15891 [label="var symbols = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 445743"];
15892 [label="var conflictDict = new Dictionary<(string, int), SourceNamedTypeSymbol>(); 445744"];
15893 [label="foreach (var childDeclaration in declaration.Children)\n                {\n                    var t = new SourceNamedTypeSymbol(this, childDeclaration, diagnostics);\n                    this.CheckMemberNameDistinctFromType(t, diagnostics);\n\n                    var key = (t.Name, t.Arity);\n                    SourceNamedTypeSymbol? other;\n                    if (conflictDict.TryGetValue(key, out other))\n                    {\n                        if (Locations.Length == 1 || IsPartial)\n                        {\n                            if (t.IsPartial && other.IsPartial)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_PartialTypeKindConflict, t.Locations[0], t);\n                            }\n                            else\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, t.Locations[0], this, t.Name);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        conflictDict.Add(key, t);\n                    }\n\n                    symbols.Add(t);\n                } 445745"];
15894 [label="IsInterface 445746"];
15895 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 445747"];
15896 [label="if (IsInterface)\n                {\n                    foreach (var t in symbols)\n                    {\n                        Binder.CheckFeatureAvailability(t.DeclaringSyntaxReferences[0].GetSyntax(), MessageID.IDS_DefaultInterfaceImplementation, diagnostics, t.Locations[0]);\n                    }\n                } 445748"];
15897 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 445749"];
15898 [label="Debug.Assert(s_emptyTypeMembers.Count == 0); 445750"];
15899 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 445751"];
15900 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 445752"];
15901 [label="symbols.Count > 0 445753"];
15902 [label="return symbols.Count > 0 ?\n                    symbols.ToDictionary(s => s.Name, StringOrdinalComparer.Instance) :\n                    s_emptyTypeMembers; 445754"];
15903 [label="symbols.Free(); 445755"];
15904 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 445756"];
15905 [label="if (Interlocked.CompareExchange(ref _lazyTypeMembers, MakeTypeMembers(diagnostics), null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n\n                    state.NotePartComplete(CompletionPart.TypeMembers);\n                } 445757"];
15906 [label="AddDeclarationDiagnostics(diagnostics); 445758"];
15907 [label="AddDeclarationDiagnostics(diagnostics) 445759"];
15908 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445760"];
15909 [label="param AddDeclarationDiagnostics(this) 445761"];
15910 [label="ContainingSymbol 445762"];
15911 [label="get\n            {\n                return _containingSymbol;\n            } 445763"];
15912 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445764"];
15913 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445765"];
15914 [label="AddDeclarationDiagnostics(diagnostics); 445766"];
15915 [label="state.NotePartComplete(CompletionPart.TypeMembers); 445767"];
15916 [label="state.NotePartComplete(CompletionPart.TypeMembers) 445768"];
15917 [label="param NotePartComplete(CompletionPart part) 445769"];
15918 [label="diagnostics.Free(); 445770"];
15919 [label="return _lazyTypeMembers; 445771"];
15920 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 445772"];
15921 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()) 445773"];
15922 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<Symbol>> membersByName) 445774"];
15923 [label="param AddNestedTypesToDictionary(Dictionary<string, ImmutableArray<NamedTypeSymbol>> typesByName) 445775"];
15924 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 445776"];
15925 [label="foreach (var pair in typesByName)\n            {\n                string name = pair.Key;\n                ImmutableArray<NamedTypeSymbol> types = pair.Value;\n                ImmutableArray<Symbol> typesAsSymbols = StaticCast<Symbol>.From(types);\n\n                ImmutableArray<Symbol> membersForName;\n                if (membersByName.TryGetValue(name, out membersForName))\n                {\n                    membersByName[name] = membersForName.Concat(typesAsSymbols);\n                }\n                else\n                {\n                    membersByName.Add(name, typesAsSymbols);\n                }\n            } 445777"];
15926 [label="AddNestedTypesToDictionary(membersByName, GetTypeMembersDictionary()); 445778"];
15927 [label="MergePartialMembers(ref membersByName, diagnostics); 445779"];
15928 [label="MergePartialMembers(ref membersByName, diagnostics); 445780"];
15929 [label="MergePartialMembers(ref membersByName, diagnostics) 445781"];
15930 [label="param MergePartialMembers(ref Dictionary<string, ImmutableArray<Symbol>> membersByName) 445782"];
15931 [label="param MergePartialMembers(DiagnosticBag diagnostics) 445783"];
15932 [label="param MergePartialMembers(this) 445784"];
15933 [label="var memberNames = ArrayBuilder<string>.GetInstance(membersByName.Count); 445785"];
15934 [label="memberNames.AddRange(membersByName.Keys); 445786"];
15935 [label="memberNames.AddRange(membersByName.Keys); 445787"];
15936 [label="var methodsBySignature = new Dictionary<MethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.PartialMethodsComparer); 445788"];
15937 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 445789"];
15938 [label="foreach (var name in memberNames)\n            {\n                methodsBySignature.Clear();\n                foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                }\n\n                foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                }\n            } 445790"];
15939 [label="methodsBySignature.Clear(); 445791"];
15940 [label="foreach (var symbol in membersByName[name])\n                {\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    }\n\n                    if (methodsBySignature.TryGetValue(method, out var prev))\n                    {\n                        var prevPart = (SourceOrdinaryMethodSymbol)prev;\n                        var methodPart = (SourceOrdinaryMethodSymbol)method;\n\n                        if (methodPart.IsPartialImplementation &&\n                            (prevPart.IsPartialImplementation || (prevPart.OtherPartOfPartial is MethodSymbol otherImplementation && (object)otherImplementation != methodPart)))\n                        {\n                            // A partial method may not have multiple implementing declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneActual, methodPart.Locations[0]);\n                        }\n                        else if (methodPart.IsPartialDefinition &&\n                                 (prevPart.IsPartialDefinition || (prevPart.OtherPartOfPartial is MethodSymbol otherDefinition && (object)otherDefinition != methodPart)))\n                        {\n                            // A partial method may not have multiple defining declarations\n                            diagnostics.Add(ErrorCode.ERR_PartialMethodOnlyOneLatent, methodPart.Locations[0]);\n                        }\n                        else\n                        {\n                            if ((object)membersByName == _lazyEarlyAttributeDecodingMembersDictionary)\n                            {\n                                // Avoid mutating the cached dictionary and especially avoid doing this possibly on multiple threads in parallel.\n                                membersByName = new Dictionary<string, ImmutableArray<Symbol>>(membersByName);\n                            }\n\n                            membersByName[name] = FixPartialMember(membersByName[name], prevPart, methodPart);\n                        }\n                    }\n                    else\n                    {\n                        methodsBySignature.Add(method, method);\n                    }\n                } 445792"];
15941 [label="var method = symbol as SourceMemberMethodSymbol; 445793"];
15942 [label="if (method is null || !method.IsPartial)\n                    {\n                        continue; // only partial methods need to be merged\n                    } 445794"];
15943 [label="foreach (SourceOrdinaryMethodSymbol method in methodsBySignature.Values)\n                {\n                    // partial implementations not paired with a definition\n                    if (method.IsPartialImplementation && method.OtherPartOfPartial is null)\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodMustHaveLatent, method.Locations[0], method);\n                    }\n                    else if (method.OtherPartOfPartial is MethodSymbol otherPart && MemberSignatureComparer.ConsideringTupleNamesCreatesDifference(method, otherPart))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodInconsistentTupleNames, method.Locations[0], method, method.OtherPartOfPartial);\n                    }\n                    else if (method is { IsPartialDefinition: true, OtherPartOfPartial: null, HasExplicitAccessModifier: true })\n                    {\n                        diagnostics.Add(ErrorCode.ERR_PartialMethodWithAccessibilityModsMustHaveImplementation, method.Locations[0], method);\n                    }\n                } 445795"];
15944 [label="memberNames.Free(); 445796"];
15945 [label="MergePartialMembers(ref membersByName, diagnostics); 445797"];
15946 [label="return membersByName; 445798"];
15947 [label="var membersDictionary = MakeAllMembers(diagnostics); 445799"];
15948 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 445800"];
15949 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 445801"];
15950 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 445802"];
15951 [label="if (Interlocked.CompareExchange(ref _lazyMembersDictionary, membersDictionary, null) == null)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                    state.NotePartComplete(CompletionPart.Members);\n                } 445803"];
15952 [label="AddDeclarationDiagnostics(diagnostics); 445804"];
15953 [label="AddDeclarationDiagnostics(diagnostics) 445805"];
15954 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 445806"];
15955 [label="param AddDeclarationDiagnostics(this) 445807"];
15956 [label="ContainingSymbol 445808"];
15957 [label="get\n            {\n                return _containingSymbol;\n            } 445809"];
15958 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 445810"];
15959 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 445811"];
15960 [label="AddDeclarationDiagnostics(diagnostics); 445812"];
15961 [label="state.NotePartComplete(CompletionPart.Members); 445813"];
15962 [label="state.NotePartComplete(CompletionPart.Members) 445814"];
15963 [label="param NotePartComplete(CompletionPart part) 445815"];
15964 [label="diagnostics.Free(); 445816"];
15965 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 445817"];
15966 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)); 445818"];
15967 [label="state.SpinWaitComplete(CompletionPart.Members, default(CancellationToken)) 445819"];
15968 [label="param SpinWaitComplete(CompletionPart part) 445820"];
15969 [label="param SpinWaitComplete(CancellationToken cancellationToken) 445821"];
15970 [label="param SpinWaitComplete(this) 445822"];
15971 [label="if (HasComplete(part))\n            {\n                return;\n            } 445823"];
15972 [label="HasComplete(part) 445824"];
15973 [label="param HasComplete(CompletionPart part) 445825"];
15974 [label="param HasComplete(this) 445826"];
15975 [label="return (_completeParts & (int)part) == (int)part; 445827"];
15976 [label="return; 445828"];
15977 [label="return _lazyMembersDictionary; 445829"];
15978 [label="return GetMembersByNameSlow(); 445830"];
15979 [label="this.GetMembersByName(); 445831"];
15980 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 445832"];
15981 [label="param SpinWaitComplete(CompletionPart part) 445833"];
15982 [label="param SpinWaitComplete(this) 445834"];
15983 [label="if (HasComplete(part))\n            {\n                return;\n            } 445835"];
15984 [label="param HasComplete(CompletionPart part) 445836"];
15985 [label="param HasComplete(this) 445837"];
15986 [label="return (_completeParts & (int)part) == (int)part; 445838"];
15987 [label="return; 445839"];
15988 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 445840"];
15989 [label="param HasAtMostOneBitSet(int bits) 445841"];
15990 [label="return (bits & (bits - 1)) == 0; 445842"];
15991 [label="this.GetSynthesizedExplicitImplementations(cancellationToken); 445843"];
15992 [label="this.GetSynthesizedExplicitImplementations(cancellationToken) 445844"];
15993 [label="param GetSynthesizedExplicitImplementations(CancellationToken cancellationToken) 445845"];
15994 [label="param GetSynthesizedExplicitImplementations(this) 445846"];
15995 [label="if (_lazySynthesizedExplicitImplementations.IsDefault)\n            {\n                var diagnostics = DiagnosticBag.GetInstance();\n                try\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckMembersAgainstBaseType(diagnostics, cancellationToken);\n\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckAbstractClassImplementations(diagnostics);\n\n                    cancellationToken.ThrowIfCancellationRequested();\n                    CheckInterfaceUnification(diagnostics);\n\n                    if (this.IsInterface)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        this.CheckInterfaceVarianceSafety(diagnostics);\n                    }\n\n                    if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    }\n                }\n                finally\n                {\n                    diagnostics.Free();\n                }\n            } 445847"];
15996 [label="var diagnostics = DiagnosticBag.GetInstance(); 445848"];
15997 [label="cancellationToken.ThrowIfCancellationRequested(); 445849"];
15998 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 445850"];
15999 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 445851"];
16000 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken) 445852"];
16001 [label="param CheckMembersAgainstBaseType(DiagnosticBag diagnostics) 445853"];
16002 [label="param CheckMembersAgainstBaseType(CancellationToken cancellationToken) 445854"];
16003 [label="param CheckMembersAgainstBaseType(this) 445855"];
16004 [label="this.TypeKind 445856"];
16005 [label="get\n            {\n                return _flags.TypeKind;\n            } 445857"];
16006 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 445858"];
16007 [label="switch (this.TypeKind)\n            {\n                // These checks don't make sense for enums and delegates:\n                case TypeKind.Enum:\n                case TypeKind.Delegate:\n                    return;\n\n                case TypeKind.Class:\n                case TypeKind.Struct:\n                case TypeKind.Interface:\n                case TypeKind.Submission: // we have to check that 'override' is not used\n                    break;\n\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(this.TypeKind);\n            } 445859"];
16008 [label="this.GetMembersUnordered() 445860"];
16009 [label="param GetMembersUnordered(this) 445861"];
16010 [label="var result = _lazyMembersFlattened; 445862"];
16011 [label="if (result.IsDefault)\n            {\n                result = GetMembersByName().Flatten(null);  // do not sort.\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result);\n                result = _lazyMembersFlattened;\n            } 445863"];
16012 [label="GetMembersByName() 445864"];
16013 [label="if (this.state.HasComplete(CompletionPart.Members))\n            {\n                return _lazyMembersDictionary!;\n            } 445865"];
16014 [label="this.state.HasComplete(CompletionPart.Members) 445866"];
16015 [label="param HasComplete(CompletionPart part) 445867"];
16016 [label="param HasComplete(this) 445868"];
16017 [label="return (_completeParts & (int)part) == (int)part; 445869"];
16018 [label="return _lazyMembersDictionary!; 445870"];
16019 [label="result = GetMembersByName().Flatten(null); 445871"];
16020 [label="result = GetMembersByName().Flatten(null); 445872"];
16021 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 445873"];
16022 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyMembersFlattened, result); 445874"];
16023 [label="result = _lazyMembersFlattened; 445875"];
16024 [label="return result.ConditionallyDeOrder(); 445876"];
16025 [label="foreach (var member in this.GetMembersUnordered())\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n\n                bool suppressAccessors;\n                switch (member.Kind)\n                {\n                    case SymbolKind.Method:\n                        var method = (MethodSymbol)member;\n                        if (MethodSymbol.CanOverrideOrHide(method.MethodKind) && !method.IsAccessor())\n                        {\n                            if (member.IsOverride)\n                            {\n                                CheckOverrideMember(method, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                            }\n                            else\n                            {\n                                var sourceMethod = method as SourceMemberMethodSymbol;\n                                if ((object)sourceMethod != null) // skip submission initializer\n                                {\n                                    var isNew = sourceMethod.IsNew;\n                                    CheckNonOverrideMember(method, isNew, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (method.MethodKind == MethodKind.Destructor)\n                        {\n                            // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.\n\n                            // First is fine, since there should only be one, since there are no parameters.\n                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(out _);\n\n                            // NOTE: Dev11 doesn't expose symbols, so it can treat destructors as override and let them go through the normal\n                            // checks.  Roslyn can't, since the language says they are not virtual/override and that's what we need to expose\n                            // in the symbol model.  Having said that, Dev11 doesn't seem to produce override errors other than this one\n                            // (see SymbolPreparer::prepareOperator).\n                            if ((object)overridden != null && overridden.IsMetadataFinal)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_CantOverrideSealed, method.Locations[0], method, overridden);\n                            }\n                        }\n                        break;\n                    case SymbolKind.Property:\n                        var property = (PropertySymbol)member;\n                        var getMethod = property.GetMethod;\n                        var setMethod = property.SetMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding property.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(property, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckOverrideMember(getMethod, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckOverrideMember(setMethod, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (property is SourcePropertySymbolBase sourceProperty)\n                        {\n                            var isNewProperty = sourceProperty.IsNew;\n                            CheckNonOverrideMember(property, isNewProperty, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckNonOverrideMember(getMethod, isNewProperty, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckNonOverrideMember(setMethod, isNewProperty, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Event:\n                        var @event = (EventSymbol)member;\n                        var addMethod = @event.AddMethod;\n                        var removeMethod = @event.RemoveMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding event.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(@event, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckOverrideMember(addMethod, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckOverrideMember(removeMethod, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            var isNewEvent = ((SourceEventSymbol)@event).IsNew;\n                            CheckNonOverrideMember(@event, isNewEvent, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckNonOverrideMember(addMethod, isNewEvent, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckNonOverrideMember(removeMethod, isNewEvent, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        var sourceField = member as SourceFieldSymbol;\n                        var isNewField = (object)sourceField != null && sourceField.IsNew;\n\n                        // We don't want to report diagnostics for field-like event backing fields (redundant),\n                        // but that shouldn't be an issue since they shouldn't be in the member list.\n                        Debug.Assert((object)sourceField == null || (object)sourceField.AssociatedSymbol == null ||\n                            sourceField.AssociatedSymbol.Kind != SymbolKind.Event);\n\n                        CheckNewModifier(member, isNewField, diagnostics);\n                        break;\n                    case SymbolKind.NamedType:\n                        CheckNewModifier(member, ((SourceMemberContainerTypeSymbol)member).IsNew, diagnostics);\n                        break;\n                }\n            } 445877"];
16026 [label="cancellationToken.ThrowIfCancellationRequested(); 445878"];
16027 [label="bool suppressAccessors; 445879"];
16028 [label="member.Kind 445880"];
16029 [label="get\n            {\n                return SymbolKind.Method;\n            } 445881"];
16030 [label="return SymbolKind.Method; 445882"];
16031 [label="switch (member.Kind)\n                {\n                    case SymbolKind.Method:\n                        var method = (MethodSymbol)member;\n                        if (MethodSymbol.CanOverrideOrHide(method.MethodKind) && !method.IsAccessor())\n                        {\n                            if (member.IsOverride)\n                            {\n                                CheckOverrideMember(method, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                            }\n                            else\n                            {\n                                var sourceMethod = method as SourceMemberMethodSymbol;\n                                if ((object)sourceMethod != null) // skip submission initializer\n                                {\n                                    var isNew = sourceMethod.IsNew;\n                                    CheckNonOverrideMember(method, isNew, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (method.MethodKind == MethodKind.Destructor)\n                        {\n                            // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.\n\n                            // First is fine, since there should only be one, since there are no parameters.\n                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(out _);\n\n                            // NOTE: Dev11 doesn't expose symbols, so it can treat destructors as override and let them go through the normal\n                            // checks.  Roslyn can't, since the language says they are not virtual/override and that's what we need to expose\n                            // in the symbol model.  Having said that, Dev11 doesn't seem to produce override errors other than this one\n                            // (see SymbolPreparer::prepareOperator).\n                            if ((object)overridden != null && overridden.IsMetadataFinal)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_CantOverrideSealed, method.Locations[0], method, overridden);\n                            }\n                        }\n                        break;\n                    case SymbolKind.Property:\n                        var property = (PropertySymbol)member;\n                        var getMethod = property.GetMethod;\n                        var setMethod = property.SetMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding property.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(property, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckOverrideMember(getMethod, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckOverrideMember(setMethod, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (property is SourcePropertySymbolBase sourceProperty)\n                        {\n                            var isNewProperty = sourceProperty.IsNew;\n                            CheckNonOverrideMember(property, isNewProperty, property.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)getMethod != null)\n                                {\n                                    CheckNonOverrideMember(getMethod, isNewProperty, getMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)setMethod != null)\n                                {\n                                    CheckNonOverrideMember(setMethod, isNewProperty, setMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Event:\n                        var @event = (EventSymbol)member;\n                        var addMethod = @event.AddMethod;\n                        var removeMethod = @event.RemoveMethod;\n\n                        // Handle the accessors here, instead of in the loop, so that we can ensure that\n                        // they're checked *after* the corresponding event.\n                        if (member.IsOverride)\n                        {\n                            CheckOverrideMember(@event, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckOverrideMember(addMethod, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckOverrideMember(removeMethod, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            var isNewEvent = ((SourceEventSymbol)@event).IsNew;\n                            CheckNonOverrideMember(@event, isNewEvent, @event.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n\n                            if (!suppressAccessors)\n                            {\n                                if ((object)addMethod != null)\n                                {\n                                    CheckNonOverrideMember(addMethod, isNewEvent, addMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                                if ((object)removeMethod != null)\n                                {\n                                    CheckNonOverrideMember(removeMethod, isNewEvent, removeMethod.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        break;\n                    case SymbolKind.Field:\n                        var sourceField = member as SourceFieldSymbol;\n                        var isNewField = (object)sourceField != null && sourceField.IsNew;\n\n                        // We don't want to report diagnostics for field-like event backing fields (redundant),\n                        // but that shouldn't be an issue since they shouldn't be in the member list.\n                        Debug.Assert((object)sourceField == null || (object)sourceField.AssociatedSymbol == null ||\n                            sourceField.AssociatedSymbol.Kind != SymbolKind.Event);\n\n                        CheckNewModifier(member, isNewField, diagnostics);\n                        break;\n                    case SymbolKind.NamedType:\n                        CheckNewModifier(member, ((SourceMemberContainerTypeSymbol)member).IsNew, diagnostics);\n                        break;\n                } 445883"];
16032 [label="var method = (MethodSymbol)member; 445884"];
16033 [label="method.MethodKind 445885"];
16034 [label="get { return MethodKind.Constructor; } 445886"];
16035 [label="return MethodKind.Constructor; 445887"];
16036 [label="if (MethodSymbol.CanOverrideOrHide(method.MethodKind) && !method.IsAccessor())\n                        {\n                            if (member.IsOverride)\n                            {\n                                CheckOverrideMember(method, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                            }\n                            else\n                            {\n                                var sourceMethod = method as SourceMemberMethodSymbol;\n                                if ((object)sourceMethod != null) // skip submission initializer\n                                {\n                                    var isNew = sourceMethod.IsNew;\n                                    CheckNonOverrideMember(method, isNew, method.OverriddenOrHiddenMembers, diagnostics, out suppressAccessors);\n                                }\n                            }\n                        }\n                        else if (method.MethodKind == MethodKind.Destructor)\n                        {\n                            // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.\n\n                            // First is fine, since there should only be one, since there are no parameters.\n                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(out _);\n\n                            // NOTE: Dev11 doesn't expose symbols, so it can treat destructors as override and let them go through the normal\n                            // checks.  Roslyn can't, since the language says they are not virtual/override and that's what we need to expose\n                            // in the symbol model.  Having said that, Dev11 doesn't seem to produce override errors other than this one\n                            // (see SymbolPreparer::prepareOperator).\n                            if ((object)overridden != null && overridden.IsMetadataFinal)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_CantOverrideSealed, method.Locations[0], method, overridden);\n                            }\n                        } 445888"];
16037 [label="MethodSymbol.CanOverrideOrHide(method.MethodKind) 445889"];
16038 [label="param CanOverrideOrHide(MethodKind kind) 445890"];
16039 [label="switch (kind)\n            {\n                case MethodKind.AnonymousFunction:\n                case MethodKind.Constructor:\n                case MethodKind.Destructor:\n                case MethodKind.ExplicitInterfaceImplementation:\n                case MethodKind.StaticConstructor:\n                case MethodKind.ReducedExtension:\n                    return false;\n                case MethodKind.Conversion:\n                case MethodKind.DelegateInvoke:\n                case MethodKind.EventAdd:\n                case MethodKind.EventRemove:\n                case MethodKind.LocalFunction:\n                case MethodKind.UserDefinedOperator:\n                case MethodKind.Ordinary:\n                case MethodKind.PropertyGet:\n                case MethodKind.PropertySet:\n                    return true;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(kind);\n            } 445891"];
16040 [label="return false; 445892"];
16041 [label="method.MethodKind 445893"];
16042 [label="get { return MethodKind.Constructor; } 445894"];
16043 [label="if (method.MethodKind == MethodKind.Destructor)\n                        {\n                            // NOTE: Normal finalize methods CanOverrideOrHide and will go through the normal code path.\n\n                            // First is fine, since there should only be one, since there are no parameters.\n                            MethodSymbol overridden = method.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(out _);\n\n                            // NOTE: Dev11 doesn't expose symbols, so it can treat destructors as override and let them go through the normal\n                            // checks.  Roslyn can't, since the language says they are not virtual/override and that's what we need to expose\n                            // in the symbol model.  Having said that, Dev11 doesn't seem to produce override errors other than this one\n                            // (see SymbolPreparer::prepareOperator).\n                            if ((object)overridden != null && overridden.IsMetadataFinal)\n                            {\n                                diagnostics.Add(ErrorCode.ERR_CantOverrideSealed, method.Locations[0], method, overridden);\n                            }\n                        } 445895"];
16044 [label="CheckMembersAgainstBaseType(diagnostics, cancellationToken); 445896"];
16045 [label="cancellationToken.ThrowIfCancellationRequested(); 445897"];
16046 [label="CheckAbstractClassImplementations(diagnostics); 445898"];
16047 [label="CheckAbstractClassImplementations(diagnostics) 445899"];
16048 [label="param CheckAbstractClassImplementations(DiagnosticBag diagnostics) 445900"];
16049 [label="param CheckAbstractClassImplementations(this) 445901"];
16050 [label="this.BaseTypeNoUseSiteDiagnostics 445902"];
16051 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 445903"];
16052 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 445904"];
16053 [label="return _lazyBaseType; 445905"];
16054 [label="NamedTypeSymbol baseType = this.BaseTypeNoUseSiteDiagnostics; 445906"];
16055 [label="this.IsAbstract 445907"];
16056 [label="=> HasFlag(DeclarationModifiers.Abstract) 445908"];
16057 [label="DeclarationModifiers.Abstract 445909"];
16058 [label="HasFlag(DeclarationModifiers.Abstract) 445910"];
16059 [label="param HasFlag(DeclarationModifiers flag) 445911"];
16060 [label="=> (_declModifiers & flag) != 0 445912"];
16061 [label="_declModifiers & flag 445913"];
16062 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445914"];
16063 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445915"];
16064 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445916"];
16065 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445917"];
16066 [label="baseType.IsAbstract 445918"];
16067 [label="get\n            {\n                return\n                    (_flags & TypeAttributes.Abstract) != 0 &&\n                    (_flags & TypeAttributes.Sealed) == 0;\n            } 445919"];
16068 [label="return\n                    (_flags & TypeAttributes.Abstract) != 0 &&\n                    (_flags & TypeAttributes.Sealed) == 0; 445920"];
16069 [label="return\n                    (_flags & TypeAttributes.Abstract) != 0 &&\n                    (_flags & TypeAttributes.Sealed) == 0; 445921"];
16070 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445922"];
16071 [label="if (this.IsAbstract || (object)baseType == null || !baseType.IsAbstract)\n            {\n                return;\n            } 445923"];
16072 [label="return; 445924"];
16073 [label="CheckAbstractClassImplementations(diagnostics); 445925"];
16074 [label="cancellationToken.ThrowIfCancellationRequested(); 445926"];
16075 [label="CheckInterfaceUnification(diagnostics); 445927"];
16076 [label="CheckInterfaceUnification(diagnostics) 445928"];
16077 [label="param CheckInterfaceUnification(DiagnosticBag diagnostics) 445929"];
16078 [label="param CheckInterfaceUnification(this) 445930"];
16079 [label="this.IsGenericType 445931"];
16080 [label="get\n            {\n                for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            } 445932"];
16081 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 445933"];
16082 [label="return _lazyTypeParameters; 445934"];
16083 [label="return GetTypeParametersAsTypeArguments(); 445935"];
16084 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 445936"];
16085 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 445937"];
16086 [label="current.ContainingType 445938"];
16087 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 445939"];
16088 [label="return _containingSymbol as NamedTypeSymbol; 445940"];
16089 [label="return false; 445941"];
16090 [label="if (!this.IsGenericType)\n            {\n                return;\n            } 445942"];
16091 [label="return; 445943"];
16092 [label="CheckInterfaceUnification(diagnostics); 445944"];
16093 [label="this.IsInterface 445945"];
16094 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 445946"];
16095 [label="if (this.IsInterface)\n                    {\n                        cancellationToken.ThrowIfCancellationRequested();\n                        this.CheckInterfaceVarianceSafety(diagnostics);\n                    } 445947"];
16096 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445948"];
16097 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445949"];
16098 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445950"];
16099 [label="ComputeInterfaceImplementations(diagnostics, cancellationToken) 445951"];
16100 [label="param ComputeInterfaceImplementations(DiagnosticBag diagnostics) 445952"];
16101 [label="param ComputeInterfaceImplementations(CancellationToken cancellationToken) 445953"];
16102 [label="param ComputeInterfaceImplementations(this) 445954"];
16103 [label="var synthesizedImplementations = ArrayBuilder<SynthesizedExplicitImplementationForwardingMethod>.GetInstance(); 445955"];
16104 [label="this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics 445956"];
16105 [label="get\n            {\n                var info = this.GetInterfaceInfo();\n                if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                }\n\n                if (info.interfacesAndTheirBaseInterfaces == null)\n                {\n                    Interlocked.CompareExchange(ref info.interfacesAndTheirBaseInterfaces, MakeInterfacesAndTheirBaseInterfaces(this.InterfacesNoUseSiteDiagnostics()), null);\n                }\n\n                return info.interfacesAndTheirBaseInterfaces;\n            } 445957"];
16106 [label="var info = _lazyInterfaceInfo; 445958"];
16107 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445959"];
16108 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445960"];
16109 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445961"];
16110 [label="info.IsDefaultValue() 445962"];
16111 [label="param IsDefaultValue(this) 445963"];
16112 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 445964"];
16113 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 445965"];
16114 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445966"];
16115 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445967"];
16116 [label="return info; 445968"];
16117 [label="var info = this.GetInterfaceInfo(); 445969"];
16118 [label="if (info == s_noInterfaces)\n                {\n                    Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty);\n                    return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces;\n                } 445970"];
16119 [label="Debug.Assert(InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces.IsEmpty); 445971"];
16120 [label="return InterfaceInfo.EmptyInterfacesAndTheirBaseInterfaces; 445972"];
16121 [label="MultiDictionary<NamedTypeSymbol, NamedTypeSymbol> interfacesAndTheirBases = this.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics; 445973"];
16122 [label="this.AllInterfacesNoUseSiteDiagnostics 445974"];
16123 [label="get\n            {\n                return GetAllInterfaces();\n            } 445975"];
16124 [label="GetAllInterfaces() 445976"];
16125 [label="param GetAllInterfaces(this) 445977"];
16126 [label="this.GetInterfaceInfo() 445978"];
16127 [label="param GetInterfaceInfo(this) 445979"];
16128 [label="var info = _lazyInterfaceInfo; 445980"];
16129 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445981"];
16130 [label="if (info != null)\n            {\n                Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified');\n                return info;\n            } 445982"];
16131 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445983"];
16132 [label="info.IsDefaultValue() 445984"];
16133 [label="param IsDefaultValue(this) 445985"];
16134 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 445986"];
16135 [label="return allInterfaces.IsDefault &&\n                    interfacesAndTheirBaseInterfaces == null &&\n                    _implementationForInterfaceMemberMap == null &&\n                    explicitInterfaceImplementationMap == null; 445987"];
16136 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445988"];
16137 [label="Debug.Assert(info != s_noInterfaces || info.IsDefaultValue(), 'default value was modified'); 445989"];
16138 [label="return info; 445990"];
16139 [label="var info = this.GetInterfaceInfo(); 445991"];
16140 [label="if (info == s_noInterfaces)\n            {\n                return ImmutableArray<NamedTypeSymbol>.Empty;\n            } 445992"];
16141 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 445993"];
16142 [label="return GetAllInterfaces(); 445994"];
16143 [label="foreach (var @interface in this.AllInterfacesNoUseSiteDiagnostics)\n            {\n                cancellationToken.ThrowIfCancellationRequested();\n\n                if (!interfacesAndTheirBases[@interface].Contains(@interface))\n                {\n                    continue;\n                }\n\n                HasBaseTypeDeclaringInterfaceResult? hasBaseClassDeclaringInterface = null;\n\n                foreach (var interfaceMember in @interface.GetMembersUnordered())\n                {\n                    cancellationToken.ThrowIfCancellationRequested();\n\n                    // Only require implementations for members that can be implemented in C#.\n                    SymbolKind interfaceMemberKind = interfaceMember.Kind;\n                    switch (interfaceMemberKind)\n                    {\n                        case SymbolKind.Method:\n                        case SymbolKind.Property:\n                        case SymbolKind.Event:\n                            if (!interfaceMember.IsImplementableInterfaceMember())\n                            {\n                                continue;\n                            }\n                            break;\n                        default:\n                            continue;\n                    }\n\n                    SymbolAndDiagnostics implementingMemberAndDiagnostics;\n\n                    if (this.IsInterface)\n                    {\n                        MultiDictionary<Symbol, Symbol>.ValueSet explicitImpl = this.GetExplicitImplementationForInterfaceMember(interfaceMember);\n\n                        switch (explicitImpl.Count)\n                        {\n                            case 0:\n                                continue; // There is no requirement to implement anything in an interface\n                            case 1:\n                                implementingMemberAndDiagnostics = new SymbolAndDiagnostics(explicitImpl.Single(), ImmutableArray<Diagnostic>.Empty);\n                                break;\n                            default:\n                                Diagnostic diag = new CSDiagnostic(new CSDiagnosticInfo(ErrorCode.ERR_DuplicateExplicitImpl, interfaceMember), this.Locations[0]);\n                                implementingMemberAndDiagnostics = new SymbolAndDiagnostics(null, ImmutableArray.Create(diag));\n                                break;\n                        }\n                    }\n                    else\n                    {\n                        implementingMemberAndDiagnostics = this.FindImplementationForInterfaceMemberInNonInterfaceWithDiagnostics(interfaceMember);\n                    }\n\n                    var implementingMember = implementingMemberAndDiagnostics.Symbol;\n                    var synthesizedImplementation = this.SynthesizeInterfaceMemberImplementation(implementingMemberAndDiagnostics, interfaceMember);\n\n                    bool wasImplementingMemberFound = (object)implementingMember != null;\n\n                    if ((object)synthesizedImplementation != null)\n                    {\n                        if (synthesizedImplementation.IsVararg)\n                        {\n                            diagnostics.Add(\n                                ErrorCode.ERR_InterfaceImplementedImplicitlyByVariadic,\n                                GetImplicitImplementationDiagnosticLocation(interfaceMember, this, implementingMember), implementingMember, interfaceMember, this);\n                        }\n                        else\n                        {\n                            synthesizedImplementations.Add(synthesizedImplementation);\n                        }\n                    }\n\n                    if (wasImplementingMemberFound && interfaceMemberKind == SymbolKind.Event)\n                    {\n                        // NOTE: unlike dev11, we're including a related location for the implementing type, because\n                        // otherwise the only error location will be in the containing type of the implementing event\n                        // (i.e. no indication of which type's interface list is actually problematic).\n\n                        EventSymbol interfaceEvent = (EventSymbol)interfaceMember;\n                        EventSymbol implementingEvent = (EventSymbol)implementingMember;\n                        EventSymbol maybeWinRTEvent;\n                        EventSymbol maybeRegularEvent;\n\n                        if (interfaceEvent.IsWindowsRuntimeEvent)\n                        {\n                            maybeWinRTEvent = interfaceEvent; // Definitely WinRT.\n                            maybeRegularEvent = implementingEvent; // Maybe regular.\n                        }\n                        else\n                        {\n                            maybeWinRTEvent = implementingEvent; // Maybe WinRT.\n                            maybeRegularEvent = interfaceEvent; // Definitely regular.\n                        }\n\n                        if (interfaceEvent.IsWindowsRuntimeEvent != implementingEvent.IsWindowsRuntimeEvent)\n                        {\n                            // At this point (and not before), we know that maybeWinRTEvent is definitely a WinRT event and maybeRegularEvent is definitely a regular event.\n                            var args = new object[] { implementingEvent, interfaceEvent, maybeWinRTEvent, maybeRegularEvent };\n                            var info = new CSDiagnosticInfo(ErrorCode.ERR_MixingWinRTEventWithRegular, args, ImmutableArray<Symbol>.Empty, ImmutableArray.Create<Location>(this.Locations[0]));\n                            diagnostics.Add(info, implementingEvent.Locations[0]);\n                        }\n                    }\n\n                    // Dev10: If a whole property is missing, report the property.  If the property is present, but an accessor\n                    // is missing, report just the accessor.\n\n                    var associatedPropertyOrEvent = interfaceMemberKind == SymbolKind.Method ? ((MethodSymbol)interfaceMember).AssociatedSymbol : null;\n                    if ((object)associatedPropertyOrEvent == null ||\n                        ReportAccessorOfInterfacePropertyOrEvent(associatedPropertyOrEvent) ||\n                        (wasImplementingMemberFound && !implementingMember.IsAccessor()))\n                    {\n                        //we're here because\n                        //(a) the interface member is not an accessor, or\n                        //(b) the interface member is an accessor of an interesting (see ReportAccessorOfInterfacePropertyOrEvent) property or event, or\n                        //(c) the implementing member exists and is not an accessor.\n                        bool reportedAnError = false;\n                        if (implementingMemberAndDiagnostics.Diagnostics.Any())\n                        {\n                            diagnostics.AddRange(implementingMemberAndDiagnostics.Diagnostics);\n                            reportedAnError = implementingMemberAndDiagnostics.Diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error);\n                        }\n\n                        if (!reportedAnError)\n                        {\n                            if (!wasImplementingMemberFound ||\n                                (!implementingMember.ContainingType.Equals(this, TypeCompareKind.ConsiderEverything) &&\n                                implementingMember.GetExplicitInterfaceImplementations().Contains(interfaceMember, ExplicitInterfaceImplementationTargetMemberEqualityComparer.Instance)))\n                            {\n                                // NOTE: An alternative approach would be to keep track of this while searching for the implementing member.\n                                // In some cases, we might even be able to stop looking and just accept that a base type has things covered\n                                // (though we'd have to be careful about losing diagnostics and we might produce fewer bridge methods).\n                                // However, this approach has the advantage that there is no cost unless we encounter a base type that\n                                // claims to implement an interface, but we can't figure out how (i.e. free in nearly all cases).\n                                hasBaseClassDeclaringInterface = hasBaseClassDeclaringInterface ?? HasBaseClassDeclaringInterface(@interface);\n\n                                HasBaseTypeDeclaringInterfaceResult matchResult = hasBaseClassDeclaringInterface.GetValueOrDefault();\n\n                                if (matchResult != HasBaseTypeDeclaringInterfaceResult.ExactMatch &&\n                                    wasImplementingMemberFound && implementingMember.ContainingType.IsInterface)\n                                {\n                                    HasBaseInterfaceDeclaringInterface(implementingMember.ContainingType, @interface, ref matchResult);\n                                }\n\n                                // If a base type from metadata declares that it implements the interface, we'll just trust it.\n                                // (See fFoundImport in SymbolPreparer::CheckInterfaceMethodImplementation.)\n                                switch (matchResult)\n                                {\n                                    case HasBaseTypeDeclaringInterfaceResult.NoMatch:\n                                        {\n                                            // CONSIDER: Dev10 does not emit this diagnostic for interface properties if the\n                                            // derived type attempts to implement an accessor directly as a method.\n\n                                            // Suppress for bogus properties and events and for indexed properties.\n                                            if (!interfaceMember.MustCallMethodsDirectly() && !interfaceMember.IsIndexedProperty())\n                                            {\n                                                DiagnosticInfo useSiteDiagnostic = interfaceMember.GetUseSiteDiagnostic();\n\n                                                if (useSiteDiagnostic != null && useSiteDiagnostic.DefaultSeverity == DiagnosticSeverity.Error)\n                                                {\n                                                    diagnostics.Add(useSiteDiagnostic, GetImplementsLocationOrFallback(@interface));\n                                                }\n                                                else\n                                                {\n                                                    diagnostics.Add(ErrorCode.ERR_UnimplementedInterfaceMember, GetImplementsLocationOrFallback(@interface), this, interfaceMember);\n                                                }\n                                            }\n                                        }\n                                        break;\n\n                                    case HasBaseTypeDeclaringInterfaceResult.ExactMatch:\n                                        break;\n\n                                    case HasBaseTypeDeclaringInterfaceResult.IgnoringNullableMatch:\n                                        diagnostics.Add(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase, GetImplementsLocationOrFallback(@interface), this, interfaceMember);\n                                        break;\n\n                                    default:\n                                        throw ExceptionUtilities.UnexpectedValue(matchResult);\n                                }\n                            }\n\n                            if (wasImplementingMemberFound && interfaceMemberKind == SymbolKind.Method)\n                            {\n                                // Don't report use site errors on properties - we'll report them on each of their accessors.\n\n                                // Don't report use site errors for implementations in other types unless\n                                // a synthesized implementation is needed that invokes the base method.\n                                // We can do so only if there are no use-site errors.\n\n                                if ((object)synthesizedImplementation != null || TypeSymbol.Equals(implementingMember.ContainingType, this, TypeCompareKind.ConsiderEverything2))\n                                {\n                                    DiagnosticInfo useSiteDiagnostic = interfaceMember.GetUseSiteDiagnostic();\n                                    // CAVEAT: don't report ERR_ByRefReturnUnsupported since by-ref return types are\n                                    // specifically allowed for the purposes of interface implementation (for C++ interop).\n                                    // However, if there's a reference to the interface member in source, then we do want\n                                    // to produce a use site error.\n                                    if (useSiteDiagnostic != null && (ErrorCode)useSiteDiagnostic.Code != ErrorCode.ERR_ByRefReturnUnsupported)\n                                    {\n                                        // Don't report a use site error with a location in another compilation.  For example,\n                                        // if the error is that a base type in another assembly implemented an interface member\n                                        // on our behalf and the use site error is that the current assembly does not reference\n                                        // some required assembly, then we want to report the error in the current assembly -\n                                        // not in the implementing assembly.\n                                        Location location = implementingMember.IsFromCompilation(this.DeclaringCompilation)\n                                            ? implementingMember.Locations[0]\n                                            : this.Locations[0];\n                                        Symbol.ReportUseSiteDiagnostic(useSiteDiagnostic, diagnostics, location);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } 445995"];
16144 [label="return synthesizedImplementations.ToImmutableAndFree(); 445996"];
16145 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445997"];
16146 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445998"];
16147 [label="if (ImmutableInterlocked.InterlockedCompareExchange(\n                            ref _lazySynthesizedExplicitImplementations,\n                            ComputeInterfaceImplementations(diagnostics, cancellationToken),\n                            default(ImmutableArray<SynthesizedExplicitImplementationForwardingMethod>)).IsDefault)\n                    {\n                        // Do not cancel from this point on.  We've assigned the member, so we must add\n                        // the diagnostics.\n                        AddDeclarationDiagnostics(diagnostics);\n\n                        state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations);\n                    } 445999"];
16148 [label="AddDeclarationDiagnostics(diagnostics); 446000"];
16149 [label="AddDeclarationDiagnostics(diagnostics) 446001"];
16150 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 446002"];
16151 [label="param AddDeclarationDiagnostics(this) 446003"];
16152 [label="ContainingSymbol 446004"];
16153 [label="get\n            {\n                return _containingSymbol;\n            } 446005"];
16154 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 446006"];
16155 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 446007"];
16156 [label="AddDeclarationDiagnostics(diagnostics); 446008"];
16157 [label="state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations); 446009"];
16158 [label="state.NotePartComplete(CompletionPart.SynthesizedExplicitImplementations) 446010"];
16159 [label="param NotePartComplete(CompletionPart part) 446011"];
16160 [label="diagnostics.Free(); 446012"];
16161 [label="return _lazySynthesizedExplicitImplementations; 446013"];
16162 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 446014"];
16163 [label="param SpinWaitComplete(CompletionPart part) 446015"];
16164 [label="param SpinWaitComplete(this) 446016"];
16165 [label="if (HasComplete(part))\n            {\n                return;\n            } 446017"];
16166 [label="param HasComplete(CompletionPart part) 446018"];
16167 [label="param HasComplete(this) 446019"];
16168 [label="return (_completeParts & (int)part) == (int)part; 446020"];
16169 [label="return; 446021"];
16170 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 446022"];
16171 [label="param HasAtMostOneBitSet(int bits) 446023"];
16172 [label="return (bits & (bits - 1)) == 0; 446024"];
16173 [label="if (state.NotePartComplete(CompletionPart.StartMemberChecks))\n                        {\n                            var diagnostics = DiagnosticBag.GetInstance();\n                            AfterMembersChecks(diagnostics);\n                            AddDeclarationDiagnostics(diagnostics);\n\n                            // We may produce a SymbolDeclaredEvent for the enclosing type before events for its contained members\n                            DeclaringCompilation.SymbolDeclaredEvent(this);\n                            var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks);\n                            Debug.Assert(thisThreadCompleted);\n                            diagnostics.Free();\n                        } 446025"];
16174 [label="state.NotePartComplete(CompletionPart.StartMemberChecks) 446026"];
16175 [label="param NotePartComplete(CompletionPart part) 446027"];
16176 [label="var diagnostics = DiagnosticBag.GetInstance(); 446028"];
16177 [label="AfterMembersChecks(diagnostics); 446029"];
16178 [label="AfterMembersChecks(diagnostics) 446030"];
16179 [label="param AfterMembersChecks(DiagnosticBag diagnostics) 446031"];
16180 [label="param AfterMembersChecks(this) 446032"];
16181 [label="IsInterface 446033"];
16182 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 446034"];
16183 [label="if (IsInterface)\n            {\n                CheckInterfaceMembers(this.GetMembersAndInitializers().NonTypeMembers, diagnostics);\n            } 446035"];
16184 [label="CheckMemberNamesDistinctFromType(diagnostics); 446036"];
16185 [label="CheckMemberNamesDistinctFromType(diagnostics) 446037"];
16186 [label="param CheckMemberNamesDistinctFromType(DiagnosticBag diagnostics) 446038"];
16187 [label="param CheckMemberNamesDistinctFromType(this) 446039"];
16188 [label="GetMembersAndInitializers() 446040"];
16189 [label="param GetMembersAndInitializers(this) 446041"];
16190 [label="var membersAndInitializers = _lazyMembersAndInitializers; 446042"];
16191 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 446043"];
16192 [label="if (membersAndInitializers != null)\n            {\n                return membersAndInitializers;\n            } 446044"];
16193 [label="return membersAndInitializers; 446045"];
16194 [label="foreach (var member in GetMembersAndInitializers().NonTypeMembers)\n            {\n                CheckMemberNameDistinctFromType(member, diagnostics);\n            } 446046"];
16195 [label="CheckMemberNameDistinctFromType(member, diagnostics); 446047"];
16196 [label="CheckMemberNameDistinctFromType(member, diagnostics); 446048"];
16197 [label="get { return WellKnownMemberNames.InstanceConstructorName; } 446049"];
16198 [label="CheckMemberNamesDistinctFromType(diagnostics); 446050"];
16199 [label="CheckMemberNameConflicts(diagnostics); 446051"];
16200 [label="CheckMemberNameConflicts(diagnostics) 446052"];
16201 [label="param CheckMemberNameConflicts(DiagnosticBag diagnostics) 446053"];
16202 [label="param CheckMemberNameConflicts(this) 446054"];
16203 [label="GetMembersByName() 446055"];
16204 [label="param GetMembersByName(this) 446056"];
16205 [label="param HasComplete(this) 446057"];
16206 [label="Dictionary<string, ImmutableArray<Symbol>> membersByName = GetMembersByName(); 446058"];
16207 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 446059"];
16208 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 446060"];
16209 [label="CheckIndexerNameConflicts(diagnostics, membersByName) 446061"];
16210 [label="param CheckIndexerNameConflicts(DiagnosticBag diagnostics) 446062"];
16211 [label="param CheckIndexerNameConflicts(Dictionary<string, ImmutableArray<Symbol>> membersByName) 446063"];
16212 [label="param CheckIndexerNameConflicts(this) 446064"];
16213 [label="PooledHashSet<string>? typeParameterNames = null; 446065"];
16214 [label="this.Arity 446066"];
16215 [label="get\n            {\n                return declaration.Arity;\n            } 446067"];
16216 [label="return declaration.Arity; 446068"];
16217 [label="if (this.Arity > 0)\n            {\n                typeParameterNames = PooledHashSet<string>.GetInstance();\n                foreach (TypeParameterSymbol typeParameter in this.TypeParameters)\n                {\n                    typeParameterNames.Add(typeParameter.Name);\n                }\n            } 446069"];
16218 [label="if (this.Arity > 0)\n            {\n                typeParameterNames = PooledHashSet<string>.GetInstance();\n                foreach (TypeParameterSymbol typeParameter in this.TypeParameters)\n                {\n                    typeParameterNames.Add(typeParameter.Name);\n                }\n            } 446070"];
16219 [label="var indexersBySignature = new Dictionary<PropertySymbol, PropertySymbol>(MemberSignatureComparer.DuplicateSourceComparer); 446071"];
16220 [label="foreach (var members in membersByName.Values)\n            {\n                string? lastIndexerName = null;\n                indexersBySignature.Clear();\n                foreach (var symbol in members)\n                {\n                    if (symbol.IsIndexer())\n                    {\n                        PropertySymbol indexer = (PropertySymbol)symbol;\n                        CheckIndexerSignatureCollisions(\n                            indexer,\n                            diagnostics,\n                            membersByName,\n                            indexersBySignature,\n                            ref lastIndexerName);\n\n                        // Also check for collisions with type parameters, which aren't in the member map.\n                        // NOTE: Accessors have normal names and are handled in CheckTypeParameterNameConflicts.\n                        if (typeParameterNames != null)\n                        {\n                            string indexerName = indexer.MetadataName;\n                            if (typeParameterNames.Contains(indexerName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, indexer.Locations[0], this, indexerName);\n                                continue;\n                            }\n                        }\n                    }\n                }\n            } 446072"];
16221 [label="string? lastIndexerName = null; 446073"];
16222 [label="indexersBySignature.Clear(); 446074"];
16223 [label="foreach (var symbol in members)\n                {\n                    if (symbol.IsIndexer())\n                    {\n                        PropertySymbol indexer = (PropertySymbol)symbol;\n                        CheckIndexerSignatureCollisions(\n                            indexer,\n                            diagnostics,\n                            membersByName,\n                            indexersBySignature,\n                            ref lastIndexerName);\n\n                        // Also check for collisions with type parameters, which aren't in the member map.\n                        // NOTE: Accessors have normal names and are handled in CheckTypeParameterNameConflicts.\n                        if (typeParameterNames != null)\n                        {\n                            string indexerName = indexer.MetadataName;\n                            if (typeParameterNames.Contains(indexerName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, indexer.Locations[0], this, indexerName);\n                                continue;\n                            }\n                        }\n                    }\n                } 446075"];
16224 [label="if (symbol.IsIndexer())\n                    {\n                        PropertySymbol indexer = (PropertySymbol)symbol;\n                        CheckIndexerSignatureCollisions(\n                            indexer,\n                            diagnostics,\n                            membersByName,\n                            indexersBySignature,\n                            ref lastIndexerName);\n\n                        // Also check for collisions with type parameters, which aren't in the member map.\n                        // NOTE: Accessors have normal names and are handled in CheckTypeParameterNameConflicts.\n                        if (typeParameterNames != null)\n                        {\n                            string indexerName = indexer.MetadataName;\n                            if (typeParameterNames.Contains(indexerName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, indexer.Locations[0], this, indexerName);\n                                continue;\n                            }\n                        }\n                    } 446076"];
16225 [label="symbol.IsIndexer() 446077"];
16226 [label="param IsIndexer(this Symbol symbol) 446078"];
16227 [label="symbol.Kind 446079"];
16228 [label="get\n            {\n                return SymbolKind.Method;\n            } 446080"];
16229 [label="return SymbolKind.Method; 446081"];
16230 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 446082"];
16231 [label="if (symbol.IsIndexer())\n                    {\n                        PropertySymbol indexer = (PropertySymbol)symbol;\n                        CheckIndexerSignatureCollisions(\n                            indexer,\n                            diagnostics,\n                            membersByName,\n                            indexersBySignature,\n                            ref lastIndexerName);\n\n                        // Also check for collisions with type parameters, which aren't in the member map.\n                        // NOTE: Accessors have normal names and are handled in CheckTypeParameterNameConflicts.\n                        if (typeParameterNames != null)\n                        {\n                            string indexerName = indexer.MetadataName;\n                            if (typeParameterNames.Contains(indexerName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, indexer.Locations[0], this, indexerName);\n                                continue;\n                            }\n                        }\n                    } 446083"];
16232 [label="typeParameterNames?.Free(); 446084"];
16233 [label="CheckIndexerNameConflicts(diagnostics, membersByName); 446085"];
16234 [label="var methodsBySignature = new Dictionary<SourceMemberMethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); 446086"];
16235 [label="var conversionsAsMethods = new Dictionary<SourceMemberMethodSymbol, SourceMemberMethodSymbol>(MemberSignatureComparer.DuplicateSourceComparer); 446087"];
16236 [label="new ConversionSignatureComparer() 446088"];
16237 [label="param ConversionSignatureComparer(this) 446089"];
16238 [label="s_comparer = new ConversionSignatureComparer() 446090"];
16239 [label="ConversionSignatureComparer.Comparer 446091"];
16240 [label="return s_comparer; 446092"];
16241 [label="var conversionsAsConversions = new HashSet<SourceUserDefinedConversionSymbol>(ConversionSignatureComparer.Comparer); 446093"];
16242 [label="foreach (var pair in membersByName)\n            {\n                var name = pair.Key;\n                Symbol? lastSym = GetTypeMembers(name).FirstOrDefault();\n                methodsBySignature.Clear();\n                // Conversion collisions do not consider the name of the conversion,\n                // so do not clear that dictionary.\n                foreach (var symbol in pair.Value)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    }\n\n                    // We detect the first category of conflict by running down the list of members\n                    // of the same name, and producing an error when we discover any of the following\n                    // 'bad transitions'.\n                    //\n                    // * a method or conversion that comes after any field (not necessarily directly)\n                    // * a field directly following a field\n                    // * a field directly following a method or conversion\n                    //\n                    // Furthermore: we do not wish to detect collisions between nested types in\n                    // this code; that is tested elsewhere. However, we do wish to detect a collision\n                    // between a nested type and a field, method or conversion. Therefore we\n                    // initialize our 'bad transition' detector with a type of the given name,\n                    // if there is one. That way we also detect the transitions of 'method following\n                    // type', and so on.\n                    //\n                    // The 'lastSym' local below is used to detect these transitions. Its value is\n                    // one of the following:\n                    //\n                    // * a nested type of the given name, or\n                    // * the first method of the given name, or\n                    // * the most recently processed field of the given name.\n                    //\n                    // If either the current symbol or the 'last symbol' are not methods then\n                    // there must be a collision:\n                    //\n                    // * if the current symbol is not a method and the last symbol is, then\n                    //   there is a field directly following a method of the same name\n                    // * if the current symbol is a method and the last symbol is not, then\n                    //   there is a method directly or indirectly following a field of the same name,\n                    //   or a method of the same name as a nested type.\n                    // * if neither are methods then either we have a field directly\n                    //   following a field of the same name, or a field and a nested type of the same name.\n                    //\n\n                    if (lastSym is object)\n                    {\n                        if (symbol.Kind != SymbolKind.Method || lastSym.Kind != SymbolKind.Method)\n                        {\n                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared)\n                            {\n                                // The type '{0}' already contains a definition for '{1}'\n                                if (Locations.Length == 1 || IsPartial)\n                                {\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, symbol.Locations[0], this, symbol.Name);\n                                }\n                            }\n\n                            if (lastSym.Kind == SymbolKind.Method)\n                            {\n                                lastSym = symbol;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        lastSym = symbol;\n                    }\n\n                    // That takes care of the first category of conflict; we detect the\n                    // second and third categories as follows:\n\n                    var conversion = symbol as SourceUserDefinedConversionSymbol;\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (!(conversion is null))\n                    {\n                        // Does this conversion collide *as a conversion* with any previously-seen\n                        // conversion?\n\n                        if (!conversionsAsConversions.Add(conversion))\n                        {\n                            // CS0557: Duplicate user-defined conversion in type 'C'\n                            diagnostics.Add(ErrorCode.ERR_DuplicateConversionInClass, conversion.Locations[0], this);\n                        }\n                        else\n                        {\n                            // The other set might already contain a conversion which would collide\n                            // *as a method* with the current conversion.\n                            if (!conversionsAsMethods.ContainsKey(conversion))\n                            {\n                                conversionsAsMethods.Add(conversion, conversion);\n                            }\n                        }\n\n                        // Does this conversion collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(conversion, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, conversion, previousMethod);\n                        }\n                        // Do not add the conversion to the set of previously-seen methods; that set\n                        // is only non-conversion methods.\n                    }\n                    else if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    }\n                }\n            } 446094"];
16243 [label="var name = pair.Key; 446095"];
16244 [label="Symbol? lastSym = GetTypeMembers(name).FirstOrDefault(); 446096"];
16245 [label="GetTypeMembers(name) 446097"];
16246 [label="param GetTypeMembers(string name) 446098"];
16247 [label="param GetTypeMembers(this) 446099"];
16248 [label="ImmutableArray<NamedTypeSymbol> members; 446100"];
16249 [label="members 446101"];
16250 [label="GetTypeMembersDictionary() 446102"];
16251 [label="param GetTypeMembersDictionary(this) 446103"];
16252 [label="return _lazyTypeMembers; 446104"];
16253 [label="if (GetTypeMembersDictionary().TryGetValue(name, out members))\n            {\n                return members;\n            } 446105"];
16254 [label="if (GetTypeMembersDictionary().TryGetValue(name, out members))\n            {\n                return members;\n            } 446106"];
16255 [label="if (GetTypeMembersDictionary().TryGetValue(name, out members))\n            {\n                return members;\n            } 446107"];
16256 [label="if (GetTypeMembersDictionary().TryGetValue(name, out members))\n            {\n                return members;\n            } 446108"];
16257 [label="return ImmutableArray<NamedTypeSymbol>.Empty; 446109"];
16258 [label="Symbol? lastSym = GetTypeMembers(name).FirstOrDefault(); 446110"];
16259 [label="methodsBySignature.Clear(); 446111"];
16260 [label="foreach (var symbol in pair.Value)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    }\n\n                    // We detect the first category of conflict by running down the list of members\n                    // of the same name, and producing an error when we discover any of the following\n                    // 'bad transitions'.\n                    //\n                    // * a method or conversion that comes after any field (not necessarily directly)\n                    // * a field directly following a field\n                    // * a field directly following a method or conversion\n                    //\n                    // Furthermore: we do not wish to detect collisions between nested types in\n                    // this code; that is tested elsewhere. However, we do wish to detect a collision\n                    // between a nested type and a field, method or conversion. Therefore we\n                    // initialize our 'bad transition' detector with a type of the given name,\n                    // if there is one. That way we also detect the transitions of 'method following\n                    // type', and so on.\n                    //\n                    // The 'lastSym' local below is used to detect these transitions. Its value is\n                    // one of the following:\n                    //\n                    // * a nested type of the given name, or\n                    // * the first method of the given name, or\n                    // * the most recently processed field of the given name.\n                    //\n                    // If either the current symbol or the 'last symbol' are not methods then\n                    // there must be a collision:\n                    //\n                    // * if the current symbol is not a method and the last symbol is, then\n                    //   there is a field directly following a method of the same name\n                    // * if the current symbol is a method and the last symbol is not, then\n                    //   there is a method directly or indirectly following a field of the same name,\n                    //   or a method of the same name as a nested type.\n                    // * if neither are methods then either we have a field directly\n                    //   following a field of the same name, or a field and a nested type of the same name.\n                    //\n\n                    if (lastSym is object)\n                    {\n                        if (symbol.Kind != SymbolKind.Method || lastSym.Kind != SymbolKind.Method)\n                        {\n                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared)\n                            {\n                                // The type '{0}' already contains a definition for '{1}'\n                                if (Locations.Length == 1 || IsPartial)\n                                {\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, symbol.Locations[0], this, symbol.Name);\n                                }\n                            }\n\n                            if (lastSym.Kind == SymbolKind.Method)\n                            {\n                                lastSym = symbol;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        lastSym = symbol;\n                    }\n\n                    // That takes care of the first category of conflict; we detect the\n                    // second and third categories as follows:\n\n                    var conversion = symbol as SourceUserDefinedConversionSymbol;\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (!(conversion is null))\n                    {\n                        // Does this conversion collide *as a conversion* with any previously-seen\n                        // conversion?\n\n                        if (!conversionsAsConversions.Add(conversion))\n                        {\n                            // CS0557: Duplicate user-defined conversion in type 'C'\n                            diagnostics.Add(ErrorCode.ERR_DuplicateConversionInClass, conversion.Locations[0], this);\n                        }\n                        else\n                        {\n                            // The other set might already contain a conversion which would collide\n                            // *as a method* with the current conversion.\n                            if (!conversionsAsMethods.ContainsKey(conversion))\n                            {\n                                conversionsAsMethods.Add(conversion, conversion);\n                            }\n                        }\n\n                        // Does this conversion collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(conversion, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, conversion, previousMethod);\n                        }\n                        // Do not add the conversion to the set of previously-seen methods; that set\n                        // is only non-conversion methods.\n                    }\n                    else if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    }\n                } 446112"];
16261 [label="foreach (var symbol in pair.Value)\n                {\n                    if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    }\n\n                    // We detect the first category of conflict by running down the list of members\n                    // of the same name, and producing an error when we discover any of the following\n                    // 'bad transitions'.\n                    //\n                    // * a method or conversion that comes after any field (not necessarily directly)\n                    // * a field directly following a field\n                    // * a field directly following a method or conversion\n                    //\n                    // Furthermore: we do not wish to detect collisions between nested types in\n                    // this code; that is tested elsewhere. However, we do wish to detect a collision\n                    // between a nested type and a field, method or conversion. Therefore we\n                    // initialize our 'bad transition' detector with a type of the given name,\n                    // if there is one. That way we also detect the transitions of 'method following\n                    // type', and so on.\n                    //\n                    // The 'lastSym' local below is used to detect these transitions. Its value is\n                    // one of the following:\n                    //\n                    // * a nested type of the given name, or\n                    // * the first method of the given name, or\n                    // * the most recently processed field of the given name.\n                    //\n                    // If either the current symbol or the 'last symbol' are not methods then\n                    // there must be a collision:\n                    //\n                    // * if the current symbol is not a method and the last symbol is, then\n                    //   there is a field directly following a method of the same name\n                    // * if the current symbol is a method and the last symbol is not, then\n                    //   there is a method directly or indirectly following a field of the same name,\n                    //   or a method of the same name as a nested type.\n                    // * if neither are methods then either we have a field directly\n                    //   following a field of the same name, or a field and a nested type of the same name.\n                    //\n\n                    if (lastSym is object)\n                    {\n                        if (symbol.Kind != SymbolKind.Method || lastSym.Kind != SymbolKind.Method)\n                        {\n                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared)\n                            {\n                                // The type '{0}' already contains a definition for '{1}'\n                                if (Locations.Length == 1 || IsPartial)\n                                {\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, symbol.Locations[0], this, symbol.Name);\n                                }\n                            }\n\n                            if (lastSym.Kind == SymbolKind.Method)\n                            {\n                                lastSym = symbol;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        lastSym = symbol;\n                    }\n\n                    // That takes care of the first category of conflict; we detect the\n                    // second and third categories as follows:\n\n                    var conversion = symbol as SourceUserDefinedConversionSymbol;\n                    var method = symbol as SourceMemberMethodSymbol;\n                    if (!(conversion is null))\n                    {\n                        // Does this conversion collide *as a conversion* with any previously-seen\n                        // conversion?\n\n                        if (!conversionsAsConversions.Add(conversion))\n                        {\n                            // CS0557: Duplicate user-defined conversion in type 'C'\n                            diagnostics.Add(ErrorCode.ERR_DuplicateConversionInClass, conversion.Locations[0], this);\n                        }\n                        else\n                        {\n                            // The other set might already contain a conversion which would collide\n                            // *as a method* with the current conversion.\n                            if (!conversionsAsMethods.ContainsKey(conversion))\n                            {\n                                conversionsAsMethods.Add(conversion, conversion);\n                            }\n                        }\n\n                        // Does this conversion collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(conversion, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, conversion, previousMethod);\n                        }\n                        // Do not add the conversion to the set of previously-seen methods; that set\n                        // is only non-conversion methods.\n                    }\n                    else if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    }\n                } 446113"];
16262 [label="symbol.Kind 446114"];
16263 [label="get\n            {\n                return SymbolKind.Method;\n            } 446115"];
16264 [label="return SymbolKind.Method; 446116"];
16265 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446117"];
16266 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446118"];
16267 [label="symbol.IsAccessor() 446119"];
16268 [label="param IsAccessor(this Symbol symbol) 446120"];
16269 [label="symbol.Kind 446121"];
16270 [label="get\n            {\n                return SymbolKind.Method;\n            } 446122"];
16271 [label="return SymbolKind.Method; 446123"];
16272 [label="return symbol.Kind == SymbolKind.Method && IsAccessor((MethodSymbol)symbol); 446124"];
16273 [label="return symbol.Kind == SymbolKind.Method && IsAccessor((MethodSymbol)symbol); 446125"];
16274 [label="IsAccessor((MethodSymbol)symbol) 446126"];
16275 [label="param IsAccessor(this MethodSymbol methodSymbol) 446127"];
16276 [label="methodSymbol.AssociatedSymbol 446128"];
16277 [label="get { return null; } 446129"];
16278 [label="return null; 446130"];
16279 [label="return (object)methodSymbol.AssociatedSymbol != null; 446131"];
16280 [label="return (object)methodSymbol.AssociatedSymbol != null; 446132"];
16281 [label="return symbol.Kind == SymbolKind.Method && IsAccessor((MethodSymbol)symbol); 446133"];
16282 [label="return symbol.Kind == SymbolKind.Method && IsAccessor((MethodSymbol)symbol); 446134"];
16283 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446135"];
16284 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446136"];
16285 [label="symbol.IsIndexer() 446137"];
16286 [label="param IsIndexer(this Symbol symbol) 446138"];
16287 [label="symbol.Kind 446139"];
16288 [label="get\n            {\n                return SymbolKind.Method;\n            } 446140"];
16289 [label="return SymbolKind.Method; 446141"];
16290 [label="return symbol.Kind == SymbolKind.Property && ((PropertySymbol)symbol).IsIndexer; 446142"];
16291 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446143"];
16292 [label="if (symbol.Kind == SymbolKind.NamedType ||\n                        symbol.IsAccessor() ||\n                        symbol.IsIndexer())\n                    {\n                        continue;\n                    } 446144"];
16293 [label="if (lastSym is object)\n                    {\n                        if (symbol.Kind != SymbolKind.Method || lastSym.Kind != SymbolKind.Method)\n                        {\n                            if (symbol.Kind != SymbolKind.Field || !symbol.IsImplicitlyDeclared)\n                            {\n                                // The type '{0}' already contains a definition for '{1}'\n                                if (Locations.Length == 1 || IsPartial)\n                                {\n                                    diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, symbol.Locations[0], this, symbol.Name);\n                                }\n                            }\n\n                            if (lastSym.Kind == SymbolKind.Method)\n                            {\n                                lastSym = symbol;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        lastSym = symbol;\n                    } 446145"];
16294 [label="lastSym = symbol; 446146"];
16295 [label="var conversion = symbol as SourceUserDefinedConversionSymbol; 446147"];
16296 [label="var method = symbol as SourceMemberMethodSymbol; 446148"];
16297 [label="if (!(conversion is null))\n                    {\n                        // Does this conversion collide *as a conversion* with any previously-seen\n                        // conversion?\n\n                        if (!conversionsAsConversions.Add(conversion))\n                        {\n                            // CS0557: Duplicate user-defined conversion in type 'C'\n                            diagnostics.Add(ErrorCode.ERR_DuplicateConversionInClass, conversion.Locations[0], this);\n                        }\n                        else\n                        {\n                            // The other set might already contain a conversion which would collide\n                            // *as a method* with the current conversion.\n                            if (!conversionsAsMethods.ContainsKey(conversion))\n                            {\n                                conversionsAsMethods.Add(conversion, conversion);\n                            }\n                        }\n\n                        // Does this conversion collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(conversion, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, conversion, previousMethod);\n                        }\n                        // Do not add the conversion to the set of previously-seen methods; that set\n                        // is only non-conversion methods.\n                    }\n                    else if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    } 446149"];
16298 [label="if (!(method is null))\n                    {\n                        // Does this method collide *as a method* with any previously-seen\n                        // conversion?\n\n                        if (conversionsAsMethods.TryGetValue(method, out var previousConversion))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousConversion);\n                        }\n                        // Do not add the method to the set of previously-seen conversions.\n\n                        // Does this method collide *as a method* with any previously-seen\n                        // non-conversion method?\n\n                        if (methodsBySignature.TryGetValue(method, out var previousMethod))\n                        {\n                            ReportMethodSignatureCollision(diagnostics, method, previousMethod);\n                        }\n                        else\n                        {\n                            // We haven't seen this method before. Make a note of it in case\n                            // we see a colliding method later.\n                            methodsBySignature.Add(method, method);\n                        }\n                    } 446150"];
16299 [label="CheckMemberNameConflicts(diagnostics); 446151"];
16300 [label="CheckRecordMemberNames(diagnostics); 446152"];
16301 [label="CheckRecordMemberNames(diagnostics) 446153"];
16302 [label="param CheckRecordMemberNames(DiagnosticBag diagnostics) 446154"];
16303 [label="param CheckRecordMemberNames(this) 446155"];
16304 [label="if (declaration.Kind != DeclarationKind.Record)\n            {\n                return;\n            } 446156"];
16305 [label="return; 446157"];
16306 [label="CheckRecordMemberNames(diagnostics); 446158"];
16307 [label="CheckSpecialMemberErrors(diagnostics); 446159"];
16308 [label="CheckSpecialMemberErrors(diagnostics) 446160"];
16309 [label="param CheckSpecialMemberErrors(DiagnosticBag diagnostics) 446161"];
16310 [label="param CheckSpecialMemberErrors(this) 446162"];
16311 [label="this.ContainingAssembly 446163"];
16312 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 446164"];
16313 [label="this.ContainingSymbol 446165"];
16314 [label="get\n            {\n                return _containingSymbol;\n            } 446166"];
16315 [label="return _containingSymbol; 446167"];
16316 [label="var container = this.ContainingSymbol; 446168"];
16317 [label="return (object)container != null ? container.ContainingAssembly : null; 446169"];
16318 [label="return (object)container != null ? container.ContainingAssembly : null; 446170"];
16319 [label="(object)container != null 446171"];
16320 [label="container.ContainingAssembly 446172"];
16321 [label="=> _module.ContainingAssembly 446173"];
16322 [label="_module.ContainingAssembly 446174"];
16323 [label="get\n            {\n                return _assemblySymbol;\n            } 446175"];
16324 [label="var conversions = new TypeConversions(this.ContainingAssembly.CorLibrary); 446176"];
16325 [label="this.ContainingAssembly.CorLibrary 446177"];
16326 [label="get\n            {\n                return _corLibrary;\n            } 446178"];
16327 [label="var conversions = new TypeConversions(this.ContainingAssembly.CorLibrary); 446179"];
16328 [label="new TypeConversions(this.ContainingAssembly.CorLibrary) 446180"];
16329 [label="param TypeConversions(AssemblySymbol corLibrary) 446181"];
16330 [label="param TypeConversions(bool includeNullability = false) 446182"];
16331 [label="param TypeConversions(this) 446183"];
16332 [label="corLibrary 446184"];
16333 [label="0 446185"];
16334 [label="includeNullability 446186"];
16335 [label="null 446187"];
16336 [label="param TypeConversions(this) 446188"];
16337 [label="param TypeConversions(AssemblySymbol corLibrary) 446189"];
16338 [label="param TypeConversions(int currentRecursionDepth) 446190"];
16339 [label="param TypeConversions(bool includeNullability) 446191"];
16340 [label="param TypeConversions(TypeConversions otherNullabilityOpt) 446192"];
16341 [label="param TypeConversions(this) 446193"];
16342 [label="50 446194"];
16343 [label="MaximumRecursionDepth = 50 446195"];
16344 [label="false 446196"];
16345 [label="F = false 446197"];
16346 [label="true 446198"];
16347 [label="T = true 446199"];
16348 [label="{ F, F, T, F, T, F, T, F, F, T, T, T } 446200"];
16349 [label="{ F, F, T, F, T, F, T, F, F, T, T, T } 446201"];
16350 [label="{ F, F, T, F, T, F, T, F, F, T, T, T } 446202"];
16351 [label="{ F, F, T, T, T, T, T, T, F, T, T, T } 446203"];
16352 [label="{ F, F, T, T, T, T, T, T, F, T, T, T } 446204"];
16353 [label="{ F, F, T, T, T, T, T, T, F, T, T, T } 446205"];
16354 [label="{ F, F, F, F, T, F, T, F, F, T, T, T } 446206"];
16355 [label="{ F, F, F, F, T, F, T, F, F, T, T, T } 446207"];
16356 [label="{ F, F, F, F, T, F, T, F, F, T, T, T } 446208"];
16357 [label="{ F, F, F, F, T, T, T, T, F, T, T, T } 446209"];
16358 [label="{ F, F, F, F, T, T, T, T, F, T, T, T } 446210"];
16359 [label="{ F, F, F, F, T, T, T, T, F, T, T, T } 446211"];
16360 [label="{ F, F, F, F, F, F, T, F, F, T, T, T } 446212"];
16361 [label="{ F, F, F, F, F, F, T, F, F, T, T, T } 446213"];
16362 [label="{ F, F, F, F, F, F, T, F, F, T, T, T } 446214"];
16363 [label="{ F, F, F, F, F, F, T, T, F, T, T, T } 446215"];
16364 [label="{ F, F, F, F, F, F, T, T, F, T, T, T } 446216"];
16365 [label="{ F, F, F, F, F, F, T, T, F, T, T, T } 446217"];
16366 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446218"];
16367 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446219"];
16368 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446220"];
16369 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446221"];
16370 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446222"];
16371 [label="{ F, F, F, F, F, F, F, F, F, T, T, T } 446223"];
16372 [label="{ F, F, F, T, T, T, T, T, F, T, T, T } 446224"];
16373 [label="{ F, F, F, T, T, T, T, T, F, T, T, T } 446225"];
16374 [label="{ F, F, F, T, T, T, T, T, F, T, T, T } 446226"];
16375 [label="{ F, F, F, F, F, F, F, F, F, F, T, F } 446227"];
16376 [label="{ F, F, F, F, F, F, F, F, F, F, T, F } 446228"];
16377 [label="{ F, F, F, F, F, F, F, F, F, F, T, F } 446229"];
16378 [label="{ F, F, F, F, F, F, F, F, F, F, F, F } 446230"];
16379 [label="{ F, F, F, F, F, F, F, F, F, F, F, F } 446231"];
16380 [label="{ F, F, F, F, F, F, F, F, F, F, F, F } 446232"];
16381 [label="{ F, F, F, F, F, F, F, F, F, F, F, F } 446233"];
16382 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446234"];
16383 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446235"];
16384 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446236"];
16385 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446237"];
16386 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446238"];
16387 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446239"];
16388 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446240"];
16389 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446241"];
16390 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446242"];
16391 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446243"];
16392 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446244"];
16393 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446245"];
16394 [label="{\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446246"];
16395 [label="s_implicitNumericConversions =\n        {\n            // to     sb  b  s  us i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, F, T, F, T, F, T, F, F, T, T, T },\n            /*  b */\n         { F, F, T, T, T, T, T, T, F, T, T, T },\n            /*  s */\n         { F, F, F, F, T, F, T, F, F, T, T, T },\n            /* us */\n         { F, F, F, F, T, T, T, T, F, T, T, T },\n            /*  i */\n         { F, F, F, F, F, F, T, F, F, T, T, T },\n            /* ui */\n         { F, F, F, F, F, F, T, T, F, T, T, T },\n            /*  l */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /* ul */\n         { F, F, F, F, F, F, F, F, F, T, T, T },\n            /*  c */\n         { F, F, F, T, T, T, T, T, F, T, T, T },\n            /*  f */\n         { F, F, F, F, F, F, F, F, F, F, T, F },\n            /*  d */\n         { F, F, F, F, F, F, F, F, F, F, F, F },\n            /*  m */\n         { F, F, F, F, F, F, F, F, F, F, F, F }\n        } 446247"];
16396 [label="{ F, T, F, T, F, T, F, T, T, F, F, F } 446248"];
16397 [label="{ F, T, F, T, F, T, F, T, T, F, F, F } 446249"];
16398 [label="{ F, T, F, T, F, T, F, T, T, F, F, F } 446250"];
16399 [label="{ T, F, F, F, F, F, F, F, T, F, F, F } 446251"];
16400 [label="{ T, F, F, F, F, F, F, F, T, F, F, F } 446252"];
16401 [label="{ T, F, F, F, F, F, F, F, T, F, F, F } 446253"];
16402 [label="{ T, T, F, T, F, T, F, T, T, F, F, F } 446254"];
16403 [label="{ T, T, F, T, F, T, F, T, T, F, F, F } 446255"];
16404 [label="{ T, T, F, T, F, T, F, T, T, F, F, F } 446256"];
16405 [label="{ T, T, T, F, F, F, F, F, T, F, F, F } 446257"];
16406 [label="{ T, T, T, F, F, F, F, F, T, F, F, F } 446258"];
16407 [label="{ T, T, T, F, F, F, F, F, T, F, F, F } 446259"];
16408 [label="{ T, T, T, T, F, T, F, T, T, F, F, F } 446260"];
16409 [label="{ T, T, T, T, F, T, F, T, T, F, F, F } 446261"];
16410 [label="{ T, T, T, T, F, T, F, T, T, F, F, F } 446262"];
16411 [label="{ T, T, T, T, T, F, F, F, T, F, F, F } 446263"];
16412 [label="{ T, T, T, T, T, F, F, F, T, F, F, F } 446264"];
16413 [label="{ T, T, T, T, T, F, F, F, T, F, F, F } 446265"];
16414 [label="{ T, T, T, T, T, T, F, T, T, F, F, F } 446266"];
16415 [label="{ T, T, T, T, T, T, F, T, T, F, F, F } 446267"];
16416 [label="{ T, T, T, T, T, T, F, T, T, F, F, F } 446268"];
16417 [label="{ T, T, T, T, T, T, T, F, T, F, F, F } 446269"];
16418 [label="{ T, T, T, T, T, T, T, F, T, F, F, F } 446270"];
16419 [label="{ T, T, T, T, T, T, T, F, T, F, F, F } 446271"];
16420 [label="{ T, T, T, F, F, F, F, F, F, F, F, F } 446272"];
16421 [label="{ T, T, T, F, F, F, F, F, F, F, F, F } 446273"];
16422 [label="{ T, T, T, F, F, F, F, F, F, F, F, F } 446274"];
16423 [label="{ T, T, T, T, T, T, T, T, T, F, F, T } 446275"];
16424 [label="{ T, T, T, T, T, T, T, T, T, F, F, T } 446276"];
16425 [label="{ T, T, T, T, T, T, T, T, T, F, F, T } 446277"];
16426 [label="{ T, T, T, T, T, T, T, T, T, T, F, T } 446278"];
16427 [label="{ T, T, T, T, T, T, T, T, T, T, F, T } 446279"];
16428 [label="{ T, T, T, T, T, T, T, T, T, T, F, T } 446280"];
16429 [label="{ T, T, T, T, T, T, T, T, T, T, T, F } 446281"];
16430 [label="{ T, T, T, T, T, T, T, T, T, T, T, F } 446282"];
16431 [label="{ T, T, T, T, T, T, T, T, T, T, T, F } 446283"];
16432 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446284"];
16433 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446285"];
16434 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446286"];
16435 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446287"];
16436 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446288"];
16437 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446289"];
16438 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446290"];
16439 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446291"];
16440 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446292"];
16441 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446293"];
16442 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446294"];
16443 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446295"];
16444 [label="{\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446296"];
16445 [label="s_explicitNumericConversions =\n        {\n            // to     sb  b  s us  i ui  l ul  c  f  d  m\n            // from\n            /* sb */\n         { F, T, F, T, F, T, F, T, T, F, F, F },\n            /*  b */\n         { T, F, F, F, F, F, F, F, T, F, F, F },\n            /*  s */\n         { T, T, F, T, F, T, F, T, T, F, F, F },\n            /* us */\n         { T, T, T, F, F, F, F, F, T, F, F, F },\n            /*  i */\n         { T, T, T, T, F, T, F, T, T, F, F, F },\n            /* ui */\n         { T, T, T, T, T, F, F, F, T, F, F, F },\n            /*  l */\n         { T, T, T, T, T, T, F, T, T, F, F, F },\n            /* ul */\n         { T, T, T, T, T, T, T, F, T, F, F, F },\n            /*  c */\n         { T, T, T, F, F, F, F, F, F, F, F, F },\n            /*  f */\n         { T, T, T, T, T, T, T, T, T, F, F, T },\n            /*  d */\n         { T, T, T, T, T, T, T, T, T, T, F, T },\n            /*  m */\n         { T, T, T, T, T, T, T, T, T, T, T, F }\n        } 446297"];
16446 [label="corLibrary 446298"];
16447 [label="currentRecursionDepth 446299"];
16448 [label="includeNullability 446300"];
16449 [label="otherNullabilityOpt 446301"];
16450 [label="param TypeConversions(this) 446302"];
16451 [label="param ConversionsBase(AssemblySymbol corLibrary) 446303"];
16452 [label="param ConversionsBase(int currentRecursionDepth) 446304"];
16453 [label="param ConversionsBase(bool includeNullability) 446305"];
16454 [label="param ConversionsBase(ConversionsBase otherNullabilityOpt) 446306"];
16455 [label="param ConversionsBase(this) 446307"];
16456 [label="corLibrary 446308"];
16457 [label="currentRecursionDepth 446309"];
16458 [label="IncludeNullability 446310"];
16459 [label="_lazyOtherNullability 446311"];
16460 [label="Debug.Assert((object)corLibrary != null); 446312"];
16461 [label="Debug.Assert((object)corLibrary != null); 446313"];
16462 [label="Debug.Assert(otherNullabilityOpt == null || includeNullability != otherNullabilityOpt.IncludeNullability); 446314"];
16463 [label="Debug.Assert(otherNullabilityOpt == null || includeNullability != otherNullabilityOpt.IncludeNullability); 446315"];
16464 [label="Debug.Assert(otherNullabilityOpt == null || currentRecursionDepth == otherNullabilityOpt.currentRecursionDepth); 446316"];
16465 [label="Debug.Assert(otherNullabilityOpt == null || currentRecursionDepth == otherNullabilityOpt.currentRecursionDepth); 446317"];
16466 [label="this.corLibrary 446318"];
16467 [label="this.currentRecursionDepth 446319"];
16468 [label="IncludeNullability 446320"];
16469 [label="_lazyOtherNullability 446321"];
16470 [label="this.GetMembersUnordered() 446322"];
16471 [label="param GetMembersUnordered(this) 446323"];
16472 [label="var result = _lazyMembersFlattened; 446324"];
16473 [label="foreach (var member in this.GetMembersUnordered())\n            {\n                member.AfterAddingTypeMembersChecks(conversions, diagnostics);\n            } 446325"];
16474 [label="member.AfterAddingTypeMembersChecks(conversions, diagnostics); 446326"];
16475 [label="member.AfterAddingTypeMembersChecks(conversions, diagnostics); 446327"];
16476 [label="member.AfterAddingTypeMembersChecks(conversions, diagnostics) 446328"];
16477 [label="param AfterAddingTypeMembersChecks(ConversionsBase conversions) 446329"];
16478 [label="param AfterAddingTypeMembersChecks(DiagnosticBag diagnostics) 446330"];
16479 [label="param AfterAddingTypeMembersChecks(this) 446331"];
16480 [label="member.AfterAddingTypeMembersChecks(conversions, diagnostics); 446332"];
16481 [label="CheckSpecialMemberErrors(diagnostics); 446333"];
16482 [label="CheckTypeParameterNameConflicts(diagnostics); 446334"];
16483 [label="CheckTypeParameterNameConflicts(diagnostics) 446335"];
16484 [label="param CheckTypeParameterNameConflicts(DiagnosticBag diagnostics) 446336"];
16485 [label="param CheckTypeParameterNameConflicts(this) 446337"];
16486 [label="this.TypeKind 446338"];
16487 [label="get\n            {\n                return _flags.TypeKind;\n            } 446339"];
16488 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 446340"];
16489 [label="if (this.TypeKind == TypeKind.Delegate)\n            {\n                // Delegates do not have conflicts between their type parameter\n                // names and their methods; it is legal (though odd) to say\n                // delegate void D<Invoke>(Invoke x);\n\n                return;\n            } 446341"];
16490 [label="Locations 446342"];
16491 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 446343"];
16492 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 446344"];
16493 [label="if (Locations.Length == 1 || IsPartial)\n            {\n                foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                }\n            } 446345"];
16494 [label="if (Locations.Length == 1 || IsPartial)\n            {\n                foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                }\n            } 446346"];
16495 [label="TypeParameters 446347"];
16496 [label="foreach (var tp in TypeParameters)\n                {\n                    foreach (var dup in GetMembers(tp.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_DuplicateNameInClass, dup.Locations[0], this, tp.Name);\n                    }\n                } 446348"];
16497 [label="CheckTypeParameterNameConflicts(diagnostics); 446349"];
16498 [label="CheckAccessorNameConflicts(diagnostics); 446350"];
16499 [label="CheckAccessorNameConflicts(diagnostics) 446351"];
16500 [label="param CheckAccessorNameConflicts(DiagnosticBag diagnostics) 446352"];
16501 [label="param CheckAccessorNameConflicts(this) 446353"];
16502 [label="this.GetMembersUnordered() 446354"];
16503 [label="param GetMembersUnordered(this) 446355"];
16504 [label="var result = _lazyMembersFlattened; 446356"];
16505 [label="foreach (Symbol symbol in this.GetMembersUnordered())\n            {\n                if (symbol.IsExplicitInterfaceImplementation())\n                {\n                    // If there's a name conflict it will show up as a more specific\n                    // interface implementation error.\n                    continue;\n                }\n                switch (symbol.Kind)\n                {\n                    case SymbolKind.Property:\n                        {\n                            var propertySymbol = (PropertySymbol)symbol;\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: false, diagnostics: diagnostics);\n                            break;\n                        }\n                    case SymbolKind.Event:\n                        {\n                            var eventSymbol = (EventSymbol)symbol;\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: false, diagnostics: diagnostics);\n                            break;\n                        }\n                }\n            } 446357"];
16506 [label="if (symbol.IsExplicitInterfaceImplementation())\n                {\n                    // If there's a name conflict it will show up as a more specific\n                    // interface implementation error.\n                    continue;\n                } 446358"];
16507 [label="symbol.IsExplicitInterfaceImplementation() 446359"];
16508 [label="param IsExplicitInterfaceImplementation(this Symbol member) 446360"];
16509 [label="member.Kind 446361"];
16510 [label="get\n            {\n                return SymbolKind.Method;\n            } 446362"];
16511 [label="return SymbolKind.Method; 446363"];
16512 [label="switch (member.Kind)\n            {\n                case SymbolKind.Method:\n                    return ((MethodSymbol)member).IsExplicitInterfaceImplementation;\n                case SymbolKind.Property:\n                    return ((PropertySymbol)member).IsExplicitInterfaceImplementation;\n                case SymbolKind.Event:\n                    return ((EventSymbol)member).IsExplicitInterfaceImplementation;\n                default:\n                    return false;\n            } 446364"];
16513 [label="((MethodSymbol)member).IsExplicitInterfaceImplementation 446365"];
16514 [label="get { return false; } 446366"];
16515 [label="return false; 446367"];
16516 [label="return ((MethodSymbol)member).IsExplicitInterfaceImplementation; 446368"];
16517 [label="if (symbol.IsExplicitInterfaceImplementation())\n                {\n                    // If there's a name conflict it will show up as a more specific\n                    // interface implementation error.\n                    continue;\n                } 446369"];
16518 [label="symbol.Kind 446370"];
16519 [label="get\n            {\n                return SymbolKind.Method;\n            } 446371"];
16520 [label="return SymbolKind.Method; 446372"];
16521 [label="switch (symbol.Kind)\n                {\n                    case SymbolKind.Property:\n                        {\n                            var propertySymbol = (PropertySymbol)symbol;\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithPropertyAccessor(propertySymbol, getNotSet: false, diagnostics: diagnostics);\n                            break;\n                        }\n                    case SymbolKind.Event:\n                        {\n                            var eventSymbol = (EventSymbol)symbol;\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: true, diagnostics: diagnostics);\n                            this.CheckForMemberConflictWithEventAccessor(eventSymbol, isAdder: false, diagnostics: diagnostics);\n                            break;\n                        }\n                } 446373"];
16522 [label="CheckAccessorNameConflicts(diagnostics); 446374"];
16523 [label="KnownCircularStruct 446375"];
16524 [label="get\n            {\n                if (_lazyKnownCircularStruct == (int)ThreeState.Unknown)\n                {\n                    if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    }\n                }\n\n                return _lazyKnownCircularStruct == (int)ThreeState.True;\n            } 446376"];
16525 [label="if (_lazyKnownCircularStruct == (int)ThreeState.Unknown)\n                {\n                    if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    }\n                } 446377"];
16526 [label="TypeKind 446378"];
16527 [label="if (TypeKind != TypeKind.Struct)\n                    {\n                        Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown);\n                    }\n                    else\n                    {\n                        var diagnostics = DiagnosticBag.GetInstance();\n                        var value = (int)CheckStructCircularity(diagnostics).ToThreeState();\n\n                        if (Interlocked.CompareExchange(ref _lazyKnownCircularStruct, value, (int)ThreeState.Unknown) == (int)ThreeState.Unknown)\n                        {\n                            AddDeclarationDiagnostics(diagnostics);\n                        }\n\n                        Debug.Assert(value == _lazyKnownCircularStruct);\n                        diagnostics.Free();\n                    } 446379"];
16528 [label="Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown); 446380"];
16529 [label="Interlocked.CompareExchange(ref _lazyKnownCircularStruct, (int)ThreeState.False, (int)ThreeState.Unknown); 446381"];
16530 [label="return _lazyKnownCircularStruct == (int)ThreeState.True; 446382"];
16531 [label="bool unused = KnownCircularStruct; 446383"];
16532 [label="CheckSequentialOnPartialType(diagnostics); 446384"];
16533 [label="CheckSequentialOnPartialType(diagnostics) 446385"];
16534 [label="param CheckSequentialOnPartialType(DiagnosticBag diagnostics) 446386"];
16535 [label="param CheckSequentialOnPartialType(this) 446387"];
16536 [label="IsPartial 446388"];
16537 [label="=> HasFlag(DeclarationModifiers.Partial) 446389"];
16538 [label="DeclarationModifiers.Partial 446390"];
16539 [label="HasFlag(DeclarationModifiers.Partial) 446391"];
16540 [label="param HasFlag(DeclarationModifiers flag) 446392"];
16541 [label="=> (_declModifiers & flag) != 0 446393"];
16542 [label="_declModifiers & flag 446394"];
16543 [label="if (!IsPartial || this.Layout.Kind != LayoutKind.Sequential)\n            {\n                return;\n            } 446395"];
16544 [label="return; 446396"];
16545 [label="CheckSequentialOnPartialType(diagnostics); 446397"];
16546 [label="CheckForProtectedInStaticClass(diagnostics); 446398"];
16547 [label="CheckForProtectedInStaticClass(diagnostics) 446399"];
16548 [label="param CheckForProtectedInStaticClass(DiagnosticBag diagnostics) 446400"];
16549 [label="param CheckForProtectedInStaticClass(this) 446401"];
16550 [label="IsStatic 446402"];
16551 [label="=> HasFlag(DeclarationModifiers.Static) 446403"];
16552 [label="_declModifiers & flag 446404"];
16553 [label="if (!IsStatic)\n            {\n                return;\n            } 446405"];
16554 [label="return; 446406"];
16555 [label="CheckForProtectedInStaticClass(diagnostics); 446407"];
16556 [label="CheckForUnmatchedOperators(diagnostics); 446408"];
16557 [label="CheckForUnmatchedOperators(diagnostics) 446409"];
16558 [label="param CheckForUnmatchedOperators(DiagnosticBag diagnostics) 446410"];
16559 [label="param CheckForUnmatchedOperators(this) 446411"];
16560 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 446412"];
16561 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 446413"];
16562 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName) 446414"];
16563 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446415"];
16564 [label="param CheckForUnmatchedOperator(string operatorName1) 446416"];
16565 [label="param CheckForUnmatchedOperator(string operatorName2) 446417"];
16566 [label="param CheckForUnmatchedOperator(this) 446418"];
16567 [label="var ops1 = this.GetOperators(operatorName1); 446419"];
16568 [label="this.GetOperators(operatorName1) 446420"];
16569 [label="param GetOperators(string name) 446421"];
16570 [label="param GetOperators(this) 446422"];
16571 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446423"];
16572 [label="GetSimpleNonTypeMembers(name) 446424"];
16573 [label="param GetSimpleNonTypeMembers(string name) 446425"];
16574 [label="param GetSimpleNonTypeMembers(this) 446426"];
16575 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446427"];
16576 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446428"];
16577 [label="return GetMembers(name); 446429"];
16578 [label="GetMembers(name) 446430"];
16579 [label="param GetMembers(string name) 446431"];
16580 [label="param GetMembers(this) 446432"];
16581 [label="ImmutableArray<Symbol> members; 446433"];
16582 [label="members 446434"];
16583 [label="GetMembersByName() 446435"];
16584 [label="param GetMembersByName(this) 446436"];
16585 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446437"];
16586 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446438"];
16587 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446439"];
16588 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446440"];
16589 [label="return ImmutableArray<Symbol>.Empty; 446441"];
16590 [label="return GetMembers(name); 446442"];
16591 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446443"];
16592 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446444"];
16593 [label="return ImmutableArray<MethodSymbol>.Empty; 446445"];
16594 [label="var ops1 = this.GetOperators(operatorName1); 446446"];
16595 [label="var ops2 = this.GetOperators(operatorName2); 446447"];
16596 [label="this.GetOperators(operatorName2) 446448"];
16597 [label="param GetOperators(string name) 446449"];
16598 [label="param GetOperators(this) 446450"];
16599 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446451"];
16600 [label="GetSimpleNonTypeMembers(name) 446452"];
16601 [label="param GetSimpleNonTypeMembers(string name) 446453"];
16602 [label="param GetSimpleNonTypeMembers(this) 446454"];
16603 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446455"];
16604 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446456"];
16605 [label="return GetMembers(name); 446457"];
16606 [label="return ImmutableArray<Symbol>.Empty; 446458"];
16607 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446459"];
16608 [label="return ImmutableArray<MethodSymbol>.Empty; 446460"];
16609 [label="var ops2 = this.GetOperators(operatorName2); 446461"];
16610 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446462"];
16611 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446463"];
16612 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446464"];
16613 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446465"];
16614 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 446466"];
16615 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446467"];
16616 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446468"];
16617 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446469"];
16618 [label="param CheckForUnmatchedOperator(string operatorName2) 446470"];
16619 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446471"];
16620 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446472"];
16621 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446473"];
16622 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446474"];
16623 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446475"];
16624 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446476"];
16625 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 446477"];
16626 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446478"];
16627 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446479"];
16628 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446480"];
16629 [label="param CheckForUnmatchedOperator(string operatorName2) 446481"];
16630 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446482"];
16631 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446483"];
16632 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.TrueOperatorName, WellKnownMemberNames.FalseOperatorName); 446484"];
16633 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 446485"];
16634 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 446486"];
16635 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName) 446487"];
16636 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446488"];
16637 [label="param CheckForUnmatchedOperator(string operatorName1) 446489"];
16638 [label="param CheckForUnmatchedOperator(string operatorName2) 446490"];
16639 [label="param CheckForUnmatchedOperator(this) 446491"];
16640 [label="var ops1 = this.GetOperators(operatorName1); 446492"];
16641 [label="this.GetOperators(operatorName1) 446493"];
16642 [label="param GetOperators(string name) 446494"];
16643 [label="param GetOperators(this) 446495"];
16644 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446496"];
16645 [label="GetSimpleNonTypeMembers(name) 446497"];
16646 [label="param GetSimpleNonTypeMembers(string name) 446498"];
16647 [label="param GetSimpleNonTypeMembers(this) 446499"];
16648 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446500"];
16649 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446501"];
16650 [label="return GetMembers(name); 446502"];
16651 [label="return ImmutableArray<Symbol>.Empty; 446503"];
16652 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446504"];
16653 [label="return ImmutableArray<MethodSymbol>.Empty; 446505"];
16654 [label="var ops2 = this.GetOperators(operatorName2); 446506"];
16655 [label="this.GetOperators(operatorName2) 446507"];
16656 [label="param GetOperators(string name) 446508"];
16657 [label="param GetOperators(this) 446509"];
16658 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446510"];
16659 [label="GetSimpleNonTypeMembers(name) 446511"];
16660 [label="param GetSimpleNonTypeMembers(string name) 446512"];
16661 [label="param GetSimpleNonTypeMembers(this) 446513"];
16662 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446514"];
16663 [label="return ImmutableArray<Symbol>.Empty; 446515"];
16664 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446516"];
16665 [label="return ImmutableArray<MethodSymbol>.Empty; 446517"];
16666 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446518"];
16667 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446519"];
16668 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446520"];
16669 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446521"];
16670 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 446522"];
16671 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446523"];
16672 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446524"];
16673 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446525"];
16674 [label="param CheckForUnmatchedOperator(string operatorName2) 446526"];
16675 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446527"];
16676 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446528"];
16677 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446529"];
16678 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446530"];
16679 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446531"];
16680 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446532"];
16681 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 446533"];
16682 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446534"];
16683 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446535"];
16684 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446536"];
16685 [label="param CheckForUnmatchedOperator(string operatorName2) 446537"];
16686 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446538"];
16687 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446539"];
16688 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.EqualityOperatorName, WellKnownMemberNames.InequalityOperatorName); 446540"];
16689 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 446541"];
16690 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 446542"];
16691 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName) 446543"];
16692 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446544"];
16693 [label="param CheckForUnmatchedOperator(string operatorName1) 446545"];
16694 [label="param CheckForUnmatchedOperator(string operatorName2) 446546"];
16695 [label="param CheckForUnmatchedOperator(this) 446547"];
16696 [label="var ops1 = this.GetOperators(operatorName1); 446548"];
16697 [label="this.GetOperators(operatorName1) 446549"];
16698 [label="param GetOperators(string name) 446550"];
16699 [label="param GetOperators(this) 446551"];
16700 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446552"];
16701 [label="GetSimpleNonTypeMembers(name) 446553"];
16702 [label="param GetSimpleNonTypeMembers(string name) 446554"];
16703 [label="param GetSimpleNonTypeMembers(this) 446555"];
16704 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446556"];
16705 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446557"];
16706 [label="return GetMembers(name); 446558"];
16707 [label="return ImmutableArray<Symbol>.Empty; 446559"];
16708 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446560"];
16709 [label="return ImmutableArray<MethodSymbol>.Empty; 446561"];
16710 [label="var ops2 = this.GetOperators(operatorName2); 446562"];
16711 [label="this.GetOperators(operatorName2) 446563"];
16712 [label="param GetOperators(string name) 446564"];
16713 [label="param GetOperators(this) 446565"];
16714 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446566"];
16715 [label="GetSimpleNonTypeMembers(name) 446567"];
16716 [label="param GetSimpleNonTypeMembers(string name) 446568"];
16717 [label="param GetSimpleNonTypeMembers(this) 446569"];
16718 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446570"];
16719 [label="return ImmutableArray<Symbol>.Empty; 446571"];
16720 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446572"];
16721 [label="return ImmutableArray<MethodSymbol>.Empty; 446573"];
16722 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446574"];
16723 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446575"];
16724 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446576"];
16725 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446577"];
16726 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 446578"];
16727 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446579"];
16728 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446580"];
16729 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446581"];
16730 [label="param CheckForUnmatchedOperator(string operatorName2) 446582"];
16731 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446583"];
16732 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446584"];
16733 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446585"];
16734 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446586"];
16735 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446587"];
16736 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446588"];
16737 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 446589"];
16738 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446590"];
16739 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446591"];
16740 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446592"];
16741 [label="param CheckForUnmatchedOperator(string operatorName2) 446593"];
16742 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446594"];
16743 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446595"];
16744 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOperatorName, WellKnownMemberNames.GreaterThanOperatorName); 446596"];
16745 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 446597"];
16746 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 446598"];
16747 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName) 446599"];
16748 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446600"];
16749 [label="param CheckForUnmatchedOperator(string operatorName1) 446601"];
16750 [label="param CheckForUnmatchedOperator(string operatorName2) 446602"];
16751 [label="param CheckForUnmatchedOperator(this) 446603"];
16752 [label="var ops1 = this.GetOperators(operatorName1); 446604"];
16753 [label="this.GetOperators(operatorName1) 446605"];
16754 [label="param GetOperators(string name) 446606"];
16755 [label="param GetOperators(this) 446607"];
16756 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446608"];
16757 [label="GetSimpleNonTypeMembers(name) 446609"];
16758 [label="param GetSimpleNonTypeMembers(string name) 446610"];
16759 [label="param GetSimpleNonTypeMembers(this) 446611"];
16760 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446612"];
16761 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446613"];
16762 [label="return GetMembers(name); 446614"];
16763 [label="return ImmutableArray<Symbol>.Empty; 446615"];
16764 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446616"];
16765 [label="return ImmutableArray<MethodSymbol>.Empty; 446617"];
16766 [label="var ops2 = this.GetOperators(operatorName2); 446618"];
16767 [label="this.GetOperators(operatorName2) 446619"];
16768 [label="param GetOperators(string name) 446620"];
16769 [label="param GetOperators(this) 446621"];
16770 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446622"];
16771 [label="GetSimpleNonTypeMembers(name) 446623"];
16772 [label="param GetSimpleNonTypeMembers(string name) 446624"];
16773 [label="param GetSimpleNonTypeMembers(this) 446625"];
16774 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446626"];
16775 [label="return ImmutableArray<Symbol>.Empty; 446627"];
16776 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446628"];
16777 [label="return ImmutableArray<MethodSymbol>.Empty; 446629"];
16778 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446630"];
16779 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446631"];
16780 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446632"];
16781 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446633"];
16782 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2) 446634"];
16783 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446635"];
16784 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446636"];
16785 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446637"];
16786 [label="param CheckForUnmatchedOperator(string operatorName2) 446638"];
16787 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446639"];
16788 [label="CheckForUnmatchedOperator(diagnostics, ops1, ops2, operatorName2); 446640"];
16789 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446641"];
16790 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446642"];
16791 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446643"];
16792 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446644"];
16793 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1) 446645"];
16794 [label="param CheckForUnmatchedOperator(DiagnosticBag diagnostics) 446646"];
16795 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops1) 446647"];
16796 [label="param CheckForUnmatchedOperator(ImmutableArray<MethodSymbol> ops2) 446648"];
16797 [label="param CheckForUnmatchedOperator(string operatorName2) 446649"];
16798 [label="foreach (var op1 in ops1)\n            {\n                bool foundMatch = false;\n                foreach (var op2 in ops2)\n                {\n                    foundMatch = DoOperatorsPair(op1, op2);\n                    if (foundMatch)\n                    {\n                        break;\n                    }\n                }\n\n                if (!foundMatch)\n                {\n                    // CS0216: The operator 'C.operator true(C)' requires a matching operator 'false' to also be defined\n                    diagnostics.Add(ErrorCode.ERR_OperatorNeedsMatch, op1.Locations[0], op1,\n                        SyntaxFacts.GetText(SyntaxFacts.GetOperatorKind(operatorName2)));\n                }\n            } 446650"];
16799 [label="CheckForUnmatchedOperator(diagnostics, ops2, ops1, operatorName1); 446651"];
16800 [label="CheckForUnmatchedOperator(diagnostics, WellKnownMemberNames.LessThanOrEqualOperatorName, WellKnownMemberNames.GreaterThanOrEqualOperatorName); 446652"];
16801 [label="CheckForEqualityAndGetHashCode(diagnostics); 446653"];
16802 [label="CheckForEqualityAndGetHashCode(diagnostics) 446654"];
16803 [label="param CheckForEqualityAndGetHashCode(DiagnosticBag diagnostics) 446655"];
16804 [label="param CheckForEqualityAndGetHashCode(this) 446656"];
16805 [label="if (this.IsInterfaceType())\n            {\n                // Interfaces are allowed to define Equals without GetHashCode if they want.\n                return;\n            } 446657"];
16806 [label="this.IsInterfaceType() 446658"];
16807 [label="param IsInterfaceType(this TypeSymbol type) 446659"];
16808 [label="RoslynDebug.Assert((object)type != null); 446660"];
16809 [label="RoslynDebug.Assert((object)type != null); 446661"];
16810 [label="type.Kind 446662"];
16811 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 446663"];
16812 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 446664"];
16813 [label="((NamedTypeSymbol)type).IsInterface 446665"];
16814 [label="get\n            {\n                // TypeKind is computed eagerly, so this is cheap.\n                return this.TypeKind == TypeKind.Interface;\n            } 446666"];
16815 [label="get { return (TypeKind)((_flags >> TypeKindOffset) & TypeKindMask); } 446667"];
16816 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 446668"];
16817 [label="return type.Kind == SymbolKind.NamedType && ((NamedTypeSymbol)type).IsInterface; 446669"];
16818 [label="IsRecord 446670"];
16819 [label="get\n            {\n                return this.declaration.Declarations[0].Kind == DeclarationKind.Record;\n            } 446671"];
16820 [label="return this.declaration.Declarations[0].Kind == DeclarationKind.Record; 446672"];
16821 [label="if (IsRecord)\n            {\n                // For records the warnings reported below are simply going to echo record specific errors,\n                // producing more noise.\n                return;\n            } 446673"];
16822 [label="bool hasOp = this.GetOperators(WellKnownMemberNames.EqualityOperatorName).Any() ||\n                this.GetOperators(WellKnownMemberNames.InequalityOperatorName).Any(); 446674"];
16823 [label="this.GetOperators(WellKnownMemberNames.EqualityOperatorName) 446675"];
16824 [label="param GetOperators(string name) 446676"];
16825 [label="param GetOperators(this) 446677"];
16826 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446678"];
16827 [label="GetSimpleNonTypeMembers(name) 446679"];
16828 [label="param GetSimpleNonTypeMembers(string name) 446680"];
16829 [label="param GetSimpleNonTypeMembers(this) 446681"];
16830 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446682"];
16831 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446683"];
16832 [label="return GetMembers(name); 446684"];
16833 [label="return ImmutableArray<Symbol>.Empty; 446685"];
16834 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446686"];
16835 [label="return ImmutableArray<MethodSymbol>.Empty; 446687"];
16836 [label="bool hasOp = this.GetOperators(WellKnownMemberNames.EqualityOperatorName).Any() ||\n                this.GetOperators(WellKnownMemberNames.InequalityOperatorName).Any(); 446688"];
16837 [label="this.GetOperators(WellKnownMemberNames.InequalityOperatorName) 446689"];
16838 [label="param GetOperators(string name) 446690"];
16839 [label="param GetOperators(this) 446691"];
16840 [label="ImmutableArray<Symbol> candidates = GetSimpleNonTypeMembers(name); 446692"];
16841 [label="GetSimpleNonTypeMembers(name) 446693"];
16842 [label="param GetSimpleNonTypeMembers(string name) 446694"];
16843 [label="param GetSimpleNonTypeMembers(this) 446695"];
16844 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446696"];
16845 [label="if (_lazyMembersDictionary != null || declaration.MemberNames.Contains(name) || declaration.Kind == DeclarationKind.Record)\n            {\n                return GetMembers(name);\n            } 446697"];
16846 [label="return ImmutableArray<Symbol>.Empty; 446698"];
16847 [label="if (candidates.IsEmpty)\n            {\n                return ImmutableArray<MethodSymbol>.Empty;\n            } 446699"];
16848 [label="return ImmutableArray<MethodSymbol>.Empty; 446700"];
16849 [label="bool overridesEquals = this.TypeOverridesObjectMethod('Equals'); 446701"];
16850 [label="this.TypeOverridesObjectMethod('Equals') 446702"];
16851 [label="param TypeOverridesObjectMethod(string name) 446703"];
16852 [label="param TypeOverridesObjectMethod(this) 446704"];
16853 [label="foreach (var method in this.GetMembers(name).OfType<MethodSymbol>())\n            {\n                if (method.IsOverride && method.GetConstructedLeastOverriddenMethod(this, requireSameReturnType: false).ContainingType.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Object)\n                {\n                    return true;\n                }\n            } 446705"];
16854 [label="this.GetMembers(name) 446706"];
16855 [label="param GetMembers(string name) 446707"];
16856 [label="param GetMembers(this) 446708"];
16857 [label="ImmutableArray<Symbol> members; 446709"];
16858 [label="members 446710"];
16859 [label="GetMembersByName() 446711"];
16860 [label="param GetMembersByName(this) 446712"];
16861 [label="param HasComplete(this) 446713"];
16862 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446714"];
16863 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446715"];
16864 [label="if (GetMembersByName().TryGetValue(name, out members))\n            {\n                return members;\n            } 446716"];
16865 [label="return ImmutableArray<Symbol>.Empty; 446717"];
16866 [label="foreach (var method in this.GetMembers(name).OfType<MethodSymbol>())\n            {\n                if (method.IsOverride && method.GetConstructedLeastOverriddenMethod(this, requireSameReturnType: false).ContainingType.SpecialType == Microsoft.CodeAnalysis.SpecialType.System_Object)\n                {\n                    return true;\n                }\n            } 446718"];
16867 [label="return false; 446719"];
16868 [label="bool overridesEquals = this.TypeOverridesObjectMethod('Equals'); 446720"];
16869 [label="if (hasOp || overridesEquals)\n            {\n                bool overridesGHC = this.TypeOverridesObjectMethod('GetHashCode');\n                if (overridesEquals && !overridesGHC)\n                {\n                    // CS0659: 'C' overrides Object.Equals(object o) but does not override Object.GetHashCode()\n                    diagnostics.Add(ErrorCode.WRN_EqualsWithoutGetHashCode, this.Locations[0], this);\n                }\n\n                if (hasOp && !overridesEquals)\n                {\n                    // CS0660: 'C' defines operator == or operator != but does not override Object.Equals(object o)\n                    diagnostics.Add(ErrorCode.WRN_EqualityOpWithoutEquals, this.Locations[0], this);\n                }\n\n                if (hasOp && !overridesGHC)\n                {\n                    // CS0661: 'C' defines operator == or operator != but does not override Object.GetHashCode()\n                    diagnostics.Add(ErrorCode.WRN_EqualityOpWithoutGetHashCode, this.Locations[0], this);\n                }\n            } 446721"];
16870 [label="CheckForEqualityAndGetHashCode(diagnostics); 446722"];
16871 [label="CheckForUnmatchedOperators(diagnostics); 446723"];
16872 [label="Locations 446724"];
16873 [label="get\n            {\n                return declaration.NameLocations.Cast<SourceLocation, Location>();\n            } 446725"];
16874 [label="return declaration.NameLocations.Cast<SourceLocation, Location>(); 446726"];
16875 [label="var location = Locations[0]; 446727"];
16876 [label="var location = Locations[0]; 446728"];
16877 [label="DeclaringCompilation 446729"];
16878 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 446730"];
16879 [label="this.Kind 446731"];
16880 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 446732"];
16881 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 446733"];
16882 [label="return _containingSymbol; 446734"];
16883 [label="var compilation = DeclaringCompilation; 446735"];
16884 [label="this.IsRefLikeType 446736"];
16885 [label="=> HasFlag(DeclarationModifiers.Ref) 446737"];
16886 [label="DeclarationModifiers.Ref 446738"];
16887 [label="HasFlag(DeclarationModifiers.Ref) 446739"];
16888 [label="param HasFlag(DeclarationModifiers flag) 446740"];
16889 [label="=> (_declModifiers & flag) != 0 446741"];
16890 [label="_declModifiers & flag 446742"];
16891 [label="if (this.IsRefLikeType)\n            {\n                compilation.EnsureIsByRefLikeAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 446743"];
16892 [label="this.IsReadOnly 446744"];
16893 [label="=> HasFlag(DeclarationModifiers.ReadOnly) 446745"];
16894 [label="DeclarationModifiers.ReadOnly 446746"];
16895 [label="HasFlag(DeclarationModifiers.ReadOnly) 446747"];
16896 [label="param HasFlag(DeclarationModifiers flag) 446748"];
16897 [label="=> (_declModifiers & flag) != 0 446749"];
16898 [label="_declModifiers & flag 446750"];
16899 [label="if (this.IsReadOnly)\n            {\n                compilation.EnsureIsReadOnlyAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 446751"];
16900 [label="BaseTypeNoUseSiteDiagnostics 446752"];
16901 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 446753"];
16902 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 446754"];
16903 [label="return _lazyBaseType; 446755"];
16904 [label="var baseType = BaseTypeNoUseSiteDiagnostics; 446756"];
16905 [label="GetInterfacesToEmit() 446757"];
16906 [label="param GetInterfacesToEmit(this) 446758"];
16907 [label="CalculateInterfacesToEmit() 446759"];
16908 [label="param CalculateInterfacesToEmit(this) 446760"];
16909 [label="this.IsDefinition 446761"];
16910 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 446762"];
16911 [label="Debug.Assert(this.IsDefinition); 446763"];
16912 [label="this.ContainingModule 446764"];
16913 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 446765"];
16914 [label="return _containingSymbol; 446766"];
16915 [label="Debug.Assert(this.ContainingModule is SourceModuleSymbol); 446767"];
16916 [label="ArrayBuilder<NamedTypeSymbol> builder = ArrayBuilder<NamedTypeSymbol>.GetInstance(); 446768"];
16917 [label="HashSet<NamedTypeSymbol> seen = null; 446769"];
16918 [label="InterfacesVisit(this, builder, ref seen); 446770"];
16919 [label="InterfacesVisit(this, builder, ref seen); 446771"];
16920 [label="InterfacesVisit(this, builder, ref seen); 446772"];
16921 [label="InterfacesVisit(this, builder, ref seen) 446773"];
16922 [label="param InterfacesVisit(NamedTypeSymbol namedType) 446774"];
16923 [label="param InterfacesVisit(ArrayBuilder<NamedTypeSymbol> builder) 446775"];
16924 [label="param InterfacesVisit(ref HashSet<NamedTypeSymbol> seen) 446776"];
16925 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 446777"];
16926 [label="namedType.InterfacesNoUseSiteDiagnostics() 446778"];
16927 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 446779"];
16928 [label="param InterfacesNoUseSiteDiagnostics(this) 446780"];
16929 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 446781"];
16930 [label="return _lazyInterfaces; 446782"];
16931 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 446783"];
16932 [label="InterfacesVisit(this, builder, ref seen); 446784"];
16933 [label="return builder.ToImmutableAndFree(); 446785"];
16934 [label="return CalculateInterfacesToEmit(); 446786"];
16935 [label="var interfaces = GetInterfacesToEmit(); 446787"];
16936 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 446788"];
16937 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 446789"];
16938 [label="if (hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces))\n            {\n                compilation.EnsureNativeIntegerAttributeExists(diagnostics, location, modifyCompilation: true);\n            } 446790"];
16939 [label="hasBaseTypeOrInterface(t => t.ContainsNativeInteger(), baseType, interfaces) 446791"];
16940 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 446792"];
16941 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 446793"];
16942 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 446794"];
16943 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 446795"];
16944 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446796"];
16945 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446797"];
16946 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446798"];
16947 [label="param ContainsNativeInteger(this TypeSymbol type) 446799"];
16948 [label="var result = type.VisitType((type, unused1, unused2) => type.IsNativeIntegerType, (object?)null, canDigThroughNullable: true); 446800"];
16949 [label="var result = type.VisitType((type, unused1, unused2) => type.IsNativeIntegerType, (object?)null, canDigThroughNullable: true); 446801"];
16950 [label="type.VisitType((type, unused1, unused2) => type.IsNativeIntegerType, (object?)null, canDigThroughNullable: true) 446802"];
16951 [label="param VisitType(this TypeSymbol type) 446803"];
16952 [label="param VisitType(Func<TypeSymbol, T, bool, bool> predicate) 446804"];
16953 [label="param VisitType(T arg) 446805"];
16954 [label="param VisitType(bool canDigThroughNullable = false) 446806"];
16955 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 446807"];
16956 [label="param VisitType(bool canDigThroughNullable = false) 446808"];
16957 [label="param VisitType(bool useDefaultType = false) 446809"];
16958 [label="typeWithAnnotationsOpt.HasType 446810"];
16959 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 446811"];
16960 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 446812"];
16961 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 446813"];
16962 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 446814"];
16963 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 446815"];
16964 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 446816"];
16965 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 446817"];
16966 [label="current.TypeKind 446818"];
16967 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 446819"];
16968 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 446820"];
16969 [label="current.ContainingType 446821"];
16970 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 446822"];
16971 [label="return _container as NamedTypeSymbol; 446823"];
16972 [label="var containingType = current.ContainingType; 446824"];
16973 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 446825"];
16974 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 446826"];
16975 [label="if (typePredicate != null)\n                {\n                    if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    }\n                } 446827"];
16976 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 446828"];
16977 [label="=> false 446829"];
16978 [label="false 446830"];
16979 [label="if (typePredicate(current, arg, isNestedNamedType))\n                    {\n                        return current;\n                    } 446831"];
16980 [label="TypeWithAnnotations next; 446832"];
16981 [label="next 446833"];
16982 [label="current.TypeKind 446834"];
16983 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 446835"];
16984 [label="TypeKind result = _lazyKind; 446836"];
16985 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Dynamic:\n                    case TypeKind.TypeParameter:\n                    case TypeKind.Submission:\n                    case TypeKind.Enum:\n                        return null;\n\n                    case TypeKind.Error:\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Delegate:\n                        var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics;\n                        if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        }\n\n                        int i;\n                        for (i = 0; i < typeArguments.Length - 1; i++)\n                        {\n                            // Let's try to avoid early resolution of nullable types\n                            (TypeWithAnnotations nextTypeWithAnnotations, TypeSymbol? nextType) = getNextIterationElements(typeArguments[i], canDigThroughNullable);\n                            var result = VisitType(\n                                typeWithAnnotationsOpt: nextTypeWithAnnotations,\n                                type: nextType,\n                                typeWithAnnotationsPredicate,\n                                typePredicate,\n                                arg,\n                                canDigThroughNullable,\n                                useDefaultType);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n                        }\n\n                        next = typeArguments[i];\n                        break;\n\n                    case TypeKind.Array:\n                        next = ((ArrayTypeSymbol)current).ElementTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.Pointer:\n                        next = ((PointerTypeSymbol)current).PointedAtTypeWithAnnotations;\n                        break;\n\n                    case TypeKind.FunctionPointer:\n                        {\n                            var result = visitFunctionPointerType((FunctionPointerTypeSymbol)current, typeWithAnnotationsPredicate, typePredicate, arg, useDefaultType, canDigThroughNullable, out next);\n                            if (result is object)\n                            {\n                                return result;\n                            }\n\n                            break;\n                        }\n\n                    default:\n                        throw ExceptionUtilities.UnexpectedValue(current.TypeKind);\n                } 446837"];
16986 [label="((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 446838"];
16987 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 446839"];
16988 [label="return ImmutableArray<TypeWithAnnotations>.Empty; 446840"];
16989 [label="var typeArguments = ((NamedTypeSymbol)current).TypeArgumentsWithAnnotationsNoUseSiteDiagnostics; 446841"];
16990 [label="if (typeArguments.IsEmpty)\n                        {\n                            return null;\n                        } 446842"];
16991 [label="return null; 446843"];
16992 [label="return result is object; 446844"];
16993 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446845"];
16994 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446846"];
16995 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 446847"];
16996 [label="if (compilation.ShouldEmitNullableAttributes(this))\n            {\n                if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                }\n\n                if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                }\n            } 446848"];
16997 [label="compilation.ShouldEmitNullableAttributes(this) 446849"];
16998 [label="param ShouldEmitNullableAttributes(Symbol symbol) 446850"];
16999 [label="param ShouldEmitNullableAttributes(this) 446851"];
17000 [label="RoslynDebug.Assert(symbol is object); 446852"];
17001 [label="RoslynDebug.Assert(symbol is object); 446853"];
17002 [label="symbol.IsDefinition 446854"];
17003 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 446855"];
17004 [label="Debug.Assert(symbol.IsDefinition); 446856"];
17005 [label="symbol.ContainingModule 446857"];
17006 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 446858"];
17007 [label="return _containingSymbol; 446859"];
17008 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446860"];
17009 [label="SourceModule 446861"];
17010 [label="get\n            {\n                return Assembly.Modules[0];\n            } 446862"];
17011 [label="Assembly 446863"];
17012 [label="get\n            {\n                return SourceAssembly;\n            } 446864"];
17013 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 446865"];
17014 [label="return _referenceManager; 446866"];
17015 [label="GetBoundReferenceManager(); 446867"];
17016 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 446868"];
17017 [label="return Assembly.Modules[0]; 446869"];
17018 [label="Assembly.Modules 446870"];
17019 [label="get\n            {\n                return _modules;\n            } 446871"];
17020 [label="return Assembly.Modules[0]; 446872"];
17021 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446873"];
17022 [label="symbol.ContainingModule != SourceModule 446874"];
17023 [label="param !=(Symbol left) 446875"];
17024 [label="param !=(Symbol right) 446876"];
17025 [label="if (right is null)\n            {\n                return left is object;\n            } 446877"];
17026 [label="return (object)left != (object)right && !right.Equals(left); 446878"];
17027 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446879"];
17028 [label="EmitNullablePublicOnly 446880"];
17029 [label="get\n            {\n                if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                }\n                return _lazyEmitNullablePublicOnly.Value();\n            } 446881"];
17030 [label="if (!_lazyEmitNullablePublicOnly.HasValue())\n                {\n                    // Lafhis\n                    var firstSt = SyntaxTrees.FirstOrDefault();\n                    bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true;\n                    _lazyEmitNullablePublicOnly = value.ToThreeState();\n                } 446882"];
17031 [label="SyntaxTrees 446883"];
17032 [label="var firstSt = SyntaxTrees.FirstOrDefault(); 446884"];
17033 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 446885"];
17034 [label="bool value = firstSt != null && firstSt.Options != null &&\n                        firstSt.Options.Features != null && \n                        firstSt.Options.Features.ContainsKey('nullablePublicOnly') == true; 446886"];
17035 [label="_lazyEmitNullablePublicOnly = value.ToThreeState(); 446887"];
17036 [label="_lazyEmitNullablePublicOnly 446888"];
17037 [label="return _lazyEmitNullablePublicOnly.Value(); 446889"];
17038 [label="if (!EmitNullablePublicOnly)\n            {\n                return true;\n            } 446890"];
17039 [label="return true; 446891"];
17040 [label="if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 446892"];
17041 [label="ShouldEmitNullableContextValue(out _) 446893"];
17042 [label="param ShouldEmitNullableContextValue(out byte value) 446894"];
17043 [label="param ShouldEmitNullableContextValue(this) 446895"];
17044 [label="GetLocalNullableContextValue() 446896"];
17045 [label="param GetLocalNullableContextValue(this) 446897"];
17046 [label="byte? value; 446898"];
17047 [label="if (!_flags.TryGetNullableContext(out value))\n            {\n                value = ComputeNullableContextValue();\n                _flags.SetNullableContext(value);\n            } 446899"];
17048 [label="_flags.TryGetNullableContext(out value) 446900"];
17049 [label="param TryGetNullableContext(out byte? value) 446901"];
17050 [label="param TryGetNullableContext(this) 446902"];
17051 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 446903"];
17052 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 446904"];
17053 [label="return ((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value); 446905"];
17054 [label="((NullableContextKind)((_flags >> NullableContextOffset) & NullableContextMask)).TryGetByte(out value) 446906"];
17055 [label="param TryGetByte(this NullableContextKind kind) 446907"];
17056 [label="param TryGetByte(out byte? value) 446908"];
17057 [label="value = null; 446909"];
17058 [label="if (!_flags.TryGetNullableContext(out value))\n            {\n                value = ComputeNullableContextValue();\n                _flags.SetNullableContext(value);\n            } 446910"];
17059 [label="ComputeNullableContextValue() 446911"];
17060 [label="param ComputeNullableContextValue(this) 446912"];
17061 [label="DeclaringCompilation 446913"];
17062 [label="get\n            {\n                switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                }\n\n                var sourceModuleSymbol = this.ContainingModule as SourceModuleSymbol;\n                return (object)sourceModuleSymbol == null ? null : sourceModuleSymbol.DeclaringCompilation;\n            } 446914"];
17063 [label="this.Kind 446915"];
17064 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 446916"];
17065 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 446917"];
17066 [label="var compilation = DeclaringCompilation; 446918"];
17067 [label="if (!compilation.ShouldEmitNullableAttributes(this))\n            {\n                return null;\n            } 446919"];
17068 [label="compilation.ShouldEmitNullableAttributes(this) 446920"];
17069 [label="param ShouldEmitNullableAttributes(Symbol symbol) 446921"];
17070 [label="param ShouldEmitNullableAttributes(this) 446922"];
17071 [label="symbol.IsDefinition 446923"];
17072 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 446924"];
17073 [label="Debug.Assert(symbol.IsDefinition); 446925"];
17074 [label="symbol.ContainingModule 446926"];
17075 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 446927"];
17076 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446928"];
17077 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 446929"];
17078 [label="return _referenceManager; 446930"];
17079 [label="GetBoundReferenceManager(); 446931"];
17080 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 446932"];
17081 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446933"];
17082 [label="symbol.ContainingModule != SourceModule 446934"];
17083 [label="param !=(Symbol left) 446935"];
17084 [label="param !=(Symbol right) 446936"];
17085 [label="if (right is null)\n            {\n                return left is object;\n            } 446937"];
17086 [label="return (object)left != (object)right && !right.Equals(left); 446938"];
17087 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 446939"];
17088 [label="var builder = new MostCommonNullableValueBuilder(); 446940"];
17089 [label="new MostCommonNullableValueBuilder() 446941"];
17090 [label="BaseTypeNoUseSiteDiagnostics 446942"];
17091 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 446943"];
17092 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 446944"];
17093 [label="return _lazyBaseType; 446945"];
17094 [label="var baseType = BaseTypeNoUseSiteDiagnostics; 446946"];
17095 [label="if (baseType is object)\n            {\n                builder.AddValue(TypeWithAnnotations.Create(baseType));\n            } 446947"];
17096 [label="builder.AddValue(TypeWithAnnotations.Create(baseType)); 446948"];
17097 [label="builder.AddValue(TypeWithAnnotations.Create(baseType)); 446949"];
17098 [label="TypeWithAnnotations.Create(baseType) 446950"];
17099 [label="param Create(TypeSymbol typeSymbol) 446951"];
17100 [label="param Create(NullableAnnotation nullableAnnotation = NullableAnnotation.Oblivious) 446952"];
17101 [label="param Create(ImmutableArray<CustomModifier> customModifiers = default) 446953"];
17102 [label="if (typeSymbol is null && nullableAnnotation == 0)\n            {\n                return default;\n            } 446954"];
17103 [label="Debug.Assert(nullableAnnotation != NullableAnnotation.Ignored || typeSymbol.IsTypeParameter()); 446955"];
17104 [label="switch (nullableAnnotation)\n            {\n                case NullableAnnotation.Oblivious:\n                case NullableAnnotation.NotAnnotated:\n                    // LAFHIS\n                    if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    }\n                    break;\n            } 446956"];
17105 [label="if (typeSymbol is not null && typeSymbol.IsNullableType())\n                    {\n                        // int?, T? where T : struct (add annotation)\n                        nullableAnnotation = NullableAnnotation.Annotated;\n                    } 446957"];
17106 [label="typeSymbol.IsNullableType() 446958"];
17107 [label="param IsNullableType(this TypeSymbol type) 446959"];
17108 [label="type.OriginalDefinition 446960"];
17109 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 446961"];
17110 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 446962"];
17111 [label="type.OriginalDefinition.SpecialType 446963"];
17112 [label="get\n            {\n                return _corTypeId;\n            } 446964"];
17113 [label="var a1 = defaultType is null; 446965"];
17114 [label="!a1 446966"];
17115 [label="var a2 = !a1 ? defaultType.IsNullableType() : true; 446967"];
17116 [label="defaultType.IsNullableType() 446968"];
17117 [label="param IsNullableType(this TypeSymbol type) 446969"];
17118 [label="type.OriginalDefinition 446970"];
17119 [label="get\n            {\n                return OriginalTypeSymbolDefinition;\n            } 446971"];
17120 [label="return type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T; 446972"];
17121 [label="type.OriginalDefinition.SpecialType 446973"];
17122 [label="get\n            {\n                return _corTypeId;\n            } 446974"];
17123 [label="var a3 = nullableAnnotation == NullableAnnotation.Annotated; 446975"];
17124 [label="Debug.Assert(a1 || a2 != true || a3); 446976"];
17125 [label="Debug.Assert(a1 || a2 != true || a3); 446977"];
17126 [label="Debug.Assert(extensions != null); 446978"];
17127 [label="Debug.Assert(extensions != null); 446979"];
17128 [label="builder.AddValue(TypeWithAnnotations.Create(baseType)); 446980"];
17129 [label="builder.AddValue(TypeWithAnnotations.Create(baseType)); 446981"];
17130 [label="param AddNullableTransforms(ArrayBuilder<byte> transforms) 446982"];
17131 [label="param AddNullableTransforms(this) 446983"];
17132 [label="AddNullableTransforms(this, transforms); 446984"];
17133 [label="AddNullableTransforms(this, transforms); 446985"];
17134 [label="AddNullableTransforms(this, transforms) 446986"];
17135 [label="param AddNullableTransforms(TypeWithAnnotations typeWithAnnotations) 446987"];
17136 [label="param AddNullableTransforms(ArrayBuilder<byte> transforms) 446988"];
17137 [label="while (true)\n            {\n                var type = typeWithAnnotations.Type;\n\n                if (!IsNonGenericValueType(type))\n                {\n                    var annotation = typeWithAnnotations.NullableAnnotation;\n                    byte flag;\n                    if (annotation.IsOblivious() || type.IsValueType)\n                    {\n                        flag = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    }\n                    else if (annotation.IsAnnotated())\n                    {\n                        flag = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    }\n                    else\n                    {\n                        flag = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    }\n                    transforms.Add(flag);\n                }\n\n                if (type.TypeKind != TypeKind.Array)\n                {\n                    type.AddNullableTransforms(transforms);\n                    return;\n                }\n\n                // Avoid recursion to allow for deeply-nested arrays.\n                typeWithAnnotations = ((ArrayTypeSymbol)type).ElementTypeWithAnnotations;\n            } 446989"];
17138 [label="typeWithAnnotations.Type 446990"];
17139 [label="=> _extensions?.GetResolvedType(DefaultType) 446991"];
17140 [label="=> defaultType 446992"];
17141 [label="var type = typeWithAnnotations.Type; 446993"];
17142 [label="if (!IsNonGenericValueType(type))\n                {\n                    var annotation = typeWithAnnotations.NullableAnnotation;\n                    byte flag;\n                    if (annotation.IsOblivious() || type.IsValueType)\n                    {\n                        flag = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    }\n                    else if (annotation.IsAnnotated())\n                    {\n                        flag = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    }\n                    else\n                    {\n                        flag = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    }\n                    transforms.Add(flag);\n                } 446994"];
17143 [label="IsNonGenericValueType(type) 446995"];
17144 [label="param IsNonGenericValueType(TypeSymbol type) 446996"];
17145 [label="var namedType = type as NamedTypeSymbol; 446997"];
17146 [label="if (namedType is null)\n            {\n                return false;\n            } 446998"];
17147 [label="namedType.IsGenericType 446999"];
17148 [label="get\n            {\n                for (var current = this; !ReferenceEquals(current, null); current = current.ContainingType)\n                {\n                    if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            } 447000"];
17149 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 447001"];
17150 [label="if (current.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics.Length != 0)\n                    {\n                        return true;\n                    } 447002"];
17151 [label="current.ContainingType 447003"];
17152 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 447004"];
17153 [label="return _container as NamedTypeSymbol; 447005"];
17154 [label="return false; 447006"];
17155 [label="if (namedType.IsGenericType)\n            {\n                return type.IsNullableType();\n            } 447007"];
17156 [label="type.IsValueType 447008"];
17157 [label="get\n            {\n                var kind = TypeKind;\n                return kind == TypeKind.Struct || kind == TypeKind.Enum;\n            } 447009"];
17158 [label="TypeKind 447010"];
17159 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 447011"];
17160 [label="var kind = TypeKind; 447012"];
17161 [label="return kind == TypeKind.Struct || kind == TypeKind.Enum; 447013"];
17162 [label="return type.IsValueType; 447014"];
17163 [label="var annotation = typeWithAnnotations.NullableAnnotation; 447015"];
17164 [label="byte flag; 447016"];
17165 [label="1 447017"];
17166 [label="NotAnnotatedAttributeValue = 1 447018"];
17167 [label="2 447019"];
17168 [label="AnnotatedAttributeValue = 2 447020"];
17169 [label="0 447021"];
17170 [label="ObliviousAttributeValue = 0 447022"];
17171 [label="if (annotation.IsOblivious() || type.IsValueType)\n                    {\n                        flag = NullableAnnotationExtensions.ObliviousAttributeValue;\n                    }\n                    else if (annotation.IsAnnotated())\n                    {\n                        flag = NullableAnnotationExtensions.AnnotatedAttributeValue;\n                    }\n                    else\n                    {\n                        flag = NullableAnnotationExtensions.NotAnnotatedAttributeValue;\n                    } 447023"];
17172 [label="annotation.IsOblivious() 447024"];
17173 [label="param IsOblivious(this NullableAnnotation annotation) 447025"];
17174 [label="annotation == NullableAnnotation.Oblivious 447026"];
17175 [label="flag = NullableAnnotationExtensions.ObliviousAttributeValue; 447027"];
17176 [label="transforms.Add(flag); 447028"];
17177 [label="transforms.Add(flag); 447029"];
17178 [label="type.TypeKind 447030"];
17179 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 447031"];
17180 [label="TypeKind result = _lazyKind; 447032"];
17181 [label="if (type.TypeKind != TypeKind.Array)\n                {\n                    type.AddNullableTransforms(transforms);\n                    return;\n                } 447033"];
17182 [label="type.AddNullableTransforms(transforms); 447034"];
17183 [label="type.AddNullableTransforms(transforms) 447035"];
17184 [label="param AddNullableTransforms(ArrayBuilder<byte> transforms) 447036"];
17185 [label="param AddNullableTransforms(this) 447037"];
17186 [label="ContainingType 447038"];
17187 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 447039"];
17188 [label="return _container as NamedTypeSymbol; 447040"];
17189 [label="ContainingType?.AddNullableTransforms(transforms); 447041"];
17190 [label="this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics 447042"];
17191 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 447043"];
17192 [label="foreach (TypeWithAnnotations arg in this.TypeArgumentsWithAnnotationsNoUseSiteDiagnostics)\n            {\n                arg.AddNullableTransforms(transforms);\n            } 447044"];
17193 [label="type.AddNullableTransforms(transforms); 447045"];
17194 [label="return; 447046"];
17195 [label="AddNullableTransforms(this, transforms); 447047"];
17196 [label="GetInterfacesToEmit() 447048"];
17197 [label="param GetInterfacesToEmit(this) 447049"];
17198 [label="param CalculateInterfacesToEmit(this) 447050"];
17199 [label="this.IsDefinition 447051"];
17200 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 447052"];
17201 [label="Debug.Assert(this.IsDefinition); 447053"];
17202 [label="this.ContainingModule 447054"];
17203 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 447055"];
17204 [label="return _containingSymbol; 447056"];
17205 [label="Debug.Assert(this.ContainingModule is SourceModuleSymbol); 447057"];
17206 [label="HashSet<NamedTypeSymbol> seen = null; 447058"];
17207 [label="InterfacesVisit(this, builder, ref seen); 447059"];
17208 [label="InterfacesVisit(this, builder, ref seen); 447060"];
17209 [label="InterfacesVisit(this, builder, ref seen); 447061"];
17210 [label="InterfacesVisit(this, builder, ref seen) 447062"];
17211 [label="param InterfacesVisit(NamedTypeSymbol namedType) 447063"];
17212 [label="param InterfacesVisit(ArrayBuilder<NamedTypeSymbol> builder) 447064"];
17213 [label="param InterfacesVisit(ref HashSet<NamedTypeSymbol> seen) 447065"];
17214 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 447066"];
17215 [label="namedType.InterfacesNoUseSiteDiagnostics() 447067"];
17216 [label="param InterfacesNoUseSiteDiagnostics(ConsList<TypeSymbol> basesBeingResolved) 447068"];
17217 [label="param InterfacesNoUseSiteDiagnostics(this) 447069"];
17218 [label="if (_lazyInterfaces.IsDefault)\n            {\n                if (basesBeingResolved != null && basesBeingResolved.ContainsReference(this.OriginalDefinition))\n                {\n                    return ImmutableArray<NamedTypeSymbol>.Empty;\n                }\n\n                var diagnostics = DiagnosticBag.GetInstance();\n                var acyclicInterfaces = MakeAcyclicInterfaces(basesBeingResolved, diagnostics);\n                if (ImmutableInterlocked.InterlockedCompareExchange(ref _lazyInterfaces, acyclicInterfaces, default(ImmutableArray<NamedTypeSymbol>)).IsDefault)\n                {\n                    AddDeclarationDiagnostics(diagnostics);\n                }\n                diagnostics.Free();\n            } 447070"];
17219 [label="return _lazyInterfaces; 447071"];
17220 [label="foreach (NamedTypeSymbol @interface in namedType.InterfacesNoUseSiteDiagnostics())\n            {\n                if (seen == null)\n                {\n                    // Don't allocate until we see at least one interface.\n                    seen = new HashSet<NamedTypeSymbol>(Symbols.SymbolEqualityComparer.CLRSignature);\n                }\n                if (seen.Add(@interface))\n                {\n                    builder.Add(@interface);\n                    InterfacesVisit(@interface, builder, ref seen);\n                }\n            } 447072"];
17221 [label="foreach (var @interface in GetInterfacesToEmit())\n            {\n                builder.AddValue(TypeWithAnnotations.Create(@interface));\n            } 447073"];
17222 [label="TypeParameters 447074"];
17223 [label="get\n            {\n                if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                }\n\n                return _lazyTypeParameters;\n            } 447075"];
17224 [label="if (_lazyTypeParameters.IsDefault)\n                {\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    if (ImmutableInterlocked.InterlockedInitialize(ref _lazyTypeParameters, MakeTypeParameters(diagnostics)))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n\n                    diagnostics.Free();\n                } 447076"];
17225 [label="return _lazyTypeParameters; 447077"];
17226 [label="foreach (var typeParameter in TypeParameters)\n            {\n                typeParameter.GetCommonNullableValues(compilation, ref builder);\n            } 447078"];
17227 [label="GetMembersUnordered() 447079"];
17228 [label="param GetMembersUnordered(this) 447080"];
17229 [label="var result = _lazyMembersFlattened; 447081"];
17230 [label="foreach (var member in GetMembersUnordered())\n            {\n                member.GetCommonNullableValues(compilation, ref builder);\n            } 447082"];
17231 [label="member.GetCommonNullableValues(compilation, ref builder); 447083"];
17232 [label="member.GetCommonNullableValues(compilation, ref builder); 447084"];
17233 [label="member.GetCommonNullableValues(compilation, ref builder) 447085"];
17234 [label="param GetCommonNullableValues(CSharpCompilation compilation) 447086"];
17235 [label="param GetCommonNullableValues(ref MostCommonNullableValueBuilder builder) 447087"];
17236 [label="param GetCommonNullableValues(this) 447088"];
17237 [label="this.Kind 447089"];
17238 [label="get\n            {\n                return SymbolKind.Method;\n            } 447090"];
17239 [label="return SymbolKind.Method; 447091"];
17240 [label="switch (this.Kind)\n            {\n                case SymbolKind.NamedType:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(this.GetLocalNullableContextValue());\n                    }\n                    break;\n                case SymbolKind.Event:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(((EventSymbol)this).TypeWithAnnotations);\n                    }\n                    break;\n                case SymbolKind.Field:\n                    var field = (FieldSymbol)this;\n                    if (field is TupleElementFieldSymbol tupleElement)\n                    {\n                        field = tupleElement.TupleUnderlyingField;\n                    }\n\n                    if (compilation.ShouldEmitNullableAttributes(field))\n                    {\n                        builder.AddValue(field.TypeWithAnnotations);\n                    }\n                    break;\n                case SymbolKind.Method:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(this.GetLocalNullableContextValue());\n                    }\n                    break;\n                case SymbolKind.Property:\n                    if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(((PropertySymbol)this).TypeWithAnnotations);\n                        // Attributes are not emitted for property parameters.\n                    }\n                    break;\n                case SymbolKind.Parameter:\n                    builder.AddValue(((ParameterSymbol)this).TypeWithAnnotations);\n                    break;\n                case SymbolKind.TypeParameter:\n                    if (this is SourceTypeParameterSymbolBase typeParameter)\n                    {\n                        builder.AddValue(typeParameter.GetSynthesizedNullableAttributeValue());\n                        foreach (var constraintType in typeParameter.ConstraintTypesNoUseSiteDiagnostics)\n                        {\n                            builder.AddValue(constraintType);\n                        }\n                    }\n                    break;\n            } 447092"];
17241 [label="if (compilation.ShouldEmitNullableAttributes(this))\n                    {\n                        builder.AddValue(this.GetLocalNullableContextValue());\n                    } 447093"];
17242 [label="compilation.ShouldEmitNullableAttributes(this) 447094"];
17243 [label="param ShouldEmitNullableAttributes(Symbol symbol) 447095"];
17244 [label="param ShouldEmitNullableAttributes(this) 447096"];
17245 [label="symbol.IsDefinition 447097"];
17246 [label="get\n            {\n                return (object)this == (object)OriginalDefinition;\n            } 447098"];
17247 [label="get\n            {\n                return this.OriginalDefinition;\n            } 447099"];
17248 [label="this.OriginalDefinition 447100"];
17249 [label="get\n            {\n                return this;\n            } 447101"];
17250 [label="return this; 447102"];
17251 [label="return this.OriginalDefinition; 447103"];
17252 [label="Debug.Assert(symbol.IsDefinition); 447104"];
17253 [label="symbol.ContainingModule 447105"];
17254 [label="get\n            {\n                // Default implementation gets the containers module.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingModule : null;\n            } 447106"];
17255 [label="get { return _containingType; } 447107"];
17256 [label="return _containingType; 447108"];
17257 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 447109"];
17258 [label="if (_lazyAssemblySymbol is null)\n            {\n                _referenceManager.CreateSourceAssemblyForCompilation(this);\n                Debug.Assert(_lazyAssemblySymbol is object);\n            } 447110"];
17259 [label="return _referenceManager; 447111"];
17260 [label="GetBoundReferenceManager(); 447112"];
17261 [label="RoslynDebug.Assert(_lazyAssemblySymbol is object); 447113"];
17262 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 447114"];
17263 [label="symbol.ContainingModule != SourceModule 447115"];
17264 [label="param !=(Symbol left) 447116"];
17265 [label="param !=(Symbol right) 447117"];
17266 [label="if (right is null)\n            {\n                return left is object;\n            } 447118"];
17267 [label="return (object)left != (object)right && !right.Equals(left); 447119"];
17268 [label="if (symbol.ContainingModule != SourceModule)\n            {\n                return false;\n            } 447120"];
17269 [label="this.GetLocalNullableContextValue() 447121"];
17270 [label="param GetLocalNullableContextValue(this) 447122"];
17271 [label="builder.AddValue(this.GetLocalNullableContextValue()); 447123"];
17272 [label="builder.AddValue(this.GetLocalNullableContextValue()); 447124"];
17273 [label="member.GetCommonNullableValues(compilation, ref builder); 447125"];
17274 [label="return builder.MostCommonValue; 447126"];
17275 [label="value = ComputeNullableContextValue(); 447127"];
17276 [label="_flags.SetNullableContext(value); 447128"];
17277 [label="_flags.SetNullableContext(value) 447129"];
17278 [label="param SetNullableContext(byte? value) 447130"];
17279 [label="param SetNullableContext(this) 447131"];
17280 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 447132"];
17281 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 447133"];
17282 [label="value.ToNullableContextFlags() 447134"];
17283 [label="param ToNullableContextFlags(this byte? value) 447135"];
17284 [label="return NullableContextKind.Oblivious; 447136"];
17285 [label="return ThreadSafeFlagOperations.Set(ref _flags, (((int)value.ToNullableContextFlags() & NullableContextMask) << NullableContextOffset)); 447137"];
17286 [label="return value; 447138"];
17287 [label="byte? localValue = GetLocalNullableContextValue(); 447139"];
17288 [label="if (localValue == null)\n            {\n                value = 0;\n                return false;\n            } 447140"];
17289 [label="if (localValue == null)\n            {\n                value = 0;\n                return false;\n            } 447141"];
17290 [label="value = localValue.GetValueOrDefault(); 447142"];
17291 [label="ContainingSymbol 447143"];
17292 [label="get\n            {\n                return _containingSymbol;\n            } 447144"];
17293 [label="return _containingSymbol; 447145"];
17294 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 447146"];
17295 [label=".GetNullableContextValue() 447147"];
17296 [label="param GetNullableContextValue(this) 447148"];
17297 [label="param GetLocalNullableContextValue(this) 447149"];
17298 [label="=> _container 447150"];
17299 [label="_container 447151"];
17300 [label="param GetLocalNullableContextValue(this) 447152"];
17301 [label="get\n            {\n                return _assemblySymbol;\n            } 447153"];
17302 [label="return _assemblySymbol; 447154"];
17303 [label="param GetLocalNullableContextValue(this) 447155"];
17304 [label="get\n            {\n                return null;\n            } 447156"];
17305 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 447157"];
17306 [label="byte containingValue = ContainingSymbol?.GetNullableContextValue() ?? 0; 447158"];
17307 [label="return value != containingValue; 447159"];
17308 [label="if (ShouldEmitNullableContextValue(out _))\n                {\n                    compilation.EnsureNullableContextAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 447160"];
17309 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 447161"];
17310 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 447162"];
17311 [label="if (hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces))\n                {\n                    compilation.EnsureNullableAttributeExists(diagnostics, location, modifyCompilation: true);\n                } 447163"];
17312 [label="hasBaseTypeOrInterface(t => t.NeedsNullableAttribute(), baseType, interfaces) 447164"];
17313 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 447165"];
17314 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 447166"];
17315 [label="bool hasBaseTypeOrInterface(Func<NamedTypeSymbol, bool> predicate, NamedTypeSymbol baseTy, ImmutableArray<NamedTypeSymbol> inter)\n            {\n                return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate);\n            } 447167"];
17316 [label="return ((object)baseTy != null && predicate(baseTy)) ||\n                    inter.Any(predicate); 447168"];
17317 [label="param NeedsNullableAttribute(this) 447169"];
17318 [label="return TypeWithAnnotations.NeedsNullableAttribute(typeWithAnnotationsOpt: default, typeOpt: this); 447170"];
17319 [label="return TypeWithAnnotations.NeedsNullableAttribute(typeWithAnnotationsOpt: default, typeOpt: this); 447171"];
17320 [label="TypeWithAnnotations.NeedsNullableAttribute(typeWithAnnotationsOpt: default, typeOpt: this) 447172"];
17321 [label="param NeedsNullableAttribute(TypeWithAnnotations typeWithAnnotationsOpt) 447173"];
17322 [label="param NeedsNullableAttribute(TypeSymbol typeOpt) 447174"];
17323 [label="var type = TypeSymbolExtensions.VisitType(\n                typeWithAnnotationsOpt,\n                typeOpt,\n                typeWithAnnotationsPredicate: (t, a, b) => t.NullableAnnotation != NullableAnnotation.Oblivious && !t.Type.IsErrorType() && !t.Type.IsValueType,\n                typePredicate: null,\n                arg: (object)null); 447175"];
17324 [label="var type = TypeSymbolExtensions.VisitType(\n                typeWithAnnotationsOpt,\n                typeOpt,\n                typeWithAnnotationsPredicate: (t, a, b) => t.NullableAnnotation != NullableAnnotation.Oblivious && !t.Type.IsErrorType() && !t.Type.IsValueType,\n                typePredicate: null,\n                arg: (object)null); 447176"];
17325 [label="var type = TypeSymbolExtensions.VisitType(\n                typeWithAnnotationsOpt,\n                typeOpt,\n                typeWithAnnotationsPredicate: (t, a, b) => t.NullableAnnotation != NullableAnnotation.Oblivious && !t.Type.IsErrorType() && !t.Type.IsValueType,\n                typePredicate: null,\n                arg: (object)null); 447177"];
17326 [label="var type = TypeSymbolExtensions.VisitType(\n                typeWithAnnotationsOpt,\n                typeOpt,\n                typeWithAnnotationsPredicate: (t, a, b) => t.NullableAnnotation != NullableAnnotation.Oblivious && !t.Type.IsErrorType() && !t.Type.IsValueType,\n                typePredicate: null,\n                arg: (object)null); 447178"];
17327 [label="TypeSymbolExtensions.VisitType(\n                typeWithAnnotationsOpt,\n                typeOpt,\n                typeWithAnnotationsPredicate: (t, a, b) => t.NullableAnnotation != NullableAnnotation.Oblivious && !t.Type.IsErrorType() && !t.Type.IsValueType,\n                typePredicate: null,\n                arg: (object)null) 447179"];
17328 [label="param VisitType(this TypeWithAnnotations typeWithAnnotationsOpt) 447180"];
17329 [label="param VisitType(TypeSymbol? type) 447181"];
17330 [label="param VisitType(Func<TypeWithAnnotations, T, bool, bool>? typeWithAnnotationsPredicate) 447182"];
17331 [label="param VisitType(Func<TypeSymbol, T, bool, bool>? typePredicate) 447183"];
17332 [label="param VisitType(T arg) 447184"];
17333 [label="param VisitType(bool canDigThroughNullable = false) 447185"];
17334 [label="param VisitType(bool useDefaultType = false) 447186"];
17335 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 447187"];
17336 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 447188"];
17337 [label="RoslynDebug.Assert(typeWithAnnotationsOpt.HasType == (type is null)); 447189"];
17338 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 447190"];
17339 [label="RoslynDebug.Assert(canDigThroughNullable == false || useDefaultType == false, 'digging through nullable will cause early resolution of nullable types'); 447191"];
17340 [label="current.TypeKind 447192"];
17341 [label="get\n            {\n                TypeKind result = _lazyKind;\n\n                if (result == TypeKind.Unknown)\n                {\n                    if (_flags.IsInterface())\n                    {\n                        result = TypeKind.Interface;\n                    }\n                    else\n                    {\n                        TypeSymbol @base = GetDeclaredBaseType(skipTransformsIfNecessary: true);\n\n                        result = TypeKind.Class;\n\n                        if ((object)@base != null)\n                        {\n                            SpecialType baseCorTypeId = @base.SpecialType;\n\n                            switch (baseCorTypeId)\n                            {\n                                case SpecialType.System_Enum:\n                                    // Enum\n                                    result = TypeKind.Enum;\n                                    break;\n\n                                case SpecialType.System_MulticastDelegate:\n                                    // Delegate\n                                    result = TypeKind.Delegate;\n                                    break;\n\n                                case SpecialType.System_ValueType:\n                                    // System.Enum is the only class that derives from ValueType\n                                    if (this.SpecialType != SpecialType.System_Enum)\n                                    {\n                                        // Struct\n                                        result = TypeKind.Struct;\n                                    }\n                                    break;\n                            }\n                        }\n                    }\n\n                    _lazyKind = result;\n                }\n\n                return result;\n            } 447193"];
17342 [label="switch (current.TypeKind)\n                {\n                    case TypeKind.Class:\n                    case TypeKind.Struct:\n                    case TypeKind.Interface:\n                    case TypeKind.Enum:\n                    case TypeKind.Delegate:\n                        {\n                            var containingType = current.ContainingType;\n                            if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            }\n                        }\n                        break;\n\n                    case TypeKind.Submission:\n                        RoslynDebug.Assert((object)current.ContainingType == null);\n                        break;\n                } 447194"];
17343 [label="current.ContainingType 447195"];
17344 [label="get\n            {\n                return _container as NamedTypeSymbol;\n            } 447196"];
17345 [label="return _container as NamedTypeSymbol; 447197"];
17346 [label="var containingType = current.ContainingType; 447198"];
17347 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 447199"];
17348 [label="if ((object)containingType != null)\n                            {\n                                isNestedNamedType = true;\n                                var result = VisitType(default, containingType, typeWithAnnotationsPredicate, typePredicate, arg, canDigThroughNullable, useDefaultType);\n                                if (result is object)\n                                {\n                                    return result;\n                                }\n                            } 447200"];
17349 [label="TypeWithAnnotations next; 447201"];
17350 [label="next 447202"];
17351 [label="get\n            {\n                return ImmutableArray<TypeWithAnnotations>.Empty;\n            } 447203"];
17352 [label="return (object)type != null; 447204"];
17353 [label="return (object)type != null; 447205"];
17354 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 447206"];
17355 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 447207"];
17356 [label="if (interfaces.Any(t => needsTupleElementNamesAttribute(t)))\n            {\n                // Note: we don't need to check base type or directly implemented interfaces (which will be reported during binding)\n                // so the checking of all interfaces here involves some redundancy.\n                Binder.ReportMissingTupleElementNamesAttributesIfNeeded(compilation, location, diagnostics);\n            } 447208"];
17357 [label="AfterMembersChecks(diagnostics); 447209"];
17358 [label="AddDeclarationDiagnostics(diagnostics); 447210"];
17359 [label="AddDeclarationDiagnostics(diagnostics) 447211"];
17360 [label="param AddDeclarationDiagnostics(DiagnosticBag diagnostics) 447212"];
17361 [label="param AddDeclarationDiagnostics(this) 447213"];
17362 [label="ContainingSymbol 447214"];
17363 [label="get\n            {\n                return _containingSymbol;\n            } 447215"];
17364 [label="return _containingSymbol; 447216"];
17365 [label="if (ContainingSymbol is SourceMemberContainerTypeSymbol container)\n            {\n                container.AssertMemberExposure(this, forDiagnostics: true);\n            } 447217"];
17366 [label="if (!diagnostics.IsEmptyWithoutResolution)\n            {\n                CSharpCompilation compilation = this.DeclaringCompilation;\n                Debug.Assert(compilation != null);\n                compilation.DeclarationDiagnostics.AddRange(diagnostics);\n            } 447218"];
17367 [label="AddDeclarationDiagnostics(diagnostics); 447219"];
17368 [label="DeclaringCompilation 447220"];
17369 [label="this.Kind 447221"];
17370 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 447222"];
17371 [label="switch (this.Kind)\n                {\n                    case SymbolKind.ErrorType:\n                        return null;\n                    case SymbolKind.Assembly:\n                        Debug.Assert(!(this is SourceAssemblySymbol), 'SourceAssemblySymbol must override DeclaringCompilation');\n                        return null;\n                    case SymbolKind.NetModule:\n                        Debug.Assert(!(this is SourceModuleSymbol), 'SourceModuleSymbol must override DeclaringCompilation');\n                        return null;\n                } 447223"];
17372 [label="return _containingSymbol; 447224"];
17373 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 447225"];
17374 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 447226"];
17375 [label="DeclaringCompilation.SymbolDeclaredEvent(this) 447227"];
17376 [label="param SymbolDeclaredEvent(Symbol symbol) 447228"];
17377 [label="param SymbolDeclaredEvent(this) 447229"];
17378 [label="EventQueue?.TryEnqueue(new SymbolDeclaredCompilationEvent(this, symbol.GetPublicSymbol())); 447230"];
17379 [label="DeclaringCompilation.SymbolDeclaredEvent(this); 447231"];
17380 [label="var thisThreadCompleted = state.NotePartComplete(CompletionPart.FinishMemberChecks); 447232"];
17381 [label="state.NotePartComplete(CompletionPart.FinishMemberChecks) 447233"];
17382 [label="param NotePartComplete(CompletionPart part) 447234"];
17383 [label="param NotePartComplete(this) 447235"];
17384 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 447236"];
17385 [label="Debug.Assert(thisThreadCompleted); 447237"];
17386 [label="diagnostics.Free(); 447238"];
17387 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 447239"];
17388 [label="param SpinWaitComplete(CompletionPart part) 447240"];
17389 [label="param SpinWaitComplete(this) 447241"];
17390 [label="if (HasComplete(part))\n            {\n                return;\n            } 447242"];
17391 [label="param HasComplete(CompletionPart part) 447243"];
17392 [label="param HasComplete(this) 447244"];
17393 [label="return (_completeParts & (int)part) == (int)part; 447245"];
17394 [label="return; 447246"];
17395 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447247"];
17396 [label="param HasAtMostOneBitSet(int bits) 447248"];
17397 [label="return (bits & (bits - 1)) == 0; 447249"];
17398 [label="this.GetMembersUnordered() 447250"];
17399 [label="ImmutableArray<Symbol> members = this.GetMembersUnordered(); 447251"];
17400 [label="bool allCompleted = true; 447252"];
17401 [label="if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            } 447253"];
17402 [label="if (locationOpt == null)\n                            {\n                                foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                }\n                            }\n                            else\n                            {\n                                foreach (var member in members)\n                                {\n                                    ForceCompleteMemberByLocation(locationOpt, member, cancellationToken);\n                                    allCompleted = allCompleted && member.HasComplete(CompletionPart.All);\n                                }\n                            } 447254"];
17403 [label="foreach (var member in members)\n                                {\n                                    cancellationToken.ThrowIfCancellationRequested();\n                                    member.ForceComplete(locationOpt, cancellationToken);\n                                } 447255"];
17404 [label="cancellationToken.ThrowIfCancellationRequested(); 447256"];
17405 [label="member.ForceComplete(locationOpt, cancellationToken); 447257"];
17406 [label="member.ForceComplete(locationOpt, cancellationToken); 447258"];
17407 [label="member.ForceComplete(locationOpt, cancellationToken) 447259"];
17408 [label="param ForceComplete(SourceLocation locationOpt) 447260"];
17409 [label="param ForceComplete(CancellationToken cancellationToken) 447261"];
17410 [label="param ForceComplete(this) 447262"];
17411 [label="this.RequiresCompletion 447263"];
17412 [label="get { return false; } 447264"];
17413 [label="return false; 447265"];
17414 [label="Debug.Assert(!this.RequiresCompletion); 447266"];
17415 [label="member.ForceComplete(locationOpt, cancellationToken); 447267"];
17416 [label="if (!allCompleted)\n                            {\n                                // We did not complete all members so we won't have enough information for\n                                // the PointedAtManagedTypeChecks, so just kick out now.\n                                var allParts = CompletionPart.NamedTypeSymbolWithLocationAll;\n                                state.SpinWaitComplete(allParts, cancellationToken);\n                                return;\n                            } 447268"];
17417 [label="EnsureFieldDefinitionsNoted() 447269"];
17418 [label="param EnsureFieldDefinitionsNoted(this) 447270"];
17419 [label="_flags.FieldDefinitionsNoted 447271"];
17420 [label="get { return (_flags & FieldDefinitionsNotedBit) != 0; } 447272"];
17421 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 447273"];
17422 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 447274"];
17423 [label="if (_flags.FieldDefinitionsNoted)\n            {\n                return;\n            } 447275"];
17424 [label="NoteFieldDefinitions() 447276"];
17425 [label="param NoteFieldDefinitions(this) 447277"];
17426 [label="this.GetMembersAndInitializers() 447278"];
17427 [label="param GetMembersAndInitializers(this) 447279"];
17428 [label="var membersAndInitializers = _lazyMembersAndInitializers; 447280"];
17429 [label="var membersAndInitializers = this.GetMembersAndInitializers(); 447281"];
17430 [label="_flags.FieldDefinitionsNoted 447282"];
17431 [label="get { return (_flags & FieldDefinitionsNotedBit) != 0; } 447283"];
17432 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 447284"];
17433 [label="return (_flags & FieldDefinitionsNotedBit) != 0; 447285"];
17434 [label="if (!_flags.FieldDefinitionsNoted)\n                {\n                    var assembly = (SourceAssemblySymbol)ContainingAssembly;\n\n                    Accessibility containerEffectiveAccessibility = EffectiveAccessibility();\n\n                    foreach (var member in membersAndInitializers.NonTypeMembers)\n                    {\n                        FieldSymbol field;\n                        if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        }\n\n                        Accessibility fieldDeclaredAccessibility = field.DeclaredAccessibility;\n                        if (fieldDeclaredAccessibility == Accessibility.Private)\n                        {\n                            // mark private fields as tentatively unassigned and unread unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: true);\n                        }\n                        else if (containerEffectiveAccessibility == Accessibility.Private)\n                        {\n                            // mark effectively private fields as tentatively unassigned unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: false);\n                        }\n                        else if (fieldDeclaredAccessibility == Accessibility.Internal || containerEffectiveAccessibility == Accessibility.Internal)\n                        {\n                            // mark effectively internal fields as tentatively unassigned unless we discover otherwise.\n                            // NOTE: These fields will be reported as unassigned only if internals are not visible from this assembly.\n                            // See property SourceAssemblySymbol.UnusedFieldWarnings.\n                            assembly.NoteFieldDefinition(field, isInternal: true, isUnread: false);\n                        }\n                    }\n                    _flags.SetFieldDefinitionsNoted();\n                } 447286"];
17435 [label="ContainingAssembly 447287"];
17436 [label="get\n            {\n                // Default implementation gets the containers assembly.\n\n                var container = this.ContainingSymbol;\n                return (object)container != null ? container.ContainingAssembly : null;\n            } 447288"];
17437 [label="this.ContainingSymbol 447289"];
17438 [label="get\n            {\n                return _containingSymbol;\n            } 447290"];
17439 [label="var container = this.ContainingSymbol; 447291"];
17440 [label="return (object)container != null ? container.ContainingAssembly : null; 447292"];
17441 [label="return (object)container != null ? container.ContainingAssembly : null; 447293"];
17442 [label="(object)container != null 447294"];
17443 [label="container.ContainingAssembly 447295"];
17444 [label="=> _module.ContainingAssembly 447296"];
17445 [label="_module.ContainingAssembly 447297"];
17446 [label="get\n            {\n                return _assemblySymbol;\n            } 447298"];
17447 [label="var assembly = (SourceAssemblySymbol)ContainingAssembly; 447299"];
17448 [label="EffectiveAccessibility() 447300"];
17449 [label="param EffectiveAccessibility(this) 447301"];
17450 [label="DeclaredAccessibility 447302"];
17451 [label="get\n            {\n                return ModifierUtils.EffectiveAccessibility(_declModifiers);\n            } 447303"];
17452 [label="return ModifierUtils.EffectiveAccessibility(_declModifiers); 447304"];
17453 [label="ModifierUtils.EffectiveAccessibility(_declModifiers) 447305"];
17454 [label="param EffectiveAccessibility(DeclarationModifiers modifiers) 447306"];
17455 [label="switch (modifiers & DeclarationModifiers.AccessibilityMask)\n            {\n                case DeclarationModifiers.None:\n                    return Accessibility.NotApplicable; // for explicit interface implementation\n                case DeclarationModifiers.Private:\n                    return Accessibility.Private;\n                case DeclarationModifiers.Protected:\n                    return Accessibility.Protected;\n                case DeclarationModifiers.Internal:\n                    return Accessibility.Internal;\n                case DeclarationModifiers.Public:\n                    return Accessibility.Public;\n                case DeclarationModifiers.ProtectedInternal:\n                    return Accessibility.ProtectedOrInternal;\n                case DeclarationModifiers.PrivateProtected:\n                    return Accessibility.ProtectedAndInternal;\n                default:\n                    // This happens when you have a mix of accessibilities.\n                    //\n                    // i.e.: public private void Goo()\n                    return Accessibility.Public;\n            } 447307"];
17456 [label="return Accessibility.Public; 447308"];
17457 [label="var result = DeclaredAccessibility; 447309"];
17458 [label="if (result == Accessibility.Private) return Accessibility.Private; 447310"];
17459 [label="this.ContainingType 447311"];
17460 [label="get\n            {\n                return _containingSymbol as NamedTypeSymbol;\n            } 447312"];
17461 [label="return _containingSymbol as NamedTypeSymbol; 447313"];
17462 [label="for (Symbol? container = this.ContainingType; !(container is null); container = container.ContainingType)\n            {\n                switch (container.DeclaredAccessibility)\n                {\n                    case Accessibility.Private:\n                        return Accessibility.Private;\n                    case Accessibility.Internal:\n                        result = Accessibility.Internal;\n                        continue;\n                }\n            } 447314"];
17463 [label="return result; 447315"];
17464 [label="Accessibility containerEffectiveAccessibility = EffectiveAccessibility(); 447316"];
17465 [label="foreach (var member in membersAndInitializers.NonTypeMembers)\n                    {\n                        FieldSymbol field;\n                        if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        }\n\n                        Accessibility fieldDeclaredAccessibility = field.DeclaredAccessibility;\n                        if (fieldDeclaredAccessibility == Accessibility.Private)\n                        {\n                            // mark private fields as tentatively unassigned and unread unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: true);\n                        }\n                        else if (containerEffectiveAccessibility == Accessibility.Private)\n                        {\n                            // mark effectively private fields as tentatively unassigned unless we discover otherwise.\n                            assembly.NoteFieldDefinition(field, isInternal: false, isUnread: false);\n                        }\n                        else if (fieldDeclaredAccessibility == Accessibility.Internal || containerEffectiveAccessibility == Accessibility.Internal)\n                        {\n                            // mark effectively internal fields as tentatively unassigned unless we discover otherwise.\n                            // NOTE: These fields will be reported as unassigned only if internals are not visible from this assembly.\n                            // See property SourceAssemblySymbol.UnusedFieldWarnings.\n                            assembly.NoteFieldDefinition(field, isInternal: true, isUnread: false);\n                        }\n                    } 447317"];
17466 [label="FieldSymbol field; 447318"];
17467 [label="if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        } 447319"];
17468 [label="if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        } 447320"];
17469 [label="member.IsFieldOrFieldLikeEvent(out field) 447321"];
17470 [label="param IsFieldOrFieldLikeEvent(this Symbol member) 447322"];
17471 [label="param IsFieldOrFieldLikeEvent(out FieldSymbol field) 447323"];
17472 [label="member.Kind 447324"];
17473 [label="get\n            {\n                return SymbolKind.Method;\n            } 447325"];
17474 [label="switch (member.Kind)\n            {\n                case SymbolKind.Field:\n                    field = (FieldSymbol)member;\n                    return true;\n                case SymbolKind.Event:\n                    field = ((EventSymbol)member).AssociatedField;\n                    return (object)field != null;\n                default:\n                    field = null;\n                    return false;\n            } 447326"];
17475 [label="field = null; 447327"];
17476 [label="return false; 447328"];
17477 [label="if (!member.IsFieldOrFieldLikeEvent(out field) || field.IsConst || field.IsFixedSizeBuffer)\n                        {\n                            continue;\n                        } 447329"];
17478 [label="_flags.SetFieldDefinitionsNoted() 447330"];
17479 [label="param SetFieldDefinitionsNoted(this) 447331"];
17480 [label="ThreadSafeFlagOperations.Set(ref _flags, FieldDefinitionsNotedBit); 447332"];
17481 [label="ThreadSafeFlagOperations.Set(ref _flags, FieldDefinitionsNotedBit); 447333"];
17482 [label="_flags.SetFieldDefinitionsNoted(); 447334"];
17483 [label="NoteFieldDefinitions(); 447335"];
17484 [label="EnsureFieldDefinitionsNoted(); 447336"];
17485 [label="state.NotePartComplete(CompletionPart.MembersCompleted); 447337"];
17486 [label="state.NotePartComplete(CompletionPart.MembersCompleted) 447338"];
17487 [label="param NotePartComplete(CompletionPart part) 447339"];
17488 [label="param NotePartComplete(this) 447340"];
17489 [label="return ThreadSafeFlagOperations.Set(ref _completeParts, (int)part); 447341"];
17490 [label="state.SpinWaitComplete(incompletePart, cancellationToken); 447342"];
17491 [label="param SpinWaitComplete(CompletionPart part) 447343"];
17492 [label="param SpinWaitComplete(this) 447344"];
17493 [label="if (HasComplete(part))\n            {\n                return;\n            } 447345"];
17494 [label="param HasComplete(CompletionPart part) 447346"];
17495 [label="param HasComplete(this) 447347"];
17496 [label="return (_completeParts & (int)part) == (int)part; 447348"];
17497 [label="return; 447349"];
17498 [label="cancellationToken.ThrowIfCancellationRequested(); 447350"];
17499 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447351"];
17500 [label="param HasAtMostOneBitSet(int bits) 447352"];
17501 [label="return (bits & (bits - 1)) == 0; 447353"];
17502 [label="return; 447354"];
17503 [label="param HasComplete(CompletionPart part) 447355"];
17504 [label="param HasComplete(this) 447356"];
17505 [label="return state.HasComplete(part); 447357"];
17506 [label="state.HasComplete(part) 447358"];
17507 [label="param HasComplete(CompletionPart part) 447359"];
17508 [label="param HasComplete(this) 447360"];
17509 [label="return (_completeParts & (int)part) == (int)part; 447361"];
17510 [label="return (_completeParts & (int)part) == (int)part; 447362"];
17511 [label="return; 447363"];
17512 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447364"];
17513 [label="param HasAtMostOneBitSet(int bits) 447365"];
17514 [label="return (bits & (bits - 1)) == 0; 447366"];
17515 [label="param HasComplete(CompletionPart part) 447367"];
17516 [label="param HasComplete(this) 447368"];
17517 [label="return _state.HasComplete(part); 447369"];
17518 [label="_state.HasComplete(part) 447370"];
17519 [label="param HasComplete(CompletionPart part) 447371"];
17520 [label="param HasComplete(this) 447372"];
17521 [label="return (_completeParts & (int)part) == (int)part; 447373"];
17522 [label="return (_completeParts & (int)part) == (int)part; 447374"];
17523 [label="return; 447375"];
17524 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447376"];
17525 [label="param HasAtMostOneBitSet(int bits) 447377"];
17526 [label="return (bits & (bits - 1)) == 0; 447378"];
17527 [label="param HasComplete(CompletionPart part) 447379"];
17528 [label="param HasComplete(this) 447380"];
17529 [label="return _state.HasComplete(part); 447381"];
17530 [label="_state.HasComplete(part) 447382"];
17531 [label="param HasComplete(CompletionPart part) 447383"];
17532 [label="param HasComplete(this) 447384"];
17533 [label="return (_completeParts & (int)part) == (int)part; 447385"];
17534 [label="return (_completeParts & (int)part) == (int)part; 447386"];
17535 [label="return; 447387"];
17536 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447388"];
17537 [label="param HasAtMostOneBitSet(int bits) 447389"];
17538 [label="return (bits & (bits - 1)) == 0; 447390"];
17539 [label="param ReportDiagnosticsForAddedModules(this) 447391"];
17540 [label="var diagnostics = DiagnosticBag.GetInstance(); 447392"];
17541 [label="_compilation.GetBoundReferenceManager() 447393"];
17542 [label="param GetBoundReferenceManager(this) 447394"];
17543 [label="foreach (var pair in _compilation.GetBoundReferenceManager().ReferencedModuleIndexMap)\n            {\n                var fileRef = pair.Key as PortableExecutableReference;\n\n                if ((object)fileRef != null && (object)fileRef.FilePath != null)\n                {\n                    string fileName = FileNameUtilities.GetFileName(fileRef.FilePath);\n                    string moduleName = _modules[pair.Value].Name;\n\n                    if (!string.Equals(fileName, moduleName, StringComparison.OrdinalIgnoreCase))\n                    {\n                        // Used to be ERR_ALinkFailed\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMismatch, NoLocation.Singleton, moduleName, fileName);\n                    }\n                }\n            } 447395"];
17544 [label="if (_modules.Length > 1 && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                var assemblyMachine = this.Machine;\n                bool isPlatformAgnostic = (assemblyMachine == System.Reflection.PortableExecutable.Machine.I386 && !this.Bit32Required);\n                var knownModuleNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);\n\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    ModuleSymbol m = _modules[i];\n                    if (!knownModuleNames.Add(m.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMustBeUnique, NoLocation.Singleton, m.Name);\n                    }\n\n                    if (!((PEModuleSymbol)m).Module.IsCOFFOnly)\n                    {\n                        var moduleMachine = m.Machine;\n\n                        if (moduleMachine == System.Reflection.PortableExecutable.Machine.I386 && !m.Bit32Required)\n                        {\n                            // Other module is agnostic, this is always safe\n                            ;\n                        }\n                        else if (isPlatformAgnostic)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_AgnosticToMachineModule, NoLocation.Singleton, m);\n                        }\n                        else if (assemblyMachine != moduleMachine)\n                        {\n                            // Different machine types, and neither is agnostic\n                            // So it is a conflict\n                            diagnostics.Add(ErrorCode.ERR_ConflictingMachineModule, NoLocation.Singleton, m);\n                        }\n                    }\n                }\n\n                // Assembly main module must explicitly reference all the modules referenced by other assembly \n                // modules, i.e. all modules from transitive closure must be referenced explicitly here\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    var m = (PEModuleSymbol)_modules[i];\n\n                    try\n                    {\n                        foreach (var referencedModuleName in m.Module.GetReferencedManagedModulesOrThrow())\n                        {\n                            // Do not report error for this module twice\n                            if (knownModuleNames.Add(referencedModuleName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_MissingNetModuleReference, NoLocation.Singleton, referencedModuleName);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    }\n                }\n            } 447396"];
17545 [label="if (_modules.Length > 1 && !_compilation.Options.OutputKind.IsNetModule())\n            {\n                var assemblyMachine = this.Machine;\n                bool isPlatformAgnostic = (assemblyMachine == System.Reflection.PortableExecutable.Machine.I386 && !this.Bit32Required);\n                var knownModuleNames = new HashSet<String>(StringComparer.OrdinalIgnoreCase);\n\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    ModuleSymbol m = _modules[i];\n                    if (!knownModuleNames.Add(m.Name))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_NetModuleNameMustBeUnique, NoLocation.Singleton, m.Name);\n                    }\n\n                    if (!((PEModuleSymbol)m).Module.IsCOFFOnly)\n                    {\n                        var moduleMachine = m.Machine;\n\n                        if (moduleMachine == System.Reflection.PortableExecutable.Machine.I386 && !m.Bit32Required)\n                        {\n                            // Other module is agnostic, this is always safe\n                            ;\n                        }\n                        else if (isPlatformAgnostic)\n                        {\n                            diagnostics.Add(ErrorCode.ERR_AgnosticToMachineModule, NoLocation.Singleton, m);\n                        }\n                        else if (assemblyMachine != moduleMachine)\n                        {\n                            // Different machine types, and neither is agnostic\n                            // So it is a conflict\n                            diagnostics.Add(ErrorCode.ERR_ConflictingMachineModule, NoLocation.Singleton, m);\n                        }\n                    }\n                }\n\n                // Assembly main module must explicitly reference all the modules referenced by other assembly \n                // modules, i.e. all modules from transitive closure must be referenced explicitly here\n                for (int i = 1; i < _modules.Length; i++)\n                {\n                    var m = (PEModuleSymbol)_modules[i];\n\n                    try\n                    {\n                        foreach (var referencedModuleName in m.Module.GetReferencedManagedModulesOrThrow())\n                        {\n                            // Do not report error for this module twice\n                            if (knownModuleNames.Add(referencedModuleName))\n                            {\n                                diagnostics.Add(ErrorCode.ERR_MissingNetModuleReference, NoLocation.Singleton, referencedModuleName);\n                            }\n                        }\n                    }\n                    catch (BadImageFormatException)\n                    {\n                        diagnostics.Add(new CSDiagnosticInfo(ErrorCode.ERR_BindToBogus, m), NoLocation.Singleton);\n                    }\n                }\n            } 447397"];
17546 [label="this.GlobalNamespace 447398"];
17547 [label="get\n            {\n                if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                }\n\n                return _globalNamespace;\n            } 447399"];
17548 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 447400"];
17549 [label="if ((object)_globalNamespace == null)\n                {\n                    // Get the root namespace from each module, and merge them all together. If there is only one, \n                    // then MergedNamespaceSymbol.Create will just return that one.\n\n                    IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace;\n                    var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable());\n                    Interlocked.CompareExchange(ref _globalNamespace, result, null);\n                } 447401"];
17550 [label="IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace; 447402"];
17551 [label="IEnumerable<NamespaceSymbol> allGlobalNamespaces = from m in Modules select m.GlobalNamespace; 447403"];
17552 [label="var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable()); 447404"];
17553 [label="var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable()); 447405"];
17554 [label="new NamespaceExtent(this) 447406"];
17555 [label="param NamespaceExtent(AssemblySymbol assembly) 447407"];
17556 [label="param NamespaceExtent(this) 447408"];
17557 [label="_kind 447409"];
17558 [label="_symbolOrCompilation 447410"];
17559 [label="var result = MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable()); 447411"];
17560 [label="MergedNamespaceSymbol.Create(new NamespaceExtent(this),\n                                                        null,\n                                                        allGlobalNamespaces.AsImmutable()) 447412"];
17561 [label="param Create(NamespaceExtent extent) 447413"];
17562 [label="param Create(NamespaceSymbol containingNamespace) 447414"];
17563 [label="param Create(ImmutableArray<NamespaceSymbol> namespacesToMerge) 447415"];
17564 [label="param Create(string nameOpt = null) 447416"];
17565 [label="Debug.Assert(namespacesToMerge.Length != 0); 447417"];
17566 [label="Debug.Assert(namespacesToMerge.Length != 0); 447418"];
17567 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 447419"];
17568 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 447420"];
17569 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 447421"];
17570 [label="return (namespacesToMerge.Length == 1 && nameOpt == null)\n                ? namespacesToMerge[0]\n                : new MergedNamespaceSymbol(extent, containingNamespace, namespacesToMerge, nameOpt); 447422"];
17571 [label="(namespacesToMerge.Length == 1 && nameOpt == null) 447423"];
17572 [label="Interlocked.CompareExchange(ref _globalNamespace, result, null); 447424"];
17573 [label="Interlocked.CompareExchange(ref _globalNamespace, result, null); 447425"];
17574 [label="Interlocked.CompareExchange(ref _globalNamespace, result, null); 447426"];
17575 [label="return _globalNamespace; 447427"];
17576 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 447428"];
17577 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 447429"];
17578 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics) 447430"];
17579 [label="param ReportNameCollisionDiagnosticsForAddedModules(NamespaceSymbol ns) 447431"];
17580 [label="param ReportNameCollisionDiagnosticsForAddedModules(DiagnosticBag diagnostics) 447432"];
17581 [label="param ReportNameCollisionDiagnosticsForAddedModules(this) 447433"];
17582 [label="var mergedNs = ns as MergedNamespaceSymbol; 447434"];
17583 [label="if ((object)mergedNs == null)\n            {\n                return;\n            } 447435"];
17584 [label="if ((object)mergedNs == null)\n            {\n                return;\n            } 447436"];
17585 [label="return; 447437"];
17586 [label="ReportNameCollisionDiagnosticsForAddedModules(this.GlobalNamespace, diagnostics); 447438"];
17587 [label="_compilation.DeclarationDiagnostics 447439"];
17588 [label="get\n            {\n                // We should only be placing diagnostics in this bag until\n                // we are done gathering declaration diagnostics. Assert that is\n                // the case. But since we have bugs (see https://github.com/dotnet/roslyn/issues/846)\n                // we disable the assertion until they are fixed.\n                Debug.Assert(!_declarationDiagnosticsFrozen || true);\n                if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                }\n\n                return _lazyDeclarationDiagnostics;\n            } 447440"];
17589 [label="Debug.Assert(!_declarationDiagnosticsFrozen || true); 447441"];
17590 [label="if (_lazyDeclarationDiagnostics == null)\n                {\n                    var diagnostics = new DiagnosticBag();\n                    Interlocked.CompareExchange(ref _lazyDeclarationDiagnostics, diagnostics, null);\n                } 447442"];
17591 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 447443"];
17592 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 447444"];
17593 [label="_compilation.DeclarationDiagnostics.AddRange(diagnostics); 447445"];
17594 [label="diagnostics.Free(); 447446"];
17595 [label="return (_completeParts & (int)part) == (int)part; 447447"];
17596 [label="return; 447448"];
17597 [label="Debug.Assert(HasAtMostOneBitSet(next), 'ForceComplete won't handle the result correctly if more than one bit is set.'); 447449"];
17598 [label="param HasAtMostOneBitSet(int bits) 447450"];
17599 [label="return (bits & (bits - 1)) == 0; 447451"];
17600 [label="if (syntaxTree is null)\n            {\n                // Don't freeze the compilation if we're getting\n                // diagnostics for a single tree\n                _declarationDiagnosticsFrozen = true;\n\n                // Also freeze generated attribute flags.\n                // Symbols bound after getting the declaration\n                // diagnostics shouldn't need to modify the flags.\n                _needsGeneratedAttributes_IsFrozen = true;\n            } 447452"];
17601 [label="_declarationDiagnosticsFrozen = true; 447453"];
17602 [label="_declarationDiagnosticsFrozen 447454"];
17603 [label="_needsGeneratedAttributes_IsFrozen = true; 447455"];
17604 [label="_needsGeneratedAttributes_IsFrozen 447456"];
17605 [label="var result = _lazyDeclarationDiagnostics?.AsEnumerable() ?? Enumerable.Empty<Diagnostic>(); 447457"];
17606 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 447458"];
17607 [label="if (locationFilterOpt != null)\n            {\n                RoslynDebug.Assert(syntaxTree != null);\n                result = locationFilterOpt(result, syntaxTree, filterSpanWithinTree);\n            } 447459"];
17608 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 447460"];
17609 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 447461"];
17610 [label="ImmutableArray<Diagnostic> clsDiagnostics = GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken); 447462"];
17611 [label="GetClsComplianceDiagnostics(syntaxTree, filterSpanWithinTree, cancellationToken) 447463"];
17612 [label="param GetClsComplianceDiagnostics(SyntaxTree? syntaxTree) 447464"];
17613 [label="param GetClsComplianceDiagnostics(TextSpan? filterSpanWithinTree) 447465"];
17614 [label="param GetClsComplianceDiagnostics(CancellationToken cancellationToken) 447466"];
17615 [label="param GetClsComplianceDiagnostics(this) 447467"];
17616 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 447468"];
17617 [label="if (syntaxTree != null)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken, syntaxTree, filterSpanWithinTree);\n                return builder.ToReadOnlyAndFree();\n            } 447469"];
17618 [label="if (_lazyClsComplianceDiagnostics.IsDefault)\n            {\n                var builder = DiagnosticBag.GetInstance();\n                ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken);\n                ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree());\n            } 447470"];
17619 [label="var builder = DiagnosticBag.GetInstance(); 447471"];
17620 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 447472"];
17621 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 447473"];
17622 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 447474"];
17623 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 447475"];
17624 [label="ClsComplianceChecker.CheckCompliance(this, builder, cancellationToken); 447476"];
17625 [label="param CSharpSymbolVisitor(this) 447477"];
17626 [label="GetBoundReferenceManager(); 447478"];
17627 [label="param Visit(Symbol symbol) 447479"];
17628 [label="param Visit(this) 447480"];
17629 [label="if ((object)symbol != null)\n            {\n                symbol.Accept(this);\n            } 447481"];
17630 [label="if ((object)symbol != null)\n            {\n                symbol.Accept(this);\n            } 447482"];
17631 [label="symbol.Accept(this); 447483"];
17632 [label="symbol.Accept(this) 447484"];
17633 [label="param Accept(CSharpSymbolVisitor visitor) 447485"];
17634 [label="param Accept(this) 447486"];
17635 [label="visitor.VisitAssembly(this); 447487"];
17636 [label="visitor.VisitAssembly(this); 447488"];
17637 [label="visitor.VisitAssembly(this); 447489"];
17638 [label="get\n            {\n                return SymbolKind.Assembly;\n            } 447490"];
17639 [label="return SymbolKind.Assembly; 447491"];
17640 [label="visitor.VisitAssembly(this); 447492"];
17641 [label="param GetHashCode(Symbol obj) 447493"];
17642 [label="param GetHashCode(this) 447494"];
17643 [label="return obj is null ? 0 : obj.GetHashCode(); 447495"];
17644 [label="obj is null 447496"];
17645 [label="obj.GetHashCode() 447497"];
17646 [label="param GetHashCode(this) 447498"];
17647 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 447499"];
17648 [label="return System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(this); 447500"];
17649 [label="param GetAttributes(this) 447501"];
17650 [label="this.GetSourceAttributesBag() 447502"];
17651 [label="param GetSourceAttributesBag(this) 447503"];
17652 [label="EnsureAttributesAreBound() 447504"];
17653 [label="param EnsureAttributesAreBound(this) 447505"];
17654 [label="if ((_lazySourceAttributesBag == null || !_lazySourceAttributesBag.IsSealed) &&\n                LoadAndValidateAttributes(OneOrMany.Create(GetAttributeDeclarations()), ref _lazySourceAttributesBag))\n            {\n                _state.NotePartComplete(CompletionPart.Attributes);\n            } 447506"];
17655 [label="EnsureAttributesAreBound(); 447507"];
17656 [label="return _lazySourceAttributesBag; 447508"];
17657 [label="var attributes = this.GetSourceAttributesBag().Attributes; 447509"];
17658 [label="this.GetNetModuleAttributesBag() 447510"];
17659 [label="param GetNetModuleAttributesBag(this) 447511"];
17660 [label="if (_lazyNetModuleAttributesBag == null)\n            {\n                LoadAndValidateNetModuleAttributes(ref _lazyNetModuleAttributesBag);\n            } 447512"];
17661 [label="EnsureNetModuleAttributesAreBound(); 447513"];
17662 [label="return _lazyNetModuleAttributesBag; 447514"];
17663 [label="var netmoduleAttributes = this.GetNetModuleAttributesBag().Attributes; 447515"];
17664 [label="Debug.Assert(!attributes.IsDefault); 447516"];
17665 [label="Debug.Assert(!netmoduleAttributes.IsDefault); 447517"];
17666 [label="if (attributes.Length > 0)\n            {\n                if (netmoduleAttributes.Length > 0)\n                {\n                    attributes = attributes.Concat(netmoduleAttributes);\n                }\n            }\n            else\n            {\n                attributes = netmoduleAttributes;\n            } 447518"];
17667 [label="if (attributes.Length > 0)\n            {\n                if (netmoduleAttributes.Length > 0)\n                {\n                    attributes = attributes.Concat(netmoduleAttributes);\n                }\n            }\n            else\n            {\n                attributes = netmoduleAttributes;\n            } 447519"];
17668 [label="attributes = netmoduleAttributes; 447520"];
17669 [label="Debug.Assert(!attributes.IsDefault); 447521"];
17670 [label="return attributes; 447522"];
17671 [label="get\n            {\n                return SymbolKind.NetModule;\n            } 447523"];
17672 [label="return SymbolKind.NetModule; 447524"];
17673 [label="visitor.VisitAssembly(this); 447525"];
17674 [label="get\n            {\n                Symbol container = this.ContainingSymbol;\n\n                NamedTypeSymbol containerAsType = container as NamedTypeSymbol;\n\n                // NOTE: container could be null, so we do not check \n                //       whether containerAsType is not null, but \n                //       instead check if it did not change after \n                //       the cast.\n                if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                }\n\n                // this is recursive, but recursion should be very short \n                // before we reach symbol that definitely knows its containing type.\n                return container.ContainingType;\n            } 447526"];
17675 [label="this.ContainingSymbol 447527"];
17676 [label="get\n            {\n                return _assemblySymbol;\n            } 447528"];
17677 [label="return _assemblySymbol; 447529"];
17678 [label="Symbol container = this.ContainingSymbol; 447530"];
17679 [label="NamedTypeSymbol containerAsType = container as NamedTypeSymbol; 447531"];
17680 [label="if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                } 447532"];
17681 [label="container.ContainingType 447533"];
17682 [label="get\n            {\n                Symbol container = this.ContainingSymbol;\n\n                NamedTypeSymbol containerAsType = container as NamedTypeSymbol;\n\n                // NOTE: container could be null, so we do not check \n                //       whether containerAsType is not null, but \n                //       instead check if it did not change after \n                //       the cast.\n                if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                }\n\n                // this is recursive, but recursion should be very short \n                // before we reach symbol that definitely knows its containing type.\n                return container.ContainingType;\n            } 447534"];
17683 [label="this.ContainingSymbol 447535"];
17684 [label="get\n            {\n                return null;\n            } 447536"];
17685 [label="Symbol container = this.ContainingSymbol; 447537"];
17686 [label="NamedTypeSymbol containerAsType = container as NamedTypeSymbol; 447538"];
17687 [label="if ((object)containerAsType == (object)container)\n                {\n                    // this should be relatively uncommon\n                    // most symbols that may be contained in a type\n                    // know their containing type and can override ContainingType\n                    // with a more precise implementation\n                    return containerAsType;\n                } 447539"];
17688 [label="return containerAsType; 447540"];
17689 [label="return container.ContainingType; 447541"];
17690 [label="visitor.VisitAssembly(this); 447542"];
17691 [label="param Equals(Symbol x) 447543"];
17692 [label="param Equals(Symbol y) 447544"];
17693 [label="param Equals(this) 447545"];
17694 [label="return x is null ? y is null : x.Equals(y, _comparison); 447546"];
17695 [label="x is null 447547"];
17696 [label="return x is null ? y is null : x.Equals(y, _comparison); 447548"];
17697 [label="return x is null ? y is null : x.Equals(y, _comparison); 447549"];
17698 [label="x.Equals(y, _comparison) 447550"];
17699 [label="param Equals(Symbol other) 447551"];
17700 [label="param Equals(TypeCompareKind compareKind) 447552"];
17701 [label="param Equals(this) 447553"];
17702 [label="return (object)this == other; 447554"];
17703 [label="visitor.VisitAssembly(this); 447555"];
17704 [label="return _globalNamespace; 447556"];
17705 [label="param Accept(CSharpSymbolVisitor visitor) 447557"];
17706 [label="param Accept(this) 447558"];
17707 [label="visitor.VisitNamespace(this); 447559"];
17708 [label="visitor.VisitNamespace(this); 447560"];
17709 [label="visitor.VisitNamespace(this); 447561"];
17710 [label="get\n            {\n                return SymbolKind.Namespace;\n            } 447562"];
17711 [label="=> _module.ContainingAssembly 447563"];
17712 [label="_module.ContainingAssembly 447564"];
17713 [label="get\n            {\n                return _assemblySymbol;\n            } 447565"];
17714 [label="get\n            {\n                return SymbolKind.Assembly;\n            } 447566"];
17715 [label="return SymbolKind.Assembly; 447567"];
17716 [label="param GetHashCode(this) 447568"];
17717 [label="param Equals(this) 447569"];
17718 [label="return x is null ? y is null : x.Equals(y, _comparison); 447570"];
17719 [label="param Equals(TypeCompareKind compareKind) 447571"];
17720 [label="symbol.Accept(this); 447572"];
17721 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 447573"];
17722 [label="ImmutableInterlocked.InterlockedInitialize(ref _lazyClsComplianceDiagnostics, builder.ToReadOnlyAndFree()); 447574"];
17723 [label="Debug.Assert(!_lazyClsComplianceDiagnostics.IsDefault); 447575"];
17724 [label="return _lazyClsComplianceDiagnostics; 447576"];
17725 [label="return result.AsImmutable().Concat(clsDiagnostics); 447577"];
17726 [label="return result.AsImmutable().Concat(clsDiagnostics); 447578"];
17727 [label="return result.AsImmutable().Concat(clsDiagnostics); 447579"];
17728 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 447580"];
17729 [label="if (EventQueue != null && SyntaxTrees.Length == 0)\n                {\n                    EnsureCompilationEventQueueCompleted();\n                } 447581"];
17730 [label="cancellationToken.ThrowIfCancellationRequested(); 447582"];
17731 [label="if (stage == CompilationStage.Compile || stage > CompilationStage.Compile && includeEarlierStages)\n            {\n                var methodBodyDiagnostics = DiagnosticBag.GetInstance();\n                GetDiagnosticsForAllMethodBodies(methodBodyDiagnostics, cancellationToken);\n                builder.AddRangeAndFree(methodBodyDiagnostics);\n            } 447583"];
17732 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 447584"];
17733 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 447585"];
17734 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 447586"];
17735 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 447587"];
17736 [label="FilterAndAppendAndFreeDiagnostics(diagnostics, ref builder, cancellationToken); 447588"];
17737 [label="GetDiagnostics(stage, includeEarlierStages, diagnostics, cancellationToken); 447589"];
17738 [label="return diagnostics.ToReadOnlyAndFree(); 447590"];
17739 [label="CustomAssert.Equal(0, comp.GetDeclarationDiagnostics().Count(e => e.Severity >= DiagnosticSeverity.Error)); 447591"];
17740 [label="comp.GlobalNamespace 447592"];
17741 [label="get\n            {\n                if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                }\n\n                return _lazyGlobalNamespace;\n            } 447593"];
17742 [label="if (_lazyGlobalNamespace is null)\n                {\n                    // Get the root namespace from each module, and merge them all together\n                    // Get all modules in this compilation, ones referenced directly by the compilation\n                    // as well as those referenced by all referenced assemblies.\n\n                    var modules = ArrayBuilder<ModuleSymbol>.GetInstance();\n                    GetAllUnaliasedModules(modules);\n\n                    var result = MergedNamespaceSymbol.Create(\n                        new NamespaceExtent(this),\n                        null,\n                        modules.SelectDistinct(m => m.GlobalNamespace));\n\n                    modules.Free();\n\n                    Interlocked.CompareExchange(ref _lazyGlobalNamespace, result, null);\n                } 447594"];
17743 [label="return _lazyGlobalNamespace; 447595"];
17744 [label="var global = comp.GlobalNamespace; 447596"];
17745 [label="var system = global.GetMembers('System').Single() as NamespaceSymbol; 447597"];
17746 [label="global.GetMembers('System') 447598"];
17747 [label="param GetMembers(string name) 447599"];
17748 [label="param GetMembers(this) 447600"];
17749 [label="return _cachedLookup[name]; 447601"];
17750 [label="var mystring = system.GetMembers('MyString').Single() as NamedTypeSymbol; 447602"];
17751 [label="system.GetMembers('MyString') 447603"];
17752 [label="param GetMembers(string name) 447604"];
17753 [label="param GetMembers(this) 447605"];
17754 [label="return _cachedLookup[name]; 447606"];
17755 [label="_cachedLookup 447607"];
17756 [label="param SlowGetChildrenOfName(string name) 447608"];
17757 [label="param SlowGetChildrenOfName(this) 447609"];
17758 [label="ArrayBuilder<NamespaceSymbol> namespaceSymbols = null; 447610"];
17759 [label="var otherSymbols = ArrayBuilder<Symbol>.GetInstance(); 447611"];
17760 [label="foreach (NamespaceSymbol namespaceSymbol in _namespacesToMerge)\n            {\n                foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                }\n            } 447612"];
17761 [label="foreach (Symbol childSymbol in namespaceSymbol.GetMembers(name))\n                {\n                    if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    }\n                } 447613"];
17762 [label="namespaceSymbol.GetMembers(name) 447614"];
17763 [label="param GetMembers(string name) 447615"];
17764 [label="childSymbol.Kind 447616"];
17765 [label="get\n            {\n                return SymbolKind.NamedType;\n            } 447617"];
17766 [label="if (childSymbol.Kind == SymbolKind.Namespace)\n                    {\n                        namespaceSymbols = namespaceSymbols ?? ArrayBuilder<NamespaceSymbol>.GetInstance();\n                        namespaceSymbols.Add((NamespaceSymbol)childSymbol);\n                    }\n                    else\n                    {\n                        otherSymbols.Add(childSymbol);\n                    } 447618"];
17767 [label="otherSymbols.Add(childSymbol); 447619"];
17768 [label="otherSymbols.Add(childSymbol); 447620"];
17769 [label="EnsureAllMembersLoaded(); 447621"];
17770 [label="return ImmutableArray<Symbol>.Empty; 447622"];
17771 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 447623"];
17772 [label="if (namespaceSymbols != null)\n            {\n                otherSymbols.Add(MergedNamespaceSymbol.Create(_extent, this, namespaceSymbols.ToImmutableAndFree()));\n            } 447624"];
17773 [label="return otherSymbols.ToImmutableAndFree(); 447625"];
17774 [label="var sourceString = mystring.BaseType(); 447626"];
17775 [label="mystring.BaseType() 447627"];
17776 [label="param BaseType(this TypeSymbol symbol) 447628"];
17777 [label="symbol.BaseTypeNoUseSiteDiagnostics 447629"];
17778 [label="get\n            {\n                if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                }\n\n                return _lazyBaseType;\n            } 447630"];
17779 [label="if (ReferenceEquals(_lazyBaseType, ErrorTypeSymbol.UnknownResultType))\n                {\n                    // force resolution of bases in containing type\n                    // to make base resolution errors more deterministic\n                    if ((object)ContainingType != null)\n                    {\n                        var tmp = ContainingType.BaseTypeNoUseSiteDiagnostics;\n                    }\n\n                    var diagnostics = DiagnosticBag.GetInstance();\n                    var acyclicBase = this.MakeAcyclicBaseType(diagnostics);\n                    if (ReferenceEquals(Interlocked.CompareExchange(ref _lazyBaseType, acyclicBase, ErrorTypeSymbol.UnknownResultType), ErrorTypeSymbol.UnknownResultType))\n                    {\n                        AddDeclarationDiagnostics(diagnostics);\n                    }\n                    diagnostics.Free();\n                } 447631"];
17780 [label="return symbol.BaseTypeNoUseSiteDiagnostics; 447632"];
17781 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447633"];
17782 [label="sourceString.GetMembers() 447634"];
17783 [label="param GetMembers(this) 447635"];
17784 [label="_flags.FlattenedMembersIsSorted 447636"];
17785 [label="get { return (_flags & FlattenedMembersIsSortedBit) != 0; } 447637"];
17786 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 447638"];
17787 [label="return (_flags & FlattenedMembersIsSortedBit) != 0; 447639"];
17788 [label="if (_flags.FlattenedMembersIsSorted)\n            {\n                return _lazyMembersFlattened;\n            }\n            else\n            {\n                var allMembers = this.GetMembersUnordered();\n\n                if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                }\n\n                _flags.SetFlattenedMembersIsSorted();\n                return allMembers;\n            } 447640"];
17789 [label="this.GetMembersUnordered() 447641"];
17790 [label="var allMembers = this.GetMembersUnordered(); 447642"];
17791 [label="if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                } 447643"];
17792 [label="if (allMembers.Length > 1)\n                {\n                    // The array isn't sorted. Sort it and remember that we sorted it.\n                    allMembers = allMembers.Sort(LexicalOrderSymbolComparer.Instance);\n                    ImmutableInterlocked.InterlockedExchange(ref _lazyMembersFlattened, allMembers);\n                } 447644"];
17793 [label="_flags.SetFlattenedMembersIsSorted() 447645"];
17794 [label="param SetFlattenedMembersIsSorted(this) 447646"];
17795 [label="ThreadSafeFlagOperations.Set(ref _flags, (FlattenedMembersIsSortedBit)); 447647"];
17796 [label="ThreadSafeFlagOperations.Set(ref _flags, (FlattenedMembersIsSortedBit)); 447648"];
17797 [label="_flags.SetFlattenedMembersIsSorted(); 447649"];
17798 [label="return allMembers; 447650"];
17799 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447651"];
17800 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447652"];
17801 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447653"];
17802 [label="get { return MethodKind.Constructor; } 447654"];
17803 [label="return MethodKind.Constructor; 447655"];
17804 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447656"];
17805 [label="CustomAssert.Equal(0,\n                sourceString.GetMembers()\n                .Count(m => !(m is MethodSymbol) || (m as MethodSymbol).MethodKind != MethodKind.Constructor)); 447657"];
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 3;
192 -> 191;
193 -> 192;
194 -> 193;
194 -> 192;
195 -> 1;
196 -> 1;
197 -> 196;
197 -> 1;
198 -> 1;
199 -> 1;
200 -> 197;
200 -> 199;
201 -> 198;
201 -> 199;
202 -> 198;
202 -> 199;
203 -> 198;
203 -> 199;
204 -> 199;
205 -> 202;
205 -> 204;
205 -> 199;
206 -> 0;
207 -> 0;
209 -> 206;
209 -> 207;
209 -> 208;
210 -> 209;
211 -> 0;
212 -> 210;
212 -> 209;
212 -> 211;
213 -> 212;
214 -> 0;
215 -> 210;
215 -> 209;
215 -> 214;
216 -> 215;
217 -> 0;
218 -> 210;
218 -> 209;
218 -> 217;
219 -> 218;
220 -> 0;
221 -> 210;
221 -> 209;
221 -> 220;
222 -> 221;
223 -> 0;
224 -> 210;
224 -> 209;
224 -> 223;
225 -> 224;
226 -> 0;
227 -> 210;
227 -> 209;
227 -> 226;
228 -> 227;
229 -> 0;
230 -> 210;
230 -> 209;
230 -> 229;
231 -> 230;
232 -> 0;
233 -> 210;
233 -> 209;
233 -> 232;
234 -> 233;
235 -> 0;
236 -> 210;
236 -> 209;
236 -> 235;
237 -> 236;
238 -> 0;
239 -> 210;
239 -> 209;
239 -> 238;
240 -> 239;
241 -> 0;
242 -> 210;
242 -> 209;
242 -> 241;
243 -> 242;
244 -> 210;
247 -> 244;
247 -> 246;
248 -> 245;
248 -> 246;
249 -> 246;
250 -> 247;
250 -> 209;
250 -> 246;
251 -> 246;
252 -> 248;
252 -> 246;
253 -> 249;
253 -> 246;
254 -> 252;
254 -> 253;
254 -> 246;
255 -> 254;
255 -> 251;
255 -> 246;
256 -> 250;
256 -> 251;
256 -> 209;
256 -> 255;
256 -> 254;
256 -> 246;
257 -> 256;
258 -> 0;
259 -> 258;
261 -> 259;
261 -> 260;
262 -> 210;
262 -> 209;
262 -> 261;
263 -> 262;
264 -> 0;
265 -> 264;
266 -> 210;
266 -> 209;
266 -> 265;
267 -> 266;
268 -> 0;
269 -> 210;
269 -> 209;
269 -> 268;
270 -> 269;
271 -> 234;
273 -> 272;
274 -> 0;
275 -> 0;
276 -> 0;
278 -> 274;
278 -> 275;
278 -> 276;
278 -> 277;
279 -> 273;
280 -> 278;
280 -> 279;
280 -> 272;
281 -> 280;
285 -> 282;
285 -> 283;
285 -> 284;
286 -> 216;
286 -> 209;
286 -> 215;
286 -> 282;
286 -> 285;
287 -> 286;
288 -> 228;
289 -> 237;
290 -> 237;
291 -> 234;
292 -> 0;
293 -> 0;
295 -> 292;
295 -> 294;
296 -> 293;
296 -> 294;
297 -> 294;
298 -> 295;
298 -> 294;
299 -> 296;
299 -> 294;
300 -> 0;
300 -> 294;
301 -> 297;
301 -> 294;
302 -> 294;
303 -> 298;
303 -> 299;
303 -> 300;
303 -> 301;
303 -> 302;
303 -> 294;
304 -> 303;
305 -> 0;
306 -> 0;
308 -> 305;
308 -> 307;
309 -> 306;
309 -> 307;
310 -> 307;
311 -> 308;
311 -> 307;
312 -> 309;
312 -> 307;
313 -> 0;
313 -> 307;
314 -> 310;
314 -> 307;
315 -> 307;
316 -> 311;
316 -> 312;
316 -> 313;
316 -> 314;
316 -> 315;
316 -> 307;
317 -> 316;
319 -> 304;
319 -> 303;
319 -> 318;
320 -> 319;
322 -> 317;
322 -> 316;
322 -> 321;
323 -> 322;
324 -> 0;
325 -> 0;
327 -> 324;
327 -> 326;
328 -> 325;
328 -> 326;
329 -> 326;
330 -> 327;
330 -> 326;
331 -> 328;
331 -> 326;
332 -> 0;
332 -> 326;
333 -> 329;
333 -> 326;
334 -> 326;
335 -> 330;
335 -> 331;
335 -> 332;
335 -> 333;
335 -> 334;
335 -> 326;
336 -> 335;
337 -> 0;
338 -> 0;
340 -> 337;
340 -> 339;
341 -> 338;
341 -> 339;
342 -> 339;
343 -> 340;
343 -> 339;
344 -> 341;
344 -> 339;
345 -> 0;
345 -> 339;
346 -> 342;
346 -> 339;
347 -> 339;
348 -> 343;
348 -> 344;
348 -> 345;
348 -> 346;
348 -> 347;
348 -> 339;
349 -> 348;
350 -> 0;
351 -> 0;
353 -> 350;
353 -> 352;
354 -> 351;
354 -> 352;
355 -> 352;
356 -> 353;
356 -> 352;
357 -> 354;
357 -> 352;
358 -> 0;
358 -> 352;
359 -> 355;
359 -> 352;
360 -> 352;
361 -> 356;
361 -> 357;
361 -> 358;
361 -> 359;
361 -> 360;
361 -> 352;
362 -> 361;
363 -> 0;
364 -> 0;
366 -> 363;
366 -> 365;
367 -> 364;
367 -> 365;
368 -> 365;
369 -> 366;
369 -> 365;
370 -> 367;
370 -> 365;
371 -> 0;
371 -> 365;
372 -> 368;
372 -> 365;
373 -> 365;
374 -> 369;
374 -> 370;
374 -> 371;
374 -> 372;
374 -> 373;
374 -> 365;
375 -> 374;
376 -> 0;
377 -> 0;
379 -> 376;
379 -> 378;
380 -> 377;
380 -> 378;
381 -> 378;
382 -> 379;
382 -> 378;
383 -> 380;
383 -> 378;
384 -> 0;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 378;
387 -> 382;
387 -> 383;
387 -> 384;
387 -> 385;
387 -> 386;
387 -> 378;
388 -> 387;
389 -> 0;
390 -> 0;
392 -> 389;
392 -> 391;
393 -> 390;
393 -> 391;
394 -> 391;
395 -> 392;
395 -> 391;
396 -> 393;
396 -> 391;
397 -> 0;
397 -> 391;
398 -> 394;
398 -> 391;
399 -> 391;
400 -> 395;
400 -> 396;
400 -> 397;
400 -> 398;
400 -> 399;
400 -> 391;
401 -> 400;
403 -> 304;
403 -> 303;
403 -> 402;
404 -> 403;
406 -> 317;
406 -> 316;
406 -> 405;
407 -> 406;
409 -> 336;
409 -> 335;
409 -> 408;
410 -> 409;
412 -> 349;
412 -> 348;
412 -> 411;
413 -> 412;
414 -> 0;
415 -> 304;
415 -> 303;
415 -> 414;
415 -> 0;
416 -> 415;
417 -> 0;
418 -> 317;
418 -> 316;
418 -> 417;
418 -> 0;
419 -> 418;
420 -> 0;
421 -> 388;
421 -> 387;
421 -> 420;
421 -> 0;
422 -> 421;
423 -> 0;
424 -> 336;
424 -> 335;
424 -> 423;
424 -> 0;
425 -> 424;
426 -> 0;
427 -> 0;
427 -> 426;
428 -> 427;
429 -> 210;
429 -> 205;
430 -> 200;
430 -> 199;
431 -> 0;
431 -> 199;
432 -> 431;
432 -> 203;
432 -> 199;
433 -> 199;
434 -> 430;
434 -> 432;
434 -> 433;
434 -> 0;
434 -> 199;
435 -> 434;
435 -> 199;
436 -> 429;
436 -> 199;
437 -> 201;
437 -> 199;
438 -> 199;
439 -> 435;
439 -> 436;
439 -> 437;
439 -> 438;
439 -> 434;
439 -> 209;
439 -> 199;
440 -> 199;
441 -> 439;
441 -> 440;
442 -> 440;
443 -> 440;
444 -> 441;
444 -> 439;
444 -> 443;
444 -> 440;
445 -> 442;
445 -> 440;
446 -> 440;
447 -> 444;
447 -> 439;
447 -> 443;
447 -> 445;
447 -> 446;
447 -> 442;
447 -> 440;
448 -> 440;
449 -> 448;
449 -> 442;
449 -> 440;
450 -> 442;
450 -> 440;
451 -> 440;
452 -> 450;
452 -> 451;
452 -> 442;
452 -> 449;
452 -> 440;
453 -> 441;
453 -> 440;
454 -> 453;
454 -> 1;
455 -> 1;
456 -> 454;
456 -> 455;
457 -> 456;
457 -> 455;
458 -> 455;
459 -> 457;
459 -> 458;
460 -> 458;
461 -> 459;
461 -> 460;
461 -> 458;
462 -> 458;
462 -> 1;
463 -> 1;
464 -> 1;
465 -> 462;
465 -> 464;
466 -> 463;
466 -> 464;
467 -> 463;
467 -> 464;
468 -> 463;
468 -> 464;
469 -> 463;
469 -> 464;
470 -> 463;
470 -> 464;
471 -> 463;
471 -> 464;
472 -> 463;
472 -> 464;
473 -> 465;
473 -> 464;
474 -> 469;
474 -> 464;
475 -> 466;
475 -> 464;
476 -> 464;
477 -> 474;
477 -> 476;
478 -> 475;
478 -> 476;
479 -> 477;
479 -> 476;
480 -> 476;
481 -> 479;
481 -> 480;
482 -> 481;
482 -> 480;
483 -> 482;
484 -> 0;
484 -> 483;
485 -> 484;
486 -> 485;
487 -> 486;
487 -> 483;
488 -> 476;
489 -> 478;
489 -> 488;
489 -> 476;
490 -> 487;
490 -> 489;
491 -> 467;
491 -> 464;
492 -> 468;
492 -> 464;
493 -> 470;
493 -> 464;
494 -> 471;
494 -> 464;
495 -> 472;
495 -> 464;
496 -> 464;
497 -> 473;
497 -> 496;
498 -> 490;
498 -> 496;
499 -> 491;
499 -> 496;
500 -> 492;
500 -> 496;
501 -> 493;
501 -> 496;
502 -> 494;
502 -> 496;
503 -> 495;
503 -> 496;
504 -> 497;
504 -> 496;
505 -> 498;
505 -> 496;
506 -> 499;
506 -> 496;
507 -> 500;
507 -> 496;
508 -> 501;
508 -> 496;
509 -> 502;
509 -> 496;
510 -> 503;
510 -> 496;
511 -> 496;
512 -> 511;
512 -> 496;
513 -> 496;
514 -> 504;
514 -> 513;
515 -> 505;
515 -> 513;
516 -> 506;
516 -> 513;
517 -> 507;
517 -> 513;
518 -> 508;
518 -> 513;
519 -> 509;
519 -> 513;
520 -> 510;
520 -> 513;
521 -> 512;
521 -> 513;
522 -> 517;
522 -> 513;
523 -> 519;
523 -> 513;
524 -> 513;
525 -> 522;
525 -> 524;
526 -> 523;
526 -> 524;
527 -> 514;
527 -> 524;
528 -> 527;
528 -> 461;
528 -> 524;
529 -> 528;
530 -> 525;
530 -> 529;
530 -> 528;
531 -> 526;
531 -> 528;
532 -> 528;
533 -> 528;
533 -> 532;
534 -> 532;
534 -> 513;
535 -> 513;
536 -> 516;
536 -> 535;
536 -> 513;
537 -> 534;
537 -> 536;
538 -> 536;
539 -> 537;
539 -> 538;
539 -> 532;
539 -> 533;
539 -> 439;
539 -> 536;
540 -> 539;
540 -> 536;
541 -> 304;
541 -> 540;
542 -> 0;
542 -> 513;
543 -> 521;
543 -> 513;
544 -> 518;
544 -> 534;
544 -> 515;
544 -> 541;
544 -> 513;
546 -> 545;
547 -> 546;
548 -> 547;
549 -> 544;
549 -> 513;
550 -> 513;
551 -> 549;
551 -> 550;
552 -> 548;
552 -> 550;
553 -> 552;
554 -> 513;
555 -> 544;
555 -> 532;
555 -> 533;
555 -> 439;
555 -> 486;
555 -> 0;
555 -> 303;
555 -> 513;
556 -> 513;
557 -> 556;
558 -> 555;
558 -> 557;
558 -> 513;
559 -> 0;
561 -> 559;
561 -> 560;
562 -> 561;
563 -> 0;
565 -> 563;
565 -> 564;
567 -> 565;
567 -> 566;
568 -> 567;
569 -> 555;
569 -> 556;
570 -> 555;
570 -> 556;
571 -> 555;
571 -> 556;
572 -> 555;
572 -> 556;
573 -> 569;
573 -> 556;
574 -> 572;
574 -> 556;
575 -> 570;
575 -> 556;
576 -> 571;
576 -> 556;
577 -> 556;
578 -> 556;
579 -> 573;
579 -> 578;
580 -> 574;
580 -> 578;
581 -> 575;
581 -> 578;
582 -> 576;
582 -> 578;
583 -> 577;
583 -> 578;
584 -> 577;
584 -> 578;
585 -> 577;
585 -> 578;
586 -> 577;
586 -> 578;
587 -> 578;
588 -> 580;
588 -> 587;
588 -> 578;
589 -> 586;
589 -> 578;
590 -> 582;
590 -> 578;
591 -> 590;
591 -> 558;
591 -> 578;
592 -> 579;
592 -> 578;
593 -> 580;
593 -> 578;
594 -> 591;
594 -> 578;
595 -> 583;
595 -> 578;
596 -> 584;
596 -> 578;
597 -> 585;
597 -> 578;
598 -> 586;
598 -> 578;
599 -> 578;
600 -> 0;
600 -> 578;
601 -> 580;
601 -> 591;
601 -> 578;
602 -> 600;
602 -> 601;
602 -> 598;
602 -> 599;
602 -> 0;
602 -> 591;
602 -> 578;
603 -> 578;
604 -> 592;
604 -> 603;
605 -> 593;
605 -> 603;
606 -> 594;
606 -> 603;
607 -> 595;
607 -> 603;
608 -> 596;
608 -> 603;
609 -> 597;
609 -> 603;
610 -> 598;
610 -> 603;
611 -> 599;
611 -> 603;
612 -> 599;
612 -> 603;
613 -> 602;
613 -> 603;
614 -> 599;
614 -> 603;
615 -> 599;
615 -> 603;
616 -> 599;
616 -> 603;
617 -> 604;
617 -> 603;
618 -> 605;
618 -> 603;
619 -> 606;
619 -> 603;
620 -> 607;
620 -> 603;
621 -> 608;
621 -> 603;
622 -> 609;
622 -> 603;
623 -> 610;
623 -> 603;
624 -> 611;
624 -> 603;
625 -> 612;
625 -> 603;
626 -> 613;
626 -> 603;
627 -> 613;
627 -> 602;
627 -> 603;
628 -> 627;
628 -> 602;
628 -> 603;
629 -> 614;
629 -> 603;
630 -> 615;
630 -> 603;
631 -> 603;
632 -> 617;
632 -> 631;
633 -> 618;
633 -> 631;
634 -> 619;
634 -> 631;
635 -> 620;
635 -> 631;
636 -> 621;
636 -> 631;
637 -> 622;
637 -> 631;
638 -> 623;
638 -> 631;
639 -> 624;
639 -> 631;
640 -> 625;
640 -> 631;
641 -> 626;
641 -> 631;
642 -> 628;
642 -> 631;
643 -> 629;
643 -> 631;
644 -> 630;
644 -> 631;
645 -> 616;
645 -> 631;
646 -> 632;
646 -> 631;
647 -> 634;
647 -> 631;
648 -> 642;
648 -> 631;
649 -> 638;
649 -> 631;
650 -> 643;
650 -> 631;
651 -> 644;
651 -> 631;
652 -> 631;
653 -> 652;
653 -> 646;
653 -> 647;
653 -> 648;
653 -> 649;
653 -> 650;
653 -> 651;
653 -> 591;
653 -> 628;
653 -> 631;
654 -> 652;
654 -> 631;
655 -> 652;
655 -> 631;
656 -> 652;
656 -> 631;
657 -> 652;
657 -> 631;
658 -> 652;
658 -> 631;
659 -> 652;
659 -> 631;
660 -> 652;
660 -> 631;
661 -> 652;
661 -> 631;
662 -> 652;
662 -> 631;
663 -> 652;
663 -> 631;
664 -> 652;
664 -> 631;
665 -> 652;
665 -> 631;
666 -> 652;
666 -> 631;
667 -> 652;
667 -> 631;
668 -> 652;
668 -> 631;
669 -> 652;
669 -> 631;
670 -> 652;
670 -> 631;
671 -> 652;
671 -> 631;
672 -> 652;
672 -> 631;
673 -> 652;
673 -> 631;
674 -> 652;
674 -> 631;
675 -> 652;
675 -> 631;
676 -> 652;
676 -> 631;
677 -> 652;
677 -> 631;
678 -> 652;
678 -> 631;
679 -> 652;
679 -> 631;
680 -> 631;
681 -> 680;
681 -> 652;
681 -> 631;
682 -> 652;
682 -> 631;
683 -> 652;
683 -> 631;
684 -> 652;
684 -> 631;
685 -> 652;
685 -> 631;
686 -> 652;
686 -> 631;
687 -> 652;
687 -> 631;
688 -> 652;
688 -> 631;
689 -> 631;
690 -> 631;
691 -> 688;
691 -> 690;
692 -> 689;
692 -> 690;
694 -> 693;
695 -> 693;
696 -> 690;
697 -> 692;
697 -> 696;
698 -> 696;
699 -> 692;
699 -> 690;
700 -> 691;
700 -> 692;
700 -> 690;
701 -> 689;
701 -> 652;
701 -> 631;
702 -> 633;
702 -> 652;
702 -> 631;
703 -> 652;
703 -> 631;
704 -> 703;
704 -> 653;
704 -> 654;
704 -> 702;
704 -> 655;
704 -> 656;
704 -> 657;
704 -> 658;
704 -> 659;
704 -> 660;
704 -> 661;
704 -> 662;
704 -> 663;
704 -> 664;
704 -> 665;
704 -> 666;
704 -> 667;
704 -> 668;
704 -> 669;
704 -> 670;
704 -> 671;
704 -> 672;
704 -> 673;
704 -> 674;
704 -> 675;
704 -> 676;
704 -> 677;
704 -> 678;
704 -> 679;
704 -> 681;
704 -> 682;
704 -> 701;
704 -> 683;
704 -> 684;
704 -> 685;
704 -> 686;
704 -> 687;
704 -> 680;
704 -> 698;
704 -> 699;
704 -> 700;
704 -> 631;
705 -> 704;
705 -> 652;
705 -> 631;
706 -> 652;
706 -> 704;
706 -> 631;
707 -> 706;
707 -> 704;
707 -> 705;
707 -> 631;
708 -> 707;
708 -> 652;
708 -> 631;
709 -> 652;
709 -> 707;
709 -> 631;
710 -> 709;
710 -> 707;
710 -> 708;
710 -> 631;
711 -> 710;
711 -> 652;
711 -> 631;
712 -> 652;
712 -> 710;
712 -> 631;
713 -> 712;
713 -> 710;
713 -> 711;
713 -> 631;
714 -> 713;
714 -> 652;
714 -> 631;
715 -> 652;
715 -> 713;
715 -> 631;
716 -> 715;
716 -> 713;
716 -> 714;
716 -> 631;
717 -> 716;
717 -> 652;
717 -> 631;
718 -> 652;
718 -> 631;
719 -> 631;
720 -> 631;
721 -> 718;
721 -> 720;
722 -> 719;
722 -> 720;
723 -> 720;
724 -> 723;
724 -> 720;
725 -> 723;
725 -> 720;
726 -> 723;
726 -> 720;
727 -> 720;
728 -> 727;
728 -> 723;
728 -> 720;
729 -> 720;
730 -> 721;
730 -> 729;
730 -> 720;
731 -> 721;
731 -> 723;
731 -> 720;
732 -> 719;
732 -> 652;
732 -> 631;
733 -> 641;
733 -> 716;
733 -> 631;
734 -> 631;
735 -> 733;
735 -> 734;
736 -> 734;
737 -> 735;
737 -> 734;
738 -> 737;
738 -> 716;
738 -> 717;
738 -> 732;
738 -> 734;
739 -> 0;
739 -> 734;
740 -> 739;
740 -> 736;
740 -> 734;
741 -> 740;
741 -> 631;
742 -> 741;
742 -> 652;
742 -> 631;
743 -> 638;
743 -> 631;
744 -> 743;
745 -> 635;
745 -> 744;
745 -> 743;
746 -> 636;
746 -> 744;
746 -> 743;
747 -> 745;
747 -> 746;
747 -> 743;
748 -> 637;
748 -> 744;
748 -> 743;
749 -> 747;
749 -> 748;
749 -> 743;
750 -> 640;
750 -> 631;
751 -> 652;
751 -> 716;
751 -> 717;
751 -> 732;
751 -> 742;
751 -> 723;
751 -> 724;
751 -> 731;
751 -> 725;
751 -> 726;
751 -> 728;
751 -> 727;
751 -> 750;
752 -> 750;
753 -> 652;
753 -> 752;
754 -> 753;
754 -> 751;
754 -> 752;
755 -> 639;
755 -> 750;
756 -> 750;
757 -> 750;
758 -> 751;
758 -> 757;
759 -> 754;
759 -> 757;
760 -> 755;
760 -> 757;
761 -> 756;
761 -> 757;
762 -> 758;
762 -> 757;
763 -> 759;
763 -> 757;
764 -> 760;
764 -> 757;
765 -> 757;
766 -> 765;
766 -> 762;
766 -> 763;
766 -> 764;
766 -> 751;
766 -> 757;
767 -> 756;
767 -> 652;
767 -> 750;
768 -> 641;
768 -> 652;
768 -> 631;
769 -> 652;
769 -> 766;
769 -> 631;
770 -> 631;
771 -> 652;
771 -> 766;
771 -> 770;
771 -> 631;
772 -> 578;
773 -> 581;
773 -> 772;
773 -> 578;
774 -> 581;
774 -> 773;
775 -> 773;
776 -> 774;
776 -> 775;
777 -> 599;
777 -> 775;
778 -> 775;
779 -> 776;
779 -> 778;
779 -> 775;
780 -> 776;
780 -> 775;
781 -> 780;
781 -> 766;
781 -> 767;
781 -> 768;
781 -> 775;
782 -> 775;
783 -> 777;
783 -> 781;
783 -> 775;
784 -> 782;
784 -> 775;
785 -> 783;
785 -> 781;
785 -> 775;
786 -> 784;
786 -> 785;
786 -> 782;
786 -> 781;
786 -> 775;
787 -> 775;
788 -> 775;
789 -> 776;
789 -> 775;
790 -> 789;
790 -> 786;
790 -> 775;
791 -> 790;
792 -> 790;
793 -> 790;
794 -> 777;
794 -> 793;
794 -> 790;
795 -> 790;
796 -> 782;
796 -> 795;
796 -> 793;
796 -> 790;
797 -> 787;
797 -> 790;
797 -> 796;
798 -> 788;
798 -> 790;
799 -> 782;
799 -> 796;
799 -> 775;
800 -> 777;
800 -> 799;
800 -> 775;
801 -> 776;
801 -> 775;
802 -> 783;
802 -> 801;
802 -> 799;
802 -> 775;
803 -> 777;
803 -> 802;
803 -> 775;
804 -> 797;
804 -> 775;
805 -> 802;
805 -> 775;
806 -> 775;
807 -> 803;
807 -> 806;
808 -> 804;
808 -> 806;
809 -> 805;
809 -> 806;
810 -> 777;
810 -> 806;
811 -> 810;
811 -> 802;
811 -> 806;
812 -> 806;
813 -> 810;
813 -> 812;
814 -> 813;
814 -> 802;
814 -> 812;
815 -> 814;
815 -> 812;
816 -> 815;
816 -> 806;
817 -> 806;
818 -> 811;
818 -> 817;
819 -> 818;
819 -> 811;
819 -> 817;
820 -> 806;
821 -> 819;
821 -> 820;
822 -> 807;
822 -> 806;
823 -> 808;
823 -> 806;
824 -> 809;
824 -> 806;
825 -> 806;
826 -> 806;
827 -> 811;
827 -> 826;
828 -> 811;
828 -> 826;
829 -> 811;
829 -> 826;
830 -> 816;
830 -> 826;
831 -> 819;
831 -> 826;
832 -> 821;
832 -> 826;
833 -> 821;
833 -> 826;
834 -> 822;
834 -> 826;
835 -> 823;
835 -> 826;
836 -> 824;
836 -> 826;
837 -> 821;
837 -> 826;
838 -> 825;
838 -> 826;
839 -> 825;
839 -> 826;
840 -> 830;
840 -> 826;
841 -> 831;
841 -> 826;
842 -> 832;
842 -> 826;
843 -> 836;
843 -> 821;
843 -> 826;
844 -> 838;
844 -> 826;
845 -> 826;
846 -> 840;
846 -> 845;
847 -> 841;
847 -> 845;
848 -> 842;
848 -> 845;
849 -> 844;
849 -> 845;
850 -> 839;
850 -> 845;
851 -> 849;
851 -> 845;
852 -> 845;
853 -> 852;
853 -> 845;
854 -> 852;
854 -> 845;
855 -> 852;
855 -> 845;
856 -> 852;
856 -> 845;
857 -> 852;
857 -> 845;
858 -> 852;
858 -> 845;
859 -> 852;
859 -> 845;
860 -> 852;
860 -> 845;
861 -> 852;
861 -> 845;
862 -> 852;
862 -> 845;
863 -> 852;
863 -> 845;
864 -> 852;
864 -> 845;
865 -> 852;
865 -> 845;
866 -> 852;
866 -> 845;
867 -> 852;
867 -> 845;
868 -> 852;
868 -> 845;
869 -> 852;
869 -> 845;
870 -> 852;
870 -> 845;
871 -> 852;
871 -> 845;
872 -> 852;
872 -> 845;
873 -> 852;
873 -> 845;
874 -> 852;
874 -> 845;
875 -> 852;
875 -> 845;
876 -> 852;
876 -> 845;
877 -> 852;
877 -> 845;
878 -> 852;
878 -> 845;
879 -> 845;
880 -> 879;
880 -> 852;
880 -> 845;
881 -> 852;
881 -> 845;
882 -> 852;
882 -> 845;
883 -> 852;
883 -> 845;
884 -> 852;
884 -> 845;
885 -> 852;
885 -> 845;
886 -> 852;
886 -> 845;
887 -> 852;
887 -> 845;
888 -> 845;
889 -> 845;
890 -> 887;
890 -> 889;
891 -> 888;
891 -> 889;
892 -> 889;
893 -> 891;
893 -> 892;
894 -> 892;
895 -> 891;
895 -> 889;
896 -> 890;
896 -> 891;
896 -> 889;
897 -> 888;
897 -> 852;
897 -> 845;
898 -> 852;
898 -> 845;
899 -> 852;
899 -> 845;
900 -> 845;
901 -> 845;
902 -> 899;
902 -> 901;
903 -> 900;
903 -> 901;
904 -> 901;
905 -> 904;
905 -> 901;
906 -> 904;
906 -> 901;
907 -> 904;
907 -> 901;
908 -> 901;
909 -> 908;
909 -> 904;
909 -> 901;
910 -> 901;
911 -> 902;
911 -> 910;
911 -> 901;
912 -> 902;
912 -> 904;
912 -> 901;
913 -> 900;
913 -> 852;
913 -> 845;
914 -> 845;
915 -> 843;
915 -> 914;
916 -> 914;
917 -> 915;
917 -> 914;
918 -> 917;
918 -> 843;
918 -> 913;
918 -> 904;
918 -> 905;
918 -> 912;
918 -> 906;
918 -> 907;
918 -> 909;
918 -> 908;
919 -> 917;
920 -> 918;
920 -> 919;
921 -> 833;
921 -> 845;
922 -> 921;
923 -> 846;
923 -> 922;
923 -> 921;
924 -> 847;
924 -> 922;
924 -> 921;
925 -> 923;
925 -> 924;
925 -> 921;
926 -> 848;
926 -> 922;
926 -> 921;
927 -> 925;
927 -> 926;
927 -> 921;
928 -> 834;
928 -> 835;
929 -> 852;
929 -> 835;
930 -> 834;
930 -> 929;
930 -> 843;
930 -> 913;
930 -> 920;
930 -> 904;
930 -> 905;
930 -> 912;
930 -> 906;
930 -> 907;
930 -> 909;
930 -> 908;
930 -> 835;
931 -> 834;
931 -> 852;
931 -> 835;
932 -> 852;
932 -> 930;
932 -> 845;
933 -> 845;
934 -> 852;
934 -> 930;
934 -> 933;
934 -> 845;
935 -> 825;
935 -> 775;
936 -> 935;
936 -> 773;
937 -> 936;
937 -> 930;
937 -> 578;
938 -> 936;
938 -> 578;
939 -> 555;
939 -> 938;
939 -> 930;
939 -> 931;
939 -> 836;
939 -> 513;
940 -> 939;
940 -> 513;
941 -> 513;
942 -> 940;
942 -> 941;
943 -> 941;
944 -> 942;
944 -> 943;
945 -> 944;
945 -> 939;
945 -> 943;
946 -> 945;
946 -> 941;
947 -> 946;
947 -> 945;
947 -> 941;
948 -> 941;
949 -> 946;
949 -> 948;
949 -> 945;
949 -> 941;
950 -> 0;
950 -> 941;
951 -> 949;
951 -> 950;
951 -> 941;
952 -> 520;
952 -> 951;
952 -> 513;
953 -> 939;
953 -> 513;
954 -> 1;
955 -> 1;
956 -> 954;
956 -> 955;
957 -> 953;
957 -> 955;
958 -> 0;
958 -> 955;
959 -> 955;
960 -> 956;
960 -> 955;
961 -> 955;
962 -> 958;
962 -> 961;
963 -> 959;
963 -> 961;
964 -> 960;
964 -> 961;
965 -> 957;
965 -> 961;
966 -> 961;
967 -> 962;
967 -> 961;
968 -> 963;
968 -> 961;
969 -> 966;
969 -> 961;
970 -> 964;
970 -> 961;
971 -> 961;
972 -> 967;
972 -> 971;
973 -> 968;
973 -> 971;
974 -> 969;
974 -> 971;
975 -> 970;
975 -> 971;
976 -> 965;
976 -> 971;
977 -> 971;
978 -> 972;
978 -> 0;
978 -> 971;
979 -> 978;
979 -> 973;
979 -> 971;
980 -> 972;
980 -> 0;
980 -> 971;
981 -> 977;
981 -> 980;
982 -> 981;
982 -> 976;
982 -> 977;
982 -> 951;
982 -> 980;
983 -> 980;
984 -> 982;
984 -> 983;
985 -> 984;
985 -> 982;
985 -> 983;
986 -> 980;
987 -> 976;
987 -> 986;
988 -> 987;
988 -> 985;
988 -> 986;
989 -> 988;
989 -> 980;
990 -> 980;
991 -> 976;
991 -> 990;
992 -> 991;
992 -> 989;
992 -> 990;
993 -> 992;
993 -> 980;
994 -> 975;
994 -> 954;
994 -> 980;
995 -> 980;
996 -> 976;
996 -> 995;
997 -> 996;
997 -> 989;
997 -> 995;
998 -> 996;
998 -> 997;
999 -> 997;
1000 -> 998;
1000 -> 999;
1001 -> 996;
1001 -> 989;
1001 -> 999;
1002 -> 1000;
1002 -> 999;
1003 -> 999;
1004 -> 1002;
1004 -> 1003;
1005 -> 1001;
1005 -> 1003;
1006 -> 1003;
1007 -> 1003;
1008 -> 1003;
1009 -> 1004;
1009 -> 1008;
1010 -> 1009;
1010 -> 1003;
1011 -> 1003;
1012 -> 1003;
1013 -> 1012;
1013 -> 1003;
1014 -> 1003;
1015 -> 1014;
1015 -> 1003;
1016 -> 1003;
1017 -> 1016;
1017 -> 1003;
1018 -> 1003;
1019 -> 1018;
1019 -> 1003;
1020 -> 1004;
1020 -> 1003;
1021 -> 1007;
1021 -> 1003;
1022 -> 1018;
1022 -> 1003;
1023 -> 1011;
1023 -> 1003;
1024 -> 1012;
1024 -> 1003;
1025 -> 1014;
1025 -> 1003;
1026 -> 1016;
1026 -> 1003;
1027 -> 1006;
1027 -> 1003;
1028 -> 1020;
1028 -> 1021;
1028 -> 1022;
1028 -> 1023;
1028 -> 1024;
1028 -> 1025;
1028 -> 1026;
1028 -> 1027;
1028 -> 1005;
1028 -> 989;
1028 -> 1007;
1028 -> 1006;
1028 -> 1019;
1028 -> 1013;
1028 -> 1015;
1028 -> 1017;
1028 -> 1003;
1029 -> 1003;
1030 -> 1028;
1030 -> 1029;
1031 -> 1029;
1032 -> 1030;
1032 -> 1031;
1033 -> 1032;
1033 -> 1028;
1033 -> 1031;
1034 -> 1033;
1034 -> 1029;
1035 -> 0;
1036 -> 0;
1036 -> 1035;
1037 -> 0;
1038 -> 1036;
1038 -> 0;
1038 -> 1037;
1039 -> 1038;
1040 -> 1029;
1041 -> 1034;
1041 -> 1040;
1042 -> 1034;
1042 -> 1040;
1043 -> 1040;
1044 -> 1041;
1044 -> 1034;
1044 -> 1043;
1044 -> 1040;
1045 -> 1034;
1045 -> 1040;
1046 -> 1034;
1046 -> 1040;
1047 -> 0;
1047 -> 1040;
1048 -> 1040;
1049 -> 1040;
1050 -> 1045;
1050 -> 1040;
1051 -> 1050;
1052 -> 1050;
1053 -> 1051;
1053 -> 1052;
1054 -> 1053;
1054 -> 1052;
1055 -> 0;
1055 -> 1054;
1056 -> 1050;
1057 -> 1055;
1057 -> 1050;
1058 -> 1047;
1058 -> 1050;
1059 -> 1048;
1059 -> 1050;
1060 -> 1049;
1060 -> 1050;
1061 -> 1046;
1061 -> 1050;
1062 -> 1050;
1063 -> 1056;
1063 -> 1062;
1064 -> 1057;
1064 -> 1062;
1065 -> 1058;
1065 -> 1062;
1066 -> 1059;
1066 -> 1062;
1067 -> 1060;
1067 -> 1062;
1068 -> 1061;
1068 -> 1062;
1069 -> 1065;
1069 -> 1064;
1069 -> 1062;
1070 -> 1062;
1071 -> 1047;
1071 -> 1055;
1071 -> 1050;
1072 -> 1071;
1072 -> 0;
1072 -> 1040;
1073 -> 1071;
1073 -> 1040;
1074 -> 1041;
1074 -> 1073;
1074 -> 1043;
1074 -> 1040;
1075 -> 1073;
1076 -> 1047;
1076 -> 1073;
1077 -> 1048;
1077 -> 1073;
1078 -> 1049;
1078 -> 1073;
1079 -> 1046;
1079 -> 1073;
1080 -> 1073;
1081 -> 1075;
1081 -> 1080;
1082 -> 1075;
1082 -> 1080;
1083 -> 1076;
1083 -> 1080;
1084 -> 1077;
1084 -> 1080;
1085 -> 1078;
1085 -> 1080;
1086 -> 1079;
1086 -> 1080;
1087 -> 1083;
1087 -> 1082;
1087 -> 1080;
1088 -> 1080;
1089 -> 1073;
1089 -> 0;
1089 -> 1040;
1090 -> 1028;
1090 -> 1029;
1091 -> 1090;
1091 -> 1073;
1091 -> 1029;
1092 -> 1028;
1092 -> 1029;
1093 -> 0;
1093 -> 1029;
1094 -> 1028;
1094 -> 1093;
1094 -> 1091;
1094 -> 1003;
1095 -> 1028;
1095 -> 1029;
1096 -> 1028;
1096 -> 1029;
1097 -> 1028;
1097 -> 1029;
1098 -> 1028;
1098 -> 1029;
1099 -> 1028;
1099 -> 1029;
1100 -> 1028;
1100 -> 1029;
1101 -> 1028;
1101 -> 1029;
1102 -> 1095;
1102 -> 1029;
1103 -> 1096;
1103 -> 1029;
1104 -> 1100;
1104 -> 1029;
1105 -> 1097;
1105 -> 1029;
1106 -> 1098;
1106 -> 1029;
1107 -> 1099;
1107 -> 1029;
1108 -> 1029;
1109 -> 1029;
1110 -> 1102;
1110 -> 1109;
1111 -> 1103;
1111 -> 1109;
1112 -> 1104;
1112 -> 1109;
1113 -> 1105;
1113 -> 1109;
1114 -> 1106;
1114 -> 1109;
1115 -> 1107;
1115 -> 1109;
1116 -> 1108;
1116 -> 1109;
1117 -> 1110;
1117 -> 1094;
1117 -> 1109;
1118 -> 1110;
1118 -> 1094;
1118 -> 1109;
1119 -> 1112;
1119 -> 1109;
1120 -> 1109;
1121 -> 1117;
1121 -> 1120;
1122 -> 1118;
1122 -> 1120;
1123 -> 1119;
1123 -> 1120;
1124 -> 1116;
1124 -> 1120;
1125 -> 1120;
1126 -> 1125;
1126 -> 1120;
1127 -> 1125;
1127 -> 1120;
1128 -> 1125;
1128 -> 1120;
1129 -> 1120;
1130 -> 1121;
1130 -> 1129;
1130 -> 1120;
1131 -> 1122;
1131 -> 1094;
1131 -> 1120;
1132 -> 1123;
1132 -> 1125;
1132 -> 1120;
1133 -> 1121;
1133 -> 1125;
1133 -> 1120;
1134 -> 1122;
1134 -> 1125;
1134 -> 1120;
1135 -> 1116;
1135 -> 1109;
1136 -> 1116;
1136 -> 1109;
1137 -> 1116;
1137 -> 1109;
1138 -> 1116;
1138 -> 1109;
1139 -> 1116;
1139 -> 1109;
1140 -> 1116;
1140 -> 1109;
1141 -> 1116;
1141 -> 1109;
1142 -> 1109;
1143 -> 1113;
1143 -> 1142;
1143 -> 1109;
1144 -> 1109;
1145 -> 1111;
1145 -> 1144;
1145 -> 1109;
1146 -> 1111;
1146 -> 1116;
1146 -> 1109;
1147 -> 1110;
1147 -> 1116;
1147 -> 1109;
1148 -> 1113;
1148 -> 1116;
1148 -> 1109;
1149 -> 1115;
1149 -> 1116;
1149 -> 1109;
1150 -> 1114;
1150 -> 1116;
1150 -> 1109;
1151 -> 1028;
1151 -> 1108;
1151 -> 1094;
1151 -> 1125;
1151 -> 1126;
1151 -> 1127;
1151 -> 1133;
1151 -> 1128;
1151 -> 1132;
1151 -> 1134;
1151 -> 1135;
1151 -> 1147;
1151 -> 1136;
1151 -> 1146;
1151 -> 1137;
1151 -> 1148;
1151 -> 1138;
1151 -> 1149;
1151 -> 1139;
1151 -> 1150;
1151 -> 1140;
1151 -> 1141;
1151 -> 1003;
1152 -> 1151;
1152 -> 1129;
1152 -> 1120;
1153 -> 1151;
1153 -> 1120;
1154 -> 1005;
1154 -> 1151;
1154 -> 1003;
1155 -> 1003;
1156 -> 1151;
1156 -> 1003;
1157 -> 1154;
1157 -> 1155;
1158 -> 1157;
1158 -> 1154;
1158 -> 1155;
1159 -> 1003;
1160 -> 1158;
1160 -> 1003;
1161 -> 1003;
1162 -> 1003;
1163 -> 1003;
1164 -> 1163;
1164 -> 1003;
1165 -> 1003;
1166 -> 1165;
1166 -> 1003;
1167 -> 1003;
1168 -> 1167;
1168 -> 1003;
1169 -> 1004;
1169 -> 1160;
1169 -> 1003;
1170 -> 1003;
1171 -> 1169;
1171 -> 1170;
1171 -> 1003;
1172 -> 1171;
1172 -> 1003;
1173 -> 1003;
1174 -> 1172;
1174 -> 1173;
1174 -> 1003;
1175 -> 1174;
1175 -> 1003;
1176 -> 1003;
1177 -> 1175;
1177 -> 1176;
1177 -> 1003;
1178 -> 1177;
1178 -> 1003;
1179 -> 0;
1179 -> 1003;
1180 -> 1179;
1180 -> 1178;
1180 -> 1003;
1181 -> 1004;
1181 -> 1003;
1182 -> 1160;
1182 -> 1003;
1183 -> 1151;
1183 -> 1003;
1184 -> 1003;
1185 -> 1004;
1185 -> 1184;
1186 -> 1185;
1186 -> 1160;
1186 -> 1184;
1187 -> 1186;
1187 -> 1003;
1188 -> 1003;
1189 -> 1004;
1189 -> 1188;
1190 -> 1189;
1190 -> 1160;
1190 -> 1188;
1191 -> 1190;
1191 -> 1003;
1192 -> 1010;
1192 -> 1003;
1193 -> 1007;
1193 -> 1003;
1194 -> 1167;
1194 -> 1003;
1195 -> 1163;
1195 -> 1003;
1196 -> 1165;
1196 -> 1003;
1197 -> 1180;
1197 -> 1003;
1198 -> 1006;
1198 -> 1003;
1199 -> 1161;
1199 -> 1003;
1200 -> 1162;
1200 -> 1003;
1201 -> 1181;
1201 -> 1182;
1201 -> 1183;
1201 -> 1187;
1201 -> 1191;
1201 -> 1192;
1201 -> 1193;
1201 -> 1194;
1201 -> 1195;
1201 -> 1196;
1201 -> 1197;
1201 -> 1198;
1201 -> 1199;
1201 -> 1200;
1201 -> 1005;
1201 -> 1160;
1201 -> 1151;
1201 -> 1168;
1201 -> 1164;
1201 -> 1166;
1201 -> 0;
1201 -> 1003;
1202 -> 1003;
1203 -> 1201;
1203 -> 1202;
1204 -> 1201;
1204 -> 1202;
1205 -> 1201;
1205 -> 1202;
1206 -> 1205;
1206 -> 1201;
1206 -> 1202;
1207 -> 1203;
1207 -> 1202;
1208 -> 1202;
1209 -> 1204;
1209 -> 1202;
1210 -> 1206;
1210 -> 1207;
1210 -> 1208;
1210 -> 1209;
1210 -> 1201;
1210 -> 1202;
1211 -> 1201;
1211 -> 1202;
1212 -> 1211;
1212 -> 1210;
1212 -> 1202;
1213 -> 1201;
1213 -> 1202;
1214 -> 1213;
1214 -> 1212;
1214 -> 1202;
1215 -> 1201;
1215 -> 1202;
1216 -> 1215;
1216 -> 1214;
1216 -> 1202;
1217 -> 1201;
1217 -> 1202;
1218 -> 1217;
1218 -> 1216;
1218 -> 1202;
1219 -> 1201;
1219 -> 1202;
1220 -> 1202;
1221 -> 1219;
1221 -> 1218;
1221 -> 1220;
1221 -> 1202;
1222 -> 1221;
1223 -> 1222;
1223 -> 1219;
1223 -> 1221;
1224 -> 1219;
1224 -> 1218;
1224 -> 1223;
1224 -> 1221;
1225 -> 1221;
1226 -> 1224;
1226 -> 1225;
1227 -> 1219;
1227 -> 1225;
1228 -> 1227;
1228 -> 1218;
1228 -> 1225;
1229 -> 1228;
1229 -> 1218;
1229 -> 1223;
1229 -> 1225;
1230 -> 1221;
1231 -> 1219;
1231 -> 1218;
1231 -> 1223;
1231 -> 1202;
1232 -> 1219;
1232 -> 1231;
1233 -> 1231;
1234 -> 1232;
1234 -> 1233;
1235 -> 1219;
1235 -> 1233;
1236 -> 1235;
1236 -> 1231;
1236 -> 1233;
1237 -> 1231;
1238 -> 1231;
1238 -> 1003;
1239 -> 1231;
1239 -> 1003;
1240 -> 1231;
1240 -> 1003;
1241 -> 1151;
1241 -> 1240;
1241 -> 1231;
1241 -> 1239;
1241 -> 1003;
1242 -> 1003;
1243 -> 1003;
1244 -> 1243;
1244 -> 1003;
1245 -> 1231;
1245 -> 1003;
1246 -> 1239;
1246 -> 1003;
1247 -> 1241;
1247 -> 1003;
1248 -> 1151;
1248 -> 1003;
1249 -> 1151;
1249 -> 1241;
1249 -> 1003;
1250 -> 1007;
1250 -> 1003;
1251 -> 1010;
1251 -> 1003;
1252 -> 1242;
1252 -> 1003;
1253 -> 1243;
1253 -> 1003;
1254 -> 1245;
1254 -> 1246;
1254 -> 1247;
1254 -> 1248;
1254 -> 1249;
1254 -> 1250;
1254 -> 1251;
1254 -> 1252;
1254 -> 1253;
1254 -> 1241;
1254 -> 1239;
1254 -> 1244;
1254 -> 1003;
1255 -> 1003;
1256 -> 1003;
1257 -> 1256;
1257 -> 1231;
1257 -> 1254;
1257 -> 1003;
1258 -> 1231;
1258 -> 1254;
1258 -> 1256;
1258 -> 1257;
1259 -> 1258;
1259 -> 1254;
1259 -> 1257;
1260 -> 1231;
1260 -> 1256;
1260 -> 1254;
1260 -> 1259;
1261 -> 1259;
1262 -> 1260;
1262 -> 1261;
1263 -> 1262;
1263 -> 1260;
1263 -> 1261;
1264 -> 1261;
1265 -> 1262;
1265 -> 1264;
1266 -> 1265;
1266 -> 1261;
1267 -> 1261;
1268 -> 1262;
1268 -> 1267;
1269 -> 1267;
1270 -> 1268;
1270 -> 1269;
1271 -> 1270;
1271 -> 1260;
1271 -> 1269;
1272 -> 1270;
1272 -> 1260;
1272 -> 1271;
1273 -> 1272;
1273 -> 1270;
1273 -> 1271;
1274 -> 1271;
1275 -> 1274;
1275 -> 1270;
1275 -> 1271;
1276 -> 1270;
1276 -> 1272;
1276 -> 1273;
1276 -> 1269;
1277 -> 1276;
1277 -> 1267;
1278 -> 1268;
1278 -> 1272;
1278 -> 1267;
1279 -> 1278;
1279 -> 1261;
1280 -> 1261;
1281 -> 1261;
1282 -> 1263;
1282 -> 1281;
1283 -> 1263;
1283 -> 1281;
1284 -> 1266;
1284 -> 1281;
1285 -> 1279;
1285 -> 1281;
1286 -> 1280;
1286 -> 1281;
1287 -> 1281;
1288 -> 1286;
1288 -> 1287;
1289 -> 1287;
1290 -> 1288;
1290 -> 1289;
1293 -> 1292;
1293 -> 1291;
1294 -> 1291;
1295 -> 1289;
1296 -> 1290;
1296 -> 1295;
1297 -> 1295;
1298 -> 1296;
1298 -> 1297;
1299 -> 1298;
1299 -> 1297;
1300 -> 1296;
1300 -> 1295;
1301 -> 1289;
1302 -> 1301;
1302 -> 1290;
1302 -> 1289;
1303 -> 1290;
1303 -> 1289;
1304 -> 1288;
1304 -> 1287;
1305 -> 1288;
1305 -> 1287;
1306 -> 1288;
1306 -> 1287;
1307 -> 1288;
1307 -> 1287;
1308 -> 1288;
1308 -> 1287;
1309 -> 1288;
1309 -> 1287;
1310 -> 1288;
1310 -> 1287;
1311 -> 1286;
1311 -> 1281;
1312 -> 1286;
1312 -> 1281;
1313 -> 1286;
1313 -> 1281;
1314 -> 1281;
1315 -> 1282;
1315 -> 1314;
1315 -> 1281;
1316 -> 1281;
1317 -> 1283;
1317 -> 1316;
1317 -> 1281;
1318 -> 1282;
1318 -> 1286;
1318 -> 1281;
1319 -> 1283;
1319 -> 1286;
1319 -> 1281;
1320 -> 1282;
1320 -> 1272;
1320 -> 1273;
1320 -> 1275;
1320 -> 1281;
1321 -> 1281;
1322 -> 1321;
1322 -> 1282;
1322 -> 1272;
1322 -> 1273;
1322 -> 1275;
1322 -> 1281;
1323 -> 1286;
1323 -> 1322;
1325 -> 1324;
1326 -> 1282;
1326 -> 1272;
1326 -> 1321;
1326 -> 1273;
1326 -> 1275;
1326 -> 1322;
1327 -> 1285;
1327 -> 1322;
1328 -> 1321;
1328 -> 1322;
1329 -> 1322;
1330 -> 1322;
1331 -> 1323;
1331 -> 1330;
1332 -> 1326;
1332 -> 1330;
1333 -> 1327;
1333 -> 1330;
1334 -> 1328;
1334 -> 1330;
1335 -> 1329;
1335 -> 1330;
1336 -> 1331;
1336 -> 1330;
1337 -> 1332;
1337 -> 1330;
1338 -> 1333;
1338 -> 1330;
1339 -> 1334;
1339 -> 1330;
1340 -> 1330;
1341 -> 1336;
1341 -> 1340;
1342 -> 1337;
1342 -> 1340;
1343 -> 1338;
1343 -> 1340;
1344 -> 1339;
1344 -> 1340;
1345 -> 1335;
1345 -> 1340;
1346 -> 1340;
1347 -> 1345;
1347 -> 1346;
1348 -> 1346;
1349 -> 1347;
1349 -> 1348;
1350 -> 1348;
1351 -> 1349;
1351 -> 1350;
1352 -> 1351;
1352 -> 1350;
1353 -> 1347;
1353 -> 1346;
1354 -> 1345;
1354 -> 1340;
1355 -> 1345;
1355 -> 1340;
1356 -> 1345;
1356 -> 1340;
1357 -> 1345;
1357 -> 1340;
1358 -> 1345;
1358 -> 1340;
1359 -> 1345;
1359 -> 1340;
1360 -> 1345;
1360 -> 1340;
1361 -> 1340;
1362 -> 1361;
1362 -> 1340;
1363 -> 1325;
1363 -> 1340;
1364 -> 1362;
1364 -> 1363;
1364 -> 1340;
1365 -> 1364;
1365 -> 1345;
1365 -> 1340;
1366 -> 1340;
1367 -> 1366;
1367 -> 1340;
1368 -> 1325;
1368 -> 1340;
1369 -> 1367;
1369 -> 1368;
1369 -> 1340;
1370 -> 1369;
1370 -> 1345;
1370 -> 1340;
1371 -> 1345;
1371 -> 1340;
1372 -> 1345;
1372 -> 1340;
1373 -> 1345;
1373 -> 1340;
1374 -> 1345;
1374 -> 1340;
1375 -> 1340;
1376 -> 1341;
1376 -> 1375;
1376 -> 1340;
1377 -> 1340;
1378 -> 1342;
1378 -> 1377;
1378 -> 1340;
1379 -> 1341;
1379 -> 1345;
1379 -> 1340;
1380 -> 1344;
1380 -> 1345;
1380 -> 1340;
1381 -> 1342;
1381 -> 1345;
1381 -> 1340;
1382 -> 1343;
1382 -> 1345;
1382 -> 1340;
1383 -> 1345;
1383 -> 1340;
1384 -> 1340;
1385 -> 1340;
1386 -> 1383;
1386 -> 1385;
1387 -> 1384;
1387 -> 1385;
1388 -> 1385;
1389 -> 1387;
1389 -> 1388;
1390 -> 1388;
1391 -> 1389;
1391 -> 1390;
1392 -> 1390;
1393 -> 1391;
1393 -> 1392;
1394 -> 1392;
1395 -> 1393;
1395 -> 1394;
1396 -> 1395;
1396 -> 1394;
1397 -> 1391;
1397 -> 1390;
1398 -> 1391;
1398 -> 1390;
1399 -> 1389;
1399 -> 1388;
1400 -> 1389;
1400 -> 1388;
1401 -> 1389;
1401 -> 1388;
1402 -> 1387;
1402 -> 1385;
1403 -> 1385;
1404 -> 1386;
1404 -> 1403;
1404 -> 1385;
1405 -> 1386;
1405 -> 1387;
1405 -> 1385;
1406 -> 1384;
1406 -> 1345;
1406 -> 1340;
1407 -> 1345;
1407 -> 1340;
1408 -> 1407;
1408 -> 1352;
1408 -> 1353;
1408 -> 1379;
1408 -> 1380;
1408 -> 1381;
1408 -> 1406;
1408 -> 1358;
1408 -> 1359;
1408 -> 1360;
1408 -> 1365;
1408 -> 1370;
1408 -> 1382;
1408 -> 1372;
1408 -> 1373;
1408 -> 1374;
1408 -> 1364;
1408 -> 1369;
1408 -> 1299;
1408 -> 1300;
1408 -> 1302;
1408 -> 1303;
1408 -> 1304;
1408 -> 1305;
1408 -> 1306;
1408 -> 1307;
1408 -> 1308;
1408 -> 1309;
1408 -> 1310;
1408 -> 1318;
1408 -> 1319;
1408 -> 1313;
1408 -> 1301;
1408 -> 1326;
1408 -> 1396;
1408 -> 1397;
1408 -> 1398;
1408 -> 1399;
1408 -> 1400;
1408 -> 1401;
1408 -> 1405;
1408 -> 1340;
1409 -> 1408;
1409 -> 1345;
1409 -> 1340;
1410 -> 1330;
1411 -> 1334;
1411 -> 1410;
1411 -> 1330;
1412 -> 1329;
1412 -> 1321;
1412 -> 1320;
1412 -> 1322;
1413 -> 1320;
1413 -> 1281;
1414 -> 1413;
1414 -> 1320;
1414 -> 1412;
1414 -> 1408;
1414 -> 1409;
1414 -> 1281;
1415 -> 1414;
1415 -> 1286;
1415 -> 1281;
1416 -> 1284;
1416 -> 1286;
1416 -> 1281;
1417 -> 1280;
1417 -> 1259;
1418 -> 1417;
1418 -> 1258;
1418 -> 1259;
1419 -> 1256;
1419 -> 1259;
1420 -> 1255;
1420 -> 1419;
1420 -> 1259;
1421 -> 1231;
1421 -> 1256;
1421 -> 1414;
1421 -> 1415;
1421 -> 1416;
1421 -> 1257;
1422 -> 1257;
1423 -> 1421;
1423 -> 1422;
1424 -> 1257;
1425 -> 1258;
1425 -> 1254;
1425 -> 1418;
1425 -> 1424;
1426 -> 1425;
1426 -> 1421;
1426 -> 1424;
1427 -> 1423;
1427 -> 1426;
1427 -> 1257;
1428 -> 1421;
1429 -> 1428;
1429 -> 1421;
1430 -> 1421;
1431 -> 1421;
1432 -> 1421;
1433 -> 1421;
1434 -> 1421;
1435 -> 1421;
1436 -> 1421;
1437 -> 1421;
1438 -> 1421;
1439 -> 1421;
1440 -> 1421;
1441 -> 1421;
1442 -> 1421;
1443 -> 1421;
1444 -> 1421;
1445 -> 1257;
1445 -> 1421;
1446 -> 1255;
1446 -> 1420;
1446 -> 1445;
1446 -> 1421;
1447 -> 1421;
1448 -> 1421;
1449 -> 1421;
1449 -> 1444;
1449 -> 1448;
1450 -> 1449;
1450 -> 1421;
1450 -> 1448;
1451 -> 1447;
1451 -> 1450;
1451 -> 1421;
1452 -> 1447;
1452 -> 1421;
1453 -> 1447;
1453 -> 1421;
1454 -> 1447;
1455 -> 1447;
1456 -> 1447;
1457 -> 1447;
1458 -> 1447;
1459 -> 1447;
1460 -> 1447;
1461 -> 1447;
1462 -> 1447;
1463 -> 1447;
1463 -> 1443;
1463 -> 1421;
1464 -> 1447;
1464 -> 1421;
1465 -> 1421;
1466 -> 1421;
1466 -> 1464;
1466 -> 1448;
1467 -> 1466;
1467 -> 1447;
1467 -> 1448;
1468 -> 1447;
1469 -> 1468;
1469 -> 1447;
1470 -> 1447;
1471 -> 1447;
1472 -> 1447;
1473 -> 1447;
1474 -> 1447;
1475 -> 1447;
1476 -> 1421;
1476 -> 1447;
1477 -> 1255;
1477 -> 1420;
1477 -> 1446;
1477 -> 1476;
1477 -> 1447;
1478 -> 1447;
1479 -> 1447;
1479 -> 1475;
1479 -> 1478;
1480 -> 1479;
1480 -> 1447;
1480 -> 1478;
1481 -> 1447;
1482 -> 1004;
1482 -> 1003;
1483 -> 1005;
1483 -> 1447;
1483 -> 1003;
1484 -> 1004;
1484 -> 1447;
1484 -> 1003;
1485 -> 1003;
1487 -> 1151;
1487 -> 1003;
1488 -> 1003;
1489 -> 1482;
1489 -> 1488;
1490 -> 1483;
1490 -> 1488;
1491 -> 1484;
1491 -> 1488;
1492 -> 1487;
1492 -> 1488;
1493 -> 1485;
1493 -> 1488;
1494 -> 1488;
1495 -> 1493;
1495 -> 1494;
1496 -> 1494;
1497 -> 1495;
1497 -> 1496;
1498 -> 1496;
1499 -> 1497;
1499 -> 1498;
1500 -> 1498;
1501 -> 1499;
1501 -> 1500;
1502 -> 1501;
1502 -> 1500;
1503 -> 1499;
1503 -> 1498;
1504 -> 1496;
1505 -> 1504;
1505 -> 1497;
1505 -> 1496;
1506 -> 1497;
1506 -> 1496;
1507 -> 1495;
1507 -> 1494;
1508 -> 1495;
1508 -> 1494;
1509 -> 1495;
1509 -> 1494;
1510 -> 1495;
1510 -> 1494;
1511 -> 1495;
1511 -> 1494;
1512 -> 1495;
1512 -> 1494;
1513 -> 1495;
1513 -> 1494;
1514 -> 1493;
1514 -> 1488;
1515 -> 1493;
1515 -> 1488;
1516 -> 1493;
1516 -> 1488;
1517 -> 1493;
1517 -> 1488;
1518 -> 1493;
1518 -> 1488;
1519 -> 1493;
1519 -> 1488;
1520 -> 1493;
1520 -> 1488;
1521 -> 1493;
1521 -> 1488;
1522 -> 1493;
1522 -> 1488;
1523 -> 1488;
1524 -> 1523;
1524 -> 1493;
1524 -> 1488;
1525 -> 1488;
1526 -> 1525;
1526 -> 1493;
1526 -> 1488;
1527 -> 1488;
1528 -> 1527;
1528 -> 1493;
1528 -> 1488;
1529 -> 1493;
1529 -> 1488;
1530 -> 1493;
1530 -> 1488;
1531 -> 1488;
1532 -> 1489;
1532 -> 1531;
1532 -> 1488;
1533 -> 1488;
1534 -> 1490;
1534 -> 1533;
1534 -> 1488;
1535 -> 1491;
1535 -> 1488;
1536 -> 1492;
1536 -> 1151;
1536 -> 1488;
1537 -> 1489;
1537 -> 1493;
1537 -> 1488;
1538 -> 1490;
1538 -> 1493;
1538 -> 1488;
1539 -> 1488;
1540 -> 1539;
1540 -> 1492;
1540 -> 1151;
1540 -> 1488;
1541 -> 1493;
1541 -> 1488;
1542 -> 1488;
1543 -> 1489;
1543 -> 1542;
1544 -> 1543;
1544 -> 1484;
1544 -> 1542;
1545 -> 1544;
1545 -> 1488;
1546 -> 1491;
1546 -> 1488;
1547 -> 1488;
1548 -> 1488;
1549 -> 1541;
1549 -> 1548;
1550 -> 1545;
1550 -> 1548;
1551 -> 1546;
1551 -> 1548;
1552 -> 1547;
1552 -> 1548;
1553 -> 1548;
1554 -> 1552;
1554 -> 1553;
1555 -> 1553;
1556 -> 1554;
1556 -> 1555;
1557 -> 1555;
1558 -> 1556;
1558 -> 1557;
1559 -> 1558;
1559 -> 1557;
1560 -> 1554;
1560 -> 1553;
1561 -> 1552;
1561 -> 1548;
1562 -> 0;
1562 -> 1552;
1562 -> 1548;
1563 -> 1552;
1563 -> 1548;
1564 -> 1552;
1564 -> 1548;
1565 -> 1552;
1565 -> 1548;
1566 -> 1552;
1566 -> 1548;
1567 -> 1552;
1567 -> 1548;
1568 -> 1548;
1569 -> 1549;
1569 -> 1568;
1569 -> 1548;
1570 -> 1549;
1570 -> 1552;
1570 -> 1548;
1571 -> 1550;
1571 -> 1552;
1571 -> 1548;
1572 -> 1551;
1572 -> 1552;
1572 -> 1548;
1573 -> 1540;
1573 -> 1547;
1573 -> 1559;
1573 -> 1560;
1573 -> 1570;
1573 -> 1562;
1573 -> 1571;
1573 -> 1564;
1573 -> 1565;
1573 -> 1566;
1573 -> 1572;
1573 -> 1502;
1573 -> 1503;
1573 -> 1505;
1573 -> 1506;
1573 -> 1507;
1573 -> 1508;
1573 -> 1509;
1573 -> 1510;
1573 -> 1511;
1573 -> 1512;
1573 -> 1513;
1573 -> 1537;
1573 -> 1515;
1573 -> 1538;
1573 -> 1517;
1573 -> 1518;
1573 -> 1519;
1573 -> 1520;
1573 -> 1521;
1573 -> 1522;
1573 -> 1524;
1573 -> 1526;
1573 -> 1528;
1573 -> 1529;
1573 -> 1530;
1573 -> 1504;
1573 -> 1544;
1573 -> 1523;
1573 -> 1525;
1573 -> 1527;
1573 -> 1488;
1574 -> 1488;
1575 -> 1489;
1575 -> 1574;
1576 -> 1575;
1576 -> 1573;
1576 -> 1574;
1577 -> 1576;
1577 -> 1488;
1578 -> 1577;
1578 -> 1488;
1579 -> 1492;
1579 -> 1488;
1580 -> 1540;
1580 -> 1573;
1580 -> 1488;
1581 -> 1580;
1581 -> 1493;
1581 -> 1488;
1582 -> 1488;
1583 -> 1489;
1583 -> 1582;
1584 -> 1583;
1584 -> 1573;
1584 -> 1582;
1585 -> 1584;
1585 -> 1488;
1586 -> 1585;
1586 -> 1573;
1586 -> 1581;
1586 -> 1488;
1587 -> 1003;
1588 -> 1003;
1589 -> 1231;
1589 -> 1588;
1589 -> 1003;
1590 -> 1589;
1591 -> 1231;
1591 -> 1573;
1591 -> 1581;
1591 -> 1590;
1592 -> 1591;
1592 -> 1003;
1593 -> 1003;
1594 -> 1592;
1594 -> 1593;
1595 -> 1485;
1595 -> 1593;
1596 -> 1593;
1597 -> 1595;
1597 -> 1573;
1597 -> 1596;
1597 -> 1593;
1598 -> 1594;
1598 -> 1595;
1598 -> 1593;
1599 -> 1003;
1600 -> 1003;
1601 -> 1003;
1602 -> 1231;
1602 -> 1573;
1602 -> 1601;
1602 -> 1003;
1603 -> 1003;
1604 -> 1603;
1604 -> 1003;
1605 -> 1485;
1605 -> 1003;
1606 -> 1151;
1606 -> 1003;
1607 -> 1602;
1607 -> 1003;
1608 -> 1231;
1608 -> 1003;
1609 -> 1600;
1609 -> 1003;
1610 -> 1603;
1610 -> 1003;
1611 -> 1003;
1612 -> 1605;
1612 -> 1611;
1613 -> 1606;
1613 -> 1611;
1614 -> 1607;
1614 -> 1611;
1615 -> 1608;
1615 -> 1611;
1616 -> 1609;
1616 -> 1611;
1617 -> 1610;
1617 -> 1611;
1618 -> 1611;
1619 -> 1612;
1619 -> 1618;
1620 -> 1619;
1620 -> 1573;
1620 -> 1581;
1620 -> 1618;
1621 -> 1620;
1621 -> 1611;
1622 -> 1611;
1623 -> 1622;
1623 -> 1613;
1623 -> 1151;
1623 -> 1611;
1624 -> 1621;
1624 -> 1573;
1624 -> 1580;
1624 -> 1623;
1624 -> 1611;
1625 -> 1611;
1626 -> 1621;
1626 -> 1573;
1626 -> 1580;
1626 -> 1625;
1626 -> 1611;
1627 -> 1626;
1627 -> 1611;
1628 -> 1611;
1629 -> 1611;
1630 -> 1629;
1630 -> 1621;
1630 -> 1573;
1630 -> 1580;
1630 -> 1611;
1631 -> 1630;
1632 -> 1631;
1632 -> 1630;
1633 -> 1614;
1633 -> 1632;
1634 -> 1633;
1634 -> 1630;
1635 -> 1633;
1635 -> 1630;
1636 -> 1630;
1637 -> 1630;
1638 -> 1637;
1638 -> 1633;
1638 -> 1630;
1639 -> 1638;
1640 -> 1615;
1640 -> 1573;
1640 -> 1581;
1640 -> 1598;
1640 -> 1639;
1640 -> 1638;
1641 -> 1638;
1642 -> 1615;
1642 -> 1573;
1642 -> 1581;
1642 -> 1598;
1642 -> 1641;
1642 -> 1638;
1643 -> 1628;
1643 -> 1637;
1643 -> 1638;
1644 -> 1642;
1644 -> 1573;
1644 -> 1581;
1644 -> 1598;
1644 -> 1580;
1644 -> 1643;
1644 -> 1638;
1645 -> 1644;
1645 -> 1573;
1645 -> 1580;
1645 -> 1638;
1646 -> 1644;
1646 -> 1573;
1646 -> 1580;
1646 -> 1638;
1647 -> 1615;
1647 -> 1646;
1648 -> 1644;
1648 -> 1646;
1649 -> 1636;
1649 -> 1646;
1650 -> 1646;
1651 -> 1647;
1651 -> 1650;
1652 -> 1648;
1652 -> 1650;
1653 -> 1649;
1653 -> 1650;
1654 -> 1652;
1654 -> 1573;
1654 -> 1580;
1654 -> 1650;
1655 -> 1652;
1655 -> 1573;
1655 -> 1580;
1655 -> 1650;
1656 -> 1651;
1656 -> 1573;
1656 -> 1581;
1656 -> 1598;
1656 -> 1652;
1656 -> 1580;
1656 -> 1650;
1657 -> 1656;
1657 -> 1650;
1658 -> 1650;
1659 -> 1652;
1659 -> 1573;
1659 -> 1580;
1659 -> 1658;
1659 -> 1650;
1660 -> 1656;
1660 -> 1650;
1661 -> 1660;
1661 -> 1637;
1661 -> 1635;
1661 -> 1646;
1662 -> 1644;
1662 -> 1573;
1662 -> 1580;
1662 -> 1637;
1662 -> 1634;
1662 -> 1638;
1663 -> 1628;
1663 -> 1638;
1664 -> 1642;
1664 -> 1573;
1664 -> 1581;
1664 -> 1598;
1664 -> 1580;
1664 -> 1663;
1664 -> 1638;
1665 -> 1664;
1665 -> 1573;
1665 -> 1580;
1665 -> 1638;
1666 -> 1664;
1666 -> 1573;
1666 -> 1580;
1666 -> 1638;
1667 -> 1615;
1667 -> 1666;
1668 -> 1664;
1668 -> 1666;
1669 -> 1666;
1670 -> 1667;
1670 -> 1669;
1671 -> 1668;
1671 -> 1669;
1672 -> 1671;
1672 -> 1573;
1672 -> 1580;
1672 -> 1669;
1673 -> 1671;
1673 -> 1573;
1673 -> 1580;
1673 -> 1669;
1674 -> 1670;
1674 -> 1573;
1674 -> 1581;
1674 -> 1598;
1674 -> 1671;
1674 -> 1580;
1674 -> 1669;
1675 -> 1674;
1675 -> 1669;
1676 -> 1669;
1677 -> 1671;
1677 -> 1573;
1677 -> 1580;
1677 -> 1676;
1677 -> 1669;
1678 -> 1674;
1678 -> 1669;
1679 -> 1678;
1679 -> 1638;
1679 -> 1635;
1679 -> 1666;
1680 -> 1664;
1680 -> 1573;
1680 -> 1580;
1680 -> 1638;
1680 -> 1634;
1681 -> 1634;
1681 -> 1630;
1682 -> 1681;
1682 -> 1634;
1682 -> 1662;
1682 -> 1680;
1682 -> 1573;
1682 -> 1581;
1682 -> 1598;
1682 -> 1580;
1682 -> 1630;
1683 -> 1635;
1683 -> 1630;
1684 -> 1683;
1684 -> 1635;
1684 -> 1661;
1684 -> 1679;
1684 -> 1682;
1684 -> 1630;
1685 -> 1653;
1685 -> 1630;
1686 -> 1682;
1686 -> 1684;
1686 -> 1685;
1686 -> 1630;
1687 -> 1630;
1688 -> 1621;
1688 -> 1629;
1688 -> 1573;
1688 -> 1581;
1688 -> 1598;
1688 -> 1580;
1688 -> 1686;
1688 -> 1630;
1689 -> 1686;
1689 -> 1630;
1690 -> 1612;
1690 -> 1630;
1691 -> 1630;
1692 -> 1689;
1692 -> 1691;
1693 -> 1690;
1693 -> 1691;
1694 -> 1688;
1694 -> 1691;
1695 -> 1691;
1696 -> 1692;
1696 -> 1695;
1696 -> 1691;
1697 -> 1691;
1698 -> 1694;
1698 -> 1697;
1699 -> 1697;
1700 -> 1698;
1700 -> 1688;
1700 -> 1699;
1700 -> 1697;
1701 -> 1691;
1702 -> 1692;
1702 -> 1694;
1702 -> 1691;
1703 -> 1630;
1704 -> 1628;
1704 -> 1633;
1704 -> 1630;
1705 -> 1627;
1705 -> 1611;
1706 -> 1003;
1707 -> 1003;
1708 -> 1255;
1708 -> 1420;
1708 -> 1446;
1708 -> 1477;
1708 -> 1707;
1708 -> 1003;
1709 -> 1231;
1709 -> 1708;
1710 -> 1255;
1710 -> 1708;
1711 -> 1485;
1711 -> 1708;
1712 -> 1231;
1712 -> 1708;
1713 -> 1616;
1713 -> 1708;
1714 -> 1708;
1715 -> 1710;
1715 -> 1714;
1716 -> 1711;
1716 -> 1714;
1717 -> 1712;
1717 -> 1714;
1718 -> 1712;
1718 -> 1714;
1719 -> 1713;
1719 -> 1714;
1720 -> 1714;
1721 -> 1715;
1721 -> 1255;
1721 -> 1420;
1721 -> 1446;
1721 -> 1477;
1721 -> 1720;
1721 -> 1714;
1722 -> 1714;
1723 -> 1716;
1723 -> 1722;
1724 -> 1723;
1724 -> 1688;
1724 -> 1722;
1725 -> 1724;
1725 -> 1714;
1726 -> 1714;
1727 -> 1725;
1727 -> 1726;
1727 -> 1714;
1728 -> 1715;
1728 -> 1714;
1729 -> 1717;
1729 -> 1728;
1729 -> 1688;
1729 -> 1702;
1730 -> 1728;
1731 -> 1729;
1731 -> 1730;
1731 -> 1728;
1732 -> 1717;
1732 -> 1728;
1732 -> 1729;
1732 -> 1731;
1733 -> 1732;
1733 -> 1731;
1734 -> 1718;
1734 -> 1731;
1735 -> 1718;
1735 -> 1732;
1735 -> 1728;
1735 -> 1731;
1736 -> 1719;
1736 -> 1731;
1737 -> 1716;
1737 -> 1731;
1738 -> 1731;
1739 -> 1733;
1739 -> 1738;
1740 -> 1734;
1740 -> 1738;
1741 -> 1735;
1741 -> 1738;
1742 -> 1736;
1742 -> 1738;
1743 -> 1737;
1743 -> 1738;
1744 -> 1741;
1744 -> 1732;
1744 -> 1738;
1745 -> 1741;
1745 -> 1732;
1745 -> 1738;
1746 -> 1741;
1746 -> 1732;
1746 -> 1738;
1747 -> 1738;
1748 -> 1746;
1748 -> 1747;
1749 -> 1748;
1749 -> 1732;
1749 -> 1747;
1750 -> 1749;
1750 -> 1738;
1751 -> 1750;
1751 -> 1732;
1751 -> 1738;
1752 -> 1738;
1753 -> 1738;
1754 -> 1753;
1754 -> 1751;
1754 -> 1738;
1755 -> 1739;
1755 -> 1732;
1755 -> 1753;
1755 -> 1754;
1756 -> 1755;
1756 -> 1754;
1757 -> 1755;
1757 -> 1754;
1758 -> 1754;
1759 -> 1739;
1759 -> 1758;
1760 -> 1759;
1760 -> 1755;
1760 -> 1758;
1761 -> 1760;
1761 -> 1754;
1762 -> 1752;
1762 -> 1754;
1763 -> 1756;
1763 -> 1754;
1764 -> 1754;
1765 -> 1755;
1765 -> 1754;
1766 -> 1761;
1766 -> 1762;
1766 -> 1763;
1766 -> 1764;
1766 -> 1765;
1766 -> 1755;
1766 -> 1756;
1766 -> 1754;
1767 -> 1754;
1768 -> 1754;
1769 -> 1768;
1769 -> 1755;
1769 -> 1754;
1770 -> 1756;
1770 -> 1754;
1771 -> 1770;
1771 -> 1766;
1771 -> 1754;
1772 -> 1757;
1772 -> 1754;
1773 -> 1767;
1773 -> 1754;
1774 -> 1771;
1774 -> 1772;
1774 -> 1773;
1774 -> 1754;
1775 -> 1750;
1775 -> 1753;
1775 -> 1732;
1775 -> 1774;
1775 -> 1754;
1776 -> 1774;
1776 -> 1754;
1777 -> 1743;
1777 -> 1754;
1778 -> 1754;
1779 -> 1776;
1779 -> 1778;
1780 -> 1777;
1780 -> 1778;
1781 -> 1775;
1781 -> 1778;
1782 -> 1778;
1783 -> 1779;
1783 -> 1782;
1783 -> 1778;
1784 -> 1778;
1785 -> 1781;
1785 -> 1784;
1786 -> 1784;
1787 -> 1785;
1787 -> 1775;
1787 -> 1786;
1787 -> 1784;
1788 -> 1778;
1789 -> 1754;
1790 -> 1752;
1790 -> 1755;
1790 -> 1754;
1791 -> 1731;
1792 -> 1742;
1792 -> 1779;
1793 -> 1716;
1793 -> 1779;
1794 -> 1779;
1795 -> 1793;
1795 -> 1779;
1796 -> 1779;
1797 -> 1779;
1798 -> 1779;
1799 -> 1779;
1799 -> 1798;
1800 -> 1799;
1800 -> 1779;
1800 -> 1798;
1801 -> 1794;
1801 -> 1800;
1802 -> 1799;
1802 -> 1800;
1803 -> 1779;
1803 -> 1800;
1804 -> 1800;
1805 -> 1801;
1805 -> 1804;
1806 -> 1802;
1806 -> 1804;
1807 -> 1803;
1807 -> 1804;
1808 -> 1806;
1808 -> 1779;
1808 -> 1804;
1809 -> 1806;
1809 -> 1779;
1809 -> 1804;
1810 -> 1805;
1810 -> 1804;
1811 -> 1804;
1812 -> 1806;
1812 -> 1779;
1812 -> 1811;
1812 -> 1804;
1813 -> 1805;
1813 -> 1798;
1813 -> 1779;
1813 -> 1800;
1814 -> 1779;
1814 -> 1798;
1814 -> 1800;
1815 -> 1792;
1815 -> 1800;
1816 -> 1800;
1817 -> 1814;
1817 -> 1816;
1818 -> 1815;
1818 -> 1816;
1819 -> 1816;
1820 -> 1816;
1821 -> 1818;
1821 -> 1820;
1821 -> 1816;
1822 -> 1821;
1823 -> 1817;
1823 -> 1816;
1824 -> 1816;
1825 -> 1816;
1826 -> 1823;
1826 -> 1825;
1827 -> 1824;
1827 -> 1825;
1828 -> 1825;
1829 -> 1827;
1829 -> 1825;
1830 -> 1827;
1830 -> 1825;
1831 -> 1825;
1832 -> 1826;
1832 -> 1831;
1832 -> 1825;
1833 -> 1826;
1833 -> 1827;
1833 -> 1825;
1834 -> 1827;
1834 -> 1825;
1835 -> 1825;
1836 -> 1825;
1837 -> 1834;
1837 -> 1836;
1838 -> 1835;
1838 -> 1836;
1839 -> 1835;
1839 -> 1836;
1840 -> 1836;
1841 -> 1839;
1841 -> 1836;
1842 -> 1839;
1842 -> 1836;
1843 -> 1839;
1843 -> 1836;
1844 -> 1836;
1845 -> 1837;
1845 -> 1844;
1845 -> 1836;
1846 -> 1836;
1847 -> 1838;
1847 -> 1846;
1847 -> 1836;
1848 -> 1837;
1848 -> 1839;
1848 -> 1836;
1849 -> 1838;
1849 -> 1839;
1849 -> 1836;
1850 -> 1839;
1850 -> 1836;
1851 -> 1836;
1852 -> 1836;
1853 -> 1850;
1853 -> 1852;
1854 -> 1851;
1854 -> 1852;
1855 -> 1852;
1856 -> 1854;
1856 -> 1852;
1857 -> 1854;
1857 -> 1852;
1858 -> 1852;
1859 -> 1853;
1859 -> 1858;
1859 -> 1852;
1860 -> 1853;
1860 -> 1854;
1860 -> 1852;
1861 -> 0;
1861 -> 1854;
1861 -> 1852;
1862 -> 1851;
1862 -> 1839;
1862 -> 1836;
1863 -> 1835;
1863 -> 1827;
1863 -> 1825;
1864 -> 1817;
1864 -> 1816;
1865 -> 1824;
1865 -> 1816;
1866 -> 1822;
1866 -> 1864;
1866 -> 1865;
1866 -> 1816;
1867 -> 1824;
1867 -> 1816;
1868 -> 1867;
1868 -> 1800;
1869 -> 1868;
1869 -> 1798;
1869 -> 1779;
1869 -> 1800;
1870 -> 1817;
1870 -> 1822;
1871 -> 1819;
1871 -> 1822;
1872 -> 1822;
1872 -> 1870;
1872 -> 1871;
1872 -> 1779;
1872 -> 1866;
1872 -> 1827;
1872 -> 1833;
1872 -> 1863;
1872 -> 1839;
1872 -> 1848;
1872 -> 1849;
1872 -> 1862;
1872 -> 1854;
1872 -> 1861;
1872 -> 1860;
1873 -> 1872;
1874 -> 1872;
1875 -> 1872;
1876 -> 1872;
1877 -> 1872;
1878 -> 1872;
1879 -> 1872;
1880 -> 1872;
1881 -> 1872;
1882 -> 1872;
1883 -> 1872;
1884 -> 1872;
1885 -> 1884;
1885 -> 1798;
1885 -> 1779;
1885 -> 1872;
1886 -> 1779;
1886 -> 1813;
1886 -> 1869;
1886 -> 1885;
1886 -> 1872;
1887 -> 1795;
1887 -> 1779;
1888 -> 1779;
1889 -> 1886;
1889 -> 1888;
1889 -> 1779;
1890 -> 1779;
1891 -> 1886;
1891 -> 1890;
1892 -> 1890;
1893 -> 1891;
1893 -> 1886;
1893 -> 1892;
1893 -> 1890;
1894 -> 1779;
1895 -> 1779;
1896 -> 1716;
1896 -> 1886;
1897 -> 1896;
1897 -> 1886;
1898 -> 1886;
1899 -> 1886;
1900 -> 1886;
1901 -> 1886;
1902 -> 1886;
1903 -> 1886;
1904 -> 1897;
1904 -> 1886;
1905 -> 1886;
1906 -> 1886;
1907 -> 1886;
1907 -> 1906;
1908 -> 1906;
1909 -> 1907;
1909 -> 1886;
1909 -> 1908;
1909 -> 1906;
1910 -> 1886;
1911 -> 1886;
1912 -> 1714;
1913 -> 1714;
1914 -> 1716;
1914 -> 1913;
1915 -> 1914;
1915 -> 1886;
1915 -> 1913;
1916 -> 1915;
1916 -> 1714;
1917 -> 1714;
1918 -> 1714;
1919 -> 1916;
1919 -> 1918;
1920 -> 1918;
1921 -> 1919;
1921 -> 1920;
1922 -> 1920;
1923 -> 1921;
1923 -> 1916;
1923 -> 1922;
1923 -> 1920;
1924 -> 1918;
1925 -> 1919;
1925 -> 1916;
1925 -> 1918;
1926 -> 1715;
1926 -> 1714;
1927 -> 1718;
1927 -> 1916;
1927 -> 1926;
1928 -> 1927;
1928 -> 1916;
1928 -> 1926;
1929 -> 1927;
1929 -> 1916;
1929 -> 1926;
1930 -> 1717;
1930 -> 1926;
1930 -> 1916;
1931 -> 1926;
1932 -> 1930;
1932 -> 1931;
1933 -> 1912;
1933 -> 1926;
1934 -> 1717;
1934 -> 1926;
1934 -> 1932;
1935 -> 1926;
1936 -> 1934;
1936 -> 1935;
1937 -> 1927;
1937 -> 1916;
1937 -> 1926;
1938 -> 1937;
1938 -> 1934;
1938 -> 1926;
1939 -> 1926;
1940 -> 1912;
1940 -> 1933;
1940 -> 1939;
1940 -> 1926;
1941 -> 1725;
1941 -> 1926;
1942 -> 1926;
1943 -> 1941;
1943 -> 1942;
1944 -> 1927;
1944 -> 1916;
1944 -> 1942;
1945 -> 1942;
1946 -> 1944;
1946 -> 1934;
1946 -> 1945;
1946 -> 1942;
1947 -> 1943;
1947 -> 1944;
1947 -> 1942;
1948 -> 1926;
1949 -> 1718;
1949 -> 1934;
1949 -> 1947;
1949 -> 1926;
1950 -> 1949;
1950 -> 1934;
1950 -> 1926;
1951 -> 1949;
1951 -> 1934;
1951 -> 1926;
1952 -> 1717;
1952 -> 1926;
1952 -> 1934;
1952 -> 1947;
1953 -> 1952;
1953 -> 1935;
1954 -> 1949;
1954 -> 1934;
1954 -> 1926;
1955 -> 1717;
1955 -> 1954;
1955 -> 1952;
1956 -> 1954;
1957 -> 1955;
1957 -> 1956;
1958 -> 1949;
1958 -> 1955;
1958 -> 1945;
1958 -> 1942;
1959 -> 1955;
1959 -> 1926;
1960 -> 1955;
1960 -> 1926;
1961 -> 1955;
1961 -> 1935;
1962 -> 1955;
1963 -> 1955;
1963 -> 1945;
1963 -> 1942;
1964 -> 1912;
1964 -> 1933;
1964 -> 1714;
1965 -> 1714;
1966 -> 1886;
1966 -> 1965;
1966 -> 1714;
1967 -> 1886;
1967 -> 1955;
1967 -> 1966;
1968 -> 1725;
1968 -> 1967;
1969 -> 1967;
1970 -> 1968;
1970 -> 1969;
1971 -> 1969;
1972 -> 1967;
1973 -> 1970;
1974 -> 1708;
1975 -> 1004;
1975 -> 1955;
1975 -> 1003;
1976 -> 1004;
1976 -> 1955;
1976 -> 1975;
1977 -> 1005;
1977 -> 1955;
1977 -> 1976;
1978 -> 1255;
1978 -> 1976;
1979 -> 1231;
1979 -> 1976;
1980 -> 1976;
1981 -> 1978;
1981 -> 1980;
1982 -> 1979;
1982 -> 1980;
1983 -> 1979;
1983 -> 1980;
1984 -> 1981;
1984 -> 1980;
1985 -> 1983;
1985 -> 1955;
1985 -> 1970;
1985 -> 1984;
1986 -> 1985;
1986 -> 1955;
1986 -> 1984;
1987 -> 1982;
1987 -> 1984;
1987 -> 1955;
1987 -> 1970;
1988 -> 1984;
1989 -> 1987;
1989 -> 1988;
1989 -> 1984;
1990 -> 1982;
1990 -> 1984;
1990 -> 1987;
1990 -> 1989;
1991 -> 1985;
1991 -> 1955;
1991 -> 1989;
1992 -> 1990;
1992 -> 1991;
1992 -> 1989;
1993 -> 1992;
1993 -> 1984;
1994 -> 1976;
1995 -> 1254;
1995 -> 1976;
1996 -> 1151;
1996 -> 1976;
1997 -> 1231;
1997 -> 1976;
1998 -> 1006;
1998 -> 1992;
1998 -> 1976;
1999 -> 1591;
1999 -> 1976;
2000 -> 1485;
2000 -> 1976;
2001 -> 1999;
2001 -> 1976;
2002 -> 1705;
2002 -> 1976;
2003 -> 1976;
2004 -> 1485;
2004 -> 2003;
2005 -> 2003;
2006 -> 2004;
2006 -> 2005;
2007 -> 2006;
2007 -> 1998;
2007 -> 2005;
2008 -> 2007;
2008 -> 2003;
2009 -> 2003;
2010 -> 1976;
2011 -> 2008;
2011 -> 2010;
2012 -> 2010;
2013 -> 2011;
2013 -> 2012;
2014 -> 2012;
2015 -> 2013;
2015 -> 2008;
2015 -> 2014;
2015 -> 2012;
2016 -> 2010;
2017 -> 2011;
2017 -> 2008;
2017 -> 2010;
2018 -> 1976;
2019 -> 1485;
2019 -> 2018;
2020 -> 2018;
2021 -> 2019;
2021 -> 2020;
2022 -> 2021;
2022 -> 2008;
2022 -> 2020;
2023 -> 2018;
2024 -> 1976;
2025 -> 2022;
2025 -> 2024;
2026 -> 2024;
2027 -> 2025;
2027 -> 2026;
2028 -> 2026;
2029 -> 2027;
2029 -> 2022;
2029 -> 2028;
2029 -> 2026;
2030 -> 2024;
2031 -> 2025;
2031 -> 2022;
2031 -> 2024;
2032 -> 1005;
2032 -> 1995;
2032 -> 1996;
2032 -> 1997;
2032 -> 1998;
2032 -> 2001;
2032 -> 2002;
2032 -> 2017;
2032 -> 2031;
2032 -> 2022;
2032 -> 2008;
2032 -> 1151;
2032 -> 1992;
2032 -> 1705;
2032 -> 1254;
2032 -> 1976;
2033 -> 1004;
2033 -> 2032;
2033 -> 1976;
2034 -> 1005;
2034 -> 1976;
2035 -> 1005;
2035 -> 1004;
2035 -> 1976;
2036 -> 1485;
2036 -> 1004;
2036 -> 1976;
2037 -> 1003;
2038 -> 1006;
2038 -> 2032;
2038 -> 2035;
2038 -> 2036;
2038 -> 1003;
2039 -> 1007;
2039 -> 2038;
2039 -> 1003;
2040 -> 2037;
2040 -> 999;
2041 -> 1001;
2041 -> 2039;
2041 -> 2040;
2041 -> 999;
2042 -> 1001;
2042 -> 2039;
2042 -> 999;
2043 -> 1000;
2043 -> 2042;
2043 -> 999;
2044 -> 997;
2045 -> 996;
2045 -> 2042;
2045 -> 997;
2046 -> 996;
2046 -> 2042;
2046 -> 995;
2047 -> 2046;
2047 -> 980;
2048 -> 975;
2048 -> 994;
2048 -> 980;
2049 -> 975;
2049 -> 980;
2050 -> 980;
2051 -> 980;
2052 -> 2050;
2052 -> 2051;
2053 -> 2050;
2053 -> 2051;
2054 -> 2050;
2054 -> 2051;
2055 -> 2049;
2055 -> 2051;
2056 -> 976;
2056 -> 2051;
2057 -> 2051;
2058 -> 2056;
2058 -> 2057;
2059 -> 2058;
2059 -> 2047;
2059 -> 2057;
2060 -> 2057;
2061 -> 2059;
2061 -> 2060;
2063 -> 0;
2064 -> 0;
2065 -> 0;
2068 -> 2062;
2068 -> 2067;
2069 -> 2063;
2069 -> 2067;
2070 -> 2064;
2070 -> 2067;
2071 -> 2065;
2071 -> 2067;
2072 -> 2066;
2072 -> 2067;
2073 -> 2067;
2074 -> 2073;
2074 -> 2067;
2075 -> 2073;
2075 -> 2067;
2076 -> 2073;
2076 -> 2067;
2077 -> 2067;
2078 -> 2069;
2078 -> 2077;
2078 -> 2067;
2079 -> 2070;
2079 -> 0;
2079 -> 2067;
2080 -> 2071;
2080 -> 0;
2080 -> 2067;
2081 -> 2068;
2081 -> 2073;
2081 -> 2067;
2082 -> 2069;
2082 -> 2073;
2082 -> 2067;
2083 -> 2070;
2083 -> 2073;
2083 -> 2067;
2084 -> 2072;
2084 -> 2073;
2084 -> 2067;
2085 -> 2071;
2085 -> 2073;
2085 -> 2067;
2086 -> 2067;
2087 -> 2061;
2087 -> 2060;
2088 -> 2060;
2089 -> 2087;
2089 -> 2088;
2090 -> 2088;
2091 -> 2089;
2091 -> 2090;
2092 -> 2091;
2092 -> 2088;
2093 -> 2088;
2094 -> 2092;
2094 -> 2059;
2094 -> 2093;
2094 -> 2088;
2095 -> 2088;
2096 -> 2089;
2096 -> 2095;
2097 -> 2096;
2097 -> 2059;
2097 -> 2095;
2098 -> 2097;
2098 -> 2095;
2099 -> 2098;
2099 -> 2088;
2100 -> 2094;
2100 -> 2099;
2100 -> 2088;
2101 -> 2086;
2101 -> 2100;
2102 -> 2059;
2102 -> 2101;
2102 -> 2081;
2102 -> 2084;
2102 -> 2082;
2102 -> 2083;
2102 -> 2085;
2102 -> 0;
2102 -> 2057;
2103 -> 2102;
2103 -> 2051;
2104 -> 2055;
2104 -> 2051;
2105 -> 2051;
2106 -> 2104;
2106 -> 2105;
2107 -> 2103;
2107 -> 2105;
2108 -> 2105;
2109 -> 2106;
2109 -> 2048;
2109 -> 2108;
2110 -> 2108;
2111 -> 2107;
2111 -> 2102;
2111 -> 2110;
2112 -> 2110;
2113 -> 2111;
2113 -> 2112;
2114 -> 2113;
2114 -> 2102;
2114 -> 0;
2114 -> 2112;
2115 -> 2114;
2115 -> 2110;
2116 -> 2110;
2117 -> 2115;
2117 -> 2116;
2117 -> 2110;
2118 -> 2117;
2118 -> 2110;
2119 -> 2110;
2120 -> 2118;
2120 -> 2119;
2121 -> 2119;
2122 -> 2120;
2122 -> 2121;
2122 -> 2119;
2123 -> 2110;
2124 -> 2117;
2124 -> 2110;
2125 -> 2124;
2125 -> 2108;
2126 -> 2125;
2126 -> 2108;
2127 -> 0;
2127 -> 2126;
2128 -> 2126;
2129 -> 2127;
2129 -> 2128;
2130 -> 2107;
2130 -> 2102;
2130 -> 2128;
2131 -> 2130;
2131 -> 2102;
2131 -> 2128;
2132 -> 2129;
2132 -> 2128;
2133 -> 2131;
2133 -> 2132;
2133 -> 2128;
2134 -> 2125;
2134 -> 2108;
2135 -> 2106;
2135 -> 2108;
2136 -> 2108;
2137 -> 2134;
2137 -> 2136;
2138 -> 2135;
2138 -> 2136;
2139 -> 2107;
2139 -> 2102;
2139 -> 2136;
2140 -> 2137;
2140 -> 2136;
2141 -> 2136;
2142 -> 2140;
2142 -> 2141;
2143 -> 2139;
2143 -> 2141;
2144 -> 2143;
2144 -> 2102;
2144 -> 2133;
2144 -> 2142;
2144 -> 2141;
2145 -> 2144;
2146 -> 2108;
2147 -> 2133;
2147 -> 2110;
2148 -> 2147;
2148 -> 2119;
2149 -> 2148;
2149 -> 2121;
2149 -> 2119;
2150 -> 0;
2150 -> 2133;
2151 -> 2133;
2152 -> 2150;
2152 -> 2151;
2153 -> 2152;
2154 -> 2107;
2154 -> 2153;
2155 -> 2154;
2155 -> 2086;
2155 -> 2153;
2156 -> 2155;
2157 -> 2152;
2158 -> 0;
2158 -> 2152;
2159 -> 2152;
2160 -> 2158;
2160 -> 2159;
2161 -> 2133;
2161 -> 2108;
2162 -> 2161;
2162 -> 2136;
2163 -> 2162;
2163 -> 2136;
2164 -> 2163;
2164 -> 2141;
2165 -> 2143;
2165 -> 2102;
2165 -> 2133;
2165 -> 2152;
2165 -> 2160;
2165 -> 2164;
2165 -> 2141;
2166 -> 2165;
2167 -> 2160;
2167 -> 2110;
2168 -> 2167;
2168 -> 2119;
2169 -> 2168;
2169 -> 2121;
2169 -> 2119;
2170 -> 2160;
2171 -> 2051;
2172 -> 2051;
2173 -> 2051;
2174 -> 2052;
2174 -> 2173;
2174 -> 2051;
2175 -> 2051;
2176 -> 2056;
2176 -> 2175;
2177 -> 2175;
2178 -> 2176;
2178 -> 2177;
2179 -> 2177;
2180 -> 2178;
2180 -> 2179;
2181 -> 2180;
2181 -> 2102;
2181 -> 2179;
2182 -> 2180;
2182 -> 2102;
2182 -> 2179;
2183 -> 2182;
2183 -> 2177;
2184 -> 2178;
2184 -> 2102;
2184 -> 2177;
2185 -> 2184;
2185 -> 2102;
2185 -> 2133;
2185 -> 2152;
2185 -> 2160;
2185 -> 2177;
2186 -> 2178;
2186 -> 2185;
2186 -> 2177;
2187 -> 2186;
2187 -> 2175;
2188 -> 2187;
2188 -> 2051;
2189 -> 2172;
2189 -> 2051;
2190 -> 2055;
2190 -> 2051;
2191 -> 2189;
2191 -> 2190;
2191 -> 2188;
2191 -> 2048;
2191 -> 2185;
2191 -> 2109;
2191 -> 2051;
2192 -> 2051;
2193 -> 2192;
2194 -> 2192;
2195 -> 2191;
2195 -> 2192;
2196 -> 2192;
2197 -> 2195;
2197 -> 2196;
2198 -> 2196;
2199 -> 2197;
2199 -> 2198;
2199 -> 2196;
2200 -> 2192;
2201 -> 2191;
2201 -> 2192;
2202 -> 2192;
2203 -> 2201;
2203 -> 2191;
2203 -> 2202;
2203 -> 2192;
2204 -> 2192;
2205 -> 2201;
2205 -> 2204;
2206 -> 2204;
2207 -> 2204;
2208 -> 2205;
2208 -> 2207;
2209 -> 2208;
2209 -> 2191;
2209 -> 2207;
2210 -> 2209;
2210 -> 2204;
2211 -> 2204;
2212 -> 2210;
2212 -> 2211;
2213 -> 2211;
2214 -> 2212;
2214 -> 2213;
2215 -> 2214;
2215 -> 2211;
2216 -> 2212;
2216 -> 2211;
2217 -> 2211;
2218 -> 2215;
2218 -> 2204;
2219 -> 2218;
2219 -> 2215;
2220 -> 2206;
2220 -> 2204;
2221 -> 2220;
2221 -> 2192;
2222 -> 2201;
2222 -> 2215;
2222 -> 2192;
2223 -> 2192;
2224 -> 2221;
2224 -> 2223;
2225 -> 2222;
2225 -> 2223;
2226 -> 2202;
2226 -> 2223;
2227 -> 2202;
2227 -> 2223;
2228 -> 2202;
2228 -> 2223;
2229 -> 2202;
2229 -> 2223;
2230 -> 2201;
2230 -> 2223;
2231 -> 2223;
2232 -> 2223;
2233 -> 2230;
2233 -> 2232;
2234 -> 2233;
2234 -> 2215;
2234 -> 2232;
2235 -> 2234;
2235 -> 2223;
2236 -> 2223;
2237 -> 2236;
2237 -> 2223;
2238 -> 2224;
2238 -> 2223;
2239 -> 2226;
2239 -> 2223;
2240 -> 2231;
2240 -> 2223;
2241 -> 2235;
2241 -> 2223;
2242 -> 2229;
2242 -> 2223;
2243 -> 2228;
2243 -> 2223;
2244 -> 2236;
2244 -> 2223;
2245 -> 2223;
2246 -> 2238;
2246 -> 2245;
2247 -> 2239;
2247 -> 2245;
2248 -> 2240;
2248 -> 2245;
2249 -> 2241;
2249 -> 2245;
2250 -> 2242;
2250 -> 2245;
2251 -> 2243;
2251 -> 2245;
2252 -> 2244;
2252 -> 2245;
2253 -> 2230;
2253 -> 2245;
2254 -> 2253;
2254 -> 2245;
2255 -> 2245;
2256 -> 2245;
2257 -> 2245;
2258 -> 2245;
2259 -> 2258;
2259 -> 2246;
2259 -> 2221;
2259 -> 2245;
2260 -> 2245;
2261 -> 2255;
2261 -> 2260;
2261 -> 2245;
2262 -> 0;
2262 -> 2261;
2263 -> 0;
2263 -> 2261;
2264 -> 2263;
2264 -> 2223;
2265 -> 2264;
2265 -> 0;
2265 -> 2223;
2266 -> 2223;
2267 -> 2266;
2267 -> 2223;
2268 -> 2223;
2269 -> 2264;
2269 -> 2223;
2270 -> 2227;
2270 -> 2269;
2271 -> 0;
2271 -> 2270;
2272 -> 2270;
2273 -> 2225;
2273 -> 2270;
2274 -> 2270;
2275 -> 2270;
2276 -> 2230;
2276 -> 2275;
2277 -> 2270;
2278 -> 2271;
2278 -> 2223;
2279 -> 2264;
2279 -> 2223;
2280 -> 2231;
2280 -> 2223;
2281 -> 2226;
2281 -> 2223;
2282 -> 2272;
2282 -> 2223;
2283 -> 2223;
2284 -> 2278;
2284 -> 2283;
2285 -> 2279;
2285 -> 2283;
2286 -> 2280;
2286 -> 2283;
2287 -> 2281;
2287 -> 2283;
2288 -> 2282;
2288 -> 2283;
2289 -> 2230;
2289 -> 2283;
2290 -> 2223;
2291 -> 2223;
2292 -> 2271;
2292 -> 2223;
2293 -> 2273;
2293 -> 2292;
2293 -> 0;
2293 -> 2223;
2294 -> 2229;
2294 -> 2293;
2295 -> 2271;
2295 -> 2294;
2296 -> 2294;
2297 -> 2295;
2297 -> 2296;
2298 -> 2230;
2298 -> 2296;
2299 -> 2297;
2299 -> 2296;
2300 -> 2294;
2301 -> 2231;
2301 -> 2294;
2302 -> 2294;
2303 -> 2301;
2303 -> 2302;
2304 -> 2230;
2304 -> 2302;
2305 -> 2302;
2306 -> 2304;
2306 -> 2305;
2307 -> 2305;
2308 -> 2307;
2308 -> 2302;
2309 -> 2303;
2309 -> 2231;
2309 -> 2302;
2310 -> 2294;
2311 -> 2293;
2312 -> 2273;
2312 -> 2293;
2313 -> 0;
2313 -> 2312;
2314 -> 2313;
2314 -> 0;
2314 -> 2223;
2315 -> 2231;
2315 -> 2223;
2316 -> 2311;
2316 -> 2223;
2317 -> 0;
2317 -> 2316;
2318 -> 2316;
2319 -> 2317;
2319 -> 2318;
2320 -> 2191;
2320 -> 2192;
2321 -> 2191;
2321 -> 2192;
2322 -> 2191;
2322 -> 2192;
2323 -> 2320;
2323 -> 2192;
2324 -> 2192;
2325 -> 2323;
2325 -> 2324;
2326 -> 2322;
2326 -> 2324;
2327 -> 2326;
2327 -> 2293;
2327 -> 2319;
2327 -> 2325;
2327 -> 2324;
2328 -> 2327;
2329 -> 2319;
2329 -> 2192;
2330 -> 2329;
2330 -> 2196;
2331 -> 2330;
2331 -> 2198;
2331 -> 2196;
2332 -> 2191;
2332 -> 2319;
2332 -> 2293;
2332 -> 2313;
2332 -> 0;
2332 -> 2051;
2333 -> 2326;
2333 -> 2332;
2333 -> 2325;
2333 -> 2324;
2334 -> 2333;
2335 -> 2332;
2335 -> 2192;
2336 -> 2335;
2336 -> 2196;
2337 -> 2336;
2337 -> 2198;
2337 -> 2196;
2338 -> 2191;
2338 -> 2192;
2339 -> 2191;
2339 -> 2192;
2340 -> 2192;
2341 -> 2339;
2341 -> 2340;
2342 -> 2340;
2343 -> 2341;
2343 -> 2332;
2343 -> 2342;
2343 -> 2340;
2344 -> 2341;
2344 -> 2343;
2345 -> 2341;
2345 -> 2332;
2345 -> 2343;
2346 -> 2343;
2347 -> 2341;
2347 -> 2346;
2348 -> 2346;
2349 -> 2347;
2349 -> 2348;
2350 -> 2346;
2351 -> 2346;
2352 -> 2347;
2352 -> 2332;
2352 -> 2351;
2353 -> 2352;
2353 -> 2346;
2354 -> 2346;
2355 -> 2347;
2355 -> 2354;
2356 -> 2355;
2356 -> 2346;
2357 -> 2346;
2358 -> 2356;
2358 -> 2357;
2359 -> 2353;
2359 -> 2346;
2360 -> 2359;
2361 -> 2347;
2361 -> 2360;
2362 -> 2360;
2363 -> 0;
2363 -> 2360;
2364 -> 2360;
2365 -> 2362;
2365 -> 2364;
2366 -> 2363;
2366 -> 2364;
2367 -> 2361;
2367 -> 2364;
2368 -> 2366;
2368 -> 2364;
2369 -> 2364;
2370 -> 2367;
2370 -> 2369;
2371 -> 2370;
2371 -> 2332;
2371 -> 2369;
2372 -> 2369;
2373 -> 2371;
2373 -> 2372;
2373 -> 2369;
2374 -> 2371;
2374 -> 2332;
2374 -> 2369;
2375 -> 2374;
2375 -> 2364;
2376 -> 2364;
2377 -> 2375;
2377 -> 2376;
2377 -> 2364;
2378 -> 2368;
2378 -> 2366;
2378 -> 2364;
2379 -> 2378;
2380 -> 2367;
2380 -> 2379;
2381 -> 2379;
2382 -> 2380;
2382 -> 2381;
2383 -> 2381;
2384 -> 2382;
2384 -> 2383;
2385 -> 2383;
2386 -> 2384;
2386 -> 2332;
2386 -> 2385;
2386 -> 2383;
2387 -> 2384;
2387 -> 2332;
2387 -> 2386;
2388 -> 2386;
2389 -> 2387;
2389 -> 2388;
2390 -> 2384;
2390 -> 2388;
2391 -> 2388;
2392 -> 2390;
2392 -> 2332;
2392 -> 2391;
2393 -> 2392;
2393 -> 2388;
2394 -> 2393;
2395 -> 2393;
2396 -> 2395;
2396 -> 2393;
2397 -> 2395;
2397 -> 2393;
2398 -> 2393;
2399 -> 2397;
2399 -> 2398;
2400 -> 2390;
2400 -> 2398;
2401 -> 2398;
2402 -> 2398;
2403 -> 2398;
2404 -> 2403;
2404 -> 2400;
2404 -> 2332;
2404 -> 2398;
2405 -> 2398;
2406 -> 2402;
2406 -> 2405;
2406 -> 2398;
2407 -> 0;
2407 -> 2406;
2408 -> 0;
2408 -> 2406;
2409 -> 2408;
2409 -> 2393;
2410 -> 2393;
2411 -> 2409;
2411 -> 2393;
2412 -> 2411;
2413 -> 2390;
2413 -> 2412;
2414 -> 2412;
2415 -> 2413;
2415 -> 2414;
2416 -> 2414;
2417 -> 2415;
2417 -> 2416;
2418 -> 2414;
2419 -> 2415;
2419 -> 2332;
2419 -> 2414;
2420 -> 2419;
2420 -> 2412;
2421 -> 2412;
2422 -> 2412;
2423 -> 2422;
2423 -> 2420;
2423 -> 2332;
2423 -> 2412;
2424 -> 2421;
2424 -> 2412;
2425 -> 2424;
2425 -> 2411;
2426 -> 2393;
2427 -> 2393;
2428 -> 2393;
2429 -> 2393;
2430 -> 2410;
2430 -> 2429;
2430 -> 2393;
2431 -> 2409;
2431 -> 2393;
2432 -> 2430;
2432 -> 2431;
2432 -> 2393;
2433 -> 0;
2433 -> 2432;
2434 -> 2389;
2434 -> 2393;
2435 -> 2433;
2435 -> 2393;
2436 -> 2393;
2437 -> 2434;
2437 -> 2435;
2437 -> 2436;
2437 -> 2332;
2437 -> 2393;
2438 -> 2394;
2438 -> 2437;
2439 -> 2437;
2440 -> 2438;
2440 -> 2439;
2441 -> 2390;
2441 -> 2439;
2442 -> 2439;
2443 -> 2441;
2443 -> 2442;
2444 -> 2442;
2445 -> 2444;
2445 -> 2439;
2446 -> 2440;
2446 -> 2394;
2446 -> 2439;
2447 -> 2437;
2448 -> 2394;
2448 -> 2393;
2449 -> 2437;
2449 -> 2388;
2450 -> 2386;
2451 -> 2381;
2452 -> 2382;
2452 -> 2437;
2452 -> 2381;
2453 -> 2452;
2453 -> 2379;
2454 -> 2453;
2454 -> 2437;
2454 -> 2379;
2455 -> 2453;
2455 -> 2437;
2455 -> 2379;
2456 -> 2455;
2456 -> 2378;
2457 -> 2378;
2458 -> 2456;
2458 -> 2457;
2458 -> 2378;
2459 -> 2368;
2459 -> 2364;
2460 -> 2459;
2460 -> 2359;
2461 -> 2460;
2461 -> 0;
2461 -> 2359;
2462 -> 2461;
2463 -> 2346;
2464 -> 2347;
2464 -> 2437;
2464 -> 2463;
2465 -> 2464;
2465 -> 2346;
2466 -> 2465;
2466 -> 2346;
2467 -> 2466;
2468 -> 2347;
2468 -> 2467;
2469 -> 2467;
2470 -> 0;
2470 -> 2467;
2471 -> 2467;
2472 -> 2469;
2472 -> 2471;
2473 -> 2470;
2473 -> 2471;
2474 -> 2468;
2474 -> 2471;
2475 -> 2471;
2476 -> 2474;
2476 -> 2475;
2477 -> 2476;
2477 -> 2437;
2477 -> 2475;
2478 -> 2475;
2479 -> 2477;
2479 -> 2478;
2479 -> 2475;
2480 -> 2477;
2480 -> 2437;
2480 -> 2475;
2481 -> 2480;
2481 -> 2471;
2482 -> 2471;
2483 -> 2481;
2483 -> 2482;
2483 -> 2471;
2484 -> 2474;
2484 -> 2473;
2485 -> 2473;
2486 -> 2484;
2486 -> 2437;
2486 -> 2473;
2487 -> 2486;
2487 -> 2473;
2488 -> 2487;
2488 -> 2437;
2488 -> 2473;
2489 -> 2487;
2489 -> 2437;
2489 -> 2473;
2490 -> 2489;
2490 -> 2473;
2491 -> 2473;
2492 -> 2490;
2492 -> 2491;
2492 -> 2473;
2493 -> 2473;
2493 -> 2471;
2494 -> 2493;
2494 -> 2466;
2495 -> 2494;
2495 -> 0;
2495 -> 2466;
2496 -> 2495;
2497 -> 2346;
2498 -> 2347;
2498 -> 2497;
2499 -> 2497;
2500 -> 2497;
2501 -> 2499;
2501 -> 2500;
2502 -> 2499;
2502 -> 2500;
2503 -> 2498;
2503 -> 2500;
2504 -> 2502;
2504 -> 2500;
2505 -> 2500;
2506 -> 2503;
2506 -> 2505;
2507 -> 2506;
2507 -> 2437;
2507 -> 2505;
2508 -> 2505;
2509 -> 2507;
2509 -> 2508;
2509 -> 2505;
2510 -> 2507;
2510 -> 2437;
2510 -> 2505;
2511 -> 2510;
2511 -> 2500;
2512 -> 2500;
2513 -> 2511;
2513 -> 2512;
2513 -> 2500;
2514 -> 2504;
2514 -> 2502;
2514 -> 2500;
2515 -> 2514;
2516 -> 2503;
2516 -> 2515;
2517 -> 2515;
2518 -> 2516;
2518 -> 2517;
2519 -> 2517;
2520 -> 2518;
2520 -> 2519;
2521 -> 2519;
2522 -> 2520;
2522 -> 2437;
2522 -> 2521;
2522 -> 2519;
2523 -> 2517;
2524 -> 2518;
2524 -> 2437;
2524 -> 2517;
2525 -> 2524;
2525 -> 2515;
2526 -> 2525;
2526 -> 2437;
2526 -> 2515;
2527 -> 2525;
2527 -> 2437;
2527 -> 2515;
2528 -> 2527;
2528 -> 2514;
2529 -> 2514;
2530 -> 2528;
2530 -> 2529;
2530 -> 2514;
2531 -> 2504;
2531 -> 2500;
2532 -> 2531;
2532 -> 2346;
2533 -> 2346;
2534 -> 2347;
2534 -> 2533;
2535 -> 2534;
2535 -> 2437;
2535 -> 2533;
2536 -> 2535;
2536 -> 2346;
2537 -> 2346;
2538 -> 2536;
2538 -> 2537;
2539 -> 2462;
2539 -> 2346;
2540 -> 2496;
2540 -> 2346;
2541 -> 2532;
2541 -> 2346;
2542 -> 0;
2542 -> 2346;
2543 -> 2538;
2543 -> 2539;
2543 -> 2540;
2543 -> 2541;
2543 -> 2542;
2543 -> 2437;
2543 -> 2346;
2544 -> 2543;
2544 -> 2343;
2545 -> 2343;
2546 -> 2343;
2547 -> 2341;
2547 -> 2544;
2547 -> 2340;
2548 -> 2547;
2548 -> 2192;
2549 -> 2192;
2550 -> 2338;
2550 -> 2192;
2551 -> 2192;
2552 -> 2550;
2552 -> 2551;
2553 -> 2339;
2553 -> 2551;
2554 -> 2551;
2555 -> 2553;
2555 -> 2554;
2556 -> 2554;
2557 -> 2555;
2557 -> 2544;
2557 -> 2556;
2557 -> 2554;
2558 -> 2551;
2559 -> 2551;
2560 -> 2553;
2560 -> 2559;
2561 -> 2559;
2562 -> 2560;
2562 -> 2544;
2562 -> 2561;
2562 -> 2559;
2563 -> 2560;
2563 -> 2544;
2563 -> 2562;
2564 -> 2562;
2565 -> 2560;
2565 -> 2564;
2566 -> 2565;
2566 -> 2544;
2566 -> 2564;
2567 -> 2564;
2568 -> 2565;
2568 -> 2544;
2568 -> 2567;
2569 -> 2568;
2569 -> 2564;
2570 -> 2564;
2571 -> 2565;
2571 -> 2570;
2572 -> 2570;
2573 -> 2572;
2573 -> 2570;
2574 -> 2570;
2575 -> 2571;
2575 -> 2574;
2576 -> 2575;
2576 -> 2544;
2576 -> 2574;
2577 -> 2574;
2578 -> 2576;
2578 -> 2577;
2578 -> 2574;
2579 -> 2576;
2579 -> 2544;
2579 -> 2574;
2580 -> 2579;
2580 -> 2570;
2581 -> 2570;
2582 -> 2580;
2582 -> 2581;
2582 -> 2570;
2583 -> 2573;
2583 -> 2572;
2583 -> 2570;
2584 -> 2583;
2585 -> 2571;
2585 -> 2584;
2586 -> 2584;
2587 -> 2585;
2587 -> 2544;
2587 -> 2584;
2588 -> 2587;
2588 -> 2584;
2589 -> 2588;
2589 -> 2544;
2589 -> 2584;
2590 -> 2588;
2590 -> 2544;
2590 -> 2584;
2591 -> 2590;
2591 -> 2583;
2592 -> 2583;
2593 -> 2591;
2593 -> 2592;
2593 -> 2583;
2594 -> 2573;
2594 -> 2570;
2595 -> 2594;
2595 -> 2564;
2596 -> 2569;
2596 -> 2595;
2596 -> 2544;
2596 -> 2564;
2597 -> 2564;
2598 -> 2565;
2598 -> 2597;
2599 -> 2597;
2600 -> 2597;
2601 -> 2599;
2601 -> 2600;
2602 -> 2599;
2602 -> 2600;
2603 -> 2598;
2603 -> 2600;
2604 -> 2600;
2605 -> 2603;
2605 -> 2604;
2606 -> 2605;
2606 -> 2596;
2606 -> 2604;
2607 -> 2604;
2608 -> 2606;
2608 -> 2607;
2608 -> 2604;
2609 -> 2606;
2609 -> 2596;
2609 -> 2604;
2610 -> 2609;
2610 -> 2600;
2611 -> 2600;
2612 -> 2610;
2612 -> 2611;
2612 -> 2600;
2613 -> 2603;
2613 -> 2602;
2614 -> 2613;
2614 -> 2596;
2614 -> 2602;
2615 -> 2602;
2616 -> 2613;
2616 -> 2596;
2616 -> 2602;
2617 -> 2616;
2617 -> 2602;
2618 -> 2617;
2618 -> 2596;
2618 -> 2602;
2619 -> 2617;
2619 -> 2596;
2619 -> 2602;
2620 -> 2619;
2620 -> 2602;
2621 -> 2602;
2622 -> 2620;
2622 -> 2621;
2622 -> 2602;
2623 -> 2602;
2623 -> 2564;
2624 -> 2564;
2625 -> 2565;
2625 -> 2624;
2626 -> 2625;
2626 -> 2596;
2626 -> 2624;
2627 -> 2625;
2627 -> 2596;
2627 -> 2624;
2628 -> 2564;
2629 -> 2565;
2629 -> 2628;
2630 -> 2629;
2630 -> 2596;
2630 -> 2628;
2631 -> 2629;
2631 -> 2596;
2631 -> 2628;
2632 -> 2566;
2632 -> 2596;
2632 -> 2623;
2632 -> 2627;
2632 -> 2631;
2632 -> 2564;
2633 -> 2632;
2633 -> 2562;
2634 -> 2562;
2635 -> 2560;
2635 -> 2633;
2635 -> 2559;
2636 -> 2635;
2636 -> 2551;
2637 -> 2636;
2638 -> 2192;
2639 -> 2338;
2639 -> 2192;
2640 -> 2192;
2641 -> 2639;
2641 -> 2640;
2642 -> 2339;
2642 -> 2640;
2643 -> 2642;
2643 -> 2633;
2643 -> 2640;
2644 -> 2640;
2645 -> 2643;
2645 -> 2644;
2645 -> 2640;
2646 -> 2192;
2647 -> 2338;
2647 -> 2192;
2648 -> 2192;
2649 -> 2647;
2649 -> 2648;
2650 -> 2339;
2650 -> 2648;
2651 -> 2648;
2652 -> 2650;
2652 -> 2651;
2653 -> 2651;
2654 -> 2652;
2654 -> 2633;
2654 -> 2653;
2654 -> 2651;
2655 -> 2648;
2656 -> 2648;
2657 -> 2650;
2657 -> 2656;
2658 -> 0;
2658 -> 2656;
2659 -> 2658;
2659 -> 2656;
2660 -> 2656;
2661 -> 2657;
2661 -> 2660;
2662 -> 2661;
2662 -> 2633;
2662 -> 2660;
2663 -> 2660;
2664 -> 2662;
2664 -> 2663;
2664 -> 2660;
2665 -> 2662;
2665 -> 2633;
2665 -> 2660;
2666 -> 2665;
2666 -> 2656;
2667 -> 2656;
2668 -> 2666;
2668 -> 2667;
2668 -> 2656;
2669 -> 2659;
2669 -> 2658;
2669 -> 2656;
2670 -> 2669;
2671 -> 2657;
2671 -> 2670;
2672 -> 2670;
2673 -> 2671;
2673 -> 2672;
2674 -> 2672;
2675 -> 2673;
2675 -> 2674;
2676 -> 2674;
2677 -> 2675;
2677 -> 2633;
2677 -> 2676;
2677 -> 2674;
2678 -> 2672;
2679 -> 2673;
2679 -> 2633;
2679 -> 2672;
2680 -> 2679;
2680 -> 2670;
2681 -> 2680;
2681 -> 2633;
2681 -> 2670;
2682 -> 2680;
2682 -> 2633;
2682 -> 2670;
2683 -> 2682;
2683 -> 2669;
2684 -> 2669;
2685 -> 2683;
2685 -> 2684;
2685 -> 2669;
2686 -> 2659;
2686 -> 2656;
2687 -> 2686;
2687 -> 2648;
2688 -> 2648;
2689 -> 2650;
2689 -> 2633;
2689 -> 2688;
2690 -> 2689;
2690 -> 2648;
2691 -> 2648;
2692 -> 2650;
2692 -> 2633;
2692 -> 2691;
2693 -> 2692;
2693 -> 2648;
2694 -> 2648;
2695 -> 2650;
2695 -> 2633;
2695 -> 2694;
2696 -> 2695;
2696 -> 2648;
2697 -> 2648;
2698 -> 2650;
2698 -> 2633;
2698 -> 2697;
2699 -> 2698;
2699 -> 2648;
2700 -> 2648;
2701 -> 2650;
2701 -> 2633;
2701 -> 2700;
2702 -> 2701;
2702 -> 2648;
2703 -> 2648;
2704 -> 2650;
2704 -> 2633;
2704 -> 2703;
2705 -> 2704;
2705 -> 2648;
2706 -> 2192;
2707 -> 2192;
2708 -> 2339;
2708 -> 2707;
2709 -> 2707;
2710 -> 2708;
2710 -> 2633;
2710 -> 2709;
2711 -> 2710;
2711 -> 2707;
2712 -> 2707;
2713 -> 2708;
2713 -> 2633;
2713 -> 2712;
2714 -> 2713;
2714 -> 2707;
2715 -> 2707;
2716 -> 2708;
2716 -> 2715;
2717 -> 0;
2717 -> 2715;
2718 -> 2717;
2718 -> 2715;
2719 -> 2715;
2720 -> 2716;
2720 -> 2719;
2721 -> 2720;
2721 -> 2633;
2721 -> 2719;
2722 -> 2719;
2723 -> 2721;
2723 -> 2722;
2723 -> 2719;
2724 -> 2721;
2724 -> 2633;
2724 -> 2719;
2725 -> 2724;
2725 -> 2715;
2726 -> 2715;
2727 -> 2725;
2727 -> 2726;
2727 -> 2715;
2728 -> 2718;
2728 -> 2717;
2728 -> 2715;
2729 -> 2728;
2730 -> 2716;
2730 -> 2729;
2731 -> 2729;
2732 -> 2730;
2732 -> 2731;
2733 -> 2731;
2734 -> 2732;
2734 -> 2733;
2735 -> 2733;
2736 -> 2734;
2736 -> 2633;
2736 -> 2735;
2736 -> 2733;
2737 -> 2731;
2738 -> 2732;
2738 -> 2633;
2738 -> 2731;
2739 -> 2738;
2739 -> 2729;
2740 -> 2739;
2740 -> 2633;
2740 -> 2729;
2741 -> 2739;
2741 -> 2633;
2741 -> 2729;
2742 -> 2741;
2742 -> 2728;
2743 -> 2728;
2744 -> 2742;
2744 -> 2743;
2744 -> 2728;
2745 -> 2718;
2745 -> 2715;
2746 -> 2745;
2746 -> 2707;
2747 -> 2746;
2747 -> 2192;
2748 -> 2192;
2749 -> 2339;
2749 -> 2748;
2750 -> 2749;
2750 -> 2633;
2750 -> 2748;
2751 -> 2750;
2751 -> 2192;
2752 -> 2192;
2753 -> 2751;
2753 -> 2752;
2754 -> 2192;
2755 -> 2339;
2755 -> 2754;
2756 -> 2755;
2756 -> 2633;
2756 -> 2754;
2757 -> 2756;
2757 -> 2192;
2758 -> 2192;
2759 -> 2757;
2759 -> 2758;
2760 -> 2192;
2761 -> 2339;
2761 -> 2760;
2762 -> 2761;
2762 -> 2633;
2762 -> 2760;
2763 -> 2762;
2763 -> 2192;
2764 -> 2192;
2765 -> 2763;
2765 -> 2764;
2766 -> 2759;
2766 -> 2765;
2766 -> 2633;
2766 -> 2192;
2767 -> 2192;
2768 -> 2339;
2768 -> 2767;
2769 -> 2767;
2770 -> 2768;
2770 -> 2633;
2770 -> 2769;
2770 -> 2767;
2771 -> 2768;
2771 -> 2633;
2771 -> 2767;
2772 -> 2771;
2772 -> 2192;
2773 -> 2766;
2773 -> 2772;
2773 -> 2633;
2773 -> 2192;
2774 -> 2339;
2774 -> 2633;
2774 -> 2192;
2775 -> 2338;
2775 -> 2192;
2776 -> 2192;
2777 -> 2774;
2777 -> 2776;
2778 -> 2775;
2778 -> 2776;
2779 -> 2777;
2779 -> 2776;
2780 -> 2778;
2780 -> 2776;
2781 -> 2776;
2782 -> 2779;
2782 -> 2781;
2783 -> 2780;
2783 -> 2781;
2784 -> 2781;
2785 -> 2782;
2785 -> 2784;
2786 -> 2785;
2786 -> 2781;
2787 -> 2786;
2787 -> 2633;
2787 -> 2781;
2788 -> 2787;
2789 -> 2776;
2790 -> 2776;
2791 -> 2777;
2791 -> 2790;
2792 -> 2791;
2792 -> 2776;
2793 -> 2792;
2793 -> 2633;
2793 -> 2776;
2794 -> 0;
2794 -> 2793;
2795 -> 2793;
2796 -> 2794;
2796 -> 2795;
2797 -> 2777;
2797 -> 2795;
2798 -> 2796;
2798 -> 2795;
2799 -> 2795;
2800 -> 2797;
2800 -> 2799;
2801 -> 2800;
2801 -> 2795;
2802 -> 0;
2802 -> 2795;
2803 -> 2795;
2804 -> 2801;
2804 -> 2803;
2805 -> 2802;
2805 -> 2803;
2806 -> 2804;
2806 -> 2805;
2806 -> 2803;
2807 -> 2796;
2807 -> 0;
2807 -> 2795;
2808 -> 2795;
2809 -> 2797;
2809 -> 2633;
2809 -> 2808;
2809 -> 2795;
2810 -> 2809;
2811 -> 2797;
2811 -> 2633;
2811 -> 2810;
2812 -> 0;
2812 -> 2810;
2813 -> 2810;
2814 -> 2796;
2814 -> 2809;
2815 -> 2809;
2816 -> 2809;
2817 -> 2809;
2818 -> 2796;
2818 -> 2809;
2819 -> 2797;
2819 -> 2818;
2819 -> 2811;
2819 -> 2809;
2820 -> 2796;
2820 -> 0;
2820 -> 2819;
2821 -> 2820;
2821 -> 2819;
2822 -> 2815;
2822 -> 2821;
2823 -> 2819;
2824 -> 2823;
2825 -> 2824;
2825 -> 2823;
2826 -> 2823;
2826 -> 2819;
2827 -> 2814;
2827 -> 2819;
2828 -> 2819;
2829 -> 2817;
2829 -> 2819;
2830 -> 2822;
2830 -> 2819;
2831 -> 2806;
2831 -> 2819;
2832 -> 2819;
2833 -> 2827;
2833 -> 2832;
2834 -> 2828;
2834 -> 2832;
2835 -> 2828;
2835 -> 2832;
2836 -> 2829;
2836 -> 2832;
2837 -> 2828;
2837 -> 2832;
2838 -> 2830;
2838 -> 2832;
2839 -> 2831;
2839 -> 2832;
2840 -> 2826;
2840 -> 2832;
2841 -> 2832;
2842 -> 2832;
2843 -> 2842;
2843 -> 2832;
2844 -> 2832;
2845 -> 2833;
2845 -> 2844;
2845 -> 2832;
2846 -> 2833;
2846 -> 2845;
2847 -> 2837;
2847 -> 2845;
2848 -> 2845;
2849 -> 2847;
2849 -> 2845;
2850 -> 2845;
2851 -> 2834;
2851 -> 2845;
2852 -> 2835;
2852 -> 2845;
2853 -> 2836;
2853 -> 2845;
2854 -> 2838;
2854 -> 2845;
2855 -> 2839;
2855 -> 2845;
2856 -> 2845;
2857 -> 2849;
2857 -> 2856;
2858 -> 2850;
2858 -> 2856;
2859 -> 2851;
2859 -> 2856;
2860 -> 2852;
2860 -> 2856;
2861 -> 2853;
2861 -> 2856;
2862 -> 2854;
2862 -> 2856;
2863 -> 2855;
2863 -> 2856;
2864 -> 2840;
2864 -> 2856;
2865 -> 2856;
2866 -> 2856;
2867 -> 2864;
2867 -> 2856;
2868 -> 2857;
2868 -> 2856;
2869 -> 2858;
2869 -> 2856;
2870 -> 2856;
2871 -> 2867;
2871 -> 2870;
2872 -> 2868;
2872 -> 2870;
2873 -> 2869;
2873 -> 2870;
2874 -> 2872;
2874 -> 2870;
2875 -> 2870;
2876 -> 2870;
2877 -> 2874;
2877 -> 2876;
2878 -> 2875;
2878 -> 2876;
2879 -> 2871;
2879 -> 2876;
2880 -> 2877;
2880 -> 2876;
2881 -> 2876;
2882 -> 2878;
2882 -> 2876;
2883 -> 2876;
2884 -> 2880;
2884 -> 2883;
2885 -> 2881;
2885 -> 2883;
2886 -> 2882;
2886 -> 2883;
2887 -> 2879;
2887 -> 2883;
2888 -> 2883;
2889 -> 2884;
2889 -> 2883;
2890 -> 2883;
2891 -> 2889;
2891 -> 2890;
2892 -> 2887;
2892 -> 2890;
2893 -> 2890;
2894 -> 2891;
2894 -> 2847;
2894 -> 2890;
2895 -> 2893;
2895 -> 2890;
2896 -> 2892;
2896 -> 2823;
2896 -> 2894;
2896 -> 2895;
2896 -> 2890;
2897 -> 2890;
2898 -> 2897;
2898 -> 2883;
2899 -> 2883;
2900 -> 2898;
2900 -> 2899;
2900 -> 2883;
2901 -> 2900;
2902 -> 2887;
2902 -> 2901;
2903 -> 2902;
2903 -> 2896;
2903 -> 2901;
2904 -> 2903;
2904 -> 2900;
2905 -> 2904;
2905 -> 2896;
2905 -> 2900;
2906 -> 2900;
2907 -> 2904;
2907 -> 2906;
2907 -> 2896;
2907 -> 2900;
2908 -> 2891;
2908 -> 2900;
2909 -> 2900;
2910 -> 2908;
2910 -> 2909;
2911 -> 2907;
2911 -> 2909;
2912 -> 2909;
2913 -> 2909;
2914 -> 2911;
2914 -> 2913;
2915 -> 2913;
2916 -> 2914;
2916 -> 2907;
2916 -> 2915;
2916 -> 2913;
2917 -> 2916;
2918 -> 2914;
2918 -> 2916;
2919 -> 2916;
2920 -> 2914;
2920 -> 2919;
2921 -> 2919;
2922 -> 2920;
2922 -> 2907;
2922 -> 2921;
2923 -> 2922;
2923 -> 2919;
2924 -> 2923;
2924 -> 2916;
2925 -> 2916;
2926 -> 2924;
2926 -> 2925;
2928 -> 2927;
2930 -> 2929;
2931 -> 2917;
2931 -> 2916;
2932 -> 2916;
2933 -> 2916;
2934 -> 2918;
2934 -> 2933;
2935 -> 2918;
2935 -> 2933;
2936 -> 2926;
2936 -> 2933;
2937 -> 2931;
2937 -> 2933;
2938 -> 2932;
2938 -> 2933;
2939 -> 2933;
2940 -> 2938;
2940 -> 2933;
2941 -> 2938;
2941 -> 2933;
2942 -> 2938;
2942 -> 2933;
2943 -> 2938;
2943 -> 2933;
2944 -> 2938;
2944 -> 2933;
2945 -> 2938;
2945 -> 2933;
2948 -> 2947;
2948 -> 2946;
2950 -> 2949;
2950 -> 2946;
2951 -> 2946;
2954 -> 2953;
2954 -> 2952;
2956 -> 2955;
2956 -> 2952;
2957 -> 2952;
2959 -> 0;
2959 -> 2958;
2961 -> 0;
2961 -> 2960;
2962 -> 2961;
2962 -> 2958;
2963 -> 2958;
2965 -> 0;
2965 -> 2964;
2966 -> 0;
2966 -> 2964;
2967 -> 2964;
2968 -> 2957;
2968 -> 2938;
2968 -> 2933;
2969 -> 2933;
2970 -> 2936;
2970 -> 2969;
2970 -> 2933;
2971 -> 2934;
2971 -> 2938;
2971 -> 2933;
2972 -> 2935;
2972 -> 2938;
2972 -> 2933;
2973 -> 2936;
2973 -> 2938;
2973 -> 2933;
2974 -> 2936;
2974 -> 2926;
2974 -> 2933;
2975 -> 2974;
2975 -> 2926;
2976 -> 2937;
2976 -> 2975;
2976 -> 2917;
2976 -> 2926;
2976 -> 2974;
2977 -> 2917;
2977 -> 2976;
2977 -> 2916;
2978 -> 2917;
2978 -> 2976;
2978 -> 2916;
2979 -> 2914;
2979 -> 2978;
2979 -> 2916;
2980 -> 2932;
2980 -> 2916;
2981 -> 2916;
2982 -> 2979;
2982 -> 2980;
2982 -> 2981;
2982 -> 2938;
2982 -> 2971;
2982 -> 2972;
2982 -> 2973;
2982 -> 2943;
2982 -> 2944;
2982 -> 2945;
2982 -> 2968;
2982 -> 2978;
2982 -> 2954;
2982 -> 2956;
2982 -> 2952;
2982 -> 2916;
2983 -> 2914;
2983 -> 2982;
2983 -> 2913;
2984 -> 2983;
2984 -> 2909;
2985 -> 2910;
2985 -> 2896;
2985 -> 2909;
2986 -> 2909;
2987 -> 2985;
2987 -> 2986;
2988 -> 2984;
2988 -> 2986;
2989 -> 2988;
2989 -> 2986;
2990 -> 2987;
2990 -> 2986;
2991 -> 2990;
2991 -> 2982;
2991 -> 2986;
2992 -> 2991;
2993 -> 2991;
2994 -> 2991;
2995 -> 2993;
2995 -> 2994;
2996 -> 2989;
2996 -> 2994;
2997 -> 2994;
2998 -> 2997;
2998 -> 2994;
2999 -> 2994;
3000 -> 2996;
3000 -> 2999;
3001 -> 2999;
3002 -> 3000;
3002 -> 2982;
3002 -> 3001;
3002 -> 2999;
3003 -> 3002;
3004 -> 3000;
3004 -> 2982;
3004 -> 3002;
3005 -> 3003;
3005 -> 3002;
3006 -> 3002;
3007 -> 3005;
3007 -> 3006;
3008 -> 3000;
3008 -> 3006;
3009 -> 3008;
3009 -> 2982;
3009 -> 3006;
3010 -> 3006;
3011 -> 3009;
3011 -> 3010;
3012 -> 3009;
3012 -> 3010;
3013 -> 3011;
3013 -> 3010;
3014 -> 0;
3014 -> 3010;
3015 -> 3013;
3015 -> 3012;
3015 -> 3010;
3016 -> 3008;
3016 -> 3015;
3016 -> 3006;
3017 -> 3016;
3018 -> 3007;
3018 -> 3016;
3019 -> 3016;
3020 -> 3017;
3020 -> 3019;
3021 -> 3018;
3021 -> 3019;
3022 -> 3008;
3022 -> 3019;
3023 -> 3020;
3023 -> 3015;
3023 -> 3019;
3024 -> 3022;
3024 -> 3015;
3024 -> 3023;
3025 -> 3022;
3025 -> 3023;
3026 -> 3020;
3026 -> 3023;
3027 -> 3021;
3027 -> 3023;
3028 -> 3023;
3029 -> 3023;
3030 -> 3024;
3030 -> 3029;
3031 -> 3025;
3031 -> 3029;
3032 -> 3026;
3032 -> 3029;
3033 -> 3027;
3033 -> 3029;
3034 -> 3028;
3034 -> 3029;
3035 -> 3034;
3035 -> 3029;
3036 -> 3034;
3036 -> 3029;
3037 -> 3034;
3037 -> 3029;
3038 -> 3029;
3039 -> 3032;
3039 -> 3038;
3039 -> 3029;
3040 -> 3016;
3041 -> 3028;
3041 -> 3040;
3042 -> 3015;
3042 -> 3040;
3043 -> 3040;
3044 -> 3041;
3044 -> 3043;
3045 -> 3044;
3045 -> 3032;
3045 -> 3033;
3045 -> 3043;
3046 -> 3045;
3046 -> 3040;
3047 -> 3040;
3048 -> 3046;
3048 -> 3040;
3049 -> 3047;
3049 -> 3040;
3050 -> 3042;
3050 -> 3015;
3050 -> 3048;
3050 -> 3049;
3050 -> 3040;
3051 -> 3041;
3051 -> 3046;
3051 -> 3042;
3051 -> 3050;
3052 -> 3006;
3053 -> 3015;
3053 -> 3052;
3054 -> 3053;
3054 -> 3015;
3054 -> 3051;
3054 -> 3050;
3054 -> 3052;
3055 -> 0;
3055 -> 3052;
3056 -> 3053;
3056 -> 3015;
3056 -> 3051;
3056 -> 3052;
3057 -> 3056;
3057 -> 3050;
3058 -> 3056;
3059 -> 3058;
3059 -> 3056;
3060 -> 3057;
3060 -> 3056;
3061 -> 3056;
3062 -> 3060;
3062 -> 3061;
3062 -> 3056;
3063 -> 3057;
3063 -> 3062;
3064 -> 3062;
3065 -> 3063;
3065 -> 3064;
3066 -> 0;
3066 -> 3064;
3067 -> 3066;
3067 -> 3062;
3068 -> 3067;
3068 -> 3062;
3069 -> 3063;
3069 -> 3068;
3070 -> 3056;
3070 -> 3050;
3071 -> 3069;
3071 -> 3056;
3072 -> 3054;
3072 -> 3070;
3072 -> 3071;
3072 -> 3056;
3073 -> 3054;
3073 -> 3052;
3074 -> 3073;
3074 -> 3006;
3075 -> 3008;
3075 -> 3006;
3076 -> 3074;
3076 -> 3006;
3077 -> 3007;
3077 -> 3006;
3078 -> 3006;
3079 -> 3075;
3079 -> 3078;
3080 -> 3076;
3080 -> 3078;
3081 -> 3077;
3081 -> 3078;
3082 -> 3078;
3083 -> 3078;
3084 -> 3078;
3085 -> 3079;
3085 -> 3084;
3086 -> 3084;
3087 -> 3085;
3087 -> 3033;
3087 -> 3086;
3088 -> 3087;
3088 -> 3033;
3088 -> 3086;
3089 -> 3088;
3089 -> 3078;
3090 -> 3078;
3091 -> 3089;
3091 -> 3090;
3092 -> 3078;
3093 -> 3080;
3093 -> 3054;
3093 -> 3078;
3094 -> 3093;
3094 -> 3054;
3094 -> 3072;
3094 -> 3078;
3095 -> 3082;
3095 -> 3094;
3096 -> 3094;
3097 -> 3080;
3097 -> 3094;
3097 -> 3054;
3097 -> 3072;
3097 -> 3033;
3097 -> 3050;
3097 -> 3069;
3098 -> 3097;
3099 -> 3097;
3100 -> 3098;
3100 -> 3099;
3100 -> 3097;
3101 -> 3100;
3101 -> 3097;
3102 -> 3101;
3102 -> 3082;
3102 -> 3095;
3102 -> 3097;
3103 -> 3082;
3103 -> 3095;
3103 -> 3101;
3103 -> 3097;
3104 -> 3097;
3105 -> 3103;
3105 -> 3104;
3105 -> 3097;
3106 -> 3083;
3106 -> 3104;
3106 -> 3097;
3107 -> 3105;
3107 -> 3106;
3107 -> 3097;
3108 -> 3097;
3109 -> 3103;
3109 -> 3108;
3109 -> 3097;
3110 -> 3097;
3110 -> 3101;
3110 -> 3082;
3111 -> 3097;
3112 -> 3098;
3112 -> 3111;
3112 -> 3097;
3113 -> 3006;
3114 -> 3074;
3114 -> 3006;
3115 -> 3002;
3116 -> 3004;
3116 -> 3114;
3116 -> 3115;
3116 -> 3097;
3116 -> 3002;
3117 -> 3116;
3118 -> 3000;
3118 -> 3117;
3119 -> 3117;
3120 -> 3118;
3120 -> 3119;
3121 -> 3119;
3121 -> 3117;
3122 -> 3117;
3123 -> 3118;
3123 -> 3122;
3124 -> 3123;
3124 -> 3116;
3124 -> 3122;
3125 -> 3124;
3125 -> 3117;
3126 -> 3117;
3127 -> 3125;
3127 -> 3126;
3127 -> 3117;
3128 -> 3127;
3128 -> 3117;
3129 -> 3128;
3130 -> 3129;
3130 -> 3116;
3131 -> 3116;
3132 -> 3130;
3132 -> 3131;
3133 -> 3132;
3133 -> 3116;
3133 -> 3131;
3134 -> 3131;
3135 -> 3132;
3135 -> 3116;
3135 -> 3134;
3135 -> 3131;
3136 -> 3135;
3137 -> 3132;
3137 -> 3116;
3137 -> 3135;
3138 -> 3136;
3138 -> 3135;
3139 -> 3135;
3140 -> 3132;
3140 -> 3138;
3140 -> 3131;
3141 -> 3003;
3141 -> 3116;
3142 -> 3116;
3143 -> 3000;
3143 -> 3142;
3144 -> 3142;
3145 -> 3143;
3145 -> 3144;
3146 -> 3144;
3147 -> 3145;
3147 -> 3140;
3147 -> 3146;
3148 -> 3147;
3148 -> 3140;
3148 -> 3146;
3149 -> 3148;
3149 -> 3142;
3150 -> 3142;
3151 -> 3149;
3151 -> 3150;
3152 -> 3150;
3153 -> 3151;
3153 -> 3152;
3154 -> 3153;
3154 -> 3150;
3155 -> 3151;
3155 -> 3150;
3156 -> 3154;
3156 -> 3142;
3157 -> 3116;
3158 -> 3116;
3159 -> 3000;
3159 -> 3158;
3160 -> 3158;
3161 -> 3159;
3161 -> 3160;
3162 -> 3160;
3162 -> 3158;
3163 -> 3158;
3164 -> 3159;
3164 -> 3163;
3165 -> 3164;
3165 -> 3140;
3165 -> 3163;
3166 -> 3158;
3167 -> 3165;
3167 -> 3116;
3168 -> 3000;
3168 -> 3116;
3169 -> 3116;
3170 -> 3168;
3170 -> 3169;
3171 -> 3167;
3171 -> 3169;
3172 -> 3171;
3172 -> 3169;
3173 -> 3170;
3173 -> 3169;
3174 -> 3173;
3174 -> 3140;
3174 -> 3169;
3175 -> 3169;
3176 -> 3172;
3176 -> 3174;
3176 -> 3175;
3176 -> 3169;
3177 -> 3116;
3178 -> 0;
3178 -> 3116;
3179 -> 3116;
3180 -> 3178;
3180 -> 3179;
3181 -> 3000;
3181 -> 3176;
3181 -> 3179;
3182 -> 3181;
3182 -> 3180;
3182 -> 3179;
3183 -> 3182;
3183 -> 3116;
3184 -> 3003;
3184 -> 3176;
3184 -> 3182;
3184 -> 3002;
3185 -> 3000;
3185 -> 3184;
3185 -> 2999;
3186 -> 3185;
3186 -> 2994;
3187 -> 2995;
3187 -> 2994;
3188 -> 2997;
3188 -> 2994;
3189 -> 3186;
3189 -> 3187;
3189 -> 3188;
3189 -> 3184;
3189 -> 2998;
3189 -> 2994;
3190 -> 3189;
3190 -> 2994;
3191 -> 3190;
3192 -> 3190;
3193 -> 3191;
3193 -> 3192;
3193 -> 3190;
3194 -> 3193;
3195 -> 2992;
3195 -> 3194;
3195 -> 3193;
3196 -> 3191;
3196 -> 3193;
3197 -> 3196;
3197 -> 2991;
3198 -> 2991;
3199 -> 3197;
3199 -> 3198;
3199 -> 2991;
3200 -> 3190;
3201 -> 3197;
3202 -> 3201;
3202 -> 3197;
3203 -> 3197;
3204 -> 3197;
3205 -> 3202;
3205 -> 3204;
3206 -> 3203;
3206 -> 3204;
3207 -> 3203;
3207 -> 3204;
3208 -> 3203;
3208 -> 3204;
3209 -> 3203;
3209 -> 3204;
3211 -> 3210;
3213 -> 3212;
3215 -> 3214;
3217 -> 3216;
3219 -> 3218;
3221 -> 3220;
3222 -> 0;
3224 -> 3211;
3224 -> 3223;
3225 -> 3213;
3225 -> 3223;
3226 -> 3215;
3226 -> 3223;
3227 -> 3217;
3227 -> 3223;
3228 -> 3219;
3228 -> 3223;
3229 -> 3221;
3229 -> 3223;
3230 -> 3222;
3230 -> 3223;
3231 -> 3223;
3232 -> 3231;
3232 -> 3223;
3233 -> 3231;
3233 -> 3223;
3234 -> 3231;
3234 -> 3223;
3235 -> 3231;
3235 -> 3223;
3236 -> 3231;
3236 -> 3223;
3237 -> 3231;
3237 -> 3223;
3238 -> 3231;
3238 -> 3223;
3239 -> 3225;
3239 -> 3223;
3240 -> 3223;
3241 -> 3224;
3241 -> 3231;
3241 -> 3223;
3242 -> 3225;
3242 -> 3231;
3242 -> 3223;
3243 -> 3226;
3243 -> 3231;
3243 -> 3223;
3244 -> 3227;
3244 -> 3231;
3244 -> 3223;
3245 -> 3228;
3245 -> 3231;
3245 -> 3223;
3246 -> 3229;
3246 -> 3231;
3246 -> 3223;
3247 -> 3230;
3247 -> 3231;
3247 -> 3223;
3248 -> 3231;
3248 -> 3247;
3248 -> 0;
3248 -> 3223;
3249 -> 3223;
3250 -> 3229;
3250 -> 3223;
3251 -> 3223;
3253 -> 3252;
3255 -> 3254;
3257 -> 3256;
3259 -> 3258;
3261 -> 3260;
3263 -> 3262;
3264 -> 0;
3266 -> 3253;
3266 -> 3265;
3267 -> 3255;
3267 -> 3265;
3268 -> 3257;
3268 -> 3265;
3269 -> 3259;
3269 -> 3265;
3270 -> 3261;
3270 -> 3265;
3271 -> 3263;
3271 -> 3265;
3272 -> 3264;
3272 -> 3265;
3273 -> 3265;
3274 -> 3273;
3274 -> 3265;
3275 -> 3273;
3275 -> 3265;
3276 -> 3273;
3276 -> 3265;
3277 -> 3273;
3277 -> 3265;
3278 -> 3273;
3278 -> 3265;
3279 -> 3273;
3279 -> 3265;
3280 -> 3273;
3280 -> 3265;
3281 -> 3267;
3281 -> 3266;
3281 -> 3265;
3282 -> 3265;
3283 -> 3266;
3283 -> 3273;
3283 -> 3265;
3284 -> 3267;
3284 -> 3273;
3284 -> 3265;
3285 -> 3268;
3285 -> 3273;
3285 -> 3265;
3286 -> 3269;
3286 -> 3273;
3286 -> 3265;
3287 -> 3270;
3287 -> 3273;
3287 -> 3265;
3288 -> 3271;
3288 -> 3273;
3288 -> 3265;
3289 -> 3272;
3289 -> 3273;
3289 -> 3265;
3290 -> 3273;
3290 -> 3289;
3290 -> 0;
3290 -> 3265;
3291 -> 3265;
3292 -> 3271;
3292 -> 3265;
3293 -> 3265;
3295 -> 3294;
3297 -> 3296;
3299 -> 3298;
3301 -> 3300;
3303 -> 3302;
3305 -> 3304;
3306 -> 0;
3308 -> 3295;
3308 -> 3307;
3309 -> 3297;
3309 -> 3307;
3310 -> 3299;
3310 -> 3307;
3311 -> 3301;
3311 -> 3307;
3312 -> 3303;
3312 -> 3307;
3313 -> 3305;
3313 -> 3307;
3314 -> 3306;
3314 -> 3307;
3315 -> 3307;
3316 -> 3315;
3316 -> 3307;
3317 -> 3315;
3317 -> 3307;
3318 -> 3315;
3318 -> 3307;
3319 -> 3315;
3319 -> 3307;
3320 -> 3315;
3320 -> 3307;
3321 -> 3315;
3321 -> 3307;
3322 -> 3315;
3322 -> 3307;
3323 -> 3309;
3323 -> 3308;
3323 -> 3307;
3324 -> 3307;
3325 -> 3308;
3325 -> 3315;
3325 -> 3307;
3326 -> 3309;
3326 -> 3315;
3326 -> 3307;
3327 -> 3310;
3327 -> 3315;
3327 -> 3307;
3328 -> 3311;
3328 -> 3315;
3328 -> 3307;
3329 -> 3312;
3329 -> 3315;
3329 -> 3307;
3330 -> 3313;
3330 -> 3315;
3330 -> 3307;
3331 -> 3314;
3331 -> 3315;
3331 -> 3307;
3332 -> 3315;
3332 -> 3331;
3332 -> 0;
3332 -> 3307;
3333 -> 3307;
3334 -> 3313;
3334 -> 3307;
3335 -> 3307;
3337 -> 3336;
3339 -> 3338;
3341 -> 3340;
3343 -> 3342;
3345 -> 3344;
3347 -> 3346;
3348 -> 0;
3350 -> 3337;
3350 -> 3349;
3351 -> 3339;
3351 -> 3349;
3352 -> 3341;
3352 -> 3349;
3353 -> 3343;
3353 -> 3349;
3354 -> 3345;
3354 -> 3349;
3355 -> 3347;
3355 -> 3349;
3356 -> 3348;
3356 -> 3349;
3357 -> 3349;
3358 -> 3357;
3358 -> 3349;
3359 -> 3357;
3359 -> 3349;
3360 -> 3357;
3360 -> 3349;
3361 -> 3357;
3361 -> 3349;
3362 -> 3357;
3362 -> 3349;
3363 -> 3357;
3363 -> 3349;
3364 -> 3357;
3364 -> 3349;
3365 -> 3351;
3365 -> 3350;
3365 -> 3349;
3366 -> 3349;
3367 -> 3350;
3367 -> 3357;
3367 -> 3349;
3368 -> 3351;
3368 -> 3357;
3368 -> 3349;
3369 -> 3352;
3369 -> 3357;
3369 -> 3349;
3370 -> 3353;
3370 -> 3357;
3370 -> 3349;
3371 -> 3354;
3371 -> 3357;
3371 -> 3349;
3372 -> 3355;
3372 -> 3357;
3372 -> 3349;
3373 -> 3356;
3373 -> 3357;
3373 -> 3349;
3374 -> 3357;
3374 -> 3373;
3374 -> 0;
3374 -> 3349;
3375 -> 3349;
3376 -> 3355;
3376 -> 3349;
3377 -> 3357;
3377 -> 3373;
3377 -> 0;
3377 -> 3376;
3378 -> 3377;
3378 -> 3357;
3378 -> 3376;
3379 -> 3349;
3381 -> 3380;
3383 -> 3382;
3385 -> 3384;
3387 -> 3386;
3389 -> 3388;
3391 -> 3390;
3392 -> 0;
3394 -> 3381;
3394 -> 3393;
3395 -> 3383;
3395 -> 3393;
3396 -> 3385;
3396 -> 3393;
3397 -> 3387;
3397 -> 3393;
3398 -> 3389;
3398 -> 3393;
3399 -> 3391;
3399 -> 3393;
3400 -> 3392;
3400 -> 3393;
3401 -> 3393;
3402 -> 3401;
3402 -> 3393;
3403 -> 3401;
3403 -> 3393;
3404 -> 3401;
3404 -> 3393;
3405 -> 3401;
3405 -> 3393;
3406 -> 3401;
3406 -> 3393;
3407 -> 3401;
3407 -> 3393;
3408 -> 3401;
3408 -> 3393;
3409 -> 3395;
3409 -> 3394;
3409 -> 3393;
3410 -> 3393;
3411 -> 3394;
3411 -> 3401;
3411 -> 3393;
3412 -> 3395;
3412 -> 3401;
3412 -> 3393;
3413 -> 3396;
3413 -> 3401;
3413 -> 3393;
3414 -> 3397;
3414 -> 3401;
3414 -> 3393;
3415 -> 3398;
3415 -> 3401;
3415 -> 3393;
3416 -> 3399;
3416 -> 3401;
3416 -> 3393;
3417 -> 3400;
3417 -> 3401;
3417 -> 3393;
3418 -> 3401;
3418 -> 3417;
3418 -> 0;
3418 -> 3393;
3419 -> 3393;
3420 -> 3399;
3420 -> 3393;
3421 -> 3393;
3423 -> 3422;
3425 -> 3424;
3427 -> 3426;
3429 -> 3428;
3431 -> 3430;
3433 -> 3432;
3434 -> 0;
3436 -> 3423;
3436 -> 3435;
3437 -> 3425;
3437 -> 3435;
3438 -> 3427;
3438 -> 3435;
3439 -> 3429;
3439 -> 3435;
3440 -> 3431;
3440 -> 3435;
3441 -> 3433;
3441 -> 3435;
3442 -> 3434;
3442 -> 3435;
3443 -> 3435;
3444 -> 3443;
3444 -> 3435;
3445 -> 3443;
3445 -> 3435;
3446 -> 3443;
3446 -> 3435;
3447 -> 3443;
3447 -> 3435;
3448 -> 3443;
3448 -> 3435;
3449 -> 3443;
3449 -> 3435;
3450 -> 3443;
3450 -> 3435;
3451 -> 3437;
3451 -> 3436;
3451 -> 3435;
3452 -> 3435;
3453 -> 3436;
3453 -> 3443;
3453 -> 3435;
3454 -> 3437;
3454 -> 3443;
3454 -> 3435;
3455 -> 3438;
3455 -> 3443;
3455 -> 3435;
3456 -> 3439;
3456 -> 3443;
3456 -> 3435;
3457 -> 3440;
3457 -> 3443;
3457 -> 3435;
3458 -> 3441;
3458 -> 3443;
3458 -> 3435;
3459 -> 3442;
3459 -> 3443;
3459 -> 3435;
3460 -> 3443;
3460 -> 3459;
3460 -> 0;
3460 -> 3435;
3461 -> 3435;
3462 -> 3441;
3462 -> 3435;
3463 -> 3435;
3465 -> 3464;
3467 -> 3466;
3469 -> 3468;
3471 -> 3470;
3473 -> 3472;
3475 -> 3474;
3476 -> 0;
3478 -> 3465;
3478 -> 3477;
3479 -> 3467;
3479 -> 3477;
3480 -> 3469;
3480 -> 3477;
3481 -> 3471;
3481 -> 3477;
3482 -> 3473;
3482 -> 3477;
3483 -> 3475;
3483 -> 3477;
3484 -> 3476;
3484 -> 3477;
3485 -> 3477;
3486 -> 3485;
3486 -> 3477;
3487 -> 3485;
3487 -> 3477;
3488 -> 3485;
3488 -> 3477;
3489 -> 3485;
3489 -> 3477;
3490 -> 3485;
3490 -> 3477;
3491 -> 3485;
3491 -> 3477;
3492 -> 3485;
3492 -> 3477;
3493 -> 3479;
3493 -> 3477;
3494 -> 3477;
3495 -> 3478;
3495 -> 3485;
3495 -> 3477;
3496 -> 3479;
3496 -> 3485;
3496 -> 3477;
3497 -> 3480;
3497 -> 3485;
3497 -> 3477;
3498 -> 3481;
3498 -> 3485;
3498 -> 3477;
3499 -> 3482;
3499 -> 3485;
3499 -> 3477;
3500 -> 3483;
3500 -> 3485;
3500 -> 3477;
3501 -> 3484;
3501 -> 3485;
3501 -> 3477;
3502 -> 3485;
3502 -> 3501;
3502 -> 0;
3502 -> 3477;
3503 -> 3477;
3504 -> 3483;
3504 -> 3477;
3505 -> 3477;
3507 -> 3506;
3509 -> 3508;
3511 -> 3510;
3513 -> 3512;
3515 -> 3514;
3517 -> 3516;
3518 -> 0;
3519 -> 3518;
3521 -> 3507;
3521 -> 3520;
3522 -> 3509;
3522 -> 3520;
3523 -> 3511;
3523 -> 3520;
3524 -> 3513;
3524 -> 3520;
3525 -> 3515;
3525 -> 3520;
3526 -> 3517;
3526 -> 3520;
3527 -> 3519;
3527 -> 3520;
3528 -> 3520;
3529 -> 3528;
3529 -> 3520;
3530 -> 3528;
3530 -> 3520;
3531 -> 3528;
3531 -> 3520;
3532 -> 3528;
3532 -> 3520;
3533 -> 3528;
3533 -> 3520;
3534 -> 3528;
3534 -> 3520;
3535 -> 3528;
3535 -> 3520;
3536 -> 3522;
3536 -> 3520;
3537 -> 3520;
3538 -> 3521;
3538 -> 3528;
3538 -> 3520;
3539 -> 3522;
3539 -> 3528;
3539 -> 3520;
3540 -> 3523;
3540 -> 3528;
3540 -> 3520;
3541 -> 3524;
3541 -> 3528;
3541 -> 3520;
3542 -> 3525;
3542 -> 3528;
3542 -> 3520;
3543 -> 3526;
3543 -> 3528;
3543 -> 3520;
3544 -> 3527;
3544 -> 3528;
3544 -> 3520;
3545 -> 3528;
3545 -> 3544;
3545 -> 0;
3545 -> 3520;
3546 -> 3520;
3547 -> 3526;
3547 -> 3520;
3548 -> 3528;
3548 -> 3544;
3548 -> 0;
3548 -> 3547;
3549 -> 3548;
3549 -> 3528;
3549 -> 3547;
3550 -> 3520;
3552 -> 3551;
3554 -> 3553;
3556 -> 3555;
3558 -> 3557;
3560 -> 3559;
3562 -> 3561;
3563 -> 0;
3565 -> 3552;
3565 -> 3564;
3566 -> 3554;
3566 -> 3564;
3567 -> 3556;
3567 -> 3564;
3568 -> 3558;
3568 -> 3564;
3569 -> 3560;
3569 -> 3564;
3570 -> 3562;
3570 -> 3564;
3571 -> 3563;
3571 -> 3564;
3572 -> 3564;
3573 -> 3572;
3573 -> 3564;
3574 -> 3572;
3574 -> 3564;
3575 -> 3572;
3575 -> 3564;
3576 -> 3572;
3576 -> 3564;
3577 -> 3572;
3577 -> 3564;
3578 -> 3572;
3578 -> 3564;
3579 -> 3572;
3579 -> 3564;
3580 -> 3566;
3580 -> 3564;
3581 -> 3564;
3582 -> 3565;
3582 -> 3572;
3582 -> 3564;
3583 -> 3566;
3583 -> 3572;
3583 -> 3564;
3584 -> 3567;
3584 -> 3572;
3584 -> 3564;
3585 -> 3568;
3585 -> 3572;
3585 -> 3564;
3586 -> 3569;
3586 -> 3572;
3586 -> 3564;
3587 -> 3570;
3587 -> 3572;
3587 -> 3564;
3588 -> 3571;
3588 -> 3572;
3588 -> 3564;
3589 -> 3572;
3589 -> 3588;
3589 -> 0;
3589 -> 3564;
3590 -> 3564;
3591 -> 3570;
3591 -> 3564;
3592 -> 3572;
3592 -> 3588;
3592 -> 0;
3592 -> 3591;
3593 -> 3592;
3593 -> 3572;
3593 -> 3591;
3594 -> 3564;
3596 -> 3595;
3598 -> 3597;
3600 -> 3599;
3602 -> 3601;
3604 -> 3603;
3606 -> 3605;
3607 -> 0;
3609 -> 3596;
3609 -> 3608;
3610 -> 3598;
3610 -> 3608;
3611 -> 3600;
3611 -> 3608;
3612 -> 3602;
3612 -> 3608;
3613 -> 3604;
3613 -> 3608;
3614 -> 3606;
3614 -> 3608;
3615 -> 3607;
3615 -> 3608;
3616 -> 3608;
3617 -> 3616;
3617 -> 3608;
3618 -> 3616;
3618 -> 3608;
3619 -> 3616;
3619 -> 3608;
3620 -> 3616;
3620 -> 3608;
3621 -> 3616;
3621 -> 3608;
3622 -> 3616;
3622 -> 3608;
3623 -> 3616;
3623 -> 3608;
3624 -> 3610;
3624 -> 3608;
3625 -> 3608;
3626 -> 3609;
3626 -> 3616;
3626 -> 3608;
3627 -> 3610;
3627 -> 3616;
3627 -> 3608;
3628 -> 3611;
3628 -> 3616;
3628 -> 3608;
3629 -> 3612;
3629 -> 3616;
3629 -> 3608;
3630 -> 3613;
3630 -> 3616;
3630 -> 3608;
3631 -> 3614;
3631 -> 3616;
3631 -> 3608;
3632 -> 3615;
3632 -> 3616;
3632 -> 3608;
3633 -> 3616;
3633 -> 3632;
3633 -> 0;
3633 -> 3608;
3634 -> 3608;
3635 -> 3614;
3635 -> 3608;
3636 -> 3608;
3638 -> 3637;
3640 -> 3639;
3642 -> 3641;
3644 -> 3643;
3646 -> 3645;
3648 -> 3647;
3649 -> 0;
3650 -> 3649;
3650 -> 0;
3651 -> 3650;
3653 -> 3638;
3653 -> 3652;
3654 -> 3640;
3654 -> 3652;
3655 -> 3642;
3655 -> 3652;
3656 -> 3644;
3656 -> 3652;
3657 -> 3646;
3657 -> 3652;
3658 -> 3648;
3658 -> 3652;
3659 -> 3651;
3659 -> 3652;
3660 -> 3652;
3661 -> 3660;
3661 -> 3652;
3662 -> 3660;
3662 -> 3652;
3663 -> 3660;
3663 -> 3652;
3664 -> 3660;
3664 -> 3652;
3665 -> 3660;
3665 -> 3652;
3666 -> 3660;
3666 -> 3652;
3667 -> 3660;
3667 -> 3652;
3668 -> 3654;
3668 -> 3652;
3669 -> 3652;
3670 -> 3653;
3670 -> 3660;
3670 -> 3652;
3671 -> 3654;
3671 -> 3660;
3671 -> 3652;
3672 -> 3655;
3672 -> 3660;
3672 -> 3652;
3673 -> 3656;
3673 -> 3660;
3673 -> 3652;
3674 -> 3657;
3674 -> 3660;
3674 -> 3652;
3675 -> 3658;
3675 -> 3660;
3675 -> 3652;
3676 -> 3659;
3676 -> 3660;
3676 -> 3652;
3677 -> 3660;
3677 -> 3676;
3677 -> 0;
3677 -> 3652;
3678 -> 3652;
3679 -> 3658;
3679 -> 3652;
3680 -> 3652;
3682 -> 3681;
3684 -> 3683;
3686 -> 3685;
3688 -> 3687;
3690 -> 3689;
3692 -> 3691;
3693 -> 0;
3694 -> 3693;
3694 -> 0;
3695 -> 3694;
3697 -> 3682;
3697 -> 3696;
3698 -> 3684;
3698 -> 3696;
3699 -> 3686;
3699 -> 3696;
3700 -> 3688;
3700 -> 3696;
3701 -> 3690;
3701 -> 3696;
3702 -> 3692;
3702 -> 3696;
3703 -> 3695;
3703 -> 3696;
3704 -> 3696;
3705 -> 3704;
3705 -> 3696;
3706 -> 3704;
3706 -> 3696;
3707 -> 3704;
3707 -> 3696;
3708 -> 3704;
3708 -> 3696;
3709 -> 3704;
3709 -> 3696;
3710 -> 3704;
3710 -> 3696;
3711 -> 3704;
3711 -> 3696;
3712 -> 3698;
3712 -> 3696;
3713 -> 3696;
3714 -> 3697;
3714 -> 3704;
3714 -> 3696;
3715 -> 3698;
3715 -> 3704;
3715 -> 3696;
3716 -> 3699;
3716 -> 3704;
3716 -> 3696;
3717 -> 3700;
3717 -> 3704;
3717 -> 3696;
3718 -> 3701;
3718 -> 3704;
3718 -> 3696;
3719 -> 3702;
3719 -> 3704;
3719 -> 3696;
3720 -> 3703;
3720 -> 3704;
3720 -> 3696;
3721 -> 3704;
3721 -> 3720;
3721 -> 0;
3721 -> 3696;
3722 -> 3696;
3723 -> 3702;
3723 -> 3696;
3724 -> 3704;
3724 -> 3720;
3724 -> 0;
3724 -> 3723;
3725 -> 3724;
3725 -> 3704;
3725 -> 3723;
3726 -> 3696;
3728 -> 3727;
3730 -> 3729;
3732 -> 3731;
3734 -> 3733;
3736 -> 3735;
3738 -> 3737;
3739 -> 0;
3740 -> 3739;
3740 -> 0;
3741 -> 3740;
3743 -> 3728;
3743 -> 3742;
3744 -> 3730;
3744 -> 3742;
3745 -> 3732;
3745 -> 3742;
3746 -> 3734;
3746 -> 3742;
3747 -> 3736;
3747 -> 3742;
3748 -> 3738;
3748 -> 3742;
3749 -> 3741;
3749 -> 3742;
3750 -> 3742;
3751 -> 3750;
3751 -> 3742;
3752 -> 3750;
3752 -> 3742;
3753 -> 3750;
3753 -> 3742;
3754 -> 3750;
3754 -> 3742;
3755 -> 3750;
3755 -> 3742;
3756 -> 3750;
3756 -> 3742;
3757 -> 3750;
3757 -> 3742;
3758 -> 3744;
3758 -> 3742;
3759 -> 3742;
3760 -> 3743;
3760 -> 3750;
3760 -> 3742;
3761 -> 3744;
3761 -> 3750;
3761 -> 3742;
3762 -> 3745;
3762 -> 3750;
3762 -> 3742;
3763 -> 3746;
3763 -> 3750;
3763 -> 3742;
3764 -> 3747;
3764 -> 3750;
3764 -> 3742;
3765 -> 3748;
3765 -> 3750;
3765 -> 3742;
3766 -> 3749;
3766 -> 3750;
3766 -> 3742;
3767 -> 3750;
3767 -> 3766;
3767 -> 0;
3767 -> 3742;
3768 -> 3742;
3769 -> 3748;
3769 -> 3742;
3770 -> 3750;
3770 -> 3766;
3770 -> 0;
3770 -> 3769;
3771 -> 3770;
3771 -> 3750;
3771 -> 3769;
3772 -> 3742;
3774 -> 3773;
3776 -> 3775;
3778 -> 3777;
3780 -> 3779;
3782 -> 3781;
3784 -> 3783;
3785 -> 0;
3786 -> 3785;
3786 -> 0;
3787 -> 3786;
3789 -> 3774;
3789 -> 3788;
3790 -> 3776;
3790 -> 3788;
3791 -> 3778;
3791 -> 3788;
3792 -> 3780;
3792 -> 3788;
3793 -> 3782;
3793 -> 3788;
3794 -> 3784;
3794 -> 3788;
3795 -> 3787;
3795 -> 3788;
3796 -> 3788;
3797 -> 3796;
3797 -> 3788;
3798 -> 3796;
3798 -> 3788;
3799 -> 3796;
3799 -> 3788;
3800 -> 3796;
3800 -> 3788;
3801 -> 3796;
3801 -> 3788;
3802 -> 3796;
3802 -> 3788;
3803 -> 3796;
3803 -> 3788;
3804 -> 3790;
3804 -> 3788;
3805 -> 3788;
3806 -> 3789;
3806 -> 3796;
3806 -> 3788;
3807 -> 3790;
3807 -> 3796;
3807 -> 3788;
3808 -> 3791;
3808 -> 3796;
3808 -> 3788;
3809 -> 3792;
3809 -> 3796;
3809 -> 3788;
3810 -> 3793;
3810 -> 3796;
3810 -> 3788;
3811 -> 3794;
3811 -> 3796;
3811 -> 3788;
3812 -> 3795;
3812 -> 3796;
3812 -> 3788;
3813 -> 3796;
3813 -> 3812;
3813 -> 0;
3813 -> 3788;
3814 -> 3788;
3815 -> 3794;
3815 -> 3788;
3816 -> 3788;
3818 -> 3817;
3820 -> 3819;
3822 -> 3821;
3824 -> 3823;
3826 -> 3825;
3828 -> 3827;
3829 -> 0;
3830 -> 3829;
3830 -> 0;
3831 -> 3830;
3833 -> 3818;
3833 -> 3832;
3834 -> 3820;
3834 -> 3832;
3835 -> 3822;
3835 -> 3832;
3836 -> 3824;
3836 -> 3832;
3837 -> 3826;
3837 -> 3832;
3838 -> 3828;
3838 -> 3832;
3839 -> 3831;
3839 -> 3832;
3840 -> 3832;
3841 -> 3840;
3841 -> 3832;
3842 -> 3840;
3842 -> 3832;
3843 -> 3840;
3843 -> 3832;
3844 -> 3840;
3844 -> 3832;
3845 -> 3840;
3845 -> 3832;
3846 -> 3840;
3846 -> 3832;
3847 -> 3840;
3847 -> 3832;
3848 -> 3834;
3848 -> 3833;
3848 -> 3832;
3849 -> 3832;
3850 -> 3833;
3850 -> 3840;
3850 -> 3832;
3851 -> 3834;
3851 -> 3840;
3851 -> 3832;
3852 -> 3835;
3852 -> 3840;
3852 -> 3832;
3853 -> 3836;
3853 -> 3840;
3853 -> 3832;
3854 -> 3837;
3854 -> 3840;
3854 -> 3832;
3855 -> 3838;
3855 -> 3840;
3855 -> 3832;
3856 -> 3839;
3856 -> 3840;
3856 -> 3832;
3857 -> 3840;
3857 -> 3856;
3857 -> 0;
3857 -> 3832;
3858 -> 3832;
3859 -> 3838;
3859 -> 3832;
3860 -> 3840;
3860 -> 3856;
3860 -> 0;
3860 -> 3859;
3861 -> 3860;
3861 -> 3840;
3861 -> 3859;
3862 -> 3832;
3864 -> 3863;
3866 -> 3865;
3868 -> 3867;
3870 -> 3869;
3872 -> 3871;
3874 -> 3873;
3875 -> 0;
3876 -> 3875;
3876 -> 0;
3877 -> 3876;
3879 -> 3864;
3879 -> 3878;
3880 -> 3866;
3880 -> 3878;
3881 -> 3868;
3881 -> 3878;
3882 -> 3870;
3882 -> 3878;
3883 -> 3872;
3883 -> 3878;
3884 -> 3874;
3884 -> 3878;
3885 -> 3877;
3885 -> 3878;
3886 -> 3878;
3887 -> 3886;
3887 -> 3878;
3888 -> 3886;
3888 -> 3878;
3889 -> 3886;
3889 -> 3878;
3890 -> 3886;
3890 -> 3878;
3891 -> 3886;
3891 -> 3878;
3892 -> 3886;
3892 -> 3878;
3893 -> 3886;
3893 -> 3878;
3894 -> 3880;
3894 -> 3879;
3894 -> 3878;
3895 -> 3878;
3896 -> 3879;
3896 -> 3886;
3896 -> 3878;
3897 -> 3880;
3897 -> 3886;
3897 -> 3878;
3898 -> 3881;
3898 -> 3886;
3898 -> 3878;
3899 -> 3882;
3899 -> 3886;
3899 -> 3878;
3900 -> 3883;
3900 -> 3886;
3900 -> 3878;
3901 -> 3884;
3901 -> 3886;
3901 -> 3878;
3902 -> 3885;
3902 -> 3886;
3902 -> 3878;
3903 -> 3886;
3903 -> 3902;
3903 -> 0;
3903 -> 3878;
3904 -> 3878;
3905 -> 3884;
3905 -> 3878;
3906 -> 3878;
3908 -> 3907;
3910 -> 3909;
3912 -> 3911;
3914 -> 3913;
3916 -> 3915;
3918 -> 3917;
3919 -> 0;
3920 -> 3919;
3920 -> 0;
3921 -> 3920;
3923 -> 3908;
3923 -> 3922;
3924 -> 3910;
3924 -> 3922;
3925 -> 3912;
3925 -> 3922;
3926 -> 3914;
3926 -> 3922;
3927 -> 3916;
3927 -> 3922;
3928 -> 3918;
3928 -> 3922;
3929 -> 3921;
3929 -> 3922;
3930 -> 3922;
3931 -> 3930;
3931 -> 3922;
3932 -> 3930;
3932 -> 3922;
3933 -> 3930;
3933 -> 3922;
3934 -> 3930;
3934 -> 3922;
3935 -> 3930;
3935 -> 3922;
3936 -> 3930;
3936 -> 3922;
3937 -> 3930;
3937 -> 3922;
3938 -> 3924;
3938 -> 3922;
3939 -> 3922;
3940 -> 3923;
3940 -> 3930;
3940 -> 3922;
3941 -> 3924;
3941 -> 3930;
3941 -> 3922;
3942 -> 3925;
3942 -> 3930;
3942 -> 3922;
3943 -> 3926;
3943 -> 3930;
3943 -> 3922;
3944 -> 3927;
3944 -> 3930;
3944 -> 3922;
3945 -> 3928;
3945 -> 3930;
3945 -> 3922;
3946 -> 3929;
3946 -> 3930;
3946 -> 3922;
3947 -> 3930;
3947 -> 3946;
3947 -> 0;
3947 -> 3922;
3948 -> 3922;
3949 -> 3928;
3949 -> 3922;
3950 -> 3922;
3952 -> 3951;
3954 -> 3953;
3956 -> 3955;
3958 -> 3957;
3960 -> 3959;
3962 -> 3961;
3963 -> 0;
3964 -> 3963;
3964 -> 0;
3965 -> 3964;
3967 -> 3952;
3967 -> 3966;
3968 -> 3954;
3968 -> 3966;
3969 -> 3956;
3969 -> 3966;
3970 -> 3958;
3970 -> 3966;
3971 -> 3960;
3971 -> 3966;
3972 -> 3962;
3972 -> 3966;
3973 -> 3965;
3973 -> 3966;
3974 -> 3966;
3975 -> 3974;
3975 -> 3966;
3976 -> 3974;
3976 -> 3966;
3977 -> 3974;
3977 -> 3966;
3978 -> 3974;
3978 -> 3966;
3979 -> 3974;
3979 -> 3966;
3980 -> 3974;
3980 -> 3966;
3981 -> 3974;
3981 -> 3966;
3982 -> 3968;
3982 -> 3966;
3983 -> 3966;
3984 -> 3967;
3984 -> 3974;
3984 -> 3966;
3985 -> 3968;
3985 -> 3974;
3985 -> 3966;
3986 -> 3969;
3986 -> 3974;
3986 -> 3966;
3987 -> 3970;
3987 -> 3974;
3987 -> 3966;
3988 -> 3971;
3988 -> 3974;
3988 -> 3966;
3989 -> 3972;
3989 -> 3974;
3989 -> 3966;
3990 -> 3973;
3990 -> 3974;
3990 -> 3966;
3991 -> 3974;
3991 -> 3990;
3991 -> 0;
3991 -> 3966;
3992 -> 3966;
3993 -> 3972;
3993 -> 3966;
3994 -> 3966;
3995 -> 3421;
3996 -> 3995;
3996 -> 3411;
3996 -> 3412;
3996 -> 3413;
3996 -> 3414;
3996 -> 3415;
3996 -> 3416;
3996 -> 3417;
3997 -> 3996;
3998 -> 0;
3999 -> 3998;
4000 -> 3999;
4001 -> 0;
4002 -> 4001;
4003 -> 0;
4004 -> 4003;
4005 -> 3205;
4005 -> 3204;
4006 -> 3206;
4006 -> 3204;
4007 -> 3207;
4007 -> 3204;
4008 -> 3208;
4008 -> 3204;
4009 -> 3204;
4010 -> 4005;
4010 -> 4009;
4011 -> 4006;
4011 -> 4009;
4012 -> 4007;
4012 -> 4009;
4013 -> 4008;
4013 -> 4009;
4014 -> 3209;
4014 -> 4009;
4016 -> 4015;
4018 -> 4017;
4020 -> 4019;
4022 -> 4021;
4024 -> 4022;
4024 -> 4023;
4025 -> 4024;
4027 -> 4026;
4029 -> 4028;
4031 -> 4030;
4033 -> 4032;
4043 -> 4035;
4043 -> 4034;
4044 -> 4036;
4044 -> 4034;
4045 -> 4037;
4045 -> 4034;
4046 -> 4038;
4046 -> 4034;
4047 -> 4039;
4047 -> 4034;
4048 -> 4040;
4048 -> 4034;
4049 -> 4041;
4049 -> 4034;
4050 -> 4042;
4050 -> 4034;
4051 -> 4034;
4052 -> 4013;
4052 -> 4009;
4053 -> 4009;
4054 -> 4052;
4054 -> 4053;
4055 -> 4014;
4055 -> 4053;
4057 -> 4056;
4059 -> 0;
4061 -> 4059;
4061 -> 4060;
4062 -> 4060;
4063 -> 4062;
4063 -> 4060;
4064 -> 4061;
4064 -> 4062;
4064 -> 4060;
4065 -> 4060;
4066 -> 0;
4068 -> 4066;
4068 -> 4067;
4069 -> 4067;
4070 -> 4069;
4070 -> 4067;
4071 -> 4068;
4071 -> 4069;
4071 -> 4067;
4072 -> 4067;
4073 -> 0;
4075 -> 4073;
4075 -> 4074;
4076 -> 4074;
4077 -> 4076;
4077 -> 4074;
4078 -> 4075;
4078 -> 4076;
4078 -> 4074;
4079 -> 4074;
4080 -> 0;
4082 -> 4080;
4082 -> 4081;
4083 -> 4081;
4084 -> 4083;
4084 -> 4081;
4085 -> 4082;
4085 -> 4083;
4085 -> 4081;
4086 -> 4081;
4087 -> 0;
4089 -> 4087;
4089 -> 4088;
4090 -> 4088;
4091 -> 4090;
4091 -> 4088;
4092 -> 4089;
4092 -> 4090;
4092 -> 4088;
4093 -> 4088;
4094 -> 0;
4096 -> 4094;
4096 -> 4095;
4097 -> 4095;
4098 -> 4097;
4098 -> 4095;
4099 -> 4096;
4099 -> 4097;
4099 -> 4095;
4100 -> 4095;
4101 -> 0;
4103 -> 4101;
4103 -> 4102;
4104 -> 4102;
4105 -> 4104;
4105 -> 4102;
4106 -> 4103;
4106 -> 4104;
4106 -> 4102;
4107 -> 4102;
4108 -> 0;
4110 -> 4108;
4110 -> 4109;
4111 -> 4109;
4112 -> 4111;
4112 -> 4109;
4113 -> 4110;
4113 -> 4111;
4113 -> 4109;
4114 -> 4109;
4115 -> 4114;
4117 -> 4058;
4117 -> 4115;
4117 -> 4116;
4117 -> 4111;
4117 -> 4112;
4117 -> 4113;
4118 -> 4117;
4120 -> 4119;
4121 -> 4120;
4121 -> 4119;
4122 -> 4120;
4122 -> 4119;
4123 -> 4120;
4123 -> 4119;
4124 -> 4119;
4126 -> 4125;
4127 -> 4053;
4128 -> 4055;
4128 -> 4127;
4129 -> 4127;
4130 -> 4128;
4130 -> 4127;
4131 -> 4128;
4131 -> 4127;
4132 -> 4055;
4132 -> 4053;
4133 -> 4055;
4133 -> 4053;
4134 -> 4055;
4134 -> 4053;
4135 -> 4054;
4135 -> 4055;
4135 -> 4053;
4136 -> 4014;
4136 -> 4009;
4137 -> 4014;
4137 -> 4009;
4138 -> 4014;
4138 -> 4009;
4140 -> 4139;
4141 -> 4140;
4141 -> 4139;
4142 -> 4140;
4142 -> 4139;
4143 -> 4140;
4143 -> 4139;
4144 -> 4140;
4144 -> 4139;
4145 -> 4140;
4145 -> 4139;
4146 -> 4140;
4146 -> 4139;
4147 -> 4139;
4148 -> 4147;
4148 -> 4014;
4148 -> 4009;
4149 -> 4014;
4149 -> 4009;
4150 -> 4014;
4150 -> 4009;
4151 -> 4014;
4151 -> 4009;
4152 -> 4014;
4152 -> 4009;
4153 -> 4014;
4153 -> 4009;
4154 -> 2957;
4154 -> 4014;
4154 -> 4009;
4155 -> 4014;
4155 -> 4009;
4156 -> 4014;
4156 -> 4009;
4157 -> 4010;
4157 -> 4014;
4157 -> 4009;
4158 -> 4011;
4158 -> 4014;
4158 -> 4009;
4159 -> 4011;
4159 -> 3197;
4159 -> 4009;
4160 -> 4009;
4161 -> 4159;
4161 -> 4160;
4162 -> 4161;
4162 -> 4160;
4163 -> 0;
4163 -> 4162;
4164 -> 4163;
4164 -> 4009;
4165 -> 4012;
4165 -> 4009;
4166 -> 4009;
4167 -> 4164;
4167 -> 4166;
4168 -> 4165;
4168 -> 4166;
4169 -> 4014;
4169 -> 4166;
4170 -> 4166;
4171 -> 4169;
4171 -> 4170;
4172 -> 4171;
4172 -> 4157;
4172 -> 4170;
4173 -> 4172;
4173 -> 4166;
4174 -> 4166;
4175 -> 0;
4175 -> 4166;
4176 -> 4166;
4177 -> 4173;
4177 -> 4176;
4178 -> 4176;
4178 -> 4166;
4179 -> 0;
4179 -> 4178;
4180 -> 4167;
4180 -> 4166;
4181 -> 0;
4181 -> 4180;
4182 -> 4175;
4182 -> 4181;
4182 -> 4180;
4183 -> 4180;
4184 -> 4169;
4184 -> 4183;
4185 -> 4183;
4186 -> 4184;
4186 -> 4158;
4186 -> 3197;
4186 -> 4185;
4186 -> 4183;
4187 -> 4186;
4187 -> 4180;
4188 -> 4182;
4188 -> 0;
4188 -> 4187;
4189 -> 4166;
4190 -> 4179;
4190 -> 4166;
4191 -> 4188;
4191 -> 4166;
4192 -> 4168;
4192 -> 4166;
4193 -> 4189;
4193 -> 4166;
4194 -> 4166;
4195 -> 4190;
4195 -> 4194;
4196 -> 4191;
4196 -> 4194;
4197 -> 4192;
4197 -> 4194;
4198 -> 4193;
4198 -> 4194;
4199 -> 4169;
4199 -> 4194;
4200 -> 4194;
4201 -> 0;
4201 -> 4194;
4202 -> 4199;
4202 -> 4158;
4202 -> 4186;
4202 -> 4194;
4203 -> 4194;
4204 -> 4194;
4205 -> 4204;
4205 -> 4202;
4205 -> 4194;
4206 -> 4199;
4206 -> 4158;
4206 -> 4186;
4206 -> 4204;
4206 -> 4205;
4207 -> 4206;
4207 -> 4205;
4208 -> 4205;
4209 -> 4200;
4209 -> 4205;
4210 -> 4207;
4210 -> 4209;
4211 -> 4196;
4211 -> 4209;
4212 -> 4199;
4212 -> 4158;
4212 -> 4206;
4212 -> 4204;
4212 -> 4209;
4213 -> 4197;
4213 -> 4209;
4214 -> 4209;
4215 -> 4200;
4215 -> 4209;
4216 -> 4209;
4217 -> 4210;
4217 -> 4216;
4218 -> 4211;
4218 -> 4216;
4219 -> 4212;
4219 -> 4216;
4220 -> 4213;
4220 -> 4216;
4221 -> 4214;
4221 -> 4216;
4222 -> 4215;
4222 -> 4216;
4223 -> 4216;
4224 -> 4217;
4224 -> 4218;
4224 -> 4216;
4225 -> 4217;
4225 -> 4218;
4225 -> 4216;
4226 -> 4224;
4226 -> 0;
4226 -> 4216;
4227 -> 4225;
4227 -> 0;
4227 -> 4216;
4228 -> 4216;
4229 -> 4225;
4229 -> 4216;
4230 -> 4223;
4230 -> 4209;
4231 -> 4229;
4231 -> 4230;
4232 -> 4199;
4232 -> 4230;
4233 -> 4230;
4234 -> 4230;
4235 -> 4231;
4235 -> 4234;
4236 -> 4232;
4236 -> 4234;
4237 -> 4233;
4237 -> 4234;
4238 -> 4235;
4238 -> 4234;
4239 -> 4234;
4240 -> 4238;
4240 -> 4239;
4241 -> 4240;
4241 -> 0;
4241 -> 4239;
4242 -> 4241;
4243 -> 4234;
4244 -> 4236;
4244 -> 4243;
4245 -> 0;
4245 -> 4243;
4246 -> 4245;
4246 -> 4234;
4247 -> 4237;
4247 -> 4246;
4247 -> 4234;
4248 -> 4235;
4248 -> 0;
4248 -> 4234;
4249 -> 4234;
4250 -> 4247;
4250 -> 4248;
4250 -> 4234;
4251 -> 4235;
4251 -> 0;
4251 -> 4250;
4252 -> 4234;
4253 -> 4252;
4253 -> 4230;
4254 -> 4230;
4255 -> 4253;
4255 -> 4254;
4255 -> 4230;
4256 -> 4201;
4256 -> 0;
4256 -> 4205;
4257 -> 4229;
4257 -> 4256;
4258 -> 4257;
4258 -> 0;
4258 -> 4194;
4259 -> 4194;
4260 -> 4203;
4260 -> 4194;
4261 -> 4194;
4262 -> 4199;
4262 -> 4261;
4263 -> 4262;
4263 -> 4158;
4263 -> 4212;
4263 -> 4261;
4264 -> 4263;
4264 -> 4194;
4265 -> 0;
4265 -> 4194;
4266 -> 4257;
4266 -> 4194;
4268 -> 4267;
4269 -> 4169;
4269 -> 4166;
4270 -> 4266;
4270 -> 4166;
4271 -> 4168;
4271 -> 4166;
4272 -> 4166;
4273 -> 4269;
4273 -> 4272;
4274 -> 4270;
4274 -> 4272;
4275 -> 4271;
4275 -> 4272;
4276 -> 4273;
4276 -> 4272;
4277 -> 4274;
4277 -> 4272;
4278 -> 4272;
4279 -> 4273;
4279 -> 4278;
4280 -> 4279;
4280 -> 4158;
4280 -> 4212;
4280 -> 4278;
4281 -> 4280;
4281 -> 4272;
4282 -> 4272;
4283 -> 4275;
4283 -> 4272;
4284 -> 4272;
4285 -> 4276;
4285 -> 4284;
4286 -> 4277;
4286 -> 4284;
4287 -> 4281;
4287 -> 4284;
4288 -> 4283;
4288 -> 4284;
4289 -> 4286;
4289 -> 0;
4289 -> 4284;
4290 -> 4166;
4291 -> 4266;
4291 -> 0;
4291 -> 4166;
4292 -> 4166;
4293 -> 4223;
4293 -> 4291;
4293 -> 4166;
4294 -> 0;
4294 -> 4166;
4295 -> 4266;
4295 -> 4294;
4295 -> 4166;
4296 -> 4223;
4296 -> 4295;
4296 -> 4166;
4297 -> 4167;
4297 -> 4166;
4298 -> 4266;
4298 -> 4166;
4299 -> 4011;
4299 -> 4281;
4299 -> 4009;
4300 -> 4299;
4300 -> 4281;
4301 -> 4012;
4301 -> 4300;
4301 -> 3197;
4301 -> 4281;
4301 -> 4299;
4302 -> 4298;
4302 -> 0;
4302 -> 4009;
4303 -> 4009;
4304 -> 4302;
4304 -> 4303;
4304 -> 4009;
4305 -> 4298;
4305 -> 4014;
4305 -> 4009;
4306 -> 4302;
4306 -> 0;
4306 -> 4009;
4307 -> 4306;
4307 -> 4009;
4308 -> 4307;
4309 -> 4014;
4309 -> 4308;
4310 -> 4308;
4311 -> 4309;
4311 -> 4310;
4312 -> 4311;
4312 -> 4157;
4312 -> 4310;
4313 -> 4312;
4313 -> 4308;
4314 -> 4308;
4315 -> 4313;
4315 -> 4314;
4316 -> 4314;
4316 -> 4308;
4317 -> 4308;
4318 -> 4309;
4318 -> 4317;
4319 -> 4318;
4319 -> 4157;
4319 -> 4317;
4320 -> 4319;
4320 -> 4308;
4321 -> 4308;
4322 -> 4320;
4322 -> 4321;
4323 -> 4321;
4324 -> 4322;
4324 -> 3190;
4324 -> 4301;
4324 -> 4323;
4325 -> 4324;
4325 -> 4301;
4325 -> 4323;
4326 -> 4308;
4327 -> 4325;
4327 -> 4326;
4328 -> 4326;
4329 -> 4327;
4329 -> 4328;
4330 -> 4329;
4330 -> 4326;
4331 -> 4327;
4331 -> 4326;
4332 -> 4316;
4332 -> 4330;
4332 -> 4308;
4333 -> 0;
4333 -> 4332;
4335 -> 4334;
4337 -> 4336;
4338 -> 4335;
4338 -> 4337;
4339 -> 4338;
4341 -> 4340;
4342 -> 4339;
4342 -> 4341;
4343 -> 4342;
4345 -> 4344;
4346 -> 4343;
4346 -> 4345;
4347 -> 4346;
4349 -> 4348;
4350 -> 4347;
4350 -> 4349;
4351 -> 4350;
4353 -> 4352;
4354 -> 4351;
4354 -> 4353;
4355 -> 4354;
4357 -> 4356;
4359 -> 4358;
4359 -> 4337;
4361 -> 4359;
4361 -> 4360;
4362 -> 4361;
4364 -> 4363;
4364 -> 4341;
4366 -> 4364;
4366 -> 4365;
4367 -> 4366;
4369 -> 4368;
4369 -> 4353;
4371 -> 4369;
4371 -> 4370;
4372 -> 4371;
4374 -> 4373;
4374 -> 4357;
4376 -> 4374;
4376 -> 4375;
4377 -> 4376;
4379 -> 4378;
4379 -> 4343;
4380 -> 4379;
4382 -> 4381;
4382 -> 4347;
4383 -> 4382;
4384 -> 4362;
4385 -> 4377;
4386 -> 4333;
4386 -> 4009;
4387 -> 4163;
4387 -> 4009;
4388 -> 4009;
4389 -> 4009;
4390 -> 4386;
4390 -> 4389;
4391 -> 4387;
4391 -> 4389;
4392 -> 4388;
4392 -> 4389;
4393 -> 4390;
4393 -> 4362;
4393 -> 4389;
4394 -> 4393;
4394 -> 4335;
4394 -> 4389;
4395 -> 4391;
4395 -> 4372;
4395 -> 4389;
4396 -> 4395;
4396 -> 4351;
4396 -> 4389;
4397 -> 4394;
4397 -> 4396;
4397 -> 4389;
4398 -> 4397;
4398 -> 4392;
4398 -> 4389;
4399 -> 4388;
4399 -> 4014;
4399 -> 4009;
4400 -> 4009;
4401 -> 4014;
4401 -> 4400;
4402 -> 4401;
4402 -> 4157;
4402 -> 4400;
4403 -> 4402;
4403 -> 4009;
4404 -> 4403;
4404 -> 4009;
4405 -> 4009;
4406 -> 0;
4406 -> 4009;
4407 -> 4009;
4408 -> 4406;
4408 -> 4407;
4409 -> 4014;
4409 -> 4407;
4410 -> 4409;
4410 -> 4408;
4410 -> 4407;
4411 -> 3209;
4411 -> 3204;
4412 -> 3209;
4412 -> 3204;
4413 -> 3209;
4413 -> 3204;
4414 -> 0;
4414 -> 3209;
4414 -> 3204;
4415 -> 3209;
4415 -> 3204;
4417 -> 4416;
4418 -> 4416;
4419 -> 4418;
4420 -> 4418;
4421 -> 4420;
4421 -> 4418;
4422 -> 4421;
4422 -> 4419;
4423 -> 4419;
4424 -> 4423;
4425 -> 4424;
4426 -> 4425;
4427 -> 4426;
4427 -> 4425;
4428 -> 4424;
4428 -> 4423;
4429 -> 4424;
4429 -> 4423;
4430 -> 4423;
4430 -> 4419;
4431 -> 4423;
4431 -> 4419;
4432 -> 4423;
4432 -> 4419;
4433 -> 4422;
4433 -> 4423;
4433 -> 4419;
4434 -> 4418;
4434 -> 4416;
4435 -> 4417;
4435 -> 4418;
4435 -> 4416;
4436 -> 4416;
4437 -> 4436;
4437 -> 3209;
4437 -> 3204;
4438 -> 3209;
4438 -> 3204;
4439 -> 4436;
4439 -> 3209;
4439 -> 3204;
4440 -> 3206;
4440 -> 4301;
4440 -> 3204;
4441 -> 3204;
4442 -> 3205;
4442 -> 4441;
4443 -> 4441;
4443 -> 3204;
4444 -> 3203;
4444 -> 3197;
4445 -> 4444;
4445 -> 4158;
4445 -> 4301;
4445 -> 3197;
4446 -> 3197;
4446 -> 4301;
4447 -> 4446;
4447 -> 4301;
4448 -> 4301;
4449 -> 4447;
4449 -> 4301;
4450 -> 4448;
4450 -> 4301;
4451 -> 4449;
4451 -> 4301;
4452 -> 4450;
4452 -> 4301;
4453 -> 4452;
4453 -> 4301;
4454 -> 4453;
4454 -> 4301;
4455 -> 4301;
4456 -> 4455;
4457 -> 4456;
4457 -> 4455;
4458 -> 4456;
4458 -> 4455;
4459 -> 4455;
4459 -> 4301;
4460 -> 4455;
4460 -> 4301;
4461 -> 4455;
4461 -> 4301;
4462 -> 4454;
4462 -> 4455;
4462 -> 4301;
4463 -> 4301;
4464 -> 4301;
4465 -> 4301;
4466 -> 4147;
4466 -> 4301;
4467 -> 4301;
4468 -> 4301;
4469 -> 4301;
4470 -> 4301;
4471 -> 4301;
4472 -> 2957;
4472 -> 4301;
4473 -> 4301;
4474 -> 4301;
4475 -> 4451;
4475 -> 4301;
4476 -> 4301;
4477 -> 4301;
4478 -> 4301;
4478 -> 4477;
4479 -> 4478;
4479 -> 4475;
4479 -> 4477;
4480 -> 4479;
4480 -> 4301;
4481 -> 4301;
4482 -> 0;
4482 -> 4301;
4483 -> 4301;
4484 -> 4480;
4484 -> 4483;
4485 -> 4483;
4485 -> 4301;
4486 -> 0;
4486 -> 4485;
4487 -> 0;
4487 -> 4301;
4488 -> 4482;
4488 -> 4487;
4488 -> 4301;
4489 -> 4301;
4490 -> 4488;
4490 -> 0;
4490 -> 4489;
4491 -> 4301;
4492 -> 4486;
4492 -> 4301;
4493 -> 4490;
4493 -> 4301;
4494 -> 4476;
4494 -> 4301;
4495 -> 4491;
4495 -> 4301;
4496 -> 4492;
4496 -> 4301;
4497 -> 4493;
4497 -> 4301;
4498 -> 4494;
4498 -> 4301;
4499 -> 4495;
4499 -> 4301;
4500 -> 0;
4500 -> 4301;
4501 -> 4301;
4502 -> 4301;
4503 -> 4301;
4504 -> 4301;
4505 -> 4502;
4505 -> 4504;
4506 -> 4497;
4506 -> 4504;
4507 -> 4502;
4507 -> 4504;
4508 -> 4498;
4508 -> 4504;
4509 -> 4502;
4509 -> 4504;
4510 -> 4502;
4510 -> 4504;
4511 -> 4504;
4512 -> 4505;
4512 -> 4506;
4512 -> 4504;
4513 -> 4505;
4513 -> 4506;
4513 -> 4504;
4514 -> 4512;
4514 -> 0;
4514 -> 4504;
4515 -> 4513;
4515 -> 0;
4515 -> 4504;
4516 -> 4504;
4517 -> 4513;
4517 -> 4504;
4518 -> 4511;
4518 -> 4301;
4519 -> 4517;
4519 -> 4518;
4520 -> 4301;
4520 -> 4518;
4521 -> 4518;
4522 -> 4518;
4523 -> 4519;
4523 -> 4522;
4524 -> 4520;
4524 -> 4522;
4525 -> 4521;
4525 -> 4522;
4526 -> 4523;
4526 -> 4522;
4527 -> 4522;
4528 -> 4526;
4528 -> 4527;
4529 -> 4528;
4529 -> 0;
4529 -> 4527;
4530 -> 4529;
4531 -> 4522;
4532 -> 4524;
4532 -> 4531;
4533 -> 0;
4533 -> 4531;
4534 -> 4533;
4534 -> 4522;
4535 -> 4525;
4535 -> 4534;
4535 -> 4522;
4536 -> 4523;
4536 -> 0;
4536 -> 4522;
4537 -> 4522;
4538 -> 4535;
4538 -> 4536;
4538 -> 4522;
4539 -> 4523;
4539 -> 0;
4539 -> 4538;
4540 -> 4522;
4541 -> 4540;
4541 -> 4518;
4542 -> 4518;
4543 -> 4541;
4543 -> 4542;
4543 -> 4518;
4544 -> 4500;
4544 -> 0;
4544 -> 4301;
4545 -> 4517;
4545 -> 4544;
4546 -> 4545;
4546 -> 0;
4546 -> 4301;
4547 -> 4301;
4548 -> 4501;
4548 -> 4301;
4549 -> 4301;
4550 -> 4301;
4550 -> 4549;
4551 -> 4550;
4551 -> 4301;
4551 -> 4502;
4551 -> 4549;
4552 -> 4551;
4552 -> 4301;
4553 -> 0;
4553 -> 4301;
4554 -> 4545;
4554 -> 4301;
4555 -> 4554;
4555 -> 4301;
4556 -> 4476;
4556 -> 4301;
4557 -> 4301;
4558 -> 4301;
4558 -> 4557;
4559 -> 4555;
4559 -> 4557;
4560 -> 4502;
4560 -> 4557;
4561 -> 4556;
4561 -> 4557;
4562 -> 4559;
4562 -> 0;
4562 -> 4557;
4563 -> 4554;
4563 -> 0;
4563 -> 4301;
4564 -> 4301;
4565 -> 4511;
4565 -> 4563;
4565 -> 4301;
4566 -> 0;
4566 -> 4301;
4567 -> 4554;
4567 -> 4566;
4567 -> 4301;
4568 -> 4511;
4568 -> 4567;
4568 -> 4301;
4569 -> 4301;
4570 -> 4554;
4570 -> 4301;
4571 -> 4570;
4571 -> 0;
4571 -> 4301;
4572 -> 4301;
4573 -> 4571;
4573 -> 4572;
4573 -> 4301;
4574 -> 4570;
4574 -> 4301;
4575 -> 4571;
4575 -> 0;
4575 -> 4301;
4576 -> 4575;
4576 -> 4301;
4577 -> 4576;
4578 -> 4301;
4578 -> 4577;
4579 -> 4577;
4580 -> 4578;
4580 -> 4579;
4581 -> 4580;
4581 -> 4475;
4581 -> 4579;
4582 -> 4581;
4582 -> 4577;
4583 -> 4577;
4584 -> 4582;
4584 -> 4583;
4585 -> 4583;
4585 -> 4577;
4586 -> 4577;
4587 -> 4578;
4587 -> 4586;
4588 -> 4587;
4588 -> 4475;
4588 -> 4586;
4589 -> 4588;
4589 -> 4577;
4590 -> 4577;
4591 -> 4589;
4591 -> 4590;
4592 -> 4590;
4593 -> 4591;
4593 -> 3190;
4593 -> 4502;
4593 -> 4592;
4594 -> 4593;
4594 -> 4502;
4594 -> 4592;
4595 -> 4577;
4596 -> 4594;
4596 -> 4595;
4597 -> 4595;
4598 -> 4596;
4598 -> 4597;
4599 -> 4598;
4599 -> 4595;
4600 -> 4596;
4600 -> 4595;
4601 -> 4585;
4601 -> 4599;
4601 -> 4577;
4602 -> 0;
4602 -> 4601;
4603 -> 4602;
4603 -> 4301;
4604 -> 4301;
4605 -> 4301;
4606 -> 4603;
4606 -> 4605;
4607 -> 4604;
4607 -> 4605;
4608 -> 4604;
4608 -> 4605;
4609 -> 4606;
4609 -> 4362;
4609 -> 4605;
4610 -> 4609;
4610 -> 4335;
4610 -> 4605;
4611 -> 4607;
4611 -> 4372;
4611 -> 4605;
4612 -> 4611;
4612 -> 4351;
4612 -> 4605;
4613 -> 4610;
4613 -> 4612;
4613 -> 4605;
4614 -> 4613;
4614 -> 4608;
4614 -> 4605;
4615 -> 4604;
4615 -> 4301;
4616 -> 4301;
4617 -> 4301;
4617 -> 4616;
4618 -> 4617;
4618 -> 4475;
4618 -> 4616;
4619 -> 4618;
4619 -> 4301;
4620 -> 4619;
4620 -> 4301;
4621 -> 4301;
4622 -> 0;
4622 -> 4301;
4623 -> 4301;
4624 -> 4622;
4624 -> 4623;
4625 -> 4301;
4626 -> 4301;
4627 -> 4301;
4628 -> 0;
4628 -> 4301;
4629 -> 4301;
4630 -> 4436;
4630 -> 4301;
4631 -> 4301;
4632 -> 4436;
4632 -> 4301;
4633 -> 4301;
4633 -> 4502;
4634 -> 4301;
4635 -> 4447;
4635 -> 4634;
4636 -> 4634;
4636 -> 4301;
4637 -> 4301;
4638 -> 4637;
4638 -> 4301;
4638 -> 4502;
4639 -> 4638;
4640 -> 4639;
4640 -> 4638;
4641 -> 4638;
4642 -> 0;
4642 -> 4638;
4643 -> 4642;
4644 -> 4643;
4644 -> 4642;
4645 -> 4642;
4646 -> 3197;
4647 -> 3197;
4648 -> 3197;
4649 -> 3197;
4650 -> 3197;
4651 -> 4646;
4651 -> 4650;
4652 -> 4650;
4653 -> 4651;
4653 -> 3190;
4653 -> 4502;
4653 -> 4652;
4654 -> 4653;
4654 -> 4502;
4654 -> 4652;
4655 -> 4654;
4655 -> 3197;
4656 -> 3197;
4657 -> 4655;
4657 -> 4656;
4658 -> 3197;
4659 -> 4648;
4659 -> 4642;
4660 -> 4642;
4661 -> 4642;
4662 -> 4642;
4663 -> 4661;
4663 -> 4662;
4663 -> 4642;
4664 -> 4663;
4664 -> 4642;
4665 -> 4664;
4666 -> 4661;
4666 -> 4665;
4667 -> 4666;
4667 -> 4642;
4667 -> 4665;
4668 -> 4667;
4668 -> 4648;
4668 -> 4659;
4668 -> 4642;
4669 -> 4648;
4669 -> 4659;
4669 -> 4667;
4669 -> 4642;
4670 -> 4642;
4671 -> 4669;
4671 -> 4670;
4671 -> 4642;
4672 -> 4649;
4672 -> 4670;
4672 -> 4642;
4673 -> 4671;
4673 -> 4672;
4673 -> 4642;
4674 -> 4642;
4675 -> 4669;
4675 -> 4674;
4675 -> 4642;
4676 -> 4642;
4676 -> 4667;
4676 -> 4648;
4677 -> 4642;
4678 -> 4661;
4678 -> 4677;
4678 -> 4642;
4679 -> 4678;
4680 -> 4661;
4680 -> 4679;
4681 -> 4680;
4681 -> 4642;
4681 -> 4679;
4682 -> 4679;
4683 -> 4681;
4683 -> 4682;
4684 -> 4683;
4684 -> 0;
4684 -> 4682;
4685 -> 0;
4685 -> 4684;
4686 -> 4685;
4686 -> 4678;
4687 -> 4686;
4687 -> 0;
4687 -> 4678;
4688 -> 4648;
4688 -> 4659;
4688 -> 4676;
4688 -> 4642;
4689 -> 4688;
4689 -> 4648;
4690 -> 4648;
4690 -> 4688;
4691 -> 4688;
4692 -> 4690;
4692 -> 4691;
4692 -> 4688;
4693 -> 4649;
4693 -> 4691;
4693 -> 4688;
4694 -> 4692;
4694 -> 4693;
4694 -> 4688;
4695 -> 4688;
4696 -> 4690;
4696 -> 4695;
4696 -> 4688;
4697 -> 4688;
4698 -> 4697;
4699 -> 4688;
4699 -> 4698;
4700 -> 4699;
4700 -> 4688;
4700 -> 4698;
4701 -> 4698;
4702 -> 4700;
4702 -> 4701;
4703 -> 4702;
4703 -> 0;
4703 -> 4701;
4704 -> 0;
4704 -> 4703;
4705 -> 4704;
4705 -> 4697;
4706 -> 4705;
4706 -> 0;
4706 -> 4697;
4707 -> 4688;
4708 -> 4688;
4708 -> 4707;
4709 -> 4707;
4709 -> 4688;
4710 -> 4688;
4711 -> 4688;
4712 -> 3197;
4712 -> 4711;
4713 -> 4711;
4714 -> 4712;
4714 -> 4713;
4715 -> 4713;
4716 -> 4714;
4716 -> 3190;
4716 -> 4688;
4716 -> 4715;
4717 -> 4716;
4717 -> 4688;
4717 -> 4715;
4718 -> 4717;
4718 -> 4711;
4719 -> 4711;
4720 -> 4718;
4720 -> 4719;
4721 -> 4719;
4722 -> 4720;
4722 -> 4721;
4723 -> 4722;
4723 -> 4719;
4724 -> 4720;
4724 -> 4719;
4725 -> 4723;
4725 -> 4711;
4726 -> 4688;
4727 -> 4688;
4728 -> 3200;
4728 -> 3190;
4729 -> 3190;
4730 -> 4728;
4730 -> 4729;
4730 -> 3190;
4731 -> 4728;
4731 -> 2986;
4732 -> 2909;
4733 -> 4731;
4733 -> 4732;
4733 -> 2909;
4734 -> 2911;
4734 -> 4733;
4735 -> 2910;
4735 -> 4733;
4736 -> 4733;
4737 -> 4733;
4738 -> 4734;
4738 -> 4737;
4739 -> 4735;
4739 -> 4737;
4740 -> 4736;
4740 -> 4737;
4741 -> 4736;
4741 -> 4737;
4742 -> 4738;
4742 -> 4737;
4743 -> 4739;
4743 -> 4737;
4744 -> 4737;
4745 -> 4740;
4745 -> 4737;
4746 -> 4737;
4747 -> 4742;
4747 -> 4746;
4748 -> 4743;
4748 -> 4746;
4749 -> 4744;
4749 -> 4746;
4750 -> 4745;
4750 -> 4746;
4751 -> 4741;
4751 -> 4746;
4752 -> 4747;
4752 -> 4746;
4753 -> 4748;
4753 -> 4746;
4754 -> 4746;
4755 -> 4748;
4755 -> 2896;
4755 -> 4754;
4755 -> 4746;
4756 -> 4755;
4756 -> 4746;
4757 -> 4750;
4757 -> 4746;
4758 -> 4749;
4758 -> 4746;
4759 -> 4746;
4760 -> 4752;
4760 -> 4759;
4761 -> 4753;
4761 -> 4759;
4762 -> 4756;
4762 -> 4759;
4763 -> 4757;
4763 -> 4759;
4764 -> 4758;
4764 -> 4759;
4765 -> 4751;
4765 -> 4759;
4766 -> 4760;
4766 -> 4759;
4767 -> 4761;
4767 -> 2896;
4767 -> 4759;
4768 -> 4762;
4768 -> 4759;
4769 -> 4761;
4769 -> 2896;
4769 -> 4768;
4770 -> 4762;
4770 -> 4759;
4771 -> 4761;
4771 -> 2896;
4771 -> 4770;
4772 -> 4762;
4772 -> 4759;
4773 -> 4759;
4774 -> 4763;
4774 -> 4759;
4775 -> 4759;
4776 -> 4764;
4776 -> 4759;
4777 -> 4759;
4778 -> 4759;
4779 -> 4766;
4779 -> 4778;
4780 -> 4767;
4780 -> 4778;
4781 -> 4769;
4781 -> 4778;
4782 -> 4771;
4782 -> 4778;
4783 -> 4772;
4783 -> 4778;
4784 -> 4773;
4784 -> 4778;
4785 -> 4774;
4785 -> 4778;
4786 -> 4775;
4786 -> 4778;
4787 -> 4776;
4787 -> 4778;
4788 -> 4777;
4788 -> 4778;
4789 -> 4765;
4789 -> 4778;
4790 -> 4781;
4790 -> 4778;
4791 -> 4782;
4791 -> 4778;
4792 -> 4783;
4792 -> 4778;
4793 -> 4788;
4793 -> 4778;
4794 -> 4778;
4795 -> 4790;
4795 -> 4794;
4796 -> 4791;
4796 -> 4794;
4797 -> 4792;
4797 -> 4794;
4798 -> 4793;
4798 -> 4794;
4799 -> 4789;
4799 -> 4794;
4800 -> 4798;
4800 -> 4794;
4801 -> 4794;
4802 -> 4800;
4802 -> 4801;
4803 -> 4799;
4803 -> 4801;
4804 -> 4802;
4804 -> 4801;
4805 -> 4801;
4806 -> 4804;
4806 -> 4805;
4807 -> 4803;
4807 -> 4805;
4808 -> 4805;
4809 -> 4807;
4809 -> 4808;
4810 -> 4808;
4811 -> 4809;
4811 -> 4808;
4812 -> 4809;
4812 -> 4808;
4813 -> 4807;
4813 -> 4805;
4814 -> 4807;
4814 -> 4805;
4815 -> 4807;
4815 -> 4805;
4816 -> 4806;
4816 -> 4807;
4816 -> 4805;
4817 -> 4799;
4817 -> 4794;
4818 -> 4799;
4818 -> 4794;
4819 -> 4799;
4819 -> 4794;
4820 -> 4794;
4821 -> 4795;
4821 -> 4820;
4821 -> 4794;
4822 -> 4795;
4822 -> 4799;
4822 -> 4794;
4823 -> 4796;
4823 -> 4799;
4823 -> 4794;
4824 -> 4794;
4825 -> 4796;
4825 -> 4824;
4825 -> 4794;
4826 -> 4797;
4826 -> 4825;
4826 -> 4794;
4827 -> 4826;
4827 -> 4799;
4827 -> 4794;
4828 -> 4789;
4828 -> 4778;
4829 -> 4789;
4829 -> 4778;
4830 -> 4789;
4830 -> 4778;
4831 -> 4789;
4831 -> 4778;
4832 -> 4789;
4832 -> 4778;
4833 -> 4789;
4833 -> 4778;
4834 -> 4778;
4835 -> 4779;
4835 -> 4834;
4835 -> 4778;
4836 -> 4778;
4837 -> 4780;
4837 -> 4836;
4837 -> 4778;
4838 -> 4778;
4839 -> 4787;
4839 -> 4838;
4839 -> 4778;
4840 -> 4780;
4840 -> 4789;
4840 -> 4778;
4841 -> 4779;
4841 -> 4789;
4841 -> 4778;
4842 -> 4784;
4842 -> 4789;
4842 -> 4778;
4843 -> 4785;
4843 -> 4789;
4843 -> 4778;
4844 -> 4786;
4844 -> 4789;
4844 -> 4778;
4845 -> 4787;
4845 -> 4789;
4845 -> 4778;
4846 -> 2909;
4847 -> 4736;
4847 -> 4846;
4847 -> 2909;
4848 -> 4736;
4848 -> 2909;
4849 -> 4848;
4849 -> 2900;
4850 -> 4849;
4851 -> 4850;
4851 -> 2905;
4851 -> 4849;
4852 -> 4850;
4852 -> 2905;
4852 -> 2900;
4853 -> 4852;
4853 -> 2900;
4854 -> 4852;
4854 -> 2886;
4854 -> 2900;
4855 -> 2900;
4856 -> 4848;
4856 -> 4855;
4856 -> 2900;
4857 -> 2886;
4857 -> 4852;
4857 -> 2900;
4858 -> 4848;
4858 -> 2900;
4859 -> 4858;
4859 -> 2870;
4860 -> 2870;
4861 -> 4859;
4861 -> 4860;
4862 -> 4860;
4863 -> 4861;
4863 -> 4862;
4864 -> 0;
4864 -> 4862;
4865 -> 4864;
4865 -> 4860;
4866 -> 4865;
4866 -> 4861;
4866 -> 4860;
4867 -> 4866;
4868 -> 4867;
4868 -> 2856;
4869 -> 2856;
4870 -> 4868;
4870 -> 4869;
4871 -> 2864;
4871 -> 4869;
4872 -> 4869;
4873 -> 4870;
4873 -> 4872;
4873 -> 4869;
4874 -> 4873;
4875 -> 2860;
4875 -> 4874;
4875 -> 2856;
4876 -> 4875;
4877 -> 2856;
4878 -> 4876;
4878 -> 4877;
4878 -> 2856;
4879 -> 4878;
4879 -> 2859;
4879 -> 2856;
4880 -> 2864;
4880 -> 2856;
4881 -> 2856;
4882 -> 2856;
4883 -> 2856;
4884 -> 2858;
4884 -> 4883;
4884 -> 2856;
4885 -> 4884;
4886 -> 2864;
4886 -> 4885;
4887 -> 4886;
4887 -> 4688;
4887 -> 4885;
4888 -> 4887;
4888 -> 4884;
4889 -> 4882;
4889 -> 4884;
4890 -> 4884;
4891 -> 4889;
4891 -> 4890;
4892 -> 4888;
4892 -> 4890;
4893 -> 4890;
4894 -> 4892;
4894 -> 4893;
4895 -> 4894;
4895 -> 4890;
4896 -> 4890;
4897 -> 4896;
4897 -> 4895;
4897 -> 4688;
4897 -> 4890;
4898 -> 4896;
4898 -> 4897;
4899 -> 4895;
4899 -> 4898;
4899 -> 4896;
4900 -> 4891;
4900 -> 4899;
4900 -> 4882;
4900 -> 4898;
4901 -> 4884;
4902 -> 4882;
4902 -> 2856;
4903 -> 4902;
4903 -> 4900;
4903 -> 2856;
4904 -> 4903;
4905 -> 4903;
4905 -> 4904;
4906 -> 4904;
4907 -> 4906;
4907 -> 4903;
4908 -> 4903;
4909 -> 4761;
4909 -> 4903;
4910 -> 2858;
4910 -> 4903;
4911 -> 4903;
4912 -> 4908;
4912 -> 4911;
4913 -> 4909;
4913 -> 4911;
4914 -> 4910;
4914 -> 4911;
4915 -> 4911;
4916 -> 4911;
4917 -> 4915;
4917 -> 4911;
4918 -> 4911;
4919 -> 4913;
4919 -> 2896;
4919 -> 4769;
4919 -> 4771;
4919 -> 4900;
4919 -> 4911;
4920 -> 4919;
4920 -> 4911;
4921 -> 4911;
4922 -> 4919;
4922 -> 4911;
4923 -> 4922;
4923 -> 4919;
4923 -> 4911;
4924 -> 4919;
4925 -> 4923;
4925 -> 4919;
4926 -> 4919;
4927 -> 4925;
4927 -> 4926;
4928 -> 4926;
4929 -> 4927;
4929 -> 4919;
4929 -> 4928;
4929 -> 4926;
4930 -> 4929;
4931 -> 4929;
4932 -> 4927;
4932 -> 4919;
4932 -> 4931;
4933 -> 4932;
4933 -> 4919;
4933 -> 4931;
4934 -> 4933;
4934 -> 4929;
4935 -> 0;
4935 -> 4929;
4936 -> 4934;
4936 -> 4929;
4937 -> 4929;
4938 -> 4936;
4938 -> 4937;
4939 -> 4927;
4939 -> 4937;
4940 -> 4937;
4941 -> 4938;
4941 -> 4940;
4941 -> 4937;
4942 -> 4937;
4943 -> 4937;
4944 -> 4937;
4945 -> 4939;
4945 -> 4944;
4946 -> 4944;
4947 -> 4946;
4947 -> 4937;
4948 -> 4947;
4948 -> 4937;
4949 -> 4947;
4949 -> 4937;
4950 -> 4949;
4951 -> 4938;
4951 -> 4937;
4952 -> 0;
4952 -> 4937;
4953 -> 4942;
4953 -> 4937;
4954 -> 4943;
4954 -> 4937;
4955 -> 4948;
4955 -> 4950;
4955 -> 4951;
4955 -> 4952;
4955 -> 4953;
4955 -> 4954;
4955 -> 4934;
4955 -> 4937;
4956 -> 4955;
4956 -> 4937;
4957 -> 4937;
4958 -> 4956;
4958 -> 4957;
4959 -> 4939;
4959 -> 4957;
4960 -> 4957;
4961 -> 4959;
4961 -> 4955;
4961 -> 4960;
4961 -> 4957;
4962 -> 0;
4962 -> 4961;
4963 -> 4958;
4963 -> 4961;
4964 -> 4963;
4964 -> 4955;
4965 -> 4959;
4965 -> 4963;
4966 -> 4963;
4967 -> 4963;
4968 -> 4964;
4968 -> 4967;
4969 -> 4965;
4969 -> 4967;
4970 -> 4964;
4970 -> 4967;
4971 -> 4966;
4971 -> 4967;
4972 -> 4967;
4973 -> 4971;
4973 -> 4967;
4974 -> 4971;
4974 -> 4967;
4975 -> 4971;
4975 -> 4967;
4976 -> 4967;
4977 -> 4968;
4977 -> 4976;
4977 -> 4967;
4978 -> 4967;
4979 -> 4969;
4979 -> 4978;
4979 -> 4967;
4980 -> 4967;
4981 -> 4970;
4981 -> 4980;
4981 -> 4967;
4982 -> 4969;
4982 -> 4971;
4982 -> 4967;
4983 -> 4968;
4983 -> 4971;
4983 -> 4967;
4984 -> 4970;
4984 -> 4971;
4984 -> 4967;
4985 -> 4963;
4986 -> 4966;
4986 -> 4985;
4987 -> 4986;
4987 -> 4983;
4987 -> 4985;
4988 -> 4987;
4988 -> 4963;
4989 -> 4966;
4989 -> 4963;
4990 -> 4962;
4990 -> 4988;
4990 -> 4989;
4990 -> 4963;
4991 -> 4959;
4991 -> 4955;
4991 -> 4961;
4992 -> 4962;
4992 -> 4961;
4993 -> 4961;
4994 -> 4991;
4994 -> 4992;
4994 -> 4993;
4994 -> 4962;
4994 -> 4955;
4994 -> 4990;
4994 -> 4971;
4994 -> 4982;
4994 -> 4983;
4994 -> 4984;
4994 -> 4961;
4995 -> 4937;
4996 -> 4955;
4996 -> 4937;
4997 -> 4937;
4998 -> 4996;
4998 -> 4997;
4999 -> 4939;
4999 -> 4997;
5000 -> 4997;
5001 -> 4999;
5001 -> 4994;
5001 -> 5000;
5001 -> 4997;
5002 -> 5001;
5003 -> 4999;
5003 -> 5002;
5004 -> 5003;
5004 -> 4994;
5004 -> 5002;
5005 -> 5004;
5005 -> 5001;
5006 -> 5001;
5007 -> 5001;
5008 -> 5005;
5008 -> 5007;
5009 -> 5008;
5009 -> 5001;
5010 -> 5001;
5011 -> 4998;
5011 -> 5001;
5012 -> 5011;
5012 -> 5009;
5012 -> 5001;
5013 -> 5012;
5014 -> 5009;
5014 -> 5013;
5015 -> 5005;
5015 -> 5014;
5016 -> 4999;
5016 -> 5014;
5017 -> 5013;
5017 -> 5014;
5018 -> 0;
5019 -> 5018;
5020 -> 5019;
5022 -> 5021;
5023 -> 5022;
5023 -> 5021;
5024 -> 0;
5024 -> 5022;
5024 -> 5021;
5025 -> 0;
5025 -> 5022;
5025 -> 5021;
5026 -> 5022;
5026 -> 5021;
5027 -> 5022;
5027 -> 5021;
5028 -> 5022;
5028 -> 5021;
5029 -> 5022;
5029 -> 5021;
5030 -> 4436;
5030 -> 5022;
5030 -> 5021;
5031 -> 0;
5031 -> 5022;
5031 -> 5021;
5032 -> 5021;
5033 -> 5012;
5033 -> 5009;
5033 -> 5014;
5034 -> 5014;
5035 -> 5015;
5035 -> 5034;
5036 -> 5016;
5036 -> 5034;
5037 -> 5017;
5037 -> 5034;
5038 -> 5033;
5038 -> 5034;
5039 -> 5034;
5040 -> 5039;
5040 -> 5034;
5041 -> 5034;
5042 -> 5034;
5043 -> 5035;
5043 -> 5034;
5044 -> 5037;
5044 -> 5034;
5045 -> 5039;
5045 -> 5034;
5046 -> 5041;
5046 -> 5034;
5047 -> 5042;
5047 -> 5034;
5048 -> 5034;
5049 -> 5043;
5049 -> 5048;
5050 -> 5044;
5050 -> 5048;
5051 -> 5045;
5051 -> 5048;
5052 -> 5046;
5052 -> 5048;
5053 -> 5047;
5053 -> 5048;
5054 -> 5048;
5055 -> 5049;
5055 -> 5054;
5056 -> 5055;
5056 -> 5048;
5057 -> 5050;
5057 -> 5048;
5058 -> 5056;
5058 -> 5057;
5058 -> 5009;
5058 -> 5048;
5059 -> 5058;
5059 -> 5048;
5060 -> 5048;
5061 -> 5034;
5062 -> 5034;
5063 -> 5034;
5064 -> 5034;
5065 -> 5059;
5065 -> 5064;
5065 -> 5034;
5066 -> 5035;
5066 -> 5065;
5067 -> 5036;
5067 -> 5065;
5068 -> 5037;
5068 -> 5065;
5069 -> 5038;
5069 -> 5065;
5070 -> 5062;
5070 -> 5065;
5071 -> 5065;
5072 -> 5065;
5073 -> 5066;
5073 -> 5072;
5074 -> 5067;
5074 -> 5072;
5075 -> 5068;
5075 -> 5072;
5076 -> 5069;
5076 -> 5072;
5077 -> 5070;
5077 -> 5072;
5078 -> 5071;
5078 -> 5072;
5079 -> 5073;
5079 -> 5072;
5080 -> 5074;
5080 -> 5072;
5081 -> 5075;
5081 -> 5072;
5082 -> 5076;
5082 -> 5072;
5083 -> 5072;
5084 -> 5077;
5084 -> 5072;
5085 -> 5072;
5086 -> 5079;
5086 -> 5085;
5087 -> 5080;
5087 -> 5085;
5088 -> 5081;
5088 -> 5085;
5089 -> 5082;
5089 -> 5085;
5090 -> 5083;
5090 -> 5085;
5091 -> 5084;
5091 -> 5085;
5092 -> 5078;
5092 -> 5085;
5093 -> 5085;
5094 -> 5092;
5094 -> 5093;
5095 -> 5093;
5096 -> 5093;
5097 -> 5094;
5097 -> 5096;
5098 -> 5096;
5099 -> 5097;
5099 -> 5096;
5100 -> 5097;
5100 -> 5096;
5101 -> 5094;
5101 -> 5093;
5102 -> 5094;
5102 -> 5093;
5103 -> 5094;
5103 -> 5093;
5104 -> 5095;
5104 -> 5094;
5104 -> 5093;
5105 -> 5092;
5105 -> 5085;
5106 -> 5092;
5106 -> 5085;
5107 -> 5092;
5107 -> 5085;
5108 -> 5092;
5108 -> 5085;
5109 -> 5092;
5109 -> 5085;
5110 -> 5092;
5110 -> 5085;
5111 -> 5092;
5111 -> 5085;
5112 -> 5092;
5112 -> 5085;
5113 -> 5092;
5113 -> 5085;
5114 -> 4436;
5114 -> 5092;
5114 -> 5085;
5115 -> 5085;
5116 -> 5115;
5116 -> 5092;
5116 -> 5085;
5117 -> 4436;
5117 -> 5092;
5117 -> 5085;
5118 -> 5085;
5119 -> 5118;
5119 -> 5092;
5119 -> 5085;
5120 -> 5092;
5120 -> 5085;
5121 -> 0;
5121 -> 5092;
5121 -> 5085;
5122 -> 5092;
5122 -> 5085;
5123 -> 5092;
5123 -> 5085;
5124 -> 5088;
5124 -> 5009;
5124 -> 5085;
5125 -> 5085;
5126 -> 5087;
5126 -> 5125;
5126 -> 5085;
5127 -> 5085;
5128 -> 5090;
5128 -> 5127;
5128 -> 5085;
5129 -> 5085;
5130 -> 5085;
5131 -> 5085;
5132 -> 5086;
5132 -> 5131;
5133 -> 5132;
5133 -> 5085;
5134 -> 5088;
5134 -> 5085;
5135 -> 5133;
5135 -> 5134;
5135 -> 5058;
5135 -> 5009;
5135 -> 5085;
5136 -> 5088;
5136 -> 5092;
5136 -> 5085;
5137 -> 5087;
5137 -> 5092;
5137 -> 5085;
5138 -> 5085;
5139 -> 5086;
5139 -> 5138;
5140 -> 5139;
5140 -> 5135;
5140 -> 5138;
5141 -> 5140;
5141 -> 5085;
5142 -> 5088;
5142 -> 5085;
5143 -> 5141;
5143 -> 5092;
5143 -> 5085;
5144 -> 5085;
5145 -> 5090;
5145 -> 5144;
5145 -> 5085;
5146 -> 5135;
5146 -> 5092;
5146 -> 5145;
5147 -> 5145;
5148 -> 5085;
5149 -> 5089;
5149 -> 5148;
5149 -> 5085;
5150 -> 5085;
5151 -> 5086;
5151 -> 5150;
5152 -> 5151;
5152 -> 5141;
5152 -> 5150;
5153 -> 5152;
5153 -> 5085;
5154 -> 5085;
5155 -> 5153;
5155 -> 5154;
5156 -> 5154;
5157 -> 5155;
5157 -> 5156;
5158 -> 5157;
5158 -> 5154;
5159 -> 5155;
5159 -> 5154;
5160 -> 5155;
5160 -> 5141;
5160 -> 0;
5160 -> 5154;
5161 -> 5149;
5161 -> 5158;
5161 -> 5085;
5162 -> 5085;
5163 -> 5092;
5163 -> 5162;
5164 -> 0;
5164 -> 5162;
5165 -> 5163;
5165 -> 5143;
5165 -> 0;
5165 -> 5162;
5166 -> 0;
5166 -> 5165;
5167 -> 5166;
5167 -> 5162;
5168 -> 5167;
5168 -> 5085;
5169 -> 5161;
5169 -> 5168;
5169 -> 5085;
5170 -> 0;
5170 -> 5092;
5170 -> 5169;
5171 -> 5130;
5171 -> 5085;
5172 -> 5034;
5173 -> 5060;
5173 -> 5172;
5173 -> 5034;
5174 -> 5071;
5174 -> 5034;
5175 -> 5006;
5175 -> 5174;
5175 -> 5097;
5175 -> 5099;
5175 -> 5100;
5175 -> 5101;
5175 -> 5102;
5175 -> 5104;
5175 -> 5137;
5175 -> 5146;
5175 -> 5143;
5175 -> 5170;
5175 -> 5109;
5175 -> 5110;
5175 -> 5111;
5175 -> 5112;
5175 -> 5113;
5175 -> 5114;
5175 -> 5116;
5175 -> 5117;
5175 -> 5119;
5175 -> 5120;
5175 -> 5121;
5175 -> 5122;
5175 -> 5123;
5175 -> 5136;
5175 -> 4427;
5175 -> 4428;
5175 -> 4429;
5175 -> 4430;
5175 -> 4431;
5175 -> 4433;
5175 -> 4435;
5175 -> 5115;
5175 -> 5118;
5175 -> 0;
5175 -> 5009;
5175 -> 5141;
5175 -> 5014;
5176 -> 5001;
5177 -> 0;
5177 -> 5001;
5178 -> 5176;
5178 -> 5177;
5178 -> 5006;
5178 -> 5175;
5178 -> 5001;
5179 -> 5178;
5179 -> 5176;
5180 -> 5179;
5180 -> 5178;
5180 -> 5176;
5181 -> 5006;
5181 -> 5180;
5181 -> 5001;
5182 -> 5001;
5183 -> 5010;
5183 -> 5182;
5183 -> 5001;
5184 -> 4999;
5184 -> 5181;
5184 -> 5001;
5185 -> 5180;
5185 -> 5001;
5186 -> 5001;
5187 -> 5001;
5188 -> 5184;
5188 -> 5187;
5188 -> 5001;
5189 -> 5180;
5189 -> 5188;
5190 -> 5188;
5191 -> 5189;
5191 -> 5190;
5192 -> 5005;
5192 -> 5190;
5193 -> 5190;
5194 -> 5192;
5194 -> 5184;
5194 -> 5193;
5194 -> 5190;
5195 -> 5190;
5196 -> 5192;
5196 -> 5184;
5196 -> 5195;
5197 -> 5196;
5197 -> 5190;
5198 -> 5191;
5198 -> 5184;
5198 -> 5190;
5199 -> 5198;
5200 -> 5199;
5201 -> 5199;
5202 -> 5199;
5202 -> 5201;
5203 -> 5202;
5203 -> 5184;
5203 -> 5201;
5204 -> 5203;
5204 -> 5199;
5205 -> 5199;
5206 -> 5192;
5206 -> 5184;
5206 -> 5204;
5206 -> 5205;
5206 -> 5199;
5207 -> 5206;
5207 -> 5199;
5208 -> 5199;
5209 -> 5199;
5209 -> 5208;
5210 -> 5209;
5210 -> 5206;
5210 -> 5208;
5211 -> 5210;
5211 -> 5199;
5212 -> 5197;
5212 -> 5211;
5212 -> 5199;
5213 -> 5188;
5214 -> 4937;
5215 -> 4929;
5216 -> 4919;
5217 -> 4919;
5218 -> 4919;
5219 -> 5218;
5219 -> 4919;
5220 -> 4924;
5220 -> 4919;
5221 -> 5217;
5221 -> 4919;
5222 -> 4925;
5222 -> 5206;
5222 -> 5220;
5222 -> 5221;
5222 -> 4919;
5223 -> 4924;
5223 -> 5222;
5224 -> 5218;
5224 -> 5222;
5225 -> 4925;
5225 -> 5222;
5225 -> 5223;
5225 -> 5224;
5225 -> 5219;
5226 -> 5222;
5226 -> 5225;
5227 -> 5226;
5228 -> 4919;
5229 -> 5226;
5229 -> 5228;
5229 -> 4919;
5230 -> 5226;
5230 -> 5225;
5231 -> 5230;
5231 -> 5226;
5231 -> 5225;
5232 -> 5225;
5233 -> 5230;
5233 -> 5226;
5233 -> 5225;
5233 -> 5232;
5234 -> 5233;
5235 -> 5231;
5235 -> 5234;
5235 -> 5233;
5236 -> 5231;
5236 -> 5233;
5237 -> 5233;
5238 -> 5236;
5238 -> 5237;
5239 -> 5237;
5240 -> 5238;
5240 -> 5239;
5240 -> 5237;
5241 -> 5237;
5242 -> 5237;
5243 -> 5242;
5244 -> 5237;
5244 -> 5243;
5245 -> 5243;
5246 -> 5244;
5246 -> 5245;
5247 -> 5246;
5247 -> 5243;
5248 -> 5243;
5249 -> 5244;
5249 -> 5248;
5250 -> 5248;
5251 -> 5249;
5251 -> 5250;
5252 -> 5251;
5252 -> 5226;
5252 -> 5225;
5252 -> 5250;
5253 -> 5252;
5253 -> 5248;
5254 -> 5248;
5255 -> 5253;
5256 -> 5253;
5257 -> 5255;
5257 -> 5256;
5257 -> 5253;
5258 -> 5255;
5258 -> 5257;
5259 -> 5258;
5259 -> 5243;
5260 -> 5243;
5261 -> 5259;
5261 -> 5260;
5262 -> 5260;
5262 -> 5243;
5263 -> 5243;
5264 -> 5247;
5264 -> 5243;
5265 -> 5242;
5265 -> 5264;
5265 -> 5238;
5265 -> 5237;
5265 -> 5226;
5265 -> 5225;
5266 -> 5265;
5267 -> 5265;
5268 -> 5265;
5269 -> 5265;
5270 -> 5265;
5271 -> 5265;
5272 -> 5237;
5272 -> 5265;
5273 -> 5265;
5274 -> 5272;
5274 -> 5265;
5274 -> 5273;
5275 -> 5274;
5275 -> 5265;
5276 -> 5265;
5277 -> 5275;
5278 -> 5277;
5278 -> 5275;
5279 -> 5275;
5280 -> 5275;
5281 -> 5277;
5281 -> 5275;
5282 -> 5279;
5282 -> 5275;
5283 -> 5280;
5283 -> 5275;
5284 -> 5275;
5285 -> 5275;
5286 -> 5275;
5287 -> 5285;
5287 -> 5275;
5288 -> 5287;
5288 -> 5275;
5289 -> 5288;
5289 -> 5285;
5290 -> 5285;
5291 -> 5285;
5292 -> 5285;
5293 -> 5285;
5294 -> 5285;
5295 -> 5285;
5295 -> 5275;
5296 -> 5285;
5297 -> 5285;
5298 -> 5285;
5299 -> 5285;
5300 -> 5285;
5301 -> 0;
5301 -> 5285;
5302 -> 0;
5302 -> 5285;
5303 -> 5285;
5303 -> 5302;
5304 -> 5303;
5304 -> 5285;
5304 -> 5302;
5305 -> 5299;
5305 -> 5285;
5306 -> 5275;
5307 -> 5284;
5307 -> 5306;
5307 -> 5275;
5308 -> 5304;
5309 -> 5308;
5309 -> 5304;
5310 -> 5304;
5311 -> 5304;
5312 -> 5308;
5312 -> 5304;
5313 -> 5310;
5313 -> 5304;
5314 -> 5311;
5314 -> 5304;
5315 -> 5304;
5316 -> 5304;
5317 -> 5304;
5318 -> 5317;
5318 -> 5304;
5319 -> 5318;
5319 -> 5304;
5320 -> 5304;
5321 -> 5304;
5322 -> 5304;
5323 -> 5304;
5324 -> 5304;
5325 -> 5304;
5326 -> 5304;
5327 -> 5304;
5328 -> 5304;
5329 -> 5304;
5330 -> 5304;
5331 -> 0;
5331 -> 5304;
5332 -> 5329;
5332 -> 5304;
5333 -> 5304;
5334 -> 5315;
5334 -> 5333;
5334 -> 5304;
5335 -> 5304;
5335 -> 5308;
5336 -> 5308;
5337 -> 5308;
5338 -> 5335;
5338 -> 5337;
5339 -> 5335;
5339 -> 5337;
5340 -> 5335;
5340 -> 5337;
5341 -> 5335;
5341 -> 5337;
5342 -> 5336;
5342 -> 5337;
5343 -> 5336;
5343 -> 5337;
5344 -> 5335;
5344 -> 5337;
5345 -> 5336;
5345 -> 5337;
5346 -> 5338;
5346 -> 5337;
5347 -> 5339;
5347 -> 5337;
5348 -> 5340;
5348 -> 5337;
5349 -> 5341;
5349 -> 5337;
5350 -> 5343;
5350 -> 5337;
5351 -> 5344;
5351 -> 5337;
5352 -> 5337;
5353 -> 5346;
5353 -> 5352;
5354 -> 5347;
5354 -> 5352;
5355 -> 5348;
5355 -> 5352;
5356 -> 5349;
5356 -> 5352;
5357 -> 5350;
5357 -> 5352;
5358 -> 5351;
5358 -> 5352;
5359 -> 5345;
5359 -> 5352;
5360 -> 5345;
5360 -> 5352;
5361 -> 5345;
5361 -> 5352;
5362 -> 5345;
5362 -> 5352;
5363 -> 5345;
5363 -> 5352;
5364 -> 5355;
5364 -> 5304;
5364 -> 5352;
5365 -> 5352;
5366 -> 5354;
5366 -> 5365;
5366 -> 5352;
5367 -> 5352;
5368 -> 5357;
5368 -> 5367;
5368 -> 5352;
5369 -> 5352;
5370 -> 5352;
5371 -> 5353;
5371 -> 5355;
5371 -> 5308;
5371 -> 5304;
5371 -> 5352;
5372 -> 5371;
5372 -> 5357;
5373 -> 5357;
5374 -> 5372;
5374 -> 5345;
5374 -> 5357;
5375 -> 5345;
5375 -> 5374;
5375 -> 5357;
5376 -> 5371;
5376 -> 5357;
5377 -> 5345;
5377 -> 5374;
5377 -> 5371;
5377 -> 5357;
5378 -> 5345;
5378 -> 5374;
5378 -> 5357;
5379 -> 5371;
5379 -> 5357;
5380 -> 5356;
5380 -> 5371;
5380 -> 5352;
5381 -> 0;
5381 -> 5352;
5382 -> 5370;
5382 -> 5352;
5383 -> 5345;
5383 -> 5337;
5384 -> 5345;
5384 -> 5337;
5385 -> 5337;
5386 -> 5342;
5386 -> 5308;
5386 -> 5385;
5386 -> 5337;
5387 -> 5343;
5387 -> 5345;
5387 -> 5337;
5388 -> 5342;
5388 -> 5345;
5388 -> 5337;
5389 -> 5378;
5389 -> 5345;
5389 -> 5337;
5390 -> 5265;
5390 -> 5336;
5390 -> 5371;
5390 -> 5345;
5390 -> 5354;
5390 -> 5374;
5390 -> 5380;
5390 -> 5355;
5390 -> 5387;
5390 -> 5389;
5390 -> 5388;
5390 -> 5352;
5390 -> 5304;
5390 -> 5308;
5391 -> 5390;
5392 -> 5390;
5393 -> 5390;
5394 -> 5390;
5395 -> 5392;
5395 -> 5390;
5396 -> 5393;
5396 -> 5390;
5397 -> 5390;
5398 -> 5390;
5399 -> 5390;
5400 -> 5399;
5400 -> 5390;
5401 -> 5400;
5401 -> 5390;
5402 -> 5390;
5403 -> 5390;
5404 -> 5390;
5405 -> 5390;
5406 -> 5390;
5407 -> 5390;
5408 -> 5390;
5409 -> 5390;
5410 -> 5390;
5411 -> 5390;
5412 -> 5390;
5413 -> 0;
5413 -> 5390;
5414 -> 5411;
5414 -> 5390;
5415 -> 5390;
5416 -> 5390;
5417 -> 5390;
5418 -> 5390;
5419 -> 5397;
5419 -> 5418;
5419 -> 5390;
5420 -> 5392;
5420 -> 5390;
5421 -> 5392;
5422 -> 5421;
5422 -> 5392;
5423 -> 5422;
5423 -> 5392;
5424 -> 5392;
5425 -> 5392;
5426 -> 5392;
5427 -> 5392;
5428 -> 5392;
5429 -> 5392;
5429 -> 5390;
5430 -> 5392;
5431 -> 5392;
5432 -> 5392;
5433 -> 5392;
5434 -> 5392;
5435 -> 0;
5435 -> 5392;
5436 -> 5433;
5436 -> 5392;
5437 -> 5392;
5438 -> 5392;
5439 -> 5392;
5440 -> 5392;
5441 -> 5392;
5442 -> 5392;
5443 -> 5392;
5444 -> 5441;
5444 -> 5392;
5445 -> 5392;
5446 -> 5392;
5447 -> 5392;
5448 -> 5392;
5449 -> 5445;
5449 -> 5448;
5449 -> 5392;
5450 -> 5441;
5450 -> 5392;
5451 -> 5441;
5451 -> 5392;
5452 -> 5441;
5453 -> 5452;
5453 -> 5441;
5454 -> 5453;
5454 -> 5441;
5455 -> 5441;
5456 -> 5441;
5457 -> 5441;
5458 -> 5441;
5459 -> 5441;
5460 -> 5441;
5460 -> 5392;
5461 -> 5441;
5462 -> 5441;
5463 -> 5441;
5464 -> 5441;
5465 -> 5441;
5466 -> 0;
5466 -> 5441;
5467 -> 5464;
5467 -> 5441;
5468 -> 5441;
5469 -> 5441;
5470 -> 5441;
5471 -> 5441;
5472 -> 5441;
5473 -> 5441;
5474 -> 5441;
5475 -> 5441;
5476 -> 5441;
5477 -> 5441;
5478 -> 5441;
5479 -> 5475;
5479 -> 5478;
5479 -> 5441;
5480 -> 5441;
5481 -> 5480;
5481 -> 5441;
5482 -> 5481;
5482 -> 5441;
5483 -> 5441;
5484 -> 5265;
5485 -> 5276;
5485 -> 5484;
5485 -> 5265;
5486 -> 5441;
5487 -> 5441;
5488 -> 5487;
5488 -> 5441;
5489 -> 5441;
5490 -> 5441;
5491 -> 5441;
5492 -> 5441;
5492 -> 5491;
5493 -> 5492;
5493 -> 5441;
5493 -> 5491;
5494 -> 5493;
5494 -> 5441;
5495 -> 5488;
5495 -> 5494;
5495 -> 5441;
5496 -> 5441;
5496 -> 5495;
5497 -> 5495;
5498 -> 5496;
5498 -> 5497;
5499 -> 5441;
5499 -> 5497;
5500 -> 5497;
5501 -> 5498;
5501 -> 5500;
5502 -> 5501;
5502 -> 5497;
5503 -> 5502;
5503 -> 0;
5503 -> 5497;
5504 -> 5497;
5505 -> 5498;
5505 -> 5504;
5506 -> 5504;
5507 -> 5505;
5507 -> 5506;
5508 -> 5507;
5508 -> 5441;
5508 -> 5506;
5509 -> 5508;
5509 -> 5504;
5510 -> 5504;
5511 -> 5509;
5511 -> 5510;
5511 -> 5504;
5512 -> 5511;
5512 -> 5504;
5513 -> 5512;
5514 -> 5509;
5514 -> 5513;
5515 -> 5513;
5516 -> 5514;
5516 -> 5515;
5517 -> 5516;
5517 -> 5513;
5518 -> 5513;
5519 -> 5517;
5519 -> 5518;
5520 -> 5519;
5520 -> 5497;
5521 -> 5499;
5521 -> 5497;
5522 -> 5520;
5522 -> 5521;
5522 -> 5497;
5523 -> 5497;
5524 -> 5498;
5524 -> 5523;
5525 -> 5523;
5526 -> 5524;
5526 -> 5525;
5527 -> 5526;
5527 -> 5441;
5527 -> 5525;
5528 -> 5525;
5529 -> 5527;
5529 -> 5528;
5530 -> 5528;
5530 -> 5525;
5531 -> 5525;
5532 -> 5527;
5532 -> 5531;
5533 -> 5532;
5533 -> 5525;
5534 -> 5533;
5534 -> 5523;
5535 -> 5534;
5535 -> 5497;
5536 -> 5497;
5537 -> 5535;
5537 -> 5536;
5538 -> 5537;
5538 -> 5441;
5538 -> 5536;
5539 -> 5497;
5540 -> 5497;
5541 -> 5499;
5541 -> 5540;
5542 -> 5541;
5542 -> 5497;
5543 -> 5499;
5543 -> 5497;
5544 -> 5497;
5545 -> 5499;
5545 -> 5441;
5545 -> 5544;
5545 -> 5497;
5546 -> 5499;
5546 -> 5441;
5546 -> 5545;
5547 -> 5545;
5548 -> 5499;
5548 -> 5546;
5548 -> 5502;
5548 -> 5497;
5549 -> 5498;
5549 -> 5497;
5550 -> 5497;
5551 -> 5499;
5551 -> 5548;
5552 -> 5548;
5553 -> 5499;
5553 -> 5548;
5553 -> 5551;
5553 -> 5552;
5554 -> 5499;
5554 -> 5548;
5554 -> 5551;
5554 -> 0;
5555 -> 5495;
5556 -> 5495;
5557 -> 5441;
5557 -> 5548;
5557 -> 5556;
5558 -> 5557;
5558 -> 5548;
5558 -> 5551;
5558 -> 0;
5558 -> 5556;
5559 -> 5558;
5559 -> 5495;
5560 -> 5551;
5561 -> 5551;
5562 -> 5559;
5562 -> 0;
5563 -> 5559;
5564 -> 5559;
5564 -> 5563;
5565 -> 5563;
5566 -> 5564;
5566 -> 5565;
5567 -> 5566;
5567 -> 5551;
5567 -> 5565;
5568 -> 5567;
5568 -> 5563;
5569 -> 5563;
5570 -> 5568;
5570 -> 5569;
5570 -> 5563;
5571 -> 5570;
5571 -> 5563;
5572 -> 5571;
5573 -> 5568;
5573 -> 5572;
5574 -> 5572;
5575 -> 5573;
5575 -> 5574;
5576 -> 5575;
5576 -> 5572;
5577 -> 5572;
5578 -> 5576;
5578 -> 5577;
5579 -> 5578;
5579 -> 5559;
5580 -> 5559;
5581 -> 5559;
5582 -> 5559;
5582 -> 5581;
5583 -> 5581;
5584 -> 5582;
5584 -> 5583;
5585 -> 5584;
5585 -> 5551;
5585 -> 5583;
5586 -> 5583;
5587 -> 5585;
5587 -> 5586;
5588 -> 5586;
5588 -> 5583;
5589 -> 5583;
5590 -> 5585;
5590 -> 5589;
5591 -> 5590;
5591 -> 5583;
5592 -> 5591;
5592 -> 5581;
5593 -> 5592;
5593 -> 5559;
5594 -> 5559;
5595 -> 5593;
5595 -> 5594;
5596 -> 5595;
5596 -> 5551;
5596 -> 5594;
5597 -> 5559;
5598 -> 5559;
5599 -> 5598;
5599 -> 5559;
5600 -> 5559;
5601 -> 5559;
5602 -> 5559;
5602 -> 0;
5603 -> 5559;
5604 -> 5559;
5605 -> 5598;
5605 -> 0;
5606 -> 5598;
5607 -> 5598;
5607 -> 5606;
5608 -> 5606;
5609 -> 5607;
5609 -> 5608;
5610 -> 5609;
5610 -> 5559;
5610 -> 5608;
5611 -> 5610;
5611 -> 5606;
5612 -> 5606;
5613 -> 5611;
5613 -> 5612;
5613 -> 5606;
5614 -> 5613;
5614 -> 5606;
5615 -> 5614;
5616 -> 5611;
5616 -> 5615;
5617 -> 5615;
5618 -> 5616;
5618 -> 5617;
5619 -> 5618;
5619 -> 5615;
5620 -> 5615;
5621 -> 5619;
5621 -> 5620;
5622 -> 5621;
5622 -> 5598;
5623 -> 5598;
5624 -> 5598;
5625 -> 5598;
5625 -> 5624;
5626 -> 5624;
5627 -> 5625;
5627 -> 5626;
5628 -> 5627;
5628 -> 5559;
5628 -> 5626;
5629 -> 5626;
5630 -> 5628;
5630 -> 5629;
5631 -> 5629;
5631 -> 5626;
5632 -> 5626;
5633 -> 5628;
5633 -> 5632;
5634 -> 5633;
5634 -> 5626;
5635 -> 5634;
5635 -> 5624;
5636 -> 5635;
5636 -> 5598;
5637 -> 5598;
5638 -> 5636;
5638 -> 5637;
5639 -> 5638;
5639 -> 5559;
5639 -> 5637;
5640 -> 5598;
5641 -> 5598;
5642 -> 5598;
5643 -> 5598;
5643 -> 0;
5644 -> 5598;
5645 -> 5598;
5646 -> 5609;
5646 -> 5598;
5646 -> 5608;
5647 -> 5646;
5647 -> 5606;
5648 -> 5647;
5648 -> 5612;
5648 -> 5606;
5649 -> 5648;
5649 -> 5606;
5650 -> 5649;
5651 -> 5647;
5651 -> 5650;
5652 -> 5650;
5653 -> 5651;
5653 -> 5652;
5654 -> 5653;
5654 -> 5650;
5655 -> 5650;
5656 -> 5654;
5656 -> 5655;
5657 -> 5656;
5657 -> 5598;
5658 -> 5627;
5658 -> 5598;
5658 -> 5626;
5659 -> 5658;
5659 -> 5629;
5660 -> 5658;
5660 -> 5632;
5661 -> 5660;
5661 -> 5626;
5662 -> 5661;
5662 -> 5624;
5663 -> 5662;
5663 -> 5598;
5664 -> 5663;
5664 -> 5637;
5665 -> 5664;
5665 -> 5598;
5665 -> 5637;
5666 -> 5233;
5667 -> 5230;
5667 -> 5598;
5667 -> 5233;
5668 -> 5233;
5669 -> 5225;
5670 -> 5667;
5671 -> 5225;
5672 -> 5667;
5672 -> 5671;
5672 -> 5225;
5673 -> 5667;
5674 -> 5667;
5675 -> 5667;
5676 -> 5667;
5677 -> 5667;
5677 -> 5676;
5678 -> 5676;
5679 -> 5677;
5679 -> 5678;
5680 -> 5679;
5680 -> 5667;
5680 -> 5678;
5681 -> 5680;
5681 -> 5676;
5682 -> 5676;
5683 -> 5681;
5684 -> 5681;
5685 -> 5683;
5685 -> 5684;
5685 -> 5681;
5686 -> 5683;
5686 -> 5685;
5687 -> 5686;
5687 -> 5667;
5688 -> 5667;
5689 -> 5687;
5689 -> 5688;
5690 -> 5688;
5690 -> 5667;
5691 -> 5667;
5692 -> 5690;
5693 -> 5687;
5693 -> 5692;
5694 -> 5693;
5694 -> 5690;
5695 -> 5690;
5696 -> 5690;
5697 -> 5687;
5697 -> 5696;
5698 -> 5696;
5699 -> 5696;
5700 -> 5697;
5700 -> 5690;
5701 -> 5700;
5701 -> 5688;
5702 -> 5694;
5703 -> 5694;
5704 -> 5694;
5705 -> 5694;
5706 -> 5694;
5707 -> 5694;
5708 -> 5694;
5709 -> 5694;
5710 -> 5694;
5711 -> 5694;
5712 -> 5694;
5713 -> 5694;
5714 -> 5694;
5715 -> 5694;
5716 -> 5715;
5716 -> 5694;
5717 -> 5716;
5717 -> 5694;
5718 -> 5694;
5719 -> 5694;
5720 -> 5694;
5721 -> 5694;
5722 -> 5694;
5723 -> 5694;
5724 -> 5694;
5725 -> 5694;
5726 -> 5694;
5727 -> 5694;
5728 -> 5694;
5729 -> 0;
5729 -> 5694;
5730 -> 5727;
5730 -> 5694;
5731 -> 5694;
5732 -> 5713;
5732 -> 5731;
5732 -> 5694;
5733 -> 5694;
5734 -> 5708;
5734 -> 5733;
5734 -> 5694;
5735 -> 5694;
5736 -> 5694;
5737 -> 5667;
5738 -> 5694;
5739 -> 5667;
5740 -> 5694;
5740 -> 5739;
5740 -> 5667;
5741 -> 4911;
5742 -> 4913;
5742 -> 5694;
5743 -> 5694;
5744 -> 5742;
5744 -> 5743;
5745 -> 5694;
5745 -> 5743;
5746 -> 5744;
5746 -> 4919;
5746 -> 5743;
5747 -> 5745;
5747 -> 5743;
5748 -> 5743;
5749 -> 5747;
5749 -> 5748;
5750 -> 5748;
5750 -> 5743;
5751 -> 5743;
5752 -> 5743;
5753 -> 5752;
5753 -> 5743;
5754 -> 5743;
5755 -> 5747;
5755 -> 5754;
5756 -> 5754;
5757 -> 5755;
5757 -> 5756;
5758 -> 5756;
5758 -> 5754;
5759 -> 5758;
5759 -> 5743;
5760 -> 0;
5760 -> 5743;
5761 -> 5743;
5762 -> 5760;
5762 -> 5761;
5763 -> 5747;
5763 -> 5761;
5764 -> 5761;
5765 -> 5763;
5765 -> 5764;
5766 -> 5765;
5766 -> 5694;
5766 -> 5764;
5767 -> 5765;
5767 -> 5694;
5767 -> 5766;
5768 -> 5766;
5769 -> 5765;
5769 -> 5768;
5770 -> 5769;
5770 -> 5768;
5771 -> 5768;
5772 -> 5768;
5773 -> 5770;
5773 -> 5772;
5774 -> 5771;
5774 -> 5772;
5775 -> 5772;
5776 -> 5774;
5776 -> 5775;
5777 -> 5775;
5778 -> 5776;
5778 -> 5777;
5779 -> 5774;
5779 -> 5772;
5780 -> 5773;
5780 -> 5772;
5781 -> 5773;
5781 -> 5774;
5781 -> 5772;
5782 -> 5771;
5782 -> 5766;
5783 -> 5766;
5784 -> 5767;
5784 -> 5782;
5784 -> 5783;
5784 -> 5781;
5784 -> 5694;
5784 -> 5766;
5785 -> 5765;
5785 -> 5784;
5785 -> 5764;
5786 -> 5785;
5786 -> 5761;
5787 -> 5762;
5787 -> 5761;
5788 -> 5761;
5789 -> 5786;
5789 -> 5788;
5790 -> 5787;
5790 -> 5788;
5791 -> 5789;
5791 -> 5788;
5792 -> 5790;
5792 -> 5788;
5793 -> 5788;
5794 -> 5791;
5794 -> 5793;
5795 -> 5792;
5795 -> 5793;
5796 -> 5795;
5796 -> 5793;
5797 -> 5794;
5797 -> 5793;
5798 -> 5793;
5799 -> 5796;
5799 -> 5793;
5800 -> 5793;
5801 -> 5797;
5801 -> 5800;
5802 -> 5798;
5802 -> 5800;
5803 -> 5798;
5803 -> 5800;
5804 -> 5799;
5804 -> 5800;
5805 -> 5798;
5805 -> 5800;
5806 -> 5800;
5807 -> 5801;
5807 -> 5806;
5807 -> 5800;
5808 -> 5805;
5808 -> 5800;
5809 -> 5808;
5810 -> 5802;
5810 -> 5809;
5810 -> 5808;
5811 -> 5808;
5812 -> 5803;
5812 -> 5811;
5812 -> 5808;
5813 -> 5801;
5813 -> 5800;
5814 -> 5800;
5816 -> 5815;
5818 -> 5817;
5819 -> 5814;
5819 -> 5800;
5820 -> 5804;
5820 -> 5800;
5821 -> 5802;
5821 -> 5800;
5822 -> 5803;
5822 -> 5800;
5823 -> 5800;
5824 -> 5800;
5825 -> 5819;
5825 -> 5824;
5826 -> 5820;
5826 -> 5824;
5827 -> 5821;
5827 -> 5824;
5828 -> 5822;
5828 -> 5824;
5829 -> 5823;
5829 -> 5824;
5830 -> 5825;
5830 -> 5824;
5831 -> 5826;
5831 -> 5824;
5832 -> 5824;
5833 -> 5827;
5833 -> 5824;
5834 -> 5828;
5834 -> 5824;
5835 -> 5824;
5836 -> 5835;
5836 -> 5830;
5836 -> 5831;
5836 -> 5832;
5836 -> 5833;
5836 -> 5834;
5836 -> 5814;
5836 -> 0;
5836 -> 5824;
5837 -> 5835;
5837 -> 5824;
5838 -> 5835;
5838 -> 5824;
5839 -> 5826;
5839 -> 5836;
5839 -> 5824;
5840 -> 0;
5840 -> 5824;
5841 -> 5839;
5841 -> 5835;
5841 -> 5824;
5842 -> 5823;
5842 -> 5800;
5843 -> 5800;
5844 -> 5842;
5844 -> 5843;
5845 -> 5801;
5845 -> 5843;
5846 -> 5844;
5846 -> 5843;
5847 -> 5843;
5848 -> 5846;
5848 -> 5847;
5849 -> 5845;
5849 -> 5847;
5850 -> 5849;
5850 -> 5847;
5851 -> 5847;
5852 -> 5850;
5852 -> 5851;
5853 -> 5848;
5853 -> 5851;
5854 -> 5853;
5854 -> 5836;
5854 -> 5851;
5855 -> 5853;
5855 -> 5836;
5855 -> 5837;
5855 -> 5841;
5855 -> 5838;
5855 -> 5851;
5856 -> 0;
5856 -> 5851;
5857 -> 5853;
5857 -> 5836;
5857 -> 5837;
5857 -> 5841;
5857 -> 5838;
5857 -> 0;
5857 -> 5851;
5858 -> 5857;
5859 -> 5852;
5859 -> 5858;
5860 -> 5858;
5861 -> 5859;
5861 -> 5860;
5862 -> 5861;
5862 -> 5784;
5862 -> 5860;
5863 -> 5858;
5864 -> 5862;
5864 -> 5863;
5865 -> 5858;
5866 -> 5864;
5866 -> 5865;
5867 -> 5866;
5867 -> 5865;
5868 -> 5865;
5869 -> 5867;
5869 -> 5868;
5870 -> 5868;
5871 -> 5869;
5871 -> 5870;
5872 -> 5871;
5873 -> 5872;
5874 -> 5871;
5875 -> 5871;
5876 -> 5871;
5876 -> 5868;
5877 -> 5876;
5877 -> 5857;
5878 -> 5877;
5878 -> 5857;
5879 -> 5857;
5880 -> 5878;
5880 -> 5879;
5881 -> 5853;
5881 -> 5879;
5882 -> 5880;
5882 -> 5879;
5883 -> 5879;
5884 -> 5882;
5884 -> 5883;
5884 -> 5879;
5885 -> 5881;
5885 -> 5836;
5885 -> 5837;
5885 -> 5841;
5885 -> 5838;
5885 -> 0;
5885 -> 5879;
5886 -> 5879;
5887 -> 5882;
5887 -> 5886;
5888 -> 5886;
5889 -> 5887;
5889 -> 5871;
5889 -> 5888;
5890 -> 5888;
5890 -> 5879;
5891 -> 5890;
5891 -> 5857;
5892 -> 5853;
5892 -> 5836;
5892 -> 5837;
5892 -> 5841;
5892 -> 5838;
5892 -> 5891;
5893 -> 5891;
5894 -> 5892;
5894 -> 5893;
5895 -> 5892;
5895 -> 5893;
5896 -> 5895;
5896 -> 5892;
5896 -> 5893;
5897 -> 5893;
5898 -> 5894;
5898 -> 5893;
5899 -> 5893;
5900 -> 5896;
5900 -> 5899;
5901 -> 5896;
5901 -> 5899;
5902 -> 5896;
5902 -> 5899;
5903 -> 5896;
5903 -> 5899;
5904 -> 5896;
5904 -> 5899;
5905 -> 5896;
5905 -> 5899;
5906 -> 5897;
5906 -> 5899;
5907 -> 5898;
5907 -> 5899;
5908 -> 5897;
5908 -> 5899;
5909 -> 5900;
5909 -> 5899;
5910 -> 5901;
5910 -> 5899;
5911 -> 5906;
5911 -> 5899;
5912 -> 5902;
5912 -> 5899;
5913 -> 5903;
5913 -> 5899;
5914 -> 5907;
5914 -> 5899;
5915 -> 5899;
5916 -> 5915;
5916 -> 5909;
5916 -> 5910;
5916 -> 5911;
5916 -> 5912;
5916 -> 5913;
5916 -> 5914;
5916 -> 5892;
5916 -> 5899;
5917 -> 5904;
5917 -> 5915;
5917 -> 5899;
5918 -> 5905;
5918 -> 5915;
5918 -> 5899;
5919 -> 5897;
5919 -> 5891;
5920 -> 5892;
5920 -> 5919;
5920 -> 5916;
5920 -> 5915;
5920 -> 5917;
5920 -> 5918;
5920 -> 5891;
5921 -> 5891;
5922 -> 5920;
5922 -> 5921;
5923 -> 5877;
5923 -> 5921;
5924 -> 5922;
5924 -> 5920;
5924 -> 5921;
5925 -> 5922;
5925 -> 5920;
5925 -> 5921;
5926 -> 5922;
5927 -> 5923;
5927 -> 5926;
5928 -> 5926;
5929 -> 5926;
5930 -> 5926;
5931 -> 5930;
5932 -> 5931;
5933 -> 5927;
5934 -> 5933;
5935 -> 5927;
5936 -> 5927;
5937 -> 5927;
5937 -> 5922;
5938 -> 5922;
5939 -> 5937;
5939 -> 5922;
5940 -> 5922;
5941 -> 5939;
5941 -> 5940;
5941 -> 5922;
5942 -> 5938;
5942 -> 5920;
5942 -> 0;
5942 -> 5922;
5943 -> 5939;
5943 -> 5922;
5944 -> 5943;
5944 -> 5927;
5944 -> 5922;
5945 -> 5922;
5945 -> 5920;
5946 -> 5922;
5946 -> 5920;
5947 -> 5943;
5947 -> 5927;
5947 -> 5922;
5948 -> 5922;
5949 -> 5927;
5949 -> 5948;
5950 -> 5949;
5950 -> 5927;
5950 -> 5948;
5951 -> 5948;
5951 -> 5922;
5952 -> 0;
5952 -> 5951;
5953 -> 5927;
5953 -> 5951;
5954 -> 5951;
5955 -> 5927;
5955 -> 5954;
5956 -> 5954;
5957 -> 5955;
5957 -> 5956;
5958 -> 5954;
5959 -> 5957;
5959 -> 5958;
5960 -> 5959;
5960 -> 5951;
5961 -> 5951;
5962 -> 5952;
5962 -> 5961;
5963 -> 5953;
5963 -> 5961;
5964 -> 5960;
5964 -> 5961;
5965 -> 5922;
5965 -> 5961;
5966 -> 5961;
5967 -> 5964;
5967 -> 5966;
5967 -> 5961;
5968 -> 5967;
5968 -> 5961;
5969 -> 5965;
5969 -> 5920;
5969 -> 5968;
5970 -> 5969;
5970 -> 5968;
5971 -> 5962;
5971 -> 5961;
5972 -> 5963;
5972 -> 5961;
5973 -> 5970;
5973 -> 5961;
5974 -> 5971;
5974 -> 5972;
5974 -> 5973;
5974 -> 5927;
5974 -> 5961;
5975 -> 5922;
5976 -> 5922;
5977 -> 5927;
5977 -> 5976;
5978 -> 5977;
5978 -> 5974;
5978 -> 5976;
5979 -> 5976;
5979 -> 5922;
5980 -> 5922;
5981 -> 5979;
5981 -> 5980;
5982 -> 5922;
5982 -> 5980;
5983 -> 0;
5983 -> 5980;
5984 -> 5980;
5985 -> 5981;
5985 -> 5980;
5986 -> 5980;
5987 -> 5983;
5987 -> 5986;
5988 -> 5984;
5988 -> 5986;
5989 -> 5985;
5989 -> 5986;
5990 -> 5982;
5990 -> 5986;
5991 -> 5986;
5992 -> 5989;
5992 -> 5991;
5992 -> 5986;
5993 -> 5992;
5993 -> 5986;
5994 -> 5990;
5994 -> 5974;
5994 -> 5993;
5995 -> 5987;
5995 -> 5986;
5996 -> 5988;
5996 -> 5986;
5997 -> 5922;
5998 -> 5921;
5999 -> 5923;
5999 -> 5998;
6000 -> 5999;
6000 -> 5994;
6000 -> 5998;
6001 -> 5998;
6001 -> 5921;
6002 -> 0;
6002 -> 6001;
6003 -> 5923;
6003 -> 6001;
6004 -> 6001;
6005 -> 5923;
6005 -> 6004;
6006 -> 6004;
6007 -> 6005;
6007 -> 6006;
6008 -> 6004;
6009 -> 6001;
6010 -> 6002;
6010 -> 6009;
6011 -> 6003;
6011 -> 6009;
6012 -> 5922;
6012 -> 6009;
6013 -> 6009;
6014 -> 6010;
6014 -> 6009;
6015 -> 6011;
6015 -> 6009;
6016 -> 5921;
6017 -> 5891;
6018 -> 5891;
6019 -> 5877;
6019 -> 6018;
6020 -> 6019;
6020 -> 5994;
6020 -> 6018;
6021 -> 6018;
6021 -> 5891;
6022 -> 5891;
6023 -> 5979;
6023 -> 6022;
6024 -> 5853;
6024 -> 6022;
6025 -> 0;
6025 -> 6022;
6026 -> 6022;
6027 -> 6023;
6027 -> 6022;
6028 -> 6022;
6029 -> 6025;
6029 -> 6028;
6030 -> 6026;
6030 -> 6028;
6031 -> 6027;
6031 -> 6028;
6032 -> 6024;
6032 -> 6028;
6033 -> 6028;
6034 -> 6031;
6034 -> 6033;
6034 -> 6028;
6035 -> 6034;
6035 -> 6028;
6036 -> 6029;
6036 -> 6028;
6037 -> 6030;
6037 -> 6028;
6038 -> 5891;
6039 -> 5851;
6040 -> 5852;
6040 -> 6039;
6041 -> 6039;
6042 -> 6040;
6042 -> 5994;
6042 -> 6041;
6043 -> 6041;
6043 -> 5851;
6044 -> 0;
6044 -> 6043;
6045 -> 5852;
6045 -> 6043;
6046 -> 6043;
6047 -> 5852;
6047 -> 6046;
6048 -> 6046;
6049 -> 6047;
6049 -> 6048;
6050 -> 6046;
6051 -> 6043;
6052 -> 6044;
6052 -> 6051;
6053 -> 6045;
6053 -> 6051;
6054 -> 5853;
6054 -> 6051;
6055 -> 6051;
6056 -> 6052;
6056 -> 6051;
6057 -> 6053;
6057 -> 6051;
6058 -> 5847;
6059 -> 5843;
6060 -> 5800;
6061 -> 5814;
6061 -> 5994;
6061 -> 5800;
6062 -> 6061;
6062 -> 5744;
6062 -> 4919;
6062 -> 5743;
6063 -> 5759;
6063 -> 6062;
6063 -> 5743;
6064 -> 5744;
6064 -> 4919;
6064 -> 5743;
6065 -> 5744;
6065 -> 4919;
6065 -> 6064;
6066 -> 6064;
6067 -> 5744;
6067 -> 4919;
6067 -> 5743;
6068 -> 5744;
6068 -> 4919;
6068 -> 5743;
6069 -> 6068;
6070 -> 6069;
6071 -> 6067;
6071 -> 6070;
6071 -> 6069;
6072 -> 6071;
6073 -> 5744;
6073 -> 4919;
6073 -> 5743;
6074 -> 5743;
6075 -> 6073;
6075 -> 6074;
6076 -> 5747;
6076 -> 6074;
6077 -> 6074;
6078 -> 6076;
6078 -> 6077;
6079 -> 6078;
6079 -> 6061;
6079 -> 6077;
6080 -> 6078;
6080 -> 6061;
6080 -> 6077;
6081 -> 6080;
6082 -> 6080;
6083 -> 6080;
6084 -> 6080;
6085 -> 6084;
6085 -> 6080;
6086 -> 6085;
6086 -> 6080;
6087 -> 6085;
6087 -> 6080;
6088 -> 6085;
6089 -> 6085;
6090 -> 6085;
6091 -> 6085;
6092 -> 6085;
6093 -> 6085;
6094 -> 6085;
6095 -> 6085;
6096 -> 6095;
6096 -> 6085;
6097 -> 6096;
6097 -> 6085;
6098 -> 6085;
6099 -> 6085;
6100 -> 6085;
6101 -> 6085;
6102 -> 6085;
6103 -> 6085;
6104 -> 6085;
6105 -> 6085;
6106 -> 6085;
6107 -> 6085;
6108 -> 6085;
6109 -> 0;
6109 -> 6085;
6110 -> 6107;
6110 -> 6085;
6111 -> 6085;
6112 -> 6093;
6112 -> 6111;
6112 -> 6085;
6113 -> 6085;
6114 -> 6113;
6114 -> 6085;
6115 -> 6114;
6115 -> 6085;
6116 -> 6085;
6117 -> 6085;
6118 -> 6085;
6119 -> 6085;
6120 -> 6085;
6121 -> 6088;
6121 -> 6120;
6121 -> 6085;
6122 -> 6085;
6123 -> 6085;
6124 -> 6085;
6124 -> 0;
6125 -> 6085;
6126 -> 6085;
6126 -> 6125;
6127 -> 6125;
6128 -> 6126;
6128 -> 6127;
6129 -> 6128;
6129 -> 6085;
6129 -> 6127;
6130 -> 6129;
6130 -> 6125;
6131 -> 6125;
6132 -> 6130;
6132 -> 6131;
6132 -> 6125;
6133 -> 6132;
6133 -> 6125;
6134 -> 6133;
6135 -> 6130;
6135 -> 6134;
6136 -> 6134;
6137 -> 6135;
6137 -> 6136;
6138 -> 6137;
6138 -> 6134;
6139 -> 6134;
6140 -> 6138;
6140 -> 6139;
6141 -> 6140;
6141 -> 6085;
6142 -> 6085;
6143 -> 6085;
6144 -> 6085;
6144 -> 6143;
6145 -> 6143;
6146 -> 6144;
6146 -> 6145;
6147 -> 6146;
6147 -> 6085;
6147 -> 6145;
6148 -> 6145;
6149 -> 6147;
6149 -> 6148;
6150 -> 6148;
6150 -> 6145;
6151 -> 6145;
6152 -> 6147;
6152 -> 6151;
6153 -> 6152;
6153 -> 6145;
6154 -> 6153;
6154 -> 6143;
6155 -> 6154;
6155 -> 6085;
6156 -> 6085;
6157 -> 6155;
6157 -> 6156;
6158 -> 6157;
6158 -> 6085;
6158 -> 6156;
6159 -> 6085;
6160 -> 6085;
6161 -> 6085;
6162 -> 6085;
6162 -> 0;
6163 -> 6074;
6164 -> 6074;
6165 -> 6164;
6165 -> 6074;
6166 -> 6075;
6166 -> 6074;
6167 -> 6164;
6167 -> 6074;
6168 -> 6076;
6168 -> 6085;
6168 -> 6166;
6168 -> 6167;
6168 -> 6165;
6168 -> 6074;
6169 -> 6168;
6169 -> 6074;
6170 -> 6169;
6170 -> 5743;
6171 -> 6170;
6172 -> 6170;
6172 -> 6171;
6173 -> 6171;
6174 -> 6173;
6174 -> 6170;
6175 -> 6170;
6176 -> 6072;
6176 -> 6175;
6176 -> 6170;
6177 -> 6170;
6178 -> 6170;
6178 -> 6177;
6179 -> 6177;
6180 -> 6179;
6180 -> 6170;
6181 -> 6072;
6181 -> 6180;
6181 -> 6170;
6182 -> 6174;
6182 -> 6181;
6182 -> 6170;
6183 -> 6182;
6184 -> 5751;
6184 -> 6183;
6184 -> 6182;
6185 -> 6170;
6185 -> 6182;
6186 -> 5743;
6187 -> 6185;
6187 -> 6186;
6187 -> 5743;
6188 -> 6185;
6188 -> 5743;
6189 -> 4911;
6190 -> 6188;
6190 -> 6189;
6190 -> 4911;
6191 -> 6188;
6191 -> 4911;
6192 -> 6191;
6192 -> 4911;
6193 -> 4911;
6193 -> 4920;
6194 -> 4911;
6195 -> 6191;
6195 -> 6194;
6196 -> 6194;
6197 -> 6195;
6197 -> 6196;
6198 -> 6197;
6198 -> 6169;
6198 -> 6196;
6199 -> 6198;
6199 -> 6194;
6200 -> 6194;
6201 -> 6199;
6201 -> 6200;
6201 -> 6194;
6202 -> 6201;
6202 -> 6194;
6203 -> 6202;
6204 -> 6199;
6204 -> 6203;
6205 -> 6203;
6206 -> 6204;
6206 -> 6205;
6207 -> 6206;
6207 -> 6203;
6208 -> 6203;
6209 -> 6207;
6209 -> 6208;
6210 -> 6209;
6210 -> 4911;
6211 -> 6193;
6211 -> 6210;
6211 -> 4911;
6212 -> 6193;
6212 -> 4911;
6213 -> 4911;
6214 -> 6191;
6214 -> 6213;
6214 -> 4911;
6215 -> 4917;
6215 -> 6193;
6215 -> 4911;
6216 -> 5744;
6216 -> 6215;
6217 -> 6191;
6217 -> 6215;
6218 -> 6215;
6219 -> 6216;
6219 -> 6218;
6220 -> 6217;
6220 -> 6218;
6221 -> 4912;
6221 -> 6218;
6222 -> 6218;
6223 -> 6219;
6223 -> 4919;
6223 -> 6169;
6223 -> 6218;
6224 -> 6220;
6224 -> 6218;
6225 -> 6221;
6225 -> 6223;
6225 -> 6224;
6225 -> 6169;
6225 -> 6218;
6226 -> 6225;
6226 -> 6218;
6227 -> 6220;
6227 -> 6218;
6228 -> 0;
6228 -> 6218;
6229 -> 6218;
6230 -> 6226;
6230 -> 6229;
6231 -> 6227;
6231 -> 6229;
6232 -> 6228;
6232 -> 6229;
6233 -> 6230;
6233 -> 6229;
6234 -> 6231;
6234 -> 6229;
6235 -> 6232;
6235 -> 6229;
6236 -> 6229;
6237 -> 6234;
6237 -> 6236;
6238 -> 6235;
6238 -> 6236;
6239 -> 6230;
6239 -> 6236;
6240 -> 6237;
6240 -> 6236;
6241 -> 6240;
6241 -> 6236;
6242 -> 6238;
6242 -> 6241;
6243 -> 6241;
6244 -> 6241;
6244 -> 6243;
6245 -> 6242;
6245 -> 6243;
6246 -> 6239;
6246 -> 6243;
6247 -> 6244;
6247 -> 6246;
6247 -> 6243;
6248 -> 6247;
6249 -> 6215;
6250 -> 6191;
6250 -> 4911;
6251 -> 6250;
6251 -> 4911;
6252 -> 4911;
6253 -> 6251;
6253 -> 6252;
6254 -> 6252;
6255 -> 6253;
6255 -> 6254;
6256 -> 6254;
6256 -> 6252;
6257 -> 6256;
6257 -> 4911;
6258 -> 4911;
6259 -> 4914;
6259 -> 6258;
6259 -> 4911;
6260 -> 6250;
6260 -> 4911;
6261 -> 6260;
6261 -> 4903;
6262 -> 4903;
6263 -> 6261;
6263 -> 6262;
6264 -> 2864;
6264 -> 6262;
6265 -> 6262;
6266 -> 6263;
6266 -> 6265;
6266 -> 6262;
6267 -> 6262;
6268 -> 6263;
6268 -> 6267;
6269 -> 6268;
6269 -> 6225;
6269 -> 6267;
6270 -> 6269;
6270 -> 0;
6270 -> 6267;
6271 -> 6268;
6271 -> 6225;
6271 -> 6270;
6272 -> 6271;
6273 -> 6271;
6274 -> 6272;
6274 -> 6273;
6275 -> 6268;
6275 -> 6273;
6276 -> 6275;
6276 -> 6225;
6276 -> 6273;
6277 -> 4436;
6277 -> 6273;
6278 -> 6276;
6279 -> 6275;
6279 -> 6278;
6280 -> 6279;
6280 -> 6225;
6280 -> 6278;
6281 -> 6280;
6282 -> 6279;
6282 -> 6281;
6283 -> 6282;
6283 -> 6225;
6283 -> 6281;
6284 -> 6281;
6285 -> 6283;
6285 -> 6284;
6286 -> 6284;
6286 -> 6281;
6287 -> 6281;
6288 -> 6283;
6288 -> 6287;
6289 -> 6288;
6289 -> 6281;
6290 -> 6289;
6290 -> 6280;
6291 -> 6280;
6292 -> 6290;
6292 -> 6291;
6293 -> 6292;
6293 -> 6280;
6294 -> 6279;
6294 -> 6225;
6294 -> 6280;
6295 -> 6293;
6295 -> 6280;
6296 -> 6290;
6296 -> 6295;
6297 -> 6279;
6297 -> 6295;
6298 -> 6295;
6299 -> 6295;
6300 -> 6296;
6300 -> 6299;
6301 -> 6297;
6301 -> 6299;
6302 -> 6298;
6302 -> 6299;
6303 -> 6300;
6303 -> 6299;
6304 -> 6301;
6304 -> 6299;
6305 -> 6299;
6306 -> 6299;
6307 -> 6303;
6307 -> 6306;
6308 -> 6304;
6308 -> 6306;
6309 -> 6305;
6309 -> 6306;
6310 -> 6302;
6310 -> 6306;
6311 -> 6306;
6312 -> 6307;
6312 -> 6311;
6313 -> 6306;
6314 -> 6307;
6314 -> 6313;
6315 -> 6314;
6315 -> 6306;
6316 -> 6315;
6317 -> 6315;
6318 -> 6316;
6318 -> 6317;
6319 -> 6318;
6319 -> 6293;
6319 -> 6317;
6321 -> 6320;
6322 -> 6320;
6323 -> 6322;
6323 -> 6306;
6324 -> 6307;
6324 -> 6306;
6325 -> 6306;
6326 -> 6325;
6326 -> 6312;
6326 -> 6319;
6326 -> 6323;
6326 -> 6324;
6326 -> 6293;
6326 -> 6321;
6326 -> 6306;
6327 -> 6325;
6327 -> 6306;
6328 -> 6325;
6328 -> 6306;
6329 -> 6306;
6330 -> 6307;
6330 -> 6329;
6330 -> 6306;
6331 -> 6308;
6331 -> 6325;
6331 -> 6306;
6332 -> 6309;
6332 -> 6325;
6332 -> 6306;
6333 -> 6293;
6333 -> 6295;
6334 -> 6333;
6334 -> 6298;
6334 -> 6293;
6334 -> 6326;
6334 -> 6327;
6334 -> 6331;
6334 -> 6328;
6334 -> 6332;
6334 -> 6295;
6335 -> 6334;
6335 -> 6298;
6336 -> 6335;
6336 -> 6334;
6336 -> 6298;
6337 -> 6336;
6337 -> 6276;
6338 -> 6337;
6338 -> 6276;
6339 -> 6274;
6339 -> 6338;
6340 -> 6337;
6340 -> 6339;
6341 -> 0;
6341 -> 6271;
6342 -> 6271;
6343 -> 6340;
6343 -> 6342;
6343 -> 6271;
6344 -> 6343;
6345 -> 6344;
6345 -> 6343;
6346 -> 6345;
6346 -> 6343;
6347 -> 6341;
6347 -> 6268;
6347 -> 6270;
6348 -> 6341;
6348 -> 6267;
6349 -> 6348;
6349 -> 6262;
6350 -> 6262;
6351 -> 6263;
6351 -> 6350;
6352 -> 6351;
6352 -> 6336;
6352 -> 6350;
6353 -> 6352;
6353 -> 6262;
6354 -> 6262;
6355 -> 6262;
6356 -> 6263;
6356 -> 6355;
6357 -> 0;
6357 -> 6355;
6358 -> 6356;
6358 -> 6336;
6358 -> 0;
6358 -> 6355;
6359 -> 6358;
6359 -> 6262;
6360 -> 2860;
6360 -> 6359;
6360 -> 4903;
6361 -> 4903;
6362 -> 6260;
6362 -> 6361;
6362 -> 4903;
6363 -> 6260;
6363 -> 4903;
6364 -> 4903;
6365 -> 6363;
6365 -> 6364;
6366 -> 6364;
6367 -> 6365;
6367 -> 6366;
6368 -> 6366;
6368 -> 6364;
6369 -> 6368;
6369 -> 6364;
6370 -> 6365;
6370 -> 6369;
6371 -> 6364;
6372 -> 6370;
6372 -> 6371;
6372 -> 6364;
6373 -> 6364;
6374 -> 6370;
6374 -> 6373;
6375 -> 6374;
6375 -> 6336;
6375 -> 6373;
6376 -> 6375;
6376 -> 6364;
6377 -> 6364;
6378 -> 6364;
6379 -> 6370;
6379 -> 6378;
6380 -> 6378;
6381 -> 6379;
6381 -> 6380;
6382 -> 6381;
6382 -> 6336;
6382 -> 6380;
6383 -> 6380;
6384 -> 6382;
6384 -> 6383;
6384 -> 6380;
6385 -> 6380;
6386 -> 6381;
6386 -> 6385;
6387 -> 6385;
6388 -> 6386;
6388 -> 6387;
6389 -> 6388;
6389 -> 6336;
6389 -> 6387;
6390 -> 6387;
6391 -> 6389;
6391 -> 6390;
6392 -> 6390;
6392 -> 6387;
6393 -> 6387;
6394 -> 6393;
6395 -> 6389;
6395 -> 6385;
6396 -> 6386;
6396 -> 6336;
6396 -> 6385;
6397 -> 6385;
6398 -> 6396;
6398 -> 6397;
6399 -> 6395;
6399 -> 6397;
6400 -> 6398;
6400 -> 6397;
6401 -> 6399;
6401 -> 6336;
6401 -> 6400;
6401 -> 6347;
6401 -> 6397;
6402 -> 6401;
6403 -> 6402;
6404 -> 6403;
6404 -> 6380;
6405 -> 6404;
6406 -> 6404;
6407 -> 6405;
6407 -> 6406;
6408 -> 6407;
6408 -> 6406;
6409 -> 0;
6409 -> 6407;
6409 -> 6406;
6410 -> 0;
6410 -> 6407;
6410 -> 6406;
6411 -> 6407;
6411 -> 6406;
6412 -> 6407;
6412 -> 6406;
6413 -> 6407;
6413 -> 6406;
6414 -> 6407;
6414 -> 6406;
6415 -> 4436;
6415 -> 6407;
6415 -> 6406;
6416 -> 0;
6416 -> 6407;
6416 -> 6406;
6417 -> 6381;
6417 -> 6401;
6417 -> 6404;
6418 -> 6405;
6418 -> 6404;
6419 -> 6404;
6420 -> 6417;
6420 -> 6418;
6420 -> 6419;
6420 -> 6408;
6420 -> 6409;
6420 -> 6410;
6420 -> 6411;
6420 -> 6412;
6420 -> 6413;
6420 -> 6414;
6420 -> 6415;
6420 -> 6416;
6420 -> 6401;
6420 -> 0;
6420 -> 6404;
6421 -> 6420;
6421 -> 6378;
6422 -> 6421;
6422 -> 5032;
6422 -> 6378;
6423 -> 6421;
6423 -> 6420;
6423 -> 6378;
6424 -> 6423;
6425 -> 6424;
6426 -> 6424;
6426 -> 6425;
6427 -> 6425;
6427 -> 6424;
6428 -> 6424;
6428 -> 6423;
6429 -> 6423;
6430 -> 6428;
6430 -> 6429;
6431 -> 6379;
6431 -> 6420;
6431 -> 6423;
6432 -> 6430;
6432 -> 6421;
6432 -> 6423;
6433 -> 6421;
6433 -> 6430;
6433 -> 6432;
6433 -> 6378;
6434 -> 6433;
6434 -> 6364;
6435 -> 6260;
6435 -> 4903;
6436 -> 4876;
6436 -> 4903;
6437 -> 0;
6437 -> 4903;
6438 -> 4903;
6439 -> 6435;
6439 -> 6438;
6440 -> 6436;
6440 -> 6438;
6441 -> 6437;
6441 -> 6438;
6442 -> 6439;
6442 -> 6438;
6443 -> 6440;
6443 -> 6438;
6444 -> 6441;
6444 -> 6438;
6445 -> 6438;
6446 -> 6443;
6446 -> 6445;
6447 -> 6444;
6447 -> 6445;
6448 -> 6439;
6448 -> 6445;
6449 -> 6446;
6449 -> 6445;
6450 -> 6449;
6450 -> 6445;
6451 -> 6447;
6451 -> 6450;
6452 -> 6450;
6453 -> 6450;
6453 -> 6452;
6454 -> 6451;
6454 -> 6452;
6455 -> 6448;
6455 -> 6452;
6456 -> 6453;
6456 -> 6455;
6456 -> 6452;
6457 -> 6452;
6458 -> 6453;
6458 -> 6457;
6458 -> 6452;
6459 -> 6458;
6460 -> 4903;
6461 -> 4876;
6461 -> 6460;
6461 -> 4903;
6462 -> 6260;
6462 -> 4903;
6463 -> 6432;
6464 -> 6432;
6464 -> 6463;
6465 -> 6463;
6466 -> 6465;
6466 -> 6432;
6467 -> 6432;
6468 -> 6432;
6469 -> 6432;
6470 -> 6432;
6471 -> 6432;
6472 -> 6432;
6473 -> 6432;
6474 -> 6432;
6475 -> 6432;
6476 -> 6432;
6477 -> 6432;
6478 -> 6432;
6479 -> 6432;
6480 -> 6432;
6481 -> 6432;
6482 -> 6432;
6483 -> 6432;
6484 -> 6432;
6485 -> 6432;
6486 -> 6432;
6487 -> 6432;
6488 -> 6487;
6488 -> 6432;
6489 -> 6488;
6489 -> 6432;
6490 -> 6432;
6491 -> 6432;
6492 -> 6432;
6493 -> 6432;
6494 -> 6432;
6495 -> 6432;
6496 -> 6432;
6497 -> 6432;
6498 -> 6432;
6499 -> 6432;
6500 -> 6432;
6501 -> 6499;
6501 -> 6432;
6502 -> 6432;
6503 -> 6485;
6503 -> 6502;
6503 -> 6432;
6504 -> 6432;
6505 -> 6480;
6505 -> 6504;
6505 -> 6432;
6506 -> 6432;
6507 -> 6432;
6508 -> 6432;
6509 -> 6432;
6510 -> 6432;
6511 -> 6432;
6512 -> 6432;
6513 -> 6432;
6514 -> 6432;
6515 -> 6432;
6515 -> 6514;
6516 -> 6514;
6516 -> 6432;
6517 -> 6432;
6518 -> 6432;
6519 -> 6518;
6519 -> 6432;
6520 -> 6432;
6521 -> 6432;
6521 -> 6520;
6522 -> 6520;
6523 -> 6521;
6523 -> 6522;
6524 -> 6522;
6524 -> 6520;
6525 -> 6524;
6525 -> 6432;
6526 -> 6432;
6527 -> 6526;
6528 -> 6432;
6529 -> 6432;
6530 -> 6432;
6531 -> 6432;
6532 -> 6530;
6532 -> 6432;
6533 -> 6532;
6534 -> 6532;
6535 -> 6432;
6536 -> 6432;
6537 -> 6432;
6538 -> 0;
6538 -> 6432;
6539 -> 6432;
6540 -> 6432;
6541 -> 6539;
6541 -> 6432;
6542 -> 6432;
6543 -> 6541;
6543 -> 6542;
6543 -> 6432;
6544 -> 6540;
6544 -> 6432;
6544 -> 0;
6545 -> 6541;
6545 -> 6432;
6546 -> 6545;
6546 -> 6432;
6547 -> 6545;
6547 -> 6432;
6548 -> 6432;
6549 -> 6548;
6549 -> 6432;
6550 -> 6432;
6551 -> 6432;
6551 -> 6550;
6552 -> 6550;
6553 -> 6432;
6554 -> 6432;
6555 -> 6517;
6555 -> 6554;
6555 -> 6432;
6556 -> 6525;
6556 -> 6555;
6557 -> 6556;
6558 -> 6432;
6558 -> 6557;
6559 -> 6557;
6560 -> 6558;
6560 -> 6432;
6560 -> 6559;
6561 -> 6560;
6561 -> 6557;
6562 -> 6561;
6562 -> 6556;
6563 -> 6432;
6563 -> 6556;
6564 -> 6556;
6565 -> 6556;
6566 -> 6562;
6566 -> 6565;
6567 -> 6563;
6567 -> 6565;
6568 -> 6564;
6568 -> 6565;
6569 -> 6564;
6569 -> 6565;
6570 -> 6566;
6570 -> 6565;
6571 -> 6565;
6572 -> 6568;
6572 -> 6565;
6573 -> 6570;
6573 -> 6565;
6574 -> 6571;
6574 -> 6565;
6575 -> 6572;
6575 -> 6565;
6576 -> 6573;
6576 -> 6565;
6577 -> 6575;
6577 -> 6565;
6578 -> 6574;
6578 -> 6565;
6579 -> 6576;
6579 -> 6565;
6580 -> 6577;
6580 -> 6565;
6581 -> 6578;
6581 -> 6565;
6582 -> 6569;
6582 -> 6565;
6583 -> 6579;
6583 -> 6565;
6584 -> 6567;
6584 -> 6432;
6584 -> 6565;
6585 -> 6567;
6585 -> 6565;
6586 -> 6565;
6587 -> 6580;
6587 -> 6565;
6588 -> 6565;
6589 -> 6581;
6589 -> 6565;
6590 -> 6565;
6591 -> 6565;
6592 -> 6583;
6592 -> 6591;
6593 -> 6584;
6593 -> 6591;
6594 -> 6567;
6594 -> 6591;
6595 -> 6567;
6595 -> 6591;
6596 -> 6585;
6596 -> 6591;
6597 -> 6586;
6597 -> 6591;
6598 -> 6587;
6598 -> 6591;
6599 -> 6588;
6599 -> 6591;
6600 -> 6589;
6600 -> 6591;
6601 -> 6590;
6601 -> 6591;
6602 -> 6582;
6602 -> 6591;
6603 -> 6594;
6603 -> 6591;
6604 -> 6595;
6604 -> 6591;
6605 -> 6596;
6605 -> 6591;
6606 -> 6601;
6606 -> 6591;
6607 -> 6591;
6608 -> 6603;
6608 -> 6607;
6609 -> 6604;
6609 -> 6607;
6610 -> 6605;
6610 -> 6607;
6611 -> 6606;
6611 -> 6607;
6612 -> 6602;
6612 -> 6607;
6613 -> 6611;
6613 -> 6607;
6614 -> 6607;
6615 -> 6613;
6615 -> 6614;
6616 -> 6612;
6616 -> 6614;
6617 -> 6615;
6617 -> 6612;
6617 -> 6614;
6618 -> 6612;
6618 -> 6607;
6619 -> 6612;
6619 -> 6607;
6620 -> 6612;
6620 -> 6607;
6621 -> 6607;
6622 -> 6608;
6622 -> 6621;
6622 -> 6607;
6623 -> 6608;
6623 -> 6612;
6623 -> 6607;
6624 -> 6609;
6624 -> 6612;
6624 -> 6607;
6625 -> 6607;
6626 -> 6609;
6626 -> 6625;
6626 -> 6607;
6627 -> 6610;
6627 -> 6626;
6627 -> 6607;
6628 -> 6627;
6628 -> 6612;
6628 -> 6607;
6629 -> 6602;
6629 -> 6591;
6630 -> 6602;
6630 -> 6591;
6631 -> 6602;
6631 -> 6591;
6632 -> 6602;
6632 -> 6591;
6633 -> 6602;
6633 -> 6591;
6634 -> 6602;
6634 -> 6591;
6635 -> 6591;
6636 -> 6592;
6636 -> 6635;
6636 -> 6591;
6637 -> 6591;
6638 -> 6593;
6638 -> 6637;
6638 -> 6591;
6639 -> 6591;
6640 -> 6600;
6640 -> 6639;
6640 -> 6591;
6641 -> 6593;
6641 -> 6602;
6641 -> 6591;
6642 -> 6592;
6642 -> 6602;
6642 -> 6591;
6643 -> 6597;
6643 -> 6602;
6643 -> 6591;
6644 -> 6598;
6644 -> 6602;
6644 -> 6591;
6645 -> 6599;
6645 -> 6602;
6645 -> 6591;
6646 -> 6600;
6646 -> 6602;
6646 -> 6591;
6647 -> 6432;
6648 -> 6564;
6648 -> 6647;
6648 -> 6432;
6649 -> 6564;
6649 -> 6432;
6650 -> 6649;
6651 -> 6650;
6651 -> 6432;
6652 -> 6650;
6652 -> 6432;
6653 -> 6432;
6654 -> 6564;
6654 -> 6653;
6654 -> 6432;
6655 -> 6564;
6655 -> 6432;
6656 -> 6432;
6657 -> 6655;
6657 -> 6656;
6658 -> 6656;
6659 -> 6657;
6659 -> 6658;
6660 -> 0;
6660 -> 6658;
6661 -> 6660;
6661 -> 6656;
6662 -> 6661;
6662 -> 6657;
6662 -> 6656;
6663 -> 6662;
6664 -> 2864;
6664 -> 6432;
6665 -> 6432;
6666 -> 6663;
6666 -> 6665;
6666 -> 6432;
6667 -> 6666;
6668 -> 2860;
6668 -> 6667;
6668 -> 6432;
6669 -> 6668;
6670 -> 6432;
6671 -> 6669;
6671 -> 6670;
6671 -> 6432;
6672 -> 6567;
6673 -> 6567;
6674 -> 6567;
6675 -> 6567;
6676 -> 6567;
6677 -> 6567;
6678 -> 6567;
6679 -> 6567;
6680 -> 6567;
6681 -> 6567;
6682 -> 6567;
6683 -> 6567;
6684 -> 6567;
6685 -> 6567;
6686 -> 6567;
6687 -> 6567;
6688 -> 6567;
6689 -> 6688;
6689 -> 6567;
6690 -> 6689;
6690 -> 6567;
6691 -> 6567;
6692 -> 6567;
6693 -> 6567;
6694 -> 6567;
6695 -> 6567;
6696 -> 6567;
6697 -> 6567;
6698 -> 6567;
6699 -> 6567;
6700 -> 6567;
6701 -> 6567;
6702 -> 6700;
6702 -> 6567;
6703 -> 6567;
6704 -> 6686;
6704 -> 6703;
6704 -> 6567;
6705 -> 6567;
6706 -> 6681;
6706 -> 6705;
6706 -> 6567;
6707 -> 6567;
6708 -> 6567;
6709 -> 6567;
6710 -> 6567;
6711 -> 6567;
6712 -> 6567;
6713 -> 6567;
6714 -> 6567;
6715 -> 6567;
6716 -> 6567;
6716 -> 6715;
6717 -> 6715;
6717 -> 6567;
6718 -> 6567;
6719 -> 6718;
6719 -> 6567;
6720 -> 6567;
6721 -> 6720;
6721 -> 6567;
6722 -> 6567;
6723 -> 6722;
6724 -> 6567;
6725 -> 6567;
6726 -> 6567;
6727 -> 6567;
6728 -> 6726;
6728 -> 6567;
6729 -> 6728;
6730 -> 6728;
6731 -> 6567;
6732 -> 6567;
6733 -> 6567;
6734 -> 0;
6734 -> 6567;
6735 -> 6567;
6736 -> 6567;
6737 -> 6735;
6737 -> 6567;
6738 -> 6567;
6739 -> 6737;
6739 -> 6738;
6739 -> 6567;
6740 -> 6736;
6740 -> 6567;
6740 -> 0;
6741 -> 6737;
6741 -> 6567;
6742 -> 6741;
6742 -> 6567;
6743 -> 6741;
6743 -> 6567;
6744 -> 6567;
6745 -> 6744;
6745 -> 6567;
6746 -> 6567;
6747 -> 6567;
6747 -> 6746;
6748 -> 6746;
6749 -> 6567;
6750 -> 6567;
6751 -> 6567;
6751 -> 6750;
6752 -> 6750;
6753 -> 6751;
6753 -> 6567;
6753 -> 6752;
6754 -> 6753;
6754 -> 6750;
6755 -> 6754;
6755 -> 6567;
6756 -> 6567;
6757 -> 6755;
6757 -> 6567;
6758 -> 6567;
6759 -> 6756;
6759 -> 6567;
6760 -> 6757;
6760 -> 6567;
6761 -> 6758;
6761 -> 6567;
6762 -> 6759;
6762 -> 6567;
6763 -> 6760;
6763 -> 6567;
6764 -> 6762;
6764 -> 6567;
6765 -> 6761;
6765 -> 6567;
6766 -> 6763;
6766 -> 6567;
6767 -> 6764;
6767 -> 6567;
6768 -> 6765;
6768 -> 6567;
6769 -> 6567;
6770 -> 6766;
6770 -> 6567;
6771 -> 6567;
6772 -> 6567;
6773 -> 6567;
6774 -> 6767;
6774 -> 6567;
6775 -> 6567;
6776 -> 6768;
6776 -> 6567;
6777 -> 6567;
6778 -> 6770;
6778 -> 6769;
6779 -> 6771;
6779 -> 6769;
6780 -> 6567;
6780 -> 6769;
6781 -> 6567;
6781 -> 6769;
6782 -> 6772;
6782 -> 6769;
6783 -> 6773;
6783 -> 6769;
6784 -> 6774;
6784 -> 6769;
6785 -> 6775;
6785 -> 6769;
6786 -> 6776;
6786 -> 6769;
6787 -> 6777;
6787 -> 6769;
6788 -> 6769;
6789 -> 6780;
6789 -> 6769;
6790 -> 6781;
6790 -> 6769;
6791 -> 6782;
6791 -> 6769;
6792 -> 6787;
6792 -> 6769;
6793 -> 6789;
6793 -> 6788;
6794 -> 6790;
6794 -> 6788;
6795 -> 6791;
6795 -> 6788;
6796 -> 6792;
6796 -> 6788;
6797 -> 6788;
6798 -> 6796;
6798 -> 6788;
6799 -> 6798;
6799 -> 6797;
6800 -> 6797;
6801 -> 6797;
6801 -> 6788;
6802 -> 6797;
6802 -> 6788;
6803 -> 6797;
6803 -> 6788;
6804 -> 6788;
6805 -> 6793;
6805 -> 6804;
6805 -> 6788;
6806 -> 6793;
6806 -> 6797;
6806 -> 6788;
6807 -> 6794;
6807 -> 6797;
6807 -> 6788;
6808 -> 6788;
6809 -> 6794;
6809 -> 6808;
6809 -> 6788;
6810 -> 6795;
6810 -> 6809;
6810 -> 6788;
6811 -> 6810;
6811 -> 6797;
6811 -> 6788;
6812 -> 6788;
6812 -> 6769;
6813 -> 6788;
6813 -> 6769;
6814 -> 6788;
6814 -> 6769;
6815 -> 6788;
6815 -> 6769;
6816 -> 6788;
6816 -> 6769;
6817 -> 6788;
6817 -> 6769;
6818 -> 6769;
6819 -> 6778;
6819 -> 6818;
6819 -> 6769;
6820 -> 6769;
6821 -> 6779;
6821 -> 6820;
6821 -> 6769;
6822 -> 6769;
6823 -> 6786;
6823 -> 6822;
6823 -> 6769;
6824 -> 6779;
6824 -> 6788;
6824 -> 6769;
6825 -> 6778;
6825 -> 6788;
6825 -> 6769;
6826 -> 6783;
6826 -> 6788;
6826 -> 6769;
6827 -> 6784;
6827 -> 6788;
6827 -> 6769;
6828 -> 6785;
6828 -> 6788;
6828 -> 6769;
6829 -> 6786;
6829 -> 6788;
6829 -> 6769;
6830 -> 6567;
6830 -> 6647;
6830 -> 6432;
6831 -> 6567;
6831 -> 6432;
6832 -> 6831;
6833 -> 6832;
6833 -> 6432;
6834 -> 6832;
6834 -> 6432;
6835 -> 6567;
6835 -> 6653;
6835 -> 6432;
6836 -> 6567;
6836 -> 6432;
6837 -> 6836;
6837 -> 6656;
6838 -> 6837;
6838 -> 6658;
6839 -> 6661;
6839 -> 6837;
6839 -> 6656;
6840 -> 6839;
6841 -> 6840;
6841 -> 6665;
6841 -> 6432;
6842 -> 6841;
6843 -> 2860;
6843 -> 6842;
6843 -> 6432;
6844 -> 6843;
6845 -> 6844;
6845 -> 6670;
6845 -> 6432;
6846 -> 6567;
6847 -> 6567;
6847 -> 6846;
6848 -> 6846;
6849 -> 6848;
6849 -> 6567;
6850 -> 6567;
6851 -> 6567;
6852 -> 6567;
6853 -> 6567;
6854 -> 6736;
6854 -> 6567;
6855 -> 6854;
6855 -> 6567;
6856 -> 6855;
6856 -> 6738;
6856 -> 6567;
6857 -> 6855;
6857 -> 6567;
6858 -> 6857;
6858 -> 6567;
6859 -> 6736;
6860 -> 6736;
6861 -> 6736;
6862 -> 6861;
6863 -> 6736;
6864 -> 6736;
6865 -> 6736;
6866 -> 6865;
6866 -> 6736;
6867 -> 6736;
6868 -> 6866;
6868 -> 6867;
6868 -> 6736;
6869 -> 6736;
6869 -> 0;
6870 -> 6866;
6870 -> 6736;
6871 -> 6870;
6871 -> 6736;
6872 -> 6870;
6872 -> 6736;
6873 -> 6736;
6874 -> 6873;
6874 -> 6736;
6875 -> 6567;
6875 -> 6736;
6876 -> 6875;
6876 -> 6736;
6877 -> 6736;
6878 -> 6736;
6879 -> 6736;
6880 -> 6736;
6881 -> 6736;
6882 -> 6736;
6883 -> 6881;
6883 -> 6882;
6883 -> 6736;
6884 -> 6751;
6884 -> 6736;
6884 -> 6752;
6885 -> 6884;
6885 -> 6750;
6886 -> 6885;
6886 -> 6567;
6887 -> 6886;
6887 -> 6567;
6888 -> 6887;
6888 -> 6567;
6889 -> 6888;
6889 -> 6567;
6890 -> 6889;
6890 -> 6567;
6891 -> 6890;
6891 -> 6567;
6892 -> 6891;
6892 -> 6769;
6893 -> 6892;
6893 -> 6818;
6893 -> 6769;
6894 -> 6892;
6894 -> 6788;
6894 -> 6769;
6895 -> 6567;
6896 -> 6567;
6897 -> 6896;
6898 -> 6897;
6898 -> 6567;
6899 -> 6897;
6899 -> 6567;
6900 -> 6567;
6901 -> 6567;
6902 -> 6567;
6903 -> 6901;
6903 -> 6902;
6904 -> 6902;
6905 -> 6903;
6905 -> 6904;
6906 -> 0;
6906 -> 6904;
6907 -> 6906;
6907 -> 6902;
6908 -> 6907;
6908 -> 6903;
6908 -> 6902;
6909 -> 6908;
6910 -> 2864;
6910 -> 6567;
6911 -> 6567;
6912 -> 6909;
6912 -> 6911;
6912 -> 6567;
6913 -> 6912;
6914 -> 2860;
6914 -> 6913;
6914 -> 6567;
6915 -> 6914;
6916 -> 6567;
6917 -> 6915;
6917 -> 6916;
6917 -> 6567;
6918 -> 6736;
6919 -> 6736;
6919 -> 6918;
6920 -> 6918;
6921 -> 6920;
6921 -> 6736;
6922 -> 6736;
6923 -> 6736;
6924 -> 6736;
6925 -> 6736;
6926 -> 6736;
6927 -> 6736;
6928 -> 6736;
6929 -> 6736;
6930 -> 6736;
6931 -> 6736;
6932 -> 6736;
6933 -> 6736;
6934 -> 6736;
6935 -> 6736;
6936 -> 6736;
6937 -> 6736;
6938 -> 6736;
6939 -> 6736;
6940 -> 6939;
6940 -> 6736;
6941 -> 6940;
6941 -> 6736;
6942 -> 6736;
6943 -> 6736;
6944 -> 6736;
6945 -> 6736;
6946 -> 6736;
6947 -> 6736;
6948 -> 6736;
6949 -> 6736;
6950 -> 6736;
6951 -> 6736;
6952 -> 6736;
6953 -> 6951;
6953 -> 6736;
6954 -> 6736;
6955 -> 6937;
6955 -> 6954;
6955 -> 6736;
6956 -> 6736;
6957 -> 6736;
6958 -> 6736;
6959 -> 6736;
6960 -> 6736;
6961 -> 6736;
6962 -> 6736;
6963 -> 6736;
6963 -> 6962;
6964 -> 6962;
6964 -> 6736;
6965 -> 6736;
6966 -> 6965;
6966 -> 6736;
6967 -> 6736;
6968 -> 6967;
6968 -> 6736;
6969 -> 6736;
6970 -> 6736;
6971 -> 6969;
6971 -> 6736;
6972 -> 6971;
6973 -> 6971;
6974 -> 6736;
6975 -> 0;
6975 -> 6736;
6976 -> 6736;
6977 -> 6736;
6977 -> 6976;
6978 -> 6976;
6979 -> 6736;
6980 -> 6736;
6981 -> 6736;
6981 -> 6980;
6982 -> 6980;
6983 -> 6981;
6983 -> 6736;
6983 -> 6982;
6984 -> 6983;
6984 -> 6980;
6985 -> 6984;
6985 -> 6736;
6986 -> 6736;
6987 -> 6985;
6987 -> 6736;
6988 -> 6736;
6989 -> 6986;
6989 -> 6736;
6990 -> 6987;
6990 -> 6736;
6991 -> 6988;
6991 -> 6736;
6992 -> 6989;
6992 -> 6736;
6993 -> 6990;
6993 -> 6736;
6994 -> 6992;
6994 -> 6736;
6995 -> 6991;
6995 -> 6736;
6996 -> 6993;
6996 -> 6736;
6997 -> 6994;
6997 -> 6736;
6998 -> 6995;
6998 -> 6736;
6999 -> 6736;
7000 -> 6996;
7000 -> 6736;
7001 -> 6736;
7002 -> 6736;
7003 -> 6736;
7004 -> 6997;
7004 -> 6736;
7005 -> 6736;
7006 -> 6998;
7006 -> 6736;
7007 -> 6736;
7008 -> 7000;
7008 -> 6999;
7009 -> 7001;
7009 -> 6999;
7010 -> 6736;
7010 -> 6999;
7011 -> 6736;
7011 -> 6999;
7012 -> 7002;
7012 -> 6999;
7013 -> 7003;
7013 -> 6999;
7014 -> 7004;
7014 -> 6999;
7015 -> 7005;
7015 -> 6999;
7016 -> 7006;
7016 -> 6999;
7017 -> 7007;
7017 -> 6999;
7018 -> 6999;
7019 -> 7010;
7019 -> 6999;
7020 -> 7011;
7020 -> 6999;
7021 -> 7012;
7021 -> 6999;
7022 -> 7017;
7022 -> 6999;
7023 -> 7019;
7023 -> 7018;
7024 -> 7020;
7024 -> 7018;
7025 -> 7021;
7025 -> 7018;
7026 -> 7022;
7026 -> 7018;
7027 -> 7018;
7028 -> 7026;
7028 -> 7018;
7029 -> 7028;
7029 -> 7027;
7030 -> 7027;
7031 -> 7027;
7031 -> 7018;
7032 -> 7027;
7032 -> 7018;
7033 -> 7027;
7033 -> 7018;
7034 -> 7018;
7035 -> 7023;
7035 -> 7034;
7035 -> 7018;
7036 -> 7023;
7036 -> 7027;
7036 -> 7018;
7037 -> 7024;
7037 -> 7027;
7037 -> 7018;
7038 -> 7018;
7039 -> 7024;
7039 -> 7038;
7039 -> 7018;
7040 -> 7025;
7040 -> 7039;
7040 -> 7018;
7041 -> 7040;
7041 -> 7027;
7041 -> 7018;
7042 -> 7018;
7042 -> 6999;
7043 -> 7018;
7043 -> 6999;
7044 -> 7018;
7044 -> 6999;
7045 -> 7018;
7045 -> 6999;
7046 -> 7018;
7046 -> 6999;
7047 -> 7018;
7047 -> 6999;
7048 -> 6999;
7049 -> 7008;
7049 -> 7048;
7049 -> 6999;
7050 -> 6999;
7051 -> 7009;
7051 -> 7050;
7051 -> 6999;
7052 -> 6999;
7053 -> 7016;
7053 -> 7052;
7053 -> 6999;
7054 -> 7009;
7054 -> 7018;
7054 -> 6999;
7055 -> 7008;
7055 -> 7018;
7055 -> 6999;
7056 -> 7013;
7056 -> 7018;
7056 -> 6999;
7057 -> 7014;
7057 -> 7018;
7057 -> 6999;
7058 -> 7015;
7058 -> 7018;
7058 -> 6999;
7059 -> 7016;
7059 -> 7018;
7059 -> 6999;
7060 -> 6736;
7061 -> 6736;
7062 -> 7061;
7063 -> 7062;
7063 -> 6736;
7064 -> 7062;
7064 -> 6736;
7065 -> 6736;
7066 -> 6736;
7067 -> 6736;
7068 -> 7066;
7068 -> 7067;
7069 -> 7067;
7070 -> 7068;
7070 -> 7069;
7071 -> 0;
7071 -> 7069;
7072 -> 7071;
7072 -> 7067;
7073 -> 7072;
7073 -> 7068;
7073 -> 7067;
7074 -> 7073;
7075 -> 2864;
7075 -> 6736;
7076 -> 6736;
7077 -> 7074;
7077 -> 7076;
7077 -> 6736;
7078 -> 7077;
7079 -> 2860;
7079 -> 7078;
7079 -> 6736;
7080 -> 7079;
7081 -> 6736;
7082 -> 7080;
7082 -> 7081;
7082 -> 6736;
7083 -> 6736;
7084 -> 4688;
7084 -> 6736;
7085 -> 6736;
7086 -> 7085;
7086 -> 6736;
7087 -> 7086;
7087 -> 6736;
7088 -> 7087;
7088 -> 6736;
7089 -> 7088;
7089 -> 6736;
7090 -> 7089;
7090 -> 6736;
7091 -> 7090;
7091 -> 6999;
7092 -> 7091;
7092 -> 7048;
7092 -> 6999;
7093 -> 7091;
7093 -> 7018;
7093 -> 6999;
7094 -> 7083;
7095 -> 7083;
7095 -> 7094;
7096 -> 7094;
7097 -> 7096;
7097 -> 7083;
7098 -> 7083;
7099 -> 7083;
7100 -> 7083;
7101 -> 7083;
7102 -> 7083;
7103 -> 7083;
7104 -> 7083;
7105 -> 7083;
7106 -> 7083;
7107 -> 7083;
7108 -> 7083;
7109 -> 7083;
7110 -> 7083;
7111 -> 7083;
7112 -> 7083;
7113 -> 7083;
7114 -> 7083;
7115 -> 7083;
7116 -> 7083;
7117 -> 7083;
7118 -> 7083;
7119 -> 7118;
7119 -> 7083;
7120 -> 7119;
7120 -> 7083;
7121 -> 7083;
7122 -> 7083;
7123 -> 7083;
7124 -> 7083;
7125 -> 7083;
7126 -> 7083;
7127 -> 7083;
7128 -> 7083;
7129 -> 7083;
7130 -> 7083;
7131 -> 7083;
7132 -> 7130;
7132 -> 7083;
7133 -> 7083;
7134 -> 7116;
7134 -> 7133;
7134 -> 7083;
7135 -> 7083;
7136 -> 7111;
7136 -> 7135;
7136 -> 7083;
7137 -> 7083;
7138 -> 7083;
7139 -> 7083;
7140 -> 7083;
7141 -> 7083;
7142 -> 7083;
7143 -> 7083;
7144 -> 4688;
7144 -> 7083;
7145 -> 7083;
7146 -> 7083;
7147 -> 7145;
7147 -> 7083;
7148 -> 7083;
7149 -> 7146;
7149 -> 7083;
7150 -> 7147;
7150 -> 7083;
7151 -> 7148;
7151 -> 7083;
7152 -> 7149;
7152 -> 7083;
7153 -> 7150;
7153 -> 7083;
7154 -> 7152;
7154 -> 7083;
7155 -> 7151;
7155 -> 7083;
7156 -> 7153;
7156 -> 7083;
7157 -> 7154;
7157 -> 7083;
7158 -> 7155;
7158 -> 7083;
7159 -> 7083;
7160 -> 7156;
7160 -> 7083;
7161 -> 7083;
7162 -> 7083;
7163 -> 7083;
7164 -> 7157;
7164 -> 7083;
7165 -> 7083;
7166 -> 7158;
7166 -> 7083;
7167 -> 7083;
7168 -> 7160;
7168 -> 7159;
7169 -> 7161;
7169 -> 7159;
7170 -> 7083;
7170 -> 7159;
7171 -> 7083;
7171 -> 7159;
7172 -> 7162;
7172 -> 7159;
7173 -> 7163;
7173 -> 7159;
7174 -> 7164;
7174 -> 7159;
7175 -> 7165;
7175 -> 7159;
7176 -> 7166;
7176 -> 7159;
7177 -> 7167;
7177 -> 7159;
7178 -> 7159;
7179 -> 7170;
7179 -> 7159;
7180 -> 7171;
7180 -> 7159;
7181 -> 7172;
7181 -> 7159;
7182 -> 7177;
7182 -> 7159;
7183 -> 7179;
7183 -> 7178;
7184 -> 7180;
7184 -> 7178;
7185 -> 7181;
7185 -> 7178;
7186 -> 7182;
7186 -> 7178;
7187 -> 7178;
7188 -> 7186;
7188 -> 7178;
7189 -> 7188;
7189 -> 7187;
7190 -> 7187;
7191 -> 7187;
7191 -> 7178;
7192 -> 7187;
7192 -> 7178;
7193 -> 7187;
7193 -> 7178;
7194 -> 7178;
7195 -> 7183;
7195 -> 7194;
7195 -> 7178;
7196 -> 7183;
7196 -> 7187;
7196 -> 7178;
7197 -> 7184;
7197 -> 7187;
7197 -> 7178;
7198 -> 7178;
7199 -> 7184;
7199 -> 7198;
7199 -> 7178;
7200 -> 7185;
7200 -> 7199;
7200 -> 7178;
7201 -> 7200;
7201 -> 7187;
7201 -> 7178;
7202 -> 7178;
7202 -> 7159;
7203 -> 7178;
7203 -> 7159;
7204 -> 7178;
7204 -> 7159;
7205 -> 7178;
7205 -> 7159;
7206 -> 7178;
7206 -> 7159;
7207 -> 7178;
7207 -> 7159;
7208 -> 7159;
7209 -> 7168;
7209 -> 7208;
7209 -> 7159;
7210 -> 7159;
7211 -> 7169;
7211 -> 7210;
7211 -> 7159;
7212 -> 7159;
7213 -> 7176;
7213 -> 7212;
7213 -> 7159;
7214 -> 7169;
7214 -> 7178;
7214 -> 7159;
7215 -> 7168;
7215 -> 7178;
7215 -> 7159;
7216 -> 7173;
7216 -> 7178;
7216 -> 7159;
7217 -> 7174;
7217 -> 7178;
7217 -> 7159;
7218 -> 7175;
7218 -> 7178;
7218 -> 7159;
7219 -> 7176;
7219 -> 7178;
7219 -> 7159;
7220 -> 7083;
7221 -> 7083;
7222 -> 7221;
7223 -> 7222;
7223 -> 7083;
7224 -> 7222;
7224 -> 7083;
7225 -> 7083;
7226 -> 7083;
7227 -> 7083;
7228 -> 7226;
7228 -> 7227;
7229 -> 7227;
7230 -> 7228;
7230 -> 7229;
7231 -> 0;
7231 -> 7229;
7232 -> 7231;
7232 -> 7227;
7233 -> 7232;
7233 -> 7228;
7233 -> 7227;
7234 -> 7233;
7235 -> 2864;
7235 -> 7083;
7236 -> 7083;
7237 -> 7234;
7237 -> 7236;
7237 -> 7083;
7238 -> 7237;
7239 -> 2860;
7239 -> 7238;
7239 -> 7083;
7240 -> 7239;
7241 -> 7083;
7242 -> 7240;
7242 -> 7241;
7242 -> 7083;
7243 -> 4882;
7243 -> 7083;
7244 -> 6462;
7244 -> 7083;
7245 -> 2832;
7246 -> 7244;
7246 -> 7245;
7246 -> 2832;
7251 -> 7247;
7251 -> 7250;
7252 -> 7248;
7252 -> 7250;
7253 -> 7249;
7253 -> 7250;
7254 -> 7250;
7255 -> 0;
7256 -> 7255;
7257 -> 0;
7258 -> 7257;
7259 -> 0;
7260 -> 7259;
7261 -> 0;
7262 -> 7261;
7263 -> 7244;
7263 -> 2832;
7264 -> 2832;
7265 -> 7263;
7265 -> 7264;
7266 -> 7264;
7267 -> 7265;
7267 -> 7266;
7267 -> 7264;
7268 -> 7264;
7269 -> 7265;
7269 -> 7268;
7270 -> 0;
7270 -> 7268;
7271 -> 7270;
7271 -> 7264;
7272 -> 7271;
7272 -> 2832;
7273 -> 7246;
7273 -> 7272;
7273 -> 2832;
7274 -> 7273;
7274 -> 2832;
7275 -> 7274;
7275 -> 2809;
7276 -> 2797;
7276 -> 7243;
7276 -> 2807;
7276 -> 2809;
7277 -> 7274;
7277 -> 2809;
7278 -> 2809;
7279 -> 7276;
7279 -> 7277;
7279 -> 7278;
7279 -> 7243;
7279 -> 2809;
7280 -> 7279;
7281 -> 2797;
7281 -> 7280;
7282 -> 7281;
7282 -> 7279;
7282 -> 7280;
7283 -> 7282;
7283 -> 7279;
7284 -> 2822;
7284 -> 7279;
7285 -> 7283;
7285 -> 7284;
7285 -> 7279;
7285 -> 2815;
7286 -> 2822;
7286 -> 7285;
7286 -> 2809;
7287 -> 2797;
7287 -> 7286;
7287 -> 2807;
7287 -> 2795;
7288 -> 2793;
7289 -> 7287;
7289 -> 7288;
7289 -> 2793;
7290 -> 7287;
7290 -> 2793;
7292 -> 7291;
7294 -> 7293;
7296 -> 7295;
7299 -> 7298;
7300 -> 0;
7301 -> 0;
7302 -> 0;
7303 -> 7302;
7305 -> 7300;
7305 -> 7301;
7305 -> 7303;
7305 -> 7304;
7306 -> 7305;
7308 -> 7307;
7310 -> 7309;
7312 -> 7311;
7314 -> 7313;
7315 -> 2777;
7315 -> 7290;
7316 -> 0;
7316 -> 7290;
7317 -> 2778;
7317 -> 7290;
7318 -> 7290;
7319 -> 7290;
7320 -> 7315;
7320 -> 7319;
7321 -> 7316;
7321 -> 7319;
7322 -> 7317;
7322 -> 7319;
7323 -> 7316;
7323 -> 7319;
7324 -> 7318;
7324 -> 7319;
7325 -> 7319;
7326 -> 7323;
7326 -> 7325;
7326 -> 7319;
7327 -> 7324;
7327 -> 7325;
7327 -> 7319;
7328 -> 7326;
7328 -> 7327;
7328 -> 7319;
7329 -> 7321;
7329 -> 7319;
7330 -> 7320;
7330 -> 7319;
7331 -> 7321;
7331 -> 7319;
7332 -> 7322;
7332 -> 7319;
7333 -> 7323;
7333 -> 7319;
7334 -> 7324;
7334 -> 7319;
7335 -> 7329;
7335 -> 7319;
7336 -> 7319;
7337 -> 7330;
7337 -> 7336;
7338 -> 7331;
7338 -> 7336;
7339 -> 7332;
7339 -> 7336;
7340 -> 7333;
7340 -> 7336;
7341 -> 7334;
7341 -> 7336;
7342 -> 7335;
7342 -> 7336;
7343 -> 7336;
7344 -> 7341;
7344 -> 7343;
7344 -> 7336;
7345 -> 7340;
7345 -> 7343;
7345 -> 7336;
7346 -> 7344;
7346 -> 7345;
7346 -> 7336;
7347 -> 7336;
7348 -> 7337;
7348 -> 7336;
7349 -> 7338;
7349 -> 7336;
7350 -> 7347;
7350 -> 7336;
7351 -> 7342;
7351 -> 7336;
7352 -> 7336;
7353 -> 7348;
7353 -> 7352;
7354 -> 7349;
7354 -> 7352;
7355 -> 7350;
7355 -> 7352;
7356 -> 7351;
7356 -> 7352;
7357 -> 7354;
7357 -> 7352;
7358 -> 7352;
7359 -> 7357;
7359 -> 7358;
7360 -> 7353;
7360 -> 7358;
7361 -> 7358;
7362 -> 7359;
7362 -> 7361;
7362 -> 7358;
7363 -> 7359;
7363 -> 0;
7363 -> 7358;
7364 -> 7359;
7364 -> 7358;
7365 -> 7360;
7365 -> 7364;
7365 -> 7286;
7365 -> 7358;
7366 -> 7358;
7367 -> 7360;
7367 -> 7365;
7367 -> 7366;
7367 -> 7358;
7368 -> 7367;
7369 -> 0;
7369 -> 7368;
7370 -> 7368;
7371 -> 7370;
7371 -> 7369;
7371 -> 7368;
7372 -> 4436;
7372 -> 7370;
7372 -> 7369;
7372 -> 7371;
7373 -> 7360;
7373 -> 7365;
7373 -> 7368;
7374 -> 7369;
7374 -> 7368;
7375 -> 7368;
7376 -> 7373;
7376 -> 7374;
7376 -> 7375;
7376 -> 7369;
7376 -> 7372;
7376 -> 7365;
7376 -> 7368;
7377 -> 7359;
7377 -> 7367;
7378 -> 7377;
7378 -> 0;
7378 -> 7367;
7379 -> 7378;
7379 -> 7367;
7380 -> 7379;
7381 -> 7380;
7382 -> 7380;
7383 -> 7382;
7383 -> 7376;
7384 -> 7383;
7384 -> 7380;
7385 -> 0;
7385 -> 7380;
7386 -> 7380;
7387 -> 7384;
7387 -> 7386;
7388 -> 7385;
7388 -> 7386;
7389 -> 7387;
7389 -> 7388;
7389 -> 7386;
7390 -> 7380;
7390 -> 7376;
7391 -> 7380;
7391 -> 7376;
7392 -> 7367;
7393 -> 7391;
7393 -> 7367;
7394 -> 7367;
7395 -> 7393;
7395 -> 7394;
7396 -> 7394;
7397 -> 7395;
7397 -> 7396;
7397 -> 7394;
7398 -> 7395;
7398 -> 7394;
7399 -> 7394;
7399 -> 7367;
7400 -> 7391;
7400 -> 7399;
7401 -> 7377;
7401 -> 7399;
7402 -> 7360;
7402 -> 7376;
7402 -> 7399;
7403 -> 7399;
7404 -> 7403;
7405 -> 7404;
7405 -> 7376;
7406 -> 7404;
7406 -> 7376;
7407 -> 7406;
7407 -> 7403;
7408 -> 7403;
7408 -> 7376;
7409 -> 7408;
7409 -> 7399;
7410 -> 7399;
7411 -> 7400;
7411 -> 7410;
7412 -> 7401;
7412 -> 7410;
7413 -> 7402;
7413 -> 7410;
7414 -> 7409;
7414 -> 7410;
7415 -> 7412;
7415 -> 7377;
7415 -> 7410;
7416 -> 7410;
7417 -> 7415;
7417 -> 7416;
7418 -> 7411;
7418 -> 7416;
7419 -> 7416;
7420 -> 7418;
7420 -> 7419;
7421 -> 7419;
7422 -> 7420;
7422 -> 7408;
7422 -> 7421;
7422 -> 7419;
7423 -> 7422;
7424 -> 7420;
7424 -> 7423;
7425 -> 7423;
7426 -> 7424;
7426 -> 7408;
7426 -> 7423;
7427 -> 7426;
7428 -> 7424;
7428 -> 7427;
7429 -> 7427;
7430 -> 7428;
7430 -> 7408;
7430 -> 7429;
7430 -> 7427;
7431 -> 7430;
7432 -> 7430;
7433 -> 7428;
7433 -> 7432;
7434 -> 7432;
7435 -> 7433;
7435 -> 7434;
7436 -> 7434;
7437 -> 7435;
7437 -> 7436;
7438 -> 7436;
7438 -> 7434;
7439 -> 7435;
7439 -> 7432;
7440 -> 7432;
7441 -> 7439;
7441 -> 7440;
7442 -> 7441;
7442 -> 7432;
7443 -> 7432;
7444 -> 7443;
7444 -> 7432;
7445 -> 7433;
7445 -> 7408;
7445 -> 7432;
7446 -> 7442;
7446 -> 7445;
7446 -> 7408;
7446 -> 7432;
7447 -> 7446;
7447 -> 7432;
7448 -> 7432;
7449 -> 7448;
7449 -> 7430;
7450 -> 7431;
7450 -> 7449;
7450 -> 7448;
7450 -> 7430;
7451 -> 7431;
7451 -> 7430;
7452 -> 7430;
7453 -> 7451;
7453 -> 7452;
7454 -> 7452;
7455 -> 7453;
7455 -> 7450;
7455 -> 7454;
7455 -> 7452;
7456 -> 5020;
7456 -> 7455;
7457 -> 7428;
7457 -> 7446;
7457 -> 7430;
7458 -> 7456;
7458 -> 7430;
7459 -> 7430;
7460 -> 7457;
7460 -> 7458;
7460 -> 7459;
7460 -> 5019;
7460 -> 7446;
7460 -> 0;
7460 -> 7430;
7461 -> 7430;
7462 -> 7460;
7462 -> 7461;
7462 -> 7430;
7463 -> 7462;
7464 -> 7463;
7465 -> 7463;
7465 -> 7464;
7466 -> 7464;
7466 -> 7463;
7467 -> 7463;
7467 -> 7462;
7468 -> 7456;
7468 -> 7462;
7469 -> 7462;
7470 -> 7468;
7470 -> 7469;
7471 -> 7467;
7471 -> 7469;
7472 -> 7462;
7473 -> 7431;
7473 -> 7450;
7473 -> 7430;
7474 -> 7426;
7475 -> 7426;
7476 -> 0;
7476 -> 7426;
7477 -> 0;
7477 -> 7426;
7478 -> 0;
7478 -> 7426;
7479 -> 0;
7479 -> 7426;
7480 -> 7426;
7481 -> 7480;
7481 -> 7460;
7482 -> 7481;
7482 -> 7480;
7483 -> 7482;
7483 -> 7426;
7484 -> 7483;
7485 -> 7483;
7486 -> 7484;
7486 -> 7483;
7487 -> 7483;
7488 -> 7486;
7488 -> 7487;
7489 -> 7424;
7489 -> 7487;
7490 -> 7487;
7491 -> 7487;
7492 -> 7489;
7492 -> 7491;
7493 -> 7491;
7494 -> 7492;
7494 -> 7493;
7495 -> 7493;
7495 -> 7491;
7496 -> 7492;
7496 -> 7487;
7497 -> 7487;
7498 -> 7496;
7498 -> 7497;
7499 -> 7498;
7499 -> 7487;
7500 -> 7487;
7501 -> 7487;
7502 -> 7487;
7503 -> 7489;
7503 -> 7502;
7504 -> 7503;
7504 -> 7487;
7505 -> 7489;
7505 -> 7460;
7505 -> 7487;
7506 -> 7499;
7506 -> 7505;
7506 -> 7460;
7506 -> 7487;
7507 -> 7490;
7507 -> 7487;
7508 -> 7507;
7508 -> 7483;
7509 -> 7485;
7509 -> 7483;
7510 -> 7483;
7511 -> 7509;
7511 -> 7510;
7512 -> 7424;
7512 -> 7510;
7513 -> 7510;
7514 -> 7512;
7514 -> 7513;
7515 -> 7514;
7515 -> 7506;
7515 -> 7513;
7516 -> 7513;
7517 -> 7515;
7517 -> 7516;
7518 -> 7516;
7518 -> 7513;
7519 -> 7515;
7519 -> 7510;
7520 -> 7510;
7521 -> 7519;
7521 -> 7520;
7522 -> 7521;
7522 -> 7510;
7523 -> 7510;
7524 -> 7510;
7525 -> 7512;
7525 -> 7524;
7526 -> 7525;
7526 -> 7506;
7526 -> 7524;
7527 -> 7526;
7527 -> 7510;
7528 -> 7512;
7528 -> 7506;
7528 -> 7510;
7529 -> 7522;
7529 -> 7528;
7529 -> 7506;
7529 -> 7510;
7530 -> 7522;
7530 -> 7529;
7531 -> 7529;
7532 -> 7519;
7532 -> 7529;
7533 -> 7527;
7533 -> 7530;
7533 -> 7529;
7534 -> 7519;
7534 -> 7533;
7535 -> 7512;
7535 -> 7533;
7536 -> 7529;
7536 -> 7533;
7537 -> 7533;
7538 -> 7533;
7539 -> 7534;
7539 -> 7538;
7540 -> 7535;
7540 -> 7538;
7541 -> 7536;
7541 -> 7538;
7542 -> 7537;
7542 -> 7538;
7544 -> 7543;
7545 -> 7538;
7546 -> 7542;
7546 -> 7545;
7547 -> 7545;
7548 -> 7546;
7548 -> 7545;
7549 -> 7546;
7549 -> 7545;
7550 -> 7542;
7550 -> 7538;
7551 -> 7542;
7551 -> 7538;
7552 -> 7542;
7552 -> 7538;
7553 -> 7542;
7553 -> 7538;
7554 -> 7542;
7554 -> 7538;
7555 -> 7542;
7555 -> 7538;
7556 -> 7542;
7556 -> 7538;
7557 -> 7538;
7558 -> 7539;
7558 -> 7557;
7558 -> 7538;
7559 -> 7538;
7560 -> 7540;
7560 -> 7559;
7560 -> 7538;
7561 -> 7541;
7561 -> 7529;
7561 -> 7538;
7562 -> 7541;
7562 -> 7542;
7562 -> 7538;
7563 -> 7540;
7563 -> 7542;
7563 -> 7538;
7564 -> 7538;
7565 -> 7538;
7566 -> 7538;
7567 -> 7538;
7568 -> 7539;
7568 -> 7567;
7569 -> 7568;
7569 -> 7538;
7570 -> 7541;
7570 -> 7538;
7571 -> 7542;
7571 -> 7550;
7571 -> 7538;
7572 -> 7566;
7572 -> 7538;
7573 -> 7564;
7573 -> 7538;
7574 -> 7565;
7574 -> 7538;
7575 -> 7569;
7575 -> 7570;
7575 -> 7571;
7575 -> 7572;
7575 -> 7573;
7575 -> 7574;
7575 -> 7530;
7575 -> 7529;
7575 -> 7538;
7576 -> 7575;
7576 -> 0;
7576 -> 7538;
7577 -> 7575;
7577 -> 7542;
7577 -> 7538;
7578 -> 7575;
7578 -> 0;
7578 -> 7538;
7579 -> 7575;
7579 -> 7542;
7579 -> 7538;
7580 -> 7537;
7580 -> 7533;
7581 -> 7511;
7581 -> 7580;
7581 -> 7485;
7581 -> 7546;
7581 -> 7548;
7581 -> 7549;
7581 -> 7575;
7581 -> 7563;
7581 -> 7552;
7581 -> 7579;
7581 -> 7577;
7581 -> 7555;
7581 -> 7556;
7581 -> 7562;
7581 -> 7529;
7581 -> 7533;
7582 -> 7529;
7582 -> 7533;
7583 -> 7537;
7583 -> 7533;
7584 -> 7523;
7584 -> 7582;
7584 -> 7583;
7584 -> 7533;
7585 -> 7581;
7586 -> 7581;
7587 -> 7581;
7588 -> 7581;
7589 -> 7581;
7590 -> 7581;
7591 -> 7581;
7591 -> 0;
7592 -> 7581;
7592 -> 0;
7593 -> 7581;
7594 -> 7523;
7594 -> 7593;
7594 -> 7581;
7595 -> 7523;
7595 -> 7510;
7596 -> 7595;
7596 -> 7483;
7597 -> 7483;
7598 -> 7597;
7598 -> 7581;
7599 -> 7598;
7599 -> 7483;
7600 -> 7596;
7600 -> 7483;
7601 -> 7485;
7601 -> 7483;
7602 -> 7483;
7603 -> 7600;
7603 -> 7602;
7604 -> 7601;
7604 -> 7602;
7605 -> 7424;
7605 -> 7602;
7606 -> 7602;
7607 -> 7605;
7607 -> 7606;
7608 -> 7607;
7608 -> 7581;
7608 -> 7606;
7609 -> 7606;
7610 -> 7608;
7610 -> 7609;
7611 -> 7609;
7611 -> 7606;
7612 -> 7608;
7612 -> 7602;
7613 -> 7602;
7614 -> 7612;
7614 -> 7613;
7615 -> 7614;
7615 -> 7602;
7616 -> 7605;
7616 -> 7581;
7616 -> 7602;
7617 -> 7615;
7617 -> 7616;
7617 -> 7581;
7617 -> 7602;
7618 -> 7617;
7619 -> 7615;
7619 -> 7617;
7620 -> 7603;
7620 -> 7617;
7621 -> 7618;
7621 -> 7617;
7622 -> 7617;
7623 -> 7619;
7623 -> 7622;
7624 -> 7620;
7624 -> 7622;
7625 -> 7621;
7625 -> 7622;
7626 -> 7605;
7626 -> 7622;
7627 -> 7625;
7627 -> 7618;
7627 -> 7622;
7628 -> 7622;
7629 -> 7625;
7629 -> 7622;
7630 -> 7628;
7630 -> 7622;
7631 -> 7624;
7631 -> 7629;
7631 -> 7630;
7631 -> 7523;
7631 -> 7618;
7631 -> 7622;
7632 -> 7631;
7632 -> 7622;
7633 -> 7631;
7633 -> 7622;
7634 -> 7615;
7634 -> 7617;
7635 -> 7603;
7635 -> 7617;
7636 -> 7618;
7636 -> 7617;
7637 -> 7617;
7638 -> 7634;
7638 -> 7637;
7639 -> 7635;
7639 -> 7637;
7640 -> 7636;
7640 -> 7637;
7641 -> 7605;
7641 -> 7637;
7642 -> 7640;
7642 -> 7631;
7642 -> 7637;
7643 -> 7642;
7644 -> 7617;
7645 -> 7633;
7645 -> 7644;
7645 -> 7617;
7647 -> 7646;
7648 -> 7612;
7648 -> 7645;
7649 -> 7605;
7649 -> 7645;
7650 -> 7617;
7650 -> 7645;
7651 -> 7633;
7651 -> 7645;
7652 -> 7643;
7652 -> 7645;
7653 -> 7645;
7654 -> 7648;
7654 -> 7653;
7655 -> 7649;
7655 -> 7653;
7656 -> 7650;
7656 -> 7653;
7657 -> 7651;
7657 -> 7653;
7658 -> 7652;
7658 -> 7653;
7659 -> 7653;
7660 -> 7654;
7660 -> 7659;
7660 -> 7653;
7661 -> 7653;
7662 -> 7655;
7662 -> 7661;
7662 -> 7653;
7663 -> 7656;
7663 -> 7617;
7663 -> 7653;
7664 -> 7654;
7664 -> 7653;
7665 -> 7655;
7665 -> 7653;
7666 -> 7653;
7667 -> 7653;
7668 -> 7664;
7668 -> 7667;
7669 -> 7665;
7669 -> 7667;
7670 -> 7666;
7670 -> 7667;
7671 -> 7667;
7672 -> 7668;
7672 -> 7671;
7672 -> 7667;
7673 -> 7653;
7674 -> 7673;
7674 -> 7653;
7675 -> 7653;
7676 -> 7656;
7676 -> 7653;
7677 -> 7673;
7677 -> 7653;
7678 -> 7675;
7678 -> 7653;
7679 -> 7676;
7679 -> 7677;
7679 -> 7678;
7679 -> 7666;
7679 -> 7617;
7679 -> 7668;
7679 -> 7667;
7679 -> 7669;
7679 -> 7674;
7679 -> 7653;
7680 -> 7653;
7681 -> 7679;
7681 -> 7680;
7682 -> 7679;
7682 -> 7680;
7683 -> 7679;
7683 -> 7680;
7684 -> 7680;
7685 -> 7681;
7685 -> 7684;
7686 -> 7685;
7686 -> 7680;
7687 -> 7682;
7687 -> 7680;
7688 -> 7680;
7689 -> 7687;
7689 -> 7688;
7690 -> 7686;
7690 -> 7688;
7691 -> 7688;
7692 -> 7690;
7692 -> 7691;
7693 -> 7692;
7693 -> 7688;
7694 -> 7689;
7694 -> 7688;
7695 -> 7688;
7696 -> 7694;
7696 -> 7695;
7697 -> 7693;
7697 -> 7695;
7698 -> 7695;
7699 -> 7697;
7699 -> 7698;
7700 -> 7699;
7700 -> 7695;
7701 -> 7700;
7702 -> 7700;
7702 -> 7701;
7703 -> 7701;
7704 -> 7702;
7704 -> 7703;
7705 -> 7703;
7706 -> 7704;
7706 -> 7679;
7706 -> 7705;
7706 -> 7703;
7707 -> 7701;
7708 -> 7702;
7708 -> 7679;
7708 -> 7701;
7709 -> 7708;
7709 -> 7700;
7710 -> 7700;
7711 -> 7695;
7712 -> 7697;
7712 -> 7679;
7712 -> 7711;
7712 -> 7695;
7713 -> 7697;
7713 -> 7679;
7713 -> 7696;
7713 -> 7695;
7714 -> 7697;
7714 -> 7679;
7714 -> 7696;
7714 -> 7695;
7715 -> 7653;
7716 -> 7714;
7716 -> 7715;
7716 -> 7653;
7717 -> 7653;
7718 -> 7714;
7718 -> 7717;
7718 -> 7653;
7719 -> 7718;
7719 -> 7714;
7719 -> 7653;
7720 -> 7719;
7720 -> 7653;
7721 -> 7657;
7721 -> 7720;
7722 -> 7658;
7722 -> 7720;
7723 -> 7720;
7724 -> 7720;
7724 -> 7723;
7725 -> 7720;
7725 -> 7723;
7726 -> 7720;
7726 -> 7723;
7727 -> 7721;
7727 -> 7723;
7728 -> 7722;
7728 -> 7723;
7729 -> 7720;
7729 -> 7723;
7730 -> 7720;
7730 -> 7723;
7731 -> 7720;
7731 -> 7723;
7732 -> 7723;
7733 -> 7731;
7733 -> 7732;
7734 -> 7732;
7735 -> 7733;
7735 -> 7732;
7736 -> 7733;
7736 -> 7732;
7737 -> 7731;
7737 -> 7723;
7738 -> 7731;
7738 -> 7723;
7739 -> 7731;
7739 -> 7723;
7740 -> 7731;
7740 -> 7723;
7741 -> 7731;
7741 -> 7723;
7742 -> 7731;
7742 -> 7723;
7743 -> 0;
7743 -> 7731;
7743 -> 7723;
7744 -> 0;
7744 -> 7731;
7744 -> 7723;
7745 -> 7647;
7745 -> 7731;
7745 -> 7723;
7746 -> 7731;
7746 -> 7723;
7747 -> 7725;
7747 -> 7731;
7747 -> 7723;
7748 -> 7723;
7749 -> 7724;
7749 -> 7748;
7750 -> 7749;
7750 -> 7723;
7751 -> 7723;
7752 -> 7723;
7753 -> 7726;
7753 -> 7723;
7754 -> 7731;
7754 -> 7737;
7754 -> 7723;
7755 -> 7751;
7755 -> 7723;
7756 -> 7750;
7756 -> 7753;
7756 -> 7754;
7756 -> 7755;
7756 -> 7714;
7756 -> 7617;
7756 -> 7723;
7757 -> 7727;
7757 -> 7731;
7757 -> 7723;
7758 -> 7728;
7758 -> 7731;
7758 -> 7723;
7759 -> 7726;
7759 -> 7731;
7759 -> 7723;
7760 -> 7723;
7761 -> 7760;
7761 -> 7723;
7762 -> 7723;
7763 -> 7723;
7764 -> 7727;
7764 -> 7763;
7764 -> 7723;
7765 -> 7764;
7765 -> 7723;
7766 -> 7765;
7767 -> 7727;
7767 -> 7766;
7768 -> 7767;
7768 -> 7756;
7768 -> 7766;
7769 -> 7760;
7769 -> 7765;
7770 -> 7762;
7770 -> 7765;
7771 -> 7768;
7771 -> 7769;
7771 -> 7770;
7771 -> 7765;
7771 -> 7730;
7771 -> 7756;
7771 -> 7761;
7772 -> 7771;
7772 -> 7765;
7773 -> 7765;
7774 -> 7771;
7774 -> 7773;
7775 -> 7774;
7775 -> 7765;
7776 -> 7775;
7777 -> 7775;
7777 -> 7776;
7778 -> 7776;
7779 -> 7777;
7779 -> 7778;
7780 -> 7778;
7781 -> 7779;
7781 -> 7771;
7781 -> 7780;
7781 -> 7778;
7782 -> 7776;
7783 -> 7777;
7783 -> 7771;
7783 -> 7776;
7784 -> 7783;
7784 -> 7775;
7785 -> 7775;
7786 -> 7765;
7787 -> 7771;
7787 -> 7786;
7787 -> 7765;
7788 -> 7771;
7788 -> 7765;
7789 -> 7723;
7790 -> 7723;
7791 -> 7728;
7791 -> 7790;
7791 -> 7723;
7792 -> 7791;
7792 -> 7723;
7793 -> 7723;
7794 -> 7792;
7794 -> 7723;
7795 -> 7794;
7795 -> 7723;
7796 -> 7724;
7796 -> 7795;
7797 -> 7731;
7797 -> 7795;
7798 -> 7727;
7798 -> 7795;
7799 -> 7729;
7799 -> 7795;
7800 -> 7771;
7800 -> 7795;
7801 -> 7793;
7801 -> 7795;
7802 -> 7795;
7803 -> 7796;
7803 -> 7802;
7804 -> 7797;
7804 -> 7802;
7805 -> 7798;
7805 -> 7802;
7806 -> 7799;
7806 -> 7802;
7807 -> 7800;
7807 -> 7802;
7808 -> 7801;
7808 -> 7802;
7809 -> 7802;
7810 -> 7802;
7811 -> 7806;
7811 -> 7771;
7811 -> 7810;
7811 -> 7802;
7812 -> 0;
7812 -> 7811;
7813 -> 7812;
7813 -> 7731;
7813 -> 7723;
7814 -> 7723;
7815 -> 7771;
7815 -> 7814;
7815 -> 7723;
7816 -> 7789;
7816 -> 7814;
7816 -> 7723;
7817 -> 7815;
7817 -> 7816;
7817 -> 7723;
7818 -> 7752;
7818 -> 7814;
7818 -> 7723;
7819 -> 7817;
7819 -> 7818;
7819 -> 7723;
7820 -> 7819;
7820 -> 7809;
7820 -> 7723;
7821 -> 7723;
7822 -> 7729;
7822 -> 7771;
7822 -> 7821;
7822 -> 7723;
7823 -> 7822;
7823 -> 7771;
7823 -> 7723;
7824 -> 7723;
7825 -> 7823;
7825 -> 7824;
7826 -> 7825;
7826 -> 7771;
7826 -> 7824;
7827 -> 0;
7827 -> 7826;
7828 -> 7822;
7828 -> 7771;
7828 -> 7723;
7829 -> 0;
7829 -> 7731;
7829 -> 7828;
7830 -> 7822;
7830 -> 7771;
7830 -> 7723;
7831 -> 7830;
7831 -> 7723;
7832 -> 7827;
7832 -> 0;
7832 -> 7723;
7833 -> 7726;
7833 -> 7723;
7834 -> 7724;
7834 -> 7723;
7835 -> 7731;
7835 -> 7829;
7835 -> 7723;
7836 -> 7723;
7837 -> 7831;
7837 -> 7836;
7838 -> 7832;
7838 -> 7836;
7839 -> 7833;
7839 -> 7836;
7840 -> 7834;
7840 -> 7836;
7841 -> 7835;
7841 -> 7836;
7842 -> 7836;
7843 -> 7837;
7843 -> 7842;
7843 -> 7836;
7844 -> 7836;
7845 -> 7844;
7845 -> 7836;
7846 -> 7836;
7847 -> 7840;
7847 -> 7846;
7848 -> 7847;
7848 -> 7771;
7848 -> 7846;
7849 -> 7848;
7849 -> 7836;
7850 -> 7839;
7850 -> 7836;
7851 -> 7844;
7851 -> 7836;
7852 -> 7849;
7852 -> 7850;
7852 -> 7851;
7852 -> 7771;
7852 -> 7617;
7852 -> 7845;
7852 -> 7836;
7853 -> 7837;
7853 -> 7836;
7854 -> 7853;
7854 -> 7723;
7855 -> 7726;
7855 -> 7723;
7856 -> 7724;
7856 -> 7723;
7857 -> 7723;
7858 -> 7854;
7858 -> 7857;
7859 -> 7855;
7859 -> 7857;
7860 -> 7856;
7860 -> 7857;
7861 -> 7857;
7862 -> 7860;
7862 -> 7861;
7863 -> 7862;
7863 -> 7852;
7863 -> 7861;
7864 -> 7863;
7864 -> 7857;
7865 -> 7859;
7865 -> 7857;
7866 -> 7857;
7867 -> 7864;
7867 -> 7865;
7867 -> 7866;
7867 -> 7852;
7867 -> 7617;
7867 -> 7857;
7868 -> 7867;
7868 -> 7857;
7869 -> 7858;
7869 -> 7868;
7870 -> 7869;
7870 -> 7723;
7871 -> 7731;
7871 -> 7747;
7871 -> 7723;
7872 -> 7723;
7873 -> 7870;
7873 -> 7872;
7874 -> 7871;
7874 -> 7872;
7875 -> 7873;
7875 -> 7872;
7876 -> 7874;
7876 -> 7872;
7877 -> 7872;
7878 -> 7872;
7879 -> 7875;
7879 -> 7878;
7880 -> 7876;
7880 -> 7878;
7881 -> 7877;
7881 -> 7878;
7882 -> 7878;
7883 -> 7879;
7883 -> 7882;
7884 -> 7883;
7884 -> 7878;
7885 -> 7878;
7886 -> 7878;
7887 -> 7886;
7887 -> 7872;
7888 -> 7873;
7888 -> 7887;
7889 -> 0;
7890 -> 0;
7891 -> 0;
7892 -> 7891;
7894 -> 7889;
7894 -> 7890;
7894 -> 7892;
7894 -> 7893;
7895 -> 7894;
7896 -> 0;
7897 -> 0;
7898 -> 0;
7899 -> 7898;
7899 -> 0;
7900 -> 7899;
7902 -> 7896;
7902 -> 7897;
7902 -> 7900;
7902 -> 7901;
7903 -> 7902;
7904 -> 7888;
7904 -> 7723;
7905 -> 7827;
7905 -> 7723;
7906 -> 7723;
7907 -> 7723;
7908 -> 7904;
7908 -> 7907;
7909 -> 7906;
7909 -> 7907;
7910 -> 7905;
7910 -> 7907;
7911 -> 7908;
7911 -> 7907;
7912 -> 7909;
7912 -> 0;
7912 -> 7907;
7913 -> 7909;
7913 -> 7907;
7914 -> 7908;
7914 -> 7913;
7915 -> 7913;
7916 -> 7914;
7916 -> 7915;
7917 -> 7915;
7918 -> 7916;
7918 -> 7917;
7919 -> 7917;
7920 -> 7918;
7920 -> 7919;
7921 -> 7919;
7922 -> 7920;
7922 -> 7921;
7923 -> 7922;
7923 -> 7921;
7924 -> 7923;
7924 -> 7919;
7925 -> 7924;
7925 -> 7917;
7926 -> 7925;
7926 -> 7915;
7927 -> 7915;
7928 -> 7926;
7928 -> 7927;
7929 -> 7908;
7929 -> 7907;
7930 -> 7909;
7930 -> 7907;
7931 -> 7910;
7931 -> 7907;
7932 -> 7907;
7933 -> 7929;
7933 -> 7932;
7934 -> 7930;
7934 -> 7932;
7935 -> 7931;
7935 -> 7932;
7936 -> 0;
7938 -> 7936;
7938 -> 7937;
7939 -> 7937;
7940 -> 7939;
7941 -> 7938;
7941 -> 0;
7941 -> 7937;
7942 -> 7938;
7942 -> 7939;
7942 -> 7937;
7943 -> 7937;
7944 -> 7933;
7944 -> 7932;
7945 -> 7934;
7945 -> 7932;
7946 -> 7935;
7946 -> 7932;
7947 -> 7932;
7948 -> 7946;
7948 -> 7947;
7949 -> 7948;
7949 -> 7931;
7949 -> 7947;
7950 -> 7943;
7950 -> 7949;
7951 -> 7932;
7952 -> 7932;
7953 -> 7944;
7953 -> 7952;
7954 -> 7945;
7954 -> 7952;
7955 -> 7950;
7955 -> 7952;
7956 -> 7951;
7956 -> 7952;
7957 -> 7953;
7957 -> 7952;
7958 -> 7957;
7958 -> 7952;
7959 -> 7953;
7959 -> 7958;
7960 -> 7958;
7961 -> 7959;
7961 -> 7960;
7962 -> 7960;
7963 -> 7961;
7963 -> 7962;
7964 -> 7962;
7965 -> 7963;
7965 -> 7964;
7966 -> 7964;
7967 -> 7965;
7967 -> 7966;
7968 -> 7967;
7968 -> 7966;
7969 -> 7968;
7969 -> 7964;
7970 -> 7969;
7970 -> 7962;
7971 -> 7970;
7971 -> 7960;
7972 -> 7960;
7973 -> 7971;
7973 -> 7972;
7974 -> 7954;
7974 -> 0;
7974 -> 7952;
7975 -> 7952;
7976 -> 7973;
7976 -> 7975;
7976 -> 7952;
7977 -> 7952;
7978 -> 7955;
7978 -> 7977;
7978 -> 7952;
7979 -> 7953;
7979 -> 7956;
7979 -> 7952;
7980 -> 7954;
7980 -> 7956;
7980 -> 7952;
7981 -> 7955;
7981 -> 7956;
7981 -> 7952;
7982 -> 7951;
7982 -> 7907;
7983 -> 7982;
7983 -> 7723;
7984 -> 7983;
7984 -> 7723;
7985 -> 7726;
7985 -> 7723;
7986 -> 7724;
7986 -> 7723;
7987 -> 7731;
7987 -> 7747;
7987 -> 7723;
7988 -> 7723;
7989 -> 7984;
7989 -> 7988;
7990 -> 7985;
7990 -> 7988;
7991 -> 7986;
7991 -> 7988;
7992 -> 7987;
7992 -> 7988;
7993 -> 7987;
7993 -> 7988;
7994 -> 7988;
7995 -> 7989;
7995 -> 7994;
7996 -> 7995;
7996 -> 7979;
7996 -> 7994;
7997 -> 7996;
7997 -> 7994;
7998 -> 7997;
7998 -> 7988;
7999 -> 7988;
8000 -> 7992;
8000 -> 7999;
8001 -> 7999;
8002 -> 8000;
8002 -> 8001;
8003 -> 8001;
8004 -> 8002;
8004 -> 8003;
8005 -> 8003;
8006 -> 8004;
8006 -> 8005;
8007 -> 8005;
8008 -> 8006;
8008 -> 8007;
8009 -> 8008;
8009 -> 8007;
8010 -> 8009;
8010 -> 8005;
8011 -> 8010;
8011 -> 8003;
8012 -> 8011;
8012 -> 8001;
8013 -> 8012;
8013 -> 7999;
8014 -> 8013;
8014 -> 7988;
8015 -> 7988;
8016 -> 7992;
8016 -> 8015;
8017 -> 8015;
8018 -> 8016;
8018 -> 8017;
8019 -> 8018;
8019 -> 7867;
8019 -> 8017;
8020 -> 8017;
8021 -> 8019;
8021 -> 8020;
8022 -> 8020;
8022 -> 8017;
8023 -> 8019;
8023 -> 8015;
8024 -> 8023;
8024 -> 7988;
8025 -> 8024;
8025 -> 7991;
8025 -> 7988;
8026 -> 7988;
8027 -> 7992;
8027 -> 7988;
8028 -> 7988;
8029 -> 8027;
8029 -> 8028;
8030 -> 8026;
8030 -> 8028;
8031 -> 8029;
8031 -> 8028;
8032 -> 8028;
8033 -> 8029;
8033 -> 8032;
8034 -> 8032;
8034 -> 8028;
8035 -> 8028;
8036 -> 8028;
8037 -> 8029;
8037 -> 8036;
8038 -> 0;
8038 -> 8036;
8039 -> 8037;
8039 -> 7867;
8039 -> 0;
8039 -> 8036;
8040 -> 8039;
8040 -> 8028;
8041 -> 8028;
8042 -> 8029;
8042 -> 8041;
8043 -> 8042;
8043 -> 7867;
8043 -> 8041;
8044 -> 8043;
8044 -> 8028;
8045 -> 8044;
8045 -> 8028;
8046 -> 8028;
8047 -> 8046;
8047 -> 7988;
8048 -> 7988;
8049 -> 7988;
8050 -> 8049;
8050 -> 7988;
8051 -> 7988;
8052 -> 7991;
8052 -> 8051;
8053 -> 8052;
8053 -> 7867;
8053 -> 8051;
8054 -> 8053;
8054 -> 7988;
8055 -> 7990;
8055 -> 7988;
8056 -> 8048;
8056 -> 7988;
8057 -> 8049;
8057 -> 7988;
8058 -> 8054;
8058 -> 8055;
8058 -> 8056;
8058 -> 8057;
8058 -> 7867;
8058 -> 7617;
8058 -> 8050;
8058 -> 7988;
8059 -> 8058;
8060 -> 7993;
8060 -> 8059;
8061 -> 8059;
8062 -> 8060;
8062 -> 8058;
8062 -> 8059;
8063 -> 8061;
8063 -> 8059;
8064 -> 8059;
8065 -> 8062;
8065 -> 8064;
8066 -> 8063;
8066 -> 8064;
8067 -> 8065;
8067 -> 8064;
8068 -> 8067;
8069 -> 8067;
8070 -> 8069;
8071 -> 8070;
8072 -> 8070;
8072 -> 8071;
8073 -> 8071;
8073 -> 8070;
8074 -> 8070;
8074 -> 8069;
8075 -> 8069;
8076 -> 8074;
8076 -> 8075;
8077 -> 8060;
8077 -> 8058;
8077 -> 8069;
8078 -> 8069;
8079 -> 8076;
8079 -> 8069;
8080 -> 8079;
8081 -> 8060;
8081 -> 8076;
8081 -> 8080;
8082 -> 8080;
8083 -> 8081;
8083 -> 8082;
8084 -> 8082;
8085 -> 8084;
8085 -> 8080;
8086 -> 8080;
8087 -> 8081;
8087 -> 8086;
8088 -> 8087;
8088 -> 8080;
8089 -> 8080;
8090 -> 8088;
8090 -> 8089;
8091 -> 8089;
8092 -> 8090;
8092 -> 8091;
8093 -> 8091;
8094 -> 8093;
8094 -> 8089;
8095 -> 8089;
8096 -> 8090;
8096 -> 8095;
8097 -> 8096;
8097 -> 8076;
8097 -> 8095;
8098 -> 8097;
8098 -> 8091;
8099 -> 8097;
8099 -> 8095;
8100 -> 8099;
8100 -> 8076;
8100 -> 8095;
8101 -> 8100;
8101 -> 8091;
8102 -> 8100;
8102 -> 8095;
8103 -> 8095;
8104 -> 8103;
8104 -> 8089;
8105 -> 8104;
8105 -> 8094;
8105 -> 8089;
8106 -> 8105;
8106 -> 8069;
8107 -> 8069;
8108 -> 8106;
8108 -> 8107;
8109 -> 8108;
8109 -> 8107;
8110 -> 0;
8110 -> 8109;
8111 -> 8110;
8111 -> 8060;
8111 -> 8069;
8112 -> 8105;
8112 -> 8059;
8113 -> 8112;
8113 -> 8058;
8114 -> 8058;
8115 -> 8113;
8115 -> 8114;
8115 -> 8058;
8116 -> 7989;
8116 -> 8115;
8117 -> 8116;
8117 -> 7723;
8118 -> 7726;
8118 -> 7723;
8119 -> 7724;
8119 -> 7723;
8120 -> 7723;
8121 -> 8117;
8121 -> 8120;
8122 -> 8118;
8122 -> 8120;
8123 -> 8119;
8123 -> 8120;
8124 -> 8120;
8125 -> 8124;
8125 -> 8120;
8126 -> 8120;
8127 -> 8123;
8127 -> 8126;
8128 -> 8127;
8128 -> 8076;
8128 -> 8126;
8129 -> 8128;
8129 -> 8120;
8130 -> 8122;
8130 -> 8120;
8131 -> 8124;
8131 -> 8120;
8132 -> 8129;
8132 -> 8130;
8132 -> 8131;
8132 -> 8076;
8132 -> 8111;
8132 -> 7617;
8132 -> 8125;
8132 -> 8120;
8133 -> 8132;
8133 -> 8120;
8134 -> 8120;
8135 -> 8121;
8135 -> 8134;
8136 -> 8135;
8136 -> 7979;
8136 -> 8134;
8137 -> 8134;
8138 -> 8136;
8138 -> 8137;
8139 -> 8135;
8139 -> 7981;
8139 -> 8137;
8140 -> 8138;
8140 -> 8137;
8141 -> 8140;
8141 -> 8134;
8142 -> 8141;
8142 -> 8120;
8143 -> 8142;
8143 -> 8120;
8144 -> 8132;
8144 -> 8120;
8145 -> 8120;
8146 -> 8143;
8146 -> 8145;
8147 -> 8144;
8147 -> 8145;
8148 -> 8144;
8148 -> 8145;
8149 -> 8146;
8149 -> 8145;
8150 -> 8149;
8150 -> 8132;
8150 -> 8145;
8151 -> 8147;
8151 -> 8145;
8152 -> 8145;
8153 -> 8145;
8154 -> 8151;
8154 -> 8153;
8155 -> 8152;
8155 -> 8153;
8156 -> 8154;
8156 -> 8155;
8156 -> 8153;
8157 -> 8154;
8157 -> 8132;
8157 -> 8153;
8158 -> 8157;
8159 -> 8158;
8159 -> 8155;
8159 -> 8153;
8160 -> 8153;
8161 -> 8160;
8161 -> 8155;
8161 -> 8153;
8162 -> 8153;
8163 -> 8162;
8163 -> 8155;
8163 -> 8153;
8164 -> 8146;
8164 -> 8145;
8165 -> 8145;
8166 -> 8164;
8166 -> 8165;
8167 -> 8152;
8167 -> 8165;
8168 -> 8165;
8169 -> 8166;
8169 -> 8168;
8170 -> 8168;
8170 -> 8165;
8171 -> 8166;
8171 -> 8170;
8172 -> 8170;
8173 -> 8171;
8173 -> 8172;
8174 -> 8167;
8174 -> 8172;
8175 -> 8172;
8176 -> 8173;
8176 -> 8175;
8177 -> 0;
8177 -> 8175;
8178 -> 8177;
8178 -> 8172;
8179 -> 8178;
8179 -> 8172;
8180 -> 8172;
8181 -> 8179;
8181 -> 8180;
8182 -> 8174;
8182 -> 8180;
8183 -> 8181;
8183 -> 0;
8183 -> 8180;
8184 -> 8181;
8184 -> 8183;
8185 -> 8173;
8185 -> 8172;
8186 -> 8172;
8187 -> 8173;
8187 -> 8186;
8188 -> 8187;
8188 -> 8150;
8188 -> 8186;
8189 -> 8188;
8189 -> 8172;
8190 -> 8172;
8191 -> 8189;
8191 -> 8172;
8192 -> 8189;
8192 -> 8191;
8193 -> 8192;
8193 -> 8172;
8194 -> 8189;
8194 -> 8172;
8195 -> 8178;
8195 -> 8184;
8195 -> 8172;
8196 -> 8195;
8196 -> 8193;
8196 -> 8172;
8197 -> 8172;
8198 -> 8185;
8198 -> 8197;
8199 -> 8197;
8200 -> 8199;
8200 -> 8197;
8201 -> 8197;
8202 -> 8200;
8202 -> 8201;
8203 -> 8198;
8203 -> 8201;
8204 -> 8201;
8205 -> 8203;
8205 -> 8204;
8206 -> 8204;
8207 -> 8206;
8207 -> 8201;
8208 -> 8201;
8209 -> 8203;
8209 -> 8208;
8210 -> 8209;
8210 -> 8150;
8210 -> 8208;
8211 -> 8210;
8211 -> 8201;
8212 -> 8201;
8213 -> 8211;
8213 -> 8212;
8214 -> 8212;
8214 -> 8201;
8215 -> 8207;
8215 -> 8214;
8215 -> 8201;
8216 -> 8201;
8217 -> 8203;
8217 -> 8216;
8218 -> 8217;
8218 -> 8216;
8219 -> 8218;
8219 -> 8150;
8219 -> 8216;
8220 -> 8219;
8220 -> 8201;
8221 -> 8201;
8222 -> 8220;
8222 -> 8221;
8223 -> 8201;
8224 -> 8222;
8224 -> 8223;
8225 -> 8223;
8225 -> 8201;
8226 -> 8201;
8227 -> 8215;
8227 -> 8225;
8227 -> 8201;
8228 -> 8201;
8229 -> 8203;
8229 -> 8228;
8230 -> 8229;
8230 -> 8150;
8230 -> 8228;
8231 -> 8230;
8231 -> 8201;
8232 -> 8231;
8232 -> 4027;
8232 -> 8201;
8233 -> 8227;
8233 -> 8232;
8233 -> 8201;
8234 -> 8201;
8235 -> 8201;
8236 -> 8235;
8236 -> 8172;
8237 -> 8185;
8237 -> 8172;
8238 -> 8152;
8238 -> 8161;
8238 -> 8145;
8239 -> 8148;
8239 -> 8238;
8240 -> 8237;
8240 -> 8239;
8241 -> 8240;
8241 -> 8142;
8241 -> 8120;
8242 -> 8241;
8242 -> 8120;
8243 -> 8242;
8243 -> 7731;
8243 -> 7723;
8244 -> 7750;
8244 -> 7723;
8245 -> 7730;
8245 -> 7723;
8246 -> 7729;
8246 -> 7723;
8247 -> 7731;
8247 -> 7757;
8247 -> 7723;
8248 -> 7771;
8248 -> 7723;
8249 -> 7731;
8249 -> 7758;
8249 -> 7723;
8250 -> 7792;
8250 -> 7723;
8251 -> 7723;
8252 -> 8244;
8252 -> 8251;
8253 -> 8245;
8253 -> 8251;
8254 -> 8246;
8254 -> 8251;
8255 -> 8247;
8255 -> 8251;
8256 -> 8248;
8256 -> 8251;
8257 -> 8249;
8257 -> 8251;
8258 -> 8250;
8258 -> 8251;
8259 -> 8251;
8260 -> 8256;
8260 -> 8259;
8260 -> 8251;
8261 -> 8255;
8261 -> 8259;
8261 -> 8251;
8262 -> 8260;
8262 -> 8261;
8262 -> 8251;
8263 -> 8251;
8264 -> 8258;
8264 -> 8263;
8264 -> 8251;
8265 -> 8257;
8265 -> 8263;
8265 -> 8251;
8266 -> 8264;
8266 -> 8265;
8266 -> 8251;
8267 -> 8251;
8268 -> 8256;
8268 -> 8267;
8268 -> 8251;
8269 -> 8251;
8270 -> 8258;
8270 -> 8269;
8270 -> 8251;
8271 -> 8254;
8271 -> 8251;
8272 -> 8256;
8272 -> 8251;
8273 -> 8251;
8274 -> 8271;
8274 -> 8272;
8274 -> 8273;
8274 -> 8253;
8274 -> 8150;
8274 -> 8251;
8275 -> 8274;
8275 -> 8273;
8276 -> 8274;
8276 -> 8273;
8277 -> 8274;
8277 -> 8273;
8278 -> 8275;
8278 -> 8273;
8279 -> 8276;
8279 -> 8273;
8280 -> 8273;
8281 -> 8278;
8281 -> 8280;
8282 -> 8279;
8282 -> 8280;
8283 -> 8277;
8283 -> 8280;
8284 -> 8281;
8284 -> 8280;
8285 -> 8284;
8285 -> 8280;
8286 -> 8284;
8286 -> 8280;
8287 -> 8282;
8287 -> 8280;
8288 -> 8280;
8289 -> 8286;
8289 -> 8288;
8290 -> 8287;
8290 -> 8288;
8291 -> 8283;
8291 -> 8288;
8292 -> 8289;
8292 -> 8288;
8293 -> 8292;
8293 -> 8288;
8294 -> 8290;
8294 -> 8293;
8295 -> 8293;
8296 -> 8293;
8296 -> 8295;
8297 -> 8294;
8297 -> 8295;
8298 -> 8291;
8298 -> 8295;
8299 -> 8296;
8299 -> 8298;
8299 -> 8295;
8300 -> 8299;
8301 -> 8268;
8301 -> 8300;
8301 -> 8251;
8302 -> 8270;
8302 -> 8251;
8303 -> 8268;
8303 -> 8270;
8303 -> 8251;
8304 -> 8251;
8305 -> 8304;
8305 -> 7723;
8306 -> 7723;
8307 -> 7731;
8307 -> 8306;
8308 -> 8306;
8309 -> 8307;
8309 -> 8308;
8310 -> 8309;
8310 -> 7829;
8310 -> 8308;
8311 -> 8310;
8311 -> 8306;
8312 -> 8311;
8313 -> 8307;
8313 -> 8312;
8314 -> 8312;
8315 -> 8313;
8315 -> 8314;
8316 -> 8315;
8316 -> 7813;
8316 -> 8314;
8317 -> 8316;
8317 -> 8312;
8318 -> 8317;
8318 -> 8311;
8319 -> 8311;
8320 -> 8318;
8321 -> 8320;
8321 -> 7723;
8322 -> 8305;
8322 -> 8321;
8322 -> 7723;
8323 -> 7723;
8324 -> 8246;
8324 -> 8323;
8325 -> 8324;
8325 -> 8323;
8326 -> 8323;
8327 -> 8325;
8327 -> 8326;
8327 -> 8300;
8327 -> 8323;
8328 -> 8322;
8328 -> 8327;
8328 -> 7723;
8329 -> 8328;
8329 -> 7723;
8330 -> 8329;
8331 -> 7731;
8331 -> 7757;
8331 -> 8330;
8331 -> 8329;
8332 -> 7731;
8332 -> 8331;
8333 -> 0;
8333 -> 8331;
8334 -> 8331;
8335 -> 8332;
8335 -> 8334;
8336 -> 8333;
8336 -> 8334;
8337 -> 7731;
8337 -> 7757;
8337 -> 8334;
8338 -> 8336;
8338 -> 0;
8338 -> 8334;
8339 -> 8335;
8339 -> 8334;
8340 -> 8336;
8340 -> 8334;
8341 -> 8334;
8342 -> 8339;
8342 -> 8341;
8343 -> 8340;
8343 -> 8341;
8344 -> 8337;
8344 -> 8341;
8345 -> 8341;
8346 -> 8344;
8346 -> 8300;
8346 -> 8345;
8346 -> 8341;
8347 -> 8346;
8348 -> 8342;
8348 -> 8347;
8349 -> 8348;
8349 -> 7747;
8349 -> 8347;
8350 -> 8349;
8350 -> 8346;
8351 -> 8344;
8351 -> 8300;
8351 -> 8346;
8352 -> 0;
8352 -> 8346;
8353 -> 8346;
8354 -> 8350;
8354 -> 8353;
8355 -> 8351;
8355 -> 8353;
8356 -> 8352;
8356 -> 8353;
8357 -> 8354;
8357 -> 8353;
8358 -> 8355;
8358 -> 8353;
8359 -> 8356;
8359 -> 8353;
8360 -> 8353;
8361 -> 8358;
8361 -> 8360;
8362 -> 8359;
8362 -> 8360;
8363 -> 8354;
8363 -> 8360;
8364 -> 8362;
8364 -> 8361;
8365 -> 8364;
8365 -> 8361;
8366 -> 8363;
8366 -> 8361;
8367 -> 8342;
8367 -> 8344;
8367 -> 8346;
8369 -> 8368;
8371 -> 8370;
8374 -> 8372;
8374 -> 8373;
8375 -> 8374;
8378 -> 8376;
8378 -> 8377;
8379 -> 8378;
8382 -> 8380;
8382 -> 8381;
8383 -> 8382;
8386 -> 8384;
8386 -> 8385;
8387 -> 8386;
8390 -> 8388;
8390 -> 8389;
8391 -> 8390;
8394 -> 8392;
8394 -> 8393;
8395 -> 8394;
8398 -> 8396;
8398 -> 8397;
8399 -> 8398;
8402 -> 8400;
8402 -> 8401;
8403 -> 8402;
8406 -> 8404;
8406 -> 8405;
8407 -> 8406;
8410 -> 8408;
8410 -> 8409;
8411 -> 8410;
8414 -> 8412;
8414 -> 8413;
8415 -> 8414;
8418 -> 8416;
8418 -> 8417;
8419 -> 8418;
8422 -> 8420;
8422 -> 8421;
8423 -> 8422;
8425 -> 8424;
8427 -> 8426;
8430 -> 8428;
8430 -> 8429;
8431 -> 8430;
8434 -> 8432;
8434 -> 8433;
8435 -> 8434;
8438 -> 8436;
8438 -> 8437;
8439 -> 8438;
8442 -> 8440;
8442 -> 8441;
8443 -> 8442;
8446 -> 8444;
8446 -> 8445;
8447 -> 8446;
8450 -> 8448;
8450 -> 8449;
8451 -> 8450;
8452 -> 8371;
8453 -> 8427;
8454 -> 8346;
8455 -> 8344;
8455 -> 8300;
8455 -> 8454;
8456 -> 8455;
8456 -> 8300;
8456 -> 8369;
8456 -> 8454;
8457 -> 8456;
8457 -> 8371;
8457 -> 8454;
8458 -> 8457;
8458 -> 8346;
8459 -> 8346;
8460 -> 8346;
8461 -> 8343;
8461 -> 8460;
8462 -> 8344;
8462 -> 8300;
8462 -> 8460;
8463 -> 8461;
8463 -> 8371;
8463 -> 8460;
8464 -> 8371;
8464 -> 8369;
8464 -> 8460;
8465 -> 8462;
8465 -> 8300;
8465 -> 8464;
8465 -> 8460;
8466 -> 8461;
8466 -> 8371;
8466 -> 8460;
8467 -> 8466;
8467 -> 8369;
8467 -> 8460;
8468 -> 8465;
8468 -> 8467;
8468 -> 8460;
8469 -> 8468;
8469 -> 8375;
8469 -> 8460;
8470 -> 8469;
8470 -> 8462;
8470 -> 8460;
8471 -> 8346;
8472 -> 8471;
8472 -> 8334;
8473 -> 8472;
8473 -> 8331;
8474 -> 8329;
8475 -> 7731;
8475 -> 7758;
8475 -> 8474;
8475 -> 8329;
8476 -> 8328;
8476 -> 7723;
8477 -> 7756;
8477 -> 0;
8477 -> 7723;
8478 -> 7723;
8479 -> 7756;
8479 -> 0;
8479 -> 7723;
8480 -> 7723;
8481 -> 7653;
8482 -> 7720;
8482 -> 8481;
8483 -> 8482;
8483 -> 7829;
8483 -> 8481;
8484 -> 8483;
8484 -> 7653;
8485 -> 7653;
8486 -> 7720;
8486 -> 8485;
8487 -> 0;
8487 -> 8485;
8488 -> 8487;
8488 -> 7653;
8489 -> 7653;
8490 -> 8488;
8490 -> 8489;
8491 -> 8490;
8491 -> 8489;
8492 -> 8489;
8493 -> 8484;
8493 -> 8491;
8493 -> 7653;
8494 -> 7653;
8495 -> 7714;
8495 -> 8494;
8495 -> 7653;
8496 -> 8495;
8496 -> 8493;
8496 -> 7653;
8497 -> 7720;
8497 -> 7653;
8498 -> 7604;
8498 -> 8497;
8498 -> 8300;
8498 -> 8367;
8498 -> 8470;
8498 -> 7733;
8498 -> 7735;
8498 -> 7736;
8498 -> 7756;
8498 -> 7747;
8498 -> 7829;
8498 -> 7757;
8498 -> 7758;
8498 -> 7742;
8498 -> 7743;
8498 -> 7744;
8498 -> 7745;
8498 -> 7746;
8498 -> 7759;
8498 -> 7813;
8498 -> 8243;
8498 -> 7617;
8498 -> 0;
8498 -> 7979;
8498 -> 7980;
8498 -> 7981;
8498 -> 7942;
8498 -> 7645;
8499 -> 7483;
8500 -> 7508;
8500 -> 7483;
8501 -> 7596;
8501 -> 7483;
8502 -> 7485;
8502 -> 7483;
8503 -> 7483;
8504 -> 8500;
8504 -> 8503;
8505 -> 8501;
8505 -> 8503;
8506 -> 8502;
8506 -> 8503;
8507 -> 7424;
8507 -> 8503;
8508 -> 8503;
8509 -> 8507;
8509 -> 8508;
8510 -> 8509;
8510 -> 8498;
8510 -> 8508;
8511 -> 8508;
8512 -> 8510;
8512 -> 8511;
8513 -> 8511;
8513 -> 8508;
8514 -> 8510;
8514 -> 8503;
8515 -> 8503;
8516 -> 8514;
8516 -> 8515;
8517 -> 8516;
8517 -> 8503;
8518 -> 8507;
8518 -> 8498;
8518 -> 8503;
8519 -> 8517;
8519 -> 8518;
8519 -> 8498;
8519 -> 8503;
8520 -> 7483;
8521 -> 7484;
8521 -> 7483;
8522 -> 7485;
8522 -> 7483;
8523 -> 7475;
8523 -> 8522;
8523 -> 8519;
8523 -> 7483;
8524 -> 7485;
8524 -> 8523;
8524 -> 7483;
8525 -> 7484;
8525 -> 7483;
8526 -> 7596;
8526 -> 8524;
8526 -> 7483;
8527 -> 7475;
8527 -> 8526;
8527 -> 7426;
8528 -> 7424;
8528 -> 8526;
8528 -> 7426;
8530 -> 8529;
8531 -> 8529;
8532 -> 8527;
8532 -> 7426;
8533 -> 8531;
8533 -> 7426;
8534 -> 7475;
8534 -> 8532;
8534 -> 8533;
8534 -> 8526;
8534 -> 7426;
8535 -> 7426;
8536 -> 7475;
8536 -> 7426;
8537 -> 8536;
8537 -> 8534;
8537 -> 7426;
8538 -> 8537;
8539 -> 8537;
8540 -> 8535;
8540 -> 8539;
8541 -> 8538;
8541 -> 8539;
8542 -> 8541;
8542 -> 8539;
8543 -> 8540;
8543 -> 8542;
8544 -> 8535;
8544 -> 8538;
8544 -> 8537;
8545 -> 8537;
8545 -> 8544;
8546 -> 8545;
8546 -> 8539;
8547 -> 8546;
8547 -> 8542;
8548 -> 8537;
8548 -> 8545;
8549 -> 8545;
8550 -> 8545;
8550 -> 8549;
8551 -> 0;
8551 -> 8549;
8552 -> 8551;
8552 -> 8545;
8553 -> 8545;
8554 -> 8548;
8554 -> 8553;
8555 -> 0;
8555 -> 8553;
8556 -> 8555;
8556 -> 8545;
8557 -> 8552;
8557 -> 8556;
8557 -> 8545;
8558 -> 8548;
8558 -> 8545;
8559 -> 8558;
8559 -> 8539;
8560 -> 8559;
8560 -> 8542;
8561 -> 8558;
8562 -> 8558;
8562 -> 8561;
8563 -> 0;
8563 -> 8561;
8564 -> 8563;
8564 -> 8558;
8565 -> 8558;
8566 -> 8558;
8566 -> 8565;
8567 -> 0;
8567 -> 8565;
8568 -> 8567;
8568 -> 8558;
8569 -> 8564;
8569 -> 8568;
8569 -> 8558;
8570 -> 8558;
8570 -> 8565;
8571 -> 0;
8571 -> 8565;
8572 -> 8571;
8572 -> 8558;
8573 -> 8564;
8573 -> 8572;
8573 -> 8558;
8574 -> 7426;
8575 -> 7424;
8575 -> 8574;
8576 -> 8574;
8577 -> 8576;
8577 -> 8574;
8578 -> 8574;
8579 -> 8577;
8579 -> 8578;
8580 -> 8575;
8580 -> 8578;
8581 -> 8578;
8582 -> 8580;
8582 -> 8581;
8583 -> 8581;
8584 -> 8583;
8584 -> 8578;
8585 -> 8578;
8586 -> 8580;
8586 -> 8585;
8587 -> 8586;
8587 -> 8534;
8587 -> 8585;
8588 -> 8587;
8588 -> 8578;
8589 -> 8578;
8590 -> 8588;
8590 -> 8589;
8591 -> 8589;
8591 -> 8578;
8592 -> 8584;
8592 -> 8591;
8592 -> 8578;
8593 -> 8578;
8594 -> 8580;
8594 -> 8593;
8595 -> 8594;
8595 -> 8593;
8596 -> 8595;
8596 -> 8534;
8596 -> 8593;
8597 -> 8596;
8597 -> 8578;
8598 -> 8578;
8599 -> 8597;
8599 -> 8598;
8600 -> 8578;
8601 -> 8599;
8601 -> 8600;
8602 -> 8600;
8602 -> 8578;
8603 -> 8578;
8604 -> 8592;
8604 -> 8602;
8604 -> 8578;
8605 -> 8578;
8606 -> 8578;
8607 -> 8606;
8607 -> 7426;
8608 -> 7475;
8608 -> 8534;
8608 -> 7426;
8609 -> 7424;
8609 -> 8608;
8609 -> 7426;
8610 -> 8608;
8610 -> 7426;
8611 -> 8527;
8611 -> 8609;
8612 -> 7423;
8613 -> 7424;
8613 -> 8611;
8613 -> 8612;
8613 -> 7423;
8614 -> 8613;
8615 -> 7475;
8615 -> 8613;
8616 -> 8613;
8617 -> 8615;
8617 -> 8616;
8618 -> 8616;
8619 -> 0;
8619 -> 8616;
8620 -> 8618;
8620 -> 8619;
8620 -> 8617;
8620 -> 8611;
8620 -> 8616;
8621 -> 8620;
8621 -> 8618;
8622 -> 8621;
8622 -> 8620;
8622 -> 8618;
8623 -> 8620;
8623 -> 8618;
8624 -> 8618;
8625 -> 8623;
8625 -> 8624;
8626 -> 8624;
8627 -> 8625;
8627 -> 8626;
8628 -> 8627;
8628 -> 8622;
8628 -> 8626;
8629 -> 8628;
8629 -> 8624;
8630 -> 8624;
8631 -> 8624;
8632 -> 8631;
8632 -> 8618;
8633 -> 8623;
8633 -> 8622;
8633 -> 8632;
8634 -> 7424;
8634 -> 8633;
8634 -> 8613;
8635 -> 8633;
8635 -> 8613;
8636 -> 8613;
8637 -> 8613;
8638 -> 8634;
8638 -> 8637;
8638 -> 8613;
8639 -> 8633;
8639 -> 8634;
8639 -> 8638;
8640 -> 7424;
8640 -> 8639;
8640 -> 8638;
8641 -> 8639;
8641 -> 8638;
8642 -> 7423;
8643 -> 7475;
8643 -> 8642;
8643 -> 7423;
8644 -> 7475;
8644 -> 8640;
8644 -> 8643;
8645 -> 7422;
8646 -> 7416;
8647 -> 7416;
8648 -> 8647;
8648 -> 7416;
8649 -> 7417;
8649 -> 7416;
8650 -> 8647;
8650 -> 7416;
8651 -> 7418;
8651 -> 8644;
8651 -> 8649;
8651 -> 8650;
8651 -> 8648;
8651 -> 7416;
8652 -> 7416;
8653 -> 8652;
8653 -> 7416;
8654 -> 7417;
8654 -> 7416;
8655 -> 8652;
8655 -> 7416;
8656 -> 7418;
8656 -> 8651;
8656 -> 8654;
8656 -> 8655;
8656 -> 8653;
8656 -> 7416;
8657 -> 8651;
8657 -> 7416;
8658 -> 8657;
8658 -> 7410;
8659 -> 7412;
8659 -> 7410;
8660 -> 7413;
8660 -> 7410;
8661 -> 7414;
8661 -> 7410;
8662 -> 7410;
8663 -> 8658;
8663 -> 8662;
8664 -> 8659;
8664 -> 8662;
8665 -> 8660;
8665 -> 8662;
8666 -> 8661;
8666 -> 8662;
8667 -> 8662;
8668 -> 0;
8668 -> 8662;
8669 -> 8664;
8669 -> 7377;
8669 -> 0;
8669 -> 8662;
8670 -> 8662;
8671 -> 8662;
8672 -> 8664;
8672 -> 7377;
8672 -> 0;
8672 -> 8662;
8673 -> 0;
8673 -> 8672;
8674 -> 0;
8674 -> 8672;
8675 -> 8669;
8675 -> 8672;
8676 -> 8663;
8676 -> 8662;
8677 -> 8676;
8678 -> 8677;
8678 -> 8651;
8678 -> 8656;
8679 -> 8678;
8679 -> 8676;
8680 -> 8664;
8680 -> 7377;
8680 -> 8676;
8681 -> 8679;
8681 -> 8680;
8681 -> 8676;
8682 -> 8676;
8683 -> 8676;
8683 -> 8682;
8684 -> 0;
8684 -> 8682;
8685 -> 8684;
8685 -> 8676;
8686 -> 8685;
8686 -> 8673;
8686 -> 8676;
8687 -> 8676;
8688 -> 8676;
8688 -> 8687;
8689 -> 0;
8689 -> 8687;
8690 -> 8687;
8691 -> 8689;
8691 -> 8690;
8692 -> 8688;
8692 -> 8690;
8693 -> 8690;
8694 -> 8691;
8694 -> 8693;
8694 -> 8690;
8695 -> 8691;
8695 -> 8692;
8695 -> 8651;
8695 -> 8656;
8695 -> 8690;
8696 -> 8690;
8697 -> 8695;
8697 -> 8676;
8698 -> 8697;
8698 -> 8669;
8698 -> 8676;
8699 -> 8686;
8699 -> 8698;
8699 -> 8676;
8700 -> 8676;
8701 -> 8676;
8701 -> 8700;
8702 -> 8700;
8703 -> 8701;
8703 -> 8702;
8704 -> 8703;
8704 -> 8651;
8704 -> 8656;
8704 -> 8702;
8705 -> 8704;
8705 -> 8700;
8706 -> 0;
8706 -> 8705;
8707 -> 8706;
8707 -> 8676;
8708 -> 8699;
8708 -> 8707;
8708 -> 8676;
8709 -> 8673;
8709 -> 8676;
8710 -> 8676;
8710 -> 8709;
8711 -> 8709;
8712 -> 8710;
8712 -> 8711;
8713 -> 8711;
8714 -> 8712;
8714 -> 8651;
8714 -> 8656;
8714 -> 8713;
8715 -> 8714;
8715 -> 8656;
8715 -> 8375;
8715 -> 8713;
8716 -> 8713;
8717 -> 8715;
8717 -> 8716;
8717 -> 8713;
8718 -> 8717;
8718 -> 8711;
8719 -> 8718;
8720 -> 8712;
8720 -> 8719;
8721 -> 8719;
8722 -> 8720;
8722 -> 8721;
8723 -> 0;
8723 -> 8721;
8724 -> 8721;
8725 -> 8723;
8725 -> 8724;
8726 -> 8722;
8726 -> 8724;
8727 -> 8724;
8728 -> 8725;
8728 -> 8727;
8728 -> 8724;
8729 -> 8725;
8729 -> 8726;
8729 -> 8651;
8729 -> 8656;
8729 -> 8724;
8730 -> 8724;
8731 -> 8729;
8731 -> 8719;
8732 -> 8731;
8733 -> 0;
8733 -> 8731;
8734 -> 8732;
8735 -> 8720;
8735 -> 8734;
8736 -> 8735;
8736 -> 8651;
8736 -> 8656;
8736 -> 8734;
8737 -> 8736;
8737 -> 8732;
8738 -> 0;
8738 -> 8732;
8739 -> 8732;
8740 -> 8720;
8740 -> 8739;
8741 -> 0;
8741 -> 8739;
8742 -> 8739;
8743 -> 8741;
8743 -> 8742;
8744 -> 8740;
8744 -> 8742;
8745 -> 8742;
8746 -> 8743;
8746 -> 8745;
8746 -> 8742;
8747 -> 8743;
8747 -> 8744;
8747 -> 8651;
8747 -> 8656;
8747 -> 8742;
8748 -> 8747;
8748 -> 8732;
8749 -> 8737;
8749 -> 8748;
8749 -> 8732;
8750 -> 8732;
8751 -> 8720;
8751 -> 8750;
8752 -> 8750;
8753 -> 8751;
8753 -> 8752;
8754 -> 8752;
8755 -> 8753;
8755 -> 8754;
8756 -> 8754;
8757 -> 8755;
8757 -> 8756;
8758 -> 8756;
8759 -> 8757;
8759 -> 8758;
8760 -> 8758;
8761 -> 8759;
8761 -> 8651;
8761 -> 8656;
8761 -> 8760;
8762 -> 8760;
8763 -> 8761;
8763 -> 8762;
8764 -> 8762;
8764 -> 8760;
8765 -> 8761;
8765 -> 8758;
8766 -> 8758;
8767 -> 8766;
8767 -> 8758;
8768 -> 8758;
8769 -> 8765;
8769 -> 8758;
8770 -> 8759;
8770 -> 8758;
8771 -> 8758;
8772 -> 8758;
8773 -> 8769;
8773 -> 8772;
8774 -> 8770;
8774 -> 8772;
8775 -> 8771;
8775 -> 8772;
8776 -> 8773;
8776 -> 8772;
8777 -> 8772;
8778 -> 8774;
8778 -> 8777;
8779 -> 8778;
8779 -> 8651;
8779 -> 8656;
8779 -> 8777;
8780 -> 8774;
8780 -> 8772;
8781 -> 8772;
8782 -> 8776;
8782 -> 8781;
8783 -> 8779;
8783 -> 8781;
8784 -> 8780;
8784 -> 8781;
8785 -> 8781;
8786 -> 8782;
8786 -> 8785;
8786 -> 8781;
8787 -> 8766;
8787 -> 8758;
8788 -> 8768;
8788 -> 8758;
8789 -> 8782;
8789 -> 8787;
8789 -> 8788;
8789 -> 8771;
8789 -> 8781;
8789 -> 8783;
8789 -> 8784;
8789 -> 8651;
8789 -> 8767;
8789 -> 8758;
8790 -> 8789;
8790 -> 8771;
8791 -> 8771;
8792 -> 8789;
8792 -> 8791;
8793 -> 8792;
8793 -> 8771;
8794 -> 8793;
8795 -> 8793;
8795 -> 8794;
8796 -> 8794;
8797 -> 8795;
8797 -> 8796;
8798 -> 8796;
8799 -> 8797;
8799 -> 8789;
8799 -> 8798;
8799 -> 8796;
8800 -> 8794;
8801 -> 8795;
8801 -> 8789;
8801 -> 8794;
8802 -> 8801;
8802 -> 8793;
8803 -> 8793;
8804 -> 8771;
8805 -> 8789;
8805 -> 8804;
8805 -> 8771;
8806 -> 8789;
8806 -> 8771;
8807 -> 8758;
8808 -> 8789;
8808 -> 8807;
8808 -> 8758;
8809 -> 8789;
8809 -> 8759;
8809 -> 8758;
8810 -> 8759;
8810 -> 8789;
8810 -> 8809;
8811 -> 0;
8811 -> 8809;
8812 -> 8758;
8813 -> 8789;
8813 -> 8810;
8813 -> 8812;
8813 -> 8758;
8814 -> 8758;
8815 -> 8814;
8815 -> 8758;
8816 -> 8758;
8817 -> 8758;
8818 -> 8813;
8818 -> 8817;
8818 -> 8758;
8819 -> 8813;
8819 -> 8818;
8820 -> 8818;
8821 -> 8765;
8821 -> 8820;
8822 -> 8759;
8822 -> 8820;
8823 -> 8820;
8824 -> 8820;
8825 -> 8823;
8825 -> 8824;
8826 -> 8759;
8826 -> 8824;
8827 -> 0;
8827 -> 8824;
8828 -> 8824;
8829 -> 8827;
8829 -> 8828;
8830 -> 8826;
8830 -> 8828;
8831 -> 8828;
8832 -> 8829;
8832 -> 8831;
8832 -> 8828;
8833 -> 8829;
8833 -> 8830;
8833 -> 8810;
8833 -> 8828;
8834 -> 8833;
8834 -> 8820;
8835 -> 8816;
8835 -> 8820;
8836 -> 8820;
8837 -> 8821;
8837 -> 8836;
8838 -> 8822;
8838 -> 8836;
8839 -> 8834;
8839 -> 8836;
8840 -> 8823;
8840 -> 8836;
8841 -> 8823;
8841 -> 8836;
8842 -> 8822;
8842 -> 8836;
8843 -> 8823;
8843 -> 8836;
8844 -> 8835;
8844 -> 8836;
8845 -> 8837;
8845 -> 8836;
8846 -> 8838;
8846 -> 8836;
8847 -> 8839;
8847 -> 8836;
8848 -> 8840;
8848 -> 8836;
8849 -> 8841;
8849 -> 8810;
8849 -> 8836;
8850 -> 8842;
8850 -> 8836;
8851 -> 8843;
8851 -> 8836;
8852 -> 8844;
8852 -> 8836;
8853 -> 8836;
8854 -> 8845;
8854 -> 8853;
8855 -> 8846;
8855 -> 8853;
8856 -> 8847;
8856 -> 8853;
8857 -> 8848;
8857 -> 8853;
8858 -> 8849;
8858 -> 8853;
8859 -> 8849;
8859 -> 8853;
8860 -> 8849;
8860 -> 8853;
8861 -> 8849;
8861 -> 8853;
8862 -> 8850;
8862 -> 8853;
8863 -> 8849;
8863 -> 8853;
8864 -> 8851;
8864 -> 8853;
8865 -> 8852;
8865 -> 8853;
8866 -> 8860;
8866 -> 8853;
8867 -> 8863;
8867 -> 8853;
8868 -> 8853;
8869 -> 8867;
8869 -> 8868;
8870 -> 8853;
8871 -> 8853;
8872 -> 8866;
8872 -> 8871;
8873 -> 8870;
8873 -> 8871;
8874 -> 8869;
8874 -> 8871;
8875 -> 8872;
8875 -> 8871;
8876 -> 8873;
8876 -> 0;
8876 -> 8871;
8877 -> 8873;
8877 -> 8871;
8878 -> 8872;
8878 -> 8877;
8879 -> 8877;
8880 -> 8878;
8880 -> 8879;
8881 -> 8879;
8882 -> 8880;
8882 -> 8881;
8883 -> 8881;
8884 -> 8882;
8884 -> 8883;
8885 -> 8883;
8886 -> 8884;
8886 -> 8885;
8887 -> 8886;
8887 -> 8885;
8888 -> 8887;
8888 -> 8883;
8889 -> 8888;
8889 -> 8881;
8890 -> 8889;
8890 -> 8879;
8891 -> 8879;
8892 -> 8890;
8892 -> 8891;
8893 -> 8872;
8893 -> 8871;
8894 -> 8893;
8894 -> 8871;
8895 -> 8872;
8895 -> 8894;
8896 -> 8894;
8897 -> 8895;
8897 -> 8896;
8898 -> 8896;
8899 -> 8897;
8899 -> 8898;
8900 -> 8898;
8901 -> 8899;
8901 -> 8900;
8902 -> 8900;
8903 -> 8901;
8903 -> 8902;
8904 -> 8903;
8904 -> 8902;
8905 -> 8904;
8905 -> 8900;
8906 -> 8905;
8906 -> 8898;
8907 -> 8906;
8907 -> 8896;
8908 -> 8896;
8909 -> 8907;
8909 -> 8908;
8910 -> 8873;
8910 -> 0;
8910 -> 8871;
8911 -> 8871;
8912 -> 8909;
8912 -> 8911;
8912 -> 8871;
8913 -> 8871;
8914 -> 8874;
8914 -> 8913;
8914 -> 8871;
8915 -> 8871;
8915 -> 8853;
8916 -> 8863;
8916 -> 8810;
8916 -> 8859;
8916 -> 8853;
8917 -> 8916;
8917 -> 8853;
8918 -> 8854;
8918 -> 8917;
8919 -> 8855;
8919 -> 8917;
8920 -> 8857;
8920 -> 8917;
8921 -> 8858;
8921 -> 8917;
8922 -> 8915;
8922 -> 8917;
8923 -> 8861;
8923 -> 8917;
8924 -> 8862;
8924 -> 8917;
8925 -> 8865;
8925 -> 8917;
8926 -> 8917;
8927 -> 8918;
8927 -> 8926;
8928 -> 8919;
8928 -> 8926;
8929 -> 8920;
8929 -> 8926;
8930 -> 8921;
8930 -> 8926;
8931 -> 8922;
8931 -> 8926;
8932 -> 8923;
8932 -> 8926;
8933 -> 8924;
8933 -> 8926;
8934 -> 8917;
8934 -> 8926;
8935 -> 8925;
8935 -> 8926;
8936 -> 8917;
8936 -> 8926;
8938 -> 8937;
8939 -> 8926;
8940 -> 8936;
8940 -> 8939;
8941 -> 8939;
8942 -> 8940;
8942 -> 8939;
8943 -> 8936;
8943 -> 8926;
8944 -> 8936;
8944 -> 8926;
8945 -> 8936;
8945 -> 8926;
8946 -> 8936;
8946 -> 8926;
8947 -> 0;
8947 -> 8936;
8947 -> 8926;
8948 -> 8936;
8948 -> 8926;
8949 -> 8936;
8949 -> 8926;
8950 -> 8926;
8951 -> 8927;
8951 -> 8950;
8951 -> 8926;
8952 -> 8926;
8953 -> 8928;
8953 -> 8952;
8953 -> 8926;
8954 -> 8926;
8955 -> 8929;
8955 -> 8954;
8955 -> 8926;
8956 -> 8926;
8957 -> 8931;
8957 -> 8956;
8958 -> 8957;
8958 -> 8872;
8958 -> 8956;
8959 -> 8958;
8959 -> 8956;
8960 -> 8959;
8960 -> 8926;
8961 -> 8926;
8962 -> 8927;
8962 -> 8936;
8962 -> 8926;
8963 -> 8928;
8963 -> 8936;
8963 -> 8926;
8964 -> 8929;
8964 -> 8936;
8964 -> 8926;
8965 -> 8932;
8965 -> 8936;
8965 -> 8926;
8966 -> 0;
8966 -> 8926;
8967 -> 8932;
8967 -> 8810;
8967 -> 8926;
8968 -> 8967;
8969 -> 8927;
8969 -> 8968;
8970 -> 8969;
8970 -> 8967;
8971 -> 8932;
8971 -> 8967;
8972 -> 8936;
8972 -> 8944;
8972 -> 8967;
8973 -> 8936;
8973 -> 8945;
8973 -> 8967;
8974 -> 8970;
8974 -> 8971;
8974 -> 8972;
8974 -> 8973;
8974 -> 8810;
8974 -> 8967;
8975 -> 8930;
8975 -> 8967;
8976 -> 8967;
8977 -> 8931;
8977 -> 8976;
8978 -> 8977;
8978 -> 8872;
8978 -> 8976;
8979 -> 8977;
8979 -> 8874;
8979 -> 8976;
8980 -> 8978;
8980 -> 8967;
8981 -> 8934;
8981 -> 8967;
8982 -> 8932;
8982 -> 8967;
8983 -> 8927;
8983 -> 8967;
8984 -> 8966;
8984 -> 8967;
8985 -> 8967;
8986 -> 8980;
8986 -> 8985;
8987 -> 8981;
8987 -> 8985;
8988 -> 8982;
8988 -> 8985;
8989 -> 8983;
8989 -> 8985;
8990 -> 8984;
8990 -> 8985;
8991 -> 8985;
8992 -> 8986;
8992 -> 8991;
8992 -> 8985;
8993 -> 8989;
8993 -> 8974;
8993 -> 8985;
8994 -> 8986;
8994 -> 8967;
8995 -> 8932;
8995 -> 8967;
8996 -> 8927;
8996 -> 8967;
8997 -> 8967;
8998 -> 8994;
8998 -> 8997;
8999 -> 8995;
8999 -> 8997;
9000 -> 8996;
9000 -> 8997;
9001 -> 9000;
9001 -> 8993;
9001 -> 8997;
9002 -> 8998;
9002 -> 9001;
9003 -> 9002;
9003 -> 8967;
9004 -> 8967;
9005 -> 8931;
9005 -> 9004;
9006 -> 9004;
9007 -> 9005;
9007 -> 8874;
9007 -> 9006;
9008 -> 9007;
9008 -> 9001;
9008 -> 9006;
9009 -> 9008;
9009 -> 8967;
9010 -> 8967;
9011 -> 9003;
9011 -> 9010;
9012 -> 9009;
9012 -> 9010;
9013 -> 8931;
9013 -> 9010;
9014 -> 9013;
9014 -> 9010;
9015 -> 9011;
9015 -> 9010;
9016 -> 9012;
9016 -> 9010;
9017 -> 9010;
9018 -> 9014;
9018 -> 9017;
9019 -> 9015;
9019 -> 9017;
9020 -> 9016;
9020 -> 9017;
9021 -> 9013;
9021 -> 8874;
9021 -> 9017;
9022 -> 9019;
9022 -> 9017;
9023 -> 9018;
9023 -> 8873;
9023 -> 9017;
9024 -> 9020;
9024 -> 9017;
9025 -> 9017;
9026 -> 9022;
9026 -> 9025;
9027 -> 9023;
9027 -> 9025;
9028 -> 9024;
9028 -> 9025;
9029 -> 9026;
9029 -> 9025;
9030 -> 9029;
9030 -> 9025;
9031 -> 9026;
9031 -> 9030;
9032 -> 9030;
9033 -> 9031;
9033 -> 9032;
9034 -> 9032;
9035 -> 9033;
9035 -> 9034;
9036 -> 9034;
9037 -> 9035;
9037 -> 9036;
9038 -> 9036;
9039 -> 9037;
9039 -> 9038;
9040 -> 9039;
9040 -> 9038;
9041 -> 9040;
9041 -> 9036;
9042 -> 9041;
9042 -> 9034;
9043 -> 9042;
9043 -> 9032;
9044 -> 9032;
9045 -> 9043;
9045 -> 9044;
9046 -> 9027;
9046 -> 0;
9046 -> 9025;
9047 -> 9025;
9048 -> 9045;
9048 -> 9047;
9048 -> 9025;
9049 -> 9025;
9050 -> 9028;
9050 -> 9049;
9050 -> 9025;
9051 -> 9025;
9051 -> 9017;
9052 -> 9051;
9052 -> 8967;
9053 -> 8967;
9054 -> 8928;
9054 -> 9053;
9055 -> 0;
9055 -> 9053;
9056 -> 9055;
9056 -> 8967;
9057 -> 9056;
9057 -> 8967;
9058 -> 8928;
9058 -> 9057;
9059 -> 9052;
9059 -> 8967;
9060 -> 8932;
9060 -> 8967;
9061 -> 8927;
9061 -> 8967;
9062 -> 9058;
9062 -> 8967;
9063 -> 8933;
9063 -> 8967;
9064 -> 8967;
9065 -> 9059;
9065 -> 9064;
9066 -> 9060;
9066 -> 9064;
9067 -> 9061;
9067 -> 9064;
9068 -> 9062;
9068 -> 9064;
9069 -> 9063;
9069 -> 9064;
9070 -> 9064;
9071 -> 9065;
9071 -> 9070;
9072 -> 9071;
9072 -> 9026;
9072 -> 9070;
9073 -> 9072;
9073 -> 9070;
9074 -> 9073;
9074 -> 9064;
9075 -> 9064;
9076 -> 9068;
9076 -> 9075;
9077 -> 9075;
9078 -> 9076;
9078 -> 9077;
9079 -> 9077;
9080 -> 9078;
9080 -> 9079;
9081 -> 9079;
9082 -> 9080;
9082 -> 9081;
9083 -> 9082;
9083 -> 9081;
9084 -> 9083;
9084 -> 9079;
9085 -> 9084;
9085 -> 9077;
9086 -> 9085;
9086 -> 9075;
9087 -> 9086;
9087 -> 9064;
9088 -> 9064;
9089 -> 9068;
9089 -> 9088;
9090 -> 9088;
9091 -> 9089;
9091 -> 9090;
9092 -> 9091;
9092 -> 9001;
9092 -> 9090;
9093 -> 9092;
9093 -> 9088;
9094 -> 9088;
9095 -> 9093;
9095 -> 9094;
9095 -> 9088;
9096 -> 9095;
9096 -> 9088;
9097 -> 9096;
9098 -> 9093;
9098 -> 9097;
9099 -> 9097;
9100 -> 9098;
9100 -> 9099;
9101 -> 9099;
9102 -> 9100;
9102 -> 9101;
9103 -> 9101;
9103 -> 9099;
9104 -> 9100;
9104 -> 9097;
9105 -> 9104;
9105 -> 9064;
9106 -> 9064;
9107 -> 9068;
9107 -> 9064;
9108 -> 9064;
9109 -> 9107;
9109 -> 9108;
9110 -> 9106;
9110 -> 9108;
9111 -> 9109;
9111 -> 9108;
9112 -> 9108;
9113 -> 9109;
9113 -> 9112;
9114 -> 0;
9114 -> 9112;
9115 -> 9114;
9115 -> 9108;
9116 -> 9108;
9117 -> 9108;
9118 -> 9109;
9118 -> 9117;
9119 -> 9117;
9120 -> 9118;
9120 -> 9119;
9121 -> 9120;
9121 -> 9001;
9121 -> 9119;
9122 -> 9121;
9122 -> 9117;
9123 -> 0;
9123 -> 9122;
9124 -> 9123;
9124 -> 9108;
9125 -> 9108;
9126 -> 9109;
9126 -> 9125;
9127 -> 9126;
9127 -> 9001;
9127 -> 9125;
9128 -> 9127;
9128 -> 9108;
9129 -> 9128;
9129 -> 9108;
9130 -> 9129;
9131 -> 0;
9131 -> 9130;
9132 -> 9130;
9132 -> 9129;
9133 -> 9128;
9133 -> 9129;
9134 -> 9133;
9134 -> 9001;
9134 -> 9129;
9135 -> 9108;
9136 -> 9135;
9136 -> 9064;
9137 -> 9067;
9137 -> 9001;
9137 -> 9064;
9138 -> 9069;
9138 -> 9137;
9139 -> 9137;
9140 -> 9139;
9140 -> 9137;
9141 -> 9137;
9142 -> 9140;
9142 -> 9141;
9143 -> 9138;
9143 -> 9137;
9143 -> 9141;
9144 -> 9143;
9144 -> 9137;
9144 -> 8425;
9144 -> 9141;
9145 -> 9144;
9145 -> 8427;
9145 -> 9141;
9146 -> 9142;
9146 -> 9141;
9147 -> 9141;
9148 -> 9145;
9148 -> 9147;
9149 -> 9146;
9149 -> 9147;
9150 -> 9148;
9151 -> 9148;
9151 -> 9137;
9152 -> 9151;
9153 -> 9152;
9154 -> 9152;
9154 -> 9153;
9155 -> 9153;
9155 -> 9152;
9156 -> 9152;
9156 -> 9151;
9157 -> 9151;
9158 -> 9156;
9158 -> 9157;
9159 -> 9138;
9159 -> 9137;
9159 -> 9151;
9160 -> 9151;
9161 -> 9158;
9161 -> 9151;
9162 -> 9161;
9163 -> 9162;
9164 -> 9163;
9164 -> 9162;
9165 -> 9162;
9166 -> 9162;
9167 -> 9165;
9167 -> 9151;
9168 -> 9151;
9169 -> 9167;
9169 -> 9168;
9170 -> 9138;
9170 -> 9158;
9170 -> 9168;
9171 -> 9170;
9171 -> 9158;
9171 -> 9168;
9172 -> 9169;
9172 -> 9168;
9173 -> 9168;
9174 -> 9172;
9174 -> 9173;
9175 -> 9171;
9175 -> 9174;
9175 -> 9168;
9176 -> 9165;
9176 -> 9137;
9177 -> 9065;
9177 -> 9176;
9178 -> 9177;
9178 -> 8967;
9179 -> 8932;
9179 -> 8967;
9180 -> 8927;
9180 -> 8967;
9181 -> 8967;
9182 -> 9178;
9182 -> 9181;
9183 -> 9179;
9183 -> 9181;
9184 -> 9180;
9184 -> 9181;
9185 -> 9184;
9185 -> 9158;
9185 -> 9181;
9186 -> 9185;
9186 -> 9183;
9186 -> 9181;
9186 -> 9158;
9186 -> 9175;
9186 -> 8810;
9187 -> 9186;
9187 -> 9181;
9188 -> 9182;
9188 -> 9026;
9188 -> 9181;
9189 -> 9182;
9189 -> 9028;
9189 -> 9181;
9190 -> 9186;
9190 -> 9181;
9191 -> 9188;
9191 -> 9186;
9191 -> 9181;
9192 -> 9190;
9192 -> 9181;
9193 -> 9192;
9193 -> 9181;
9194 -> 9192;
9194 -> 9186;
9194 -> 9181;
9195 -> 9194;
9196 -> 9195;
9196 -> 9181;
9197 -> 9181;
9198 -> 9197;
9198 -> 9181;
9199 -> 9181;
9200 -> 9188;
9200 -> 9181;
9201 -> 9199;
9201 -> 9181;
9202 -> 9181;
9203 -> 9188;
9203 -> 9202;
9204 -> 0;
9204 -> 9202;
9205 -> 9204;
9205 -> 9181;
9206 -> 9205;
9206 -> 9181;
9207 -> 9181;
9208 -> 9206;
9208 -> 9207;
9209 -> 9201;
9209 -> 9207;
9210 -> 9208;
9210 -> 0;
9210 -> 9207;
9211 -> 9208;
9211 -> 9210;
9212 -> 9181;
9213 -> 9188;
9213 -> 9212;
9214 -> 9213;
9214 -> 9191;
9214 -> 9212;
9215 -> 9214;
9215 -> 9181;
9216 -> 9181;
9217 -> 9215;
9217 -> 9181;
9218 -> 9215;
9218 -> 9217;
9219 -> 9218;
9219 -> 9181;
9220 -> 9215;
9220 -> 9181;
9221 -> 9205;
9221 -> 9211;
9221 -> 9181;
9222 -> 9221;
9222 -> 9219;
9222 -> 9181;
9223 -> 9181;
9224 -> 9188;
9224 -> 9223;
9225 -> 9223;
9226 -> 9225;
9226 -> 9223;
9227 -> 9223;
9228 -> 9226;
9228 -> 9227;
9229 -> 9224;
9229 -> 9227;
9230 -> 9227;
9231 -> 9229;
9231 -> 9230;
9232 -> 9230;
9233 -> 9232;
9233 -> 9227;
9234 -> 9227;
9235 -> 9229;
9235 -> 9234;
9236 -> 9235;
9236 -> 9191;
9236 -> 9234;
9237 -> 9236;
9237 -> 9227;
9238 -> 9227;
9239 -> 9237;
9239 -> 9238;
9240 -> 9238;
9240 -> 9227;
9241 -> 9233;
9241 -> 9240;
9241 -> 9227;
9242 -> 9227;
9243 -> 9229;
9243 -> 9242;
9244 -> 9243;
9244 -> 9242;
9245 -> 9244;
9245 -> 9191;
9245 -> 9242;
9246 -> 9245;
9246 -> 9227;
9247 -> 9227;
9248 -> 9246;
9248 -> 9247;
9249 -> 9227;
9250 -> 9248;
9250 -> 9249;
9251 -> 9249;
9251 -> 9227;
9252 -> 9227;
9253 -> 9241;
9253 -> 9251;
9253 -> 9227;
9254 -> 9227;
9255 -> 9229;
9255 -> 9254;
9256 -> 9255;
9256 -> 9191;
9256 -> 9254;
9257 -> 9256;
9257 -> 9227;
9258 -> 9257;
9258 -> 4027;
9258 -> 9227;
9259 -> 9253;
9259 -> 9258;
9259 -> 9227;
9260 -> 9227;
9261 -> 9227;
9262 -> 9261;
9262 -> 9181;
9263 -> 9188;
9263 -> 9186;
9264 -> 9263;
9264 -> 8936;
9264 -> 8926;
9265 -> 8936;
9265 -> 8974;
9265 -> 8926;
9266 -> 9265;
9266 -> 8926;
9268 -> 9267;
9270 -> 9269;
9272 -> 9271;
9274 -> 9273;
9276 -> 9275;
9278 -> 9277;
9279 -> 9278;
9281 -> 9280;
9284 -> 9282;
9284 -> 9283;
9285 -> 9284;
9288 -> 9286;
9288 -> 9287;
9289 -> 9288;
9290 -> 9279;
9290 -> 9270;
9291 -> 9290;
9292 -> 9278;
9293 -> 9276;
9294 -> 9281;
9295 -> 8966;
9295 -> 8926;
9296 -> 8932;
9296 -> 8810;
9296 -> 8926;
9297 -> 9265;
9297 -> 8926;
9298 -> 8926;
9299 -> 8926;
9300 -> 9295;
9300 -> 9299;
9301 -> 9296;
9301 -> 9299;
9302 -> 9297;
9302 -> 9299;
9303 -> 9298;
9303 -> 9299;
9304 -> 9300;
9304 -> 9276;
9304 -> 9299;
9305 -> 9304;
9305 -> 9272;
9305 -> 9299;
9306 -> 9301;
9306 -> 9299;
9307 -> 9306;
9308 -> 9302;
9308 -> 9299;
9309 -> 9285;
9309 -> 9308;
9310 -> 9305;
9310 -> 9307;
9310 -> 9299;
9311 -> 9310;
9311 -> 9309;
9311 -> 9299;
9312 -> 9311;
9312 -> 9303;
9312 -> 9299;
9313 -> 9298;
9313 -> 8936;
9313 -> 8926;
9314 -> 8926;
9315 -> 8936;
9315 -> 9314;
9316 -> 9314;
9317 -> 9315;
9317 -> 9313;
9317 -> 9316;
9318 -> 9317;
9318 -> 9312;
9318 -> 9272;
9318 -> 9316;
9319 -> 9318;
9319 -> 9314;
9320 -> 9319;
9320 -> 8926;
9321 -> 8926;
9322 -> 8936;
9322 -> 9321;
9323 -> 9321;
9324 -> 9322;
9324 -> 9313;
9324 -> 9323;
9325 -> 9324;
9325 -> 9312;
9325 -> 9309;
9325 -> 9323;
9326 -> 9323;
9327 -> 9325;
9327 -> 9321;
9328 -> 9327;
9328 -> 8926;
9329 -> 8853;
9330 -> 8917;
9330 -> 9329;
9331 -> 0;
9331 -> 9329;
9332 -> 9331;
9332 -> 8853;
9333 -> 8853;
9334 -> 9332;
9334 -> 9333;
9335 -> 9334;
9335 -> 9333;
9336 -> 9333;
9337 -> 8864;
9337 -> 8853;
9338 -> 9337;
9339 -> 8917;
9339 -> 9338;
9340 -> 9338;
9341 -> 9339;
9341 -> 9313;
9341 -> 9340;
9342 -> 9341;
9342 -> 9312;
9342 -> 9272;
9342 -> 9340;
9343 -> 9342;
9343 -> 9338;
9344 -> 9343;
9344 -> 9337;
9345 -> 9335;
9345 -> 9344;
9346 -> 8917;
9346 -> 8853;
9347 -> 8819;
9347 -> 9346;
9347 -> 8940;
9347 -> 8942;
9347 -> 8963;
9347 -> 8974;
9347 -> 8962;
9347 -> 8947;
9347 -> 8948;
9347 -> 8964;
9347 -> 8965;
9347 -> 9264;
9347 -> 9313;
9347 -> 0;
9347 -> 9191;
9347 -> 8810;
9347 -> 9026;
9347 -> 9027;
9347 -> 9028;
9347 -> 9312;
9347 -> 8820;
9348 -> 8961;
9348 -> 8820;
9349 -> 8819;
9349 -> 9347;
9349 -> 8818;
9350 -> 8758;
9351 -> 8789;
9351 -> 9349;
9351 -> 9350;
9351 -> 8758;
9352 -> 8759;
9352 -> 9349;
9352 -> 8758;
9353 -> 8758;
9354 -> 9351;
9354 -> 9353;
9355 -> 9352;
9355 -> 9353;
9356 -> 9354;
9356 -> 9353;
9357 -> 9355;
9357 -> 9353;
9358 -> 9353;
9359 -> 9353;
9360 -> 9356;
9360 -> 9359;
9361 -> 9360;
9361 -> 9353;
9362 -> 9353;
9363 -> 8758;
9364 -> 8789;
9364 -> 9349;
9364 -> 9363;
9364 -> 8758;
9365 -> 9354;
9365 -> 9364;
9365 -> 8758;
9366 -> 8765;
9366 -> 8758;
9367 -> 8759;
9367 -> 8758;
9368 -> 8758;
9369 -> 8758;
9370 -> 9368;
9370 -> 9369;
9371 -> 8759;
9371 -> 9369;
9372 -> 0;
9372 -> 9369;
9373 -> 9369;
9374 -> 9372;
9374 -> 9373;
9375 -> 9371;
9375 -> 9373;
9376 -> 9373;
9377 -> 9374;
9377 -> 9376;
9377 -> 9373;
9378 -> 9374;
9378 -> 9375;
9378 -> 9349;
9378 -> 9373;
9379 -> 9378;
9379 -> 8758;
9380 -> 8789;
9380 -> 9349;
9380 -> 9368;
9380 -> 8758;
9381 -> 8961;
9381 -> 8758;
9382 -> 8758;
9383 -> 9366;
9383 -> 9382;
9384 -> 9367;
9384 -> 9382;
9385 -> 9379;
9385 -> 9382;
9386 -> 9368;
9386 -> 9382;
9387 -> 9380;
9387 -> 9382;
9388 -> 9367;
9388 -> 9382;
9389 -> 9368;
9389 -> 9382;
9390 -> 9381;
9390 -> 9382;
9391 -> 9383;
9391 -> 9382;
9392 -> 9384;
9392 -> 9382;
9393 -> 9386;
9393 -> 9382;
9394 -> 9388;
9394 -> 9382;
9395 -> 9389;
9395 -> 9382;
9396 -> 9382;
9397 -> 9391;
9397 -> 9396;
9398 -> 9392;
9398 -> 9396;
9399 -> 9385;
9399 -> 9396;
9400 -> 9393;
9400 -> 9396;
9401 -> 9387;
9401 -> 9396;
9402 -> 9394;
9402 -> 9396;
9403 -> 9395;
9403 -> 9396;
9404 -> 9390;
9404 -> 9396;
9405 -> 9396;
9406 -> 9396;
9407 -> 9396;
9408 -> 9406;
9408 -> 9407;
9409 -> 9387;
9409 -> 9407;
9410 -> 9408;
9410 -> 0;
9410 -> 9407;
9411 -> 9408;
9411 -> 9407;
9412 -> 9387;
9412 -> 9411;
9413 -> 9411;
9414 -> 9412;
9414 -> 9413;
9415 -> 9413;
9416 -> 9414;
9416 -> 9415;
9417 -> 9415;
9418 -> 9416;
9418 -> 9417;
9419 -> 9417;
9420 -> 9418;
9420 -> 9419;
9421 -> 9420;
9421 -> 9419;
9422 -> 9421;
9422 -> 9417;
9423 -> 9422;
9423 -> 9415;
9424 -> 9423;
9424 -> 9413;
9425 -> 9413;
9426 -> 9424;
9426 -> 9425;
9427 -> 9387;
9427 -> 9407;
9428 -> 9427;
9428 -> 9407;
9429 -> 9387;
9429 -> 9428;
9430 -> 9428;
9431 -> 9429;
9431 -> 9430;
9432 -> 9430;
9433 -> 9431;
9433 -> 9432;
9434 -> 9432;
9435 -> 9433;
9435 -> 9434;
9436 -> 9434;
9437 -> 9435;
9437 -> 9436;
9438 -> 9437;
9438 -> 9436;
9439 -> 9438;
9439 -> 9434;
9440 -> 9439;
9440 -> 9432;
9441 -> 9440;
9441 -> 9430;
9442 -> 9430;
9443 -> 9441;
9443 -> 9442;
9444 -> 9408;
9444 -> 0;
9444 -> 9407;
9445 -> 9407;
9446 -> 9443;
9446 -> 9445;
9446 -> 9407;
9447 -> 9407;
9448 -> 9387;
9448 -> 9447;
9448 -> 9407;
9449 -> 9407;
9449 -> 9396;
9450 -> 9404;
9450 -> 9387;
9451 -> 9401;
9451 -> 9387;
9452 -> 9387;
9453 -> 9450;
9453 -> 9387;
9454 -> 9387;
9455 -> 9387;
9456 -> 9387;
9457 -> 9387;
9458 -> 9387;
9459 -> 9387;
9460 -> 9387;
9461 -> 9387;
9461 -> 9460;
9462 -> 9461;
9462 -> 9387;
9462 -> 9460;
9463 -> 9462;
9463 -> 9460;
9464 -> 9463;
9464 -> 9387;
9465 -> 9387;
9466 -> 9451;
9466 -> 9387;
9467 -> 0;
9467 -> 9466;
9468 -> 9387;
9469 -> 9468;
9470 -> 9469;
9470 -> 9468;
9471 -> 9470;
9471 -> 9468;
9472 -> 9468;
9473 -> 9468;
9473 -> 9387;
9474 -> 9473;
9474 -> 9387;
9475 -> 0;
9475 -> 9387;
9476 -> 0;
9476 -> 9387;
9477 -> 0;
9477 -> 9387;
9478 -> 0;
9478 -> 9387;
9479 -> 9387;
9480 -> 9479;
9481 -> 9480;
9481 -> 9387;
9481 -> 9479;
9482 -> 9291;
9482 -> 9387;
9483 -> 9467;
9483 -> 9482;
9483 -> 9387;
9484 -> 9387;
9485 -> 9387;
9485 -> 9484;
9486 -> 9484;
9487 -> 9485;
9487 -> 9387;
9487 -> 9486;
9488 -> 9487;
9488 -> 9483;
9488 -> 9272;
9488 -> 9486;
9489 -> 9488;
9489 -> 9484;
9490 -> 9489;
9490 -> 9387;
9491 -> 9387;
9492 -> 9387;
9492 -> 9491;
9493 -> 9491;
9494 -> 9492;
9494 -> 9387;
9494 -> 9493;
9495 -> 9494;
9495 -> 9483;
9495 -> 9309;
9495 -> 9493;
9496 -> 9493;
9497 -> 9495;
9497 -> 9491;
9498 -> 9497;
9498 -> 9387;
9499 -> 9396;
9500 -> 9401;
9500 -> 9499;
9501 -> 0;
9501 -> 9499;
9502 -> 9501;
9502 -> 9396;
9503 -> 9396;
9504 -> 9502;
9504 -> 9503;
9505 -> 9504;
9505 -> 9503;
9506 -> 9503;
9507 -> 9403;
9507 -> 9396;
9508 -> 9507;
9509 -> 9401;
9509 -> 9508;
9510 -> 9508;
9511 -> 9509;
9511 -> 9387;
9511 -> 9510;
9512 -> 9511;
9512 -> 9483;
9512 -> 9272;
9512 -> 9510;
9513 -> 9512;
9513 -> 9508;
9514 -> 9513;
9514 -> 9507;
9515 -> 9514;
9515 -> 9505;
9515 -> 9507;
9516 -> 9465;
9516 -> 9515;
9516 -> 9507;
9517 -> 8808;
9517 -> 9516;
9517 -> 8758;
9518 -> 8789;
9518 -> 8758;
9519 -> 9349;
9519 -> 8758;
9520 -> 9401;
9520 -> 8758;
9521 -> 8758;
9522 -> 8758;
9523 -> 9518;
9523 -> 9522;
9524 -> 9519;
9524 -> 9522;
9525 -> 9520;
9525 -> 9522;
9526 -> 9521;
9526 -> 9522;
9527 -> 9526;
9527 -> 9522;
9528 -> 9523;
9528 -> 9526;
9528 -> 9522;
9529 -> 9524;
9529 -> 9526;
9529 -> 9522;
9530 -> 9525;
9530 -> 9526;
9530 -> 9522;
9531 -> 8759;
9531 -> 9349;
9531 -> 8758;
9532 -> 9521;
9532 -> 8758;
9533 -> 9531;
9533 -> 9532;
9533 -> 9530;
9533 -> 9528;
9533 -> 9529;
9533 -> 9349;
9533 -> 8789;
9533 -> 9387;
9533 -> 9481;
9533 -> 9477;
9533 -> 9478;
9533 -> 9475;
9533 -> 9476;
9533 -> 0;
9533 -> 9408;
9533 -> 9483;
9533 -> 8758;
9534 -> 9533;
9534 -> 8756;
9535 -> 8754;
9536 -> 9534;
9536 -> 9533;
9536 -> 9535;
9537 -> 9536;
9537 -> 9533;
9537 -> 9535;
9538 -> 8752;
9539 -> 9537;
9539 -> 9538;
9540 -> 9539;
9540 -> 9533;
9540 -> 9538;
9541 -> 8750;
9542 -> 9539;
9542 -> 9541;
9543 -> 9541;
9544 -> 9542;
9544 -> 9543;
9545 -> 9544;
9545 -> 9541;
9546 -> 9545;
9546 -> 8732;
9547 -> 8749;
9547 -> 9546;
9547 -> 8732;
9548 -> 8732;
9549 -> 8720;
9549 -> 9548;
9550 -> 9549;
9550 -> 9533;
9550 -> 9548;
9551 -> 9549;
9551 -> 9533;
9551 -> 9550;
9552 -> 9551;
9552 -> 8732;
9553 -> 8732;
9554 -> 9547;
9554 -> 9552;
9554 -> 8732;
9555 -> 9554;
9556 -> 9555;
9557 -> 9555;
9557 -> 9554;
9558 -> 0;
9558 -> 9557;
9559 -> 9558;
9559 -> 8718;
9560 -> 8718;
9561 -> 9559;
9561 -> 9560;
9562 -> 8712;
9562 -> 9533;
9562 -> 9560;
9563 -> 9561;
9563 -> 8371;
9563 -> 9560;
9564 -> 9561;
9564 -> 8371;
9564 -> 9560;
9565 -> 9562;
9565 -> 9533;
9565 -> 9560;
9566 -> 9564;
9566 -> 9560;
9567 -> 9560;
9568 -> 9565;
9568 -> 9567;
9569 -> 9566;
9569 -> 9567;
9570 -> 9568;
9570 -> 9569;
9570 -> 9567;
9571 -> 9567;
9572 -> 9562;
9572 -> 9533;
9572 -> 9560;
9573 -> 9564;
9573 -> 9560;
9574 -> 9572;
9574 -> 9573;
9574 -> 9560;
9575 -> 8718;
9576 -> 8711;
9577 -> 8712;
9577 -> 9533;
9577 -> 9576;
9578 -> 9577;
9578 -> 9533;
9578 -> 9574;
9578 -> 8369;
9578 -> 9576;
9579 -> 9578;
9579 -> 8711;
9580 -> 9579;
9580 -> 8709;
9581 -> 9580;
9581 -> 0;
9581 -> 8709;
9582 -> 8709;
9583 -> 8710;
9583 -> 9582;
9584 -> 9583;
9584 -> 9533;
9584 -> 9574;
9584 -> 9582;
9585 -> 9584;
9585 -> 8709;
9586 -> 9580;
9586 -> 8674;
9586 -> 8709;
9587 -> 9585;
9587 -> 9586;
9587 -> 8709;
9588 -> 8664;
9588 -> 7377;
9588 -> 0;
9588 -> 8709;
9589 -> 8709;
9590 -> 8709;
9591 -> 8710;
9591 -> 9590;
9592 -> 9590;
9593 -> 9592;
9594 -> 9591;
9594 -> 9592;
9595 -> 0;
9595 -> 9592;
9596 -> 9592;
9597 -> 9595;
9597 -> 9596;
9598 -> 9594;
9598 -> 9596;
9599 -> 9596;
9600 -> 9597;
9600 -> 9599;
9600 -> 9596;
9601 -> 9597;
9601 -> 9598;
9601 -> 9533;
9601 -> 9596;
9602 -> 9596;
9603 -> 9601;
9603 -> 9590;
9604 -> 9603;
9604 -> 9590;
9605 -> 9604;
9605 -> 9590;
9606 -> 9605;
9606 -> 9590;
9607 -> 9606;
9607 -> 8709;
9608 -> 8709;
9609 -> 8710;
9609 -> 9608;
9610 -> 9608;
9611 -> 9609;
9611 -> 9533;
9611 -> 9610;
9612 -> 9611;
9612 -> 9533;
9612 -> 9610;
9613 -> 9608;
9614 -> 9613;
9615 -> 9609;
9615 -> 9613;
9616 -> 0;
9616 -> 9613;
9617 -> 9613;
9618 -> 9616;
9618 -> 9617;
9619 -> 9615;
9619 -> 9617;
9620 -> 9617;
9621 -> 9618;
9621 -> 9620;
9621 -> 9617;
9622 -> 9618;
9622 -> 9619;
9622 -> 9533;
9622 -> 9617;
9623 -> 9617;
9624 -> 9612;
9624 -> 9622;
9624 -> 9608;
9625 -> 9624;
9625 -> 9608;
9626 -> 9625;
9626 -> 9608;
9627 -> 9626;
9627 -> 8709;
9628 -> 9607;
9628 -> 9627;
9628 -> 8709;
9629 -> 8709;
9630 -> 8710;
9630 -> 9629;
9631 -> 0;
9631 -> 9629;
9632 -> 9629;
9633 -> 9631;
9633 -> 9632;
9634 -> 9630;
9634 -> 9632;
9635 -> 9632;
9636 -> 9633;
9636 -> 9635;
9636 -> 9632;
9637 -> 9633;
9637 -> 9634;
9637 -> 9533;
9637 -> 9632;
9638 -> 9632;
9639 -> 9637;
9639 -> 8709;
9640 -> 9628;
9640 -> 9639;
9640 -> 8709;
9641 -> 9587;
9641 -> 9640;
9641 -> 8709;
9642 -> 8710;
9642 -> 8709;
9643 -> 8664;
9643 -> 7377;
9643 -> 8709;
9644 -> 9642;
9644 -> 9643;
9644 -> 8665;
9644 -> 9533;
9644 -> 9574;
9644 -> 7377;
9644 -> 8709;
9645 -> 8709;
9646 -> 9644;
9646 -> 9645;
9647 -> 9644;
9647 -> 9645;
9648 -> 9645;
9649 -> 9646;
9649 -> 9648;
9650 -> 9648;
9651 -> 9649;
9651 -> 9650;
9652 -> 9651;
9652 -> 9644;
9652 -> 9648;
9653 -> 9652;
9653 -> 9645;
9654 -> 9644;
9654 -> 9645;
9655 -> 9644;
9655 -> 9645;
9656 -> 9645;
9657 -> 9654;
9657 -> 9656;
9658 -> 9656;
9659 -> 9657;
9659 -> 9658;
9660 -> 9659;
9660 -> 9653;
9660 -> 9658;
9661 -> 9656;
9662 -> 9660;
9662 -> 9653;
9662 -> 9661;
9663 -> 9661;
9664 -> 9662;
9664 -> 9653;
9664 -> 9663;
9665 -> 9664;
9665 -> 9653;
9665 -> 9272;
9665 -> 9663;
9666 -> 9665;
9666 -> 9661;
9667 -> 9666;
9667 -> 9645;
9668 -> 9644;
9668 -> 9645;
9669 -> 9644;
9669 -> 9645;
9670 -> 9645;
9671 -> 9668;
9671 -> 9670;
9672 -> 9670;
9673 -> 9672;
9674 -> 9671;
9674 -> 9667;
9674 -> 9673;
9675 -> 9672;
9676 -> 9670;
9677 -> 9674;
9677 -> 9667;
9677 -> 9676;
9678 -> 9674;
9678 -> 9645;
9679 -> 9644;
9679 -> 9645;
9680 -> 9644;
9680 -> 9645;
9681 -> 9644;
9681 -> 9645;
9682 -> 9680;
9682 -> 9645;
9683 -> 9682;
9683 -> 9645;
9684 -> 9679;
9684 -> 9645;
9685 -> 9680;
9685 -> 9645;
9686 -> 9645;
9687 -> 9684;
9687 -> 9686;
9688 -> 9685;
9688 -> 9686;
9689 -> 9681;
9689 -> 9686;
9690 -> 9686;
9691 -> 9687;
9691 -> 9690;
9692 -> 9690;
9693 -> 9691;
9693 -> 9692;
9694 -> 9692;
9695 -> 9693;
9695 -> 9694;
9696 -> 9695;
9696 -> 9694;
9697 -> 9696;
9697 -> 9692;
9698 -> 9697;
9698 -> 9690;
9699 -> 9698;
9699 -> 9686;
9700 -> 9686;
9701 -> 9699;
9701 -> 9700;
9702 -> 9701;
9702 -> 9678;
9702 -> 9700;
9703 -> 9702;
9703 -> 9688;
9703 -> 9686;
9704 -> 9703;
9705 -> 9687;
9705 -> 9704;
9706 -> 9704;
9707 -> 9705;
9707 -> 9706;
9708 -> 9706;
9709 -> 9707;
9709 -> 9708;
9710 -> 9708;
9711 -> 9709;
9711 -> 9710;
9712 -> 9711;
9712 -> 9708;
9713 -> 9712;
9713 -> 9706;
9714 -> 9713;
9714 -> 9704;
9715 -> 9714;
9715 -> 9703;
9716 -> 9715;
9717 -> 9644;
9717 -> 9645;
9718 -> 9644;
9718 -> 9645;
9719 -> 9645;
9720 -> 9717;
9720 -> 9719;
9721 -> 9719;
9722 -> 9720;
9722 -> 9716;
9722 -> 9721;
9723 -> 9722;
9723 -> 9645;
9724 -> 9644;
9724 -> 9645;
9725 -> 9644;
9725 -> 9645;
9726 -> 9645;
9727 -> 9724;
9727 -> 9726;
9728 -> 9726;
9729 -> 9727;
9729 -> 9728;
9730 -> 9729;
9730 -> 9723;
9730 -> 9728;
9731 -> 9726;
9732 -> 9730;
9732 -> 9731;
9733 -> 9732;
9733 -> 9723;
9733 -> 9731;
9734 -> 9732;
9734 -> 9645;
9735 -> 8671;
9735 -> 8676;
9736 -> 8676;
9737 -> 9734;
9738 -> 9737;
9738 -> 9734;
9739 -> 8664;
9739 -> 7377;
9739 -> 9734;
9740 -> 9734;
9741 -> 9734;
9741 -> 9740;
9742 -> 0;
9742 -> 9740;
9743 -> 9742;
9743 -> 9734;
9744 -> 9734;
9745 -> 9744;
9746 -> 9744;
9746 -> 9734;
9747 -> 9746;
9747 -> 8669;
9747 -> 9734;
9748 -> 9743;
9748 -> 9747;
9748 -> 9734;
9749 -> 9734;
9750 -> 9734;
9750 -> 9749;
9751 -> 9749;
9752 -> 9750;
9752 -> 9751;
9753 -> 9752;
9753 -> 9749;
9754 -> 0;
9754 -> 9753;
9755 -> 9754;
9755 -> 9734;
9756 -> 9748;
9756 -> 9755;
9756 -> 9734;
9757 -> 9734;
9758 -> 9744;
9758 -> 9757;
9758 -> 9734;
9759 -> 9744;
9760 -> 9744;
9760 -> 9759;
9761 -> 9759;
9761 -> 9744;
9762 -> 9744;
9763 -> 9744;
9764 -> 9744;
9765 -> 9764;
9765 -> 9744;
9766 -> 9765;
9767 -> 9765;
9767 -> 9766;
9768 -> 9766;
9769 -> 9767;
9769 -> 9768;
9770 -> 9768;
9771 -> 9769;
9771 -> 9744;
9771 -> 9770;
9771 -> 9768;
9772 -> 9766;
9773 -> 9767;
9773 -> 9744;
9773 -> 9766;
9774 -> 9773;
9774 -> 9765;
9775 -> 9765;
9776 -> 9744;
9777 -> 9744;
9778 -> 9744;
9779 -> 9777;
9779 -> 9778;
9780 -> 9744;
9781 -> 9779;
9781 -> 9780;
9781 -> 9744;
9782 -> 9744;
9783 -> 9782;
9783 -> 9744;
9784 -> 9744;
9785 -> 9779;
9786 -> 9779;
9786 -> 9785;
9787 -> 9744;
9787 -> 9785;
9788 -> 0;
9788 -> 9785;
9789 -> 9785;
9790 -> 9788;
9790 -> 9789;
9791 -> 9787;
9791 -> 9789;
9792 -> 9789;
9793 -> 9790;
9793 -> 9792;
9793 -> 9789;
9794 -> 9790;
9794 -> 9791;
9794 -> 9779;
9794 -> 9789;
9795 -> 9784;
9795 -> 9779;
9796 -> 9794;
9796 -> 9779;
9797 -> 9779;
9798 -> 9795;
9798 -> 9779;
9799 -> 9796;
9799 -> 9779;
9800 -> 9797;
9800 -> 9779;
9801 -> 9798;
9801 -> 9779;
9802 -> 9779;
9803 -> 9779;
9803 -> 0;
9804 -> 9779;
9805 -> 9779;
9805 -> 9804;
9806 -> 9804;
9807 -> 9805;
9807 -> 9806;
9808 -> 9806;
9809 -> 9807;
9809 -> 9808;
9810 -> 9809;
9810 -> 9806;
9811 -> 9806;
9812 -> 9810;
9812 -> 9811;
9813 -> 9779;
9814 -> 9813;
9814 -> 9779;
9815 -> 9779;
9815 -> 9814;
9816 -> 9814;
9817 -> 9815;
9817 -> 9816;
9818 -> 9816;
9819 -> 9817;
9819 -> 9818;
9820 -> 9819;
9820 -> 9816;
9821 -> 9816;
9822 -> 9820;
9822 -> 9821;
9823 -> 9779;
9823 -> 0;
9824 -> 9779;
9825 -> 9822;
9825 -> 9824;
9825 -> 9779;
9826 -> 9779;
9827 -> 9779;
9828 -> 9801;
9828 -> 9779;
9829 -> 9779;
9830 -> 9779;
9831 -> 9779;
9832 -> 9779;
9833 -> 9779;
9834 -> 9779;
9835 -> 9779;
9836 -> 9779;
9836 -> 9835;
9837 -> 9836;
9837 -> 9779;
9837 -> 9835;
9838 -> 9837;
9838 -> 9835;
9839 -> 9838;
9839 -> 9779;
9840 -> 9779;
9841 -> 9779;
9842 -> 9779;
9843 -> 9827;
9843 -> 9779;
9844 -> 9827;
9844 -> 9779;
9845 -> 9779;
9846 -> 9779;
9847 -> 9827;
9847 -> 9779;
9848 -> 9847;
9848 -> 9779;
9849 -> 9827;
9849 -> 9848;
9850 -> 9848;
9851 -> 9849;
9851 -> 9850;
9852 -> 9850;
9853 -> 9851;
9853 -> 9852;
9854 -> 9853;
9854 -> 9850;
9855 -> 9850;
9856 -> 9854;
9856 -> 9855;
9857 -> 9827;
9857 -> 0;
9857 -> 9779;
9858 -> 9856;
9858 -> 9824;
9858 -> 9779;
9859 -> 9827;
9859 -> 9826;
9859 -> 9779;
9860 -> 9779;
9861 -> 9779;
9861 -> 9860;
9862 -> 0;
9862 -> 9860;
9863 -> 9862;
9863 -> 9779;
9864 -> 9863;
9864 -> 9779;
9865 -> 9864;
9865 -> 9779;
9866 -> 9779;
9867 -> 9827;
9867 -> 9866;
9868 -> 9867;
9868 -> 9827;
9868 -> 9866;
9869 -> 9868;
9869 -> 9866;
9870 -> 9869;
9870 -> 9779;
9871 -> 9779;
9872 -> 9865;
9872 -> 9871;
9873 -> 9872;
9873 -> 9871;
9874 -> 9871;
9875 -> 9873;
9875 -> 9874;
9876 -> 9875;
9876 -> 9874;
9877 -> 9876;
9877 -> 9871;
9878 -> 9877;
9878 -> 9779;
9879 -> 9779;
9880 -> 9865;
9880 -> 9879;
9881 -> 9879;
9882 -> 9880;
9882 -> 9881;
9883 -> 9882;
9883 -> 9827;
9883 -> 9881;
9884 -> 9883;
9884 -> 9879;
9885 -> 9879;
9886 -> 9884;
9886 -> 9885;
9886 -> 9879;
9887 -> 9886;
9887 -> 9879;
9888 -> 9887;
9889 -> 9884;
9889 -> 9888;
9890 -> 9888;
9891 -> 9889;
9891 -> 9890;
9892 -> 9890;
9893 -> 9891;
9893 -> 9892;
9894 -> 9892;
9894 -> 9890;
9895 -> 9891;
9895 -> 9888;
9896 -> 9895;
9896 -> 9779;
9897 -> 9779;
9898 -> 9865;
9898 -> 9779;
9899 -> 9779;
9900 -> 9898;
9900 -> 9899;
9901 -> 9897;
9901 -> 9899;
9902 -> 9900;
9902 -> 9899;
9903 -> 9899;
9904 -> 9900;
9904 -> 9903;
9905 -> 0;
9905 -> 9903;
9906 -> 9905;
9906 -> 9899;
9907 -> 9899;
9908 -> 9899;
9909 -> 9900;
9909 -> 9908;
9910 -> 9908;
9911 -> 9909;
9911 -> 9910;
9912 -> 9911;
9912 -> 9827;
9912 -> 9910;
9913 -> 9912;
9913 -> 9908;
9914 -> 0;
9914 -> 9913;
9915 -> 9914;
9915 -> 9899;
9916 -> 9899;
9917 -> 9900;
9917 -> 9916;
9918 -> 9917;
9918 -> 9827;
9918 -> 9916;
9919 -> 9918;
9919 -> 9899;
9920 -> 9919;
9920 -> 9899;
9921 -> 9920;
9922 -> 0;
9922 -> 9921;
9923 -> 9921;
9923 -> 9920;
9924 -> 9919;
9924 -> 9920;
9925 -> 9924;
9925 -> 9827;
9925 -> 9920;
9926 -> 9899;
9927 -> 9926;
9927 -> 9779;
9928 -> 9827;
9929 -> 9928;
9929 -> 9827;
9930 -> 9929;
9930 -> 9827;
9931 -> 9827;
9932 -> 9928;
9933 -> 9928;
9933 -> 9932;
9934 -> 9932;
9934 -> 9928;
9935 -> 9928;
9936 -> 9935;
9936 -> 9928;
9937 -> 9928;
9938 -> 9928;
9938 -> 9779;
9939 -> 9928;
9939 -> 9827;
9939 -> 9779;
9940 -> 9928;
9940 -> 9779;
9941 -> 9940;
9941 -> 9779;
9942 -> 9941;
9942 -> 9779;
9943 -> 9941;
9943 -> 9928;
9943 -> 9779;
9944 -> 9943;
9945 -> 9944;
9945 -> 9779;
9946 -> 9779;
9947 -> 9946;
9947 -> 9779;
9948 -> 9779;
9949 -> 9928;
9949 -> 9779;
9950 -> 9948;
9950 -> 9779;
9951 -> 9779;
9952 -> 9928;
9952 -> 9951;
9953 -> 0;
9953 -> 9951;
9954 -> 9953;
9954 -> 9779;
9955 -> 9954;
9955 -> 9779;
9956 -> 9779;
9957 -> 9955;
9957 -> 9956;
9958 -> 9950;
9958 -> 9956;
9959 -> 9957;
9959 -> 0;
9959 -> 9956;
9960 -> 9957;
9960 -> 9959;
9961 -> 9779;
9962 -> 9928;
9962 -> 9961;
9963 -> 9962;
9963 -> 9928;
9963 -> 9961;
9964 -> 9963;
9964 -> 9779;
9965 -> 9779;
9966 -> 9964;
9966 -> 9779;
9967 -> 9964;
9967 -> 9966;
9968 -> 9967;
9968 -> 9779;
9969 -> 9964;
9969 -> 9779;
9970 -> 9954;
9970 -> 9960;
9970 -> 9779;
9971 -> 9970;
9971 -> 9968;
9971 -> 9779;
9972 -> 9779;
9973 -> 9928;
9973 -> 9972;
9974 -> 9972;
9975 -> 9974;
9975 -> 9972;
9976 -> 9972;
9977 -> 9975;
9977 -> 9976;
9978 -> 9973;
9978 -> 9976;
9979 -> 9976;
9980 -> 9978;
9980 -> 9979;
9981 -> 9979;
9982 -> 9981;
9982 -> 9976;
9983 -> 9976;
9984 -> 9978;
9984 -> 9983;
9985 -> 9984;
9985 -> 9928;
9985 -> 9983;
9986 -> 9985;
9986 -> 9976;
9987 -> 9976;
9988 -> 9986;
9988 -> 9987;
9989 -> 9987;
9989 -> 9976;
9990 -> 9982;
9990 -> 9989;
9990 -> 9976;
9991 -> 9976;
9992 -> 9978;
9992 -> 9991;
9993 -> 9992;
9993 -> 9991;
9994 -> 9993;
9994 -> 9928;
9994 -> 9991;
9995 -> 9994;
9995 -> 9976;
9996 -> 9976;
9997 -> 9995;
9997 -> 9996;
9998 -> 9976;
9999 -> 9997;
9999 -> 9998;
10000 -> 9998;
10000 -> 9976;
10001 -> 9976;
10002 -> 9990;
10002 -> 10000;
10002 -> 9976;
10003 -> 9976;
10004 -> 9976;
10005 -> 10004;
10005 -> 9779;
10006 -> 9779;
10007 -> 10006;
10007 -> 9779;
10008 -> 9779;
10009 -> 9779;
10009 -> 10008;
10010 -> 10008;
10011 -> 10009;
10011 -> 9779;
10011 -> 10010;
10012 -> 10011;
10012 -> 9779;
10012 -> 10010;
10013 -> 10010;
10014 -> 10012;
10014 -> 10008;
10015 -> 10014;
10015 -> 9779;
10016 -> 9779;
10017 -> 9779;
10017 -> 10016;
10018 -> 0;
10018 -> 10016;
10019 -> 10018;
10019 -> 9779;
10020 -> 9779;
10021 -> 10019;
10021 -> 10020;
10022 -> 10021;
10022 -> 10020;
10023 -> 10020;
10024 -> 9800;
10024 -> 9779;
10025 -> 10024;
10026 -> 10025;
10026 -> 10024;
10027 -> 10022;
10027 -> 10026;
10028 -> 9779;
10028 -> 9797;
10028 -> 9928;
10028 -> 9827;
10029 -> 9840;
10029 -> 9779;
10030 -> 9744;
10031 -> 9779;
10031 -> 10028;
10031 -> 10030;
10031 -> 9744;
10032 -> 9744;
10032 -> 10028;
10033 -> 9744;
10034 -> 10031;
10034 -> 10033;
10035 -> 10032;
10035 -> 10033;
10036 -> 10034;
10036 -> 10033;
10037 -> 10035;
10037 -> 10033;
10038 -> 10033;
10039 -> 10033;
10040 -> 10036;
10040 -> 10039;
10041 -> 10040;
10041 -> 10033;
10042 -> 10033;
10043 -> 9744;
10044 -> 9779;
10044 -> 10028;
10044 -> 10043;
10044 -> 9744;
10045 -> 10034;
10045 -> 10044;
10045 -> 9744;
10046 -> 9744;
10047 -> 9744;
10047 -> 10046;
10048 -> 9744;
10048 -> 10046;
10049 -> 0;
10049 -> 10046;
10050 -> 10046;
10051 -> 10049;
10051 -> 10050;
10052 -> 10048;
10052 -> 10050;
10053 -> 10050;
10054 -> 10051;
10054 -> 10053;
10054 -> 10050;
10055 -> 10051;
10055 -> 10052;
10055 -> 10028;
10055 -> 10050;
10056 -> 10055;
10056 -> 9744;
10057 -> 9744;
10058 -> 9840;
10058 -> 9744;
10059 -> 10056;
10059 -> 9744;
10060 -> 10057;
10060 -> 9744;
10061 -> 10058;
10061 -> 9744;
10062 -> 10028;
10062 -> 9744;
10063 -> 9744;
10063 -> 0;
10064 -> 9744;
10065 -> 10028;
10065 -> 10064;
10066 -> 10064;
10067 -> 10065;
10067 -> 10066;
10068 -> 10066;
10069 -> 10067;
10069 -> 10068;
10070 -> 10069;
10070 -> 10066;
10071 -> 10066;
10072 -> 10070;
10072 -> 10071;
10073 -> 10028;
10073 -> 9744;
10074 -> 10073;
10074 -> 9744;
10075 -> 10028;
10075 -> 10074;
10076 -> 10074;
10077 -> 10075;
10077 -> 10076;
10078 -> 10076;
10079 -> 10077;
10079 -> 10078;
10080 -> 10079;
10080 -> 10076;
10081 -> 10076;
10082 -> 10080;
10082 -> 10081;
10083 -> 9744;
10083 -> 0;
10084 -> 9744;
10085 -> 10082;
10085 -> 10084;
10085 -> 9744;
10086 -> 9744;
10087 -> 10028;
10087 -> 10086;
10087 -> 9744;
10088 -> 10061;
10088 -> 10028;
10089 -> 10088;
10089 -> 10028;
10090 -> 10028;
10091 -> 10028;
10092 -> 10028;
10093 -> 10028;
10094 -> 10028;
10095 -> 10028;
10096 -> 10028;
10097 -> 10028;
10097 -> 10096;
10098 -> 10097;
10098 -> 10028;
10098 -> 10096;
10099 -> 10098;
10099 -> 10096;
10100 -> 10099;
10100 -> 10028;
10101 -> 10028;
10102 -> 10028;
10103 -> 10102;
10104 -> 10103;
10104 -> 10102;
10105 -> 10102;
10106 -> 10102;
10106 -> 10028;
10107 -> 10106;
10107 -> 10028;
10108 -> 10028;
10109 -> 10108;
10109 -> 10028;
10110 -> 10028;
10111 -> 10028;
10111 -> 10110;
10112 -> 10110;
10113 -> 10111;
10113 -> 10028;
10113 -> 10112;
10114 -> 10113;
10114 -> 10028;
10114 -> 9779;
10114 -> 10112;
10115 -> 10112;
10116 -> 10114;
10116 -> 10110;
10117 -> 10116;
10117 -> 10028;
10118 -> 9744;
10119 -> 10028;
10119 -> 10118;
10120 -> 0;
10120 -> 10118;
10121 -> 10120;
10121 -> 9744;
10122 -> 9744;
10123 -> 10121;
10123 -> 10122;
10124 -> 10123;
10124 -> 10122;
10125 -> 10122;
10126 -> 10060;
10126 -> 9744;
10127 -> 10126;
10128 -> 10028;
10128 -> 10127;
10129 -> 10128;
10129 -> 10126;
10130 -> 10129;
10130 -> 10124;
10130 -> 10126;
10131 -> 10101;
10131 -> 10130;
10131 -> 10126;
10132 -> 9781;
10132 -> 10131;
10132 -> 9744;
10133 -> 9744;
10134 -> 10028;
10134 -> 9744;
10135 -> 10028;
10136 -> 10028;
10136 -> 8371;
10136 -> 9734;
10137 -> 10028;
10137 -> 9734;
10138 -> 9734;
10139 -> 10137;
10139 -> 10138;
10140 -> 10137;
10140 -> 10138;
10141 -> 10139;
10141 -> 10140;
10141 -> 10138;
10142 -> 10138;
10143 -> 9734;
10144 -> 9734;
10144 -> 10028;
10144 -> 10143;
10145 -> 10144;
10145 -> 10028;
10145 -> 8369;
10145 -> 10143;
10146 -> 10145;
10146 -> 9734;
10147 -> 10146;
10147 -> 9734;
10148 -> 10147;
10148 -> 0;
10148 -> 9734;
10149 -> 9734;
10150 -> 10149;
10150 -> 10028;
10151 -> 10150;
10151 -> 9734;
10152 -> 10147;
10152 -> 8674;
10152 -> 9734;
10153 -> 10151;
10153 -> 10152;
10153 -> 9734;
10154 -> 8664;
10154 -> 7377;
10154 -> 0;
10154 -> 9734;
10155 -> 9734;
10156 -> 9734;
10157 -> 9734;
10157 -> 10156;
10158 -> 10156;
10159 -> 10158;
10160 -> 10157;
10160 -> 10158;
10161 -> 0;
10161 -> 10158;
10162 -> 10158;
10163 -> 10161;
10163 -> 10162;
10164 -> 10160;
10164 -> 10162;
10165 -> 10162;
10166 -> 10163;
10166 -> 10165;
10166 -> 10162;
10167 -> 10163;
10167 -> 10164;
10167 -> 10028;
10167 -> 10162;
10168 -> 10167;
10168 -> 10156;
10169 -> 10168;
10169 -> 10156;
10170 -> 10169;
10170 -> 10156;
10171 -> 10170;
10171 -> 10156;
10172 -> 10171;
10172 -> 9734;
10173 -> 9734;
10174 -> 9734;
10174 -> 10173;
10175 -> 10173;
10176 -> 10174;
10176 -> 10028;
10176 -> 10175;
10177 -> 10176;
10177 -> 10028;
10177 -> 10175;
10178 -> 10173;
10179 -> 10178;
10180 -> 10174;
10180 -> 10178;
10181 -> 0;
10181 -> 10178;
10182 -> 10178;
10183 -> 10181;
10183 -> 10182;
10184 -> 10180;
10184 -> 10182;
10185 -> 10182;
10186 -> 10183;
10186 -> 10185;
10186 -> 10182;
10187 -> 10183;
10187 -> 10184;
10187 -> 10028;
10187 -> 10182;
10188 -> 10177;
10188 -> 10187;
10188 -> 10173;
10189 -> 10188;
10189 -> 10173;
10190 -> 10189;
10190 -> 10173;
10191 -> 10190;
10191 -> 9734;
10192 -> 10172;
10192 -> 10191;
10192 -> 9734;
10193 -> 9734;
10194 -> 9734;
10194 -> 10193;
10195 -> 0;
10195 -> 10193;
10196 -> 10193;
10197 -> 10195;
10197 -> 10196;
10198 -> 10194;
10198 -> 10196;
10199 -> 10196;
10200 -> 10197;
10200 -> 10199;
10200 -> 10196;
10201 -> 10197;
10201 -> 10198;
10201 -> 10028;
10201 -> 10196;
10202 -> 10201;
10202 -> 9734;
10203 -> 10192;
10203 -> 10202;
10203 -> 9734;
10204 -> 10153;
10204 -> 10203;
10204 -> 9734;
10205 -> 10028;
10205 -> 9734;
10206 -> 10028;
10206 -> 9734;
10207 -> 10028;
10207 -> 9734;
10208 -> 10028;
10208 -> 9734;
10209 -> 10028;
10209 -> 9734;
10210 -> 10209;
10210 -> 9734;
10211 -> 10208;
10211 -> 9734;
10212 -> 10028;
10212 -> 9734;
10213 -> 10028;
10213 -> 9734;
10214 -> 9734;
10215 -> 10028;
10215 -> 10214;
10215 -> 9734;
10216 -> 9736;
10216 -> 9734;
10217 -> 7360;
10217 -> 10215;
10217 -> 7359;
10217 -> 7367;
10218 -> 10216;
10218 -> 7367;
10219 -> 4436;
10219 -> 7367;
10220 -> 10217;
10220 -> 10218;
10220 -> 10219;
10220 -> 10215;
10220 -> 7367;
10221 -> 7360;
10221 -> 10220;
10221 -> 7359;
10221 -> 7358;
10222 -> 7352;
10223 -> 10221;
10223 -> 10222;
10223 -> 7352;
10224 -> 10223;
10225 -> 10221;
10225 -> 10224;
10226 -> 10224;
10227 -> 10225;
10227 -> 10226;
10228 -> 10226;
10229 -> 10227;
10229 -> 10220;
10229 -> 10228;
10230 -> 10229;
10230 -> 10220;
10230 -> 8407;
10230 -> 10228;
10231 -> 10228;
10232 -> 10230;
10232 -> 10231;
10232 -> 10228;
10233 -> 10232;
10233 -> 10226;
10234 -> 10233;
10235 -> 10234;
10235 -> 10233;
10236 -> 10233;
10237 -> 10235;
10237 -> 10236;
10238 -> 10227;
10238 -> 10236;
10239 -> 10236;
10240 -> 10238;
10240 -> 10239;
10241 -> 10240;
10241 -> 10239;
10242 -> 10239;
10243 -> 10241;
10243 -> 10242;
10244 -> 10243;
10244 -> 10242;
10245 -> 10244;
10245 -> 10239;
10246 -> 10245;
10246 -> 10236;
10247 -> 10237;
10247 -> 10236;
10248 -> 10236;
10249 -> 10238;
10249 -> 10248;
10250 -> 10249;
10250 -> 10236;
10251 -> 10236;
10252 -> 10238;
10252 -> 10251;
10253 -> 10251;
10254 -> 10252;
10254 -> 10220;
10254 -> 10253;
10255 -> 10254;
10255 -> 10220;
10255 -> 8447;
10255 -> 10253;
10256 -> 10253;
10257 -> 10255;
10257 -> 10256;
10257 -> 10253;
10258 -> 10257;
10258 -> 10251;
10259 -> 10258;
10260 -> 10259;
10261 -> 10259;
10261 -> 10258;
10262 -> 10258;
10263 -> 10262;
10264 -> 10262;
10264 -> 10220;
10264 -> 10263;
10265 -> 10264;
10265 -> 10220;
10265 -> 8369;
10265 -> 10263;
10266 -> 10265;
10266 -> 10262;
10267 -> 10266;
10267 -> 10258;
10268 -> 10261;
10268 -> 10267;
10268 -> 10258;
10269 -> 10268;
10269 -> 10258;
10270 -> 10258;
10271 -> 10269;
10271 -> 10270;
10272 -> 10252;
10272 -> 10220;
10272 -> 10270;
10273 -> 10271;
10273 -> 10270;
10274 -> 10273;
10275 -> 10272;
10275 -> 10220;
10275 -> 10270;
10276 -> 10274;
10276 -> 10270;
10277 -> 10270;
10278 -> 10275;
10278 -> 10277;
10279 -> 10276;
10279 -> 10277;
10280 -> 10278;
10280 -> 10279;
10280 -> 10277;
10281 -> 10277;
10282 -> 10272;
10282 -> 10220;
10282 -> 10270;
10283 -> 10274;
10283 -> 10270;
10284 -> 10282;
10284 -> 10283;
10284 -> 10270;
10285 -> 10258;
10286 -> 10251;
10287 -> 10252;
10287 -> 10220;
10287 -> 10286;
10288 -> 10287;
10288 -> 10220;
10288 -> 10284;
10288 -> 8443;
10288 -> 10286;
10289 -> 10286;
10290 -> 10288;
10290 -> 10289;
10290 -> 10286;
10291 -> 10290;
10291 -> 10251;
10292 -> 10291;
10292 -> 10236;
10293 -> 10236;
10294 -> 10247;
10294 -> 10293;
10295 -> 10250;
10295 -> 10293;
10296 -> 10292;
10296 -> 10293;
10297 -> 10238;
10297 -> 10293;
10298 -> 10294;
10298 -> 10293;
10299 -> 10293;
10300 -> 10295;
10300 -> 10299;
10301 -> 10300;
10301 -> 10220;
10301 -> 10299;
10302 -> 10300;
10302 -> 10293;
10303 -> 10293;
10304 -> 10298;
10304 -> 10303;
10305 -> 10302;
10305 -> 10303;
10306 -> 10297;
10306 -> 10303;
10307 -> 10303;
10308 -> 10305;
10308 -> 10307;
10309 -> 10308;
10309 -> 10220;
10309 -> 10307;
10310 -> 0;
10310 -> 10307;
10311 -> 10309;
10312 -> 10308;
10312 -> 10311;
10313 -> 10311;
10314 -> 10313;
10314 -> 10311;
10315 -> 10311;
10316 -> 10312;
10316 -> 10315;
10317 -> 10315;
10318 -> 10317;
10318 -> 10315;
10319 -> 10315;
10320 -> 10316;
10320 -> 10319;
10321 -> 10319;
10322 -> 10320;
10322 -> 10321;
10323 -> 10322;
10323 -> 10220;
10323 -> 10321;
10324 -> 4436;
10324 -> 10321;
10325 -> 10322;
10325 -> 10220;
10325 -> 10323;
10326 -> 10323;
10327 -> 10322;
10327 -> 10326;
10328 -> 10326;
10329 -> 10326;
10330 -> 10328;
10330 -> 10329;
10331 -> 10327;
10331 -> 10329;
10332 -> 10329;
10333 -> 10329;
10334 -> 10332;
10334 -> 10333;
10335 -> 10331;
10335 -> 10333;
10336 -> 10335;
10337 -> 10335;
10337 -> 10336;
10338 -> 10336;
10338 -> 10335;
10339 -> 10335;
10339 -> 10220;
10339 -> 10284;
10340 -> 10339;
10341 -> 10339;
10341 -> 10335;
10342 -> 10341;
10342 -> 10335;
10343 -> 10334;
10343 -> 10342;
10344 -> 10342;
10345 -> 10344;
10346 -> 10344;
10346 -> 10345;
10347 -> 10345;
10347 -> 10344;
10348 -> 10344;
10348 -> 10342;
10349 -> 10341;
10349 -> 10342;
10350 -> 10342;
10351 -> 10335;
10351 -> 10339;
10351 -> 10342;
10352 -> 10348;
10352 -> 10342;
10353 -> 10342;
10354 -> 10349;
10354 -> 10353;
10355 -> 10350;
10355 -> 10353;
10356 -> 10351;
10356 -> 10353;
10357 -> 10352;
10357 -> 10353;
10358 -> 10350;
10358 -> 10353;
10359 -> 10353;
10360 -> 10354;
10360 -> 10359;
10360 -> 10353;
10361 -> 10354;
10361 -> 10342;
10362 -> 10335;
10362 -> 10357;
10362 -> 10342;
10363 -> 10348;
10363 -> 10342;
10364 -> 10342;
10365 -> 10361;
10365 -> 10364;
10366 -> 10362;
10366 -> 10364;
10367 -> 10363;
10367 -> 10364;
10368 -> 10367;
10368 -> 10357;
10368 -> 10364;
10369 -> 10368;
10369 -> 10342;
10370 -> 10335;
10370 -> 10368;
10370 -> 10342;
10371 -> 10348;
10371 -> 10342;
10372 -> 10342;
10373 -> 10369;
10373 -> 10372;
10374 -> 10370;
10374 -> 10372;
10375 -> 10371;
10375 -> 10372;
10376 -> 10372;
10377 -> 10376;
10377 -> 10372;
10378 -> 10372;
10379 -> 10375;
10379 -> 10378;
10380 -> 10379;
10380 -> 10368;
10380 -> 10378;
10381 -> 10380;
10381 -> 10372;
10382 -> 10374;
10382 -> 10372;
10383 -> 10376;
10383 -> 10372;
10384 -> 10381;
10384 -> 10382;
10384 -> 10383;
10384 -> 10368;
10384 -> 10377;
10384 -> 10372;
10385 -> 10384;
10385 -> 10372;
10386 -> 10373;
10386 -> 10372;
10387 -> 10384;
10387 -> 10372;
10388 -> 10372;
10389 -> 10386;
10389 -> 10388;
10390 -> 10387;
10390 -> 10388;
10391 -> 10387;
10391 -> 10388;
10392 -> 10389;
10392 -> 10384;
10392 -> 10388;
10393 -> 10390;
10393 -> 10388;
10394 -> 10393;
10394 -> 10388;
10395 -> 10393;
10395 -> 10384;
10395 -> 10388;
10396 -> 10395;
10397 -> 10396;
10397 -> 10388;
10398 -> 10388;
10399 -> 10398;
10399 -> 10388;
10400 -> 10388;
10401 -> 10389;
10401 -> 10388;
10402 -> 10400;
10402 -> 10388;
10403 -> 10388;
10404 -> 10389;
10404 -> 10403;
10405 -> 0;
10405 -> 10403;
10406 -> 10405;
10406 -> 10388;
10407 -> 10406;
10407 -> 10388;
10408 -> 10388;
10409 -> 10407;
10409 -> 10408;
10410 -> 10402;
10410 -> 10408;
10411 -> 10409;
10411 -> 0;
10411 -> 10408;
10412 -> 10409;
10412 -> 10411;
10413 -> 10388;
10414 -> 10389;
10414 -> 10413;
10415 -> 10414;
10415 -> 10392;
10415 -> 10413;
10416 -> 10415;
10416 -> 10388;
10417 -> 10388;
10418 -> 10416;
10418 -> 10388;
10419 -> 10416;
10419 -> 10418;
10420 -> 10419;
10420 -> 10388;
10421 -> 10416;
10421 -> 10388;
10422 -> 10406;
10422 -> 10412;
10422 -> 10388;
10423 -> 10422;
10423 -> 10420;
10423 -> 10388;
10424 -> 10388;
10425 -> 10389;
10425 -> 10424;
10426 -> 10424;
10427 -> 10426;
10427 -> 10424;
10428 -> 10424;
10429 -> 10427;
10429 -> 10428;
10430 -> 10425;
10430 -> 10428;
10431 -> 10428;
10432 -> 10430;
10432 -> 10431;
10433 -> 10431;
10434 -> 10433;
10434 -> 10428;
10435 -> 10428;
10436 -> 10430;
10436 -> 10435;
10437 -> 10436;
10437 -> 10392;
10437 -> 10435;
10438 -> 10437;
10438 -> 10428;
10439 -> 10428;
10440 -> 10438;
10440 -> 10439;
10441 -> 10439;
10441 -> 10428;
10442 -> 10434;
10442 -> 10441;
10442 -> 10428;
10443 -> 10428;
10444 -> 10430;
10444 -> 10443;
10445 -> 10444;
10445 -> 10443;
10446 -> 10445;
10446 -> 10392;
10446 -> 10443;
10447 -> 10446;
10447 -> 10428;
10448 -> 10428;
10449 -> 10447;
10449 -> 10448;
10450 -> 10428;
10451 -> 10449;
10451 -> 10450;
10452 -> 10450;
10452 -> 10428;
10453 -> 10428;
10454 -> 10442;
10454 -> 10452;
10454 -> 10428;
10455 -> 10428;
10456 -> 10430;
10456 -> 10455;
10457 -> 10456;
10457 -> 10392;
10457 -> 10455;
10458 -> 10457;
10458 -> 10428;
10459 -> 10458;
10459 -> 4027;
10459 -> 10428;
10460 -> 10454;
10460 -> 10459;
10460 -> 10428;
10461 -> 10428;
10462 -> 10428;
10463 -> 10462;
10463 -> 10388;
10464 -> 10389;
10464 -> 10391;
10465 -> 10464;
10465 -> 10342;
10466 -> 10342;
10467 -> 10342;
10468 -> 10465;
10468 -> 10467;
10469 -> 10466;
10469 -> 10467;
10470 -> 10466;
10470 -> 10467;
10471 -> 10468;
10471 -> 10467;
10472 -> 10469;
10472 -> 0;
10472 -> 10467;
10473 -> 10469;
10473 -> 10467;
10474 -> 10468;
10474 -> 10473;
10475 -> 10473;
10476 -> 10474;
10476 -> 10475;
10477 -> 10475;
10478 -> 10476;
10478 -> 10477;
10479 -> 10478;
10479 -> 10475;
10480 -> 10475;
10481 -> 10479;
10481 -> 10480;
10482 -> 10468;
10482 -> 10467;
10483 -> 10482;
10483 -> 10467;
10484 -> 10468;
10484 -> 10483;
10485 -> 10483;
10486 -> 10484;
10486 -> 10485;
10487 -> 10485;
10488 -> 10486;
10488 -> 10487;
10489 -> 10488;
10489 -> 10485;
10490 -> 10485;
10491 -> 10489;
10491 -> 10490;
10492 -> 10469;
10492 -> 0;
10492 -> 10467;
10493 -> 10467;
10494 -> 10491;
10494 -> 10493;
10494 -> 10467;
10495 -> 10467;
10496 -> 10470;
10496 -> 10495;
10496 -> 10467;
10497 -> 10467;
10497 -> 10342;
10498 -> 10335;
10498 -> 10392;
10498 -> 10342;
10499 -> 10348;
10499 -> 10342;
10500 -> 10335;
10500 -> 10342;
10501 -> 10342;
10502 -> 10497;
10502 -> 10501;
10503 -> 10498;
10503 -> 10501;
10504 -> 10499;
10504 -> 10501;
10505 -> 10500;
10505 -> 10501;
10506 -> 10500;
10506 -> 10501;
10507 -> 10501;
10508 -> 10502;
10508 -> 10507;
10509 -> 10508;
10509 -> 10468;
10509 -> 10507;
10510 -> 10509;
10510 -> 10507;
10511 -> 10510;
10511 -> 10501;
10512 -> 10501;
10513 -> 10505;
10513 -> 10512;
10514 -> 10513;
10514 -> 10501;
10515 -> 10501;
10516 -> 10505;
10516 -> 10515;
10517 -> 10515;
10518 -> 10516;
10518 -> 10517;
10519 -> 10518;
10519 -> 10392;
10519 -> 10517;
10520 -> 10517;
10521 -> 10519;
10521 -> 10520;
10522 -> 10520;
10522 -> 10517;
10523 -> 10519;
10523 -> 10515;
10524 -> 10523;
10524 -> 10501;
10525 -> 10501;
10526 -> 10505;
10526 -> 10501;
10527 -> 10501;
10528 -> 10526;
10528 -> 10527;
10529 -> 10525;
10529 -> 10527;
10530 -> 10528;
10530 -> 10527;
10531 -> 10527;
10532 -> 10528;
10532 -> 10531;
10533 -> 10531;
10533 -> 10527;
10534 -> 10527;
10535 -> 10527;
10536 -> 10528;
10536 -> 10535;
10537 -> 0;
10537 -> 10535;
10538 -> 10536;
10538 -> 10392;
10538 -> 0;
10538 -> 10535;
10539 -> 10538;
10539 -> 10527;
10540 -> 10527;
10541 -> 10528;
10541 -> 10540;
10542 -> 10541;
10542 -> 10392;
10542 -> 10540;
10543 -> 10542;
10543 -> 10527;
10544 -> 10543;
10544 -> 10527;
10545 -> 10527;
10546 -> 10545;
10546 -> 10501;
10547 -> 10504;
10547 -> 10392;
10547 -> 10501;
10548 -> 10547;
10549 -> 10548;
10549 -> 10547;
10550 -> 10547;
10551 -> 10548;
10552 -> 10548;
10552 -> 10551;
10553 -> 10551;
10553 -> 10548;
10554 -> 10547;
10554 -> 10548;
10555 -> 10554;
10555 -> 10548;
10556 -> 10554;
10556 -> 10548;
10557 -> 10556;
10557 -> 10548;
10558 -> 10557;
10558 -> 10548;
10559 -> 10557;
10559 -> 10548;
10560 -> 10559;
10560 -> 10548;
10561 -> 10560;
10561 -> 10548;
10562 -> 10560;
10562 -> 10548;
10563 -> 10502;
10563 -> 10548;
10564 -> 10342;
10565 -> 10563;
10565 -> 10564;
10566 -> 10565;
10566 -> 10470;
10566 -> 10564;
10567 -> 10335;
10567 -> 10548;
10568 -> 10565;
10568 -> 10335;
10569 -> 4436;
10569 -> 10335;
10570 -> 10335;
10570 -> 10568;
10570 -> 10333;
10571 -> 10570;
10571 -> 10329;
10572 -> 10571;
10572 -> 10326;
10573 -> 10326;
10574 -> 10572;
10574 -> 10573;
10574 -> 10326;
10575 -> 10572;
10575 -> 10326;
10576 -> 10327;
10576 -> 10326;
10577 -> 10326;
10578 -> 10575;
10578 -> 10577;
10579 -> 10576;
10579 -> 10577;
10580 -> 10577;
10581 -> 10578;
10581 -> 10580;
10581 -> 10577;
10582 -> 10577;
10583 -> 10579;
10583 -> 10582;
10583 -> 10577;
10584 -> 10577;
10585 -> 10579;
10585 -> 10584;
10586 -> 10585;
10586 -> 10577;
10587 -> 10577;
10588 -> 10578;
10588 -> 10577;
10589 -> 10577;
10590 -> 10578;
10590 -> 10589;
10591 -> 10589;
10592 -> 10591;
10592 -> 10577;
10593 -> 10587;
10593 -> 10577;
10594 -> 10577;
10595 -> 10588;
10595 -> 10594;
10596 -> 10592;
10596 -> 10594;
10597 -> 10593;
10597 -> 10594;
10598 -> 10594;
10599 -> 10595;
10599 -> 10598;
10599 -> 10594;
10600 -> 10594;
10601 -> 10595;
10601 -> 10600;
10602 -> 10601;
10602 -> 10594;
10603 -> 10602;
10603 -> 10594;
10604 -> 10603;
10604 -> 10597;
10604 -> 10568;
10604 -> 10587;
10604 -> 10594;
10605 -> 10594;
10606 -> 10604;
10606 -> 10605;
10607 -> 10605;
10608 -> 10606;
10608 -> 10607;
10609 -> 10608;
10609 -> 10605;
10610 -> 10605;
10611 -> 10606;
10611 -> 10610;
10612 -> 10611;
10612 -> 10605;
10613 -> 10612;
10614 -> 10602;
10614 -> 10613;
10615 -> 10614;
10615 -> 10612;
10615 -> 10613;
10616 -> 10615;
10616 -> 10612;
10617 -> 10616;
10618 -> 10616;
10619 -> 10617;
10619 -> 10618;
10620 -> 10618;
10621 -> 10618;
10622 -> 10618;
10622 -> 10621;
10623 -> 10621;
10623 -> 10618;
10624 -> 10618;
10625 -> 10620;
10625 -> 10618;
10626 -> 10618;
10627 -> 10618;
10628 -> 10618;
10629 -> 10618;
10630 -> 10618;
10631 -> 10630;
10631 -> 10618;
10632 -> 10631;
10632 -> 10630;
10632 -> 10618;
10633 -> 10631;
10633 -> 10618;
10634 -> 10633;
10635 -> 10634;
10635 -> 10630;
10635 -> 10618;
10636 -> 10618;
10637 -> 10636;
10637 -> 10630;
10637 -> 10618;
10638 -> 10630;
10638 -> 10618;
10639 -> 10618;
10640 -> 10638;
10640 -> 10618;
10641 -> 10618;
10642 -> 10618;
10642 -> 10641;
10643 -> 0;
10643 -> 10641;
10644 -> 10643;
10644 -> 10618;
10645 -> 10644;
10645 -> 10618;
10646 -> 10618;
10647 -> 10645;
10647 -> 10646;
10648 -> 10640;
10648 -> 10646;
10649 -> 10647;
10649 -> 0;
10649 -> 10646;
10650 -> 10647;
10650 -> 10649;
10651 -> 10618;
10652 -> 10618;
10652 -> 10651;
10653 -> 10652;
10653 -> 10618;
10653 -> 10651;
10654 -> 10653;
10654 -> 10618;
10655 -> 10618;
10656 -> 10654;
10656 -> 10618;
10657 -> 10654;
10657 -> 10656;
10658 -> 10657;
10658 -> 10618;
10659 -> 10654;
10659 -> 10618;
10660 -> 10644;
10660 -> 10650;
10660 -> 10618;
10661 -> 10660;
10661 -> 10658;
10661 -> 10618;
10662 -> 10618;
10663 -> 10618;
10663 -> 10662;
10664 -> 10662;
10665 -> 10664;
10665 -> 10662;
10666 -> 10662;
10667 -> 10665;
10667 -> 10666;
10668 -> 10663;
10668 -> 10666;
10669 -> 10666;
10670 -> 10668;
10670 -> 10669;
10671 -> 10669;
10672 -> 10671;
10672 -> 10666;
10673 -> 10666;
10674 -> 10668;
10674 -> 10673;
10675 -> 10674;
10675 -> 10618;
10675 -> 10673;
10676 -> 10675;
10676 -> 10666;
10677 -> 10666;
10678 -> 10676;
10678 -> 10677;
10679 -> 10677;
10679 -> 10666;
10680 -> 10672;
10680 -> 10679;
10680 -> 10666;
10681 -> 10666;
10682 -> 10668;
10682 -> 10681;
10683 -> 10682;
10683 -> 10681;
10684 -> 10683;
10684 -> 10618;
10684 -> 10681;
10685 -> 10684;
10685 -> 10666;
10686 -> 10666;
10687 -> 10685;
10687 -> 10686;
10688 -> 10666;
10689 -> 10687;
10689 -> 10688;
10690 -> 10688;
10690 -> 10666;
10691 -> 10666;
10692 -> 10680;
10692 -> 10690;
10692 -> 10666;
10693 -> 10666;
10694 -> 10668;
10694 -> 10693;
10695 -> 10694;
10695 -> 10666;
10696 -> 10695;
10696 -> 4027;
10696 -> 10666;
10697 -> 10692;
10697 -> 10696;
10697 -> 10666;
10698 -> 10666;
10699 -> 10666;
10700 -> 10699;
10700 -> 10618;
10701 -> 10630;
10701 -> 10618;
10702 -> 10630;
10702 -> 0;
10702 -> 10618;
10703 -> 10630;
10703 -> 10618;
10704 -> 10630;
10704 -> 10703;
10705 -> 10703;
10706 -> 10704;
10706 -> 10705;
10707 -> 10705;
10708 -> 10706;
10708 -> 10707;
10709 -> 10708;
10709 -> 10705;
10710 -> 10705;
10711 -> 10709;
10711 -> 10710;
10712 -> 10630;
10712 -> 10618;
10713 -> 10712;
10713 -> 10618;
10714 -> 10630;
10714 -> 10713;
10715 -> 10713;
10716 -> 10714;
10716 -> 10715;
10717 -> 10715;
10718 -> 10716;
10718 -> 10717;
10719 -> 10718;
10719 -> 10715;
10720 -> 10715;
10721 -> 10719;
10721 -> 10720;
10722 -> 10630;
10722 -> 0;
10722 -> 10618;
10723 -> 10618;
10724 -> 10721;
10724 -> 10723;
10724 -> 10618;
10725 -> 10618;
10726 -> 10630;
10726 -> 10725;
10726 -> 10618;
10727 -> 10630;
10727 -> 10618;
10728 -> 10618;
10729 -> 10630;
10729 -> 10728;
10730 -> 10729;
10730 -> 10630;
10730 -> 10728;
10731 -> 10730;
10731 -> 10728;
10732 -> 10731;
10732 -> 10618;
10733 -> 10618;
10734 -> 10727;
10734 -> 10733;
10735 -> 10734;
10735 -> 10618;
10736 -> 10618;
10737 -> 10727;
10737 -> 10736;
10738 -> 10736;
10739 -> 10737;
10739 -> 10738;
10740 -> 10738;
10741 -> 10739;
10741 -> 10740;
10742 -> 10740;
10742 -> 10738;
10743 -> 10739;
10743 -> 10736;
10744 -> 10743;
10744 -> 10618;
10745 -> 10618;
10746 -> 10727;
10746 -> 10618;
10747 -> 10618;
10748 -> 10746;
10748 -> 10747;
10749 -> 10745;
10749 -> 10747;
10750 -> 10748;
10750 -> 10747;
10751 -> 10747;
10752 -> 10748;
10752 -> 10751;
10753 -> 10751;
10753 -> 10747;
10754 -> 10747;
10755 -> 10747;
10756 -> 10748;
10756 -> 10755;
10757 -> 0;
10757 -> 10755;
10758 -> 10756;
10758 -> 10747;
10759 -> 10747;
10760 -> 10748;
10760 -> 10759;
10761 -> 10760;
10761 -> 10618;
10761 -> 10759;
10762 -> 10761;
10762 -> 10747;
10763 -> 10762;
10763 -> 10747;
10764 -> 10747;
10765 -> 10764;
10765 -> 10618;
10766 -> 10630;
10767 -> 10630;
10768 -> 10630;
10769 -> 10630;
10769 -> 10768;
10770 -> 10768;
10770 -> 10630;
10771 -> 10630;
10772 -> 10771;
10772 -> 10630;
10773 -> 10771;
10773 -> 10630;
10774 -> 10773;
10774 -> 10630;
10775 -> 10774;
10775 -> 10630;
10776 -> 10774;
10776 -> 10630;
10777 -> 10776;
10777 -> 10630;
10778 -> 10777;
10778 -> 10630;
10779 -> 10777;
10779 -> 10630;
10780 -> 10771;
10780 -> 10630;
10780 -> 10618;
10781 -> 10771;
10781 -> 10616;
10782 -> 10596;
10782 -> 10616;
10783 -> 10597;
10783 -> 10616;
10784 -> 10616;
10785 -> 10781;
10785 -> 10784;
10786 -> 10782;
10786 -> 10784;
10787 -> 10783;
10787 -> 10784;
10788 -> 10784;
10789 -> 10785;
10789 -> 10788;
10789 -> 10784;
10790 -> 10784;
10791 -> 10785;
10791 -> 10790;
10792 -> 10791;
10792 -> 10784;
10793 -> 0;
10793 -> 10792;
10794 -> 10793;
10795 -> 10793;
10796 -> 10793;
10797 -> 10793;
10797 -> 10796;
10798 -> 10796;
10798 -> 10793;
10799 -> 10793;
10800 -> 10786;
10800 -> 10793;
10801 -> 10793;
10802 -> 10799;
10802 -> 10801;
10802 -> 10793;
10803 -> 10802;
10804 -> 10793;
10805 -> 10786;
10805 -> 10804;
10805 -> 10793;
10806 -> 10612;
10807 -> 10596;
10807 -> 10806;
10807 -> 10612;
10808 -> 10577;
10809 -> 10579;
10809 -> 10577;
10810 -> 10809;
10810 -> 10587;
10810 -> 10799;
10810 -> 10577;
10811 -> 10577;
10812 -> 10811;
10813 -> 10811;
10814 -> 10587;
10814 -> 10810;
10814 -> 10577;
10815 -> 10810;
10815 -> 10577;
10816 -> 10326;
10817 -> 10327;
10817 -> 10816;
10818 -> 10816;
10819 -> 10818;
10819 -> 10817;
10819 -> 10816;
10820 -> 10326;
10821 -> 10572;
10821 -> 10326;
10822 -> 10821;
10822 -> 10323;
10823 -> 4436;
10823 -> 10323;
10824 -> 10325;
10824 -> 10822;
10824 -> 10823;
10824 -> 10814;
10824 -> 10819;
10824 -> 10323;
10825 -> 10322;
10825 -> 10824;
10825 -> 10321;
10826 -> 10825;
10826 -> 10319;
10827 -> 10319;
10828 -> 10826;
10828 -> 10827;
10828 -> 10319;
10829 -> 10826;
10829 -> 10828;
10830 -> 10828;
10831 -> 10829;
10831 -> 10830;
10832 -> 10830;
10833 -> 10831;
10833 -> 10832;
10833 -> 10830;
10834 -> 10831;
10834 -> 10830;
10835 -> 10830;
10835 -> 10828;
10836 -> 10828;
10837 -> 10836;
10838 -> 10836;
10839 -> 10836;
10840 -> 10836;
10841 -> 10836;
10842 -> 10836;
10843 -> 10842;
10843 -> 10836;
10844 -> 10836;
10845 -> 10836;
10845 -> 10844;
10846 -> 10844;
10847 -> 10846;
10847 -> 10836;
10848 -> 10836;
10849 -> 10842;
10850 -> 10842;
10851 -> 10847;
10851 -> 10842;
10852 -> 10842;
10853 -> 10852;
10854 -> 10842;
10855 -> 10847;
10855 -> 10854;
10855 -> 10842;
10856 -> 10842;
10856 -> 10836;
10857 -> 10836;
10858 -> 10842;
10858 -> 10828;
10859 -> 10858;
10860 -> 10858;
10861 -> 10859;
10861 -> 10860;
10862 -> 10860;
10863 -> 10861;
10863 -> 10862;
10863 -> 10860;
10864 -> 10861;
10864 -> 10860;
10865 -> 10860;
10865 -> 10858;
10866 -> 10858;
10867 -> 10858;
10868 -> 10858;
10869 -> 10868;
10870 -> 10319;
10871 -> 10870;
10871 -> 10315;
10872 -> 10315;
10873 -> 10318;
10873 -> 10872;
10874 -> 10871;
10874 -> 10872;
10875 -> 10316;
10875 -> 10872;
10876 -> 10872;
10877 -> 10874;
10877 -> 10876;
10877 -> 10872;
10878 -> 10877;
10879 -> 10315;
10880 -> 10316;
10880 -> 10879;
10881 -> 10879;
10882 -> 10880;
10882 -> 10881;
10883 -> 10882;
10883 -> 10869;
10883 -> 10881;
10884 -> 10881;
10885 -> 10883;
10885 -> 10884;
10886 -> 10884;
10886 -> 10881;
10887 -> 10883;
10887 -> 10879;
10888 -> 10887;
10888 -> 10315;
10889 -> 10315;
10890 -> 10888;
10890 -> 10889;
10891 -> 10889;
10892 -> 10890;
10892 -> 10891;
10893 -> 10891;
10894 -> 10892;
10894 -> 10893;
10895 -> 10893;
10896 -> 10894;
10896 -> 10869;
10896 -> 10895;
10896 -> 10893;
10897 -> 10891;
10898 -> 10892;
10898 -> 10889;
10899 -> 10889;
10900 -> 10873;
10900 -> 10315;
10901 -> 10900;
10901 -> 10311;
10902 -> 10311;
10903 -> 10314;
10903 -> 10902;
10904 -> 10901;
10904 -> 10902;
10905 -> 10312;
10905 -> 10902;
10906 -> 10902;
10907 -> 10904;
10907 -> 10906;
10907 -> 10902;
10908 -> 10907;
10909 -> 10908;
10910 -> 10312;
10910 -> 10909;
10911 -> 10910;
10911 -> 10869;
10911 -> 10909;
10912 -> 10909;
10913 -> 10911;
10913 -> 10912;
10914 -> 10912;
10914 -> 10909;
10915 -> 10911;
10915 -> 10908;
10916 -> 10908;
10917 -> 10915;
10917 -> 10916;
10918 -> 10312;
10918 -> 10869;
10918 -> 10908;
10919 -> 10917;
10920 -> 10919;
10921 -> 10920;
10921 -> 10919;
10922 -> 10919;
10923 -> 10920;
10923 -> 10922;
10923 -> 10919;
10924 -> 10923;
10925 -> 10924;
10925 -> 10923;
10926 -> 10925;
10926 -> 10923;
10927 -> 10926;
10928 -> 10927;
10928 -> 10926;
10929 -> 0;
10929 -> 10928;
10930 -> 10929;
10930 -> 10917;
10931 -> 10903;
10931 -> 10311;
10932 -> 10931;
10932 -> 10309;
10933 -> 10932;
10933 -> 10308;
10933 -> 10309;
10934 -> 10308;
10934 -> 10917;
10934 -> 10933;
10934 -> 10307;
10935 -> 10934;
10935 -> 10303;
10936 -> 10303;
10937 -> 10935;
10937 -> 10936;
10937 -> 10303;
10938 -> 10304;
10938 -> 10303;
10939 -> 10935;
10939 -> 10303;
10940 -> 10303;
10941 -> 10938;
10941 -> 10940;
10942 -> 10939;
10942 -> 10940;
10943 -> 10306;
10943 -> 10940;
10944 -> 10940;
10945 -> 10293;
10946 -> 10295;
10946 -> 10945;
10947 -> 10946;
10947 -> 10917;
10947 -> 10945;
10948 -> 10296;
10948 -> 10293;
10949 -> 10293;
10950 -> 10941;
10950 -> 10949;
10951 -> 10947;
10951 -> 10949;
10952 -> 10948;
10952 -> 10949;
10953 -> 10297;
10953 -> 10949;
10954 -> 10292;
10954 -> 10949;
10955 -> 10949;
10956 -> 10951;
10956 -> 10949;
10957 -> 10956;
10957 -> 10917;
10957 -> 10929;
10957 -> 10933;
10957 -> 10949;
10958 -> 10949;
10959 -> 10958;
10959 -> 10293;
10960 -> 10942;
10960 -> 10959;
10960 -> 10293;
10961 -> 10236;
10962 -> 10238;
10962 -> 10961;
10963 -> 10961;
10964 -> 10962;
10964 -> 10963;
10965 -> 10964;
10965 -> 10917;
10965 -> 10963;
10966 -> 10961;
10967 -> 10965;
10967 -> 10917;
10967 -> 10966;
10968 -> 0;
10968 -> 10966;
10969 -> 10968;
10969 -> 10236;
10970 -> 0;
10970 -> 10236;
10971 -> 10236;
10972 -> 10950;
10972 -> 10971;
10973 -> 10969;
10973 -> 10971;
10974 -> 10970;
10974 -> 10971;
10975 -> 10238;
10975 -> 10971;
10976 -> 10292;
10976 -> 10971;
10977 -> 10971;
10978 -> 10973;
10978 -> 10971;
10979 -> 10971;
10980 -> 10979;
10980 -> 10236;
10981 -> 10960;
10981 -> 10980;
10981 -> 10236;
10982 -> 10236;
10983 -> 10238;
10983 -> 10982;
10984 -> 10983;
10984 -> 10917;
10984 -> 10982;
10985 -> 10236;
10986 -> 10972;
10986 -> 10985;
10987 -> 10984;
10987 -> 10985;
10988 -> 10238;
10988 -> 10985;
10989 -> 10987;
10989 -> 10985;
10990 -> 10989;
10990 -> 10917;
10990 -> 10929;
10990 -> 10933;
10990 -> 10985;
10991 -> 10986;
10991 -> 10990;
10992 -> 10990;
10993 -> 10990;
10994 -> 10991;
10994 -> 10993;
10995 -> 10992;
10995 -> 10993;
10996 -> 10988;
10996 -> 10993;
10997 -> 10994;
10997 -> 10993;
10998 -> 10993;
10999 -> 10995;
10999 -> 10998;
11000 -> 10999;
11000 -> 10993;
11001 -> 10292;
11001 -> 10993;
11002 -> 10993;
11003 -> 10997;
11003 -> 11002;
11004 -> 11000;
11004 -> 11002;
11005 -> 11001;
11005 -> 11002;
11006 -> 10996;
11006 -> 11002;
11007 -> 11004;
11007 -> 10917;
11007 -> 11002;
11008 -> 11006;
11008 -> 11002;
11009 -> 11004;
11010 -> 11004;
11011 -> 11004;
11012 -> 11004;
11012 -> 11011;
11013 -> 11011;
11013 -> 11004;
11014 -> 11004;
11015 -> 11010;
11015 -> 11004;
11016 -> 11004;
11017 -> 11004;
11018 -> 11004;
11019 -> 11004;
11020 -> 11004;
11021 -> 11020;
11021 -> 11004;
11022 -> 11020;
11022 -> 11004;
11023 -> 11022;
11024 -> 11023;
11024 -> 11004;
11025 -> 11004;
11026 -> 11025;
11026 -> 11004;
11027 -> 11004;
11028 -> 11004;
11029 -> 11027;
11029 -> 11004;
11030 -> 11004;
11031 -> 11004;
11031 -> 11030;
11032 -> 0;
11032 -> 11030;
11033 -> 11032;
11033 -> 11004;
11034 -> 11033;
11034 -> 11004;
11035 -> 11004;
11036 -> 11034;
11036 -> 11035;
11037 -> 11029;
11037 -> 11035;
11038 -> 11036;
11038 -> 0;
11038 -> 11035;
11039 -> 11036;
11039 -> 11038;
11040 -> 11004;
11041 -> 11004;
11041 -> 11040;
11042 -> 11041;
11042 -> 11004;
11042 -> 11040;
11043 -> 11042;
11043 -> 11004;
11044 -> 11004;
11045 -> 11043;
11045 -> 11004;
11046 -> 11043;
11046 -> 11045;
11047 -> 11046;
11047 -> 11004;
11048 -> 11043;
11048 -> 11004;
11049 -> 11033;
11049 -> 11039;
11049 -> 11004;
11050 -> 11049;
11050 -> 11047;
11050 -> 11004;
11051 -> 11004;
11052 -> 11004;
11052 -> 11051;
11053 -> 11051;
11054 -> 11053;
11054 -> 11051;
11055 -> 11051;
11056 -> 11054;
11056 -> 11055;
11057 -> 11052;
11057 -> 11055;
11058 -> 11055;
11059 -> 11057;
11059 -> 11058;
11060 -> 11058;
11061 -> 11060;
11061 -> 11055;
11062 -> 11055;
11063 -> 11057;
11063 -> 11062;
11064 -> 11063;
11064 -> 11004;
11064 -> 11062;
11065 -> 11064;
11065 -> 11055;
11066 -> 11055;
11067 -> 11065;
11067 -> 11066;
11068 -> 11066;
11068 -> 11055;
11069 -> 11061;
11069 -> 11068;
11069 -> 11055;
11070 -> 11055;
11071 -> 11057;
11071 -> 11070;
11072 -> 11071;
11072 -> 11070;
11073 -> 11072;
11073 -> 11004;
11073 -> 11070;
11074 -> 11073;
11074 -> 11055;
11075 -> 11055;
11076 -> 11074;
11076 -> 11075;
11077 -> 11055;
11078 -> 11076;
11078 -> 11077;
11079 -> 11077;
11079 -> 11055;
11080 -> 11055;
11081 -> 11069;
11081 -> 11079;
11081 -> 11055;
11082 -> 11055;
11083 -> 11057;
11083 -> 11082;
11084 -> 11083;
11084 -> 11055;
11085 -> 11084;
11085 -> 4027;
11085 -> 11055;
11086 -> 11081;
11086 -> 11085;
11086 -> 11055;
11087 -> 11055;
11088 -> 11055;
11089 -> 11088;
11089 -> 11004;
11090 -> 11004;
11091 -> 11004;
11091 -> 0;
11092 -> 11004;
11093 -> 11004;
11093 -> 11092;
11094 -> 11092;
11095 -> 11093;
11095 -> 11094;
11096 -> 11094;
11097 -> 11095;
11097 -> 11096;
11098 -> 11097;
11098 -> 11094;
11099 -> 11094;
11100 -> 11098;
11100 -> 11099;
11101 -> 11004;
11102 -> 11101;
11102 -> 11004;
11103 -> 11004;
11103 -> 11102;
11104 -> 11102;
11105 -> 11103;
11105 -> 11104;
11106 -> 11104;
11107 -> 11105;
11107 -> 11106;
11108 -> 11107;
11108 -> 11104;
11109 -> 11104;
11110 -> 11108;
11110 -> 11109;
11111 -> 11004;
11111 -> 0;
11112 -> 11004;
11113 -> 11110;
11113 -> 11112;
11113 -> 11004;
11114 -> 11004;
11115 -> 11004;
11116 -> 11004;
11117 -> 11004;
11117 -> 11116;
11118 -> 11117;
11118 -> 11004;
11118 -> 11116;
11119 -> 11118;
11119 -> 11116;
11120 -> 11119;
11120 -> 11004;
11121 -> 11004;
11122 -> 11115;
11122 -> 11121;
11123 -> 11122;
11123 -> 11004;
11124 -> 11004;
11125 -> 11115;
11125 -> 11124;
11126 -> 11124;
11127 -> 11125;
11127 -> 11126;
11128 -> 11126;
11129 -> 11127;
11129 -> 11128;
11130 -> 11128;
11130 -> 11126;
11131 -> 11127;
11131 -> 11124;
11132 -> 11131;
11132 -> 11004;
11133 -> 11004;
11134 -> 11115;
11134 -> 11004;
11135 -> 11004;
11136 -> 11134;
11136 -> 11135;
11137 -> 11133;
11137 -> 11135;
11138 -> 11136;
11138 -> 11135;
11139 -> 11135;
11140 -> 11136;
11140 -> 11139;
11141 -> 11139;
11141 -> 11135;
11142 -> 11135;
11143 -> 11135;
11144 -> 11136;
11144 -> 11143;
11145 -> 0;
11145 -> 11143;
11146 -> 11144;
11146 -> 11135;
11147 -> 11135;
11148 -> 11136;
11148 -> 11147;
11149 -> 11148;
11149 -> 11004;
11149 -> 11147;
11150 -> 11149;
11150 -> 11135;
11151 -> 11150;
11151 -> 11135;
11152 -> 11135;
11153 -> 11152;
11153 -> 11004;
11154 -> 11004;
11155 -> 11004;
11156 -> 11004;
11157 -> 11004;
11158 -> 11157;
11158 -> 11004;
11159 -> 11158;
11159 -> 11004;
11160 -> 11158;
11160 -> 11004;
11161 -> 11160;
11161 -> 11004;
11162 -> 11161;
11162 -> 11004;
11163 -> 11161;
11163 -> 11004;
11164 -> 11004;
11165 -> 11004;
11166 -> 11004;
11167 -> 11121;
11167 -> 11004;
11168 -> 11004;
11169 -> 11004;
11169 -> 11168;
11170 -> 11168;
11171 -> 11170;
11171 -> 11004;
11172 -> 11004;
11173 -> 11121;
11174 -> 11121;
11175 -> 11171;
11175 -> 11121;
11176 -> 11121;
11177 -> 11176;
11178 -> 11121;
11179 -> 11175;
11179 -> 11178;
11179 -> 11121;
11180 -> 11171;
11180 -> 11178;
11180 -> 11121;
11181 -> 11121;
11181 -> 11004;
11182 -> 11004;
11183 -> 11121;
11184 -> 11121;
11185 -> 11183;
11185 -> 11184;
11186 -> 11184;
11187 -> 11185;
11187 -> 11186;
11187 -> 11184;
11188 -> 11185;
11188 -> 11184;
11189 -> 11184;
11189 -> 11121;
11190 -> 11004;
11191 -> 11004;
11192 -> 11004;
11193 -> 11004;
11193 -> 11192;
11194 -> 11192;
11195 -> 11193;
11195 -> 11194;
11196 -> 11195;
11196 -> 11121;
11196 -> 11194;
11197 -> 11194;
11198 -> 11196;
11198 -> 11197;
11199 -> 11197;
11199 -> 11194;
11200 -> 11196;
11200 -> 11192;
11201 -> 11200;
11201 -> 11004;
11202 -> 11004;
11203 -> 11201;
11203 -> 11202;
11204 -> 11202;
11205 -> 11203;
11205 -> 11204;
11206 -> 11204;
11207 -> 11205;
11207 -> 11206;
11208 -> 11206;
11209 -> 11207;
11209 -> 11121;
11209 -> 11208;
11209 -> 11206;
11210 -> 11204;
11211 -> 11205;
11211 -> 11202;
11212 -> 11202;
11213 -> 11190;
11213 -> 11121;
11214 -> 11190;
11215 -> 11213;
11215 -> 11214;
11216 -> 11214;
11216 -> 11190;
11217 -> 11004;
11217 -> 11121;
11217 -> 11190;
11218 -> 11213;
11219 -> 11213;
11220 -> 11004;
11220 -> 11213;
11220 -> 11002;
11221 -> 11220;
11221 -> 11002;
11222 -> 11002;
11223 -> 11221;
11223 -> 11222;
11223 -> 11002;
11224 -> 11221;
11224 -> 11002;
11225 -> 11002;
11226 -> 11224;
11226 -> 11225;
11227 -> 11008;
11227 -> 11225;
11228 -> 11002;
11229 -> 11004;
11229 -> 11228;
11230 -> 11229;
11230 -> 11213;
11230 -> 11228;
11231 -> 11002;
11232 -> 11230;
11232 -> 11231;
11233 -> 11005;
11233 -> 11231;
11234 -> 11006;
11234 -> 11231;
11235 -> 10292;
11235 -> 11231;
11236 -> 11231;
11237 -> 11232;
11237 -> 11231;
11238 -> 11231;
11239 -> 11226;
11239 -> 11238;
11239 -> 11002;
11240 -> 10993;
11241 -> 10995;
11241 -> 11240;
11242 -> 0;
11242 -> 11240;
11243 -> 11242;
11243 -> 10993;
11244 -> 10996;
11244 -> 10993;
11245 -> 10993;
11246 -> 11244;
11246 -> 11245;
11247 -> 11246;
11247 -> 11213;
11247 -> 11245;
11248 -> 11246;
11248 -> 11213;
11248 -> 11245;
11249 -> 11248;
11249 -> 10993;
11250 -> 10993;
11251 -> 11003;
11251 -> 11250;
11252 -> 11243;
11252 -> 11250;
11253 -> 11249;
11253 -> 11250;
11254 -> 10996;
11254 -> 11250;
11255 -> 10292;
11255 -> 11250;
11256 -> 11250;
11257 -> 11252;
11257 -> 11250;
11258 -> 11250;
11259 -> 11258;
11259 -> 10993;
11260 -> 11239;
11260 -> 11259;
11260 -> 10993;
11261 -> 10985;
11262 -> 11261;
11262 -> 10236;
11263 -> 10981;
11263 -> 11262;
11263 -> 10236;
11264 -> 10236;
11265 -> 10238;
11265 -> 11264;
11266 -> 11264;
11267 -> 11265;
11267 -> 11266;
11268 -> 11267;
11268 -> 11213;
11268 -> 11266;
11269 -> 11268;
11269 -> 11264;
11270 -> 11264;
11271 -> 11269;
11271 -> 11270;
11271 -> 11264;
11272 -> 11271;
11272 -> 11264;
11273 -> 11272;
11274 -> 11269;
11274 -> 11273;
11275 -> 11273;
11276 -> 11274;
11276 -> 11275;
11277 -> 11275;
11278 -> 11276;
11278 -> 11277;
11279 -> 11277;
11279 -> 11275;
11280 -> 11276;
11280 -> 11273;
11281 -> 11280;
11281 -> 10236;
11282 -> 10236;
11283 -> 11281;
11283 -> 11282;
11284 -> 11282;
11285 -> 11283;
11285 -> 11284;
11286 -> 11284;
11287 -> 11285;
11287 -> 11286;
11288 -> 11286;
11289 -> 11287;
11289 -> 11213;
11289 -> 11288;
11289 -> 11286;
11290 -> 11284;
11291 -> 11285;
11291 -> 11282;
11292 -> 11282;
11293 -> 10236;
11294 -> 10236;
11295 -> 11294;
11295 -> 10233;
11296 -> 11251;
11296 -> 10233;
11297 -> 10233;
11298 -> 11296;
11298 -> 11297;
11299 -> 10227;
11299 -> 11297;
11300 -> 11299;
11300 -> 11213;
11300 -> 11297;
11301 -> 11300;
11301 -> 11213;
11301 -> 11297;
11302 -> 11300;
11302 -> 11301;
11303 -> 11302;
11303 -> 10233;
11304 -> 10233;
11305 -> 11298;
11305 -> 11304;
11305 -> 10233;
11306 -> 10233;
11307 -> 11304;
11307 -> 11306;
11308 -> 10227;
11308 -> 11306;
11309 -> 11306;
11310 -> 11308;
11310 -> 11213;
11310 -> 11309;
11311 -> 11310;
11311 -> 11213;
11311 -> 8451;
11311 -> 11309;
11312 -> 11309;
11313 -> 11311;
11313 -> 11312;
11313 -> 11309;
11314 -> 11313;
11314 -> 11306;
11315 -> 11314;
11316 -> 11308;
11316 -> 11315;
11317 -> 11315;
11318 -> 11316;
11318 -> 11317;
11319 -> 11318;
11319 -> 11213;
11319 -> 11317;
11320 -> 11319;
11320 -> 11315;
11321 -> 11315;
11322 -> 11320;
11322 -> 11321;
11322 -> 11315;
11323 -> 11322;
11323 -> 11315;
11324 -> 11323;
11325 -> 11320;
11325 -> 11324;
11326 -> 11324;
11327 -> 11325;
11327 -> 11326;
11328 -> 11326;
11329 -> 11327;
11329 -> 11328;
11330 -> 11328;
11330 -> 11326;
11331 -> 11327;
11331 -> 11324;
11332 -> 11331;
11332 -> 11314;
11333 -> 11314;
11334 -> 11332;
11334 -> 11333;
11335 -> 11334;
11335 -> 11314;
11336 -> 11308;
11336 -> 11213;
11336 -> 11314;
11337 -> 11332;
11337 -> 11314;
11338 -> 11314;
11339 -> 11314;
11340 -> 11337;
11340 -> 11339;
11341 -> 11338;
11341 -> 11339;
11342 -> 11340;
11342 -> 11339;
11343 -> 11339;
11344 -> 11339;
11345 -> 11339;
11346 -> 11342;
11346 -> 11345;
11347 -> 11343;
11347 -> 11345;
11348 -> 11344;
11348 -> 11345;
11349 -> 11345;
11350 -> 11346;
11350 -> 11349;
11350 -> 11345;
11351 -> 11335;
11351 -> 11336;
11351 -> 11338;
11351 -> 11346;
11351 -> 11345;
11351 -> 11347;
11351 -> 11348;
11351 -> 11213;
11351 -> 11004;
11351 -> 11314;
11352 -> 11351;
11352 -> 11314;
11353 -> 0;
11353 -> 11314;
11354 -> 11314;
11355 -> 11308;
11355 -> 11354;
11356 -> 11355;
11356 -> 11351;
11356 -> 11354;
11357 -> 11355;
11357 -> 11351;
11357 -> 11354;
11358 -> 11354;
11359 -> 11355;
11359 -> 11358;
11360 -> 11358;
11361 -> 11358;
11362 -> 11360;
11362 -> 11361;
11363 -> 11362;
11363 -> 11361;
11364 -> 11362;
11364 -> 11361;
11365 -> 11362;
11365 -> 11361;
11366 -> 11362;
11366 -> 11361;
11367 -> 11362;
11367 -> 11361;
11368 -> 11362;
11368 -> 11361;
11369 -> 11362;
11369 -> 11361;
11370 -> 11358;
11371 -> 11359;
11371 -> 11351;
11371 -> 11370;
11372 -> 11371;
11372 -> 11351;
11372 -> 8399;
11372 -> 11370;
11373 -> 11370;
11374 -> 11372;
11374 -> 11373;
11374 -> 11370;
11375 -> 11374;
11375 -> 11358;
11376 -> 0;
11376 -> 11360;
11376 -> 11375;
11377 -> 11358;
11378 -> 11359;
11378 -> 11351;
11378 -> 11377;
11379 -> 11378;
11379 -> 11358;
11380 -> 0;
11380 -> 11360;
11380 -> 11379;
11381 -> 11358;
11382 -> 11359;
11382 -> 11351;
11382 -> 11381;
11383 -> 11382;
11383 -> 11351;
11383 -> 8403;
11383 -> 11381;
11384 -> 11381;
11385 -> 11383;
11385 -> 11384;
11385 -> 11381;
11386 -> 11385;
11386 -> 11358;
11387 -> 11358;
11388 -> 11359;
11388 -> 11351;
11388 -> 11387;
11389 -> 11388;
11389 -> 11351;
11389 -> 8411;
11389 -> 11387;
11390 -> 11387;
11391 -> 11389;
11391 -> 11390;
11391 -> 11387;
11392 -> 11391;
11392 -> 11358;
11393 -> 11358;
11394 -> 11359;
11394 -> 11351;
11394 -> 11393;
11395 -> 11394;
11395 -> 11351;
11395 -> 8415;
11395 -> 11393;
11396 -> 11393;
11397 -> 11395;
11397 -> 11396;
11397 -> 11393;
11398 -> 11397;
11398 -> 11358;
11399 -> 11358;
11400 -> 11359;
11400 -> 11351;
11400 -> 11399;
11401 -> 11400;
11401 -> 11351;
11401 -> 8439;
11401 -> 11399;
11402 -> 11399;
11403 -> 11401;
11403 -> 11402;
11403 -> 11399;
11404 -> 11403;
11404 -> 11358;
11405 -> 11358;
11406 -> 11359;
11406 -> 11351;
11406 -> 11405;
11407 -> 11406;
11407 -> 11351;
11407 -> 8395;
11407 -> 11405;
11408 -> 11405;
11409 -> 11407;
11409 -> 11408;
11409 -> 11405;
11410 -> 11409;
11410 -> 11358;
11411 -> 11360;
11411 -> 11358;
11412 -> 11411;
11412 -> 11354;
11413 -> 11357;
11413 -> 11412;
11413 -> 11363;
11413 -> 11364;
11413 -> 11365;
11413 -> 11376;
11413 -> 11380;
11413 -> 11368;
11413 -> 11369;
11413 -> 11351;
11413 -> 0;
11413 -> 11354;
11414 -> 11413;
11414 -> 11356;
11414 -> 11354;
11415 -> 11414;
11415 -> 11314;
11416 -> 11351;
11416 -> 11314;
11417 -> 0;
11417 -> 11314;
11418 -> 11314;
11419 -> 11308;
11419 -> 11415;
11419 -> 11418;
11420 -> 11419;
11420 -> 11415;
11420 -> 11418;
11421 -> 8451;
11421 -> 11418;
11422 -> 11314;
11423 -> 11415;
11423 -> 11314;
11424 -> 11423;
11424 -> 10233;
11425 -> 11305;
11425 -> 11424;
11425 -> 10233;
11426 -> 11298;
11426 -> 10233;
11427 -> 10233;
11428 -> 11426;
11428 -> 11427;
11429 -> 10227;
11429 -> 11427;
11430 -> 11427;
11431 -> 11429;
11431 -> 11415;
11431 -> 11430;
11432 -> 11431;
11432 -> 11415;
11432 -> 11420;
11432 -> 8407;
11432 -> 11430;
11433 -> 11432;
11433 -> 11427;
11434 -> 11427;
11435 -> 11428;
11435 -> 11434;
11435 -> 11427;
11436 -> 11427;
11437 -> 11429;
11437 -> 11415;
11437 -> 11436;
11438 -> 11437;
11438 -> 11415;
11438 -> 11420;
11438 -> 11436;
11439 -> 8407;
11439 -> 11436;
11440 -> 11427;
11441 -> 11428;
11441 -> 11427;
11442 -> 11441;
11442 -> 10224;
11443 -> 10224;
11444 -> 11442;
11444 -> 11443;
11444 -> 10224;
11445 -> 10224;
11446 -> 10225;
11446 -> 11445;
11447 -> 11446;
11447 -> 11415;
11447 -> 11445;
11448 -> 11447;
11448 -> 10224;
11449 -> 10224;
11450 -> 11448;
11450 -> 11449;
11451 -> 0;
11451 -> 11449;
11452 -> 11450;
11453 -> 11450;
11454 -> 11450;
11455 -> 11450;
11455 -> 11454;
11456 -> 11454;
11456 -> 11450;
11457 -> 11450;
11457 -> 11415;
11457 -> 11420;
11457 -> 11438;
11458 -> 11457;
11459 -> 11453;
11459 -> 11457;
11460 -> 11457;
11461 -> 11457;
11461 -> 11460;
11462 -> 11460;
11462 -> 11457;
11463 -> 11457;
11464 -> 11457;
11465 -> 11457;
11466 -> 11457;
11467 -> 11457;
11468 -> 11467;
11468 -> 11457;
11469 -> 11467;
11469 -> 11457;
11470 -> 11469;
11471 -> 11470;
11471 -> 11457;
11472 -> 11457;
11473 -> 11472;
11473 -> 11457;
11474 -> 11457;
11475 -> 11457;
11476 -> 11474;
11476 -> 11457;
11477 -> 11457;
11478 -> 11457;
11478 -> 11477;
11479 -> 0;
11479 -> 11477;
11480 -> 11479;
11480 -> 11457;
11481 -> 11480;
11481 -> 11457;
11482 -> 11457;
11483 -> 11481;
11483 -> 11482;
11484 -> 11476;
11484 -> 11482;
11485 -> 11483;
11485 -> 0;
11485 -> 11482;
11486 -> 11483;
11486 -> 11485;
11487 -> 11457;
11488 -> 11457;
11488 -> 11487;
11489 -> 11488;
11489 -> 11457;
11489 -> 11487;
11490 -> 11489;
11490 -> 11457;
11491 -> 11457;
11492 -> 11490;
11492 -> 11457;
11493 -> 11490;
11493 -> 11492;
11494 -> 11493;
11494 -> 11457;
11495 -> 11490;
11495 -> 11457;
11496 -> 11480;
11496 -> 11486;
11496 -> 11457;
11497 -> 11496;
11497 -> 11494;
11497 -> 11457;
11498 -> 11457;
11499 -> 11457;
11499 -> 11498;
11500 -> 11498;
11501 -> 11500;
11501 -> 11498;
11502 -> 11498;
11503 -> 11501;
11503 -> 11502;
11504 -> 11499;
11504 -> 11502;
11505 -> 11502;
11506 -> 11504;
11506 -> 11505;
11507 -> 11505;
11508 -> 11507;
11508 -> 11502;
11509 -> 11502;
11510 -> 11504;
11510 -> 11509;
11511 -> 11510;
11511 -> 11457;
11511 -> 11509;
11512 -> 11511;
11512 -> 11502;
11513 -> 11502;
11514 -> 11512;
11514 -> 11513;
11515 -> 11513;
11515 -> 11502;
11516 -> 11508;
11516 -> 11515;
11516 -> 11502;
11517 -> 11502;
11518 -> 11504;
11518 -> 11517;
11519 -> 11518;
11519 -> 11517;
11520 -> 11519;
11520 -> 11457;
11520 -> 11517;
11521 -> 11520;
11521 -> 11502;
11522 -> 11502;
11523 -> 11521;
11523 -> 11522;
11524 -> 11502;
11525 -> 11523;
11525 -> 11524;
11526 -> 11524;
11526 -> 11502;
11527 -> 11502;
11528 -> 11516;
11528 -> 11526;
11528 -> 11502;
11529 -> 11502;
11530 -> 11504;
11530 -> 11529;
11531 -> 11530;
11531 -> 11502;
11532 -> 11531;
11532 -> 4027;
11532 -> 11502;
11533 -> 11528;
11533 -> 11532;
11533 -> 11502;
11534 -> 11502;
11535 -> 11502;
11536 -> 11535;
11536 -> 11457;
11537 -> 11457;
11538 -> 11457;
11538 -> 0;
11539 -> 11457;
11540 -> 11457;
11540 -> 11539;
11541 -> 11539;
11542 -> 11540;
11542 -> 11541;
11543 -> 11541;
11544 -> 11542;
11544 -> 11543;
11545 -> 11544;
11545 -> 11541;
11546 -> 11541;
11547 -> 11545;
11547 -> 11546;
11548 -> 11457;
11549 -> 11548;
11549 -> 11457;
11550 -> 11457;
11550 -> 11549;
11551 -> 11549;
11552 -> 11550;
11552 -> 11551;
11553 -> 11551;
11554 -> 11552;
11554 -> 11553;
11555 -> 11554;
11555 -> 11551;
11556 -> 11551;
11557 -> 11555;
11557 -> 11556;
11558 -> 11457;
11558 -> 0;
11559 -> 11457;
11560 -> 11557;
11560 -> 11559;
11560 -> 11457;
11561 -> 11457;
11562 -> 11457;
11563 -> 11457;
11564 -> 11457;
11564 -> 11563;
11565 -> 11564;
11565 -> 11457;
11565 -> 11563;
11566 -> 11565;
11566 -> 11563;
11567 -> 11566;
11567 -> 11457;
11568 -> 11562;
11568 -> 11457;
11569 -> 11457;
11570 -> 11562;
11570 -> 11569;
11571 -> 11569;
11572 -> 11570;
11572 -> 11571;
11573 -> 11571;
11573 -> 11569;
11574 -> 11570;
11574 -> 11457;
11575 -> 11457;
11576 -> 11562;
11576 -> 11457;
11577 -> 11457;
11578 -> 11576;
11578 -> 11577;
11579 -> 11575;
11579 -> 11577;
11580 -> 11578;
11580 -> 11577;
11581 -> 11577;
11582 -> 11578;
11582 -> 11581;
11583 -> 11581;
11583 -> 11577;
11584 -> 11577;
11585 -> 11577;
11586 -> 11578;
11586 -> 11585;
11587 -> 0;
11587 -> 11585;
11588 -> 11586;
11588 -> 11577;
11589 -> 11577;
11590 -> 11578;
11590 -> 11589;
11591 -> 11590;
11591 -> 11457;
11591 -> 11589;
11592 -> 11591;
11592 -> 11577;
11593 -> 11592;
11593 -> 11577;
11594 -> 11577;
11595 -> 11594;
11595 -> 11457;
11596 -> 11457;
11597 -> 11457;
11598 -> 11457;
11599 -> 11450;
11600 -> 11457;
11600 -> 11599;
11600 -> 11450;
11601 -> 11450;
11602 -> 11450;
11603 -> 11450;
11604 -> 11457;
11604 -> 11603;
11605 -> 11603;
11606 -> 11605;
11606 -> 11450;
11607 -> 11450;
11608 -> 11457;
11608 -> 11607;
11608 -> 11450;
11609 -> 11457;
11610 -> 11457;
11611 -> 11569;
11612 -> 11610;
11612 -> 11569;
11613 -> 11569;
11613 -> 11571;
11614 -> 11569;
11615 -> 11569;
11616 -> 11569;
11617 -> 11569;
11618 -> 11569;
11619 -> 11618;
11619 -> 11569;
11620 -> 11618;
11620 -> 11569;
11621 -> 11620;
11622 -> 11621;
11622 -> 11569;
11623 -> 11569;
11624 -> 11623;
11624 -> 11569;
11625 -> 11569;
11626 -> 11569;
11627 -> 11625;
11627 -> 11569;
11628 -> 11569;
11629 -> 11569;
11629 -> 11628;
11630 -> 0;
11630 -> 11628;
11631 -> 11630;
11631 -> 11569;
11632 -> 11631;
11632 -> 11569;
11633 -> 11569;
11634 -> 11632;
11634 -> 11633;
11635 -> 11627;
11635 -> 11633;
11636 -> 11634;
11636 -> 0;
11636 -> 11633;
11637 -> 11634;
11637 -> 11636;
11638 -> 11569;
11639 -> 11569;
11639 -> 11638;
11640 -> 11639;
11640 -> 11569;
11640 -> 11638;
11641 -> 11640;
11641 -> 11569;
11642 -> 11569;
11643 -> 11641;
11643 -> 11569;
11644 -> 11641;
11644 -> 11643;
11645 -> 11644;
11645 -> 11569;
11646 -> 11641;
11646 -> 11569;
11647 -> 11631;
11647 -> 11637;
11647 -> 11569;
11648 -> 11647;
11648 -> 11645;
11648 -> 11569;
11649 -> 11569;
11650 -> 11569;
11650 -> 11649;
11651 -> 11649;
11652 -> 11651;
11652 -> 11649;
11653 -> 11649;
11654 -> 11652;
11654 -> 11653;
11655 -> 11650;
11655 -> 11653;
11656 -> 11653;
11657 -> 11655;
11657 -> 11656;
11658 -> 11656;
11659 -> 11658;
11659 -> 11653;
11660 -> 11653;
11661 -> 11655;
11661 -> 11660;
11662 -> 11661;
11662 -> 11569;
11662 -> 11660;
11663 -> 11662;
11663 -> 11653;
11664 -> 11653;
11665 -> 11663;
11665 -> 11664;
11666 -> 11664;
11666 -> 11653;
11667 -> 11659;
11667 -> 11666;
11667 -> 11653;
11668 -> 11653;
11669 -> 11655;
11669 -> 11668;
11670 -> 11669;
11670 -> 11668;
11671 -> 11670;
11671 -> 11569;
11671 -> 11668;
11672 -> 11671;
11672 -> 11653;
11673 -> 11653;
11674 -> 11672;
11674 -> 11673;
11675 -> 11653;
11676 -> 11674;
11676 -> 11675;
11677 -> 11675;
11677 -> 11653;
11678 -> 11653;
11679 -> 11667;
11679 -> 11677;
11679 -> 11653;
11680 -> 11653;
11681 -> 11655;
11681 -> 11680;
11682 -> 11681;
11682 -> 11653;
11683 -> 11682;
11683 -> 4027;
11683 -> 11653;
11684 -> 11679;
11684 -> 11683;
11684 -> 11653;
11685 -> 11653;
11686 -> 11653;
11687 -> 11686;
11687 -> 11569;
11688 -> 11569;
11689 -> 11569;
11689 -> 0;
11690 -> 11569;
11691 -> 11569;
11691 -> 11690;
11692 -> 11690;
11693 -> 11691;
11693 -> 11692;
11694 -> 11692;
11695 -> 11693;
11695 -> 11694;
11696 -> 11695;
11696 -> 11692;
11697 -> 11692;
11698 -> 11696;
11698 -> 11697;
11699 -> 11569;
11700 -> 11699;
11700 -> 11569;
11701 -> 11569;
11701 -> 11700;
11702 -> 11700;
11703 -> 11701;
11703 -> 11702;
11704 -> 11702;
11705 -> 11703;
11705 -> 11704;
11706 -> 11705;
11706 -> 11702;
11707 -> 11702;
11708 -> 11706;
11708 -> 11707;
11709 -> 11569;
11709 -> 0;
11710 -> 11569;
11711 -> 11708;
11711 -> 11710;
11711 -> 11569;
11712 -> 11569;
11713 -> 11569;
11714 -> 11569;
11715 -> 11569;
11715 -> 11714;
11716 -> 11715;
11716 -> 11569;
11716 -> 11714;
11717 -> 11716;
11717 -> 11714;
11718 -> 11717;
11718 -> 11569;
11719 -> 11713;
11719 -> 11569;
11720 -> 11713;
11720 -> 11571;
11721 -> 11713;
11721 -> 11569;
11722 -> 11569;
11723 -> 11713;
11723 -> 11569;
11724 -> 11569;
11725 -> 11723;
11725 -> 11724;
11726 -> 11722;
11726 -> 11724;
11727 -> 11725;
11727 -> 11724;
11728 -> 11724;
11729 -> 11725;
11729 -> 11728;
11730 -> 11728;
11730 -> 11724;
11731 -> 11724;
11732 -> 11724;
11733 -> 11725;
11733 -> 11732;
11734 -> 0;
11734 -> 11732;
11735 -> 11733;
11735 -> 11724;
11736 -> 11724;
11737 -> 11725;
11737 -> 11736;
11738 -> 11737;
11738 -> 11569;
11738 -> 11736;
11739 -> 11738;
11739 -> 11724;
11740 -> 11739;
11740 -> 11724;
11741 -> 11724;
11742 -> 11741;
11742 -> 11569;
11743 -> 11569;
11744 -> 11569;
11745 -> 11713;
11746 -> 11713;
11747 -> 11746;
11747 -> 11713;
11748 -> 11747;
11748 -> 11713;
11749 -> 11747;
11749 -> 11713;
11750 -> 11749;
11750 -> 11713;
11751 -> 11750;
11751 -> 11713;
11752 -> 11750;
11752 -> 11713;
11753 -> 11713;
11753 -> 11569;
11754 -> 11606;
11754 -> 11457;
11755 -> 11457;
11756 -> 11713;
11756 -> 11755;
11756 -> 11457;
11757 -> 11713;
11758 -> 11713;
11759 -> 11754;
11759 -> 11713;
11760 -> 11713;
11761 -> 11760;
11762 -> 11713;
11763 -> 11754;
11763 -> 11762;
11763 -> 11713;
11764 -> 11457;
11765 -> 11606;
11765 -> 11764;
11765 -> 11457;
11766 -> 11713;
11766 -> 11450;
11767 -> 11450;
11768 -> 11713;
11769 -> 11713;
11770 -> 11768;
11770 -> 11769;
11771 -> 11769;
11772 -> 11770;
11772 -> 11771;
11772 -> 11769;
11773 -> 11770;
11773 -> 11769;
11774 -> 11769;
11774 -> 11713;
11775 -> 11713;
11776 -> 11713;
11777 -> 11713;
11778 -> 11713;
11779 -> 11713;
11779 -> 11778;
11780 -> 11778;
11781 -> 11780;
11781 -> 11713;
11782 -> 11781;
11782 -> 11762;
11782 -> 11713;
11783 -> 11713;
11784 -> 11713;
11785 -> 11450;
11786 -> 11450;
11787 -> 11786;
11787 -> 11713;
11788 -> 11786;
11789 -> 11787;
11789 -> 11788;
11790 -> 11788;
11790 -> 11786;
11791 -> 11787;
11791 -> 11450;
11792 -> 11450;
11793 -> 11791;
11793 -> 11792;
11794 -> 11792;
11795 -> 11793;
11795 -> 11794;
11796 -> 11794;
11797 -> 11795;
11797 -> 11796;
11798 -> 11796;
11799 -> 11797;
11799 -> 11713;
11799 -> 11798;
11799 -> 11796;
11800 -> 11794;
11801 -> 11795;
11801 -> 11792;
11802 -> 11792;
11803 -> 11786;
11803 -> 11713;
11803 -> 11450;
11804 -> 11803;
11804 -> 11454;
11805 -> 11803;
11806 -> 11803;
11807 -> 11806;
11807 -> 11803;
11808 -> 11807;
11809 -> 11807;
11810 -> 11808;
11810 -> 11809;
11811 -> 11809;
11812 -> 11809;
11812 -> 11807;
11813 -> 11807;
11814 -> 11812;
11814 -> 11813;
11815 -> 11814;
11815 -> 11807;
11816 -> 11807;
11817 -> 11812;
11817 -> 11816;
11818 -> 11816;
11819 -> 11817;
11819 -> 11818;
11820 -> 11819;
11820 -> 11803;
11820 -> 11818;
11821 -> 11820;
11821 -> 11816;
11822 -> 11816;
11823 -> 11821;
11823 -> 11822;
11823 -> 11816;
11824 -> 11823;
11824 -> 11816;
11825 -> 11824;
11826 -> 11821;
11826 -> 11825;
11827 -> 11825;
11828 -> 11826;
11828 -> 11827;
11829 -> 11828;
11829 -> 11825;
11830 -> 11825;
11831 -> 11829;
11831 -> 11830;
11832 -> 11831;
11832 -> 11807;
11833 -> 11807;
11834 -> 11832;
11834 -> 11833;
11835 -> 11833;
11836 -> 11835;
11836 -> 11807;
11837 -> 11807;
11838 -> 11815;
11838 -> 11836;
11838 -> 11807;
11839 -> 11450;
11839 -> 11803;
11839 -> 11449;
11840 -> 11442;
11840 -> 10224;
11841 -> 11840;
11841 -> 11839;
11841 -> 10224;
11842 -> 11841;
11842 -> 10223;
11843 -> 10223;
11844 -> 11842;
11844 -> 11843;
11844 -> 10223;
11845 -> 10221;
11845 -> 7352;
11846 -> 7336;
11847 -> 11842;
11847 -> 11846;
11847 -> 7336;
11848 -> 11845;
11848 -> 7336;
11849 -> 0;
11849 -> 2793;
11850 -> 2793;
11851 -> 11849;
11851 -> 11850;
11852 -> 2777;
11852 -> 11850;
11853 -> 11851;
11853 -> 11850;
11854 -> 11850;
11855 -> 11852;
11855 -> 11854;
11856 -> 11855;
11856 -> 11803;
11856 -> 11854;
11857 -> 11856;
11857 -> 11850;
11858 -> 0;
11858 -> 11850;
11859 -> 11850;
11860 -> 11857;
11860 -> 11859;
11861 -> 11858;
11861 -> 11859;
11862 -> 11860;
11862 -> 11861;
11862 -> 11859;
11863 -> 11851;
11863 -> 0;
11863 -> 11850;
11864 -> 11850;
11865 -> 11852;
11865 -> 11803;
11865 -> 11864;
11865 -> 11850;
11866 -> 11852;
11866 -> 11803;
11866 -> 11450;
11866 -> 11863;
11866 -> 11850;
11867 -> 11866;
11868 -> 11866;
11869 -> 11866;
11870 -> 11869;
11870 -> 11866;
11871 -> 11862;
11871 -> 11866;
11872 -> 11866;
11873 -> 11866;
11874 -> 11868;
11874 -> 11866;
11875 -> 11868;
11875 -> 11866;
11876 -> 11871;
11876 -> 11866;
11877 -> 11866;
11878 -> 11866;
11879 -> 11878;
11879 -> 11866;
11880 -> 11872;
11880 -> 11866;
11881 -> 11873;
11881 -> 11866;
11882 -> 11874;
11882 -> 11866;
11883 -> 11875;
11883 -> 11866;
11884 -> 11876;
11884 -> 11866;
11885 -> 11866;
11886 -> 11866;
11887 -> 11866;
11888 -> 11866;
11889 -> 11866;
11890 -> 11866;
11891 -> 11866;
11892 -> 11866;
11893 -> 11866;
11894 -> 11866;
11895 -> 11893;
11895 -> 11866;
11896 -> 11866;
11897 -> 11894;
11897 -> 11866;
11898 -> 11895;
11898 -> 11866;
11899 -> 11896;
11899 -> 11866;
11900 -> 11897;
11900 -> 11866;
11901 -> 11898;
11901 -> 11866;
11902 -> 11900;
11902 -> 11866;
11903 -> 11899;
11903 -> 11866;
11904 -> 11901;
11904 -> 11866;
11905 -> 11902;
11905 -> 11866;
11906 -> 11903;
11906 -> 11866;
11907 -> 11866;
11908 -> 11904;
11908 -> 11866;
11909 -> 11866;
11910 -> 11866;
11911 -> 11866;
11912 -> 11905;
11912 -> 11866;
11913 -> 11866;
11914 -> 11906;
11914 -> 11866;
11915 -> 11866;
11916 -> 11908;
11916 -> 11907;
11917 -> 11909;
11917 -> 11907;
11918 -> 11866;
11918 -> 11907;
11919 -> 11866;
11919 -> 11907;
11920 -> 11910;
11920 -> 11907;
11921 -> 11911;
11921 -> 11907;
11922 -> 11912;
11922 -> 11907;
11923 -> 11913;
11923 -> 11907;
11924 -> 11914;
11924 -> 11907;
11925 -> 11915;
11925 -> 11907;
11926 -> 11907;
11927 -> 11918;
11927 -> 11907;
11928 -> 11919;
11928 -> 11907;
11929 -> 11920;
11929 -> 11907;
11930 -> 11925;
11930 -> 11907;
11931 -> 11927;
11931 -> 11926;
11932 -> 11928;
11932 -> 11926;
11933 -> 11929;
11933 -> 11926;
11934 -> 11930;
11934 -> 11926;
11935 -> 11926;
11936 -> 11934;
11936 -> 11926;
11937 -> 11936;
11937 -> 11935;
11938 -> 11935;
11939 -> 11935;
11939 -> 11926;
11940 -> 11935;
11940 -> 11926;
11941 -> 11935;
11941 -> 11926;
11942 -> 11926;
11943 -> 11931;
11943 -> 11942;
11943 -> 11926;
11944 -> 11931;
11944 -> 11935;
11944 -> 11926;
11945 -> 11932;
11945 -> 11935;
11945 -> 11926;
11946 -> 11926;
11947 -> 11932;
11947 -> 11946;
11947 -> 11926;
11948 -> 11933;
11948 -> 11947;
11948 -> 11926;
11949 -> 11948;
11949 -> 11935;
11949 -> 11926;
11950 -> 11926;
11950 -> 11907;
11951 -> 11926;
11951 -> 11907;
11952 -> 11926;
11952 -> 11907;
11953 -> 11926;
11953 -> 11907;
11954 -> 11926;
11954 -> 11907;
11955 -> 11926;
11955 -> 11907;
11956 -> 11907;
11957 -> 11916;
11957 -> 11956;
11957 -> 11907;
11958 -> 11907;
11959 -> 11917;
11959 -> 11958;
11959 -> 11907;
11960 -> 11907;
11961 -> 11924;
11961 -> 11960;
11961 -> 11907;
11962 -> 11917;
11962 -> 11926;
11962 -> 11907;
11963 -> 11916;
11963 -> 11926;
11963 -> 11907;
11964 -> 11921;
11964 -> 11926;
11964 -> 11907;
11965 -> 11922;
11965 -> 11926;
11965 -> 11907;
11966 -> 11923;
11966 -> 11926;
11966 -> 11907;
11967 -> 11924;
11967 -> 11926;
11967 -> 11907;
11968 -> 11866;
11969 -> 11866;
11970 -> 11969;
11971 -> 11970;
11971 -> 11866;
11972 -> 11970;
11972 -> 11866;
11973 -> 11866;
11974 -> 11866;
11975 -> 11866;
11976 -> 11974;
11976 -> 11975;
11977 -> 11975;
11978 -> 11976;
11978 -> 11977;
11979 -> 0;
11979 -> 11977;
11980 -> 11979;
11980 -> 11975;
11981 -> 11980;
11981 -> 11976;
11981 -> 11975;
11982 -> 11981;
11983 -> 11982;
11983 -> 11866;
11984 -> 11866;
11985 -> 11983;
11985 -> 11984;
11986 -> 11866;
11986 -> 11984;
11987 -> 11984;
11988 -> 11985;
11988 -> 11987;
11988 -> 11984;
11989 -> 11988;
11990 -> 11881;
11990 -> 11989;
11990 -> 11866;
11991 -> 11990;
11992 -> 11866;
11993 -> 11991;
11993 -> 11992;
11993 -> 11866;
11994 -> 11993;
11994 -> 11880;
11994 -> 11866;
11995 -> 11866;
11996 -> 11869;
11997 -> 11869;
11997 -> 11996;
11998 -> 11996;
11999 -> 11998;
11999 -> 11869;
12000 -> 11869;
12001 -> 11869;
12002 -> 11869;
12003 -> 11869;
12004 -> 11869;
12005 -> 11869;
12006 -> 11869;
12007 -> 11869;
12008 -> 11869;
12009 -> 11869;
12009 -> 12008;
12010 -> 12008;
12010 -> 11869;
12011 -> 11869;
12012 -> 12011;
12012 -> 11869;
12013 -> 11869;
12014 -> 12013;
12014 -> 11869;
12015 -> 11869;
12016 -> 11869;
12017 -> 12015;
12017 -> 11869;
12018 -> 12017;
12019 -> 12017;
12020 -> 11869;
12021 -> 11869;
12022 -> 11869;
12023 -> 0;
12023 -> 11869;
12024 -> 11869;
12025 -> 12024;
12025 -> 11869;
12026 -> 11869;
12027 -> 12025;
12027 -> 12026;
12027 -> 11869;
12028 -> 11869;
12028 -> 0;
12029 -> 12025;
12029 -> 11869;
12030 -> 12029;
12030 -> 11869;
12031 -> 12029;
12031 -> 11869;
12032 -> 11869;
12033 -> 12032;
12033 -> 11869;
12034 -> 11869;
12035 -> 11869;
12035 -> 12034;
12036 -> 12034;
12037 -> 11869;
12038 -> 11869;
12039 -> 11869;
12040 -> 11869;
12041 -> 11869;
12042 -> 11869;
12043 -> 11869;
12044 -> 11869;
12044 -> 12043;
12045 -> 12043;
12046 -> 12044;
12046 -> 12045;
12047 -> 12046;
12047 -> 11869;
12047 -> 12045;
12048 -> 12047;
12048 -> 12043;
12049 -> 12043;
12050 -> 12048;
12050 -> 12049;
12050 -> 12043;
12051 -> 12050;
12051 -> 12043;
12052 -> 12051;
12053 -> 12048;
12053 -> 12052;
12054 -> 12052;
12055 -> 12053;
12055 -> 12054;
12056 -> 12055;
12056 -> 12052;
12057 -> 12052;
12058 -> 12056;
12058 -> 12057;
12059 -> 12058;
12059 -> 11869;
12060 -> 11869;
12061 -> 11869;
12062 -> 11869;
12063 -> 11869;
12064 -> 0;
12064 -> 11869;
12065 -> 11869;
12066 -> 12063;
12066 -> 12065;
12067 -> 12063;
12067 -> 12065;
12068 -> 12064;
12068 -> 12065;
12069 -> 12066;
12069 -> 12065;
12070 -> 12067;
12070 -> 12065;
12071 -> 12068;
12071 -> 12065;
12072 -> 12065;
12073 -> 12070;
12073 -> 12072;
12074 -> 12071;
12074 -> 12072;
12075 -> 12066;
12075 -> 12072;
12076 -> 12074;
12076 -> 12073;
12077 -> 12076;
12077 -> 12073;
12078 -> 12075;
12078 -> 12073;
12079 -> 11869;
12080 -> 11869;
12081 -> 12079;
12081 -> 12080;
12082 -> 12080;
12083 -> 12081;
12083 -> 12082;
12084 -> 12082;
12084 -> 12080;
12085 -> 12084;
12085 -> 11869;
12086 -> 11869;
12087 -> 12000;
12087 -> 12086;
12087 -> 11869;
12088 -> 11866;
12088 -> 11869;
12089 -> 11869;
12090 -> 11869;
12091 -> 11869;
12092 -> 11869;
12092 -> 12091;
12093 -> 12091;
12093 -> 11869;
12094 -> 11869;
12095 -> 12090;
12095 -> 11869;
12096 -> 11869;
12096 -> 12095;
12097 -> 11869;
12098 -> 11869;
12098 -> 12097;
12099 -> 12098;
12099 -> 11869;
12099 -> 12097;
12100 -> 12099;
12100 -> 11869;
12101 -> 11869;
12102 -> 11869;
12103 -> 0;
12103 -> 12102;
12104 -> 12102;
12104 -> 11869;
12105 -> 11881;
12105 -> 12104;
12105 -> 11869;
12106 -> 11869;
12107 -> 11869;
12108 -> 11869;
12109 -> 11869;
12110 -> 11869;
12110 -> 12109;
12111 -> 12110;
12111 -> 11869;
12111 -> 12109;
12112 -> 12111;
12112 -> 11869;
12113 -> 11869;
12114 -> 11869;
12115 -> 11869;
12116 -> 12114;
12116 -> 12115;
12116 -> 11869;
12117 -> 11869;
12117 -> 5032;
12118 -> 11869;
12119 -> 12118;
12119 -> 11869;
12120 -> 11869;
12121 -> 11991;
12121 -> 11869;
12122 -> 0;
12122 -> 11869;
12123 -> 11869;
12124 -> 12120;
12124 -> 12123;
12125 -> 12121;
12125 -> 12123;
12126 -> 12122;
12126 -> 12123;
12127 -> 12124;
12127 -> 12123;
12128 -> 12125;
12128 -> 12123;
12129 -> 12126;
12129 -> 12123;
12130 -> 12123;
12131 -> 12128;
12131 -> 12130;
12132 -> 12129;
12132 -> 12130;
12133 -> 12124;
12133 -> 12130;
12134 -> 12132;
12134 -> 12131;
12135 -> 12134;
12135 -> 12131;
12136 -> 12133;
12136 -> 12131;
12137 -> 12131;
12138 -> 12137;
12139 -> 11869;
12140 -> 11991;
12140 -> 12139;
12140 -> 11869;
12141 -> 11869;
12142 -> 11869;
12142 -> 12141;
12143 -> 12141;
12144 -> 12142;
12144 -> 11869;
12144 -> 12143;
12145 -> 12144;
12145 -> 12141;
12146 -> 12145;
12146 -> 11869;
12147 -> 11869;
12148 -> 12146;
12148 -> 11869;
12149 -> 11869;
12150 -> 12147;
12150 -> 11869;
12151 -> 12148;
12151 -> 11869;
12152 -> 12149;
12152 -> 11869;
12153 -> 12150;
12153 -> 11869;
12154 -> 12151;
12154 -> 11869;
12155 -> 12153;
12155 -> 11869;
12156 -> 12152;
12156 -> 11869;
12157 -> 12154;
12157 -> 11869;
12158 -> 12155;
12158 -> 11869;
12159 -> 12156;
12159 -> 11869;
12160 -> 11869;
12161 -> 12157;
12161 -> 11869;
12162 -> 11869;
12163 -> 11869;
12164 -> 11869;
12165 -> 12158;
12165 -> 11869;
12166 -> 11869;
12167 -> 12159;
12167 -> 11869;
12168 -> 11869;
12169 -> 12161;
12169 -> 12160;
12170 -> 12162;
12170 -> 12160;
12171 -> 11869;
12171 -> 12160;
12172 -> 11869;
12172 -> 12160;
12173 -> 12163;
12173 -> 12160;
12174 -> 12164;
12174 -> 12160;
12175 -> 12165;
12175 -> 12160;
12176 -> 12166;
12176 -> 12160;
12177 -> 12167;
12177 -> 12160;
12178 -> 12168;
12178 -> 12160;
12179 -> 12160;
12180 -> 12171;
12180 -> 12160;
12181 -> 12172;
12181 -> 12160;
12182 -> 12173;
12182 -> 12160;
12183 -> 12178;
12183 -> 12160;
12184 -> 12180;
12184 -> 12179;
12185 -> 12181;
12185 -> 12179;
12186 -> 12182;
12186 -> 12179;
12187 -> 12183;
12187 -> 12179;
12188 -> 12179;
12189 -> 12187;
12189 -> 12179;
12190 -> 12189;
12190 -> 12188;
12191 -> 12188;
12192 -> 12188;
12192 -> 12179;
12193 -> 12188;
12193 -> 12179;
12194 -> 12188;
12194 -> 12179;
12195 -> 12179;
12196 -> 12184;
12196 -> 12195;
12196 -> 12179;
12197 -> 12184;
12197 -> 12188;
12197 -> 12179;
12198 -> 12185;
12198 -> 12188;
12198 -> 12179;
12199 -> 12179;
12200 -> 12185;
12200 -> 12199;
12200 -> 12179;
12201 -> 12186;
12201 -> 12200;
12201 -> 12179;
12202 -> 12201;
12202 -> 12188;
12202 -> 12179;
12203 -> 12179;
12203 -> 12160;
12204 -> 12179;
12204 -> 12160;
12205 -> 12179;
12205 -> 12160;
12206 -> 12179;
12206 -> 12160;
12207 -> 12179;
12207 -> 12160;
12208 -> 12179;
12208 -> 12160;
12209 -> 12160;
12210 -> 12169;
12210 -> 12209;
12210 -> 12160;
12211 -> 12160;
12212 -> 12170;
12212 -> 12211;
12212 -> 12160;
12213 -> 12160;
12214 -> 12177;
12214 -> 12213;
12214 -> 12160;
12215 -> 12170;
12215 -> 12179;
12215 -> 12160;
12216 -> 12169;
12216 -> 12179;
12216 -> 12160;
12217 -> 12174;
12217 -> 12179;
12217 -> 12160;
12218 -> 12175;
12218 -> 12179;
12218 -> 12160;
12219 -> 12176;
12219 -> 12179;
12219 -> 12160;
12220 -> 12177;
12220 -> 12179;
12220 -> 12160;
12221 -> 12042;
12222 -> 12221;
12222 -> 11869;
12223 -> 12221;
12223 -> 11869;
12224 -> 12081;
12224 -> 12082;
12225 -> 0;
12225 -> 12082;
12226 -> 12225;
12226 -> 12080;
12227 -> 12226;
12227 -> 12081;
12227 -> 12080;
12228 -> 12227;
12229 -> 12228;
12229 -> 12089;
12229 -> 11869;
12230 -> 12229;
12231 -> 11881;
12231 -> 12230;
12231 -> 11869;
12232 -> 12231;
12233 -> 12232;
12233 -> 12106;
12233 -> 11869;
12234 -> 11866;
12234 -> 11869;
12235 -> 11869;
12236 -> 12235;
12236 -> 11869;
12237 -> 12236;
12237 -> 11869;
12238 -> 12237;
12238 -> 11869;
12239 -> 12238;
12239 -> 11869;
12240 -> 12239;
12240 -> 11869;
12241 -> 12240;
12241 -> 12160;
12242 -> 12241;
12242 -> 12209;
12242 -> 12160;
12243 -> 12241;
12243 -> 12179;
12243 -> 12160;
12244 -> 11869;
12244 -> 11866;
12245 -> 11866;
12246 -> 12244;
12246 -> 12245;
12246 -> 11866;
12247 -> 12244;
12247 -> 11866;
12248 -> 11869;
12248 -> 11866;
12249 -> 2793;
12250 -> 11869;
12250 -> 12249;
12250 -> 2793;
12251 -> 11869;
12251 -> 2793;
12252 -> 2777;
12252 -> 12251;
12253 -> 0;
12253 -> 12251;
12254 -> 2778;
12254 -> 12251;
12255 -> 12251;
12256 -> 12251;
12257 -> 12252;
12257 -> 12256;
12258 -> 12253;
12258 -> 12256;
12259 -> 12254;
12259 -> 12256;
12260 -> 12253;
12260 -> 12256;
12261 -> 12255;
12261 -> 12256;
12262 -> 12256;
12263 -> 12260;
12263 -> 12262;
12263 -> 12256;
12264 -> 12261;
12264 -> 12262;
12264 -> 12256;
12265 -> 12263;
12265 -> 12264;
12265 -> 12256;
12266 -> 12258;
12266 -> 12256;
12267 -> 12259;
12267 -> 12256;
12268 -> 12260;
12268 -> 12256;
12269 -> 12261;
12269 -> 12256;
12270 -> 12266;
12270 -> 12256;
12271 -> 12256;
12272 -> 12269;
12272 -> 12271;
12272 -> 12256;
12273 -> 12268;
12273 -> 12271;
12273 -> 12256;
12274 -> 12272;
12274 -> 12273;
12274 -> 12256;
12275 -> 12256;
12276 -> 12275;
12276 -> 12256;
12277 -> 12270;
12277 -> 12256;
12278 -> 12256;
12279 -> 12258;
12279 -> 12278;
12279 -> 12256;
12280 -> 12258;
12280 -> 0;
12280 -> 12256;
12281 -> 12258;
12282 -> 12258;
12283 -> 12282;
12283 -> 12258;
12284 -> 0;
12284 -> 12258;
12285 -> 12258;
12286 -> 12283;
12286 -> 12285;
12287 -> 12284;
12287 -> 12285;
12288 -> 12286;
12288 -> 12287;
12288 -> 12285;
12289 -> 12257;
12290 -> 12257;
12291 -> 12257;
12292 -> 12290;
12292 -> 12291;
12292 -> 12257;
12293 -> 12290;
12293 -> 12257;
12294 -> 12257;
12295 -> 12257;
12296 -> 12257;
12297 -> 12257;
12298 -> 12257;
12298 -> 12297;
12299 -> 12297;
12299 -> 12257;
12300 -> 12257;
12301 -> 12300;
12301 -> 12257;
12302 -> 12257;
12303 -> 12257;
12304 -> 12303;
12305 -> 12304;
12306 -> 12304;
12306 -> 12305;
12307 -> 12305;
12307 -> 12304;
12308 -> 12304;
12308 -> 12303;
12309 -> 12257;
12309 -> 12303;
12310 -> 12303;
12311 -> 12309;
12311 -> 12310;
12312 -> 12308;
12312 -> 12310;
12313 -> 12303;
12314 -> 12257;
12315 -> 12257;
12316 -> 0;
12316 -> 12257;
12317 -> 0;
12317 -> 12257;
12318 -> 0;
12318 -> 12257;
12319 -> 0;
12319 -> 12257;
12320 -> 12257;
12321 -> 12320;
12321 -> 12257;
12322 -> 12321;
12322 -> 12257;
12323 -> 12257;
12324 -> 12257;
12325 -> 12257;
12326 -> 12257;
12327 -> 12326;
12327 -> 12257;
12328 -> 12323;
12328 -> 12257;
12329 -> 12328;
12329 -> 12257;
12330 -> 12326;
12331 -> 12326;
12332 -> 12326;
12333 -> 12326;
12334 -> 12326;
12335 -> 12326;
12335 -> 12257;
12336 -> 12326;
12336 -> 0;
12337 -> 12326;
12337 -> 0;
12338 -> 12257;
12338 -> 12326;
12339 -> 12326;
12340 -> 12326;
12341 -> 12257;
12342 -> 12341;
12342 -> 12326;
12343 -> 12342;
12343 -> 12257;
12344 -> 12326;
12344 -> 12297;
12345 -> 12326;
12346 -> 12257;
12346 -> 12326;
12347 -> 12326;
12348 -> 12326;
12349 -> 12326;
12350 -> 12326;
12351 -> 12326;
12352 -> 12326;
12353 -> 12326;
12354 -> 12353;
12354 -> 12326;
12355 -> 12354;
12356 -> 12354;
12356 -> 12355;
12357 -> 12355;
12358 -> 12356;
12358 -> 12357;
12359 -> 12357;
12360 -> 12358;
12360 -> 12326;
12360 -> 12359;
12360 -> 12357;
12361 -> 12355;
12362 -> 12356;
12362 -> 12326;
12362 -> 12355;
12363 -> 12362;
12363 -> 12354;
12364 -> 12354;
12365 -> 12326;
12366 -> 12326;
12367 -> 12326;
12368 -> 12326;
12369 -> 12326;
12370 -> 12326;
12371 -> 12326;
12372 -> 12326;
12373 -> 12326;
12374 -> 12373;
12374 -> 12372;
12374 -> 12326;
12375 -> 12374;
12375 -> 12373;
12376 -> 12373;
12377 -> 12374;
12377 -> 12376;
12378 -> 12377;
12378 -> 12373;
12379 -> 12378;
12380 -> 12378;
12380 -> 12379;
12381 -> 12379;
12382 -> 12380;
12382 -> 12381;
12383 -> 12381;
12384 -> 12382;
12384 -> 12374;
12384 -> 12383;
12384 -> 12381;
12385 -> 12379;
12386 -> 12380;
12386 -> 12374;
12386 -> 12379;
12387 -> 12386;
12387 -> 12378;
12388 -> 12378;
12389 -> 12373;
12390 -> 12374;
12390 -> 12389;
12390 -> 12373;
12391 -> 12374;
12391 -> 12373;
12392 -> 12326;
12393 -> 12392;
12393 -> 12374;
12394 -> 12374;
12395 -> 12374;
12395 -> 12394;
12396 -> 12374;
12396 -> 12394;
12397 -> 12374;
12397 -> 12394;
12398 -> 12374;
12398 -> 12394;
12399 -> 12393;
12399 -> 12394;
12400 -> 12394;
12401 -> 12326;
12402 -> 12374;
12402 -> 12401;
12402 -> 12326;
12403 -> 12371;
12403 -> 12401;
12403 -> 12326;
12404 -> 12402;
12404 -> 12403;
12404 -> 12326;
12405 -> 12404;
12405 -> 12400;
12405 -> 12326;
12406 -> 12374;
12406 -> 12326;
12407 -> 12374;
12407 -> 12326;
12408 -> 12326;
12409 -> 12374;
12409 -> 12408;
12409 -> 12326;
12410 -> 12326;
12411 -> 12374;
12411 -> 12326;
12412 -> 12410;
12412 -> 12326;
12413 -> 12410;
12413 -> 12326;
12414 -> 12326;
12415 -> 12411;
12415 -> 12414;
12416 -> 12415;
12416 -> 12326;
12417 -> 12326;
12418 -> 12374;
12418 -> 12410;
12419 -> 12418;
12419 -> 12326;
12420 -> 12326;
12420 -> 0;
12421 -> 12326;
12422 -> 12418;
12422 -> 12421;
12423 -> 12421;
12424 -> 12422;
12424 -> 12423;
12425 -> 12423;
12426 -> 12424;
12426 -> 12425;
12427 -> 12426;
12427 -> 12423;
12428 -> 12423;
12429 -> 12427;
12429 -> 12428;
12430 -> 12418;
12430 -> 12326;
12431 -> 12430;
12431 -> 12326;
12432 -> 12418;
12432 -> 12431;
12433 -> 12431;
12434 -> 12432;
12434 -> 12433;
12435 -> 12433;
12436 -> 12434;
12436 -> 12435;
12437 -> 12436;
12437 -> 12433;
12438 -> 12433;
12439 -> 12437;
12439 -> 12438;
12440 -> 12326;
12440 -> 0;
12441 -> 12326;
12442 -> 12439;
12442 -> 12441;
12442 -> 12326;
12443 -> 12326;
12444 -> 12374;
12444 -> 12443;
12444 -> 12326;
12445 -> 12326;
12446 -> 12326;
12446 -> 12445;
12447 -> 12446;
12447 -> 12418;
12447 -> 12445;
12448 -> 12447;
12448 -> 12445;
12449 -> 12448;
12449 -> 12326;
12450 -> 12326;
12451 -> 12326;
12452 -> 12374;
12452 -> 12451;
12453 -> 12451;
12453 -> 12326;
12454 -> 12374;
12454 -> 12326;
12455 -> 12326;
12456 -> 12326;
12457 -> 12455;
12457 -> 12456;
12458 -> 12455;
12458 -> 12456;
12459 -> 12457;
12459 -> 12456;
12460 -> 12456;
12461 -> 12457;
12461 -> 12460;
12462 -> 12460;
12462 -> 12456;
12463 -> 12456;
12464 -> 12456;
12465 -> 12457;
12465 -> 12464;
12466 -> 0;
12466 -> 12464;
12467 -> 12465;
12467 -> 12374;
12467 -> 0;
12467 -> 12464;
12468 -> 12467;
12468 -> 12456;
12469 -> 12456;
12470 -> 12457;
12470 -> 12469;
12471 -> 12470;
12471 -> 12374;
12471 -> 12469;
12472 -> 12471;
12472 -> 12456;
12473 -> 12472;
12473 -> 12456;
12474 -> 12456;
12475 -> 12474;
12475 -> 12326;
12476 -> 12374;
12477 -> 12374;
12478 -> 12374;
12479 -> 12374;
12479 -> 12478;
12480 -> 12478;
12480 -> 12374;
12481 -> 12374;
12482 -> 12374;
12483 -> 12482;
12483 -> 12374;
12484 -> 12483;
12484 -> 12374;
12485 -> 12483;
12485 -> 12374;
12486 -> 12485;
12486 -> 12374;
12487 -> 12486;
12487 -> 12374;
12488 -> 12486;
12488 -> 12374;
12489 -> 12374;
12489 -> 12326;
12490 -> 12374;
12490 -> 12326;
12491 -> 12374;
12491 -> 12326;
12492 -> 12491;
12492 -> 12326;
12493 -> 12491;
12493 -> 12374;
12493 -> 12326;
12494 -> 12493;
12495 -> 12494;
12495 -> 12326;
12496 -> 12326;
12497 -> 12496;
12497 -> 12326;
12498 -> 12326;
12499 -> 12418;
12499 -> 12326;
12500 -> 12498;
12500 -> 12326;
12501 -> 12326;
12502 -> 12418;
12502 -> 12501;
12503 -> 0;
12503 -> 12501;
12504 -> 12503;
12504 -> 12326;
12505 -> 12504;
12505 -> 12326;
12506 -> 12326;
12507 -> 12505;
12507 -> 12506;
12508 -> 12500;
12508 -> 12506;
12509 -> 12507;
12509 -> 0;
12509 -> 12506;
12510 -> 12507;
12510 -> 12509;
12511 -> 12326;
12512 -> 12418;
12512 -> 12511;
12513 -> 12512;
12513 -> 12418;
12513 -> 12511;
12514 -> 12513;
12514 -> 12326;
12515 -> 12326;
12516 -> 12514;
12516 -> 12326;
12517 -> 12514;
12517 -> 12516;
12518 -> 12517;
12518 -> 12326;
12519 -> 12514;
12519 -> 12326;
12520 -> 12504;
12520 -> 12510;
12520 -> 12326;
12521 -> 12520;
12521 -> 12518;
12521 -> 12326;
12522 -> 12326;
12523 -> 12418;
12523 -> 12522;
12524 -> 12522;
12525 -> 12524;
12525 -> 12522;
12526 -> 12522;
12527 -> 12525;
12527 -> 12526;
12528 -> 12523;
12528 -> 12526;
12529 -> 12526;
12530 -> 12528;
12530 -> 12529;
12531 -> 12529;
12532 -> 12531;
12532 -> 12526;
12533 -> 12526;
12534 -> 12528;
12534 -> 12533;
12535 -> 12534;
12535 -> 12418;
12535 -> 12533;
12536 -> 12535;
12536 -> 12526;
12537 -> 12526;
12538 -> 12536;
12538 -> 12537;
12539 -> 12537;
12539 -> 12526;
12540 -> 12532;
12540 -> 12539;
12540 -> 12526;
12541 -> 12526;
12542 -> 12528;
12542 -> 12541;
12543 -> 12542;
12543 -> 12541;
12544 -> 12543;
12544 -> 12418;
12544 -> 12541;
12545 -> 12544;
12545 -> 12526;
12546 -> 12526;
12547 -> 12545;
12547 -> 12546;
12548 -> 12526;
12549 -> 12547;
12549 -> 12548;
12550 -> 12548;
12550 -> 12526;
12551 -> 12526;
12552 -> 12540;
12552 -> 12550;
12552 -> 12526;
12553 -> 12526;
12554 -> 12528;
12554 -> 12553;
12555 -> 12554;
12555 -> 12526;
12556 -> 12555;
12556 -> 4027;
12556 -> 12526;
12557 -> 12552;
12557 -> 12556;
12557 -> 12526;
12558 -> 12526;
12559 -> 12526;
12560 -> 12559;
12560 -> 12326;
12561 -> 12326;
12562 -> 12326;
12563 -> 12326;
12564 -> 12374;
12564 -> 12326;
12565 -> 12326;
12566 -> 12562;
12566 -> 12565;
12566 -> 12326;
12567 -> 12326;
12568 -> 12564;
12568 -> 12567;
12568 -> 12326;
12569 -> 12563;
12569 -> 12567;
12569 -> 12326;
12570 -> 12568;
12570 -> 12569;
12570 -> 12326;
12571 -> 12326;
12572 -> 12326;
12573 -> 12564;
12573 -> 12572;
12573 -> 12326;
12574 -> 12418;
12574 -> 12326;
12575 -> 12574;
12575 -> 12326;
12576 -> 12418;
12576 -> 12326;
12577 -> 12575;
12577 -> 12326;
12578 -> 12577;
12578 -> 12418;
12579 -> 12571;
12579 -> 12574;
12579 -> 12326;
12580 -> 12326;
12581 -> 12564;
12581 -> 12326;
12582 -> 12580;
12582 -> 12581;
12582 -> 12326;
12582 -> 12574;
12583 -> 12582;
12583 -> 12580;
12584 -> 12582;
12584 -> 12580;
12585 -> 12582;
12585 -> 12580;
12586 -> 12580;
12587 -> 12584;
12587 -> 12586;
12588 -> 12586;
12589 -> 12587;
12589 -> 12588;
12590 -> 12589;
12590 -> 12586;
12591 -> 12590;
12592 -> 12591;
12592 -> 12590;
12593 -> 12592;
12593 -> 12580;
12594 -> 12582;
12594 -> 12580;
12595 -> 12582;
12595 -> 12580;
12596 -> 12594;
12596 -> 12580;
12597 -> 12596;
12597 -> 12582;
12598 -> 12582;
12598 -> 12594;
12598 -> 12593;
12598 -> 12326;
12599 -> 12573;
12599 -> 12598;
12599 -> 12326;
12600 -> 12571;
12600 -> 12573;
12600 -> 12326;
12601 -> 12600;
12602 -> 12326;
12602 -> 12598;
12602 -> 12601;
12602 -> 12600;
12603 -> 12326;
12603 -> 12598;
12603 -> 12602;
12603 -> 12600;
12604 -> 12564;
12604 -> 12598;
12604 -> 12602;
12604 -> 12600;
12605 -> 12603;
12605 -> 12598;
12605 -> 12600;
12606 -> 12604;
12606 -> 12598;
12606 -> 12600;
12607 -> 12605;
12607 -> 12606;
12607 -> 12600;
12608 -> 12600;
12609 -> 12562;
12609 -> 12608;
12610 -> 0;
12610 -> 12608;
12611 -> 12608;
12612 -> 12610;
12612 -> 12611;
12613 -> 12609;
12613 -> 12611;
12614 -> 12611;
12615 -> 12612;
12615 -> 12614;
12615 -> 12611;
12616 -> 12612;
12616 -> 12613;
12616 -> 12598;
12616 -> 12611;
12617 -> 12616;
12617 -> 12600;
12618 -> 12600;
12619 -> 12563;
12619 -> 12618;
12620 -> 0;
12620 -> 12618;
12621 -> 12618;
12622 -> 12620;
12622 -> 12621;
12623 -> 12619;
12623 -> 12621;
12624 -> 12621;
12625 -> 12622;
12625 -> 12624;
12625 -> 12621;
12626 -> 12622;
12626 -> 12623;
12626 -> 12598;
12626 -> 12621;
12627 -> 12626;
12627 -> 12600;
12628 -> 12617;
12628 -> 12627;
12628 -> 12600;
12629 -> 12600;
12630 -> 12562;
12630 -> 12629;
12631 -> 12629;
12632 -> 12630;
12632 -> 12631;
12633 -> 0;
12633 -> 12631;
12634 -> 12631;
12635 -> 12633;
12635 -> 12634;
12636 -> 12632;
12636 -> 12634;
12637 -> 12634;
12638 -> 12635;
12638 -> 12637;
12638 -> 12634;
12639 -> 12635;
12639 -> 12636;
12639 -> 12598;
12639 -> 12634;
12640 -> 12639;
12640 -> 12629;
12641 -> 12640;
12641 -> 12600;
12642 -> 12600;
12643 -> 12563;
12643 -> 12642;
12644 -> 12642;
12645 -> 12643;
12645 -> 12644;
12646 -> 0;
12646 -> 12644;
12647 -> 12644;
12648 -> 12646;
12648 -> 12647;
12649 -> 12645;
12649 -> 12647;
12650 -> 12647;
12651 -> 12648;
12651 -> 12650;
12651 -> 12647;
12652 -> 12648;
12652 -> 12649;
12652 -> 12598;
12652 -> 12647;
12653 -> 12652;
12653 -> 12642;
12654 -> 12653;
12654 -> 12600;
12655 -> 12641;
12655 -> 12654;
12655 -> 12600;
12656 -> 12628;
12656 -> 12655;
12656 -> 12600;
12657 -> 12600;
12658 -> 12562;
12658 -> 12657;
12659 -> 12657;
12660 -> 12658;
12660 -> 12598;
12660 -> 12659;
12661 -> 12657;
12662 -> 12661;
12663 -> 12658;
12663 -> 12661;
12664 -> 0;
12664 -> 12661;
12665 -> 12661;
12666 -> 12664;
12666 -> 12665;
12667 -> 12663;
12667 -> 12665;
12668 -> 12665;
12669 -> 12666;
12669 -> 12668;
12669 -> 12665;
12670 -> 12666;
12670 -> 12667;
12670 -> 12598;
12670 -> 12665;
12671 -> 12660;
12671 -> 12670;
12671 -> 12657;
12672 -> 12671;
12672 -> 12657;
12673 -> 12672;
12673 -> 12657;
12674 -> 12673;
12674 -> 12600;
12675 -> 12600;
12676 -> 12563;
12676 -> 12675;
12677 -> 12675;
12678 -> 12676;
12678 -> 12598;
12678 -> 12677;
12679 -> 12675;
12680 -> 12679;
12681 -> 12676;
12681 -> 12679;
12682 -> 0;
12682 -> 12679;
12683 -> 12679;
12684 -> 12682;
12684 -> 12683;
12685 -> 12681;
12685 -> 12683;
12686 -> 12683;
12687 -> 12684;
12687 -> 12686;
12687 -> 12683;
12688 -> 12684;
12688 -> 12685;
12688 -> 12598;
12688 -> 12683;
12689 -> 12678;
12689 -> 12688;
12689 -> 12675;
12690 -> 12689;
12690 -> 12675;
12691 -> 12690;
12691 -> 12675;
12692 -> 12691;
12692 -> 12600;
12693 -> 12674;
12693 -> 12692;
12693 -> 12600;
12694 -> 12656;
12694 -> 12693;
12694 -> 12600;
12695 -> 12600;
12696 -> 12562;
12696 -> 12695;
12697 -> 12695;
12698 -> 12695;
12698 -> 12696;
12698 -> 12598;
12699 -> 12698;
12699 -> 12600;
12700 -> 12600;
12701 -> 12563;
12701 -> 12700;
12702 -> 12700;
12703 -> 12700;
12703 -> 12701;
12703 -> 12598;
12704 -> 12703;
12704 -> 12600;
12705 -> 12699;
12705 -> 12704;
12705 -> 12600;
12706 -> 12694;
12706 -> 12705;
12706 -> 12600;
12707 -> 12394;
12707 -> 12598;
12707 -> 12326;
12708 -> 12707;
12708 -> 0;
12709 -> 12707;
12710 -> 12707;
12710 -> 12709;
12711 -> 12710;
12711 -> 12326;
12711 -> 12709;
12712 -> 12711;
12712 -> 12707;
12713 -> 12707;
12713 -> 12598;
12714 -> 0;
12714 -> 12707;
12715 -> 12707;
12716 -> 12712;
12716 -> 12715;
12717 -> 12713;
12717 -> 12715;
12718 -> 12714;
12718 -> 12715;
12719 -> 12716;
12719 -> 12715;
12720 -> 12717;
12720 -> 12715;
12721 -> 12718;
12721 -> 12715;
12722 -> 12715;
12723 -> 12720;
12723 -> 12722;
12724 -> 12721;
12724 -> 12722;
12725 -> 12716;
12725 -> 12722;
12726 -> 12724;
12726 -> 12723;
12727 -> 12726;
12727 -> 12723;
12728 -> 12725;
12728 -> 12723;
12729 -> 12707;
12730 -> 12729;
12730 -> 12707;
12731 -> 12707;
12732 -> 12707;
12732 -> 8371;
12733 -> 12707;
12734 -> 12707;
12735 -> 12326;
12735 -> 12734;
12736 -> 0;
12736 -> 12734;
12737 -> 12734;
12738 -> 12735;
12738 -> 12737;
12739 -> 12736;
12739 -> 12737;
12740 -> 12739;
12740 -> 0;
12740 -> 12737;
12741 -> 12737;
12742 -> 12738;
12742 -> 12741;
12743 -> 12742;
12743 -> 12326;
12743 -> 12741;
12744 -> 12743;
12744 -> 12737;
12745 -> 12737;
12745 -> 12598;
12746 -> 0;
12746 -> 12737;
12747 -> 12737;
12748 -> 12744;
12748 -> 12747;
12749 -> 12745;
12749 -> 12747;
12750 -> 12746;
12750 -> 12747;
12751 -> 12748;
12751 -> 12747;
12752 -> 12749;
12752 -> 12747;
12753 -> 12750;
12753 -> 12747;
12754 -> 12747;
12755 -> 12752;
12755 -> 12754;
12756 -> 12753;
12756 -> 12754;
12757 -> 12748;
12757 -> 12754;
12758 -> 12756;
12758 -> 12755;
12759 -> 12758;
12759 -> 12755;
12760 -> 12757;
12760 -> 12755;
12761 -> 12737;
12762 -> 12761;
12762 -> 12737;
12763 -> 12737;
12764 -> 12739;
12764 -> 8371;
12764 -> 12737;
12765 -> 12737;
12766 -> 12765;
12766 -> 12734;
12767 -> 12707;
12767 -> 12326;
12768 -> 12326;
12768 -> 0;
12769 -> 12326;
12770 -> 12326;
12770 -> 0;
12771 -> 12326;
12772 -> 12326;
12773 -> 12772;
12773 -> 12374;
12774 -> 12773;
12774 -> 12326;
12775 -> 12326;
12776 -> 12326;
12776 -> 12775;
12777 -> 0;
12777 -> 12775;
12778 -> 12777;
12778 -> 12326;
12779 -> 12326;
12780 -> 12778;
12780 -> 12779;
12781 -> 12780;
12781 -> 12779;
12782 -> 12779;
12783 -> 12774;
12783 -> 12781;
12783 -> 12326;
12784 -> 12326;
12785 -> 12784;
12785 -> 12783;
12785 -> 12326;
12786 -> 12329;
12786 -> 12257;
12787 -> 12257;
12788 -> 12786;
12788 -> 12257;
12789 -> 12787;
12789 -> 12257;
12790 -> 12787;
12790 -> 12257;
12791 -> 12738;
12791 -> 12297;
12792 -> 12320;
12792 -> 12257;
12793 -> 12320;
12793 -> 12257;
12794 -> 12257;
12794 -> 12738;
12795 -> 12257;
12796 -> 12257;
12797 -> 12796;
12797 -> 12738;
12797 -> 12257;
12798 -> 12797;
12799 -> 12797;
12800 -> 12795;
12800 -> 12799;
12801 -> 12798;
12801 -> 12799;
12802 -> 12801;
12802 -> 12799;
12803 -> 12800;
12803 -> 12802;
12804 -> 12795;
12804 -> 12798;
12804 -> 12797;
12805 -> 12797;
12805 -> 12804;
12806 -> 12805;
12806 -> 12799;
12807 -> 12806;
12807 -> 12802;
12808 -> 12797;
12808 -> 12805;
12809 -> 12805;
12810 -> 12805;
12810 -> 12809;
12811 -> 0;
12811 -> 12809;
12812 -> 12811;
12812 -> 12805;
12813 -> 12805;
12814 -> 12808;
12814 -> 12813;
12815 -> 0;
12815 -> 12813;
12816 -> 12815;
12816 -> 12805;
12817 -> 12812;
12817 -> 12816;
12817 -> 12805;
12818 -> 12808;
12818 -> 12805;
12819 -> 12818;
12819 -> 12799;
12820 -> 12819;
12820 -> 12802;
12821 -> 12818;
12822 -> 12818;
12822 -> 12821;
12823 -> 0;
12823 -> 12821;
12824 -> 12823;
12824 -> 12818;
12825 -> 12818;
12826 -> 12818;
12826 -> 12825;
12827 -> 0;
12827 -> 12825;
12828 -> 12827;
12828 -> 12818;
12829 -> 12824;
12829 -> 12828;
12829 -> 12818;
12830 -> 12818;
12830 -> 12825;
12831 -> 0;
12831 -> 12825;
12832 -> 12831;
12832 -> 12818;
12833 -> 12824;
12833 -> 12832;
12833 -> 12818;
12834 -> 12257;
12835 -> 12257;
12835 -> 12834;
12836 -> 12834;
12837 -> 12836;
12837 -> 12834;
12838 -> 12834;
12839 -> 12837;
12839 -> 12838;
12840 -> 12835;
12840 -> 12838;
12841 -> 12838;
12842 -> 12840;
12842 -> 12841;
12843 -> 12841;
12844 -> 12843;
12844 -> 12838;
12845 -> 12838;
12846 -> 12840;
12846 -> 12845;
12847 -> 12846;
12847 -> 12738;
12847 -> 12845;
12848 -> 12847;
12848 -> 12838;
12849 -> 12838;
12850 -> 12848;
12850 -> 12849;
12851 -> 12849;
12851 -> 12838;
12852 -> 12844;
12852 -> 12851;
12852 -> 12838;
12853 -> 12838;
12854 -> 12840;
12854 -> 12853;
12855 -> 12854;
12855 -> 12853;
12856 -> 12855;
12856 -> 12738;
12856 -> 12853;
12857 -> 12856;
12857 -> 12838;
12858 -> 12838;
12859 -> 12857;
12859 -> 12858;
12860 -> 12838;
12861 -> 12859;
12861 -> 12860;
12862 -> 12860;
12862 -> 12838;
12863 -> 12838;
12864 -> 12852;
12864 -> 12862;
12864 -> 12838;
12865 -> 12838;
12866 -> 12838;
12867 -> 12866;
12867 -> 12257;
12868 -> 12738;
12869 -> 12738;
12870 -> 12738;
12871 -> 12869;
12871 -> 12870;
12872 -> 12871;
12872 -> 12738;
12873 -> 12738;
12874 -> 12257;
12875 -> 12257;
12876 -> 12295;
12876 -> 12257;
12877 -> 12257;
12878 -> 0;
12878 -> 12257;
12879 -> 12258;
12879 -> 0;
12879 -> 12257;
12880 -> 12257;
12881 -> 12257;
12882 -> 0;
12882 -> 12258;
12883 -> 12879;
12883 -> 12258;
12884 -> 12738;
12885 -> 12884;
12885 -> 12738;
12886 -> 12258;
12886 -> 12738;
12887 -> 12738;
12888 -> 12738;
12888 -> 12887;
12889 -> 0;
12889 -> 12887;
12890 -> 12889;
12890 -> 12738;
12891 -> 12738;
12892 -> 12738;
12893 -> 12892;
12893 -> 12879;
12893 -> 12738;
12894 -> 12890;
12894 -> 12893;
12894 -> 12738;
12895 -> 12738;
12896 -> 12738;
12896 -> 12895;
12897 -> 12895;
12898 -> 12896;
12898 -> 12897;
12899 -> 12898;
12899 -> 12895;
12900 -> 0;
12900 -> 12899;
12901 -> 12900;
12901 -> 12738;
12902 -> 12894;
12902 -> 12901;
12902 -> 12738;
12903 -> 12738;
12904 -> 12738;
12904 -> 12903;
12905 -> 12903;
12905 -> 12738;
12906 -> 12738;
12907 -> 12738;
12908 -> 12738;
12909 -> 12908;
12909 -> 12738;
12910 -> 12909;
12911 -> 12909;
12911 -> 12910;
12912 -> 12910;
12913 -> 12911;
12913 -> 12912;
12914 -> 12912;
12915 -> 12913;
12915 -> 12738;
12915 -> 12914;
12915 -> 12912;
12916 -> 12910;
12917 -> 12911;
12917 -> 12738;
12917 -> 12910;
12918 -> 12917;
12918 -> 12909;
12919 -> 12909;
12920 -> 12738;
12921 -> 12738;
12922 -> 12738;
12923 -> 12922;
12923 -> 12738;
12924 -> 12738;
12925 -> 0;
12925 -> 12738;
12926 -> 12738;
12927 -> 12738;
12928 -> 12926;
12928 -> 12927;
12929 -> 12926;
12929 -> 12927;
12930 -> 12928;
12930 -> 12927;
12931 -> 12929;
12931 -> 12927;
12932 -> 12927;
12933 -> 12927;
12934 -> 12930;
12934 -> 12933;
12935 -> 12934;
12935 -> 12927;
12936 -> 12927;
12937 -> 12738;
12938 -> 12928;
12938 -> 12937;
12938 -> 12738;
12939 -> 12738;
12940 -> 12738;
12940 -> 12939;
12941 -> 12738;
12941 -> 12939;
12942 -> 0;
12942 -> 12939;
12943 -> 12939;
12944 -> 12942;
12944 -> 12943;
12945 -> 12941;
12945 -> 12943;
12946 -> 12943;
12947 -> 12944;
12947 -> 12946;
12947 -> 12943;
12948 -> 12944;
12948 -> 12945;
12948 -> 12738;
12948 -> 12943;
12949 -> 12948;
12949 -> 12738;
12950 -> 12924;
12950 -> 12738;
12951 -> 12949;
12951 -> 12738;
12952 -> 12738;
12953 -> 12950;
12953 -> 12738;
12954 -> 12738;
12955 -> 12738;
12955 -> 0;
12956 -> 12738;
12957 -> 12738;
12957 -> 12956;
12958 -> 12956;
12959 -> 12957;
12959 -> 12958;
12960 -> 12958;
12961 -> 12959;
12961 -> 12960;
12962 -> 12961;
12962 -> 12958;
12963 -> 12958;
12964 -> 12962;
12964 -> 12963;
12965 -> 12738;
12966 -> 12965;
12966 -> 12738;
12967 -> 12738;
12967 -> 12966;
12968 -> 12966;
12969 -> 12967;
12969 -> 12968;
12970 -> 12968;
12971 -> 12969;
12971 -> 12970;
12972 -> 12971;
12972 -> 12968;
12973 -> 12968;
12974 -> 12972;
12974 -> 12973;
12975 -> 12738;
12975 -> 0;
12976 -> 12738;
12977 -> 12974;
12977 -> 12976;
12977 -> 12738;
12978 -> 12738;
12979 -> 12953;
12979 -> 12738;
12980 -> 12738;
12981 -> 12738;
12982 -> 12738;
12983 -> 12738;
12984 -> 12738;
12985 -> 12738;
12986 -> 12738;
12987 -> 12738;
12987 -> 12986;
12988 -> 12987;
12988 -> 12738;
12988 -> 12986;
12989 -> 12988;
12989 -> 12986;
12990 -> 12989;
12990 -> 12738;
12991 -> 12738;
12992 -> 12738;
12993 -> 12992;
12994 -> 12993;
12994 -> 12992;
12995 -> 12992;
12996 -> 12993;
12997 -> 12993;
12997 -> 12996;
12998 -> 12996;
12998 -> 12993;
12999 -> 12993;
13000 -> 12993;
13001 -> 12993;
13001 -> 12738;
13002 -> 13001;
13002 -> 12738;
13003 -> 12738;
13004 -> 13003;
13004 -> 12738;
13005 -> 12738;
13006 -> 12738;
13006 -> 13005;
13007 -> 13005;
13008 -> 13006;
13008 -> 12738;
13008 -> 13007;
13009 -> 13008;
13009 -> 12738;
13009 -> 9779;
13009 -> 13007;
13010 -> 13007;
13011 -> 13009;
13011 -> 13005;
13012 -> 13011;
13012 -> 12738;
13013 -> 12738;
13014 -> 12738;
13014 -> 13013;
13015 -> 0;
13015 -> 13013;
13016 -> 13015;
13016 -> 12738;
13017 -> 12738;
13018 -> 13016;
13018 -> 13017;
13019 -> 13018;
13019 -> 13017;
13020 -> 13017;
13021 -> 12952;
13021 -> 12738;
13022 -> 13021;
13023 -> 13022;
13023 -> 13021;
13024 -> 13023;
13024 -> 13019;
13024 -> 13021;
13025 -> 12991;
13025 -> 13024;
13025 -> 13021;
13026 -> 12921;
13026 -> 13025;
13026 -> 12738;
13027 -> 12924;
13027 -> 12738;
13028 -> 12925;
13028 -> 12924;
13028 -> 12738;
13029 -> 12993;
13029 -> 12924;
13029 -> 13028;
13029 -> 12738;
13029 -> 0;
13030 -> 13029;
13030 -> 12738;
13031 -> 13029;
13032 -> 13029;
13032 -> 8371;
13032 -> 12738;
13033 -> 13029;
13033 -> 12738;
13034 -> 12738;
13035 -> 13033;
13035 -> 13034;
13036 -> 13033;
13036 -> 13034;
13037 -> 13035;
13037 -> 13036;
13037 -> 13034;
13038 -> 13034;
13039 -> 13029;
13039 -> 12738;
13040 -> 13039;
13040 -> 0;
13040 -> 12738;
13041 -> 12738;
13042 -> 13041;
13042 -> 13029;
13043 -> 13042;
13043 -> 12738;
13044 -> 13039;
13044 -> 12882;
13044 -> 12738;
13045 -> 13043;
13045 -> 13044;
13045 -> 12738;
13046 -> 12258;
13046 -> 0;
13046 -> 12738;
13047 -> 12738;
13048 -> 12738;
13049 -> 12738;
13049 -> 13048;
13050 -> 13048;
13051 -> 13050;
13052 -> 13049;
13052 -> 13050;
13053 -> 0;
13053 -> 13050;
13054 -> 13050;
13055 -> 13053;
13055 -> 13054;
13056 -> 13052;
13056 -> 13054;
13057 -> 13054;
13058 -> 13055;
13058 -> 13057;
13058 -> 13054;
13059 -> 13055;
13059 -> 13056;
13059 -> 13029;
13059 -> 13054;
13060 -> 13059;
13060 -> 13048;
13061 -> 13060;
13061 -> 13048;
13062 -> 13061;
13062 -> 13048;
13063 -> 13062;
13063 -> 13048;
13064 -> 13063;
13064 -> 12738;
13065 -> 12738;
13066 -> 12738;
13066 -> 13065;
13067 -> 13065;
13068 -> 13066;
13068 -> 13029;
13068 -> 13067;
13069 -> 13065;
13070 -> 13069;
13071 -> 13066;
13071 -> 13069;
13072 -> 0;
13072 -> 13069;
13073 -> 13069;
13074 -> 13072;
13074 -> 13073;
13075 -> 13071;
13075 -> 13073;
13076 -> 13073;
13077 -> 13074;
13077 -> 13076;
13077 -> 13073;
13078 -> 13074;
13078 -> 13075;
13078 -> 13029;
13078 -> 13073;
13079 -> 13068;
13079 -> 13078;
13079 -> 13065;
13080 -> 13079;
13080 -> 13065;
13081 -> 13080;
13081 -> 13065;
13082 -> 13081;
13082 -> 12738;
13083 -> 13064;
13083 -> 13082;
13083 -> 12738;
13084 -> 12738;
13085 -> 12738;
13085 -> 13084;
13086 -> 0;
13086 -> 13084;
13087 -> 13084;
13088 -> 13086;
13088 -> 13087;
13089 -> 13085;
13089 -> 13087;
13090 -> 13087;
13091 -> 13088;
13091 -> 13090;
13091 -> 13087;
13092 -> 13088;
13092 -> 13089;
13092 -> 13029;
13092 -> 13087;
13093 -> 13092;
13093 -> 12738;
13094 -> 13083;
13094 -> 13093;
13094 -> 12738;
13095 -> 13045;
13095 -> 13094;
13095 -> 12738;
13096 -> 13029;
13096 -> 12738;
13097 -> 13029;
13097 -> 12738;
13098 -> 13029;
13098 -> 13003;
13099 -> 13029;
13099 -> 12738;
13100 -> 13098;
13100 -> 12738;
13101 -> 13029;
13101 -> 12738;
13102 -> 13029;
13102 -> 12738;
13103 -> 13102;
13103 -> 12738;
13104 -> 13101;
13104 -> 12738;
13105 -> 12881;
13105 -> 12738;
13106 -> 13098;
13107 -> 13106;
13107 -> 13098;
13108 -> 13107;
13108 -> 13098;
13109 -> 13098;
13110 -> 13109;
13111 -> 13109;
13112 -> 13110;
13112 -> 13111;
13113 -> 13112;
13113 -> 13111;
13114 -> 13113;
13114 -> 13109;
13115 -> 13114;
13115 -> 13098;
13116 -> 13098;
13117 -> 13098;
13118 -> 13098;
13119 -> 13117;
13119 -> 13118;
13120 -> 13117;
13120 -> 13118;
13121 -> 13119;
13121 -> 13120;
13121 -> 13118;
13122 -> 13118;
13123 -> 13098;
13124 -> 13098;
13124 -> 13123;
13125 -> 13124;
13125 -> 13098;
13125 -> 8443;
13125 -> 13123;
13126 -> 13123;
13127 -> 13125;
13127 -> 13126;
13127 -> 13123;
13128 -> 13127;
13128 -> 13098;
13129 -> 13108;
13129 -> 13098;
13130 -> 13128;
13130 -> 13098;
13131 -> 13098;
13132 -> 13098;
13133 -> 13129;
13133 -> 13098;
13134 -> 13131;
13134 -> 13098;
13135 -> 13098;
13136 -> 13135;
13136 -> 13098;
13137 -> 13098;
13138 -> 13136;
13138 -> 13137;
13138 -> 13098;
13139 -> 13133;
13139 -> 13098;
13140 -> 13136;
13140 -> 13098;
13141 -> 13098;
13142 -> 13139;
13142 -> 13141;
13143 -> 13140;
13143 -> 13141;
13144 -> 13134;
13144 -> 13141;
13145 -> 13098;
13146 -> 13098;
13147 -> 13142;
13147 -> 13146;
13148 -> 13145;
13148 -> 13146;
13149 -> 13130;
13149 -> 13146;
13150 -> 13131;
13150 -> 13146;
13151 -> 13128;
13151 -> 13146;
13152 -> 13146;
13153 -> 13148;
13153 -> 13146;
13154 -> 13146;
13155 -> 13143;
13155 -> 13154;
13155 -> 13098;
13156 -> 13098;
13157 -> 13098;
13157 -> 13156;
13158 -> 13156;
13159 -> 13157;
13159 -> 13158;
13160 -> 13156;
13161 -> 13159;
13161 -> 13098;
13161 -> 13160;
13162 -> 0;
13162 -> 13160;
13163 -> 11249;
13163 -> 13098;
13164 -> 13098;
13165 -> 13147;
13165 -> 13164;
13166 -> 13162;
13166 -> 13164;
13167 -> 13163;
13167 -> 13164;
13168 -> 13098;
13168 -> 13164;
13169 -> 13128;
13169 -> 13164;
13170 -> 13164;
13171 -> 13166;
13171 -> 13164;
13172 -> 13164;
13173 -> 13155;
13173 -> 13172;
13173 -> 13098;
13174 -> 13165;
13174 -> 13098;
13175 -> 13098;
13176 -> 13098;
13177 -> 13173;
13177 -> 13176;
13177 -> 13098;
13178 -> 13098;
13179 -> 13178;
13180 -> 13178;
13180 -> 13179;
13181 -> 13179;
13181 -> 13178;
13182 -> 13178;
13182 -> 13098;
13183 -> 13098;
13184 -> 13182;
13184 -> 13183;
13185 -> 13183;
13186 -> 13184;
13186 -> 13185;
13187 -> 13185;
13188 -> 13186;
13188 -> 13187;
13189 -> 13187;
13190 -> 13188;
13190 -> 13098;
13190 -> 13189;
13190 -> 13187;
13191 -> 13185;
13192 -> 13186;
13192 -> 13183;
13193 -> 13183;
13194 -> 13098;
13195 -> 13098;
13196 -> 13195;
13196 -> 13098;
13197 -> 13174;
13197 -> 13098;
13198 -> 13098;
13199 -> 13197;
13199 -> 13198;
13200 -> 13098;
13200 -> 13198;
13201 -> 13200;
13201 -> 13098;
13201 -> 13198;
13202 -> 13201;
13202 -> 13098;
13202 -> 13198;
13203 -> 13201;
13203 -> 13202;
13204 -> 13203;
13204 -> 13098;
13205 -> 13098;
13206 -> 13199;
13206 -> 13205;
13206 -> 13098;
13207 -> 13205;
13207 -> 13098;
13208 -> 13178;
13209 -> 13178;
13209 -> 13098;
13210 -> 0;
13210 -> 13098;
13211 -> 13098;
13212 -> 13098;
13213 -> 13098;
13214 -> 13098;
13214 -> 13178;
13214 -> 13213;
13215 -> 13214;
13215 -> 13178;
13215 -> 8403;
13215 -> 13213;
13216 -> 13213;
13217 -> 13215;
13217 -> 13216;
13217 -> 13213;
13218 -> 13217;
13218 -> 13098;
13219 -> 13098;
13220 -> 13098;
13220 -> 13178;
13220 -> 13219;
13221 -> 13220;
13221 -> 13178;
13221 -> 8411;
13221 -> 13219;
13222 -> 13219;
13223 -> 13221;
13223 -> 13222;
13223 -> 13219;
13224 -> 13223;
13224 -> 13098;
13225 -> 13098;
13226 -> 13098;
13226 -> 13178;
13226 -> 13225;
13227 -> 13226;
13227 -> 13178;
13227 -> 8415;
13227 -> 13225;
13228 -> 13225;
13229 -> 13227;
13229 -> 13228;
13229 -> 13225;
13230 -> 13229;
13230 -> 13098;
13231 -> 13098;
13232 -> 13098;
13232 -> 13178;
13232 -> 13231;
13233 -> 13232;
13233 -> 13178;
13233 -> 8439;
13233 -> 13231;
13234 -> 13231;
13235 -> 13233;
13235 -> 13234;
13235 -> 13231;
13236 -> 13235;
13236 -> 13098;
13237 -> 13098;
13238 -> 13098;
13238 -> 13178;
13238 -> 13237;
13239 -> 13238;
13239 -> 13178;
13239 -> 8395;
13239 -> 13237;
13240 -> 13237;
13241 -> 13239;
13241 -> 13240;
13241 -> 13237;
13242 -> 13241;
13242 -> 13098;
13243 -> 13098;
13244 -> 13178;
13244 -> 13098;
13245 -> 13244;
13245 -> 13098;
13246 -> 13206;
13246 -> 13245;
13246 -> 13098;
13247 -> 13199;
13247 -> 13098;
13248 -> 13247;
13248 -> 13098;
13249 -> 13098;
13250 -> 13098;
13250 -> 13178;
13250 -> 13249;
13251 -> 13250;
13251 -> 13098;
13252 -> 13098;
13253 -> 13248;
13253 -> 13252;
13253 -> 13098;
13254 -> 13098;
13255 -> 13248;
13255 -> 13098;
13256 -> 13255;
13256 -> 13098;
13257 -> 13098;
13258 -> 13256;
13258 -> 13257;
13258 -> 13098;
13259 -> 13178;
13260 -> 13178;
13261 -> 13260;
13261 -> 13178;
13262 -> 13178;
13263 -> 13178;
13264 -> 13178;
13265 -> 13178;
13266 -> 13178;
13267 -> 13266;
13267 -> 13178;
13268 -> 13266;
13268 -> 13178;
13269 -> 13268;
13270 -> 13269;
13270 -> 13178;
13271 -> 13178;
13272 -> 13271;
13272 -> 13178;
13273 -> 13178;
13274 -> 13178;
13275 -> 13273;
13275 -> 13178;
13276 -> 13178;
13277 -> 13178;
13277 -> 13276;
13278 -> 0;
13278 -> 13276;
13279 -> 13278;
13279 -> 13178;
13280 -> 13279;
13280 -> 13178;
13281 -> 13178;
13282 -> 13280;
13282 -> 13281;
13283 -> 13275;
13283 -> 13281;
13284 -> 13282;
13284 -> 0;
13284 -> 13281;
13285 -> 13282;
13285 -> 13284;
13286 -> 13178;
13287 -> 13178;
13287 -> 13286;
13288 -> 13287;
13288 -> 13178;
13288 -> 13286;
13289 -> 13288;
13289 -> 13178;
13290 -> 13178;
13291 -> 13289;
13291 -> 13178;
13292 -> 13289;
13292 -> 13291;
13293 -> 13292;
13293 -> 13178;
13294 -> 13289;
13294 -> 13178;
13295 -> 13279;
13295 -> 13285;
13295 -> 13178;
13296 -> 13295;
13296 -> 13293;
13296 -> 13178;
13297 -> 13178;
13298 -> 13178;
13298 -> 13297;
13299 -> 13297;
13300 -> 13299;
13300 -> 13297;
13301 -> 13297;
13302 -> 13300;
13302 -> 13301;
13303 -> 13298;
13303 -> 13301;
13304 -> 13301;
13305 -> 13303;
13305 -> 13304;
13306 -> 13304;
13307 -> 13306;
13307 -> 13301;
13308 -> 13301;
13309 -> 13303;
13309 -> 13308;
13310 -> 13309;
13310 -> 13178;
13310 -> 13308;
13311 -> 13310;
13311 -> 13301;
13312 -> 13301;
13313 -> 13311;
13313 -> 13312;
13314 -> 13312;
13314 -> 13301;
13315 -> 13307;
13315 -> 13314;
13315 -> 13301;
13316 -> 13301;
13317 -> 13303;
13317 -> 13316;
13318 -> 13317;
13318 -> 13316;
13319 -> 13318;
13319 -> 13178;
13319 -> 13316;
13320 -> 13319;
13320 -> 13301;
13321 -> 13301;
13322 -> 13320;
13322 -> 13321;
13323 -> 13301;
13324 -> 13322;
13324 -> 13323;
13325 -> 13323;
13325 -> 13301;
13326 -> 13301;
13327 -> 13315;
13327 -> 13325;
13327 -> 13301;
13328 -> 13301;
13329 -> 13303;
13329 -> 13328;
13330 -> 13329;
13330 -> 13301;
13331 -> 13330;
13331 -> 4027;
13331 -> 13301;
13332 -> 13327;
13332 -> 13331;
13332 -> 13301;
13333 -> 13301;
13334 -> 13301;
13335 -> 13334;
13335 -> 13178;
13336 -> 13178;
13337 -> 13178;
13337 -> 0;
13338 -> 13178;
13339 -> 13178;
13339 -> 13338;
13340 -> 13338;
13341 -> 13339;
13341 -> 13340;
13342 -> 13340;
13343 -> 13341;
13343 -> 13342;
13344 -> 13343;
13344 -> 13340;
13345 -> 13340;
13346 -> 13344;
13346 -> 13345;
13347 -> 13178;
13348 -> 13347;
13348 -> 13178;
13349 -> 13178;
13349 -> 13348;
13350 -> 13348;
13351 -> 13349;
13351 -> 13350;
13352 -> 13350;
13353 -> 13351;
13353 -> 13352;
13354 -> 13353;
13354 -> 13350;
13355 -> 13350;
13356 -> 13354;
13356 -> 13355;
13357 -> 13178;
13357 -> 0;
13358 -> 13178;
13359 -> 13356;
13359 -> 13358;
13359 -> 13178;
13360 -> 13178;
13361 -> 13178;
13362 -> 13178;
13362 -> 13361;
13363 -> 13362;
13363 -> 13178;
13363 -> 13361;
13364 -> 13363;
13364 -> 13361;
13365 -> 13364;
13365 -> 13178;
13366 -> 13178;
13367 -> 13178;
13368 -> 13178;
13369 -> 13178;
13370 -> 13368;
13370 -> 13369;
13371 -> 13368;
13371 -> 13369;
13372 -> 13370;
13372 -> 13369;
13373 -> 13369;
13374 -> 13370;
13374 -> 13373;
13375 -> 13373;
13375 -> 13369;
13376 -> 13369;
13377 -> 13369;
13378 -> 13370;
13378 -> 13377;
13379 -> 0;
13379 -> 13377;
13380 -> 13378;
13380 -> 13369;
13381 -> 13369;
13382 -> 13370;
13382 -> 13381;
13383 -> 13382;
13383 -> 13178;
13383 -> 13381;
13384 -> 13383;
13384 -> 13369;
13385 -> 13384;
13385 -> 13369;
13386 -> 13369;
13387 -> 13386;
13387 -> 13178;
13388 -> 13178;
13389 -> 13178;
13390 -> 13178;
13391 -> 13178;
13392 -> 13178;
13393 -> 13178;
13394 -> 13178;
13395 -> 13178;
13395 -> 13394;
13396 -> 13394;
13397 -> 13396;
13397 -> 13178;
13398 -> 13178;
13399 -> 13398;
13400 -> 13178;
13401 -> 13397;
13401 -> 13400;
13401 -> 13178;
13402 -> 13178;
13403 -> 13178;
13404 -> 13178;
13405 -> 13178;
13406 -> 13404;
13406 -> 13405;
13407 -> 13405;
13408 -> 13406;
13408 -> 13407;
13408 -> 13405;
13409 -> 13406;
13409 -> 13405;
13410 -> 13405;
13410 -> 13178;
13411 -> 13178;
13412 -> 13178;
13413 -> 13178;
13414 -> 13412;
13414 -> 13413;
13415 -> 13413;
13416 -> 13414;
13416 -> 13415;
13417 -> 13415;
13418 -> 13416;
13418 -> 13417;
13419 -> 13417;
13420 -> 13418;
13420 -> 13178;
13420 -> 13419;
13420 -> 13417;
13421 -> 13415;
13422 -> 13416;
13422 -> 13413;
13423 -> 13413;
13424 -> 13178;
13425 -> 13178;
13426 -> 13425;
13426 -> 13178;
13427 -> 13426;
13428 -> 13426;
13429 -> 13427;
13429 -> 13428;
13430 -> 13428;
13431 -> 13428;
13431 -> 13426;
13432 -> 13426;
13433 -> 13431;
13433 -> 13432;
13434 -> 13433;
13434 -> 13426;
13435 -> 13426;
13436 -> 13431;
13436 -> 13435;
13437 -> 13435;
13438 -> 13436;
13438 -> 13437;
13439 -> 13438;
13439 -> 13178;
13439 -> 13437;
13440 -> 13439;
13440 -> 13435;
13441 -> 13435;
13442 -> 13440;
13442 -> 13441;
13442 -> 13435;
13443 -> 13442;
13443 -> 13435;
13444 -> 13443;
13445 -> 13440;
13445 -> 13444;
13446 -> 13444;
13447 -> 13445;
13447 -> 13446;
13448 -> 13447;
13448 -> 13444;
13449 -> 13444;
13450 -> 13448;
13450 -> 13449;
13451 -> 13450;
13451 -> 13426;
13452 -> 13426;
13453 -> 13451;
13453 -> 13452;
13454 -> 13452;
13455 -> 13454;
13455 -> 13426;
13456 -> 13426;
13457 -> 13434;
13457 -> 13455;
13457 -> 13426;
13458 -> 13178;
13458 -> 13098;
13459 -> 13256;
13459 -> 13458;
13459 -> 13098;
13460 -> 13459;
13460 -> 13098;
13461 -> 13098;
13462 -> 13460;
13462 -> 13461;
13462 -> 13098;
13463 -> 13098;
13463 -> 12256;
13464 -> 12256;
13465 -> 13460;
13465 -> 13464;
13465 -> 12256;
13466 -> 13463;
13466 -> 12256;
13467 -> 2777;
13467 -> 12251;
13468 -> 0;
13468 -> 12251;
13469 -> 2778;
13469 -> 12251;
13470 -> 12251;
13471 -> 12251;
13472 -> 13467;
13472 -> 13471;
13473 -> 13468;
13473 -> 13471;
13474 -> 13469;
13474 -> 13471;
13475 -> 13468;
13475 -> 13471;
13476 -> 13470;
13476 -> 13471;
13477 -> 13471;
13478 -> 13475;
13478 -> 13477;
13478 -> 13471;
13479 -> 13476;
13479 -> 13477;
13479 -> 13471;
13480 -> 13478;
13480 -> 13479;
13480 -> 13471;
13481 -> 13473;
13481 -> 13471;
13482 -> 13474;
13482 -> 13471;
13483 -> 13475;
13483 -> 13471;
13484 -> 13476;
13484 -> 13471;
13485 -> 13481;
13485 -> 13471;
13486 -> 13471;
13487 -> 13484;
13487 -> 13486;
13487 -> 13471;
13488 -> 13483;
13488 -> 13486;
13488 -> 13471;
13489 -> 13487;
13489 -> 13488;
13489 -> 13471;
13490 -> 13471;
13491 -> 13490;
13491 -> 13471;
13492 -> 13485;
13492 -> 13471;
13493 -> 13471;
13494 -> 13473;
13494 -> 13493;
13494 -> 13471;
13495 -> 13473;
13495 -> 0;
13495 -> 13471;
13496 -> 13472;
13496 -> 13473;
13496 -> 13178;
13496 -> 13471;
13497 -> 13496;
13498 -> 13496;
13499 -> 13498;
13499 -> 13496;
13500 -> 0;
13500 -> 13496;
13501 -> 13496;
13502 -> 13499;
13502 -> 13501;
13503 -> 13500;
13503 -> 13501;
13504 -> 13502;
13504 -> 13503;
13504 -> 13501;
13505 -> 13496;
13506 -> 13496;
13507 -> 13496;
13508 -> 13506;
13508 -> 13507;
13508 -> 13496;
13509 -> 13506;
13509 -> 13496;
13510 -> 13496;
13511 -> 13496;
13512 -> 13496;
13513 -> 13511;
13513 -> 13496;
13514 -> 13496;
13515 -> 0;
13515 -> 13496;
13516 -> 13496;
13516 -> 0;
13517 -> 13496;
13518 -> 13496;
13519 -> 0;
13519 -> 13496;
13520 -> 13496;
13521 -> 13520;
13522 -> 13520;
13523 -> 13521;
13523 -> 13522;
13524 -> 13523;
13524 -> 13520;
13525 -> 13520;
13526 -> 13520;
13526 -> 13496;
13527 -> 13496;
13528 -> 13496;
13529 -> 13496;
13529 -> 13528;
13530 -> 0;
13530 -> 13528;
13531 -> 13530;
13531 -> 13496;
13532 -> 13531;
13532 -> 13519;
13532 -> 13496;
13533 -> 13496;
13534 -> 13496;
13535 -> 13533;
13535 -> 13496;
13535 -> 13534;
13536 -> 13496;
13537 -> 13533;
13537 -> 13496;
13537 -> 13536;
13538 -> 13536;
13539 -> 13537;
13539 -> 13496;
13540 -> 13539;
13540 -> 13496;
13541 -> 13540;
13541 -> 13516;
13541 -> 13496;
13542 -> 13532;
13542 -> 13541;
13542 -> 13496;
13543 -> 13496;
13544 -> 13496;
13544 -> 13543;
13545 -> 13544;
13545 -> 13496;
13545 -> 7647;
13545 -> 13543;
13546 -> 13545;
13547 -> 13545;
13548 -> 13544;
13548 -> 13547;
13549 -> 13547;
13550 -> 13548;
13550 -> 13496;
13550 -> 13549;
13550 -> 13547;
13551 -> 13547;
13552 -> 13548;
13552 -> 13496;
13552 -> 13551;
13553 -> 13551;
13554 -> 13552;
13554 -> 13496;
13554 -> 13553;
13555 -> 13551;
13556 -> 13555;
13557 -> 13552;
13557 -> 13555;
13558 -> 0;
13558 -> 13555;
13559 -> 13555;
13560 -> 13558;
13560 -> 13559;
13561 -> 13557;
13561 -> 13559;
13562 -> 13559;
13563 -> 13560;
13563 -> 13562;
13563 -> 13559;
13564 -> 13560;
13564 -> 13561;
13564 -> 13496;
13564 -> 13559;
13565 -> 13554;
13565 -> 13564;
13565 -> 13551;
13566 -> 13565;
13566 -> 13551;
13567 -> 13566;
13567 -> 13551;
13568 -> 13567;
13568 -> 13547;
13569 -> 13547;
13570 -> 13548;
13570 -> 13496;
13570 -> 13569;
13571 -> 13569;
13572 -> 13570;
13572 -> 13496;
13572 -> 13571;
13573 -> 13569;
13574 -> 13573;
13575 -> 13570;
13575 -> 13573;
13576 -> 0;
13576 -> 13573;
13577 -> 13573;
13578 -> 13576;
13578 -> 13577;
13579 -> 13575;
13579 -> 13577;
13580 -> 13577;
13581 -> 13578;
13581 -> 13580;
13581 -> 13577;
13582 -> 13578;
13582 -> 13579;
13582 -> 13496;
13582 -> 13577;
13583 -> 13572;
13583 -> 13582;
13583 -> 13569;
13584 -> 13583;
13584 -> 13569;
13585 -> 13584;
13585 -> 13569;
13586 -> 13585;
13586 -> 13547;
13587 -> 13568;
13587 -> 13586;
13587 -> 13547;
13588 -> 13587;
13588 -> 13545;
13589 -> 13588;
13590 -> 13544;
13590 -> 13589;
13591 -> 13590;
13591 -> 13496;
13591 -> 13589;
13592 -> 13591;
13592 -> 13588;
13593 -> 13588;
13594 -> 13544;
13594 -> 13593;
13595 -> 13594;
13595 -> 13496;
13595 -> 13593;
13596 -> 13595;
13596 -> 13588;
13597 -> 13588;
13598 -> 13592;
13598 -> 13597;
13599 -> 13596;
13599 -> 13597;
13600 -> 13597;
13601 -> 13598;
13601 -> 13600;
13601 -> 13597;
13602 -> 13601;
13603 -> 13599;
13603 -> 13602;
13603 -> 13601;
13604 -> 13597;
13605 -> 13598;
13605 -> 13604;
13606 -> 13604;
13607 -> 13605;
13607 -> 13606;
13608 -> 13607;
13608 -> 13604;
13609 -> 0;
13609 -> 13608;
13610 -> 13609;
13610 -> 13597;
13611 -> 13597;
13612 -> 13599;
13612 -> 13611;
13613 -> 13611;
13614 -> 13612;
13614 -> 13613;
13615 -> 13614;
13615 -> 13611;
13616 -> 0;
13616 -> 13615;
13617 -> 13616;
13617 -> 13597;
13618 -> 13597;
13619 -> 13610;
13619 -> 13618;
13620 -> 13617;
13620 -> 13618;
13621 -> 13619;
13621 -> 13620;
13621 -> 13618;
13622 -> 13621;
13622 -> 13618;
13623 -> 13622;
13623 -> 13620;
13623 -> 13618;
13624 -> 13623;
13624 -> 13618;
13625 -> 13622;
13625 -> 0;
13625 -> 13618;
13626 -> 13625;
13626 -> 13618;
13627 -> 13624;
13627 -> 13626;
13628 -> 13544;
13628 -> 13496;
13628 -> 13545;
13629 -> 13627;
13629 -> 13545;
13630 -> 7647;
13630 -> 13545;
13631 -> 13544;
13631 -> 13496;
13631 -> 13629;
13631 -> 13543;
13632 -> 13631;
13632 -> 13496;
13633 -> 13542;
13633 -> 13632;
13633 -> 13496;
13634 -> 13496;
13634 -> 13519;
13635 -> 13496;
13635 -> 0;
13635 -> 13519;
13636 -> 13519;
13637 -> 13519;
13638 -> 13634;
13638 -> 13637;
13639 -> 13637;
13640 -> 13638;
13640 -> 13639;
13641 -> 13639;
13642 -> 13640;
13642 -> 13496;
13642 -> 13641;
13642 -> 13639;
13643 -> 13639;
13644 -> 13640;
13644 -> 13496;
13644 -> 13643;
13645 -> 13643;
13646 -> 13644;
13646 -> 13496;
13646 -> 13645;
13647 -> 13643;
13648 -> 13647;
13649 -> 13644;
13649 -> 13647;
13650 -> 0;
13650 -> 13647;
13651 -> 13647;
13652 -> 13650;
13652 -> 13651;
13653 -> 13649;
13653 -> 13651;
13654 -> 13651;
13655 -> 13652;
13655 -> 13654;
13655 -> 13651;
13656 -> 13652;
13656 -> 13653;
13656 -> 13496;
13656 -> 13651;
13657 -> 13646;
13657 -> 13656;
13657 -> 13643;
13658 -> 13657;
13658 -> 13643;
13659 -> 13658;
13659 -> 13643;
13660 -> 13659;
13660 -> 13639;
13661 -> 13639;
13662 -> 13640;
13662 -> 13496;
13662 -> 13661;
13663 -> 13661;
13664 -> 13662;
13664 -> 13496;
13664 -> 13663;
13665 -> 13661;
13666 -> 13665;
13667 -> 13662;
13667 -> 13665;
13668 -> 0;
13668 -> 13665;
13669 -> 13665;
13670 -> 13668;
13670 -> 13669;
13671 -> 13667;
13671 -> 13669;
13672 -> 13669;
13673 -> 13670;
13673 -> 13672;
13673 -> 13669;
13674 -> 13670;
13674 -> 13671;
13674 -> 13496;
13674 -> 13669;
13675 -> 13664;
13675 -> 13674;
13675 -> 13661;
13676 -> 13675;
13676 -> 13661;
13677 -> 13676;
13677 -> 13661;
13678 -> 13677;
13678 -> 13639;
13679 -> 13660;
13679 -> 13678;
13679 -> 13639;
13680 -> 13679;
13680 -> 13637;
13681 -> 13637;
13682 -> 13638;
13682 -> 13681;
13683 -> 13681;
13684 -> 13682;
13684 -> 13496;
13684 -> 13683;
13684 -> 13681;
13685 -> 13681;
13686 -> 13682;
13686 -> 13496;
13686 -> 13685;
13687 -> 0;
13687 -> 13685;
13688 -> 13685;
13689 -> 13687;
13689 -> 13688;
13690 -> 13686;
13690 -> 13688;
13691 -> 13688;
13692 -> 13689;
13692 -> 13691;
13692 -> 13688;
13693 -> 13689;
13693 -> 13690;
13693 -> 13496;
13693 -> 13688;
13694 -> 13693;
13694 -> 13681;
13695 -> 13681;
13696 -> 13682;
13696 -> 13496;
13696 -> 13695;
13697 -> 0;
13697 -> 13695;
13698 -> 13695;
13699 -> 13697;
13699 -> 13698;
13700 -> 13696;
13700 -> 13698;
13701 -> 13698;
13702 -> 13699;
13702 -> 13701;
13702 -> 13698;
13703 -> 13699;
13703 -> 13700;
13703 -> 13496;
13703 -> 13698;
13704 -> 13703;
13704 -> 13681;
13705 -> 13694;
13705 -> 13704;
13705 -> 13681;
13706 -> 13705;
13706 -> 13637;
13707 -> 13680;
13707 -> 13706;
13707 -> 13637;
13708 -> 13637;
13709 -> 13638;
13709 -> 13496;
13709 -> 13708;
13709 -> 13637;
13710 -> 13637;
13711 -> 13638;
13711 -> 13496;
13711 -> 13710;
13712 -> 13710;
13713 -> 13712;
13714 -> 13711;
13714 -> 13712;
13715 -> 0;
13715 -> 13712;
13716 -> 13712;
13717 -> 13715;
13717 -> 13716;
13718 -> 13714;
13718 -> 13716;
13719 -> 13716;
13720 -> 13717;
13720 -> 13719;
13720 -> 13716;
13721 -> 13717;
13721 -> 13718;
13721 -> 13496;
13721 -> 13716;
13722 -> 13721;
13722 -> 13710;
13723 -> 13722;
13723 -> 13710;
13724 -> 13723;
13724 -> 13710;
13725 -> 13724;
13725 -> 13710;
13726 -> 13725;
13726 -> 13637;
13727 -> 13637;
13728 -> 13638;
13728 -> 13496;
13728 -> 13727;
13729 -> 13727;
13730 -> 13729;
13731 -> 13728;
13731 -> 13729;
13732 -> 0;
13732 -> 13729;
13733 -> 13729;
13734 -> 13732;
13734 -> 13733;
13735 -> 13731;
13735 -> 13733;
13736 -> 13733;
13737 -> 13734;
13737 -> 13736;
13737 -> 13733;
13738 -> 13734;
13738 -> 13735;
13738 -> 13496;
13738 -> 13733;
13739 -> 13738;
13739 -> 13727;
13740 -> 13739;
13740 -> 13727;
13741 -> 13740;
13741 -> 13727;
13742 -> 13741;
13742 -> 13727;
13743 -> 13742;
13743 -> 13637;
13744 -> 13726;
13744 -> 13743;
13744 -> 13637;
13745 -> 13707;
13745 -> 13744;
13745 -> 13637;
13746 -> 13745;
13746 -> 13519;
13747 -> 13519;
13748 -> 13634;
13748 -> 13747;
13749 -> 13747;
13750 -> 13748;
13750 -> 13496;
13750 -> 13749;
13750 -> 13747;
13751 -> 13747;
13752 -> 13748;
13752 -> 13496;
13752 -> 13751;
13753 -> 13751;
13754 -> 13752;
13754 -> 13496;
13754 -> 13753;
13755 -> 13751;
13756 -> 13755;
13757 -> 13752;
13757 -> 13755;
13758 -> 0;
13758 -> 13755;
13759 -> 13755;
13760 -> 13758;
13760 -> 13759;
13761 -> 13757;
13761 -> 13759;
13762 -> 13759;
13763 -> 13760;
13763 -> 13762;
13763 -> 13759;
13764 -> 13760;
13764 -> 13761;
13764 -> 13496;
13764 -> 13759;
13765 -> 13754;
13765 -> 13764;
13765 -> 13751;
13766 -> 13765;
13766 -> 13751;
13767 -> 13766;
13767 -> 13751;
13768 -> 13767;
13768 -> 13747;
13769 -> 13747;
13770 -> 13748;
13770 -> 13496;
13770 -> 13769;
13771 -> 13769;
13772 -> 13770;
13772 -> 13496;
13772 -> 13771;
13773 -> 13769;
13774 -> 13773;
13775 -> 13770;
13775 -> 13773;
13776 -> 0;
13776 -> 13773;
13777 -> 13773;
13778 -> 13776;
13778 -> 13777;
13779 -> 13775;
13779 -> 13777;
13780 -> 13777;
13781 -> 13778;
13781 -> 13780;
13781 -> 13777;
13782 -> 13778;
13782 -> 13779;
13782 -> 13496;
13782 -> 13777;
13783 -> 13772;
13783 -> 13782;
13783 -> 13769;
13784 -> 13783;
13784 -> 13769;
13785 -> 13784;
13785 -> 13769;
13786 -> 13785;
13786 -> 13747;
13787 -> 13768;
13787 -> 13786;
13787 -> 13747;
13788 -> 13787;
13788 -> 13519;
13789 -> 13746;
13789 -> 13788;
13789 -> 13519;
13790 -> 13519;
13791 -> 13634;
13791 -> 13790;
13792 -> 13790;
13793 -> 13791;
13793 -> 13496;
13793 -> 13792;
13793 -> 13790;
13794 -> 13790;
13795 -> 13791;
13795 -> 13496;
13795 -> 13794;
13796 -> 0;
13796 -> 13794;
13797 -> 13794;
13798 -> 13796;
13798 -> 13797;
13799 -> 13795;
13799 -> 13797;
13800 -> 13797;
13801 -> 13798;
13801 -> 13800;
13801 -> 13797;
13802 -> 13798;
13802 -> 13799;
13802 -> 13496;
13802 -> 13797;
13803 -> 13802;
13803 -> 13790;
13804 -> 13790;
13805 -> 13791;
13805 -> 13496;
13805 -> 13804;
13806 -> 0;
13806 -> 13804;
13807 -> 13804;
13808 -> 13806;
13808 -> 13807;
13809 -> 13805;
13809 -> 13807;
13810 -> 13807;
13811 -> 13808;
13811 -> 13810;
13811 -> 13807;
13812 -> 13808;
13812 -> 13809;
13812 -> 13496;
13812 -> 13807;
13813 -> 13812;
13813 -> 13790;
13814 -> 13803;
13814 -> 13813;
13814 -> 13790;
13815 -> 13814;
13815 -> 13519;
13816 -> 13789;
13816 -> 13815;
13816 -> 13519;
13817 -> 13634;
13817 -> 13519;
13818 -> 13496;
13818 -> 13519;
13819 -> 13817;
13819 -> 13818;
13819 -> 13496;
13819 -> 13520;
13819 -> 13629;
13819 -> 13519;
13820 -> 13519;
13821 -> 13819;
13821 -> 13820;
13822 -> 13819;
13822 -> 13820;
13823 -> 13820;
13824 -> 13821;
13824 -> 13823;
13825 -> 13824;
13825 -> 13820;
13826 -> 13819;
13826 -> 13820;
13827 -> 13819;
13827 -> 13820;
13828 -> 13820;
13829 -> 13826;
13829 -> 13828;
13830 -> 13829;
13830 -> 13825;
13830 -> 13828;
13831 -> 13830;
13831 -> 13820;
13832 -> 13819;
13832 -> 13820;
13833 -> 13819;
13833 -> 13820;
13834 -> 13820;
13835 -> 13832;
13835 -> 13834;
13836 -> 13834;
13837 -> 13835;
13837 -> 13836;
13838 -> 13837;
13838 -> 13831;
13838 -> 13836;
13839 -> 13834;
13840 -> 13838;
13840 -> 13839;
13841 -> 13840;
13841 -> 13831;
13841 -> 13839;
13842 -> 13840;
13842 -> 13820;
13843 -> 13819;
13843 -> 13820;
13844 -> 13819;
13844 -> 13820;
13845 -> 13844;
13845 -> 13820;
13846 -> 13843;
13846 -> 13820;
13847 -> 13518;
13847 -> 13496;
13848 -> 13842;
13848 -> 13511;
13848 -> 13496;
13849 -> 13848;
13850 -> 13849;
13850 -> 13848;
13851 -> 0;
13851 -> 13848;
13852 -> 13850;
13853 -> 13852;
13853 -> 13850;
13854 -> 13850;
13855 -> 13853;
13855 -> 13854;
13856 -> 13849;
13856 -> 13854;
13857 -> 13854;
13858 -> 13856;
13858 -> 13857;
13859 -> 13858;
13859 -> 13857;
13860 -> 13857;
13861 -> 13859;
13861 -> 13860;
13862 -> 13861;
13862 -> 13860;
13863 -> 13862;
13863 -> 13857;
13864 -> 13863;
13864 -> 13854;
13865 -> 13855;
13865 -> 13854;
13866 -> 13854;
13867 -> 13856;
13867 -> 13866;
13868 -> 13867;
13868 -> 13854;
13869 -> 13128;
13869 -> 13854;
13870 -> 13854;
13871 -> 13865;
13871 -> 13870;
13872 -> 13868;
13872 -> 13870;
13873 -> 13869;
13873 -> 13870;
13874 -> 13856;
13874 -> 13870;
13875 -> 13872;
13875 -> 13848;
13875 -> 13870;
13876 -> 13871;
13876 -> 13870;
13877 -> 13874;
13877 -> 13870;
13878 -> 13872;
13879 -> 13872;
13880 -> 13872;
13881 -> 13872;
13881 -> 13880;
13882 -> 13880;
13882 -> 13872;
13883 -> 13872;
13884 -> 13879;
13884 -> 13872;
13885 -> 13872;
13886 -> 13872;
13887 -> 13872;
13888 -> 13872;
13889 -> 13872;
13890 -> 13889;
13890 -> 13872;
13891 -> 13889;
13891 -> 13872;
13892 -> 13891;
13893 -> 13892;
13893 -> 13872;
13894 -> 13872;
13895 -> 13894;
13895 -> 13872;
13896 -> 13872;
13897 -> 13872;
13898 -> 13896;
13898 -> 13872;
13899 -> 13872;
13900 -> 13872;
13900 -> 13899;
13901 -> 0;
13901 -> 13899;
13902 -> 13901;
13902 -> 13872;
13903 -> 13902;
13903 -> 13872;
13904 -> 13872;
13905 -> 13903;
13905 -> 13904;
13906 -> 13898;
13906 -> 13904;
13907 -> 13905;
13907 -> 0;
13907 -> 13904;
13908 -> 13905;
13908 -> 13907;
13909 -> 13872;
13910 -> 13872;
13910 -> 13909;
13911 -> 13910;
13911 -> 13872;
13911 -> 13909;
13912 -> 13911;
13912 -> 13872;
13913 -> 13872;
13914 -> 13912;
13914 -> 13872;
13915 -> 13912;
13915 -> 13914;
13916 -> 13915;
13916 -> 13872;
13917 -> 13912;
13917 -> 13872;
13918 -> 13902;
13918 -> 13908;
13918 -> 13872;
13919 -> 13918;
13919 -> 13916;
13919 -> 13872;
13920 -> 13872;
13921 -> 13872;
13921 -> 13920;
13922 -> 13920;
13923 -> 13922;
13923 -> 13920;
13924 -> 13920;
13925 -> 13923;
13925 -> 13924;
13926 -> 13921;
13926 -> 13924;
13927 -> 13924;
13928 -> 13926;
13928 -> 13927;
13929 -> 13927;
13930 -> 13929;
13930 -> 13924;
13931 -> 13924;
13932 -> 13926;
13932 -> 13931;
13933 -> 13932;
13933 -> 13872;
13933 -> 13931;
13934 -> 13933;
13934 -> 13924;
13935 -> 13924;
13936 -> 13934;
13936 -> 13935;
13937 -> 13935;
13937 -> 13924;
13938 -> 13930;
13938 -> 13937;
13938 -> 13924;
13939 -> 13924;
13940 -> 13926;
13940 -> 13939;
13941 -> 13940;
13941 -> 13939;
13942 -> 13941;
13942 -> 13872;
13942 -> 13939;
13943 -> 13942;
13943 -> 13924;
13944 -> 13924;
13945 -> 13943;
13945 -> 13944;
13946 -> 13924;
13947 -> 13945;
13947 -> 13946;
13948 -> 13946;
13948 -> 13924;
13949 -> 13924;
13950 -> 13938;
13950 -> 13948;
13950 -> 13924;
13951 -> 13924;
13952 -> 13926;
13952 -> 13951;
13953 -> 13952;
13953 -> 13924;
13954 -> 13953;
13954 -> 4027;
13954 -> 13924;
13955 -> 13950;
13955 -> 13954;
13955 -> 13924;
13956 -> 13924;
13957 -> 13924;
13958 -> 13957;
13958 -> 13872;
13959 -> 13872;
13960 -> 13872;
13960 -> 0;
13961 -> 13872;
13962 -> 13872;
13962 -> 13961;
13963 -> 13961;
13964 -> 13962;
13964 -> 13963;
13965 -> 13963;
13966 -> 13964;
13966 -> 13965;
13967 -> 13966;
13967 -> 13963;
13968 -> 13963;
13969 -> 13967;
13969 -> 13968;
13970 -> 13872;
13971 -> 13970;
13971 -> 13872;
13972 -> 13872;
13972 -> 13971;
13973 -> 13971;
13974 -> 13972;
13974 -> 13973;
13975 -> 13973;
13976 -> 13974;
13976 -> 13975;
13977 -> 13976;
13977 -> 13973;
13978 -> 13973;
13979 -> 13977;
13979 -> 13978;
13980 -> 13872;
13980 -> 0;
13981 -> 13872;
13982 -> 13979;
13982 -> 13981;
13982 -> 13872;
13983 -> 13872;
13984 -> 13872;
13985 -> 13872;
13985 -> 13984;
13986 -> 13985;
13986 -> 13872;
13986 -> 13984;
13987 -> 13986;
13987 -> 13984;
13988 -> 13987;
13988 -> 13872;
13989 -> 13872;
13990 -> 13872;
13991 -> 13872;
13992 -> 13872;
13993 -> 13991;
13993 -> 13992;
13994 -> 13991;
13994 -> 13992;
13995 -> 13993;
13995 -> 13992;
13996 -> 13992;
13997 -> 13993;
13997 -> 13996;
13998 -> 13996;
13998 -> 13992;
13999 -> 13992;
14000 -> 13992;
14001 -> 13993;
14001 -> 14000;
14002 -> 0;
14002 -> 14000;
14003 -> 14001;
14003 -> 13992;
14004 -> 13992;
14005 -> 13993;
14005 -> 14004;
14006 -> 14005;
14006 -> 13872;
14006 -> 14004;
14007 -> 14006;
14007 -> 13992;
14008 -> 14007;
14008 -> 13992;
14009 -> 13992;
14010 -> 14009;
14010 -> 13872;
14011 -> 13872;
14012 -> 13872;
14013 -> 13872;
14014 -> 13872;
14015 -> 14014;
14015 -> 13872;
14016 -> 14015;
14016 -> 13872;
14017 -> 14015;
14017 -> 13872;
14018 -> 14017;
14018 -> 13872;
14019 -> 14018;
14019 -> 13872;
14020 -> 14018;
14020 -> 13872;
14021 -> 13872;
14022 -> 13872;
14023 -> 13872;
14024 -> 13872;
14025 -> 13872;
14026 -> 13872;
14026 -> 14025;
14027 -> 14025;
14028 -> 14027;
14028 -> 13872;
14029 -> 13872;
14030 -> 14029;
14031 -> 13872;
14032 -> 14028;
14032 -> 14031;
14032 -> 13872;
14033 -> 13872;
14034 -> 13872;
14035 -> 13872;
14036 -> 13872;
14037 -> 14035;
14037 -> 14036;
14038 -> 14036;
14039 -> 14037;
14039 -> 14038;
14039 -> 14036;
14040 -> 14037;
14040 -> 14036;
14041 -> 14036;
14041 -> 13872;
14042 -> 13872;
14043 -> 13872;
14044 -> 13872;
14045 -> 14043;
14045 -> 14044;
14046 -> 14044;
14047 -> 14045;
14047 -> 14046;
14048 -> 14046;
14049 -> 14047;
14049 -> 14048;
14050 -> 14048;
14051 -> 14049;
14051 -> 13872;
14051 -> 14050;
14051 -> 14048;
14052 -> 14046;
14053 -> 14047;
14053 -> 14044;
14054 -> 14044;
14055 -> 13872;
14056 -> 13872;
14056 -> 13870;
14057 -> 14056;
14057 -> 13870;
14058 -> 13870;
14059 -> 14057;
14059 -> 14058;
14059 -> 13870;
14060 -> 13876;
14060 -> 13870;
14061 -> 14057;
14061 -> 13870;
14062 -> 13870;
14063 -> 14060;
14063 -> 14062;
14064 -> 14061;
14064 -> 14062;
14065 -> 13877;
14065 -> 14062;
14066 -> 13870;
14067 -> 13872;
14067 -> 14066;
14068 -> 13870;
14069 -> 14063;
14069 -> 14068;
14070 -> 14067;
14070 -> 14068;
14071 -> 13873;
14071 -> 14068;
14072 -> 13874;
14072 -> 14068;
14073 -> 13128;
14073 -> 14068;
14074 -> 14068;
14075 -> 14070;
14075 -> 14068;
14076 -> 14068;
14077 -> 14064;
14077 -> 14076;
14077 -> 13870;
14078 -> 13854;
14079 -> 13856;
14079 -> 14078;
14080 -> 0;
14080 -> 14078;
14081 -> 14080;
14081 -> 13854;
14082 -> 11249;
14082 -> 13854;
14083 -> 13854;
14084 -> 14069;
14084 -> 14083;
14085 -> 14081;
14085 -> 14083;
14086 -> 14082;
14086 -> 14083;
14087 -> 13856;
14087 -> 14083;
14088 -> 13128;
14088 -> 14083;
14089 -> 14083;
14090 -> 14085;
14090 -> 14083;
14091 -> 14083;
14092 -> 14091;
14092 -> 13854;
14093 -> 14077;
14093 -> 14092;
14093 -> 13854;
14094 -> 13854;
14095 -> 13856;
14095 -> 14094;
14096 -> 14095;
14096 -> 13872;
14096 -> 14094;
14097 -> 13854;
14098 -> 14084;
14098 -> 14097;
14099 -> 14096;
14099 -> 14097;
14100 -> 13856;
14100 -> 14097;
14101 -> 14097;
14102 -> 14101;
14102 -> 13854;
14103 -> 14093;
14103 -> 14102;
14103 -> 13854;
14104 -> 13854;
14105 -> 13856;
14105 -> 14104;
14106 -> 14105;
14106 -> 14104;
14107 -> 14106;
14107 -> 13872;
14107 -> 14104;
14108 -> 14107;
14109 -> 14107;
14109 -> 14108;
14110 -> 14108;
14110 -> 14107;
14111 -> 14107;
14111 -> 13854;
14112 -> 13854;
14113 -> 14111;
14113 -> 14112;
14114 -> 14112;
14115 -> 14113;
14115 -> 14114;
14116 -> 14114;
14117 -> 14115;
14117 -> 14116;
14118 -> 14116;
14119 -> 14117;
14119 -> 13872;
14119 -> 14118;
14119 -> 14116;
14120 -> 14114;
14121 -> 14115;
14121 -> 14112;
14122 -> 14112;
14123 -> 13854;
14124 -> 14123;
14124 -> 13850;
14125 -> 14098;
14125 -> 13849;
14125 -> 13850;
14126 -> 13849;
14126 -> 13872;
14126 -> 14125;
14126 -> 13848;
14127 -> 14126;
14127 -> 13848;
14128 -> 13848;
14129 -> 14127;
14129 -> 14128;
14129 -> 13848;
14130 -> 13848;
14131 -> 14130;
14131 -> 13872;
14131 -> 13848;
14132 -> 14131;
14132 -> 13872;
14132 -> 14125;
14132 -> 13848;
14133 -> 14131;
14133 -> 13872;
14133 -> 14125;
14133 -> 13848;
14134 -> 14127;
14134 -> 14133;
14134 -> 13848;
14135 -> 14134;
14135 -> 13848;
14136 -> 13848;
14137 -> 14135;
14137 -> 14136;
14137 -> 13848;
14138 -> 13848;
14138 -> 13471;
14139 -> 13471;
14140 -> 14135;
14140 -> 14139;
14140 -> 13471;
14141 -> 14138;
14141 -> 13471;
14142 -> 2192;
14143 -> 2191;
14143 -> 2192;
14144 -> 2191;
14144 -> 2192;
14145 -> 2192;
14146 -> 14144;
14146 -> 14145;
14147 -> 14145;
14148 -> 14147;
14148 -> 2192;
14149 -> 14143;
14149 -> 13872;
14149 -> 2192;
14150 -> 2191;
14150 -> 13872;
14150 -> 14125;
14150 -> 2051;
14151 -> 2326;
14151 -> 14150;
14151 -> 2325;
14151 -> 2324;
14152 -> 14151;
14153 -> 14150;
14153 -> 2192;
14154 -> 14153;
14154 -> 2196;
14155 -> 14154;
14155 -> 2198;
14155 -> 2196;
14156 -> 2192;
14157 -> 2192;
14158 -> 2191;
14158 -> 2192;
14159 -> 2192;
14160 -> 14158;
14160 -> 14159;
14161 -> 14159;
14162 -> 14160;
14162 -> 14150;
14162 -> 14161;
14162 -> 14159;
14163 -> 14162;
14164 -> 14160;
14164 -> 14163;
14165 -> 14164;
14165 -> 14150;
14165 -> 14163;
14166 -> 14165;
14166 -> 14162;
14167 -> 14162;
14168 -> 14166;
14168 -> 14167;
14169 -> 14167;
14170 -> 14168;
14170 -> 14167;
14171 -> 14170;
14171 -> 14168;
14172 -> 14169;
14172 -> 14167;
14173 -> 14172;
14173 -> 14162;
14174 -> 14173;
14174 -> 14162;
14175 -> 14160;
14175 -> 14168;
14175 -> 14162;
14176 -> 14162;
14177 -> 14162;
14178 -> 14174;
14178 -> 14177;
14179 -> 14175;
14179 -> 14177;
14180 -> 14176;
14180 -> 14177;
14181 -> 14176;
14181 -> 14177;
14182 -> 14176;
14182 -> 14177;
14183 -> 14176;
14183 -> 14177;
14184 -> 14160;
14184 -> 14177;
14185 -> 14177;
14186 -> 14177;
14187 -> 14184;
14187 -> 14186;
14188 -> 14187;
14188 -> 14168;
14188 -> 14186;
14189 -> 14188;
14189 -> 14177;
14190 -> 14177;
14191 -> 14190;
14191 -> 14177;
14192 -> 14178;
14192 -> 14177;
14193 -> 14180;
14193 -> 14177;
14194 -> 14185;
14194 -> 14177;
14195 -> 14189;
14195 -> 14177;
14196 -> 14183;
14196 -> 14177;
14197 -> 14182;
14197 -> 14177;
14198 -> 14190;
14198 -> 14177;
14199 -> 14184;
14199 -> 14177;
14200 -> 14199;
14200 -> 14177;
14201 -> 14177;
14202 -> 14177;
14203 -> 14177;
14204 -> 14203;
14204 -> 14192;
14204 -> 14174;
14204 -> 14177;
14205 -> 0;
14205 -> 14177;
14206 -> 14185;
14206 -> 0;
14206 -> 14177;
14207 -> 14177;
14208 -> 14207;
14208 -> 14177;
14209 -> 14177;
14210 -> 14181;
14210 -> 14185;
14211 -> 14210;
14212 -> 14179;
14212 -> 14210;
14213 -> 14210;
14214 -> 14184;
14214 -> 14213;
14215 -> 14210;
14216 -> 14210;
14216 -> 14177;
14217 -> 14185;
14217 -> 14177;
14218 -> 14180;
14218 -> 14177;
14219 -> 14211;
14219 -> 14177;
14220 -> 14177;
14221 -> 14216;
14221 -> 14220;
14222 -> 14217;
14222 -> 14220;
14223 -> 14217;
14223 -> 14220;
14224 -> 14218;
14224 -> 14220;
14225 -> 14219;
14225 -> 14220;
14226 -> 14184;
14226 -> 14220;
14227 -> 14177;
14228 -> 14177;
14229 -> 14183;
14229 -> 14212;
14230 -> 14210;
14230 -> 14229;
14231 -> 14229;
14232 -> 14230;
14232 -> 14231;
14233 -> 14184;
14233 -> 14231;
14234 -> 14232;
14234 -> 14231;
14235 -> 14229;
14236 -> 14185;
14236 -> 14229;
14237 -> 14229;
14238 -> 14236;
14238 -> 14237;
14239 -> 14184;
14239 -> 14237;
14240 -> 14237;
14241 -> 14239;
14241 -> 14240;
14242 -> 14241;
14242 -> 14212;
14242 -> 14240;
14243 -> 14242;
14243 -> 14237;
14244 -> 14238;
14244 -> 14185;
14244 -> 14237;
14245 -> 14229;
14246 -> 14212;
14246 -> 14177;
14247 -> 14185;
14247 -> 14177;
14248 -> 0;
14248 -> 14212;
14249 -> 14212;
14250 -> 14248;
14250 -> 14249;
14251 -> 14250;
14251 -> 14212;
14252 -> 14160;
14252 -> 14212;
14252 -> 14159;
14253 -> 14252;
14253 -> 2192;
14254 -> 2191;
14254 -> 14253;
14254 -> 14212;
14254 -> 14250;
14254 -> 2051;
14255 -> 2326;
14255 -> 14254;
14255 -> 2325;
14255 -> 2324;
14256 -> 14255;
14257 -> 14254;
14257 -> 2192;
14258 -> 14257;
14258 -> 2196;
14259 -> 14258;
14259 -> 2198;
14259 -> 2196;
14260 -> 2191;
14260 -> 2192;
14261 -> 2192;
14262 -> 14260;
14262 -> 14261;
14263 -> 14262;
14263 -> 14254;
14263 -> 14261;
14264 -> 14263;
14265 -> 14262;
14265 -> 14264;
14266 -> 14264;
14267 -> 14265;
14267 -> 14254;
14267 -> 14266;
14267 -> 14264;
14268 -> 14263;
14269 -> 14263;
14270 -> 14263;
14271 -> 14270;
14272 -> 14270;
14272 -> 14271;
14273 -> 14271;
14274 -> 14272;
14274 -> 14254;
14274 -> 14273;
14274 -> 14271;
14275 -> 14270;
14276 -> 14270;
14276 -> 14263;
14277 -> 14276;
14278 -> 14276;
14278 -> 14277;
14279 -> 14278;
14279 -> 14254;
14279 -> 14277;
14280 -> 14279;
14280 -> 14276;
14281 -> 14262;
14281 -> 14254;
14281 -> 14263;
14282 -> 14269;
14282 -> 14263;
14283 -> 14263;
14284 -> 14262;
14284 -> 14282;
14284 -> 14261;
14285 -> 14262;
14285 -> 14282;
14285 -> 14261;
14286 -> 14285;
14286 -> 2192;
14287 -> 2192;
14288 -> 2326;
14288 -> 14286;
14288 -> 2325;
14288 -> 2324;
14289 -> 14288;
14290 -> 14286;
14290 -> 2192;
14291 -> 14290;
14291 -> 2196;
14292 -> 14291;
14292 -> 2198;
14292 -> 2196;
14293 -> 2191;
14293 -> 2192;
14294 -> 2192;
14295 -> 2191;
14295 -> 2192;
14296 -> 14295;
14296 -> 14286;
14296 -> 2928;
14296 -> 2192;
14297 -> 2192;
14298 -> 14296;
14299 -> 14295;
14299 -> 14298;
14300 -> 14299;
14300 -> 14286;
14300 -> 14298;
14301 -> 14300;
14301 -> 14286;
14301 -> 14298;
14302 -> 14301;
14303 -> 14302;
14303 -> 14301;
14304 -> 14301;
14305 -> 14299;
14305 -> 14303;
14305 -> 14301;
14306 -> 14303;
14306 -> 14301;
14307 -> 14299;
14307 -> 14305;
14307 -> 14301;
14308 -> 14307;
14308 -> 14298;
14309 -> 14308;
14309 -> 14296;
14310 -> 14296;
14311 -> 14309;
14311 -> 14308;
14311 -> 14310;
14311 -> 14296;
14312 -> 14295;
14312 -> 14308;
14312 -> 14296;
14313 -> 2928;
14313 -> 14296;
14314 -> 14309;
14314 -> 14296;
14315 -> 2191;
14315 -> 14314;
14315 -> 14308;
14315 -> 14312;
14315 -> 2051;
14316 -> 2191;
14316 -> 2192;
14317 -> 2192;
14318 -> 14316;
14318 -> 14317;
14319 -> 0;
14319 -> 14317;
14320 -> 14319;
14320 -> 2192;
14321 -> 2192;
14322 -> 14316;
14322 -> 14321;
14323 -> 2192;
14324 -> 2191;
14324 -> 2192;
14325 -> 2191;
14325 -> 2192;
14326 -> 2191;
14326 -> 2192;
14327 -> 2192;
14328 -> 14324;
14328 -> 14327;
14328 -> 2192;
14329 -> 14326;
14329 -> 14315;
14329 -> 14328;
14330 -> 14324;
14330 -> 14328;
14331 -> 14326;
14331 -> 14328;
14332 -> 14330;
14332 -> 14331;
14332 -> 14325;
14332 -> 14329;
14332 -> 14328;
14333 -> 14328;
14334 -> 14332;
14334 -> 14333;
14335 -> 14333;
14336 -> 14334;
14336 -> 14335;
14337 -> 14335;
14338 -> 14336;
14338 -> 14337;
14338 -> 14335;
14339 -> 14333;
14340 -> 14332;
14340 -> 14333;
14341 -> 14332;
14341 -> 14333;
14342 -> 14332;
14342 -> 14333;
14343 -> 14340;
14343 -> 14333;
14344 -> 14333;
14345 -> 14343;
14345 -> 14344;
14346 -> 14342;
14346 -> 14344;
14347 -> 14346;
14347 -> 14332;
14347 -> 14345;
14347 -> 14344;
14348 -> 14347;
14349 -> 14333;
14350 -> 14332;
14351 -> 0;
14351 -> 14350;
14352 -> 14350;
14353 -> 14351;
14353 -> 14352;
14354 -> 14351;
14354 -> 14352;
14355 -> 14354;
14355 -> 14352;
14356 -> 14353;
14356 -> 14354;
14356 -> 14352;
14357 -> 14353;
14357 -> 14352;
14358 -> 14352;
14359 -> 14357;
14359 -> 14358;
14360 -> 14354;
14360 -> 14358;
14361 -> 14359;
14361 -> 14358;
14362 -> 14358;
14363 -> 14358;
14364 -> 14361;
14364 -> 14363;
14365 -> 14362;
14365 -> 14363;
14366 -> 14360;
14366 -> 14363;
14367 -> 14364;
14367 -> 14363;
14368 -> 14364;
14368 -> 14363;
14369 -> 14365;
14369 -> 14363;
14370 -> 14366;
14370 -> 14363;
14371 -> 14368;
14371 -> 14363;
14372 -> 14368;
14372 -> 14371;
14373 -> 14369;
14373 -> 14371;
14374 -> 14371;
14375 -> 14372;
14375 -> 14374;
14376 -> 14373;
14376 -> 14374;
14377 -> 14370;
14377 -> 14374;
14378 -> 14375;
14378 -> 14377;
14378 -> 14374;
14379 -> 14374;
14380 -> 14375;
14380 -> 14379;
14380 -> 14374;
14381 -> 14376;
14381 -> 0;
14381 -> 14374;
14382 -> 14374;
14383 -> 14375;
14383 -> 14374;
14384 -> 14374;
14385 -> 14383;
14385 -> 14384;
14385 -> 14374;
14386 -> 14374;
14387 -> 14377;
14387 -> 14386;
14388 -> 14387;
14388 -> 14374;
14389 -> 14374;
14390 -> 14383;
14390 -> 14389;
14391 -> 14390;
14391 -> 14374;
14392 -> 14377;
14392 -> 14388;
14392 -> 14374;
14393 -> 14383;
14393 -> 14391;
14393 -> 14374;
14394 -> 14392;
14394 -> 14393;
14394 -> 14374;
14395 -> 14394;
14396 -> 14351;
14396 -> 14352;
14397 -> 14352;
14398 -> 14396;
14398 -> 14395;
14398 -> 14397;
14399 -> 14398;
14399 -> 14395;
14399 -> 14397;
14400 -> 14397;
14401 -> 14399;
14401 -> 14352;
14402 -> 14401;
14403 -> 14402;
14404 -> 14402;
14404 -> 14403;
14405 -> 14403;
14405 -> 14402;
14406 -> 14402;
14407 -> 14406;
14407 -> 14395;
14407 -> 14402;
14408 -> 14407;
14408 -> 14401;
14409 -> 14401;
14410 -> 14408;
14410 -> 14409;
14411 -> 14408;
14411 -> 14409;
14412 -> 14408;
14412 -> 14409;
14413 -> 14410;
14413 -> 14408;
14413 -> 14409;
14414 -> 14410;
14414 -> 14408;
14414 -> 14409;
14415 -> 14411;
14415 -> 14409;
14416 -> 14409;
14417 -> 14413;
14417 -> 14416;
14418 -> 14414;
14418 -> 14416;
14419 -> 14415;
14419 -> 14416;
14420 -> 14412;
14420 -> 14416;
14421 -> 14416;
14422 -> 14417;
14422 -> 14421;
14422 -> 14416;
14423 -> 14417;
14423 -> 14422;
14424 -> 14422;
14425 -> 14423;
14425 -> 14424;
14426 -> 14419;
14426 -> 14424;
14427 -> 14425;
14427 -> 14424;
14428 -> 14424;
14429 -> 14427;
14429 -> 14428;
14430 -> 14426;
14430 -> 14428;
14431 -> 14428;
14432 -> 14429;
14432 -> 14431;
14432 -> 14428;
14433 -> 14430;
14433 -> 14408;
14433 -> 14428;
14434 -> 14429;
14434 -> 14428;
14435 -> 14433;
14435 -> 14434;
14435 -> 14428;
14436 -> 14426;
14436 -> 14435;
14436 -> 14424;
14437 -> 14418;
14437 -> 14416;
14438 -> 14436;
14438 -> 14416;
14439 -> 14437;
14439 -> 14416;
14440 -> 14420;
14440 -> 14416;
14441 -> 14416;
14442 -> 14439;
14442 -> 14441;
14442 -> 14416;
14443 -> 14416;
14444 -> 14438;
14444 -> 14443;
14444 -> 14416;
14445 -> 14438;
14445 -> 14440;
14445 -> 14416;
14446 -> 14439;
14446 -> 14440;
14446 -> 14416;
14447 -> 14408;
14447 -> 14436;
14447 -> 14445;
14447 -> 14446;
14447 -> 14401;
14448 -> 14401;
14449 -> 14447;
14449 -> 14448;
14450 -> 14396;
14450 -> 14447;
14450 -> 14448;
14451 -> 14448;
14452 -> 14449;
14452 -> 14451;
14453 -> 14452;
14453 -> 14448;
14454 -> 14449;
14454 -> 14447;
14454 -> 14450;
14454 -> 14448;
14455 -> 14450;
14455 -> 14447;
14455 -> 14448;
14456 -> 14449;
14456 -> 14447;
14456 -> 14452;
14456 -> 14448;
14457 -> 14455;
14457 -> 14456;
14457 -> 14448;
14458 -> 14396;
14458 -> 14447;
14458 -> 14352;
14459 -> 14351;
14459 -> 14458;
14459 -> 14447;
14459 -> 14454;
14459 -> 14457;
14459 -> 14350;
14460 -> 14459;
14461 -> 14459;
14461 -> 14460;
14462 -> 14460;
14462 -> 14459;
14463 -> 14459;
14464 -> 14459;
14465 -> 14459;
14466 -> 14352;
14467 -> 14351;
14467 -> 14466;
14468 -> 14466;
14468 -> 14352;
14469 -> 14351;
14469 -> 14352;
14470 -> 14351;
14470 -> 14352;
14471 -> 14351;
14471 -> 14352;
14472 -> 14352;
14473 -> 14352;
14474 -> 14470;
14474 -> 14473;
14475 -> 14474;
14475 -> 14459;
14475 -> 14473;
14476 -> 14475;
14476 -> 14352;
14477 -> 14352;
14478 -> 14471;
14478 -> 14477;
14479 -> 14478;
14479 -> 14459;
14479 -> 14477;
14480 -> 14479;
14480 -> 14352;
14481 -> 14476;
14481 -> 14480;
14481 -> 14352;
14482 -> 14352;
14483 -> 14470;
14483 -> 14482;
14484 -> 14483;
14484 -> 14459;
14484 -> 14482;
14485 -> 14484;
14485 -> 14352;
14486 -> 14352;
14487 -> 14471;
14487 -> 14486;
14488 -> 14487;
14488 -> 14459;
14488 -> 14486;
14489 -> 14488;
14489 -> 14352;
14490 -> 14485;
14490 -> 14489;
14490 -> 14352;
14491 -> 14474;
14491 -> 14490;
14491 -> 14473;
14492 -> 14491;
14492 -> 14352;
14493 -> 14478;
14493 -> 14490;
14493 -> 14477;
14494 -> 14493;
14494 -> 14352;
14495 -> 14492;
14495 -> 14494;
14495 -> 14352;
14496 -> 14332;
14496 -> 14490;
14496 -> 14350;
14497 -> 14490;
14497 -> 14350;
14498 -> 14333;
14499 -> 14332;
14499 -> 14498;
14500 -> 0;
14500 -> 14498;
14501 -> 14500;
14501 -> 14333;
14502 -> 14333;
14503 -> 14333;
14504 -> 14332;
14505 -> 14332;
14505 -> 14504;
14506 -> 14332;
14506 -> 14504;
14507 -> 14332;
14507 -> 14504;
14508 -> 14504;
14509 -> 14506;
14509 -> 14496;
14509 -> 14508;
14510 -> 14508;
14511 -> 14507;
14511 -> 14509;
14511 -> 14510;
14512 -> 14511;
14512 -> 14510;
14513 -> 14510;
14514 -> 14512;
14514 -> 14513;
14515 -> 14513;
14516 -> 14514;
14516 -> 14515;
14516 -> 14513;
14517 -> 14510;
14518 -> 14511;
14518 -> 14508;
14519 -> 14518;
14519 -> 14508;
14520 -> 14519;
14521 -> 14507;
14521 -> 14520;
14522 -> 14520;
14523 -> 14521;
14523 -> 14522;
14524 -> 14523;
14524 -> 14509;
14524 -> 14522;
14525 -> 14522;
14526 -> 14524;
14526 -> 14525;
14526 -> 14522;
14527 -> 14522;
14528 -> 14523;
14528 -> 14527;
14529 -> 14528;
14529 -> 14509;
14529 -> 14527;
14530 -> 14529;
14530 -> 14522;
14531 -> 14522;
14532 -> 14522;
14533 -> 14530;
14533 -> 14532;
14534 -> 14530;
14534 -> 14532;
14535 -> 14531;
14535 -> 14532;
14536 -> 14531;
14536 -> 14532;
14537 -> 14531;
14537 -> 14532;
14538 -> 14531;
14538 -> 14532;
14539 -> 14523;
14539 -> 14532;
14540 -> 14532;
14541 -> 14539;
14541 -> 14540;
14542 -> 14540;
14543 -> 14541;
14543 -> 14542;
14544 -> 14542;
14544 -> 14540;
14545 -> 14541;
14545 -> 14530;
14545 -> 14540;
14546 -> 14545;
14546 -> 14532;
14547 -> 14532;
14548 -> 14547;
14548 -> 14532;
14549 -> 14533;
14549 -> 14532;
14550 -> 14535;
14550 -> 14532;
14551 -> 14532;
14552 -> 14546;
14552 -> 14532;
14553 -> 14538;
14553 -> 14532;
14554 -> 14537;
14554 -> 14532;
14555 -> 14547;
14555 -> 14532;
14556 -> 14539;
14556 -> 14532;
14557 -> 14556;
14557 -> 14532;
14558 -> 14532;
14559 -> 14532;
14560 -> 14532;
14561 -> 14560;
14561 -> 14549;
14561 -> 14530;
14561 -> 14532;
14562 -> 0;
14562 -> 14532;
14563 -> 14547;
14563 -> 0;
14563 -> 14532;
14564 -> 14532;
14565 -> 14564;
14565 -> 14532;
14566 -> 14532;
14567 -> 14536;
14567 -> 14547;
14568 -> 14567;
14569 -> 14534;
14569 -> 14567;
14570 -> 14567;
14571 -> 14539;
14571 -> 14570;
14572 -> 14567;
14573 -> 14567;
14573 -> 14532;
14574 -> 14547;
14574 -> 14532;
14575 -> 14532;
14576 -> 14535;
14576 -> 14532;
14577 -> 14568;
14577 -> 14532;
14578 -> 14532;
14579 -> 14573;
14579 -> 14578;
14580 -> 14574;
14580 -> 14578;
14581 -> 14575;
14581 -> 14578;
14582 -> 14576;
14582 -> 14578;
14583 -> 14577;
14583 -> 14578;
14584 -> 14539;
14584 -> 14578;
14585 -> 14579;
14585 -> 0;
14585 -> 14578;
14586 -> 14580;
14586 -> 0;
14586 -> 14578;
14587 -> 14579;
14587 -> 0;
14587 -> 14580;
14587 -> 14578;
14588 -> 14578;
14589 -> 14584;
14589 -> 14569;
14589 -> 14588;
14589 -> 14578;
14590 -> 14584;
14590 -> 14569;
14590 -> 14578;
14591 -> 14582;
14591 -> 0;
14591 -> 14578;
14592 -> 14583;
14592 -> 14578;
14593 -> 14578;
14594 -> 14584;
14594 -> 14593;
14595 -> 14593;
14596 -> 14594;
14596 -> 14595;
14597 -> 14596;
14597 -> 14569;
14597 -> 14595;
14598 -> 14595;
14599 -> 14597;
14599 -> 14598;
14599 -> 14595;
14600 -> 14597;
14600 -> 14569;
14600 -> 14595;
14601 -> 14600;
14601 -> 14593;
14602 -> 14593;
14603 -> 14601;
14603 -> 14602;
14603 -> 14593;
14604 -> 14603;
14604 -> 14578;
14605 -> 14604;
14606 -> 14584;
14606 -> 14605;
14607 -> 14605;
14608 -> 14606;
14608 -> 14607;
14609 -> 14608;
14609 -> 14569;
14609 -> 14607;
14610 -> 14607;
14611 -> 14609;
14611 -> 14610;
14611 -> 14607;
14612 -> 14609;
14612 -> 14569;
14612 -> 14607;
14613 -> 14612;
14613 -> 14605;
14614 -> 14605;
14615 -> 14613;
14615 -> 14614;
14615 -> 14605;
14616 -> 14615;
14616 -> 14605;
14617 -> 14616;
14617 -> 14604;
14618 -> 14604;
14619 -> 14578;
14620 -> 14592;
14620 -> 14619;
14620 -> 14578;
14621 -> 14579;
14621 -> 14578;
14622 -> 14580;
14622 -> 14578;
14623 -> 14581;
14623 -> 14578;
14624 -> 14582;
14624 -> 14578;
14625 -> 14583;
14625 -> 14578;
14626 -> 14578;
14627 -> 14621;
14627 -> 14626;
14628 -> 14622;
14628 -> 14626;
14629 -> 14623;
14629 -> 14626;
14630 -> 14624;
14630 -> 14626;
14631 -> 14625;
14631 -> 14626;
14632 -> 14584;
14632 -> 14626;
14633 -> 14578;
14634 -> 14532;
14635 -> 14538;
14635 -> 14569;
14636 -> 14567;
14636 -> 14635;
14637 -> 14635;
14638 -> 14636;
14638 -> 14637;
14639 -> 14539;
14639 -> 14637;
14640 -> 14638;
14640 -> 14637;
14641 -> 14635;
14642 -> 14532;
14642 -> 14635;
14643 -> 14635;
14644 -> 14642;
14644 -> 14643;
14645 -> 14539;
14645 -> 14643;
14646 -> 14643;
14647 -> 14645;
14647 -> 14646;
14648 -> 14647;
14648 -> 14643;
14649 -> 14644;
14649 -> 14532;
14649 -> 14643;
14650 -> 14635;
14651 -> 14569;
14651 -> 14532;
14652 -> 14532;
14653 -> 0;
14653 -> 14569;
14654 -> 14569;
14655 -> 14653;
14655 -> 14654;
14656 -> 14655;
14656 -> 14569;
14657 -> 14523;
14657 -> 14569;
14657 -> 14655;
14657 -> 14522;
14658 -> 14523;
14658 -> 14569;
14658 -> 14522;
14659 -> 14658;
14659 -> 14520;
14660 -> 14659;
14660 -> 14519;
14661 -> 14518;
14661 -> 14508;
14662 -> 14506;
14662 -> 14508;
14663 -> 14508;
14664 -> 14661;
14664 -> 14663;
14665 -> 14662;
14665 -> 14663;
14666 -> 14507;
14666 -> 14569;
14666 -> 14663;
14667 -> 14664;
14667 -> 14663;
14668 -> 14663;
14669 -> 14667;
14669 -> 14668;
14670 -> 14666;
14670 -> 14668;
14671 -> 14670;
14671 -> 14569;
14671 -> 14655;
14671 -> 14669;
14671 -> 14668;
14672 -> 14671;
14673 -> 14508;
14674 -> 14655;
14674 -> 14510;
14675 -> 14674;
14675 -> 14513;
14676 -> 14675;
14676 -> 14515;
14676 -> 14513;
14677 -> 14655;
14677 -> 0;
14678 -> 14655;
14679 -> 0;
14679 -> 14655;
14680 -> 14655;
14681 -> 14679;
14681 -> 14680;
14682 -> 14655;
14682 -> 14508;
14683 -> 14682;
14683 -> 14663;
14684 -> 14507;
14684 -> 14655;
14684 -> 14663;
14685 -> 14683;
14685 -> 14663;
14686 -> 14685;
14686 -> 14668;
14687 -> 14684;
14687 -> 14668;
14688 -> 14687;
14688 -> 14655;
14688 -> 14681;
14688 -> 14686;
14688 -> 14668;
14689 -> 14688;
14690 -> 14681;
14690 -> 14510;
14691 -> 14690;
14691 -> 14513;
14692 -> 14691;
14692 -> 14515;
14692 -> 14513;
14693 -> 0;
14693 -> 14681;
14694 -> 14681;
14695 -> 14693;
14695 -> 14694;
14696 -> 14695;
14697 -> 14696;
14697 -> 14695;
14698 -> 14695;
14699 -> 14697;
14699 -> 14698;
14700 -> 14507;
14700 -> 14698;
14701 -> 14698;
14702 -> 14700;
14702 -> 14701;
14703 -> 14702;
14703 -> 14681;
14703 -> 14701;
14704 -> 4436;
14704 -> 14701;
14705 -> 14703;
14706 -> 14702;
14706 -> 14705;
14707 -> 14706;
14707 -> 14681;
14707 -> 14705;
14708 -> 14707;
14708 -> 14703;
14709 -> 14703;
14710 -> 14703;
14711 -> 14710;
14711 -> 14703;
14712 -> 14703;
14713 -> 14711;
14713 -> 14712;
14714 -> 14702;
14714 -> 14712;
14715 -> 14712;
14716 -> 14714;
14716 -> 14715;
14717 -> 14715;
14718 -> 14716;
14718 -> 14681;
14718 -> 14717;
14719 -> 14718;
14719 -> 14681;
14719 -> 4351;
14719 -> 14717;
14720 -> 14719;
14720 -> 4372;
14720 -> 14717;
14721 -> 14720;
14721 -> 14715;
14722 -> 14721;
14722 -> 14712;
14723 -> 14712;
14724 -> 14714;
14724 -> 14723;
14725 -> 14723;
14726 -> 14724;
14726 -> 14725;
14727 -> 14725;
14727 -> 14723;
14728 -> 14724;
14728 -> 14712;
14729 -> 14712;
14730 -> 14722;
14730 -> 0;
14730 -> 14712;
14731 -> 14730;
14732 -> 14730;
14733 -> 14731;
14733 -> 14732;
14734 -> 14714;
14734 -> 14732;
14735 -> 14733;
14735 -> 14732;
14736 -> 14732;
14737 -> 14735;
14737 -> 14736;
14738 -> 14734;
14738 -> 14736;
14739 -> 14738;
14739 -> 14681;
14739 -> 14736;
14740 -> 14736;
14741 -> 14739;
14742 -> 14738;
14742 -> 14681;
14742 -> 14739;
14743 -> 14737;
14743 -> 14739;
14744 -> 14741;
14744 -> 14739;
14745 -> 14739;
14746 -> 14743;
14746 -> 14745;
14747 -> 14744;
14747 -> 14745;
14748 -> 14738;
14748 -> 14745;
14749 -> 14745;
14750 -> 14748;
14750 -> 14749;
14751 -> 14750;
14751 -> 14745;
14752 -> 14745;
14753 -> 14745;
14754 -> 14746;
14754 -> 14753;
14754 -> 14745;
14755 -> 14746;
14755 -> 14745;
14756 -> 14745;
14757 -> 14748;
14757 -> 14756;
14758 -> 14757;
14758 -> 14745;
14759 -> 14755;
14759 -> 14758;
14759 -> 14681;
14759 -> 14695;
14759 -> 14745;
14760 -> 14745;
14761 -> 14745;
14762 -> 14745;
14763 -> 14745;
14764 -> 0;
14764 -> 14763;
14765 -> 14763;
14766 -> 14764;
14766 -> 14765;
14766 -> 14763;
14767 -> 14764;
14767 -> 14763;
14768 -> 14767;
14768 -> 14745;
14769 -> 14748;
14769 -> 14759;
14769 -> 14745;
14770 -> 14759;
14770 -> 14769;
14771 -> 14769;
14772 -> 14747;
14772 -> 14769;
14773 -> 14769;
14774 -> 14770;
14774 -> 14773;
14775 -> 14771;
14775 -> 14773;
14776 -> 14772;
14776 -> 14773;
14777 -> 14748;
14777 -> 14773;
14778 -> 14775;
14778 -> 14773;
14779 -> 14773;
14780 -> 14778;
14780 -> 14779;
14781 -> 14780;
14781 -> 14759;
14781 -> 14779;
14782 -> 14779;
14783 -> 14782;
14783 -> 14773;
14784 -> 14773;
14785 -> 14783;
14785 -> 14784;
14785 -> 14773;
14786 -> 14785;
14787 -> 14786;
14787 -> 14769;
14788 -> 14769;
14789 -> 14787;
14789 -> 14788;
14789 -> 14769;
14790 -> 14769;
14791 -> 14748;
14791 -> 14759;
14791 -> 0;
14791 -> 14769;
14792 -> 14769;
14793 -> 14761;
14793 -> 14792;
14793 -> 14769;
14794 -> 14760;
14794 -> 14769;
14795 -> 14769;
14796 -> 14748;
14796 -> 14795;
14797 -> 14796;
14797 -> 14759;
14797 -> 14795;
14798 -> 14795;
14799 -> 14797;
14799 -> 14798;
14800 -> 14799;
14800 -> 0;
14800 -> 14798;
14801 -> 0;
14801 -> 14800;
14802 -> 14801;
14802 -> 14769;
14803 -> 14769;
14804 -> 14748;
14804 -> 14803;
14805 -> 14803;
14806 -> 14804;
14806 -> 14805;
14807 -> 14806;
14807 -> 14803;
14808 -> 14807;
14808 -> 14769;
14809 -> 14802;
14809 -> 14808;
14809 -> 14769;
14810 -> 14768;
14810 -> 14764;
14810 -> 14769;
14811 -> 14747;
14811 -> 14769;
14812 -> 14769;
14813 -> 14812;
14813 -> 14769;
14814 -> 14769;
14815 -> 14790;
14815 -> 14769;
14816 -> 14811;
14816 -> 14813;
14816 -> 14815;
14816 -> 14741;
14816 -> 14769;
14817 -> 14761;
14817 -> 14769;
14818 -> 14794;
14818 -> 14769;
14819 -> 14817;
14819 -> 14818;
14819 -> 14794;
14819 -> 14760;
14819 -> 14769;
14820 -> 14739;
14821 -> 14742;
14821 -> 14819;
14821 -> 14820;
14821 -> 14816;
14821 -> 14739;
14822 -> 14741;
14822 -> 14821;
14823 -> 14821;
14824 -> 14822;
14824 -> 14823;
14825 -> 14738;
14825 -> 14823;
14826 -> 14823;
14827 -> 14825;
14827 -> 14826;
14828 -> 14827;
14828 -> 14823;
14829 -> 14824;
14829 -> 14821;
14829 -> 14823;
14830 -> 14821;
14831 -> 14741;
14831 -> 14821;
14831 -> 14739;
14832 -> 14738;
14832 -> 14831;
14832 -> 14736;
14833 -> 14712;
14834 -> 14832;
14834 -> 14833;
14834 -> 14712;
14835 -> 14722;
14835 -> 14834;
14836 -> 14835;
14837 -> 14714;
14837 -> 14836;
14838 -> 14836;
14839 -> 14837;
14839 -> 14831;
14839 -> 14838;
14840 -> 14839;
14840 -> 14831;
14840 -> 4335;
14840 -> 14838;
14841 -> 14840;
14841 -> 4362;
14841 -> 14838;
14842 -> 14841;
14842 -> 14836;
14843 -> 14842;
14843 -> 14835;
14844 -> 0;
14844 -> 14835;
14845 -> 14835;
14846 -> 14844;
14846 -> 14845;
14847 -> 14728;
14847 -> 14845;
14848 -> 14846;
14848 -> 0;
14848 -> 14845;
14849 -> 14845;
14850 -> 14846;
14850 -> 14845;
14851 -> 14847;
14851 -> 14850;
14851 -> 14831;
14851 -> 14845;
14852 -> 14851;
14853 -> 14852;
14854 -> 14852;
14854 -> 14851;
14855 -> 14846;
14855 -> 14851;
14856 -> 14851;
14857 -> 14855;
14857 -> 14856;
14858 -> 14854;
14858 -> 14856;
14859 -> 14856;
14860 -> 14858;
14860 -> 14859;
14861 -> 14860;
14861 -> 14856;
14862 -> 14861;
14863 -> 14861;
14863 -> 14862;
14864 -> 14862;
14865 -> 14863;
14865 -> 14864;
14866 -> 14864;
14867 -> 14865;
14867 -> 14852;
14867 -> 14866;
14867 -> 14864;
14868 -> 14862;
14869 -> 14863;
14869 -> 14852;
14869 -> 14862;
14870 -> 14869;
14870 -> 14861;
14871 -> 14861;
14872 -> 14856;
14873 -> 14858;
14873 -> 14852;
14873 -> 14872;
14873 -> 14856;
14874 -> 14858;
14874 -> 14852;
14874 -> 14857;
14874 -> 14856;
14875 -> 14845;
14876 -> 14858;
14876 -> 14875;
14877 -> 14876;
14877 -> 14845;
14878 -> 14858;
14878 -> 14845;
14879 -> 14878;
14879 -> 14712;
14880 -> 14714;
14880 -> 14712;
14881 -> 14712;
14882 -> 14879;
14882 -> 14881;
14883 -> 14880;
14883 -> 14881;
14884 -> 14881;
14885 -> 14882;
14885 -> 14884;
14885 -> 14881;
14886 -> 14881;
14887 -> 14883;
14887 -> 14886;
14887 -> 14881;
14888 -> 14883;
14888 -> 14881;
14889 -> 14881;
14890 -> 14882;
14890 -> 14889;
14891 -> 14889;
14892 -> 14891;
14892 -> 14881;
14893 -> 14881;
14894 -> 14882;
14894 -> 14893;
14894 -> 14881;
14895 -> 14882;
14896 -> 14882;
14897 -> 14892;
14897 -> 14882;
14898 -> 14882;
14899 -> 14898;
14900 -> 14882;
14901 -> 14892;
14901 -> 14900;
14901 -> 14882;
14902 -> 14882;
14902 -> 14881;
14903 -> 14881;
14904 -> 14902;
14904 -> 14882;
14904 -> 14903;
14905 -> 14904;
14905 -> 14882;
14905 -> 4335;
14905 -> 14903;
14906 -> 14905;
14906 -> 4362;
14906 -> 14903;
14907 -> 14906;
14907 -> 14881;
14908 -> 14882;
14908 -> 14881;
14909 -> 14712;
14910 -> 14714;
14910 -> 14909;
14911 -> 14712;
14912 -> 14712;
14913 -> 14878;
14913 -> 14712;
14914 -> 14712;
14915 -> 14913;
14915 -> 14914;
14916 -> 14914;
14917 -> 14916;
14917 -> 14712;
14918 -> 14712;
14919 -> 14714;
14919 -> 14918;
14920 -> 14918;
14921 -> 14919;
14921 -> 14920;
14922 -> 14920;
14922 -> 14918;
14923 -> 14919;
14923 -> 14882;
14923 -> 14918;
14924 -> 14923;
14924 -> 14712;
14925 -> 14917;
14925 -> 14924;
14925 -> 14712;
14926 -> 14913;
14926 -> 14712;
14927 -> 14912;
14927 -> 14712;
14928 -> 14712;
14929 -> 14926;
14929 -> 14928;
14930 -> 14927;
14930 -> 14928;
14931 -> 14928;
14932 -> 14929;
14932 -> 14931;
14933 -> 14932;
14933 -> 14882;
14933 -> 14931;
14934 -> 14933;
14935 -> 14933;
14936 -> 14933;
14936 -> 14935;
14937 -> 14935;
14937 -> 14933;
14938 -> 14933;
14939 -> 14933;
14940 -> 14938;
14940 -> 14939;
14941 -> 14939;
14942 -> 14940;
14942 -> 14941;
14943 -> 14941;
14944 -> 14942;
14944 -> 14943;
14945 -> 14943;
14946 -> 14944;
14946 -> 14882;
14946 -> 14945;
14946 -> 14943;
14947 -> 14941;
14948 -> 14942;
14948 -> 14882;
14948 -> 14910;
14948 -> 14941;
14949 -> 14948;
14949 -> 14939;
14950 -> 14939;
14951 -> 14933;
14951 -> 14882;
14951 -> 14910;
14952 -> 14951;
14953 -> 14951;
14954 -> 14951;
14955 -> 14954;
14955 -> 14951;
14956 -> 14955;
14957 -> 14955;
14958 -> 14956;
14958 -> 14957;
14959 -> 14957;
14960 -> 14957;
14960 -> 14955;
14961 -> 14960;
14961 -> 14955;
14962 -> 14932;
14962 -> 14951;
14962 -> 14933;
14962 -> 14931;
14963 -> 14962;
14963 -> 14928;
14964 -> 14928;
14965 -> 14963;
14965 -> 14964;
14965 -> 14928;
14966 -> 14712;
14967 -> 14712;
14968 -> 14913;
14968 -> 14967;
14969 -> 14968;
14969 -> 14951;
14969 -> 14967;
14970 -> 14968;
14970 -> 14951;
14970 -> 14967;
14971 -> 14970;
14971 -> 14712;
14972 -> 14712;
14973 -> 14971;
14973 -> 14972;
14973 -> 14712;
14974 -> 14930;
14974 -> 14712;
14975 -> 14878;
14975 -> 14712;
14976 -> 14975;
14976 -> 14703;
14977 -> 14702;
14977 -> 14951;
14977 -> 14703;
14978 -> 14976;
14978 -> 14703;
14979 -> 4436;
14979 -> 14703;
14980 -> 14977;
14980 -> 14978;
14980 -> 14979;
14980 -> 14951;
14980 -> 14933;
14980 -> 14703;
14981 -> 14710;
14981 -> 14980;
14982 -> 14980;
14983 -> 14981;
14983 -> 14982;
14984 -> 14702;
14984 -> 14982;
14985 -> 14982;
14986 -> 14984;
14986 -> 14985;
14987 -> 14986;
14987 -> 14982;
14988 -> 14983;
14988 -> 14710;
14988 -> 14982;
14989 -> 14980;
14990 -> 14710;
14990 -> 14703;
14991 -> 14702;
14991 -> 14980;
14991 -> 14701;
14992 -> 14991;
14992 -> 14698;
14993 -> 14698;
14994 -> 14992;
14994 -> 14993;
14994 -> 14698;
14995 -> 14698;
14996 -> 14992;
14996 -> 14698;
14997 -> 14698;
14998 -> 14996;
14998 -> 14997;
14999 -> 14998;
14999 -> 14997;
15000 -> 14997;
15001 -> 14997;
15002 -> 14999;
15002 -> 15001;
15003 -> 15000;
15003 -> 15001;
15004 -> 15000;
15004 -> 15001;
15005 -> 15000;
15005 -> 15001;
15006 -> 15001;
15007 -> 15002;
15007 -> 15001;
15008 -> 15003;
15008 -> 15001;
15009 -> 15004;
15009 -> 15001;
15010 -> 15005;
15010 -> 15001;
15011 -> 15001;
15012 -> 15006;
15012 -> 15011;
15013 -> 15007;
15013 -> 15011;
15014 -> 15006;
15014 -> 15011;
15015 -> 15008;
15015 -> 15011;
15016 -> 15009;
15016 -> 15011;
15017 -> 15010;
15017 -> 15011;
15018 -> 15006;
15018 -> 15011;
15019 -> 15011;
15020 -> 15012;
15020 -> 15019;
15021 -> 15020;
15021 -> 15006;
15021 -> 15019;
15022 -> 15021;
15022 -> 15019;
15023 -> 15022;
15023 -> 15011;
15024 -> 15013;
15024 -> 15011;
15025 -> 15023;
15025 -> 15024;
15025 -> 15011;
15026 -> 15011;
15027 -> 15017;
15027 -> 15026;
15027 -> 15011;
15028 -> 15018;
15028 -> 15026;
15028 -> 15011;
15029 -> 15027;
15029 -> 15028;
15029 -> 15011;
15030 -> 15011;
15031 -> 15013;
15031 -> 15030;
15032 -> 15030;
15033 -> 15030;
15034 -> 15031;
15034 -> 15033;
15035 -> 15034;
15035 -> 15030;
15036 -> 15035;
15037 -> 15031;
15037 -> 15036;
15038 -> 15037;
15038 -> 14980;
15038 -> 15036;
15039 -> 15038;
15039 -> 15035;
15040 -> 15035;
15041 -> 15039;
15041 -> 15040;
15041 -> 15035;
15042 -> 15030;
15043 -> 15012;
15043 -> 15042;
15044 -> 15043;
15044 -> 15006;
15044 -> 15042;
15045 -> 15044;
15045 -> 15042;
15046 -> 15045;
15046 -> 15030;
15047 -> 15046;
15048 -> 15015;
15048 -> 15047;
15048 -> 15046;
15049 -> 15031;
15049 -> 15048;
15050 -> 15016;
15050 -> 15048;
15051 -> 15032;
15051 -> 15048;
15052 -> 15049;
15052 -> 15050;
15052 -> 15051;
15052 -> 15015;
15052 -> 14980;
15052 -> 15000;
15052 -> 15048;
15053 -> 15048;
15054 -> 15052;
15054 -> 15053;
15055 -> 15053;
15056 -> 15054;
15056 -> 15055;
15056 -> 15053;
15057 -> 15054;
15057 -> 15053;
15058 -> 15030;
15059 -> 15058;
15059 -> 15030;
15060 -> 15030;
15061 -> 15031;
15061 -> 15060;
15062 -> 15061;
15062 -> 15052;
15062 -> 15060;
15063 -> 15062;
15063 -> 15030;
15064 -> 15063;
15065 -> 15031;
15065 -> 15064;
15066 -> 0;
15066 -> 15064;
15067 -> 15066;
15067 -> 15063;
15068 -> 15067;
15068 -> 0;
15068 -> 15063;
15069 -> 15068;
15070 -> 15069;
15070 -> 14997;
15071 -> 15070;
15071 -> 14698;
15072 -> 14992;
15072 -> 15071;
15073 -> 15071;
15074 -> 15072;
15074 -> 15073;
15075 -> 14700;
15075 -> 15073;
15076 -> 15075;
15076 -> 15052;
15076 -> 15073;
15077 -> 15076;
15078 -> 15076;
15079 -> 15077;
15079 -> 15078;
15080 -> 15079;
15080 -> 15052;
15080 -> 15078;
15081 -> 15078;
15082 -> 15081;
15082 -> 15076;
15083 -> 15076;
15084 -> 15082;
15084 -> 15083;
15084 -> 15076;
15085 -> 15073;
15086 -> 15085;
15086 -> 15071;
15087 -> 14700;
15087 -> 15071;
15088 -> 15071;
15089 -> 15087;
15089 -> 15088;
15090 -> 15088;
15091 -> 15089;
15091 -> 15090;
15091 -> 15088;
15092 -> 15088;
15093 -> 15089;
15093 -> 15092;
15094 -> 15093;
15094 -> 15088;
15095 -> 14992;
15095 -> 15071;
15096 -> 15071;
15097 -> 15095;
15097 -> 15096;
15098 -> 15096;
15099 -> 15097;
15099 -> 15098;
15100 -> 15099;
15100 -> 15096;
15101 -> 15094;
15101 -> 15100;
15101 -> 15071;
15102 -> 14698;
15103 -> 14700;
15103 -> 15102;
15104 -> 15103;
15104 -> 15102;
15105 -> 15102;
15106 -> 15104;
15107 -> 15104;
15107 -> 15106;
15108 -> 15106;
15109 -> 15107;
15109 -> 15108;
15110 -> 15108;
15111 -> 15109;
15111 -> 15110;
15112 -> 15111;
15112 -> 15052;
15112 -> 15110;
15113 -> 15112;
15114 -> 15111;
15114 -> 15052;
15114 -> 15112;
15115 -> 15113;
15115 -> 15112;
15116 -> 15113;
15116 -> 15115;
15117 -> 15115;
15118 -> 15116;
15118 -> 15117;
15119 -> 15111;
15119 -> 15117;
15120 -> 15117;
15121 -> 15119;
15121 -> 15120;
15122 -> 15121;
15122 -> 15117;
15123 -> 15118;
15123 -> 15115;
15123 -> 15117;
15124 -> 15115;
15125 -> 15113;
15125 -> 15115;
15125 -> 15112;
15126 -> 15111;
15126 -> 15125;
15126 -> 15110;
15127 -> 15126;
15127 -> 15108;
15129 -> 15128;
15130 -> 0;
15131 -> 15130;
15131 -> 0;
15132 -> 15131;
15134 -> 15133;
15135 -> 15132;
15135 -> 15133;
15136 -> 15135;
15136 -> 15134;
15137 -> 15134;
15138 -> 15137;
15139 -> 15137;
15139 -> 15134;
15140 -> 15136;
15140 -> 15137;
15140 -> 15134;
15141 -> 15132;
15141 -> 15133;
15142 -> 15133;
15143 -> 15108;
15144 -> 15127;
15144 -> 15143;
15145 -> 15144;
15145 -> 15143;
15146 -> 15143;
15147 -> 15145;
15147 -> 15106;
15148 -> 15147;
15148 -> 15104;
15149 -> 15104;
15150 -> 15104;
15151 -> 15104;
15151 -> 15150;
15152 -> 15151;
15152 -> 15145;
15152 -> 15150;
15153 -> 15102;
15154 -> 15153;
15154 -> 14698;
15155 -> 14698;
15156 -> 14700;
15156 -> 15155;
15157 -> 15156;
15157 -> 15145;
15157 -> 15155;
15158 -> 15157;
15159 -> 15157;
15160 -> 15158;
15160 -> 15159;
15161 -> 15160;
15161 -> 15145;
15161 -> 15159;
15162 -> 15159;
15163 -> 15162;
15163 -> 15157;
15164 -> 15157;
15165 -> 15163;
15165 -> 15164;
15165 -> 15157;
15166 -> 15155;
15167 -> 15166;
15167 -> 14698;
15168 -> 14698;
15169 -> 15167;
15169 -> 15168;
15169 -> 14698;
15170 -> 14700;
15170 -> 14698;
15171 -> 14698;
15172 -> 15170;
15172 -> 15171;
15173 -> 15171;
15174 -> 15172;
15174 -> 15173;
15174 -> 15171;
15175 -> 15171;
15176 -> 15172;
15176 -> 15175;
15177 -> 15175;
15178 -> 15176;
15178 -> 15145;
15178 -> 15177;
15179 -> 15178;
15179 -> 15171;
15180 -> 14992;
15180 -> 14698;
15181 -> 14698;
15182 -> 15180;
15182 -> 15181;
15183 -> 15181;
15184 -> 15182;
15184 -> 15183;
15185 -> 15184;
15185 -> 15145;
15185 -> 15183;
15186 -> 15185;
15186 -> 15181;
15187 -> 15179;
15187 -> 15186;
15187 -> 14698;
15188 -> 14695;
15189 -> 14696;
15189 -> 14695;
15190 -> 14695;
15191 -> 15189;
15191 -> 15190;
15192 -> 14507;
15192 -> 15190;
15193 -> 15190;
15194 -> 15192;
15194 -> 15193;
15195 -> 15194;
15195 -> 15145;
15195 -> 15193;
15196 -> 15195;
15196 -> 15190;
15197 -> 15191;
15197 -> 14696;
15197 -> 15190;
15198 -> 14695;
15199 -> 0;
15199 -> 14695;
15200 -> 14695;
15201 -> 15199;
15201 -> 15200;
15202 -> 14507;
15202 -> 15145;
15202 -> 15200;
15203 -> 15202;
15203 -> 15201;
15203 -> 15200;
15204 -> 14696;
15204 -> 14695;
15205 -> 14681;
15205 -> 14508;
15206 -> 15205;
15206 -> 14663;
15207 -> 14507;
15207 -> 15145;
15207 -> 14663;
15208 -> 15206;
15208 -> 14663;
15209 -> 15208;
15209 -> 14668;
15210 -> 15207;
15210 -> 14668;
15211 -> 15210;
15211 -> 15145;
15211 -> 15203;
15211 -> 15209;
15211 -> 14668;
15212 -> 15211;
15213 -> 15203;
15213 -> 14510;
15214 -> 15213;
15214 -> 14513;
15215 -> 15214;
15215 -> 14515;
15215 -> 14513;
15216 -> 0;
15216 -> 15203;
15217 -> 15203;
15218 -> 15216;
15218 -> 15217;
15219 -> 15218;
15220 -> 15219;
15220 -> 15218;
15221 -> 15218;
15222 -> 15220;
15222 -> 15221;
15223 -> 14507;
15223 -> 15221;
15224 -> 15221;
15225 -> 15223;
15225 -> 15224;
15226 -> 15224;
15227 -> 15225;
15227 -> 15226;
15228 -> 15227;
15228 -> 15203;
15228 -> 15226;
15229 -> 15226;
15230 -> 15228;
15230 -> 15229;
15230 -> 15226;
15231 -> 15227;
15231 -> 15226;
15232 -> 15226;
15233 -> 15231;
15234 -> 15233;
15234 -> 15231;
15235 -> 15234;
15235 -> 15231;
15236 -> 15235;
15237 -> 15235;
15237 -> 15236;
15238 -> 15231;
15238 -> 15236;
15239 -> 15238;
15239 -> 15203;
15239 -> 15218;
15239 -> 15236;
15240 -> 15239;
15241 -> 15237;
15241 -> 15240;
15241 -> 15239;
15242 -> 15239;
15243 -> 15237;
15243 -> 15239;
15244 -> 15242;
15244 -> 15239;
15245 -> 15239;
15246 -> 15243;
15246 -> 15245;
15247 -> 15244;
15247 -> 15245;
15248 -> 15238;
15248 -> 15245;
15249 -> 15245;
15250 -> 15248;
15250 -> 15249;
15251 -> 15250;
15251 -> 15245;
15252 -> 15251;
15252 -> 0;
15252 -> 15245;
15253 -> 15246;
15253 -> 15245;
15254 -> 15245;
15255 -> 15253;
15255 -> 15254;
15256 -> 15248;
15256 -> 15254;
15257 -> 15255;
15257 -> 15254;
15258 -> 15254;
15259 -> 15257;
15259 -> 15258;
15260 -> 15256;
15260 -> 15258;
15261 -> 15260;
15261 -> 15254;
15262 -> 15261;
15262 -> 15245;
15263 -> 15251;
15263 -> 0;
15263 -> 15245;
15264 -> 15263;
15264 -> 15245;
15265 -> 15264;
15266 -> 15262;
15266 -> 15245;
15267 -> 15263;
15267 -> 15245;
15268 -> 15262;
15268 -> 15267;
15269 -> 15268;
15269 -> 15239;
15270 -> 15238;
15270 -> 15203;
15270 -> 15239;
15271 -> 15269;
15271 -> 15239;
15272 -> 15239;
15273 -> 15242;
15273 -> 15271;
15274 -> 15271;
15275 -> 15273;
15275 -> 15274;
15276 -> 15238;
15276 -> 15274;
15277 -> 15274;
15278 -> 15276;
15278 -> 15277;
15279 -> 15278;
15279 -> 15274;
15280 -> 15275;
15280 -> 15242;
15280 -> 15274;
15281 -> 15271;
15282 -> 15242;
15282 -> 15239;
15283 -> 15238;
15283 -> 15271;
15283 -> 15236;
15284 -> 15283;
15284 -> 15271;
15284 -> 15231;
15285 -> 15231;
15286 -> 15285;
15286 -> 15271;
15287 -> 15285;
15287 -> 15271;
15288 -> 15287;
15289 -> 15287;
15290 -> 15289;
15290 -> 15271;
15290 -> 15287;
15291 -> 15289;
15291 -> 15271;
15291 -> 15290;
15292 -> 15290;
15293 -> 15289;
15293 -> 15292;
15294 -> 15292;
15295 -> 15292;
15296 -> 15294;
15296 -> 15295;
15297 -> 15293;
15297 -> 15295;
15298 -> 15297;
15298 -> 15271;
15298 -> 15295;
15299 -> 15297;
15299 -> 15271;
15299 -> 15298;
15300 -> 15298;
15301 -> 15297;
15301 -> 15300;
15302 -> 15300;
15303 -> 15301;
15303 -> 15302;
15304 -> 15302;
15305 -> 15303;
15305 -> 15304;
15306 -> 15304;
15306 -> 15302;
15307 -> 15303;
15307 -> 15300;
15308 -> 15300;
15309 -> 15307;
15309 -> 15308;
15310 -> 15309;
15310 -> 15300;
15311 -> 15301;
15311 -> 15271;
15311 -> 15300;
15312 -> 15300;
15313 -> 15310;
15313 -> 15312;
15313 -> 15300;
15314 -> 11869;
15314 -> 15300;
15315 -> 15314;
15315 -> 15298;
15316 -> 15298;
15317 -> 15299;
15317 -> 15315;
15317 -> 15316;
15317 -> 0;
15317 -> 15310;
15317 -> 15271;
15317 -> 15298;
15318 -> 15297;
15318 -> 15317;
15318 -> 15295;
15319 -> 15318;
15319 -> 15292;
15320 -> 15292;
15321 -> 15293;
15321 -> 15320;
15322 -> 15321;
15322 -> 15317;
15322 -> 15320;
15323 -> 15322;
15323 -> 15292;
15324 -> 15319;
15324 -> 15323;
15325 -> 15324;
15325 -> 15290;
15326 -> 15290;
15327 -> 15289;
15327 -> 15325;
15327 -> 15287;
15328 -> 15327;
15328 -> 15325;
15328 -> 15287;
15329 -> 4124;
15329 -> 15226;
15330 -> 4124;
15330 -> 15227;
15330 -> 15226;
15331 -> 15329;
15331 -> 15226;
15332 -> 15331;
15332 -> 15224;
15333 -> 15332;
15333 -> 4124;
15333 -> 15224;
15334 -> 4118;
15334 -> 4117;
15334 -> 15333;
15335 -> 4118;
15335 -> 15333;
15336 -> 15335;
15336 -> 15221;
15337 -> 15336;
15337 -> 4117;
15337 -> 15221;
15338 -> 15337;
15339 -> 15218;
15340 -> 15219;
15340 -> 15218;
15341 -> 15218;
15342 -> 15340;
15342 -> 15341;
15343 -> 14507;
15343 -> 15341;
15344 -> 15341;
15345 -> 15343;
15345 -> 15344;
15346 -> 15345;
15346 -> 15325;
15346 -> 15344;
15347 -> 15346;
15347 -> 15341;
15348 -> 15342;
15348 -> 15219;
15348 -> 15341;
15349 -> 15218;
15350 -> 0;
15350 -> 15218;
15351 -> 15218;
15352 -> 15350;
15352 -> 15351;
15353 -> 14507;
15353 -> 15325;
15353 -> 15351;
15354 -> 15353;
15354 -> 15352;
15354 -> 15351;
15355 -> 15219;
15355 -> 15218;
15356 -> 15203;
15356 -> 14508;
15357 -> 15356;
15357 -> 14663;
15358 -> 14507;
15358 -> 15325;
15358 -> 14663;
15359 -> 15357;
15359 -> 14663;
15360 -> 15359;
15360 -> 14668;
15361 -> 15358;
15361 -> 14668;
15362 -> 15361;
15362 -> 15325;
15362 -> 15354;
15362 -> 15360;
15362 -> 14668;
15363 -> 15362;
15364 -> 14506;
15364 -> 15325;
15364 -> 15330;
15364 -> 15354;
15364 -> 4121;
15364 -> 4122;
15364 -> 4123;
15364 -> 14508;
15365 -> 15364;
15365 -> 14510;
15366 -> 15365;
15366 -> 14513;
15367 -> 15366;
15367 -> 14515;
15367 -> 14513;
15368 -> 15364;
15369 -> 14507;
15369 -> 15368;
15370 -> 15369;
15370 -> 15364;
15370 -> 15368;
15371 -> 4436;
15371 -> 15368;
15372 -> 15370;
15373 -> 15369;
15373 -> 15364;
15373 -> 15370;
15374 -> 15372;
15374 -> 15370;
15375 -> 15370;
15376 -> 15374;
15376 -> 15375;
15377 -> 15369;
15377 -> 15375;
15378 -> 15375;
15379 -> 15377;
15379 -> 15378;
15380 -> 15379;
15380 -> 15375;
15381 -> 15380;
15382 -> 15381;
15382 -> 15370;
15383 -> 4436;
15383 -> 15370;
15384 -> 15372;
15384 -> 15382;
15385 -> 15382;
15386 -> 15384;
15386 -> 15385;
15387 -> 15369;
15387 -> 15385;
15388 -> 15385;
15389 -> 15387;
15389 -> 15388;
15390 -> 15389;
15390 -> 15385;
15391 -> 15386;
15391 -> 15372;
15391 -> 15385;
15392 -> 15382;
15393 -> 0;
15393 -> 15382;
15394 -> 15382;
15395 -> 15393;
15395 -> 15394;
15396 -> 15372;
15396 -> 15370;
15397 -> 15369;
15397 -> 15382;
15397 -> 15368;
15398 -> 15397;
15398 -> 15364;
15399 -> 15364;
15399 -> 14508;
15400 -> 15399;
15400 -> 14663;
15401 -> 14507;
15401 -> 15382;
15401 -> 14663;
15402 -> 15400;
15402 -> 14663;
15403 -> 15402;
15403 -> 14668;
15404 -> 15401;
15404 -> 14668;
15405 -> 15404;
15405 -> 15382;
15405 -> 15395;
15405 -> 15403;
15405 -> 14668;
15406 -> 15405;
15407 -> 15395;
15407 -> 14510;
15408 -> 15407;
15408 -> 14513;
15409 -> 15408;
15409 -> 14515;
15409 -> 14513;
15410 -> 15395;
15411 -> 15410;
15411 -> 15395;
15412 -> 0;
15412 -> 15395;
15413 -> 15395;
15414 -> 15412;
15414 -> 15413;
15415 -> 15395;
15415 -> 14508;
15416 -> 15415;
15416 -> 14663;
15417 -> 14507;
15417 -> 15395;
15417 -> 14663;
15418 -> 15416;
15418 -> 14663;
15419 -> 15418;
15419 -> 14668;
15420 -> 15417;
15420 -> 14668;
15421 -> 15420;
15421 -> 15395;
15421 -> 15414;
15421 -> 15419;
15421 -> 14668;
15422 -> 15421;
15423 -> 15414;
15423 -> 14510;
15424 -> 15423;
15424 -> 14513;
15425 -> 15424;
15425 -> 14515;
15425 -> 14513;
15426 -> 15414;
15427 -> 14507;
15427 -> 15426;
15428 -> 0;
15428 -> 15426;
15429 -> 15426;
15430 -> 15428;
15430 -> 15429;
15431 -> 15427;
15431 -> 15414;
15431 -> 15429;
15432 -> 15431;
15432 -> 15414;
15432 -> 15430;
15432 -> 15429;
15433 -> 15426;
15434 -> 15427;
15434 -> 15433;
15435 -> 15433;
15436 -> 15434;
15436 -> 15414;
15436 -> 15435;
15436 -> 15433;
15437 -> 15436;
15438 -> 15437;
15438 -> 15436;
15439 -> 15436;
15440 -> 15438;
15440 -> 15439;
15441 -> 15434;
15441 -> 15439;
15442 -> 15439;
15443 -> 15439;
15444 -> 15441;
15444 -> 15443;
15445 -> 15444;
15445 -> 15414;
15445 -> 15443;
15446 -> 15443;
15447 -> 15445;
15447 -> 15446;
15447 -> 15443;
15448 -> 15443;
15449 -> 15448;
15449 -> 15443;
15450 -> 15443;
15451 -> 15449;
15451 -> 15450;
15452 -> 15444;
15452 -> 15450;
15453 -> 15450;
15454 -> 15452;
15454 -> 15453;
15455 -> 15454;
15455 -> 15414;
15455 -> 15453;
15456 -> 15455;
15456 -> 4147;
15456 -> 15453;
15457 -> 15454;
15457 -> 15414;
15457 -> 15453;
15458 -> 15453;
15459 -> 15458;
15459 -> 15453;
15460 -> 15453;
15461 -> 15459;
15461 -> 15460;
15462 -> 15454;
15462 -> 15460;
15463 -> 15460;
15464 -> 15460;
15465 -> 15463;
15465 -> 15464;
15466 -> 15464;
15467 -> 15466;
15467 -> 15465;
15467 -> 15464;
15468 -> 15464;
15469 -> 15468;
15469 -> 15465;
15469 -> 15464;
15470 -> 15464;
15471 -> 15470;
15471 -> 15465;
15471 -> 15464;
15472 -> 15465;
15472 -> 15464;
15473 -> 15465;
15473 -> 15464;
15474 -> 15465;
15474 -> 15464;
15475 -> 15464;
15476 -> 15475;
15476 -> 15465;
15476 -> 15464;
15477 -> 15465;
15477 -> 15464;
15478 -> 15465;
15478 -> 15464;
15479 -> 15463;
15479 -> 15460;
15480 -> 15461;
15480 -> 15460;
15481 -> 15460;
15482 -> 15479;
15482 -> 15481;
15483 -> 15480;
15483 -> 15481;
15484 -> 15462;
15484 -> 15481;
15485 -> 15484;
15485 -> 15457;
15485 -> 15481;
15486 -> 15485;
15486 -> 15457;
15487 -> 15460;
15488 -> 15460;
15489 -> 15462;
15489 -> 15488;
15490 -> 15489;
15490 -> 15457;
15490 -> 15488;
15491 -> 15490;
15491 -> 15460;
15492 -> 15460;
15493 -> 15462;
15493 -> 15492;
15494 -> 15492;
15495 -> 15494;
15495 -> 15492;
15496 -> 15492;
15497 -> 15495;
15497 -> 15496;
15498 -> 15493;
15498 -> 15496;
15499 -> 15496;
15500 -> 15498;
15500 -> 15499;
15501 -> 15499;
15502 -> 15501;
15502 -> 15496;
15503 -> 15496;
15504 -> 15498;
15504 -> 15503;
15505 -> 15504;
15505 -> 15457;
15505 -> 15503;
15506 -> 15505;
15506 -> 15496;
15507 -> 15496;
15508 -> 15506;
15508 -> 15507;
15509 -> 15507;
15509 -> 15496;
15510 -> 15502;
15510 -> 15509;
15510 -> 15496;
15511 -> 15496;
15512 -> 15498;
15512 -> 15511;
15513 -> 15512;
15513 -> 15457;
15513 -> 15511;
15514 -> 15513;
15514 -> 15496;
15515 -> 15496;
15516 -> 15514;
15516 -> 15515;
15517 -> 15516;
15517 -> 15515;
15518 -> 15517;
15518 -> 15457;
15518 -> 15515;
15519 -> 15496;
15520 -> 15518;
15520 -> 15519;
15521 -> 15519;
15522 -> 15520;
15522 -> 15521;
15523 -> 15522;
15524 -> 15522;
15524 -> 15523;
15525 -> 15524;
15525 -> 15457;
15525 -> 15523;
15526 -> 15525;
15527 -> 15521;
15528 -> 15527;
15528 -> 15519;
15529 -> 15519;
15530 -> 15528;
15530 -> 15496;
15531 -> 15496;
15532 -> 15510;
15532 -> 15530;
15532 -> 15496;
15533 -> 15496;
15534 -> 15498;
15534 -> 15533;
15535 -> 15534;
15535 -> 15457;
15535 -> 15533;
15536 -> 15535;
15536 -> 15496;
15537 -> 15536;
15537 -> 4027;
15537 -> 15496;
15538 -> 15532;
15538 -> 15537;
15538 -> 15496;
15539 -> 15496;
15540 -> 15496;
15541 -> 15540;
15541 -> 15460;
15542 -> 15462;
15542 -> 15457;
15542 -> 15460;
15543 -> 15542;
15543 -> 4147;
15543 -> 15460;
15544 -> 15460;
15545 -> 15463;
15545 -> 15544;
15546 -> 15545;
15546 -> 15467;
15546 -> 15466;
15546 -> 15544;
15547 -> 15545;
15547 -> 15469;
15547 -> 15544;
15548 -> 15544;
15549 -> 15547;
15549 -> 15548;
15550 -> 15548;
15551 -> 15549;
15551 -> 15468;
15551 -> 15550;
15551 -> 15548;
15552 -> 15549;
15552 -> 15468;
15552 -> 15551;
15553 -> 0;
15553 -> 15551;
15554 -> 15545;
15554 -> 15471;
15554 -> 15544;
15555 -> 15544;
15556 -> 15554;
15556 -> 15555;
15557 -> 15555;
15558 -> 15556;
15558 -> 15470;
15558 -> 15557;
15558 -> 15555;
15559 -> 15556;
15559 -> 15470;
15559 -> 15558;
15560 -> 0;
15560 -> 15558;
15561 -> 15545;
15561 -> 15472;
15561 -> 15544;
15562 -> 15545;
15562 -> 15473;
15562 -> 15544;
15563 -> 15545;
15563 -> 15474;
15563 -> 15544;
15564 -> 15545;
15564 -> 15476;
15564 -> 15544;
15565 -> 15545;
15565 -> 15477;
15565 -> 15544;
15566 -> 15545;
15566 -> 15478;
15566 -> 15544;
15567 -> 15544;
15568 -> 15544;
15569 -> 15546;
15569 -> 15568;
15570 -> 15553;
15570 -> 15568;
15571 -> 15560;
15571 -> 15568;
15572 -> 15561;
15572 -> 15568;
15573 -> 15562;
15573 -> 15568;
15574 -> 15563;
15574 -> 15568;
15575 -> 15564;
15575 -> 15568;
15576 -> 15565;
15576 -> 15568;
15577 -> 15566;
15577 -> 15568;
15578 -> 15567;
15578 -> 15568;
15579 -> 15578;
15579 -> 15568;
15580 -> 15578;
15580 -> 15568;
15581 -> 15578;
15581 -> 15568;
15582 -> 15578;
15582 -> 15568;
15583 -> 15578;
15583 -> 15568;
15584 -> 15578;
15584 -> 15568;
15585 -> 15569;
15585 -> 15546;
15585 -> 15568;
15586 -> 15570;
15586 -> 0;
15586 -> 15568;
15587 -> 15571;
15587 -> 0;
15587 -> 15568;
15588 -> 15569;
15588 -> 15568;
15589 -> 15568;
15590 -> 15573;
15590 -> 15574;
15590 -> 15568;
15591 -> 15569;
15591 -> 15578;
15591 -> 15568;
15592 -> 15570;
15592 -> 15578;
15592 -> 15568;
15593 -> 15571;
15593 -> 15578;
15593 -> 15568;
15594 -> 15572;
15594 -> 15578;
15594 -> 15568;
15595 -> 15573;
15595 -> 15578;
15595 -> 15568;
15596 -> 15574;
15596 -> 15578;
15596 -> 15568;
15597 -> 15575;
15597 -> 15578;
15597 -> 15568;
15598 -> 15576;
15598 -> 15578;
15598 -> 15568;
15599 -> 15577;
15599 -> 15578;
15599 -> 15568;
15600 -> 15567;
15600 -> 15460;
15601 -> 15600;
15601 -> 15453;
15602 -> 15454;
15602 -> 15542;
15602 -> 15453;
15603 -> 15601;
15603 -> 15453;
15604 -> 4147;
15604 -> 15453;
15605 -> 15602;
15605 -> 15603;
15605 -> 15604;
15605 -> 15594;
15605 -> 15595;
15605 -> 15596;
15605 -> 15597;
15605 -> 15598;
15605 -> 15599;
15605 -> 15591;
15605 -> 15592;
15605 -> 15593;
15605 -> 4141;
15605 -> 4142;
15605 -> 4143;
15605 -> 4144;
15605 -> 4145;
15605 -> 4146;
15605 -> 15542;
15605 -> 15546;
15605 -> 15588;
15605 -> 0;
15605 -> 15453;
15606 -> 15605;
15606 -> 4147;
15606 -> 15453;
15607 -> 15458;
15607 -> 15453;
15608 -> 15453;
15609 -> 15607;
15609 -> 15608;
15610 -> 15454;
15610 -> 15608;
15611 -> 15608;
15612 -> 15610;
15612 -> 15611;
15613 -> 15612;
15613 -> 15605;
15613 -> 15611;
15614 -> 15613;
15614 -> 15608;
15615 -> 15609;
15615 -> 15458;
15615 -> 15608;
15616 -> 15453;
15617 -> 15458;
15617 -> 15453;
15618 -> 15601;
15618 -> 15453;
15619 -> 15618;
15619 -> 15450;
15620 -> 15619;
15620 -> 15450;
15621 -> 15619;
15621 -> 15450;
15622 -> 15450;
15623 -> 15450;
15624 -> 15621;
15624 -> 15623;
15625 -> 15622;
15625 -> 15623;
15626 -> 15625;
15626 -> 15623;
15627 -> 15625;
15627 -> 15623;
15628 -> 15625;
15628 -> 15623;
15629 -> 15625;
15629 -> 15623;
15630 -> 15624;
15630 -> 4147;
15630 -> 15623;
15631 -> 15624;
15631 -> 15605;
15631 -> 15625;
15631 -> 15623;
15632 -> 15624;
15632 -> 15605;
15632 -> 15625;
15632 -> 15623;
15633 -> 15622;
15633 -> 15450;
15634 -> 15619;
15634 -> 15450;
15635 -> 15451;
15635 -> 15450;
15636 -> 15450;
15637 -> 15633;
15637 -> 15636;
15638 -> 15634;
15638 -> 15636;
15639 -> 15635;
15639 -> 15636;
15640 -> 15452;
15640 -> 15636;
15641 -> 15636;
15642 -> 15640;
15642 -> 15641;
15643 -> 15642;
15643 -> 15605;
15643 -> 15641;
15644 -> 15643;
15644 -> 15636;
15645 -> 15637;
15645 -> 15644;
15646 -> 15638;
15646 -> 15644;
15647 -> 15639;
15647 -> 15644;
15648 -> 15644;
15649 -> 15645;
15649 -> 15648;
15650 -> 15646;
15650 -> 15648;
15651 -> 15647;
15651 -> 15648;
15652 -> 15640;
15652 -> 15648;
15653 -> 15652;
15653 -> 15605;
15653 -> 0;
15653 -> 15648;
15654 -> 15653;
15655 -> 15644;
15656 -> 15637;
15656 -> 15644;
15657 -> 15638;
15657 -> 15644;
15658 -> 15639;
15658 -> 15644;
15659 -> 15644;
15660 -> 15656;
15660 -> 15659;
15661 -> 15657;
15661 -> 15659;
15662 -> 15658;
15662 -> 15659;
15663 -> 15640;
15663 -> 15659;
15664 -> 15659;
15665 -> 15659;
15666 -> 15659;
15667 -> 15661;
15667 -> 15659;
15668 -> 15659;
15669 -> 15667;
15669 -> 15668;
15670 -> 15660;
15670 -> 15668;
15671 -> 15669;
15671 -> 15605;
15671 -> 15668;
15672 -> 15671;
15672 -> 15670;
15672 -> 15626;
15672 -> 15668;
15673 -> 15672;
15673 -> 15659;
15674 -> 15663;
15674 -> 15659;
15675 -> 15659;
15676 -> 15674;
15676 -> 15675;
15677 -> 15675;
15678 -> 15676;
15678 -> 15677;
15678 -> 15675;
15679 -> 15675;
15680 -> 15676;
15680 -> 15679;
15681 -> 15680;
15681 -> 15675;
15682 -> 15665;
15682 -> 15681;
15682 -> 15659;
15683 -> 15659;
15684 -> 15663;
15684 -> 15683;
15685 -> 0;
15685 -> 15683;
15686 -> 15683;
15687 -> 15685;
15687 -> 15686;
15688 -> 15684;
15688 -> 15686;
15689 -> 15688;
15689 -> 15605;
15689 -> 15687;
15689 -> 15686;
15690 -> 15686;
15691 -> 15689;
15691 -> 15690;
15691 -> 15686;
15692 -> 15691;
15692 -> 15659;
15693 -> 15664;
15693 -> 15692;
15693 -> 15659;
15694 -> 15659;
15695 -> 15663;
15695 -> 15694;
15696 -> 15694;
15697 -> 15695;
15697 -> 15696;
15698 -> 15697;
15698 -> 15694;
15699 -> 15698;
15699 -> 15659;
15700 -> 15693;
15700 -> 15699;
15700 -> 15659;
15701 -> 15682;
15701 -> 15700;
15701 -> 15659;
15702 -> 15701;
15703 -> 15702;
15703 -> 15701;
15704 -> 15703;
15704 -> 15701;
15705 -> 15704;
15706 -> 15704;
15706 -> 15705;
15707 -> 15704;
15707 -> 15705;
15708 -> 15705;
15709 -> 15707;
15709 -> 15708;
15710 -> 15708;
15711 -> 15709;
15711 -> 15708;
15712 -> 15707;
15712 -> 15705;
15713 -> 15705;
15714 -> 15706;
15714 -> 15713;
15714 -> 15705;
15715 -> 15706;
15715 -> 15707;
15715 -> 15705;
15716 -> 15661;
15716 -> 15701;
15717 -> 15701;
15718 -> 15704;
15718 -> 15717;
15719 -> 15716;
15719 -> 15717;
15720 -> 15660;
15720 -> 15717;
15721 -> 15720;
15721 -> 15626;
15721 -> 15717;
15722 -> 15721;
15723 -> 15719;
15723 -> 15605;
15723 -> 15722;
15723 -> 15721;
15724 -> 15723;
15724 -> 15720;
15724 -> 15721;
15725 -> 15719;
15725 -> 15605;
15725 -> 15721;
15726 -> 15720;
15726 -> 15724;
15726 -> 15725;
15726 -> 15723;
15726 -> 15605;
15726 -> 15721;
15727 -> 15718;
15727 -> 15717;
15728 -> 15720;
15728 -> 15724;
15728 -> 15727;
15728 -> 15726;
15728 -> 15709;
15728 -> 15711;
15728 -> 15715;
15728 -> 15717;
15729 -> 15701;
15730 -> 15661;
15730 -> 15728;
15730 -> 15659;
15731 -> 15659;
15732 -> 15730;
15732 -> 15731;
15733 -> 15732;
15733 -> 15731;
15734 -> 15731;
15735 -> 15666;
15735 -> 15733;
15735 -> 15659;
15736 -> 15659;
15737 -> 15663;
15737 -> 15736;
15738 -> 15736;
15739 -> 15737;
15739 -> 15733;
15739 -> 15738;
15739 -> 15736;
15740 -> 15739;
15740 -> 0;
15740 -> 15736;
15741 -> 15740;
15741 -> 15659;
15742 -> 15644;
15743 -> 15450;
15744 -> 15452;
15744 -> 15739;
15744 -> 15450;
15745 -> 15450;
15746 -> 15619;
15746 -> 15450;
15747 -> 15450;
15748 -> 15746;
15748 -> 15747;
15749 -> 15622;
15749 -> 15747;
15750 -> 15749;
15750 -> 15724;
15750 -> 15744;
15750 -> 15747;
15751 -> 15749;
15751 -> 15627;
15751 -> 15747;
15752 -> 15751;
15752 -> 15747;
15753 -> 15748;
15753 -> 15744;
15753 -> 15752;
15754 -> 15750;
15754 -> 15747;
15755 -> 15748;
15755 -> 15744;
15755 -> 15747;
15756 -> 15753;
15756 -> 15747;
15757 -> 15749;
15757 -> 15631;
15757 -> 15747;
15758 -> 15749;
15758 -> 15632;
15758 -> 15747;
15759 -> 15747;
15760 -> 15747;
15761 -> 15754;
15761 -> 15760;
15762 -> 15755;
15762 -> 15760;
15763 -> 15756;
15763 -> 15760;
15764 -> 15755;
15764 -> 15760;
15765 -> 15757;
15765 -> 15760;
15766 -> 15758;
15766 -> 15760;
15767 -> 15759;
15767 -> 15760;
15768 -> 15767;
15768 -> 15760;
15769 -> 15767;
15769 -> 15760;
15770 -> 15767;
15770 -> 15760;
15771 -> 15761;
15771 -> 15750;
15771 -> 15760;
15772 -> 15762;
15772 -> 15744;
15772 -> 15760;
15773 -> 15762;
15773 -> 15760;
15774 -> 15760;
15775 -> 15773;
15775 -> 15774;
15775 -> 15744;
15775 -> 15753;
15775 -> 15760;
15776 -> 15763;
15776 -> 15744;
15776 -> 15760;
15777 -> 15763;
15777 -> 15760;
15778 -> 15760;
15779 -> 15777;
15779 -> 15778;
15779 -> 15744;
15779 -> 15753;
15779 -> 15775;
15779 -> 15760;
15780 -> 15761;
15780 -> 15760;
15781 -> 15760;
15782 -> 15780;
15782 -> 15781;
15782 -> 15750;
15782 -> 15779;
15782 -> 15760;
15783 -> 15761;
15783 -> 15760;
15784 -> 15760;
15785 -> 15783;
15785 -> 15784;
15785 -> 15750;
15785 -> 15782;
15785 -> 15760;
15786 -> 15764;
15786 -> 15785;
15786 -> 15760;
15787 -> 15786;
15787 -> 15784;
15788 -> 15784;
15789 -> 15787;
15789 -> 15788;
15790 -> 0;
15790 -> 15788;
15791 -> 15790;
15791 -> 15784;
15792 -> 15786;
15792 -> 15791;
15792 -> 15760;
15793 -> 15761;
15793 -> 15767;
15793 -> 15760;
15794 -> 15762;
15794 -> 15767;
15794 -> 15760;
15795 -> 15763;
15795 -> 15767;
15795 -> 15760;
15796 -> 15764;
15796 -> 15767;
15796 -> 15760;
15797 -> 15765;
15797 -> 15767;
15797 -> 15760;
15798 -> 15766;
15798 -> 15767;
15798 -> 15760;
15799 -> 15759;
15799 -> 15450;
15800 -> 15799;
15800 -> 15443;
15801 -> 15444;
15801 -> 15785;
15801 -> 15443;
15802 -> 15800;
15802 -> 15443;
15803 -> 15443;
15804 -> 15801;
15804 -> 15802;
15804 -> 15803;
15804 -> 15796;
15804 -> 15797;
15804 -> 15798;
15804 -> 15793;
15804 -> 15794;
15804 -> 15795;
15804 -> 15785;
15804 -> 15750;
15804 -> 15744;
15804 -> 15753;
15804 -> 15443;
15805 -> 15443;
15806 -> 15804;
15806 -> 15805;
15806 -> 15443;
15807 -> 15448;
15807 -> 15443;
15808 -> 15443;
15809 -> 15807;
15809 -> 15808;
15810 -> 15444;
15810 -> 15808;
15811 -> 15808;
15812 -> 15810;
15812 -> 15811;
15813 -> 15812;
15813 -> 15804;
15813 -> 15811;
15814 -> 15813;
15814 -> 15808;
15815 -> 15809;
15815 -> 15448;
15815 -> 15808;
15816 -> 15443;
15817 -> 15448;
15817 -> 15443;
15818 -> 15443;
15819 -> 15818;
15819 -> 15444;
15819 -> 15443;
15820 -> 15800;
15820 -> 15443;
15821 -> 15820;
15821 -> 15439;
15822 -> 15439;
15823 -> 15441;
15823 -> 15822;
15824 -> 15822;
15825 -> 15824;
15825 -> 15822;
15826 -> 15822;
15827 -> 15825;
15827 -> 15826;
15828 -> 15823;
15828 -> 15826;
15829 -> 15826;
15830 -> 15828;
15830 -> 15829;
15831 -> 15829;
15832 -> 15831;
15832 -> 15826;
15833 -> 15826;
15834 -> 15828;
15834 -> 15833;
15835 -> 15834;
15835 -> 15804;
15835 -> 15833;
15836 -> 15835;
15836 -> 15826;
15837 -> 15826;
15838 -> 15836;
15838 -> 15837;
15839 -> 15837;
15839 -> 15826;
15840 -> 15832;
15840 -> 15839;
15840 -> 15826;
15841 -> 15826;
15842 -> 15828;
15842 -> 15841;
15843 -> 15842;
15843 -> 15804;
15843 -> 15841;
15844 -> 15843;
15844 -> 15826;
15845 -> 15826;
15846 -> 15844;
15846 -> 15845;
15847 -> 15846;
15847 -> 15845;
15848 -> 15847;
15848 -> 15804;
15848 -> 15845;
15849 -> 15826;
15850 -> 15848;
15850 -> 15849;
15851 -> 15849;
15852 -> 15850;
15852 -> 15851;
15853 -> 15852;
15854 -> 15852;
15854 -> 15853;
15855 -> 15854;
15855 -> 15804;
15855 -> 15853;
15856 -> 15855;
15857 -> 15851;
15858 -> 15857;
15858 -> 15849;
15859 -> 15849;
15860 -> 15858;
15860 -> 15826;
15861 -> 15826;
15862 -> 15840;
15862 -> 15860;
15862 -> 15826;
15863 -> 15826;
15864 -> 15828;
15864 -> 15863;
15865 -> 15864;
15865 -> 15804;
15865 -> 15819;
15865 -> 15863;
15866 -> 15865;
15866 -> 15826;
15867 -> 15866;
15867 -> 4027;
15867 -> 15826;
15868 -> 15862;
15868 -> 15867;
15868 -> 15826;
15869 -> 15826;
15870 -> 15826;
15871 -> 15870;
15871 -> 15439;
15872 -> 15821;
15872 -> 15804;
15872 -> 15871;
15872 -> 15439;
15873 -> 15821;
15873 -> 15804;
15873 -> 15872;
15874 -> 15872;
15875 -> 0;
15875 -> 15872;
15876 -> 15873;
15876 -> 15874;
15876 -> 15875;
15876 -> 15804;
15876 -> 15819;
15876 -> 15872;
15877 -> 15876;
15877 -> 15874;
15878 -> 12738;
15878 -> 15874;
15879 -> 15876;
15879 -> 15878;
15879 -> 15872;
15880 -> 15879;
15880 -> 15872;
15881 -> 15872;
15882 -> 15441;
15882 -> 15881;
15883 -> 15881;
15884 -> 15882;
15884 -> 15879;
15884 -> 15883;
15884 -> 15881;
15885 -> 15884;
15886 -> 15882;
15886 -> 15879;
15886 -> 15884;
15887 -> 15885;
15887 -> 15884;
15888 -> 15884;
15889 -> 15887;
15889 -> 15888;
15890 -> 15882;
15890 -> 15888;
15891 -> 15888;
15892 -> 15888;
15893 -> 15890;
15893 -> 15879;
15893 -> 15888;
15894 -> 15888;
15895 -> 15890;
15895 -> 15894;
15896 -> 15895;
15896 -> 15888;
15897 -> 15888;
15898 -> 4000;
15898 -> 3999;
15898 -> 15897;
15898 -> 15888;
15899 -> 15888;
15900 -> 15891;
15900 -> 15899;
15900 -> 15888;
15901 -> 15900;
15901 -> 15888;
15902 -> 4000;
15902 -> 15901;
15903 -> 15891;
15903 -> 15888;
15904 -> 15902;
15904 -> 15884;
15905 -> 15884;
15906 -> 15885;
15906 -> 15904;
15907 -> 15904;
15908 -> 15906;
15908 -> 15907;
15909 -> 15882;
15909 -> 15907;
15910 -> 15907;
15911 -> 15909;
15911 -> 15910;
15912 -> 15911;
15912 -> 15907;
15913 -> 15908;
15913 -> 15885;
15913 -> 15907;
15914 -> 15904;
15915 -> 0;
15915 -> 15904;
15916 -> 15904;
15917 -> 15915;
15917 -> 15916;
15918 -> 15885;
15918 -> 15884;
15919 -> 15882;
15919 -> 15904;
15919 -> 15881;
15920 -> 15919;
15920 -> 15872;
15921 -> 15872;
15922 -> 15880;
15922 -> 15921;
15923 -> 15920;
15923 -> 15921;
15924 -> 15923;
15924 -> 15921;
15925 -> 15924;
15925 -> 15904;
15925 -> 15917;
15925 -> 15921;
15926 -> 15872;
15927 -> 15879;
15927 -> 15439;
15928 -> 15440;
15928 -> 15439;
15929 -> 15439;
15930 -> 15927;
15930 -> 15929;
15931 -> 15928;
15931 -> 15929;
15932 -> 15441;
15932 -> 15929;
15933 -> 15930;
15933 -> 15904;
15933 -> 15929;
15934 -> 15930;
15934 -> 15904;
15934 -> 15929;
15935 -> 15933;
15935 -> 15934;
15935 -> 15904;
15935 -> 15917;
15935 -> 15929;
15936 -> 3463;
15936 -> 15929;
15937 -> 15933;
15937 -> 15929;
15938 -> 15937;
15938 -> 15935;
15938 -> 15929;
15939 -> 15936;
15939 -> 3453;
15939 -> 3454;
15939 -> 3455;
15939 -> 3456;
15939 -> 3457;
15939 -> 3458;
15939 -> 3459;
15939 -> 15938;
15940 -> 15930;
15940 -> 15938;
15940 -> 15935;
15941 -> 15940;
15942 -> 15941;
15942 -> 15940;
15943 -> 15936;
15943 -> 15939;
15943 -> 15940;
15944 -> 15933;
15944 -> 15940;
15945 -> 15439;
15946 -> 15930;
15946 -> 15439;
15947 -> 15946;
15947 -> 15436;
15948 -> 15434;
15948 -> 15944;
15948 -> 15436;
15949 -> 15947;
15949 -> 15436;
15950 -> 15436;
15951 -> 15948;
15951 -> 15949;
15951 -> 15950;
15951 -> 15944;
15951 -> 15436;
15952 -> 15437;
15952 -> 15951;
15953 -> 15951;
15954 -> 15952;
15954 -> 15953;
15955 -> 15434;
15955 -> 15953;
15956 -> 15953;
15957 -> 15955;
15957 -> 15956;
15958 -> 15957;
15958 -> 15953;
15959 -> 15954;
15959 -> 15437;
15959 -> 15953;
15960 -> 15951;
15961 -> 0;
15961 -> 15951;
15962 -> 15951;
15963 -> 15961;
15963 -> 15962;
15964 -> 15437;
15964 -> 15436;
15965 -> 0;
15965 -> 15433;
15966 -> 15433;
15967 -> 15433;
15968 -> 15965;
15968 -> 15967;
15969 -> 15966;
15969 -> 15967;
15970 -> 15434;
15970 -> 15951;
15970 -> 15967;
15971 -> 15968;
15971 -> 15967;
15972 -> 15967;
15973 -> 15971;
15973 -> 15972;
15974 -> 15970;
15974 -> 15972;
15975 -> 15974;
15975 -> 15951;
15975 -> 15963;
15975 -> 15973;
15975 -> 15972;
15976 -> 15975;
15977 -> 15434;
15977 -> 15951;
15977 -> 15433;
15978 -> 15977;
15978 -> 15426;
15979 -> 15978;
15979 -> 15414;
15980 -> 15414;
15980 -> 14508;
15981 -> 15980;
15981 -> 14663;
15982 -> 14507;
15982 -> 15951;
15982 -> 14663;
15983 -> 15981;
15983 -> 14663;
15984 -> 15983;
15984 -> 14668;
15985 -> 15982;
15985 -> 14668;
15986 -> 15985;
15986 -> 15951;
15986 -> 15963;
15986 -> 15984;
15986 -> 14668;
15987 -> 15986;
15988 -> 15963;
15988 -> 14510;
15989 -> 15988;
15989 -> 14513;
15990 -> 15989;
15990 -> 14515;
15990 -> 14513;
15991 -> 14506;
15991 -> 15963;
15992 -> 15963;
15993 -> 15991;
15993 -> 15992;
15994 -> 14507;
15994 -> 15992;
15995 -> 15994;
15995 -> 15963;
15995 -> 15992;
15996 -> 15995;
15997 -> 15993;
15997 -> 15963;
15997 -> 15995;
15998 -> 15996;
15998 -> 15995;
15999 -> 15993;
15999 -> 15995;
16000 -> 15995;
16001 -> 15998;
16001 -> 16000;
16002 -> 15999;
16002 -> 16000;
16003 -> 15994;
16003 -> 16000;
16004 -> 16000;
16005 -> 16003;
16005 -> 16004;
16006 -> 16005;
16006 -> 15997;
16006 -> 16004;
16007 -> 16006;
16007 -> 16000;
16008 -> 16000;
16009 -> 16003;
16009 -> 16008;
16010 -> 16009;
16010 -> 15997;
16010 -> 16008;
16011 -> 16010;
16011 -> 15997;
16011 -> 16008;
16012 -> 16011;
16013 -> 0;
16013 -> 16012;
16014 -> 16012;
16015 -> 16013;
16015 -> 16014;
16016 -> 16012;
16016 -> 15997;
16016 -> 16014;
16017 -> 16016;
16017 -> 15997;
16017 -> 16015;
16017 -> 16014;
16018 -> 16012;
16018 -> 15997;
16018 -> 16017;
16019 -> 16018;
16019 -> 16011;
16020 -> 16011;
16021 -> 16009;
16021 -> 16019;
16021 -> 16011;
16022 -> 16019;
16022 -> 16011;
16023 -> 16009;
16023 -> 16021;
16023 -> 16011;
16024 -> 16023;
16024 -> 16008;
16025 -> 16024;
16025 -> 16000;
16026 -> 16002;
16026 -> 15997;
16026 -> 16024;
16026 -> 16025;
16027 -> 16025;
16028 -> 16025;
16029 -> 16025;
16029 -> 16028;
16030 -> 0;
16030 -> 16028;
16031 -> 16030;
16031 -> 16025;
16032 -> 16025;
16032 -> 16031;
16033 -> 16031;
16034 -> 16032;
16034 -> 16033;
16035 -> 0;
16035 -> 16033;
16036 -> 16035;
16036 -> 16031;
16037 -> 16031;
16038 -> 16036;
16038 -> 16037;
16039 -> 16038;
16039 -> 16037;
16040 -> 16039;
16041 -> 16040;
16042 -> 16032;
16042 -> 16041;
16043 -> 16041;
16043 -> 16040;
16044 -> 15995;
16045 -> 15993;
16045 -> 16026;
16045 -> 15995;
16046 -> 15996;
16046 -> 15995;
16047 -> 15995;
16048 -> 16046;
16048 -> 16047;
16049 -> 15994;
16049 -> 16047;
16050 -> 16047;
16051 -> 16049;
16051 -> 16050;
16052 -> 16051;
16052 -> 16045;
16052 -> 16050;
16053 -> 16051;
16053 -> 16045;
16053 -> 16050;
16054 -> 16053;
16054 -> 16047;
16055 -> 16047;
16056 -> 16049;
16056 -> 16055;
16057 -> 0;
16057 -> 16055;
16058 -> 16055;
16059 -> 16057;
16059 -> 16058;
16060 -> 16056;
16060 -> 16058;
16061 -> 16060;
16061 -> 16045;
16061 -> 16059;
16061 -> 16058;
16062 -> 16061;
16062 -> 16047;
16063 -> 16047;
16064 -> 16054;
16064 -> 16063;
16064 -> 16047;
16065 -> 16062;
16065 -> 16064;
16065 -> 16047;
16066 -> 16047;
16067 -> 16054;
16067 -> 16066;
16068 -> 16067;
16068 -> 16045;
16068 -> 0;
16068 -> 16066;
16069 -> 16066;
16070 -> 16068;
16070 -> 16047;
16071 -> 16065;
16071 -> 16070;
16071 -> 16047;
16072 -> 16071;
16073 -> 15995;
16074 -> 15993;
16074 -> 16045;
16074 -> 15995;
16075 -> 15996;
16075 -> 15995;
16076 -> 15995;
16077 -> 16075;
16077 -> 16076;
16078 -> 15994;
16078 -> 16076;
16079 -> 16076;
16080 -> 16078;
16080 -> 16079;
16081 -> 16080;
16081 -> 16074;
16082 -> 16080;
16082 -> 16074;
16083 -> 16082;
16083 -> 16080;
16084 -> 16083;
16084 -> 16080;
16085 -> 16080;
16086 -> 16080;
16087 -> 16080;
16087 -> 16086;
16088 -> 16087;
16088 -> 16082;
16088 -> 16086;
16089 -> 16079;
16090 -> 16089;
16090 -> 16076;
16091 -> 16090;
16092 -> 15995;
16093 -> 15995;
16094 -> 16093;
16094 -> 16082;
16095 -> 16094;
16095 -> 15995;
16096 -> 15994;
16096 -> 16082;
16096 -> 15995;
16097 -> 15996;
16097 -> 15995;
16098 -> 15993;
16098 -> 15995;
16099 -> 15995;
16100 -> 16097;
16100 -> 16099;
16101 -> 16098;
16101 -> 16099;
16102 -> 15994;
16102 -> 16099;
16103 -> 16099;
16104 -> 16099;
16105 -> 16102;
16105 -> 16104;
16106 -> 16105;
16106 -> 16082;
16106 -> 16104;
16107 -> 16104;
16108 -> 16106;
16108 -> 16107;
16108 -> 16104;
16109 -> 16106;
16109 -> 4124;
16109 -> 16108;
16110 -> 16108;
16111 -> 16106;
16111 -> 16110;
16112 -> 16110;
16113 -> 16111;
16113 -> 16082;
16113 -> 16112;
16113 -> 16110;
16114 -> 16113;
16114 -> 16108;
16115 -> 16108;
16116 -> 16106;
16116 -> 16108;
16117 -> 16116;
16117 -> 16104;
16118 -> 16117;
16118 -> 4124;
16118 -> 16104;
16119 -> 4118;
16119 -> 4117;
16119 -> 16118;
16120 -> 4118;
16120 -> 16118;
16121 -> 16120;
16121 -> 16099;
16122 -> 16099;
16123 -> 16102;
16123 -> 16122;
16124 -> 16122;
16125 -> 16123;
16125 -> 16124;
16126 -> 16124;
16127 -> 16125;
16127 -> 16126;
16128 -> 16127;
16128 -> 16082;
16128 -> 16126;
16129 -> 16126;
16130 -> 16128;
16130 -> 16129;
16130 -> 16126;
16131 -> 16128;
16131 -> 4124;
16131 -> 16130;
16132 -> 16130;
16133 -> 16128;
16133 -> 16132;
16134 -> 16132;
16135 -> 16133;
16135 -> 16082;
16135 -> 16134;
16135 -> 16132;
16136 -> 16135;
16136 -> 16130;
16137 -> 16130;
16138 -> 16128;
16138 -> 16130;
16139 -> 16138;
16139 -> 16124;
16140 -> 16139;
16140 -> 4124;
16140 -> 16124;
16141 -> 11869;
16141 -> 16140;
16142 -> 16141;
16142 -> 16122;
16143 -> 16142;
16143 -> 16099;
16144 -> 16103;
16144 -> 16099;
16145 -> 16144;
16145 -> 15995;
16146 -> 15995;
16147 -> 16096;
16147 -> 16145;
16147 -> 16146;
16147 -> 16144;
16147 -> 16082;
16147 -> 16103;
16147 -> 15995;
16148 -> 15996;
16148 -> 16147;
16149 -> 16147;
16150 -> 16148;
16150 -> 16149;
16151 -> 15994;
16151 -> 16149;
16152 -> 16149;
16153 -> 16151;
16153 -> 16152;
16154 -> 16153;
16154 -> 16149;
16155 -> 16150;
16155 -> 15996;
16155 -> 16149;
16156 -> 16147;
16157 -> 0;
16157 -> 16147;
16158 -> 16147;
16159 -> 16157;
16159 -> 16158;
16160 -> 15996;
16160 -> 15995;
16161 -> 15994;
16161 -> 16147;
16161 -> 15992;
16162 -> 15963;
16162 -> 14508;
16163 -> 16162;
16163 -> 14663;
16164 -> 14507;
16164 -> 16147;
16164 -> 14663;
16165 -> 16163;
16165 -> 14663;
16166 -> 16165;
16166 -> 14668;
16167 -> 16164;
16167 -> 14668;
16168 -> 16167;
16168 -> 16147;
16168 -> 16159;
16168 -> 16166;
16168 -> 14668;
16169 -> 16168;
16170 -> 16159;
16170 -> 14510;
16171 -> 16170;
16171 -> 14513;
16172 -> 16171;
16172 -> 14515;
16172 -> 14513;
16173 -> 0;
16173 -> 16159;
16174 -> 16159;
16175 -> 16173;
16175 -> 16174;
16176 -> 16175;
16177 -> 16176;
16177 -> 16175;
16178 -> 16175;
16179 -> 16177;
16179 -> 16178;
16180 -> 14507;
16180 -> 16178;
16181 -> 16178;
16182 -> 16180;
16182 -> 16181;
16183 -> 16182;
16183 -> 16178;
16184 -> 16179;
16184 -> 16178;
16185 -> 16178;
16186 -> 16184;
16186 -> 16185;
16187 -> 16180;
16187 -> 16185;
16188 -> 16185;
16189 -> 16187;
16189 -> 16188;
16190 -> 16189;
16190 -> 16159;
16190 -> 16188;
16191 -> 16188;
16192 -> 16190;
16192 -> 16191;
16192 -> 16188;
16193 -> 16190;
16193 -> 16192;
16194 -> 16193;
16194 -> 16185;
16195 -> 16194;
16196 -> 16186;
16196 -> 16194;
16197 -> 16196;
16197 -> 16195;
16198 -> 16178;
16199 -> 16179;
16199 -> 16178;
16200 -> 16178;
16201 -> 16199;
16201 -> 16200;
16202 -> 16180;
16202 -> 16200;
16203 -> 16200;
16204 -> 16202;
16204 -> 16203;
16205 -> 16204;
16205 -> 16196;
16205 -> 16203;
16206 -> 16205;
16206 -> 16200;
16207 -> 16201;
16207 -> 16200;
16208 -> 16206;
16208 -> 16200;
16209 -> 16200;
16210 -> 16207;
16210 -> 16209;
16211 -> 16208;
16211 -> 16209;
16212 -> 16202;
16212 -> 16209;
16213 -> 16209;
16214 -> 16209;
16215 -> 16212;
16215 -> 16214;
16216 -> 16215;
16216 -> 16196;
16216 -> 16214;
16217 -> 16216;
16217 -> 16209;
16218 -> 16209;
16219 -> 3379;
16219 -> 16209;
16220 -> 16211;
16220 -> 16196;
16220 -> 16209;
16221 -> 16220;
16222 -> 16219;
16222 -> 3367;
16222 -> 3368;
16222 -> 3369;
16222 -> 3370;
16222 -> 3371;
16222 -> 3372;
16222 -> 3378;
16222 -> 16220;
16223 -> 16220;
16224 -> 16223;
16225 -> 16223;
16226 -> 16224;
16226 -> 16225;
16227 -> 16225;
16228 -> 16226;
16228 -> 16227;
16229 -> 0;
16229 -> 16227;
16230 -> 16229;
16230 -> 16225;
16231 -> 16230;
16231 -> 16223;
16232 -> 16213;
16232 -> 16209;
16233 -> 16200;
16234 -> 3379;
16234 -> 16200;
16235 -> 3379;
16235 -> 16200;
16237 -> 16236;
16238 -> 16236;
16239 -> 16200;
16240 -> 16238;
16240 -> 16239;
16241 -> 16240;
16241 -> 16200;
16242 -> 16206;
16242 -> 16200;
16243 -> 16242;
16243 -> 16196;
16244 -> 16243;
16244 -> 16242;
16245 -> 16242;
16246 -> 16244;
16246 -> 16245;
16247 -> 16202;
16247 -> 16245;
16248 -> 16245;
16249 -> 16248;
16249 -> 16245;
16250 -> 16245;
16251 -> 16247;
16251 -> 16250;
16252 -> 16251;
16252 -> 16196;
16252 -> 16250;
16253 -> 16252;
16253 -> 16245;
16254 -> 16246;
16254 -> 16245;
16255 -> 16248;
16255 -> 16245;
16256 -> 16253;
16256 -> 16254;
16256 -> 16255;
16256 -> 16196;
16256 -> 16249;
16256 -> 16245;
16257 -> 11869;
16257 -> 16245;
16258 -> 16257;
16258 -> 16242;
16259 -> 16234;
16259 -> 16222;
16259 -> 16242;
16260 -> 16242;
16260 -> 16196;
16261 -> 16260;
16261 -> 16256;
16261 -> 16196;
16261 -> 16242;
16262 -> 16261;
16263 -> 16261;
16263 -> 16262;
16264 -> 0;
16264 -> 16262;
16265 -> 16264;
16265 -> 16261;
16266 -> 16261;
16267 -> 16261;
16268 -> 16266;
16268 -> 16267;
16269 -> 16267;
16270 -> 16268;
16270 -> 16269;
16271 -> 0;
16271 -> 16269;
16272 -> 16271;
16272 -> 16267;
16273 -> 16268;
16273 -> 16267;
16274 -> 16267;
16275 -> 16273;
16275 -> 16274;
16276 -> 16274;
16277 -> 16275;
16277 -> 16276;
16278 -> 16276;
16279 -> 16278;
16279 -> 16274;
16280 -> 16274;
16281 -> 16279;
16281 -> 16267;
16282 -> 16272;
16282 -> 16281;
16282 -> 16267;
16283 -> 16282;
16283 -> 16261;
16284 -> 16265;
16284 -> 16283;
16284 -> 16261;
16285 -> 16261;
16286 -> 16266;
16286 -> 16285;
16287 -> 16285;
16288 -> 16286;
16288 -> 16287;
16289 -> 0;
16289 -> 16287;
16290 -> 16289;
16290 -> 16285;
16291 -> 16290;
16291 -> 16261;
16292 -> 16284;
16292 -> 16291;
16292 -> 16261;
16293 -> 16258;
16293 -> 16261;
16294 -> 16261;
16294 -> 16293;
16295 -> 16261;
16296 -> 16261;
16297 -> 16295;
16297 -> 16261;
16298 -> 16296;
16298 -> 16297;
16299 -> 16178;
16300 -> 16179;
16300 -> 16178;
16301 -> 16178;
16302 -> 16300;
16302 -> 16301;
16303 -> 16180;
16303 -> 16301;
16304 -> 16303;
16304 -> 16256;
16304 -> 0;
16304 -> 16301;
16305 -> 16304;
16306 -> 16178;
16307 -> 16179;
16307 -> 16178;
16308 -> 16178;
16309 -> 16307;
16309 -> 16308;
16310 -> 16180;
16310 -> 16308;
16311 -> 16308;
16312 -> 16310;
16312 -> 16311;
16313 -> 16311;
16314 -> 16312;
16314 -> 16313;
16315 -> 16314;
16315 -> 16256;
16315 -> 16313;
16316 -> 16315;
16316 -> 16311;
16317 -> 16311;
16318 -> 16316;
16318 -> 16317;
16318 -> 16311;
16319 -> 16318;
16319 -> 16311;
16320 -> 16319;
16321 -> 16316;
16321 -> 16320;
16322 -> 16320;
16323 -> 16321;
16323 -> 16256;
16323 -> 16322;
16324 -> 16323;
16324 -> 16308;
16325 -> 16308;
16326 -> 16324;
16326 -> 16325;
16327 -> 16308;
16328 -> 16308;
16329 -> 16326;
16329 -> 16328;
16330 -> 16327;
16330 -> 16328;
16331 -> 16327;
16331 -> 16328;
16332 -> 16329;
16332 -> 16328;
16333 -> 16328;
16334 -> 16330;
16334 -> 16328;
16335 -> 16328;
16336 -> 16328;
16337 -> 16332;
16337 -> 16336;
16338 -> 16333;
16338 -> 16336;
16339 -> 16334;
16339 -> 16336;
16340 -> 16335;
16340 -> 16336;
16341 -> 16331;
16341 -> 16336;
16343 -> 16342;
16345 -> 16344;
16347 -> 16346;
16349 -> 16345;
16349 -> 16348;
16350 -> 16347;
16350 -> 16348;
16352 -> 16345;
16352 -> 16351;
16353 -> 16347;
16353 -> 16351;
16355 -> 16345;
16355 -> 16354;
16356 -> 16347;
16356 -> 16354;
16358 -> 16345;
16358 -> 16357;
16359 -> 16347;
16359 -> 16357;
16361 -> 16345;
16361 -> 16360;
16362 -> 16347;
16362 -> 16360;
16364 -> 16345;
16364 -> 16363;
16365 -> 16347;
16365 -> 16363;
16367 -> 16345;
16367 -> 16366;
16368 -> 16347;
16368 -> 16366;
16370 -> 16345;
16370 -> 16369;
16371 -> 16347;
16371 -> 16369;
16373 -> 16345;
16373 -> 16372;
16374 -> 16347;
16374 -> 16372;
16376 -> 16345;
16376 -> 16375;
16377 -> 16347;
16377 -> 16375;
16379 -> 16345;
16379 -> 16378;
16381 -> 16345;
16381 -> 16380;
16383 -> 16348;
16383 -> 16382;
16384 -> 16351;
16384 -> 16382;
16385 -> 16354;
16385 -> 16382;
16386 -> 16357;
16386 -> 16382;
16387 -> 16360;
16387 -> 16382;
16388 -> 16363;
16388 -> 16382;
16389 -> 16366;
16389 -> 16382;
16390 -> 16369;
16390 -> 16382;
16391 -> 16372;
16391 -> 16382;
16392 -> 16375;
16392 -> 16382;
16393 -> 16378;
16393 -> 16382;
16394 -> 16380;
16394 -> 16382;
16395 -> 16382;
16397 -> 16345;
16397 -> 16396;
16398 -> 16347;
16398 -> 16396;
16400 -> 16347;
16400 -> 16399;
16401 -> 16345;
16401 -> 16399;
16403 -> 16347;
16403 -> 16402;
16404 -> 16345;
16404 -> 16402;
16406 -> 16347;
16406 -> 16405;
16407 -> 16345;
16407 -> 16405;
16409 -> 16347;
16409 -> 16408;
16410 -> 16345;
16410 -> 16408;
16412 -> 16347;
16412 -> 16411;
16413 -> 16345;
16413 -> 16411;
16415 -> 16347;
16415 -> 16414;
16416 -> 16345;
16416 -> 16414;
16418 -> 16347;
16418 -> 16417;
16419 -> 16345;
16419 -> 16417;
16421 -> 16347;
16421 -> 16420;
16422 -> 16345;
16422 -> 16420;
16424 -> 16347;
16424 -> 16423;
16425 -> 16345;
16425 -> 16423;
16427 -> 16347;
16427 -> 16426;
16428 -> 16345;
16428 -> 16426;
16430 -> 16347;
16430 -> 16429;
16431 -> 16345;
16431 -> 16429;
16433 -> 16396;
16433 -> 16432;
16434 -> 16399;
16434 -> 16432;
16435 -> 16402;
16435 -> 16432;
16436 -> 16405;
16436 -> 16432;
16437 -> 16408;
16437 -> 16432;
16438 -> 16411;
16438 -> 16432;
16439 -> 16414;
16439 -> 16432;
16440 -> 16417;
16440 -> 16432;
16441 -> 16420;
16441 -> 16432;
16442 -> 16423;
16442 -> 16432;
16443 -> 16426;
16443 -> 16432;
16444 -> 16429;
16444 -> 16432;
16445 -> 16432;
16446 -> 16337;
16446 -> 16336;
16447 -> 16338;
16447 -> 16336;
16448 -> 16339;
16448 -> 16336;
16449 -> 16340;
16449 -> 16336;
16450 -> 16336;
16451 -> 16446;
16451 -> 16450;
16452 -> 16447;
16452 -> 16450;
16453 -> 16448;
16453 -> 16450;
16454 -> 16449;
16454 -> 16450;
16455 -> 16341;
16455 -> 16450;
16456 -> 16455;
16456 -> 16450;
16457 -> 16455;
16457 -> 16450;
16458 -> 16455;
16458 -> 16450;
16459 -> 16455;
16459 -> 16450;
16460 -> 16450;
16461 -> 16451;
16461 -> 16460;
16461 -> 16450;
16462 -> 16450;
16463 -> 16454;
16463 -> 16462;
16463 -> 16450;
16464 -> 16450;
16465 -> 16454;
16465 -> 16464;
16465 -> 16450;
16466 -> 16451;
16466 -> 16455;
16466 -> 16450;
16467 -> 16452;
16467 -> 16455;
16467 -> 16450;
16468 -> 16453;
16468 -> 16455;
16468 -> 16450;
16469 -> 16454;
16469 -> 16455;
16469 -> 16450;
16470 -> 16308;
16471 -> 16310;
16471 -> 16470;
16472 -> 16471;
16472 -> 16256;
16472 -> 16470;
16473 -> 16472;
16473 -> 16308;
16474 -> 16327;
16474 -> 16473;
16475 -> 16309;
16475 -> 16473;
16476 -> 16473;
16477 -> 16474;
16477 -> 16476;
16478 -> 16475;
16478 -> 16476;
16479 -> 16473;
16479 -> 16476;
16480 -> 16473;
16481 -> 16178;
16482 -> 16179;
16482 -> 16178;
16483 -> 16178;
16484 -> 16482;
16484 -> 16483;
16485 -> 16180;
16485 -> 16483;
16486 -> 16483;
16487 -> 16485;
16487 -> 16486;
16488 -> 16487;
16488 -> 16472;
16488 -> 16486;
16489 -> 16488;
16489 -> 16483;
16490 -> 16483;
16491 -> 16485;
16491 -> 16490;
16492 -> 16491;
16492 -> 16472;
16492 -> 16490;
16493 -> 16492;
16493 -> 16483;
16494 -> 16483;
16495 -> 16493;
16496 -> 16495;
16496 -> 16493;
16497 -> 16178;
16498 -> 16179;
16498 -> 16178;
16499 -> 16178;
16500 -> 16498;
16500 -> 16499;
16501 -> 16180;
16501 -> 16499;
16502 -> 16499;
16503 -> 16501;
16503 -> 16502;
16504 -> 16503;
16504 -> 16492;
16504 -> 16502;
16505 -> 16504;
16505 -> 16499;
16506 -> 16505;
16507 -> 16505;
16508 -> 16506;
16508 -> 16507;
16509 -> 16507;
16510 -> 16508;
16510 -> 16509;
16511 -> 0;
16511 -> 16509;
16512 -> 16511;
16512 -> 16507;
16513 -> 16512;
16514 -> 16508;
16514 -> 16513;
16515 -> 16513;
16516 -> 16515;
16516 -> 16512;
16517 -> 16516;
16517 -> 16505;
16518 -> 16505;
16519 -> 16505;
16519 -> 16518;
16520 -> 0;
16520 -> 16518;
16521 -> 16520;
16521 -> 16505;
16522 -> 16178;
16523 -> 16178;
16524 -> 16180;
16524 -> 16523;
16525 -> 16524;
16525 -> 16504;
16525 -> 0;
16525 -> 16523;
16526 -> 16525;
16527 -> 16526;
16527 -> 16525;
16528 -> 16524;
16528 -> 16504;
16528 -> 16527;
16529 -> 0;
16529 -> 16527;
16530 -> 16524;
16530 -> 16504;
16530 -> 16528;
16530 -> 0;
16530 -> 16523;
16531 -> 16530;
16531 -> 16178;
16532 -> 16179;
16532 -> 16178;
16533 -> 16178;
16534 -> 16532;
16534 -> 16533;
16535 -> 16180;
16535 -> 16533;
16536 -> 16533;
16537 -> 16535;
16537 -> 16536;
16538 -> 0;
16538 -> 16536;
16539 -> 16536;
16540 -> 16538;
16540 -> 16539;
16541 -> 16537;
16541 -> 16539;
16542 -> 16541;
16542 -> 16504;
16542 -> 16540;
16542 -> 16539;
16543 -> 16542;
16543 -> 16533;
16544 -> 16543;
16545 -> 16178;
16546 -> 16179;
16546 -> 16178;
16547 -> 16178;
16548 -> 16546;
16548 -> 16547;
16549 -> 16180;
16549 -> 16547;
16550 -> 16547;
16551 -> 16549;
16551 -> 16550;
16552 -> 16551;
16552 -> 16504;
16552 -> 16550;
16553 -> 16552;
16553 -> 16547;
16554 -> 16553;
16555 -> 16178;
16556 -> 16179;
16556 -> 16178;
16557 -> 16178;
16558 -> 16556;
16558 -> 16557;
16559 -> 16180;
16559 -> 16557;
16560 -> 16558;
16560 -> 16557;
16561 -> 0;
16561 -> 16557;
16562 -> 16557;
16563 -> 16560;
16563 -> 16562;
16564 -> 16561;
16564 -> 16562;
16565 -> 16561;
16565 -> 16562;
16566 -> 16559;
16566 -> 16562;
16567 -> 16564;
16567 -> 16562;
16568 -> 16562;
16569 -> 16567;
16569 -> 16568;
16570 -> 16566;
16570 -> 16568;
16571 -> 16569;
16571 -> 16568;
16572 -> 16568;
16573 -> 16571;
16573 -> 16572;
16574 -> 16570;
16574 -> 16572;
16575 -> 16572;
16576 -> 16574;
16576 -> 16504;
16576 -> 16575;
16576 -> 16572;
16577 -> 16573;
16577 -> 16576;
16578 -> 16576;
16579 -> 16577;
16579 -> 16578;
16580 -> 16574;
16580 -> 16578;
16581 -> 16578;
16582 -> 16581;
16582 -> 16578;
16583 -> 16578;
16584 -> 16580;
16584 -> 16583;
16585 -> 16584;
16585 -> 16578;
16586 -> 16579;
16586 -> 16578;
16587 -> 16581;
16587 -> 16578;
16588 -> 16585;
16588 -> 16586;
16588 -> 16587;
16588 -> 16504;
16588 -> 16528;
16588 -> 16582;
16588 -> 16578;
16589 -> 11866;
16589 -> 16578;
16590 -> 16589;
16590 -> 16576;
16591 -> 16590;
16591 -> 16568;
16592 -> 16591;
16592 -> 0;
16592 -> 16568;
16593 -> 0;
16593 -> 16592;
16594 -> 16593;
16594 -> 16562;
16595 -> 16565;
16595 -> 16562;
16596 -> 16562;
16597 -> 16595;
16597 -> 16596;
16598 -> 16566;
16598 -> 16596;
16599 -> 16597;
16599 -> 16596;
16600 -> 16596;
16601 -> 16599;
16601 -> 16600;
16602 -> 16598;
16602 -> 16600;
16603 -> 16600;
16604 -> 16602;
16604 -> 16588;
16604 -> 16603;
16604 -> 16600;
16605 -> 16601;
16605 -> 16604;
16606 -> 11866;
16606 -> 16604;
16607 -> 16606;
16607 -> 0;
16607 -> 16596;
16608 -> 0;
16608 -> 16607;
16609 -> 16608;
16609 -> 16562;
16610 -> 16563;
16610 -> 16562;
16611 -> 16594;
16611 -> 16562;
16612 -> 16609;
16612 -> 16562;
16613 -> 16565;
16613 -> 16562;
16614 -> 16562;
16615 -> 16610;
16615 -> 16614;
16616 -> 16611;
16616 -> 16614;
16617 -> 16612;
16617 -> 16614;
16618 -> 16613;
16618 -> 16614;
16619 -> 16616;
16619 -> 16614;
16620 -> 16562;
16621 -> 16563;
16621 -> 16562;
16622 -> 16609;
16622 -> 16562;
16623 -> 16594;
16623 -> 16562;
16624 -> 16564;
16624 -> 16562;
16625 -> 16562;
16626 -> 16621;
16626 -> 16625;
16627 -> 16622;
16627 -> 16625;
16628 -> 16623;
16628 -> 16625;
16629 -> 16624;
16629 -> 16625;
16630 -> 16627;
16630 -> 16625;
16631 -> 16562;
16632 -> 16557;
16633 -> 16558;
16633 -> 16557;
16634 -> 0;
16634 -> 16557;
16635 -> 16557;
16636 -> 16633;
16636 -> 16635;
16637 -> 16634;
16637 -> 16635;
16638 -> 16634;
16638 -> 16635;
16639 -> 16559;
16639 -> 16635;
16640 -> 16637;
16640 -> 16635;
16641 -> 16635;
16642 -> 16640;
16642 -> 16641;
16643 -> 16639;
16643 -> 16641;
16644 -> 16642;
16644 -> 16641;
16645 -> 16641;
16646 -> 16644;
16646 -> 16645;
16647 -> 16643;
16647 -> 16645;
16648 -> 16645;
16649 -> 16647;
16649 -> 16605;
16649 -> 16648;
16649 -> 16645;
16650 -> 16646;
16650 -> 16649;
16651 -> 11866;
16651 -> 16649;
16652 -> 16651;
16652 -> 0;
16652 -> 16641;
16653 -> 0;
16653 -> 16652;
16654 -> 16638;
16654 -> 16635;
16655 -> 16635;
16656 -> 16654;
16656 -> 16655;
16657 -> 16639;
16657 -> 16655;
16658 -> 16656;
16658 -> 16655;
16659 -> 16655;
16660 -> 16658;
16660 -> 16659;
16661 -> 16657;
16661 -> 16659;
16662 -> 16659;
16663 -> 11866;
16663 -> 16650;
16664 -> 16663;
16664 -> 0;
16664 -> 16655;
16665 -> 0;
16665 -> 16664;
16666 -> 16636;
16666 -> 16635;
16667 -> 16653;
16667 -> 16635;
16668 -> 16665;
16668 -> 16635;
16669 -> 16638;
16669 -> 16635;
16670 -> 16635;
16671 -> 16666;
16671 -> 16670;
16672 -> 16667;
16672 -> 16670;
16673 -> 16668;
16673 -> 16670;
16674 -> 16669;
16674 -> 16670;
16675 -> 16672;
16675 -> 16670;
16676 -> 16635;
16677 -> 16636;
16677 -> 16635;
16678 -> 16665;
16678 -> 16635;
16679 -> 16653;
16679 -> 16635;
16680 -> 16637;
16680 -> 16635;
16681 -> 16635;
16682 -> 16677;
16682 -> 16681;
16683 -> 16678;
16683 -> 16681;
16684 -> 16679;
16684 -> 16681;
16685 -> 16680;
16685 -> 16681;
16686 -> 16683;
16686 -> 16681;
16687 -> 16635;
16688 -> 16557;
16689 -> 16558;
16689 -> 16557;
16690 -> 0;
16690 -> 16557;
16691 -> 16557;
16692 -> 16689;
16692 -> 16691;
16693 -> 16690;
16693 -> 16691;
16694 -> 16690;
16694 -> 16691;
16695 -> 16559;
16695 -> 16691;
16696 -> 16693;
16696 -> 16691;
16697 -> 16691;
16698 -> 16696;
16698 -> 16697;
16699 -> 16695;
16699 -> 16697;
16700 -> 16698;
16700 -> 16697;
16701 -> 16697;
16702 -> 16700;
16702 -> 16701;
16703 -> 16699;
16703 -> 16701;
16704 -> 16701;
16705 -> 16703;
16705 -> 16650;
16705 -> 16704;
16705 -> 16701;
16706 -> 16702;
16706 -> 16705;
16707 -> 11866;
16707 -> 16705;
16708 -> 16707;
16708 -> 0;
16708 -> 16697;
16709 -> 0;
16709 -> 16708;
16710 -> 16694;
16710 -> 16691;
16711 -> 16691;
16712 -> 16710;
16712 -> 16711;
16713 -> 16695;
16713 -> 16711;
16714 -> 16712;
16714 -> 16711;
16715 -> 16711;
16716 -> 16714;
16716 -> 16715;
16717 -> 16713;
16717 -> 16715;
16718 -> 16715;
16719 -> 11866;
16719 -> 16706;
16720 -> 16719;
16720 -> 0;
16720 -> 16711;
16721 -> 0;
16721 -> 16720;
16722 -> 16692;
16722 -> 16691;
16723 -> 16709;
16723 -> 16691;
16724 -> 16721;
16724 -> 16691;
16725 -> 16694;
16725 -> 16691;
16726 -> 16691;
16727 -> 16722;
16727 -> 16726;
16728 -> 16723;
16728 -> 16726;
16729 -> 16724;
16729 -> 16726;
16730 -> 16725;
16730 -> 16726;
16731 -> 16728;
16731 -> 16726;
16732 -> 16691;
16733 -> 16692;
16733 -> 16691;
16734 -> 16721;
16734 -> 16691;
16735 -> 16709;
16735 -> 16691;
16736 -> 16693;
16736 -> 16691;
16737 -> 16691;
16738 -> 16733;
16738 -> 16737;
16739 -> 16734;
16739 -> 16737;
16740 -> 16735;
16740 -> 16737;
16741 -> 16736;
16741 -> 16737;
16742 -> 16739;
16742 -> 16737;
16743 -> 16691;
16744 -> 16557;
16745 -> 16558;
16745 -> 16557;
16746 -> 0;
16746 -> 16557;
16747 -> 16557;
16748 -> 16745;
16748 -> 16747;
16749 -> 16746;
16749 -> 16747;
16750 -> 16746;
16750 -> 16747;
16751 -> 16559;
16751 -> 16747;
16752 -> 16749;
16752 -> 16747;
16753 -> 16747;
16754 -> 16752;
16754 -> 16753;
16755 -> 16751;
16755 -> 16753;
16756 -> 16754;
16756 -> 16753;
16757 -> 16753;
16758 -> 16756;
16758 -> 16757;
16759 -> 16755;
16759 -> 16757;
16760 -> 16757;
16761 -> 16759;
16761 -> 16706;
16761 -> 16760;
16761 -> 16757;
16762 -> 16758;
16762 -> 16761;
16763 -> 11866;
16763 -> 16761;
16764 -> 16763;
16764 -> 0;
16764 -> 16753;
16765 -> 0;
16765 -> 16764;
16766 -> 16750;
16766 -> 16747;
16767 -> 16747;
16768 -> 16766;
16768 -> 16767;
16769 -> 16751;
16769 -> 16767;
16770 -> 16768;
16770 -> 16767;
16771 -> 16767;
16772 -> 16770;
16772 -> 16771;
16773 -> 16769;
16773 -> 16771;
16774 -> 16771;
16775 -> 11866;
16775 -> 16762;
16776 -> 16775;
16776 -> 0;
16776 -> 16767;
16777 -> 0;
16777 -> 16776;
16778 -> 16748;
16778 -> 16747;
16779 -> 16765;
16779 -> 16747;
16780 -> 16777;
16780 -> 16747;
16781 -> 16750;
16781 -> 16747;
16782 -> 16747;
16783 -> 16778;
16783 -> 16782;
16784 -> 16779;
16784 -> 16782;
16785 -> 16780;
16785 -> 16782;
16786 -> 16781;
16786 -> 16782;
16787 -> 16784;
16787 -> 16782;
16788 -> 16747;
16789 -> 16748;
16789 -> 16747;
16790 -> 16777;
16790 -> 16747;
16791 -> 16765;
16791 -> 16747;
16792 -> 16749;
16792 -> 16747;
16793 -> 16747;
16794 -> 16789;
16794 -> 16793;
16795 -> 16790;
16795 -> 16793;
16796 -> 16791;
16796 -> 16793;
16797 -> 16792;
16797 -> 16793;
16798 -> 16795;
16798 -> 16793;
16799 -> 16747;
16800 -> 16557;
16801 -> 16558;
16801 -> 16557;
16802 -> 16557;
16803 -> 16801;
16803 -> 16802;
16804 -> 16559;
16804 -> 16802;
16805 -> 16804;
16805 -> 16802;
16806 -> 16802;
16807 -> 16805;
16807 -> 16806;
16808 -> 16806;
16809 -> 16807;
16809 -> 16808;
16809 -> 16806;
16810 -> 16806;
16811 -> 16807;
16811 -> 16810;
16812 -> 16810;
16812 -> 16806;
16813 -> 16806;
16814 -> 16807;
16814 -> 16813;
16815 -> 16814;
16815 -> 16762;
16815 -> 16813;
16816 -> 16815;
16816 -> 16806;
16817 -> 16812;
16817 -> 16816;
16817 -> 16806;
16818 -> 16802;
16819 -> 16804;
16819 -> 16818;
16820 -> 16819;
16820 -> 16762;
16820 -> 16818;
16821 -> 16820;
16821 -> 16802;
16822 -> 0;
16822 -> 16802;
16823 -> 16802;
16824 -> 16822;
16824 -> 16823;
16825 -> 16804;
16825 -> 16823;
16826 -> 16824;
16826 -> 16823;
16827 -> 16823;
16828 -> 16826;
16828 -> 16827;
16829 -> 16825;
16829 -> 16827;
16830 -> 16827;
16831 -> 16829;
16831 -> 16820;
16831 -> 16830;
16831 -> 16827;
16832 -> 16828;
16832 -> 16831;
16833 -> 11866;
16833 -> 16831;
16834 -> 16833;
16834 -> 0;
16834 -> 16823;
16835 -> 0;
16835 -> 16834;
16836 -> 16835;
16836 -> 16802;
16837 -> 16802;
16838 -> 16822;
16838 -> 16837;
16839 -> 16804;
16839 -> 16837;
16840 -> 16838;
16840 -> 16837;
16841 -> 16837;
16842 -> 16840;
16842 -> 16841;
16843 -> 16839;
16843 -> 16841;
16844 -> 16841;
16845 -> 16843;
16845 -> 16832;
16845 -> 16844;
16845 -> 16841;
16846 -> 11866;
16846 -> 16845;
16847 -> 16846;
16847 -> 0;
16847 -> 16837;
16848 -> 0;
16848 -> 16847;
16849 -> 16802;
16850 -> 16802;
16851 -> 16849;
16851 -> 16850;
16852 -> 16804;
16852 -> 16850;
16853 -> 16851;
16853 -> 16850;
16854 -> 16850;
16855 -> 16853;
16855 -> 16854;
16856 -> 16852;
16856 -> 16854;
16857 -> 16854;
16858 -> 16857;
16858 -> 16854;
16859 -> 16854;
16860 -> 16856;
16860 -> 16859;
16861 -> 16860;
16861 -> 16845;
16861 -> 16859;
16862 -> 16855;
16862 -> 16854;
16863 -> 16857;
16863 -> 16854;
16864 -> 16861;
16864 -> 16862;
16864 -> 16863;
16864 -> 16845;
16864 -> 16858;
16864 -> 16854;
16865 -> 11866;
16865 -> 16854;
16866 -> 16865;
16866 -> 16850;
16867 -> 16850;
16868 -> 16867;
16868 -> 16802;
16869 -> 16848;
16869 -> 16868;
16869 -> 16802;
16870 -> 16557;
16871 -> 16178;
16872 -> 16178;
16873 -> 16180;
16873 -> 16872;
16874 -> 16873;
16874 -> 16864;
16874 -> 16872;
16875 -> 16874;
16875 -> 16178;
16876 -> 16178;
16877 -> 16178;
16878 -> 16180;
16878 -> 16877;
16879 -> 16877;
16880 -> 16878;
16880 -> 16879;
16881 -> 16879;
16881 -> 16877;
16882 -> 16878;
16882 -> 16875;
16882 -> 16877;
16883 -> 16882;
16883 -> 16178;
16884 -> 16178;
16885 -> 16180;
16885 -> 16884;
16886 -> 0;
16886 -> 16884;
16887 -> 16884;
16888 -> 16886;
16888 -> 16887;
16889 -> 16885;
16889 -> 16887;
16890 -> 16889;
16890 -> 16875;
16890 -> 16888;
16890 -> 16887;
16891 -> 16890;
16891 -> 16178;
16892 -> 16178;
16893 -> 16180;
16893 -> 16892;
16894 -> 0;
16894 -> 16892;
16895 -> 16892;
16896 -> 16894;
16896 -> 16895;
16897 -> 16893;
16897 -> 16895;
16898 -> 16897;
16898 -> 16875;
16898 -> 16896;
16898 -> 16895;
16899 -> 16898;
16899 -> 16178;
16900 -> 16178;
16901 -> 16180;
16901 -> 16900;
16902 -> 16901;
16902 -> 16875;
16902 -> 16900;
16903 -> 16901;
16903 -> 16875;
16903 -> 16900;
16904 -> 16903;
16904 -> 16178;
16905 -> 16178;
16906 -> 16180;
16906 -> 16905;
16907 -> 16905;
16908 -> 16906;
16908 -> 16907;
16909 -> 16907;
16910 -> 16908;
16910 -> 16909;
16911 -> 16910;
16911 -> 16907;
16912 -> 16907;
16913 -> 16908;
16913 -> 16912;
16914 -> 16913;
16914 -> 16875;
16914 -> 16912;
16915 -> 16914;
16915 -> 16907;
16916 -> 16907;
16917 -> 16907;
16918 -> 16908;
16918 -> 16907;
16919 -> 16916;
16919 -> 16907;
16920 -> 16917;
16920 -> 16907;
16921 -> 16907;
16922 -> 16918;
16922 -> 16921;
16923 -> 16919;
16923 -> 16921;
16924 -> 16920;
16924 -> 16921;
16925 -> 16921;
16926 -> 16921;
16927 -> 16925;
16927 -> 16926;
16928 -> 16922;
16928 -> 16926;
16929 -> 16928;
16929 -> 16875;
16929 -> 16926;
16930 -> 16928;
16930 -> 16875;
16930 -> 16926;
16931 -> 16930;
16931 -> 16921;
16932 -> 16907;
16933 -> 16916;
16933 -> 16907;
16934 -> 16933;
16934 -> 16905;
16935 -> 16934;
16935 -> 16178;
16936 -> 16178;
16937 -> 16904;
16937 -> 16178;
16938 -> 16935;
16938 -> 16178;
16939 -> 16178;
16940 -> 16936;
16940 -> 16939;
16941 -> 16937;
16941 -> 16939;
16942 -> 16938;
16942 -> 16939;
16943 -> 16180;
16943 -> 16939;
16944 -> 16939;
16945 -> 16941;
16945 -> 16944;
16945 -> 16939;
16946 -> 16941;
16946 -> 16939;
16947 -> 16946;
16947 -> 16944;
16948 -> 16947;
16948 -> 16944;
16949 -> 16944;
16950 -> 16944;
16951 -> 16948;
16951 -> 16950;
16952 -> 16949;
16952 -> 16950;
16953 -> 16949;
16953 -> 16950;
16954 -> 16949;
16954 -> 16950;
16955 -> 16950;
16956 -> 16954;
16956 -> 16950;
16957 -> 16950;
16958 -> 16950;
16959 -> 16958;
16959 -> 16950;
16960 -> 16951;
16960 -> 16950;
16961 -> 16959;
16961 -> 16960;
16961 -> 16950;
16962 -> 16950;
16963 -> 16956;
16963 -> 16962;
16963 -> 16950;
16964 -> 16957;
16964 -> 16962;
16964 -> 16950;
16965 -> 16963;
16965 -> 16964;
16965 -> 16950;
16966 -> 16950;
16967 -> 16951;
16967 -> 16966;
16968 -> 16967;
16968 -> 16950;
16969 -> 16968;
16970 -> 16951;
16970 -> 16969;
16971 -> 16970;
16971 -> 16946;
16971 -> 16969;
16972 -> 16971;
16972 -> 16968;
16973 -> 16968;
16974 -> 16972;
16974 -> 16973;
16974 -> 16968;
16975 -> 16952;
16975 -> 16958;
16976 -> 16951;
16976 -> 16975;
16977 -> 16976;
16977 -> 16975;
16978 -> 16975;
16979 -> 16976;
16979 -> 16978;
16979 -> 16975;
16980 -> 16950;
16981 -> 16980;
16981 -> 16950;
16982 -> 16950;
16983 -> 16951;
16983 -> 16982;
16984 -> 16983;
16984 -> 16979;
16984 -> 16982;
16985 -> 16984;
16985 -> 16950;
16986 -> 16985;
16987 -> 16951;
16987 -> 16986;
16988 -> 0;
16988 -> 16986;
16989 -> 16988;
16989 -> 16985;
16990 -> 16989;
16990 -> 0;
16990 -> 16985;
16991 -> 16990;
16992 -> 16991;
16992 -> 16944;
16993 -> 16942;
16993 -> 16939;
16994 -> 16940;
16994 -> 16939;
16995 -> 16993;
16995 -> 16994;
16995 -> 16933;
16995 -> 16992;
16995 -> 16916;
16995 -> 16939;
16996 -> 16180;
16996 -> 16178;
16997 -> 16178;
16998 -> 16996;
16998 -> 16997;
16999 -> 16883;
16999 -> 16997;
17000 -> 16998;
17000 -> 16997;
17001 -> 17000;
17001 -> 16995;
17001 -> 16997;
17002 -> 16997;
17003 -> 16998;
17003 -> 17002;
17004 -> 17003;
17004 -> 16997;
17005 -> 16997;
17006 -> 16998;
17006 -> 17005;
17007 -> 17006;
17007 -> 17001;
17007 -> 17005;
17008 -> 17007;
17008 -> 16997;
17009 -> 16997;
17010 -> 16999;
17010 -> 17009;
17011 -> 17009;
17012 -> 17010;
17012 -> 17011;
17013 -> 17012;
17013 -> 17001;
17013 -> 17011;
17014 -> 17012;
17014 -> 17001;
17014 -> 17011;
17015 -> 17014;
17015 -> 17011;
17016 -> 17012;
17016 -> 17001;
17016 -> 17011;
17017 -> 17016;
17017 -> 17009;
17018 -> 17009;
17019 -> 17017;
17019 -> 17018;
17020 -> 17009;
17021 -> 17019;
17021 -> 16997;
17022 -> 16997;
17023 -> 17008;
17023 -> 17022;
17024 -> 17021;
17024 -> 17022;
17025 -> 17024;
17025 -> 17022;
17026 -> 17023;
17026 -> 17024;
17026 -> 17022;
17027 -> 17008;
17027 -> 17021;
17027 -> 16997;
17028 -> 16997;
17029 -> 16999;
17029 -> 17028;
17030 -> 17029;
17030 -> 17019;
17030 -> 17028;
17031 -> 17030;
17032 -> 17031;
17032 -> 17030;
17033 -> 17030;
17034 -> 17032;
17034 -> 17033;
17034 -> 17030;
17035 -> 17034;
17035 -> 17030;
17036 -> 17035;
17036 -> 17029;
17036 -> 17030;
17037 -> 17029;
17037 -> 17034;
17037 -> 17036;
17037 -> 17028;
17038 -> 17037;
17038 -> 16997;
17039 -> 17038;
17040 -> 17039;
17041 -> 17039;
17042 -> 17040;
17042 -> 17041;
17043 -> 16180;
17043 -> 17041;
17044 -> 17041;
17045 -> 17043;
17045 -> 17044;
17046 -> 17044;
17047 -> 17046;
17047 -> 17044;
17048 -> 17044;
17049 -> 17047;
17049 -> 17048;
17050 -> 17045;
17050 -> 17034;
17050 -> 17048;
17051 -> 17050;
17051 -> 17034;
17051 -> 4355;
17051 -> 17048;
17052 -> 17051;
17052 -> 4377;
17052 -> 17048;
17053 -> 17049;
17053 -> 17048;
17054 -> 17048;
17055 -> 17052;
17055 -> 17054;
17056 -> 17053;
17056 -> 17054;
17057 -> 17055;
17058 -> 17055;
17058 -> 17044;
17059 -> 17058;
17060 -> 17045;
17060 -> 17059;
17061 -> 17059;
17062 -> 17060;
17062 -> 17061;
17063 -> 17061;
17064 -> 17062;
17064 -> 17063;
17065 -> 17063;
17065 -> 17061;
17066 -> 17062;
17066 -> 17059;
17067 -> 17060;
17067 -> 17059;
17068 -> 17059;
17069 -> 17067;
17069 -> 17068;
17070 -> 17066;
17070 -> 17068;
17071 -> 17068;
17072 -> 17069;
17072 -> 17071;
17073 -> 17072;
17073 -> 17068;
17074 -> 17068;
17075 -> 17069;
17075 -> 17074;
17076 -> 17075;
17076 -> 17068;
17077 -> 17070;
17077 -> 17069;
17077 -> 17068;
17078 -> 17070;
17078 -> 17069;
17078 -> 17068;
17079 -> 17078;
17079 -> 17068;
17080 -> 17070;
17080 -> 17069;
17080 -> 17068;
17081 -> 17080;
17081 -> 17068;
17082 -> 17068;
17083 -> 17076;
17083 -> 17082;
17084 -> 17081;
17084 -> 17082;
17085 -> 17084;
17085 -> 17082;
17086 -> 17083;
17086 -> 17084;
17086 -> 17082;
17087 -> 17076;
17087 -> 17081;
17087 -> 17068;
17088 -> 17059;
17089 -> 17088;
17089 -> 17059;
17090 -> 17059;
17091 -> 17060;
17091 -> 17090;
17092 -> 17091;
17092 -> 17080;
17092 -> 17090;
17093 -> 17091;
17093 -> 17080;
17093 -> 17090;
17094 -> 17093;
17094 -> 17059;
17095 -> 17094;
17095 -> 17059;
17096 -> 17094;
17096 -> 17095;
17097 -> 17095;
17098 -> 17095;
17099 -> 17096;
17099 -> 17098;
17100 -> 17097;
17100 -> 17098;
17101 -> 17097;
17101 -> 17098;
17102 -> 17099;
17102 -> 17098;
17103 -> 17100;
17103 -> 0;
17103 -> 17098;
17104 -> 17100;
17104 -> 17098;
17105 -> 17099;
17105 -> 17104;
17106 -> 17104;
17107 -> 17105;
17107 -> 17106;
17108 -> 17106;
17109 -> 17107;
17109 -> 17108;
17110 -> 17109;
17110 -> 17106;
17111 -> 17106;
17112 -> 17110;
17112 -> 17111;
17113 -> 17099;
17113 -> 17098;
17114 -> 17113;
17114 -> 17098;
17115 -> 17099;
17115 -> 17114;
17116 -> 17114;
17117 -> 17115;
17117 -> 17116;
17118 -> 17116;
17119 -> 17117;
17119 -> 17118;
17120 -> 17119;
17120 -> 17116;
17121 -> 17116;
17122 -> 17120;
17122 -> 17121;
17123 -> 17100;
17123 -> 0;
17123 -> 17098;
17124 -> 17098;
17125 -> 17122;
17125 -> 17124;
17125 -> 17098;
17126 -> 17098;
17127 -> 17101;
17127 -> 17126;
17127 -> 17098;
17128 -> 17098;
17128 -> 17095;
17129 -> 17128;
17129 -> 17088;
17129 -> 17099;
17129 -> 17100;
17129 -> 17101;
17129 -> 17089;
17129 -> 17080;
17129 -> 17095;
17130 -> 17129;
17130 -> 17097;
17131 -> 17129;
17131 -> 17097;
17132 -> 17131;
17132 -> 17097;
17133 -> 17130;
17133 -> 17097;
17134 -> 17097;
17135 -> 17132;
17135 -> 17134;
17136 -> 17133;
17136 -> 17134;
17137 -> 17134;
17138 -> 17137;
17139 -> 17135;
17139 -> 17138;
17140 -> 17139;
17140 -> 17129;
17140 -> 17138;
17141 -> 17139;
17141 -> 17137;
17142 -> 17141;
17142 -> 17137;
17143 -> 17137;
17144 -> 17142;
17144 -> 17143;
17145 -> 17144;
17145 -> 17143;
17146 -> 17145;
17146 -> 17143;
17147 -> 17143;
17148 -> 17145;
17148 -> 17147;
17149 -> 17148;
17150 -> 17148;
17151 -> 17148;
17152 -> 17148;
17152 -> 17151;
17153 -> 17152;
17153 -> 17129;
17153 -> 17151;
17154 -> 17147;
17155 -> 17154;
17155 -> 17143;
17156 -> 17143;
17157 -> 17144;
17157 -> 17156;
17158 -> 17156;
17159 -> 17157;
17159 -> 17158;
17160 -> 17159;
17160 -> 17156;
17161 -> 17160;
17161 -> 0;
17161 -> 17156;
17162 -> 17161;
17162 -> 17143;
17163 -> 17135;
17163 -> 17129;
17163 -> 17162;
17164 -> 17162;
17166 -> 17165;
17168 -> 17167;
17170 -> 17169;
17171 -> 17163;
17171 -> 17162;
17172 -> 17162;
17173 -> 17171;
17173 -> 17172;
17174 -> 17173;
17174 -> 0;
17174 -> 17172;
17175 -> 17170;
17175 -> 17174;
17176 -> 17175;
17176 -> 17162;
17177 -> 17136;
17177 -> 17176;
17177 -> 17129;
17177 -> 17162;
17178 -> 17137;
17179 -> 17141;
17179 -> 17178;
17180 -> 17179;
17180 -> 17177;
17180 -> 17178;
17181 -> 17180;
17181 -> 17137;
17182 -> 17136;
17182 -> 17181;
17183 -> 17181;
17184 -> 17182;
17184 -> 17183;
17185 -> 17141;
17185 -> 17183;
17186 -> 17183;
17187 -> 17185;
17187 -> 17186;
17188 -> 17187;
17188 -> 17177;
17188 -> 17186;
17189 -> 17188;
17189 -> 17183;
17190 -> 17183;
17191 -> 17185;
17191 -> 17190;
17192 -> 17190;
17192 -> 17183;
17193 -> 17181;
17194 -> 17181;
17195 -> 17097;
17196 -> 17059;
17197 -> 17060;
17197 -> 17196;
17198 -> 17197;
17198 -> 17196;
17199 -> 17196;
17200 -> 17198;
17200 -> 17199;
17201 -> 17200;
17201 -> 17196;
17202 -> 17196;
17203 -> 17198;
17203 -> 17202;
17204 -> 17203;
17204 -> 17177;
17204 -> 17202;
17205 -> 17204;
17205 -> 17196;
17206 -> 17196;
17207 -> 17198;
17207 -> 17196;
17208 -> 17196;
17209 -> 17206;
17209 -> 17196;
17210 -> 17196;
17211 -> 17207;
17211 -> 17210;
17212 -> 17208;
17212 -> 17210;
17213 -> 17209;
17213 -> 17210;
17214 -> 17210;
17215 -> 17210;
17216 -> 17214;
17216 -> 17215;
17217 -> 17211;
17217 -> 17215;
17218 -> 17217;
17218 -> 17177;
17218 -> 17215;
17219 -> 17217;
17219 -> 17177;
17219 -> 17215;
17220 -> 17219;
17220 -> 17210;
17221 -> 17196;
17221 -> 17059;
17222 -> 17059;
17223 -> 17060;
17223 -> 17222;
17224 -> 17223;
17224 -> 17177;
17224 -> 17222;
17225 -> 17223;
17225 -> 17177;
17225 -> 17222;
17226 -> 17225;
17226 -> 17059;
17227 -> 17059;
17228 -> 17060;
17228 -> 17227;
17229 -> 17228;
17229 -> 17177;
17229 -> 17227;
17230 -> 17229;
17230 -> 17059;
17231 -> 17066;
17231 -> 17230;
17232 -> 17088;
17232 -> 17230;
17233 -> 17230;
17234 -> 17231;
17234 -> 17233;
17235 -> 17232;
17235 -> 17233;
17236 -> 17230;
17236 -> 17233;
17237 -> 17233;
17238 -> 17236;
17238 -> 17237;
17239 -> 0;
17239 -> 17237;
17240 -> 17239;
17240 -> 17233;
17241 -> 17236;
17241 -> 17240;
17242 -> 17240;
17243 -> 17241;
17243 -> 17242;
17244 -> 17234;
17244 -> 17242;
17245 -> 17242;
17246 -> 17243;
17246 -> 17245;
17247 -> 17246;
17247 -> 17245;
17248 -> 17245;
17249 -> 17247;
17249 -> 17248;
17250 -> 17249;
17250 -> 17248;
17251 -> 17250;
17251 -> 17245;
17252 -> 17251;
17252 -> 17242;
17253 -> 17242;
17254 -> 17243;
17254 -> 17253;
17255 -> 17254;
17255 -> 17253;
17256 -> 17255;
17256 -> 17243;
17256 -> 17253;
17257 -> 17256;
17257 -> 17242;
17258 -> 17244;
17258 -> 17243;
17258 -> 17242;
17259 -> 17244;
17259 -> 17243;
17259 -> 17242;
17260 -> 17259;
17260 -> 17242;
17261 -> 17244;
17261 -> 17243;
17261 -> 17242;
17262 -> 17261;
17262 -> 17242;
17263 -> 17242;
17264 -> 17257;
17264 -> 17263;
17265 -> 17262;
17265 -> 17263;
17266 -> 17265;
17266 -> 17263;
17267 -> 17264;
17267 -> 17265;
17267 -> 17263;
17268 -> 17257;
17268 -> 17262;
17268 -> 17242;
17269 -> 17261;
17270 -> 17236;
17270 -> 17269;
17271 -> 17269;
17271 -> 17261;
17272 -> 17235;
17272 -> 17271;
17272 -> 17229;
17272 -> 17261;
17273 -> 17230;
17274 -> 17235;
17274 -> 17272;
17274 -> 17059;
17275 -> 17274;
17275 -> 17058;
17276 -> 17275;
17276 -> 17058;
17277 -> 17058;
17278 -> 17276;
17278 -> 17277;
17279 -> 17045;
17279 -> 17272;
17279 -> 17277;
17280 -> 17279;
17280 -> 17272;
17280 -> 17277;
17281 -> 17278;
17281 -> 17277;
17282 -> 17277;
17283 -> 17281;
17283 -> 17282;
17284 -> 0;
17284 -> 17283;
17285 -> 17280;
17285 -> 17284;
17285 -> 17277;
17286 -> 17275;
17286 -> 17044;
17287 -> 17286;
17287 -> 17041;
17288 -> 17041;
17289 -> 17287;
17289 -> 17288;
17289 -> 17041;
17290 -> 17287;
17290 -> 17041;
17291 -> 17041;
17292 -> 17043;
17292 -> 17291;
17293 -> 17292;
17293 -> 17272;
17293 -> 17291;
17294 -> 17293;
17294 -> 17041;
17295 -> 17041;
17296 -> 17294;
17296 -> 17295;
17297 -> 17296;
17297 -> 17295;
17298 -> 17296;
17298 -> 17295;
17299 -> 17298;
17299 -> 17272;
17299 -> 17295;
17300 -> 17299;
17300 -> 17295;
17301 -> 17299;
17301 -> 17295;
17302 -> 17301;
17302 -> 17272;
17302 -> 17295;
17303 -> 17302;
17303 -> 17295;
17304 -> 17302;
17304 -> 17295;
17305 -> 17295;
17305 -> 17041;
17306 -> 17041;
17307 -> 17290;
17307 -> 17305;
17307 -> 17041;
17308 -> 17307;
17308 -> 17039;
17309 -> 17039;
17310 -> 16904;
17310 -> 17039;
17311 -> 16935;
17311 -> 17039;
17312 -> 17039;
17313 -> 17309;
17313 -> 17312;
17314 -> 17310;
17314 -> 17312;
17315 -> 17311;
17315 -> 17312;
17316 -> 17314;
17316 -> 17313;
17316 -> 17272;
17316 -> 17285;
17316 -> 17309;
17316 -> 17312;
17317 -> 17316;
17317 -> 17312;
17318 -> 17312;
17319 -> 17317;
17319 -> 17312;
17320 -> 17312;
17321 -> 17318;
17321 -> 17320;
17322 -> 17319;
17322 -> 17320;
17323 -> 17321;
17323 -> 17320;
17324 -> 17322;
17324 -> 17320;
17325 -> 0;
17325 -> 17320;
17326 -> 17320;
17327 -> 17320;
17328 -> 17323;
17328 -> 17327;
17329 -> 17324;
17329 -> 17327;
17330 -> 17325;
17330 -> 17327;
17331 -> 17326;
17331 -> 17327;
17332 -> 17326;
17332 -> 17327;
17333 -> 17326;
17333 -> 17327;
17334 -> 17326;
17334 -> 17327;
17335 -> 17328;
17335 -> 17327;
17336 -> 17329;
17336 -> 17327;
17337 -> 17335;
17337 -> 17336;
17337 -> 17327;
17338 -> 17327;
17339 -> 17333;
17339 -> 17338;
17339 -> 17327;
17340 -> 17327;
17341 -> 17329;
17341 -> 17340;
17342 -> 17341;
17342 -> 17327;
17343 -> 17342;
17344 -> 17329;
17344 -> 17343;
17345 -> 17344;
17345 -> 17316;
17345 -> 17343;
17346 -> 17345;
17346 -> 17342;
17347 -> 17342;
17348 -> 17346;
17348 -> 17347;
17348 -> 17342;
17349 -> 17327;
17350 -> 17349;
17350 -> 17327;
17351 -> 17329;
17352 -> 17320;
17353 -> 17329;
17353 -> 17352;
17353 -> 17320;
17354 -> 16935;
17354 -> 16178;
17355 -> 16178;
17356 -> 17354;
17356 -> 17355;
17356 -> 16933;
17356 -> 17353;
17356 -> 16178;
17357 -> 16175;
17358 -> 16176;
17358 -> 16175;
17359 -> 16175;
17360 -> 17358;
17360 -> 17359;
17361 -> 14507;
17361 -> 17359;
17362 -> 17359;
17363 -> 17361;
17363 -> 17362;
17364 -> 17363;
17364 -> 17356;
17364 -> 17362;
17365 -> 17364;
17365 -> 17359;
17366 -> 17360;
17366 -> 17356;
17366 -> 17359;
17367 -> 16175;
17368 -> 16175;
17369 -> 17368;
17370 -> 17368;
17370 -> 17369;
17371 -> 17369;
17371 -> 17368;
17372 -> 17368;
17372 -> 17356;
17373 -> 17372;
17373 -> 16175;
17374 -> 14507;
17374 -> 16175;
17375 -> 16175;
17376 -> 17374;
17376 -> 17375;
17377 -> 17373;
17377 -> 17375;
17378 -> 17376;
17378 -> 17356;
17378 -> 17375;
17379 -> 16175;
17380 -> 0;
17380 -> 16175;
17381 -> 16175;
17382 -> 17380;
17382 -> 17381;
17383 -> 14507;
17383 -> 17377;
17383 -> 17381;
17384 -> 17383;
17384 -> 17382;
17384 -> 17381;
17385 -> 17384;
17385 -> 16175;
17386 -> 16176;
17386 -> 17377;
17386 -> 17384;
17386 -> 16175;
17387 -> 16159;
17387 -> 14508;
17388 -> 17387;
17388 -> 14663;
17389 -> 14507;
17389 -> 17386;
17389 -> 14663;
17390 -> 17388;
17390 -> 14663;
17391 -> 17390;
17391 -> 14668;
17392 -> 17389;
17392 -> 14668;
17393 -> 17392;
17393 -> 17386;
17393 -> 17391;
17393 -> 14668;
17394 -> 17393;
17395 -> 17386;
17395 -> 14510;
17396 -> 17395;
17396 -> 14513;
17397 -> 17396;
17397 -> 14515;
17397 -> 14513;
17398 -> 17386;
17399 -> 17398;
17399 -> 17386;
17400 -> 17386;
17401 -> 17386;
17402 -> 14505;
17402 -> 17401;
17402 -> 17386;
17403 -> 17399;
17403 -> 17402;
17404 -> 14506;
17404 -> 17398;
17404 -> 17403;
17405 -> 14505;
17405 -> 17403;
17406 -> 14506;
17406 -> 17403;
17407 -> 17403;
17408 -> 17405;
17408 -> 17407;
17409 -> 17406;
17409 -> 17407;
17410 -> 17403;
17410 -> 17407;
17411 -> 17407;
17412 -> 17410;
17412 -> 17411;
17413 -> 17411;
17414 -> 17413;
17414 -> 17407;
17415 -> 17403;
17416 -> 17400;
17416 -> 17386;
17417 -> 17386;
17418 -> 14507;
17418 -> 17417;
17419 -> 17417;
17420 -> 17418;
17420 -> 17404;
17420 -> 17419;
17421 -> 17420;
17421 -> 17404;
17421 -> 4380;
17421 -> 17419;
17422 -> 17419;
17423 -> 17421;
17423 -> 17417;
17424 -> 17417;
17425 -> 17418;
17425 -> 17424;
17426 -> 17424;
17427 -> 17425;
17427 -> 17426;
17428 -> 17427;
17428 -> 17404;
17428 -> 17426;
17429 -> 17428;
17429 -> 17424;
17430 -> 17424;
17431 -> 17425;
17431 -> 17404;
17431 -> 17430;
17432 -> 17431;
17432 -> 17404;
17432 -> 4380;
17432 -> 17430;
17433 -> 17430;
17434 -> 17432;
17434 -> 17424;
17435 -> 17434;
17436 -> 17425;
17436 -> 17435;
17437 -> 17435;
17438 -> 17436;
17438 -> 17437;
17439 -> 17438;
17439 -> 17435;
17440 -> 17435;
17441 -> 17439;
17441 -> 17440;
17441 -> 17435;
17442 -> 17441;
17442 -> 17435;
17443 -> 17442;
17444 -> 17439;
17444 -> 17443;
17445 -> 17443;
17446 -> 17444;
17446 -> 17404;
17446 -> 17445;
17447 -> 17446;
17447 -> 17434;
17448 -> 17434;
17449 -> 17425;
17449 -> 17448;
17450 -> 17448;
17451 -> 17449;
17451 -> 17450;
17452 -> 17451;
17452 -> 17404;
17452 -> 17450;
17453 -> 17450;
17454 -> 17452;
17454 -> 17453;
17455 -> 17454;
17455 -> 0;
17455 -> 17453;
17456 -> 0;
17456 -> 17455;
17457 -> 17456;
17457 -> 17448;
17458 -> 17457;
17458 -> 0;
17458 -> 17448;
17459 -> 17448;
17460 -> 17449;
17460 -> 17459;
17461 -> 17460;
17461 -> 17404;
17461 -> 17459;
17462 -> 17461;
17462 -> 17448;
17463 -> 17457;
17463 -> 17448;
17464 -> 17463;
17464 -> 17434;
17465 -> 17429;
17465 -> 17404;
17465 -> 17434;
17466 -> 17465;
17467 -> 17465;
17468 -> 17466;
17468 -> 17465;
17469 -> 17465;
17470 -> 17467;
17470 -> 17469;
17471 -> 17468;
17471 -> 17469;
17472 -> 17469;
17473 -> 17470;
17473 -> 17472;
17474 -> 17472;
17474 -> 17469;
17475 -> 17474;
17476 -> 17474;
17477 -> 17476;
17477 -> 17465;
17478 -> 17465;
17479 -> 17425;
17479 -> 17404;
17479 -> 17478;
17480 -> 17479;
17480 -> 17404;
17480 -> 17478;
17481 -> 4380;
17481 -> 17478;
17482 -> 17465;
17483 -> 17417;
17484 -> 17386;
17485 -> 0;
17485 -> 17386;
17486 -> 17386;
17487 -> 17485;
17487 -> 17486;
17488 -> 14507;
17488 -> 17404;
17488 -> 17486;
17489 -> 17488;
17489 -> 17487;
17489 -> 17486;
17490 -> 17386;
17490 -> 14508;
17491 -> 17490;
17491 -> 14663;
17492 -> 14507;
17492 -> 17404;
17492 -> 14663;
17493 -> 17491;
17493 -> 14663;
17494 -> 17493;
17494 -> 14668;
17495 -> 17492;
17495 -> 14668;
17496 -> 17495;
17496 -> 17404;
17496 -> 17489;
17496 -> 17494;
17496 -> 14668;
17497 -> 17496;
17498 -> 14506;
17498 -> 17404;
17498 -> 17480;
17498 -> 17489;
17498 -> 14508;
17499 -> 17498;
17499 -> 14510;
17500 -> 17499;
17500 -> 14513;
17501 -> 17500;
17501 -> 14515;
17501 -> 14513;
17502 -> 17498;
17503 -> 14332;
17503 -> 14333;
17504 -> 14332;
17504 -> 14333;
17505 -> 17503;
17505 -> 14333;
17506 -> 14333;
17507 -> 17505;
17507 -> 17506;
17508 -> 17504;
17508 -> 17498;
17508 -> 17506;
17509 -> 17508;
17509 -> 17498;
17509 -> 17507;
17509 -> 17506;
17510 -> 14346;
17510 -> 17509;
17510 -> 14345;
17510 -> 14344;
17511 -> 17510;
17512 -> 17509;
17512 -> 14333;
17513 -> 17512;
17513 -> 14335;
17514 -> 17513;
17514 -> 14337;
17514 -> 14335;
17515 -> 2191;
17515 -> 2192;
17516 -> 2191;
17516 -> 2192;
17517 -> 17515;
17517 -> 2192;
17518 -> 2192;
17519 -> 17517;
17519 -> 17518;
17520 -> 17516;
17520 -> 17509;
17520 -> 17518;
17521 -> 17520;
17521 -> 17509;
17521 -> 17519;
17521 -> 17518;
17522 -> 2326;
17522 -> 17521;
17522 -> 2325;
17522 -> 2324;
17523 -> 17522;
17524 -> 17521;
17524 -> 2192;
17525 -> 17524;
17525 -> 2196;
17526 -> 17525;
17526 -> 2198;
17526 -> 2196;
17527 -> 2191;
17527 -> 2192;
17528 -> 2191;
17528 -> 2192;
17529 -> 17527;
17529 -> 2192;
17530 -> 2192;
17531 -> 17529;
17531 -> 17530;
17532 -> 17528;
17532 -> 17521;
17532 -> 17530;
17533 -> 17532;
17533 -> 17521;
17533 -> 17531;
17533 -> 17530;
17534 -> 2326;
17534 -> 17533;
17534 -> 2325;
17534 -> 2324;
17535 -> 17534;
17536 -> 17533;
17536 -> 2192;
17537 -> 17536;
17537 -> 2196;
17538 -> 17537;
17538 -> 2198;
17538 -> 2196;
17539 -> 2191;
17539 -> 2192;
17540 -> 2192;
17541 -> 2192;
17542 -> 17539;
17542 -> 17533;
17542 -> 17541;
17543 -> 17542;
17543 -> 2192;
17544 -> 2192;
17545 -> 17539;
17545 -> 17533;
17545 -> 17544;
17545 -> 2192;
17546 -> 2192;
17547 -> 17539;
17547 -> 17546;
17548 -> 17546;
17549 -> 17547;
17549 -> 17533;
17549 -> 17548;
17549 -> 17546;
17550 -> 17547;
17550 -> 17533;
17550 -> 17549;
17551 -> 17549;
17552 -> 17547;
17552 -> 17549;
17553 -> 17549;
17554 -> 17549;
17555 -> 17552;
17555 -> 17554;
17556 -> 17553;
17556 -> 17554;
17557 -> 0;
17557 -> 17556;
17557 -> 17554;
17558 -> 17555;
17558 -> 17556;
17558 -> 17554;
17559 -> 17550;
17559 -> 17549;
17560 -> 17549;
17561 -> 17553;
17561 -> 17560;
17562 -> 17553;
17562 -> 17560;
17563 -> 17559;
17563 -> 17560;
17564 -> 17553;
17564 -> 17560;
17565 -> 17560;
17566 -> 17563;
17566 -> 17559;
17566 -> 17565;
17566 -> 17560;
17567 -> 17560;
17568 -> 17563;
17568 -> 17559;
17568 -> 17567;
17568 -> 17560;
17569 -> 17564;
17569 -> 17567;
17569 -> 17560;
17570 -> 17568;
17570 -> 17569;
17570 -> 17560;
17571 -> 17570;
17571 -> 17560;
17572 -> 17547;
17572 -> 17571;
17572 -> 17549;
17573 -> 17571;
17573 -> 17549;
17574 -> 17549;
17575 -> 17547;
17575 -> 17572;
17575 -> 17546;
17576 -> 17575;
17576 -> 2192;
17577 -> 17540;
17577 -> 2192;
17578 -> 2192;
17579 -> 17576;
17579 -> 17578;
17580 -> 17577;
17580 -> 17578;
17581 -> 17539;
17581 -> 17578;
17582 -> 17579;
17582 -> 17578;
17583 -> 17578;
17584 -> 17582;
17584 -> 17583;
17584 -> 17578;
17585 -> 17584;
17586 -> 2192;
17587 -> 2192;
17588 -> 17539;
17588 -> 17572;
17588 -> 17587;
17589 -> 17588;
17589 -> 17572;
17589 -> 17587;
17590 -> 17587;
17591 -> 17588;
17591 -> 2192;
17592 -> 17540;
17592 -> 2192;
17593 -> 17591;
17593 -> 17592;
17593 -> 17572;
17593 -> 17540;
17593 -> 2192;
17594 -> 17540;
17594 -> 17593;
17594 -> 2192;
17595 -> 2326;
17595 -> 17594;
17595 -> 2325;
17595 -> 2324;
17596 -> 17595;
17597 -> 17594;
17597 -> 2192;
17598 -> 17597;
17598 -> 2196;
17599 -> 17598;
17599 -> 2198;
17599 -> 2196;
17600 -> 2052;
17600 -> 2051;
17601 -> 17600;
17602 -> 17601;
17602 -> 2056;
17602 -> 17600;
17603 -> 17600;
17604 -> 17603;
17604 -> 2056;
17604 -> 17600;
17605 -> 2056;
17605 -> 17594;
17605 -> 17602;
17605 -> 17604;
17605 -> 2051;
17606 -> 2051;
17607 -> 2054;
17607 -> 17606;
17607 -> 2051;
17608 -> 2052;
17608 -> 2051;
17609 -> 2053;
17609 -> 2051;
17610 -> 2055;
17610 -> 2051;
17611 -> 2051;
17612 -> 17608;
17612 -> 17611;
17613 -> 17609;
17613 -> 17611;
17614 -> 17610;
17614 -> 17611;
17615 -> 2056;
17615 -> 17611;
17616 -> 17611;
17617 -> 17612;
17617 -> 17616;
17617 -> 17611;
17618 -> 17615;
17618 -> 17605;
17618 -> 17611;
17619 -> 17618;
17620 -> 17615;
17620 -> 17618;
17621 -> 17619;
17621 -> 17618;
17622 -> 17614;
17622 -> 17618;
17623 -> 17618;
17624 -> 17620;
17624 -> 17621;
17624 -> 17622;
17624 -> 17623;
17624 -> 17618;
17625 -> 17624;
17625 -> 17623;
17626 -> 17624;
17626 -> 17623;
17627 -> 17624;
17627 -> 17623;
17628 -> 17624;
17628 -> 17623;
17629 -> 17623;
17630 -> 17627;
17630 -> 17629;
17630 -> 17623;
17631 -> 17628;
17631 -> 17630;
17632 -> 17630;
17633 -> 17631;
17633 -> 17632;
17634 -> 17627;
17634 -> 17632;
17635 -> 17634;
17635 -> 17632;
17636 -> 17635;
17636 -> 17633;
17636 -> 17624;
17636 -> 17632;
17637 -> 17632;
17638 -> 17636;
17638 -> 17637;
17639 -> 0;
17639 -> 17637;
17640 -> 17636;
17640 -> 17639;
17640 -> 17632;
17641 -> 17636;
17641 -> 17637;
17642 -> 17636;
17642 -> 17637;
17643 -> 17641;
17643 -> 17637;
17644 -> 17643;
17644 -> 17637;
17645 -> 17644;
17646 -> 17641;
17646 -> 17645;
17647 -> 17646;
17647 -> 17645;
17648 -> 17647;
17648 -> 17640;
17648 -> 17645;
17649 -> 17636;
17649 -> 17637;
17650 -> 17637;
17651 -> 17649;
17651 -> 17650;
17652 -> 17650;
17653 -> 17651;
17653 -> 17652;
17654 -> 17653;
17654 -> 17648;
17654 -> 17652;
17655 -> 17650;
17656 -> 17651;
17656 -> 17648;
17656 -> 17650;
17657 -> 17656;
17657 -> 17637;
17658 -> 17637;
17659 -> 17649;
17659 -> 17658;
17660 -> 17659;
17660 -> 17648;
17660 -> 17658;
17661 -> 17658;
17662 -> 17659;
17662 -> 17648;
17662 -> 17658;
17663 -> 17662;
17663 -> 17637;
17664 -> 17657;
17664 -> 17648;
17664 -> 17637;
17665 -> 17663;
17665 -> 17648;
17665 -> 17637;
17666 -> 17637;
17667 -> 17657;
17667 -> 17648;
17667 -> 17666;
17667 -> 17637;
17668 -> 17663;
17668 -> 17667;
17669 -> 17668;
17669 -> 17648;
17669 -> 17637;
17670 -> 17668;
17670 -> 17637;
17671 -> 17636;
17671 -> 17637;
17672 -> 0;
17672 -> 17637;
17673 -> 17636;
17673 -> 17672;
17673 -> 17670;
17673 -> 17632;
17674 -> 17636;
17674 -> 17637;
17675 -> 17637;
17676 -> 17674;
17676 -> 17675;
17677 -> 17676;
17677 -> 17673;
17677 -> 17675;
17678 -> 17677;
17678 -> 17637;
17679 -> 17678;
17679 -> 17637;
17680 -> 17679;
17680 -> 17678;
17680 -> 17637;
17681 -> 17637;
17682 -> 17678;
17682 -> 17681;
17683 -> 17681;
17684 -> 17682;
17684 -> 17683;
17685 -> 17683;
17685 -> 17681;
17686 -> 17685;
17686 -> 17681;
17687 -> 17686;
17687 -> 17685;
17687 -> 17681;
17688 -> 17686;
17688 -> 17687;
17689 -> 17688;
17689 -> 17637;
17690 -> 17636;
17690 -> 17689;
17690 -> 17673;
17690 -> 17632;
17691 -> 17636;
17691 -> 17637;
17692 -> 17636;
17692 -> 17637;
17693 -> 17636;
17693 -> 17637;
17694 -> 17691;
17694 -> 17637;
17695 -> 17694;
17695 -> 17637;
17696 -> 17692;
17696 -> 17695;
17697 -> 17693;
17697 -> 17690;
17697 -> 17695;
17698 -> 17695;
17699 -> 17696;
17699 -> 17698;
17700 -> 17697;
17700 -> 17698;
17701 -> 17691;
17701 -> 17698;
17702 -> 17701;
17702 -> 17699;
17702 -> 17698;
17703 -> 17636;
17703 -> 17702;
17703 -> 17690;
17703 -> 17632;
17704 -> 17636;
17704 -> 17703;
17704 -> 17637;
17705 -> 17636;
17706 -> 17636;
17707 -> 17706;
17707 -> 17636;
17708 -> 17707;
17708 -> 17705;
17708 -> 17704;
17708 -> 17636;
17709 -> 17636;
17710 -> 17708;
17710 -> 17709;
17711 -> 17708;
17711 -> 17709;
17712 -> 17709;
17713 -> 17711;
17713 -> 17708;
17713 -> 17712;
17714 -> 17708;
17714 -> 17709;
17715 -> 0;
17715 -> 17709;
17716 -> 17708;
17716 -> 17709;
17717 -> 17708;
17717 -> 17709;
17718 -> 17717;
17718 -> 17713;
17718 -> 17708;
17719 -> 17718;
17719 -> 17708;
17720 -> 17630;
17721 -> 17615;
17721 -> 17713;
17721 -> 17618;
17722 -> 17619;
17722 -> 17713;
17722 -> 17618;
17723 -> 17615;
17723 -> 17721;
17723 -> 17611;
17724 -> 17615;
17724 -> 17721;
17724 -> 17611;
17725 -> 17605;
17725 -> 2051;
17726 -> 17725;
17726 -> 17721;
17726 -> 2051;
17727 -> 17724;
17727 -> 2051;
17728 -> 980;
17729 -> 976;
17729 -> 17727;
17729 -> 17728;
17729 -> 980;
17730 -> 975;
17730 -> 17727;
17730 -> 971;
17731 -> 972;
17731 -> 0;
17731 -> 971;
17732 -> 974;
17732 -> 971;
17733 -> 977;
17733 -> 971;
17734 -> 975;
17734 -> 971;
17735 -> 17732;
17735 -> 17733;
17735 -> 17734;
17735 -> 976;
17735 -> 966;
17735 -> 17730;
17735 -> 971;
17736 -> 971;
17737 -> 961;
17738 -> 966;
17738 -> 17735;
17738 -> 961;
17739 -> 0;
17739 -> 1;
17740 -> 1;
17741 -> 953;
17741 -> 17740;
17742 -> 17741;
17742 -> 17738;
17742 -> 17740;
17743 -> 17741;
17743 -> 17738;
17743 -> 17740;
17744 -> 17743;
17744 -> 1;
17745 -> 1;
17746 -> 1;
17747 -> 17745;
17747 -> 17746;
17748 -> 17744;
17748 -> 17746;
17749 -> 17748;
17749 -> 17738;
17749 -> 17747;
17749 -> 17746;
17750 -> 1;
17751 -> 1;
17752 -> 17750;
17752 -> 17751;
17753 -> 17749;
17753 -> 17751;
17754 -> 17753;
17754 -> 17749;
17754 -> 17752;
17754 -> 17751;
17755 -> 17751;
17756 -> 17754;
17756 -> 17755;
17757 -> 17754;
17757 -> 17755;
17758 -> 17755;
17759 -> 17755;
17760 -> 17757;
17760 -> 17754;
17760 -> 17755;
17761 -> 17756;
17761 -> 17760;
17762 -> 17760;
17763 -> 17761;
17763 -> 17762;
17764 -> 17763;
17765 -> 17763;
17765 -> 17764;
17766 -> 17764;
17766 -> 17763;
17767 -> 17763;
17767 -> 17766;
17768 -> 17759;
17768 -> 17767;
17768 -> 17763;
17768 -> 17766;
17769 -> 17768;
17770 -> 11866;
17770 -> 17768;
17771 -> 17755;
17772 -> 17758;
17772 -> 17771;
17772 -> 17755;
17773 -> 17759;
17773 -> 17768;
17773 -> 17755;
17774 -> 17773;
17774 -> 1;
17775 -> 1;
17776 -> 17774;
17776 -> 17775;
17777 -> 17775;
17778 -> 17776;
17778 -> 17777;
17779 -> 4436;
17779 -> 17777;
17780 -> 17778;
17780 -> 17775;
17781 -> 1;
17782 -> 1;
17783 -> 17780;
17783 -> 17782;
17784 -> 17782;
17785 -> 17783;
17785 -> 17773;
17785 -> 17784;
17786 -> 17785;
17786 -> 17773;
17786 -> 4383;
17786 -> 17784;
17787 -> 17784;
17788 -> 17786;
17788 -> 17782;
17789 -> 17788;
17790 -> 17789;
17790 -> 17788;
17791 -> 17788;
17792 -> 17790;
17792 -> 17789;
17792 -> 17791;
17792 -> 17788;
17793 -> 17788;
17794 -> 17783;
17794 -> 17789;
17794 -> 17793;
17795 -> 17794;
17795 -> 17789;
17795 -> 17793;
17796 -> 4383;
17796 -> 17793;
17797 -> 17788;
17798 -> 17790;
17798 -> 17788;
17799 -> 17798;
17799 -> 1;
17800 -> 0;
17800 -> 1;
17801 -> 17799;
17801 -> 17800;
17801 -> 17789;
17801 -> 17795;
17801 -> 1;
17802 -> 17801;
17802 -> 17781;
17803 -> 0;
17803 -> 17781;
17804 -> 17801;
17804 -> 17803;
17804 -> 1;
17805 -> 17781;
17805 -> 17801;
17805 -> 17803;
17805 -> 1;
}