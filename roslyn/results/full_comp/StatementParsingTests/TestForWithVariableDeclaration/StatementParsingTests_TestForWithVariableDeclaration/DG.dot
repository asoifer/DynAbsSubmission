digraph G {
0 [label="EXTERNAL"];
1 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 97741"];
2 [label="Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 97742"];
3 [label="RuntimeHelpers.RunModuleConstructor(typeof(TestBase).Module.ModuleHandle); 97743"];
4 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 97744"];
5 [label="NullableAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Event | // The type of the event is nullable, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Field | // The type of the field is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.GenericParameter | // The generic parameter is a nullable reference type\n                    AttributeTargets.Module | // Nullable reference types in this module are annotated by means of NullableAttribute applied to other targets in it\n                    AttributeTargets.Parameter | // The type of the parameter is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.ReturnValue | // The return type is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Property | // The type of the property is a nullable reference type, or has a nullable reference type as one of its constituents\n                    AttributeTargets.Class, // Base type has a nullable reference type as one of its constituents\n                   AllowMultiple = false)]\n    public class NullableAttribute : Attribute\n    {\n        public NullableAttribute(byte transformFlag) { }\n        public NullableAttribute(byte[] transformFlags)\n        {\n        }\n    }\n}\n' 97745"];
6 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 97746"];
7 [label="NullableContextAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Delegate |\n        AttributeTargets.Interface |\n        AttributeTargets.Method |\n        AttributeTargets.Struct,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NullableContextAttribute : Attribute\n    {\n        public readonly byte Flag;\n        public NullableContextAttribute(byte flag)\n        {\n            Flag = flag;\n        }\n    }\n}' 97747"];
8 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 97748"];
9 [label="NullablePublicOnlyAttributeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Module, AllowMultiple = false)]\n    public sealed class NullablePublicOnlyAttribute : Attribute\n    {\n        public readonly bool IncludesInternals;\n        public NullablePublicOnlyAttribute(bool includesInternals)\n        {\n            IncludesInternals = includesInternals;\n        }\n    }\n}' 97749"];
10 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 97750"];
11 [label="AllowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class AllowNullAttribute : Attribute\n    {\n    }\n}' 97751"];
12 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 97752"];
13 [label="DisallowNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property)]\n    public sealed class DisallowNullAttribute : Attribute\n    {\n    }\n}' 97753"];
14 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 97754"];
15 [label="MaybeNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class MaybeNullAttribute : Attribute\n    {\n    }\n}\n' 97755"];
16 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 97756"];
17 [label="MaybeNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class MaybeNullWhenAttribute : Attribute\n    {\n        public MaybeNullWhenAttribute(bool when) { }\n    }\n}\n' 97757"];
18 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 97758"];
19 [label="NotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue)]\n    public sealed class NotNullAttribute : Attribute\n    {\n    }\n}\n' 97759"];
20 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 97760"];
21 [label="NotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public sealed class NotNullWhenAttribute : Attribute\n    {\n        public NotNullWhenAttribute(bool when) { }\n    }\n}\n' 97761"];
22 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 97762"];
23 [label="MemberNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullAttribute : Attribute\n    {\n        public MemberNotNullAttribute(params string[] members) { }\n        public MemberNotNullAttribute(string member) { }\n    }\n}\n' 97763"];
24 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 97764"];
25 [label="MemberNotNullWhenAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)]\n    public sealed class MemberNotNullWhenAttribute : Attribute\n    {\n        public MemberNotNullWhenAttribute(bool when, params string[] members) { }\n        public MemberNotNullWhenAttribute(bool when, string member) { }\n    }\n}\n' 97765"];
26 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 97766"];
27 [label="DoesNotReturnIfAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class DoesNotReturnIfAttribute : Attribute\n    {\n        public DoesNotReturnIfAttribute(bool condition) { }\n    }\n}\n' 97767"];
28 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 97768"];
29 [label="DoesNotReturnAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\n    public class DoesNotReturnAttribute : Attribute\n    {\n        public DoesNotReturnAttribute() { }\n    }\n}\n' 97769"];
30 [label="@'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 97770"];
31 [label="NotNullIfNotNullAttributeDefinition = @'\nnamespace System.Diagnostics.CodeAnalysis\n{\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.ReturnValue, AllowMultiple = true, Inherited = false)]\n    public sealed class NotNullIfNotNullAttribute : Attribute\n    {\n        public NotNullIfNotNullAttribute(string parameterName) { }\n    }\n}\n' 97771"];
32 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 97772"];
33 [label="IsExternalInitTypeDefinition = @'\nnamespace System.Runtime.CompilerServices\n{\n    public static class IsExternalInit\n    {\n    }\n}\n' 97773"];
34 [label="@'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 97774"];
35 [label="IAsyncDisposableDefinition = @'\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n       System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 97775"];
36 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 97776"];
37 [label="AsyncStreamsTypes = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = false)]\n    public sealed class AsyncIteratorStateMachineAttribute : StateMachineAttribute\n    {\n        public AsyncIteratorStateMachineAttribute(Type stateMachineType) : base(stateMachineType)\n        {\n        }\n    }\n}\n\n#nullable disable\n\nnamespace System.Threading.Tasks.Sources\n{\n    using System.Diagnostics;\n    using System.Runtime.ExceptionServices;\n    using System.Runtime.InteropServices;\n\n    [StructLayout(LayoutKind.Auto)]\n    public struct ManualResetValueTaskSourceCore<TResult>\n    {\n        private Action<object> _continuation;\n        private object _continuationState;\n        private ExecutionContext _executionContext;\n        private object _capturedContext;\n        private bool _completed;\n        private TResult _result;\n        private ExceptionDispatchInfo _error;\n        private short _version;\n\n        /// <summary>Gets or sets whether to force continuations to run asynchronously.</summary>\n        /// <remarks>Continuations may run asynchronously if this is false, but they'll never run synchronously if this is true.</remarks>\n        public bool RunContinuationsAsynchronously { get; set; }\n\n        /// <summary>Resets to prepare for the next operation.</summary>\n        public void Reset()\n        {\n            // Reset/update state for the next use/await of this instance.\n            _version++;\n            _completed = false;\n            _result = default;\n            _error = null;\n            _executionContext = null;\n            _capturedContext = null;\n            _continuation = null;\n            _continuationState = null;\n        }\n\n        public void SetResult(TResult result)\n        {\n            _result = result;\n            SignalCompletion();\n        }\n\n        public void SetException(Exception error)\n        {\n            _error = ExceptionDispatchInfo.Capture(error);\n            SignalCompletion();\n        }\n\n        public short Version => _version;\n\n        public ValueTaskSourceStatus GetStatus(short token)\n        {\n            ValidateToken(token);\n            return\n                !_completed ? ValueTaskSourceStatus.Pending :\n                _error == null ? ValueTaskSourceStatus.Succeeded :\n                _error.SourceException is OperationCanceledException ? ValueTaskSourceStatus.Canceled :\n                ValueTaskSourceStatus.Faulted;\n        }\n\n        public TResult GetResult(short token)\n        {\n            ValidateToken(token);\n            if (!_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n\n            _error?.Throw();\n            return _result;\n        }\n\n        public void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags)\n        {\n            if (continuation == null)\n            {\n                throw new ArgumentNullException(nameof(continuation));\n            }\n            ValidateToken(token);\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.FlowExecutionContext) != 0)\n            {\n                _executionContext = ExecutionContext.Capture();\n            }\n\n            if ((flags & ValueTaskSourceOnCompletedFlags.UseSchedulingContext) != 0)\n            {\n                SynchronizationContext sc = SynchronizationContext.Current;\n                if (sc != null && sc.GetType() != typeof(SynchronizationContext))\n                {\n                    _capturedContext = sc;\n                }\n                else\n                {\n                    TaskScheduler ts = TaskScheduler.Current;\n                    if (ts != TaskScheduler.Default)\n                    {\n                        _capturedContext = ts;\n                    }\n                }\n            }\n\n            // We need to set the continuation state before we swap in the delegate, so that\n            // if there's a race between this and SetResult/Exception and SetResult/Exception\n            // sees the _continuation as non-null, it'll be able to invoke it with the state\n            // stored here.  However, this also means that if this is used incorrectly (e.g.\n            // awaited twice concurrently), _continuationState might get erroneously overwritten.\n            // To minimize the chances of that, we check preemptively whether _continuation\n            // is already set to something other than the completion sentinel.\n\n            object oldContinuation = _continuation;\n            if (oldContinuation == null)\n            {\n                _continuationState = state;\n                oldContinuation = Interlocked.CompareExchange(ref _continuation, continuation, null);\n            }\n\n            if (oldContinuation != null)\n            {\n                // Operation already completed, so we need to queue the supplied callback.\n                if (!ReferenceEquals(oldContinuation, ManualResetValueTaskSourceCoreShared.s_sentinel))\n                {\n                    ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n                }\n\n                switch (_capturedContext)\n                {\n                    case null:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                        break;\n\n                    case SynchronizationContext sc:\n                        sc.Post(s =>\n                        {\n                            var tuple = (Tuple<Action<object>, object>)s;\n                            tuple.Item1(tuple.Item2);\n                        }, Tuple.Create(continuation, state));\n                        break;\n\n                    case TaskScheduler ts:\n                        Task.Factory.StartNew(continuation, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                        break;\n                }\n            }\n        }\n\n        private void ValidateToken(short token)\n        {\n            if (token != _version)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n        }\n\n        private void SignalCompletion()\n        {\n            if (_completed)\n            {\n                ManualResetValueTaskSourceCoreShared.ThrowInvalidOperationException();\n            }\n            _completed = true;\n\n            if (_continuation != null || Interlocked.CompareExchange(ref _continuation, ManualResetValueTaskSourceCoreShared.s_sentinel, null) != null)\n            {\n                if (_executionContext != null)\n                {\n                    ExecutionContext.Run(\n                        _executionContext,\n                        s => ((ManualResetValueTaskSourceCore<TResult>)s).InvokeContinuation(),\n                        this);\n                }\n                else\n                {\n                    InvokeContinuation();\n                }\n            }\n        }\n\n        private void InvokeContinuation()\n        {\n            switch (_capturedContext)\n            {\n                case null:\n                    if (RunContinuationsAsynchronously)\n                    {\n                        Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);\n                    }\n                    else\n                    {\n                        _continuation(_continuationState);\n                    }\n                    break;\n\n                case SynchronizationContext sc:\n                    sc.Post(s =>\n                    {\n                        var state = (Tuple<Action<object>, object>)s;\n                        state.Item1(state.Item2);\n                    }, Tuple.Create(_continuation, _continuationState));\n                    break;\n\n                case TaskScheduler ts:\n                    Task.Factory.StartNew(_continuation, _continuationState, CancellationToken.None, TaskCreationOptions.DenyChildAttach, ts);\n                    break;\n            }\n        }\n    }\n\n    internal static class ManualResetValueTaskSourceCoreShared // separated out of generic to avoid unnecessary duplication\n    {\n        internal static void ThrowInvalidOperationException() => throw new InvalidOperationException();\n\n        internal static readonly Action<object> s_sentinel = CompletionSentinel;\n        private static void CompletionSentinel(object _) // named method to aid debugging\n        {\n            Debug.Fail(''The sentinel delegate should never be invoked.'');\n            ThrowInvalidOperationException();\n        }\n    }\n}\n\nnamespace System.Runtime.CompilerServices\n{\n    using System.Runtime.InteropServices;\n\n    /// <summary>Represents a builder for asynchronous iterators.</summary>\n    [StructLayout(LayoutKind.Auto)]\n    public struct AsyncIteratorMethodBuilder\n    {\n        // AsyncIteratorMethodBuilder is used by the language compiler as part of generating\n        // async iterators. For now, the implementation just wraps AsyncTaskMethodBuilder, as\n        // most of the logic is shared.  However, in the future this could be changed and\n        // optimized.  For example, we do need to allocate an object (once) to flow state like\n        // ExecutionContext, which AsyncTaskMethodBuilder handles, but it handles it by\n        // allocating a Task-derived object.  We could optimize this further by removing\n        // the Task from the hierarchy, but in doing so we'd also lose a variety of optimizations\n        // related to it, so we'd need to replicate all of those optimizations (e.g. storing\n        // that box object directly into a Task's continuation field).\n\n        private AsyncTaskMethodBuilder _methodBuilder; // mutable struct; do not make it readonly\n\n        public static AsyncIteratorMethodBuilder Create() =>\n            new AsyncIteratorMethodBuilder() { _methodBuilder = AsyncTaskMethodBuilder.Create() };\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void MoveNext<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.Start(ref stateMachine);\n\n        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : INotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitOnCompleted(ref awaiter, ref stateMachine);\n\n        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)\n            where TAwaiter : ICriticalNotifyCompletion\n            where TStateMachine : IAsyncStateMachine =>\n            _methodBuilder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);\n\n        /// <summary>Marks iteration as being completed, whether successfully or otherwise.</summary>\n        public void Complete() => _methodBuilder.SetResult();\n    }\n}\n' 97777"];
38 [label="@'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 97778"];
39 [label="EnumeratorCancellationAttributeType = @'\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]\n    public class EnumeratorCancellationAttribute : Attribute\n    {\n        public EnumeratorCancellationAttribute() { }\n    }\n}\n' 97779"];
40 [label="@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 97780"];
41 [label="NativeIntegerAttributeDefinition =\n@'using System.Collections.Generic;\nnamespace System.Runtime.CompilerServices\n{\n    [System.AttributeUsage(\n        AttributeTargets.Class |\n        AttributeTargets.Event |\n        AttributeTargets.Field |\n        AttributeTargets.GenericParameter |\n        AttributeTargets.Parameter |\n        AttributeTargets.Property |\n        AttributeTargets.ReturnValue,\n        AllowMultiple = false,\n        Inherited = false)]\n    public sealed class NativeIntegerAttribute : Attribute\n    {\n        public NativeIntegerAttribute()\n        {\n            TransformFlags = new[] { true };\n        }\n        public NativeIntegerAttribute(bool[] flags)\n        {\n            TransformFlags = flags;\n        }\n        public readonly IList<bool> TransformFlags;\n    }\n}' 97781"];
42 [label="() => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic } 97782"];
43 [label="LazyThreadSafetyMode.PublicationOnly 97783"];
44 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 97784"];
45 [label="s_lazyDefaultVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net40.mscorlib, Net40.System, Net40.SystemCore, Net40.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 97785"];
46 [label="() => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic } 97786"];
47 [label="LazyThreadSafetyMode.PublicationOnly 97787"];
48 [label="new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 97788"];
49 [label="s_lazyLatestVbReferences = new Lazy<MetadataReference[]>(\n            () => new[] { Net451.mscorlib, Net451.System, Net451.SystemCore, Net451.MicrosoftVisualBasic },\n            LazyThreadSafetyMode.PublicationOnly) 97789"];
50 [label="RuntimeUtilities.IsCoreClrRuntime 97790"];
51 [label="'netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' 97791"];
52 [label="new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51') 97792"];
53 [label="RuntimeCorLibName = RuntimeUtilities.IsCoreClrRuntime\n            ? new AssemblyName('netstandard, Version=2.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51')\n            : new AssemblyName('mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089') 97793"];
54 [label="() =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            } 97794"];
55 [label="LazyThreadSafetyMode.PublicationOnly 97795"];
56 [label="new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 97796"];
57 [label="s_winRtRefs = new Lazy<MetadataReference[]>(\n            () =>\n            {\n                var winmd = AssemblyMetadata.CreateFromImage(TestResources.WinRt.Windows).GetReference(display: 'Windows');\n\n                var windowsruntime =\n                    AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime).GetReference(display: 'System.Runtime.WindowsRuntime.dll');\n\n                var runtime =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll');\n\n                var objectModel =\n                    AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemObjectModel).GetReference(display: 'System.ObjectModel.dll');\n\n                var uixaml = AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319_17929.System_Runtime_WindowsRuntime_UI_Xaml).\n                    GetReference(display: 'System.Runtime.WindowsRuntime.UI.Xaml.dll');\n\n                var interop = AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntimeInteropServicesWindowsRuntime).\n                    GetReference(display: 'System.Runtime.InteropServices.WindowsRuntime.dll');\n\n                //Not mentioned in the adapter doc but pointed to from System.Runtime, so we'll put it here.\n                var system = AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.dll');\n\n                var mscor = AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib');\n\n                return new MetadataReference[] { winmd, windowsruntime, runtime, objectModel, uixaml, interop, system, mscor };\n            },\n            LazyThreadSafetyMode.PublicationOnly) 97797"];
58 [label="() => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref } 97798"];
59 [label="LazyThreadSafetyMode.PublicationOnly 97799"];
60 [label="new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 97800"];
61 [label="s_portableRefsMinimal = new Lazy<MetadataReference[]>(\n            () => new MetadataReference[] { MscorlibPP7Ref, SystemRuntimePP7Ref },\n            LazyThreadSafetyMode.PublicationOnly) 97801"];
62 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll') 97802"];
63 [label="LazyThreadSafetyMode.PublicationOnly 97803"];
64 [label="new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 97804"];
65 [label="s_systemCoreRef =\n            new Lazy<MetadataReference>(\n                () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319.dll'),\n                LazyThreadSafetyMode.PublicationOnly) 97805"];
66 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll') 97806"];
67 [label="LazyThreadSafetyMode.PublicationOnly 97807"];
68 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97808"];
69 [label="s_systemCoreRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemCore).GetReference(display: 'System.Core.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97809"];
70 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll') 97810"];
71 [label="LazyThreadSafetyMode.PublicationOnly 97811"];
72 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97812"];
73 [label="s_systemCoreRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.SystemCore).GetReference(display: 'System.Core.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97813"];
74 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll') 97814"];
75 [label="LazyThreadSafetyMode.PublicationOnly 97815"];
76 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97816"];
77 [label="s_systemWindowsFormsRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemWindowsForms).GetReference(display: 'System.Windows.Forms.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97817"];
78 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll') 97818"];
79 [label="LazyThreadSafetyMode.PublicationOnly 97819"];
80 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97820"];
81 [label="s_systemDrawingRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemDrawing).GetReference(display: 'System.Drawing.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97821"];
82 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll') 97822"];
83 [label="LazyThreadSafetyMode.PublicationOnly 97823"];
84 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97824"];
85 [label="s_systemDataRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemData).GetReference(display: 'System.Data.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97825"];
86 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll') 97826"];
87 [label="LazyThreadSafetyMode.PublicationOnly 97827"];
88 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97828"];
89 [label="s_mscorlibRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97829"];
90 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll') 97830"];
91 [label="LazyThreadSafetyMode.PublicationOnly 97831"];
92 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97832"];
93 [label="s_mscorlibRefPortable = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.v4_0_30319.mscorlib_portable).GetReference(display: 'mscorlib.v4_0_30319.portable.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97833"];
94 [label="() =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            } 97834"];
95 [label="LazyThreadSafetyMode.PublicationOnly 97835"];
96 [label="new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 97836"];
97 [label="s_aacorlibRef = new Lazy<MetadataReference>(\n            () =>\n            {\n                var source = TestResources.NetFX.aacorlib_v15_0_3928.aacorlib_v15_0_3928_cs;\n                var syntaxTree = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(source);\n\n                var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);\n\n                var compilation = CSharpCompilation.Create('aacorlib.v15.0.3928.dll', new[] { syntaxTree }, null, compilationOptions);\n\n                Stream dllStream = new MemoryStream();\n                var emitResult = compilation.Emit(dllStream);\n                if (!emitResult.Success)\n                {\n                    emitResult.Diagnostics.Verify();\n                }\n                dllStream.Seek(0, SeekOrigin.Begin);\n\n                return AssemblyMetadata.CreateFromStream(dllStream).GetReference(display: 'mscorlib.v4_0_30319.dll');\n            },\n            LazyThreadSafetyMode.PublicationOnly) 97837"];
98 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri') 97838"];
99 [label="LazyThreadSafetyMode.PublicationOnly 97839"];
100 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 97840"];
101 [label="s_mscorlibRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.mscorlib).GetReference(display: 'mscorlib.v4_6_1038_0.dll', filePath: @'Z:\\FxReferenceAssembliesUri'),\n            LazyThreadSafetyMode.PublicationOnly) 97841"];
102 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll') 97842"];
103 [label="LazyThreadSafetyMode.PublicationOnly 97843"];
104 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97844"];
105 [label="s_mscorlibRef_silverlight = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.silverlight_v5_0_5_0.mscorlib_v5_0_5_0_silverlight).GetReference(display: 'mscorlib.v5.0.5.0_silverlight.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97845"];
106 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll') 97846"];
107 [label="LazyThreadSafetyMode.PublicationOnly 97847"];
108 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97848"];
109 [label="s_desktopCSharpRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.MicrosoftCSharp).GetReference(display: 'Microsoft.CSharp.v4.0.30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97849"];
110 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll') 97850"];
111 [label="LazyThreadSafetyMode.PublicationOnly 97851"];
112 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97852"];
113 [label="s_std20Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNetStandard20.netstandard).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97853"];
114 [label="() => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll') 97854"];
115 [label="LazyThreadSafetyMode.PublicationOnly 97855"];
116 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97856"];
117 [label="s_46NetStandardFacade = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesBuildExtensions.NetStandardToNet461).GetReference(display: 'netstandard20.netstandard.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97857"];
118 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)') 97858"];
119 [label="LazyThreadSafetyMode.PublicationOnly 97859"];
120 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 97860"];
121 [label="s_systemDynamicRuntimeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.netstandard13.System_Dynamic_Runtime).GetReference(display: 'System.Dynamic.Runtime.dll (netstandard 1.3 ref)'),\n            LazyThreadSafetyMode.PublicationOnly) 97861"];
122 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll') 97862"];
123 [label="LazyThreadSafetyMode.PublicationOnly 97863"];
124 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97864"];
125 [label="s_systemRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97865"];
126 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll') 97866"];
127 [label="LazyThreadSafetyMode.PublicationOnly 97867"];
128 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97868"];
129 [label="s_systemRef_v46 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet461.System).GetReference(display: 'System.v4_6_1038_0.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97869"];
130 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll') 97870"];
131 [label="LazyThreadSafetyMode.PublicationOnly 97871"];
132 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97872"];
133 [label="s_systemRef_v4_0_30319_17929 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.System).GetReference(display: 'System.v4_0_30319_17929.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97873"];
134 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll') 97874"];
135 [label="LazyThreadSafetyMode.PublicationOnly 97875"];
136 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97876"];
137 [label="s_systemRef_v20 = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet20.System).GetReference(display: 'System.v2_0_50727.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97877"];
138 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll') 97878"];
139 [label="LazyThreadSafetyMode.PublicationOnly 97879"];
140 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97880"];
141 [label="s_systemXmlRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXml).GetReference(display: 'System.Xml.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97881"];
142 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll') 97882"];
143 [label="LazyThreadSafetyMode.PublicationOnly 97883"];
144 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97884"];
145 [label="s_systemXmlLinqRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemXmlLinq).GetReference(display: 'System.Xml.Linq.v4_0_30319.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97885"];
146 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll') 97886"];
147 [label="LazyThreadSafetyMode.PublicationOnly 97887"];
148 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97888"];
149 [label="s_mscorlibFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97889"];
150 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll') 97890"];
151 [label="LazyThreadSafetyMode.PublicationOnly 97891"];
152 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97892"];
153 [label="s_systemRuntimeFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemRuntime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97893"];
154 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll') 97894"];
155 [label="LazyThreadSafetyMode.PublicationOnly 97895"];
156 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97896"];
157 [label="s_systemThreadingFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreading).GetReference(display: 'System.Threading.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97897"];
158 [label="() => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll') 97898"];
159 [label="LazyThreadSafetyMode.PublicationOnly 97899"];
160 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97900"];
161 [label="s_systemThreadingTasksFacadeRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ResourcesNet451.SystemThreadingTasks).GetReference(display: 'System.Threading.Tasks.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97901"];
162 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll') 97902"];
163 [label="LazyThreadSafetyMode.PublicationOnly 97903"];
164 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97904"];
165 [label="s_mscorlibPP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.mscorlib).GetReference(display: 'mscorlib.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97905"];
166 [label="() => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll') 97906"];
167 [label="LazyThreadSafetyMode.PublicationOnly 97907"];
168 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97908"];
169 [label="s_systemRuntimePP7Ref = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(ProprietaryTestResources.ReferenceAssemblies_PortableProfile7.System_Runtime).GetReference(display: 'System.Runtime.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97909"];
170 [label="() => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll') 97910"];
171 [label="LazyThreadSafetyMode.PublicationOnly 97911"];
172 [label="new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97912"];
173 [label="s_FSharpTestLibraryRef = new Lazy<MetadataReference>(\n            () => AssemblyMetadata.CreateFromImage(TestResources.General.FSharpTestLibrary).GetReference(display: 'FSharpTestLibrary.dll'),\n            LazyThreadSafetyMode.PublicationOnly) 97913"];
174 [label="@'R:\\Invalid.dll' 97914"];
175 [label="fullPath: @'R:\\Invalid.dll' 97915"];
176 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 97916"];
177 [label="new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 97917"];
178 [label="InvalidRef = new TestMetadataReference(fullPath: @'R:\\Invalid.dll') 97918"];
179 [label="MscorlibRef_v4_0_30316_17626 97919"];
180 [label="Net451.mscorlib 97920"];
181 [label="ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 97921"];
182 [label="s_scriptRefs = ImmutableArray.Create(MscorlibRef_v4_0_30316_17626) 97922"];
183 [label="'/*<bind>*/' 97923"];
184 [label="StartString = '/*<bind>*/' 97924"];
185 [label="'/*</bind>*/' 97925"];
186 [label="EndString = '/*</bind>*/' 97926"];
187 [label="@'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 97927"];
188 [label="SpanSource = @'\nnamespace System\n    {\n        public readonly ref struct Span<T>\n        {\n            private readonly T[] arr;\n\n            public ref T this[int i] => ref arr[i];\n            public override int GetHashCode() => 1;\n            public int Length { get; }\n\n            unsafe public Span(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public Span(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly Span<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(Span<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator Span<T>(T[] array) => new Span<T>(array);\n        }\n\n        public readonly ref struct ReadOnlySpan<T>\n        {\n            private readonly T[] arr;\n\n            public ref readonly T this[int i] => ref arr[i];\n            public override int GetHashCode() => 2;\n            public int Length { get; }\n\n            unsafe public ReadOnlySpan(void* pointer, int length)\n            {\n                this.arr = Helpers.ToArray<T>(pointer, length);\n                this.Length = length;\n            }\n\n            public ReadOnlySpan(T[] arr)\n            {\n                this.arr = arr;\n                this.Length = arr.Length;\n            }\n\n            public void CopyTo(Span<T> other) { }\n\n            /// <summary>Gets an enumerator for this span.</summary>\n            public Enumerator GetEnumerator() => new Enumerator(this);\n\n            /// <summary>Enumerates the elements of a <see cref=''Span{T}''/>.</summary>\n            public ref struct Enumerator\n            {\n                /// <summary>The span being enumerated.</summary>\n                private readonly ReadOnlySpan<T> _span;\n                /// <summary>The next index to yield.</summary>\n                private int _index;\n\n                /// <summary>Initialize the enumerator.</summary>\n                /// <param name=''span''>The span to enumerate.</param>\n                internal Enumerator(ReadOnlySpan<T> span)\n                {\n                    _span = span;\n                    _index = -1;\n                }\n\n                /// <summary>Advances the enumerator to the next element of the span.</summary>\n                public bool MoveNext()\n                {\n                    int index = _index + 1;\n                    if (index < _span.Length)\n                    {\n                        _index = index;\n                        return true;\n                    }\n\n                    return false;\n                }\n\n                /// <summary>Gets the element at the current position of the enumerator.</summary>\n                public ref readonly T Current\n                {\n                    get => ref _span[_index];\n                }\n            }\n\n            public static implicit operator ReadOnlySpan<T>(T[] array) => array == null ? default : new ReadOnlySpan<T>(array);\n\n            public static implicit operator ReadOnlySpan<T>(string stringValue) => string.IsNullOrEmpty(stringValue) ? default : new ReadOnlySpan<T>((T[])(object)stringValue.ToCharArray());\n        }\n\n        public readonly ref struct SpanLike<T>\n        {\n            public readonly Span<T> field;\n        }\n\n        public enum Color: sbyte\n        {\n            Red,\n            Green,\n            Blue\n        }\n\n        public static unsafe class Helpers\n        {\n            public static T[] ToArray<T>(void* ptr, int count)\n            {\n                if (ptr == null)\n                {\n                    return null;\n                }\n\n                if (typeof(T) == typeof(int))\n                {\n                    var arr = new int[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((int*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(byte))\n                {\n                    var arr = new byte[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((byte*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(char))\n                {\n                    var arr = new char[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((char*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                if (typeof(T) == typeof(Color))\n                {\n                    var arr = new Color[count];\n                    for(int i = 0; i < count; i++)\n                    {\n                        arr[i] = ((Color*)ptr)[i];\n                    }\n\n                    return (T[])(object)arr;\n                }\n\n                throw new Exception(''add a case for: '' + typeof(T));\n            }\n        }\n    }' 97928"];
189 [label="@'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 97929"];
190 [label="s_IAsyncEnumerable = @'\nnamespace System.Collections.Generic\n{\n    public interface IAsyncEnumerable<out T>\n    {\n        IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken token = default);\n    }\n\n    public interface IAsyncEnumerator<out T> : System.IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask<bool> MoveNextAsync();\n        T Current { get; }\n    }\n}\nnamespace System\n{\n    public interface IAsyncDisposable\n    {\n        System.Threading.Tasks.ValueTask DisposeAsync();\n    }\n}\n' 97930"];
191 [label="param StatementParsingTests(ITestOutputHelper output) 97931"];
192 [label="param StatementParsingTests(this) 97932"];
193 [label="output 97933"];
194 [label="param ParsingTests(ITestOutputHelper output) 97934"];
195 [label="param ParsingTests(this) 97935"];
196 [label="param CSharpTestBase(this) 97936"];
197 [label="param CommonTestBase(this) 97937"];
198 [label="param TestBase(this) 97938"];
199 [label="_temp 97939"];
200 [label="_node 97940"];
201 [label="_treeEnumerator 97941"];
202 [label="_output 97942"];
203 [label="this._output 97943"];
204 [label="=> Roslyn.Test.Utilities.ExecutionConditionUtil.IsMonoDesktop 97944"];
205 [label="param TestForWithVariableDeclaration(this) 97945"];
206 [label="var text = 'for(T a = 0;;) { }'; 97946"];
207 [label="var statement = this.ParseStatement(text); 97947"];
208 [label="var statement = this.ParseStatement(text); 97948"];
209 [label="this.ParseStatement(text) 97949"];
210 [label="param ParseStatement(string text) 97950"];
211 [label="param ParseStatement(int offset = 0) 97951"];
212 [label="param ParseStatement(ParseOptions options = null) 97952"];
213 [label="param ParseStatement(this) 97953"];
214 [label="'\\r\\n' 97954"];
215 [label="CrLf = '\\r\\n' 97955"];
216 [label="CrLf 97956"];
217 [label="EndOfLine(CrLf) 97957"];
218 [label="param EndOfLine(string text) 97958"];
219 [label="param EndOfLine(bool elastic = false) 97959"];
220 [label="SyntaxTrivia trivia = null; 97960"];
221 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 97961"];
222 [label="elastic 97962"];
223 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 97963"];
224 [label="if (trivia != null)\n            {\n                return trivia;\n            } 97964"];
225 [label="if (trivia != null)\n            {\n                return trivia;\n            } 97965"];
226 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTrivia), r => new SyntaxTrivia(r)); 97966"];
227 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 97967"];
228 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 97968"];
229 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 97969"];
230 [label="param Create(SyntaxKind kind) 97970"];
231 [label="param Create(string text) 97971"];
232 [label="return new SyntaxTrivia(kind, text); 97972"];
233 [label="return new SyntaxTrivia(kind, text); 97973"];
234 [label="return new SyntaxTrivia(kind, text); 97974"];
235 [label="new SyntaxTrivia(kind, text) 97975"];
236 [label="param SyntaxTrivia(SyntaxKind kind) 97976"];
237 [label="param SyntaxTrivia(string text) 97977"];
238 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 97978"];
239 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 97979"];
240 [label="param SyntaxTrivia(this) 97980"];
241 [label="kind 97981"];
242 [label="diagnostics 97982"];
243 [label="annotations 97983"];
244 [label="new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 97984"];
245 [label="s_structuresTable\n            = new ConditionalWeakTable<SyntaxNode, Dictionary<CodeAnalysis.SyntaxTrivia, SyntaxNode>>() 97985"];
246 [label="text 97986"];
247 [label="param SyntaxTrivia(this) 97987"];
248 [label="param CSharpSyntaxNode(SyntaxKind kind) 97988"];
249 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 97989"];
250 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 97990"];
251 [label="param CSharpSyntaxNode(int fullWidth) 97991"];
252 [label="param CSharpSyntaxNode(this) 97992"];
253 [label="kind 97993"];
254 [label="diagnostics 97994"];
255 [label="annotations 97995"];
256 [label="fullWidth 97996"];
257 [label="param CSharpSyntaxNode(this) 97997"];
258 [label="param CSharpSyntaxNode(this) 97998"];
259 [label="GreenStats.NoteGreen(this); 97999"];
260 [label="GreenStats.NoteGreen(this); 98000"];
261 [label="Text 98001"];
262 [label="this.Text 98002"];
263 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98003"];
264 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98004"];
265 [label="if (!elastic)\n            {\n                return trivia;\n            } 98005"];
266 [label="return trivia; 98006"];
267 [label="CarriageReturnLineFeed = EndOfLine(CrLf) 98007"];
268 [label="'\\n' 98008"];
269 [label="EndOfLine('\\n') 98009"];
270 [label="param EndOfLine(string text) 98010"];
271 [label="param EndOfLine(bool elastic = false) 98011"];
272 [label="SyntaxTrivia trivia = null; 98012"];
273 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 98013"];
274 [label="elastic 98014"];
275 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 98015"];
276 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98016"];
277 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98017"];
278 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98018"];
279 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98019"];
280 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 98020"];
281 [label="param Create(SyntaxKind kind) 98021"];
282 [label="param Create(string text) 98022"];
283 [label="return new SyntaxTrivia(kind, text); 98023"];
284 [label="return new SyntaxTrivia(kind, text); 98024"];
285 [label="return new SyntaxTrivia(kind, text); 98025"];
286 [label="new SyntaxTrivia(kind, text) 98026"];
287 [label="param SyntaxTrivia(SyntaxKind kind) 98027"];
288 [label="param SyntaxTrivia(string text) 98028"];
289 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98029"];
290 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98030"];
291 [label="param SyntaxTrivia(this) 98031"];
292 [label="kind 98032"];
293 [label="diagnostics 98033"];
294 [label="annotations 98034"];
295 [label="text 98035"];
296 [label="param SyntaxTrivia(this) 98036"];
297 [label="param CSharpSyntaxNode(SyntaxKind kind) 98037"];
298 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98038"];
299 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98039"];
300 [label="param CSharpSyntaxNode(int fullWidth) 98040"];
301 [label="param CSharpSyntaxNode(this) 98041"];
302 [label="kind 98042"];
303 [label="diagnostics 98043"];
304 [label="annotations 98044"];
305 [label="fullWidth 98045"];
306 [label="param CSharpSyntaxNode(this) 98046"];
307 [label="param CSharpSyntaxNode(this) 98047"];
308 [label="GreenStats.NoteGreen(this); 98048"];
309 [label="GreenStats.NoteGreen(this); 98049"];
310 [label="Text 98050"];
311 [label="this.Text 98051"];
312 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98052"];
313 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98053"];
314 [label="if (!elastic)\n            {\n                return trivia;\n            } 98054"];
315 [label="return trivia; 98055"];
316 [label="LineFeed = EndOfLine('\\n') 98056"];
317 [label="'\\r' 98057"];
318 [label="EndOfLine('\\r') 98058"];
319 [label="param EndOfLine(string text) 98059"];
320 [label="param EndOfLine(bool elastic = false) 98060"];
321 [label="SyntaxTrivia trivia = null; 98061"];
322 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 98062"];
323 [label="elastic 98063"];
324 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 98064"];
325 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98065"];
326 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98066"];
327 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98067"];
328 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98068"];
329 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 98069"];
330 [label="param Create(SyntaxKind kind) 98070"];
331 [label="param Create(string text) 98071"];
332 [label="return new SyntaxTrivia(kind, text); 98072"];
333 [label="return new SyntaxTrivia(kind, text); 98073"];
334 [label="return new SyntaxTrivia(kind, text); 98074"];
335 [label="new SyntaxTrivia(kind, text) 98075"];
336 [label="param SyntaxTrivia(SyntaxKind kind) 98076"];
337 [label="param SyntaxTrivia(string text) 98077"];
338 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98078"];
339 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98079"];
340 [label="param SyntaxTrivia(this) 98080"];
341 [label="kind 98081"];
342 [label="diagnostics 98082"];
343 [label="annotations 98083"];
344 [label="text 98084"];
345 [label="param SyntaxTrivia(this) 98085"];
346 [label="param CSharpSyntaxNode(SyntaxKind kind) 98086"];
347 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98087"];
348 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98088"];
349 [label="param CSharpSyntaxNode(int fullWidth) 98089"];
350 [label="param CSharpSyntaxNode(this) 98090"];
351 [label="kind 98091"];
352 [label="diagnostics 98092"];
353 [label="annotations 98093"];
354 [label="fullWidth 98094"];
355 [label="param CSharpSyntaxNode(this) 98095"];
356 [label="param CSharpSyntaxNode(this) 98096"];
357 [label="GreenStats.NoteGreen(this); 98097"];
358 [label="GreenStats.NoteGreen(this); 98098"];
359 [label="Text 98099"];
360 [label="this.Text 98100"];
361 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98101"];
362 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98102"];
363 [label="if (!elastic)\n            {\n                return trivia;\n            } 98103"];
364 [label="return trivia; 98104"];
365 [label="CarriageReturn = EndOfLine('\\r') 98105"];
366 [label="' ' 98106"];
367 [label="Whitespace(' ') 98107"];
368 [label="param Whitespace(string text) 98108"];
369 [label="param Whitespace(bool elastic = false) 98109"];
370 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98110"];
371 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98111"];
372 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 98112"];
373 [label="param Create(SyntaxKind kind) 98113"];
374 [label="param Create(string text) 98114"];
375 [label="return new SyntaxTrivia(kind, text); 98115"];
376 [label="return new SyntaxTrivia(kind, text); 98116"];
377 [label="return new SyntaxTrivia(kind, text); 98117"];
378 [label="new SyntaxTrivia(kind, text) 98118"];
379 [label="param SyntaxTrivia(SyntaxKind kind) 98119"];
380 [label="param SyntaxTrivia(string text) 98120"];
381 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98121"];
382 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98122"];
383 [label="param SyntaxTrivia(this) 98123"];
384 [label="kind 98124"];
385 [label="diagnostics 98125"];
386 [label="annotations 98126"];
387 [label="text 98127"];
388 [label="param SyntaxTrivia(this) 98128"];
389 [label="param CSharpSyntaxNode(SyntaxKind kind) 98129"];
390 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98130"];
391 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98131"];
392 [label="param CSharpSyntaxNode(int fullWidth) 98132"];
393 [label="param CSharpSyntaxNode(this) 98133"];
394 [label="kind 98134"];
395 [label="diagnostics 98135"];
396 [label="annotations 98136"];
397 [label="fullWidth 98137"];
398 [label="param CSharpSyntaxNode(this) 98138"];
399 [label="param CSharpSyntaxNode(this) 98139"];
400 [label="GreenStats.NoteGreen(this); 98140"];
401 [label="GreenStats.NoteGreen(this); 98141"];
402 [label="Text 98142"];
403 [label="this.Text 98143"];
404 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98144"];
405 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98145"];
406 [label="if (!elastic)\n            {\n                return trivia;\n            } 98146"];
407 [label="return trivia; 98147"];
408 [label="Space = Whitespace(' ') 98148"];
409 [label="'\\t' 98149"];
410 [label="Whitespace('\\t') 98150"];
411 [label="param Whitespace(string text) 98151"];
412 [label="param Whitespace(bool elastic = false) 98152"];
413 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98153"];
414 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98154"];
415 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 98155"];
416 [label="param Create(SyntaxKind kind) 98156"];
417 [label="param Create(string text) 98157"];
418 [label="return new SyntaxTrivia(kind, text); 98158"];
419 [label="return new SyntaxTrivia(kind, text); 98159"];
420 [label="return new SyntaxTrivia(kind, text); 98160"];
421 [label="new SyntaxTrivia(kind, text) 98161"];
422 [label="param SyntaxTrivia(SyntaxKind kind) 98162"];
423 [label="param SyntaxTrivia(string text) 98163"];
424 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98164"];
425 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98165"];
426 [label="param SyntaxTrivia(this) 98166"];
427 [label="kind 98167"];
428 [label="diagnostics 98168"];
429 [label="annotations 98169"];
430 [label="text 98170"];
431 [label="param SyntaxTrivia(this) 98171"];
432 [label="param CSharpSyntaxNode(SyntaxKind kind) 98172"];
433 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98173"];
434 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98174"];
435 [label="param CSharpSyntaxNode(int fullWidth) 98175"];
436 [label="param CSharpSyntaxNode(this) 98176"];
437 [label="kind 98177"];
438 [label="diagnostics 98178"];
439 [label="annotations 98179"];
440 [label="fullWidth 98180"];
441 [label="param CSharpSyntaxNode(this) 98181"];
442 [label="param CSharpSyntaxNode(this) 98182"];
443 [label="GreenStats.NoteGreen(this); 98183"];
444 [label="GreenStats.NoteGreen(this); 98184"];
445 [label="Text 98185"];
446 [label="this.Text 98186"];
447 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98187"];
448 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98188"];
449 [label="if (!elastic)\n            {\n                return trivia;\n            } 98189"];
450 [label="return trivia; 98190"];
451 [label="Tab = Whitespace('\\t') 98191"];
452 [label="CrLf 98192"];
453 [label="true 98193"];
454 [label="elastic: true 98194"];
455 [label="EndOfLine(CrLf, elastic: true) 98195"];
456 [label="param EndOfLine(string text) 98196"];
457 [label="param EndOfLine(bool elastic = false) 98197"];
458 [label="SyntaxTrivia trivia = null; 98198"];
459 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 98199"];
460 [label="elastic 98200"];
461 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed; 98201"];
462 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98202"];
463 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98203"];
464 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98204"];
465 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98205"];
466 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 98206"];
467 [label="param Create(SyntaxKind kind) 98207"];
468 [label="param Create(string text) 98208"];
469 [label="return new SyntaxTrivia(kind, text); 98209"];
470 [label="return new SyntaxTrivia(kind, text); 98210"];
471 [label="return new SyntaxTrivia(kind, text); 98211"];
472 [label="new SyntaxTrivia(kind, text) 98212"];
473 [label="param SyntaxTrivia(SyntaxKind kind) 98213"];
474 [label="param SyntaxTrivia(string text) 98214"];
475 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98215"];
476 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98216"];
477 [label="param SyntaxTrivia(this) 98217"];
478 [label="kind 98218"];
479 [label="diagnostics 98219"];
480 [label="annotations 98220"];
481 [label="text 98221"];
482 [label="param SyntaxTrivia(this) 98222"];
483 [label="param CSharpSyntaxNode(SyntaxKind kind) 98223"];
484 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98224"];
485 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98225"];
486 [label="param CSharpSyntaxNode(int fullWidth) 98226"];
487 [label="param CSharpSyntaxNode(this) 98227"];
488 [label="kind 98228"];
489 [label="diagnostics 98229"];
490 [label="annotations 98230"];
491 [label="fullWidth 98231"];
492 [label="param CSharpSyntaxNode(this) 98232"];
493 [label="param CSharpSyntaxNode(this) 98233"];
494 [label="GreenStats.NoteGreen(this); 98234"];
495 [label="GreenStats.NoteGreen(this); 98235"];
496 [label="Text 98236"];
497 [label="this.Text 98237"];
498 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98238"];
499 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98239"];
500 [label="if (!elastic)\n            {\n                return trivia;\n            } 98240"];
501 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98241"];
502 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98242"];
503 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98243"];
504 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98244"];
505 [label="param SetAnnotations(SyntaxAnnotation[]? annotations) 98245"];
506 [label="param SetAnnotations(this) 98246"];
507 [label="this.Kind 98247"];
508 [label="get { return (SyntaxKind)this.RawKind; } 98248"];
509 [label="return (SyntaxKind)this.RawKind; 98249"];
510 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98250"];
511 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98251"];
512 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98252"];
513 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98253"];
514 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98254"];
515 [label="param SyntaxTrivia(SyntaxKind kind) 98255"];
516 [label="param SyntaxTrivia(string text) 98256"];
517 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98257"];
518 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98258"];
519 [label="param SyntaxTrivia(this) 98259"];
520 [label="param SyntaxTrivia(this) 98260"];
521 [label="param CSharpSyntaxNode(this) 98261"];
522 [label="param CSharpSyntaxNode(this) 98262"];
523 [label="param CSharpSyntaxNode(this) 98263"];
524 [label="GreenStats.NoteGreen(this); 98264"];
525 [label="Text 98265"];
526 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98266"];
527 [label="ElasticCarriageReturnLineFeed = EndOfLine(CrLf, elastic: true) 98267"];
528 [label="'\\n' 98268"];
529 [label="true 98269"];
530 [label="elastic: true 98270"];
531 [label="EndOfLine('\\n', elastic: true) 98271"];
532 [label="param EndOfLine(string text) 98272"];
533 [label="param EndOfLine(bool elastic = false) 98273"];
534 [label="SyntaxTrivia trivia = null; 98274"];
535 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 98275"];
536 [label="elastic 98276"];
537 [label="trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed; 98277"];
538 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98278"];
539 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98279"];
540 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98280"];
541 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98281"];
542 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 98282"];
543 [label="param Create(SyntaxKind kind) 98283"];
544 [label="param Create(string text) 98284"];
545 [label="return new SyntaxTrivia(kind, text); 98285"];
546 [label="return new SyntaxTrivia(kind, text); 98286"];
547 [label="return new SyntaxTrivia(kind, text); 98287"];
548 [label="new SyntaxTrivia(kind, text) 98288"];
549 [label="param SyntaxTrivia(SyntaxKind kind) 98289"];
550 [label="param SyntaxTrivia(string text) 98290"];
551 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98291"];
552 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98292"];
553 [label="param SyntaxTrivia(this) 98293"];
554 [label="kind 98294"];
555 [label="diagnostics 98295"];
556 [label="annotations 98296"];
557 [label="text 98297"];
558 [label="param SyntaxTrivia(this) 98298"];
559 [label="param CSharpSyntaxNode(SyntaxKind kind) 98299"];
560 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98300"];
561 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98301"];
562 [label="param CSharpSyntaxNode(int fullWidth) 98302"];
563 [label="param CSharpSyntaxNode(this) 98303"];
564 [label="kind 98304"];
565 [label="diagnostics 98305"];
566 [label="annotations 98306"];
567 [label="fullWidth 98307"];
568 [label="param CSharpSyntaxNode(this) 98308"];
569 [label="param CSharpSyntaxNode(this) 98309"];
570 [label="GreenStats.NoteGreen(this); 98310"];
571 [label="GreenStats.NoteGreen(this); 98311"];
572 [label="Text 98312"];
573 [label="this.Text 98313"];
574 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98314"];
575 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98315"];
576 [label="if (!elastic)\n            {\n                return trivia;\n            } 98316"];
577 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98317"];
578 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98318"];
579 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98319"];
580 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98320"];
581 [label="this.Kind 98321"];
582 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98322"];
583 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98323"];
584 [label="param SyntaxTrivia(this) 98324"];
585 [label="param SyntaxTrivia(this) 98325"];
586 [label="param CSharpSyntaxNode(this) 98326"];
587 [label="param CSharpSyntaxNode(this) 98327"];
588 [label="GreenStats.NoteGreen(this); 98328"];
589 [label="Text 98329"];
590 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98330"];
591 [label="ElasticLineFeed = EndOfLine('\\n', elastic: true) 98331"];
592 [label="'\\r' 98332"];
593 [label="true 98333"];
594 [label="elastic: true 98334"];
595 [label="EndOfLine('\\r', elastic: true) 98335"];
596 [label="param EndOfLine(string text) 98336"];
597 [label="param EndOfLine(bool elastic = false) 98337"];
598 [label="SyntaxTrivia trivia = null; 98338"];
599 [label="switch (text)\n            {\n                case '\\r':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn;\n                    break;\n                case '\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticLineFeed : SyntaxFactory.LineFeed;\n                    break;\n                case '\\r\\n':\n                    trivia = elastic ? SyntaxFactory.ElasticCarriageReturnLineFeed : SyntaxFactory.CarriageReturnLineFeed;\n                    break;\n            } 98339"];
600 [label="elastic 98340"];
601 [label="trivia = elastic ? SyntaxFactory.ElasticCarriageReturn : SyntaxFactory.CarriageReturn; 98341"];
602 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98342"];
603 [label="if (trivia != null)\n            {\n                return trivia;\n            } 98343"];
604 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98344"];
605 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98345"];
606 [label="SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text) 98346"];
607 [label="param Create(SyntaxKind kind) 98347"];
608 [label="param Create(string text) 98348"];
609 [label="return new SyntaxTrivia(kind, text); 98349"];
610 [label="return new SyntaxTrivia(kind, text); 98350"];
611 [label="return new SyntaxTrivia(kind, text); 98351"];
612 [label="new SyntaxTrivia(kind, text) 98352"];
613 [label="param SyntaxTrivia(SyntaxKind kind) 98353"];
614 [label="param SyntaxTrivia(string text) 98354"];
615 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98355"];
616 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98356"];
617 [label="param SyntaxTrivia(this) 98357"];
618 [label="kind 98358"];
619 [label="diagnostics 98359"];
620 [label="annotations 98360"];
621 [label="text 98361"];
622 [label="param SyntaxTrivia(this) 98362"];
623 [label="param CSharpSyntaxNode(SyntaxKind kind) 98363"];
624 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98364"];
625 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98365"];
626 [label="param CSharpSyntaxNode(int fullWidth) 98366"];
627 [label="param CSharpSyntaxNode(this) 98367"];
628 [label="kind 98368"];
629 [label="diagnostics 98369"];
630 [label="annotations 98370"];
631 [label="fullWidth 98371"];
632 [label="param CSharpSyntaxNode(this) 98372"];
633 [label="param CSharpSyntaxNode(this) 98373"];
634 [label="GreenStats.NoteGreen(this); 98374"];
635 [label="GreenStats.NoteGreen(this); 98375"];
636 [label="Text 98376"];
637 [label="this.Text 98377"];
638 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98378"];
639 [label="trivia = SyntaxTrivia.Create(SyntaxKind.EndOfLineTrivia, text); 98379"];
640 [label="if (!elastic)\n            {\n                return trivia;\n            } 98380"];
641 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98381"];
642 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98382"];
643 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98383"];
644 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98384"];
645 [label="this.Kind 98385"];
646 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98386"];
647 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98387"];
648 [label="param SyntaxTrivia(this) 98388"];
649 [label="param SyntaxTrivia(this) 98389"];
650 [label="param CSharpSyntaxNode(this) 98390"];
651 [label="param CSharpSyntaxNode(this) 98391"];
652 [label="GreenStats.NoteGreen(this); 98392"];
653 [label="Text 98393"];
654 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98394"];
655 [label="ElasticCarriageReturn = EndOfLine('\\r', elastic: true) 98395"];
656 [label="' ' 98396"];
657 [label="true 98397"];
658 [label="elastic: true 98398"];
659 [label="Whitespace(' ', elastic: true) 98399"];
660 [label="param Whitespace(string text) 98400"];
661 [label="param Whitespace(bool elastic = false) 98401"];
662 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98402"];
663 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98403"];
664 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 98404"];
665 [label="param Create(SyntaxKind kind) 98405"];
666 [label="param Create(string text) 98406"];
667 [label="return new SyntaxTrivia(kind, text); 98407"];
668 [label="return new SyntaxTrivia(kind, text); 98408"];
669 [label="return new SyntaxTrivia(kind, text); 98409"];
670 [label="new SyntaxTrivia(kind, text) 98410"];
671 [label="param SyntaxTrivia(SyntaxKind kind) 98411"];
672 [label="param SyntaxTrivia(string text) 98412"];
673 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98413"];
674 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98414"];
675 [label="param SyntaxTrivia(this) 98415"];
676 [label="kind 98416"];
677 [label="diagnostics 98417"];
678 [label="annotations 98418"];
679 [label="text 98419"];
680 [label="param SyntaxTrivia(this) 98420"];
681 [label="param CSharpSyntaxNode(SyntaxKind kind) 98421"];
682 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98422"];
683 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98423"];
684 [label="param CSharpSyntaxNode(int fullWidth) 98424"];
685 [label="param CSharpSyntaxNode(this) 98425"];
686 [label="kind 98426"];
687 [label="diagnostics 98427"];
688 [label="annotations 98428"];
689 [label="fullWidth 98429"];
690 [label="param CSharpSyntaxNode(this) 98430"];
691 [label="param CSharpSyntaxNode(this) 98431"];
692 [label="GreenStats.NoteGreen(this); 98432"];
693 [label="GreenStats.NoteGreen(this); 98433"];
694 [label="Text 98434"];
695 [label="this.Text 98435"];
696 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98436"];
697 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98437"];
698 [label="if (!elastic)\n            {\n                return trivia;\n            } 98438"];
699 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98439"];
700 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98440"];
701 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98441"];
702 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98442"];
703 [label="this.Kind 98443"];
704 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98444"];
705 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98445"];
706 [label="param SyntaxTrivia(this) 98446"];
707 [label="param SyntaxTrivia(this) 98447"];
708 [label="param CSharpSyntaxNode(this) 98448"];
709 [label="param CSharpSyntaxNode(this) 98449"];
710 [label="GreenStats.NoteGreen(this); 98450"];
711 [label="Text 98451"];
712 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98452"];
713 [label="ElasticSpace = Whitespace(' ', elastic: true) 98453"];
714 [label="'\\t' 98454"];
715 [label="true 98455"];
716 [label="elastic: true 98456"];
717 [label="Whitespace('\\t', elastic: true) 98457"];
718 [label="param Whitespace(string text) 98458"];
719 [label="param Whitespace(bool elastic = false) 98459"];
720 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98460"];
721 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98461"];
722 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 98462"];
723 [label="param Create(SyntaxKind kind) 98463"];
724 [label="param Create(string text) 98464"];
725 [label="return new SyntaxTrivia(kind, text); 98465"];
726 [label="return new SyntaxTrivia(kind, text); 98466"];
727 [label="return new SyntaxTrivia(kind, text); 98467"];
728 [label="new SyntaxTrivia(kind, text) 98468"];
729 [label="param SyntaxTrivia(SyntaxKind kind) 98469"];
730 [label="param SyntaxTrivia(string text) 98470"];
731 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98471"];
732 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98472"];
733 [label="param SyntaxTrivia(this) 98473"];
734 [label="kind 98474"];
735 [label="diagnostics 98475"];
736 [label="annotations 98476"];
737 [label="text 98477"];
738 [label="param SyntaxTrivia(this) 98478"];
739 [label="param CSharpSyntaxNode(SyntaxKind kind) 98479"];
740 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98480"];
741 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98481"];
742 [label="param CSharpSyntaxNode(int fullWidth) 98482"];
743 [label="param CSharpSyntaxNode(this) 98483"];
744 [label="kind 98484"];
745 [label="diagnostics 98485"];
746 [label="annotations 98486"];
747 [label="fullWidth 98487"];
748 [label="param CSharpSyntaxNode(this) 98488"];
749 [label="param CSharpSyntaxNode(this) 98489"];
750 [label="GreenStats.NoteGreen(this); 98490"];
751 [label="GreenStats.NoteGreen(this); 98491"];
752 [label="Text 98492"];
753 [label="this.Text 98493"];
754 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98494"];
755 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98495"];
756 [label="if (!elastic)\n            {\n                return trivia;\n            } 98496"];
757 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98497"];
758 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98498"];
759 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98499"];
760 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98500"];
761 [label="this.Kind 98501"];
762 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98502"];
763 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98503"];
764 [label="param SyntaxTrivia(this) 98504"];
765 [label="param SyntaxTrivia(this) 98505"];
766 [label="param CSharpSyntaxNode(this) 98506"];
767 [label="param CSharpSyntaxNode(this) 98507"];
768 [label="GreenStats.NoteGreen(this); 98508"];
769 [label="Text 98509"];
770 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98510"];
771 [label="ElasticTab = Whitespace('\\t', elastic: true) 98511"];
772 [label="string.Empty 98512"];
773 [label="true 98513"];
774 [label="elastic: true 98514"];
775 [label="Whitespace(string.Empty, elastic: true) 98515"];
776 [label="param Whitespace(string text) 98516"];
777 [label="param Whitespace(bool elastic = false) 98517"];
778 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98518"];
779 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98519"];
780 [label="SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text) 98520"];
781 [label="param Create(SyntaxKind kind) 98521"];
782 [label="param Create(string text) 98522"];
783 [label="return new SyntaxTrivia(kind, text); 98523"];
784 [label="return new SyntaxTrivia(kind, text); 98524"];
785 [label="return new SyntaxTrivia(kind, text); 98525"];
786 [label="new SyntaxTrivia(kind, text) 98526"];
787 [label="param SyntaxTrivia(SyntaxKind kind) 98527"];
788 [label="param SyntaxTrivia(string text) 98528"];
789 [label="param SyntaxTrivia(DiagnosticInfo[]? diagnostics = null) 98529"];
790 [label="param SyntaxTrivia(SyntaxAnnotation[]? annotations = null) 98530"];
791 [label="param SyntaxTrivia(this) 98531"];
792 [label="kind 98532"];
793 [label="diagnostics 98533"];
794 [label="annotations 98534"];
795 [label="text 98535"];
796 [label="param SyntaxTrivia(this) 98536"];
797 [label="param CSharpSyntaxNode(SyntaxKind kind) 98537"];
798 [label="param CSharpSyntaxNode(DiagnosticInfo[] diagnostics) 98538"];
799 [label="param CSharpSyntaxNode(SyntaxAnnotation[] annotations) 98539"];
800 [label="param CSharpSyntaxNode(int fullWidth) 98540"];
801 [label="param CSharpSyntaxNode(this) 98541"];
802 [label="kind 98542"];
803 [label="diagnostics 98543"];
804 [label="annotations 98544"];
805 [label="fullWidth 98545"];
806 [label="param CSharpSyntaxNode(this) 98546"];
807 [label="param CSharpSyntaxNode(this) 98547"];
808 [label="GreenStats.NoteGreen(this); 98548"];
809 [label="GreenStats.NoteGreen(this); 98549"];
810 [label="Text 98550"];
811 [label="this.Text 98551"];
812 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98552"];
813 [label="var trivia = SyntaxTrivia.Create(SyntaxKind.WhitespaceTrivia, text); 98553"];
814 [label="if (!elastic)\n            {\n                return trivia;\n            } 98554"];
815 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98555"];
816 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98556"];
817 [label="new[] { SyntaxAnnotation.ElasticAnnotation } 98557"];
818 [label="return trivia.WithAnnotationsGreen(new[] { SyntaxAnnotation.ElasticAnnotation }); 98558"];
819 [label="this.Kind 98559"];
820 [label="return new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations); 98560"];
821 [label="new SyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations) 98561"];
822 [label="param SyntaxTrivia(this) 98562"];
823 [label="param SyntaxTrivia(this) 98563"];
824 [label="param CSharpSyntaxNode(this) 98564"];
825 [label="param CSharpSyntaxNode(this) 98565"];
826 [label="GreenStats.NoteGreen(this); 98566"];
827 [label="Text 98567"];
828 [label="if (kind == SyntaxKind.PreprocessingMessageTrivia)\n            {\n                this.flags |= NodeFlags.ContainsSkippedText;\n            } 98568"];
829 [label="ElasticZeroSpace = Whitespace(string.Empty, elastic: true) 98569"];
830 [label="s_xmlCarriageReturnLineFeed 98570"];
831 [label="public static SyntaxTrivia CarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturnLineFeed; 98571"];
832 [label="param operator(SyntaxTrivia trivia) 98572"];
833 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98573"];
834 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98574"];
835 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98575"];
836 [label="public static SyntaxTrivia LineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.LineFeed; 98576"];
837 [label="param operator(SyntaxTrivia trivia) 98577"];
838 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98578"];
839 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98579"];
840 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98580"];
841 [label="public static SyntaxTrivia CarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.CarriageReturn; 98581"];
842 [label="param operator(SyntaxTrivia trivia) 98582"];
843 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98583"];
844 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98584"];
845 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98585"];
846 [label="public static SyntaxTrivia Space { get; } = Syntax.InternalSyntax.SyntaxFactory.Space; 98586"];
847 [label="param operator(SyntaxTrivia trivia) 98587"];
848 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98588"];
849 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98589"];
850 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98590"];
851 [label="public static SyntaxTrivia Tab { get; } = Syntax.InternalSyntax.SyntaxFactory.Tab; 98591"];
852 [label="param operator(SyntaxTrivia trivia) 98592"];
853 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98593"];
854 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98594"];
855 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98595"];
856 [label="public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturnLineFeed; 98596"];
857 [label="param operator(SyntaxTrivia trivia) 98597"];
858 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98598"];
859 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98599"];
860 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98600"];
861 [label="public static SyntaxTrivia ElasticLineFeed { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticLineFeed; 98601"];
862 [label="param operator(SyntaxTrivia trivia) 98602"];
863 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98603"];
864 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98604"];
865 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98605"];
866 [label="public static SyntaxTrivia ElasticCarriageReturn { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticCarriageReturn; 98606"];
867 [label="param operator(SyntaxTrivia trivia) 98607"];
868 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98608"];
869 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98609"];
870 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98610"];
871 [label="public static SyntaxTrivia ElasticSpace { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticSpace; 98611"];
872 [label="param operator(SyntaxTrivia trivia) 98612"];
873 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98613"];
874 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98614"];
875 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98615"];
876 [label="public static SyntaxTrivia ElasticTab { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticTab; 98616"];
877 [label="param operator(SyntaxTrivia trivia) 98617"];
878 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98618"];
879 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98619"];
880 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98620"];
881 [label="public static SyntaxTrivia ElasticMarker { get; } = Syntax.InternalSyntax.SyntaxFactory.ElasticZeroSpace; 98621"];
882 [label="param operator(SyntaxTrivia trivia) 98622"];
883 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98623"];
884 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98624"];
885 [label="return new CodeAnalysis.SyntaxTrivia(token: default, trivia, position: 0, index: 0); 98625"];
886 [label="return SyntaxFactory.ParseStatement(text, offset, options); 98626"];
887 [label="return SyntaxFactory.ParseStatement(text, offset, options); 98627"];
888 [label="return SyntaxFactory.ParseStatement(text, offset, options); 98628"];
889 [label="return SyntaxFactory.ParseStatement(text, offset, options); 98629"];
890 [label="SyntaxFactory.ParseStatement(text, offset, options) 98630"];
891 [label="param ParseStatement(string text) 98631"];
892 [label="param ParseStatement(int offset = 0) 98632"];
893 [label="param ParseStatement(ParseOptions? options = null) 98633"];
894 [label="param ParseStatement(bool consumeFullText = true) 98634"];
895 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 98635"];
896 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 98636"];
897 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 98637"];
898 [label="MakeLexer(text, offset, (CSharpParseOptions?)options) 98638"];
899 [label="param MakeLexer(string text) 98639"];
900 [label="param MakeLexer(int offset) 98640"];
901 [label="param MakeLexer(CSharpParseOptions? options = null) 98641"];
902 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 98642"];
903 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 98643"];
904 [label="MakeSourceText(text, offset) 98644"];
905 [label="param MakeSourceText(string text) 98645"];
906 [label="param MakeSourceText(int offset) 98646"];
907 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98647"];
908 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98648"];
909 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98649"];
910 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98650"];
911 [label="return SourceText.From(text, Encoding.UTF8).GetSubText(offset); 98651"];
912 [label="new CSharpParseOptions() 98652"];
913 [label="param CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default) 98653"];
914 [label="param CSharpParseOptions(DocumentationMode documentationMode = DocumentationMode.Parse) 98654"];
915 [label="param CSharpParseOptions(SourceCodeKind kind = SourceCodeKind.Regular) 98655"];
916 [label="param CSharpParseOptions(IEnumerable<string>? preprocessorSymbols = null) 98656"];
917 [label="param CSharpParseOptions(this) 98657"];
918 [label="languageVersion 98658"];
919 [label="documentationMode 98659"];
920 [label="kind 98660"];
921 [label="preprocessorSymbols 98661"];
922 [label="preprocessorSymbols.ToImmutableArrayOrEmpty() 98662"];
923 [label="ImmutableDictionary<string, string>.Empty 98663"];
924 [label="param CSharpParseOptions(LanguageVersion languageVersion) 98664"];
925 [label="param CSharpParseOptions(DocumentationMode documentationMode) 98665"];
926 [label="param CSharpParseOptions(SourceCodeKind kind) 98666"];
927 [label="param CSharpParseOptions(ImmutableArray<string> preprocessorSymbols) 98667"];
928 [label="param CSharpParseOptions(IReadOnlyDictionary<string, string>? features) 98668"];
929 [label="param CSharpParseOptions(this) 98669"];
930 [label="kind 98670"];
931 [label="documentationMode 98671"];
932 [label="param CSharpParseOptions(this) 98672"];
933 [label="_features 98673"];
934 [label="public LanguageVersion LanguageVersion { get; private set; } 98674"];
935 [label="public LanguageVersion SpecifiedLanguageVersion { get; private set; } 98675"];
936 [label="this.SpecifiedLanguageVersion 98676"];
937 [label="this.LanguageVersion = languageVersion.MapSpecifiedToEffectiveVersion(); 98677"];
938 [label="languageVersion.MapSpecifiedToEffectiveVersion() 98678"];
939 [label="param MapSpecifiedToEffectiveVersion(this LanguageVersion version) 98679"];
940 [label="switch (version)\n            {\n                case LanguageVersion.Latest:\n                case LanguageVersion.Default:\n                case LanguageVersion.LatestMajor:\n                    return LanguageVersion.CSharp9;\n                default:\n                    return version;\n            } 98680"];
941 [label="return LanguageVersion.CSharp9; 98681"];
942 [label="this.LanguageVersion 98682"];
943 [label="this.PreprocessorSymbols = preprocessorSymbols.ToImmutableArrayOrEmpty(); 98683"];
944 [label="this.PreprocessorSymbols 98684"];
945 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 98685"];
946 [label="_features = features?.ToImmutableDictionary() ?? ImmutableDictionary<string, string>.Empty; 98686"];
947 [label="_features 98687"];
948 [label="public static CSharpParseOptions Default { get; } = new CSharpParseOptions(); 98688"];
949 [label="8 98689"];
950 [label="TriviaListInitialCapacity = 8 98690"];
951 [label="TokensLexed 98691"];
952 [label="'<<<<<<<' 98692"];
953 [label="s_conflictMarkerLength = '<<<<<<<'.Length 98693"];
954 [label="42 98694"];
955 [label="MaxCachedTokenSize = 42 98695"];
956 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98696"];
957 [label="{\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            } 98697"];
958 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98698"];
959 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98699"];
960 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98700"];
961 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98701"];
962 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98702"];
963 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98703"];
964 [label="{\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98704"];
965 [label="{\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            } 98705"];
966 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98706"];
967 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98707"];
968 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98708"];
969 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98709"];
970 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98710"];
971 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98711"];
972 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98712"];
973 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98713"];
974 [label="new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98714"];
975 [label="s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (DotDot range token, exit so that we handle it in subsequent scanning code)\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        } 98715"];
976 [label="new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 98716"];
977 [label="s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        } 98717"];
978 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 98718"];
979 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 98719"];
980 [label="return new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default); 98720"];
981 [label="new InternalSyntax.Lexer(\n                text: MakeSourceText(text, offset),\n                options: options ?? CSharpParseOptions.Default) 98721"];
982 [label="param Lexer(SourceText text) 98722"];
983 [label="param Lexer(CSharpParseOptions options) 98723"];
984 [label="param Lexer(bool allowPreprocessorDirectives = true) 98724"];
985 [label="param Lexer(bool interpolationFollowedByColon = false) 98725"];
986 [label="param Lexer(this) 98726"];
987 [label="text 98727"];
988 [label="param Lexer(this) 98728"];
989 [label="param AbstractLexer(SourceText text) 98729"];
990 [label="param AbstractLexer(this) 98730"];
991 [label="TextWindow 98731"];
992 [label="_errors 98732"];
993 [label="InvalidCharacter = char.MaxValue 98733"];
994 [label="2048 98734"];
995 [label="DefaultWindowLength = 2048 98735"];
996 [label="() => new char[DefaultWindowLength] 98736"];
997 [label="new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 98737"];
998 [label="s_windowPool = new ObjectPool<char[]>(() => new char[DefaultWindowLength]) 98738"];
999 [label="this.TextWindow = new SlidingTextWindow(text); 98739"];
1000 [label="this.TextWindow = new SlidingTextWindow(text); 98740"];
1001 [label="new SlidingTextWindow(text) 98741"];
1002 [label="param SlidingTextWindow(SourceText text) 98742"];
1003 [label="param SlidingTextWindow(this) 98743"];
1004 [label="_text 98744"];
1005 [label="_basis 98745"];
1006 [label="_offset 98746"];
1007 [label="_textEnd 98747"];
1008 [label="_characterWindow 98748"];
1009 [label="_characterWindowCount 98749"];
1010 [label="_lexemeStart 98750"];
1011 [label="_strings 98751"];
1012 [label="_text 98752"];
1013 [label="_basis = 0; 98753"];
1014 [label="_basis 98754"];
1015 [label="_offset = 0; 98755"];
1016 [label="_offset 98756"];
1017 [label="_textEnd 98757"];
1018 [label="_strings = StringTable.GetInstance(); 98758"];
1019 [label="_strings 98759"];
1020 [label="_characterWindow = s_windowPool.Allocate(); 98760"];
1021 [label="_characterWindow 98761"];
1022 [label="_lexemeStart = 0; 98762"];
1023 [label="_lexemeStart 98763"];
1024 [label="this.TextWindow 98764"];
1025 [label="_options 98765"];
1026 [label="_mode 98766"];
1027 [label="_builder 98767"];
1028 [label="_identBuffer 98768"];
1029 [label="_identLen 98769"];
1030 [label="_cache 98770"];
1031 [label="_allowPreprocessorDirectives 98771"];
1032 [label="_interpolationFollowedByColon 98772"];
1033 [label="_xmlParser 98773"];
1034 [label="_badTokenCount 98774"];
1035 [label="10 98775"];
1036 [label="new SyntaxListBuilder(10) 98776"];
1037 [label="_leadingTriviaCache = new SyntaxListBuilder(10) 98777"];
1038 [label="10 98778"];
1039 [label="new SyntaxListBuilder(10) 98779"];
1040 [label="_trailingTriviaCache = new SyntaxListBuilder(10) 98780"];
1041 [label="_createWhitespaceTriviaFunction 98781"];
1042 [label="_createQuickTokenFunction 98782"];
1043 [label="Debug.Assert(options != null); 98783"];
1044 [label="Debug.Assert(options != null); 98784"];
1045 [label="_options 98785"];
1046 [label="_builder = new StringBuilder(); 98786"];
1047 [label="_builder 98787"];
1048 [label="_identBuffer = new char[32]; 98788"];
1049 [label="_identBuffer 98789"];
1050 [label="512 98790"];
1051 [label="(key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            } 98791"];
1052 [label="CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 98792"];
1053 [label="s_keywordKindPool =\n            CachingIdentityFactory<string, SyntaxKind>.CreatePool(\n                            512,\n                            (key) =>\n                            {\n                                var kind = SyntaxFacts.GetKeywordKind(key);\n                                if (kind == SyntaxKind.None)\n                                {\n                                    kind = SyntaxFacts.GetContextualKeywordKind(key);\n                                }\n\n                                return kind;\n                            }) 98793"];
1054 [label="10 98794"];
1055 [label="MaxKeywordLength = 10 98795"];
1056 [label="_cache = new LexerCache(); 98796"];
1057 [label="new LexerCache() 98797"];
1058 [label="param LexerCache(this) 98798"];
1059 [label="_triviaMap 98799"];
1060 [label="_tokenMap 98800"];
1061 [label="_keywordKindMap 98801"];
1062 [label="_triviaMap = TextKeyedCache<SyntaxTrivia>.GetInstance(); 98802"];
1063 [label="_triviaMap 98803"];
1064 [label="_tokenMap = TextKeyedCache<SyntaxToken>.GetInstance(); 98804"];
1065 [label="_tokenMap 98805"];
1066 [label="_keywordKindMap = s_keywordKindPool.Allocate(); 98806"];
1067 [label="_keywordKindMap 98807"];
1068 [label="_cache 98808"];
1069 [label="_createQuickTokenFunction 98809"];
1070 [label="_allowPreprocessorDirectives 98810"];
1071 [label="_interpolationFollowedByColon 98811"];
1072 [label="using (var lexer = MakeLexer(text, offset, (CSharpParseOptions?)options))\n            using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 98812"];
1073 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 98813"];
1074 [label="MakeParser(lexer) 98814"];
1075 [label="param MakeParser(InternalSyntax.Lexer lexer) 98815"];
1076 [label="LastTerminatorState = (int)TerminatorState.IsEndOfRecordSignature 98816"];
1077 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 98817"];
1078 [label="return new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null); 98818"];
1079 [label="new InternalSyntax.LanguageParser(lexer, oldTree: null, changes: null) 98819"];
1080 [label="param LanguageParser(Lexer lexer) 98820"];
1081 [label="param LanguageParser(CSharp.CSharpSyntaxNode oldTree) 98821"];
1082 [label="param LanguageParser(IEnumerable<TextChangeRange> changes) 98822"];
1083 [label="param LanguageParser(LexerMode lexerMode = LexerMode.Syntax) 98823"];
1084 [label="param LanguageParser(CancellationToken cancellationToken = default(CancellationToken)) 98824"];
1085 [label="param LanguageParser(this) 98825"];
1086 [label="() => new BlendedNode[32] 98826"];
1087 [label="2 98827"];
1088 [label="new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 98828"];
1089 [label="s_blendedNodesPool = new ObjectPool<BlendedNode[]>(() => new BlendedNode[32], 2) 98829"];
1090 [label="lexer 98830"];
1091 [label="lexerMode 98831"];
1092 [label="oldTree 98832"];
1093 [label="changes 98833"];
1094 [label="false 98834"];
1095 [label="true 98835"];
1096 [label="cancellationToken 98836"];
1097 [label="param LanguageParser(this) 98837"];
1098 [label="param SyntaxParser(Lexer lexer) 98838"];
1099 [label="param SyntaxParser(LexerMode mode) 98839"];
1100 [label="param SyntaxParser(CSharp.CSharpSyntaxNode oldTree) 98840"];
1101 [label="param SyntaxParser(IEnumerable<TextChangeRange> changes) 98841"];
1102 [label="param SyntaxParser(bool allowModeReset) 98842"];
1103 [label="param SyntaxParser(bool preLexIfNotIncremental = false) 98843"];
1104 [label="param SyntaxParser(CancellationToken cancellationToken = default(CancellationToken)) 98844"];
1105 [label="param SyntaxParser(this) 98845"];
1106 [label="lexer 98846"];
1107 [label="_isIncremental 98847"];
1108 [label="_allowModeReset 98848"];
1109 [label="_mode 98849"];
1110 [label="_currentToken 98850"];
1111 [label="_lexedTokens 98851"];
1112 [label="_prevTokenTrailingTrivia 98852"];
1113 [label="_firstToken 98853"];
1114 [label="_tokenOffset 98854"];
1115 [label="_tokenCount 98855"];
1116 [label="_resetCount 98856"];
1117 [label="_resetStart 98857"];
1118 [label="_blendedTokens 98858"];
1119 [label="this.lexer 98859"];
1120 [label="_mode 98860"];
1121 [label="_allowModeReset 98861"];
1122 [label="this.cancellationToken 98862"];
1123 [label="_currentNode = default(BlendedNode); 98863"];
1124 [label="_currentNode 98864"];
1125 [label="_isIncremental = oldTree != null; 98865"];
1126 [label="_isIncremental = oldTree != null; 98866"];
1127 [label="_isIncremental 98867"];
1128 [label="this.IsIncremental 98868"];
1129 [label="get\n            {\n                return _isIncremental;\n            } 98869"];
1130 [label="return _isIncremental; 98870"];
1131 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 98871"];
1132 [label="if (this.IsIncremental || allowModeReset)\n            {\n                _firstBlender = new Blender(lexer, oldTree, changes);\n                _blendedTokens = s_blendedNodesPool.Allocate();\n            }\n            else\n            {\n                _firstBlender = default(Blender);\n                _lexedTokens = new ArrayElement<SyntaxToken>[32];\n            } 98872"];
1133 [label="_firstBlender = default(Blender); 98873"];
1134 [label="_firstBlender 98874"];
1135 [label="_lexedTokens = new ArrayElement<SyntaxToken>[32]; 98875"];
1136 [label="_lexedTokens 98876"];
1137 [label="this.IsIncremental 98877"];
1138 [label="get\n            {\n                return _isIncremental;\n            } 98878"];
1139 [label="return _isIncremental; 98879"];
1140 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 98880"];
1141 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 98881"];
1142 [label="if (preLexIfNotIncremental && !this.IsIncremental && !cancellationToken.CanBeCanceled)\n            {\n                this.PreLex();\n            } 98882"];
1143 [label="this.PreLex() 98883"];
1144 [label="param PreLex(this) 98884"];
1145 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 98885"];
1146 [label="this.lexer.TextWindow.Text 98886"];
1147 [label="=> _text 98887"];
1148 [label="_text 98888"];
1149 [label="var size = Math.Min(4096, Math.Max(32, this.lexer.TextWindow.Text.Length / 2)); 98889"];
1150 [label="_lexedTokens = new ArrayElement<SyntaxToken>[size]; 98890"];
1151 [label="_lexedTokens 98891"];
1152 [label="var lexer = this.lexer; 98892"];
1153 [label="var mode = _mode; 98893"];
1154 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 98894"];
1155 [label="for (int i = 0; i < size; i++)\n            {\n                var token = lexer.Lex(mode);\n                this.AddLexedToken(token);\n                if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                }\n            } 98895"];
1156 [label="var token = lexer.Lex(mode); 98896"];
1157 [label="lexer.Lex(mode) 98897"];
1158 [label="param Lex(LexerMode mode) 98898"];
1159 [label="param Lex(this) 98899"];
1160 [label="TokensLexed++; 98900"];
1161 [label="_mode 98901"];
1162 [label="switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            } 98902"];
1163 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 98903"];
1164 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 98904"];
1165 [label="param Start(this) 98905"];
1166 [label="TextWindow.Start() 98906"];
1167 [label="param Start(this) 98907"];
1168 [label="_lexemeStart 98908"];
1169 [label="TextWindow.Start(); 98909"];
1170 [label="_errors = null; 98910"];
1171 [label="_errors 98911"];
1172 [label="get\n            {\n                return _offset;\n            } 98912"];
1173 [label="return _offset; 98913"];
1174 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 98914"];
1175 [label="get\n            {\n                return _characterWindowCount;\n            } 98915"];
1176 [label="return _characterWindowCount; 98916"];
1177 [label="get\n            {\n                return _characterWindow;\n            } 98917"];
1178 [label="return _characterWindow; 98918"];
1179 [label="param AdvanceChar(int n) 98919"];
1180 [label="param AdvanceChar(this) 98920"];
1181 [label="_offset += n; 98921"];
1182 [label="_offset 98922"];
1183 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 98923"];
1184 [label="return _basis + _lexemeStart; 98924"];
1185 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 98925"];
1186 [label="param Reset(int position) 98926"];
1187 [label="param Reset(this) 98927"];
1188 [label="int relative = position - _basis; 98928"];
1189 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 98929"];
1190 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 98930"];
1191 [label="if (relative >= 0 && relative <= _characterWindowCount)\n            {\n                _offset = relative;\n            }\n            else\n            {\n                // we need to reread text buffer\n                int amountToRead = Math.Min(_text.Length, position + _characterWindow.Length) - position;\n                amountToRead = Math.Max(amountToRead, 0);\n                if (amountToRead > 0)\n                {\n                    _text.CopyTo(position, _characterWindow, 0, amountToRead);\n                }\n\n                _lexemeStart = 0;\n                _offset = 0;\n                _basis = position;\n                _characterWindowCount = amountToRead;\n            } 98931"];
1192 [label="_offset 98932"];
1193 [label="this.LexSyntaxToken() 98933"];
1194 [label="param LexSyntaxToken(this) 98934"];
1195 [label="_leadingTriviaCache.Clear(); 98935"];
1196 [label="TextWindow.Position 98936"];
1197 [label="get\n            {\n                return _basis + _offset;\n            } 98937"];
1198 [label="return _basis + _offset; 98938"];
1199 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 98939"];
1200 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 98940"];
1201 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache); 98941"];
1202 [label="this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache) 98942"];
1203 [label="param LexSyntaxTrivia(bool afterFirstToken) 98943"];
1204 [label="param LexSyntaxTrivia(bool isTrailing) 98944"];
1205 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 98945"];
1206 [label="param LexSyntaxTrivia(this) 98946"];
1207 [label="bool onlyWhitespaceOnLine = !isTrailing; 98947"];
1208 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 98948"];
1209 [label="this.Start() 98949"];
1210 [label="param Start(this) 98950"];
1211 [label="TextWindow.Start() 98951"];
1212 [label="param Start(this) 98952"];
1213 [label="TextWindow.Start(); 98953"];
1214 [label="_errors = null; 98954"];
1215 [label="_errors 98955"];
1216 [label="this.Start(); 98956"];
1217 [label="TextWindow.PeekChar() 98957"];
1218 [label="param PeekChar(this) 98958"];
1219 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 98959"];
1220 [label="MoreChars() 98960"];
1221 [label="param MoreChars(this) 98961"];
1222 [label="if (_offset >= _characterWindowCount)\n            {\n                if (this.Position >= _textEnd)\n                {\n                    return false;\n                }\n\n                // if lexeme scanning is sufficiently into the char buffer, \n                // then refocus the window onto the lexeme\n                if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                }\n\n                if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                }\n\n                int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount);\n                _text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead);\n                _characterWindowCount += amountToRead;\n                return amountToRead > 0;\n            } 98962"];
1223 [label="this.Position 98963"];
1224 [label="get\n            {\n                return _basis + _offset;\n            } 98964"];
1225 [label="return _basis + _offset; 98965"];
1226 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 98966"];
1227 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 98967"];
1228 [label="if (_lexemeStart > (_characterWindowCount / 4))\n                {\n                    Array.Copy(_characterWindow,\n                        _lexemeStart,\n                        _characterWindow,\n                        0,\n                        _characterWindowCount - _lexemeStart);\n                    _characterWindowCount -= _lexemeStart;\n                    _offset -= _lexemeStart;\n                    _basis += _lexemeStart;\n                    _lexemeStart = 0;\n                } 98968"];
1229 [label="if (_characterWindowCount >= _characterWindow.Length)\n                {\n                    // grow char array, since we need more contiguous space\n                    char[] oldWindow = _characterWindow;\n                    char[] newWindow = new char[_characterWindow.Length * 2];\n                    Array.Copy(oldWindow, 0, newWindow, 0, _characterWindowCount);\n                    s_windowPool.ForgetTrackedObject(oldWindow, newWindow);\n                    _characterWindow = newWindow;\n                } 98969"];
1230 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 98970"];
1231 [label="int amountToRead = Math.Min(_textEnd - (_basis + _characterWindowCount),\n                    _characterWindow.Length - _characterWindowCount); 98971"];
1232 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 98972"];
1233 [label="_text.CopyTo(_basis + _characterWindowCount,\n                    _characterWindow,\n                    _characterWindowCount,\n                    amountToRead); 98973"];
1234 [label="_characterWindowCount += amountToRead; 98974"];
1235 [label="_characterWindowCount 98975"];
1236 [label="return amountToRead > 0; 98976"];
1237 [label="return amountToRead > 0; 98977"];
1238 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 98978"];
1239 [label="return _characterWindow[_offset]; 98979"];
1240 [label="char ch = TextWindow.PeekChar(); 98980"];
1241 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 98981"];
1242 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 98982"];
1243 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 98983"];
1244 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 98984"];
1245 [label="return; 98985"];
1246 [label="var leading = _leadingTriviaCache; 98986"];
1247 [label="var tokenInfo = default(TokenInfo); 98987"];
1248 [label="this.Start() 98988"];
1249 [label="param Start(this) 98989"];
1250 [label="TextWindow.Start() 98990"];
1251 [label="param Start(this) 98991"];
1252 [label="TextWindow.Start(); 98992"];
1253 [label="_errors = null; 98993"];
1254 [label="_errors 98994"];
1255 [label="this.Start(); 98995"];
1256 [label="this.ScanSyntaxToken(ref tokenInfo); 98996"];
1257 [label="this.ScanSyntaxToken(ref tokenInfo); 98997"];
1258 [label="this.ScanSyntaxToken(ref tokenInfo); 98998"];
1259 [label="get\n            {\n                return _basis + _offset;\n            } 98999"];
1260 [label="return _basis + _offset; 99000"];
1261 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 99001"];
1262 [label="return _characterWindow[_offset]; 99002"];
1263 [label="param ScanIdentifierOrKeyword(ref TokenInfo info) 99003"];
1264 [label="param ScanIdentifierOrKeyword(this) 99004"];
1265 [label="info.ContextualKind 99005"];
1266 [label="if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            } 99006"];
1267 [label="this.ScanIdentifier(ref info) 99007"];
1268 [label="param ScanIdentifier(ref TokenInfo info) 99008"];
1269 [label="param ScanIdentifier(this) 99009"];
1270 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 99010"];
1271 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 99011"];
1272 [label="return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info)); 99012"];
1273 [label="param Intern(char[] array) 99013"];
1274 [label="param Intern(int start) 99014"];
1275 [label="param Intern(int length) 99015"];
1276 [label="param Intern(this) 99016"];
1277 [label="return _strings.Add(array, start, length); 99017"];
1278 [label="return _strings.Add(array, start, length); 99018"];
1279 [label="return _strings.Add(array, start, length); 99019"];
1280 [label="return _strings.Add(array, start, length); 99020"];
1281 [label="if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                } 99021"];
1282 [label="if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    } 99022"];
1283 [label="this.ModeIs(LexerMode.Directive) 99023"];
1284 [label="param ModeIs(LexerMode mode) 99024"];
1285 [label="param ModeIs(this) 99025"];
1286 [label="return ModeOf(_mode) == mode; 99026"];
1287 [label="ModeOf(_mode) 99027"];
1288 [label="param ModeOf(LexerMode mode) 99028"];
1289 [label="return mode & LexerMode.MaskLexMode; 99029"];
1290 [label="return ModeOf(_mode) == mode; 99030"];
1291 [label="if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 99031"];
1292 [label="_cache.TryGetKeywordKind(info.Text, out info.Kind) 99032"];
1293 [label="param TryGetKeywordKind(string key) 99033"];
1294 [label="param TryGetKeywordKind(out SyntaxKind kind) 99034"];
1295 [label="param TryGetKeywordKind(this) 99035"];
1296 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 99036"];
1297 [label="new SyntaxKindEqualityComparer() 99037"];
1298 [label="param SyntaxKindEqualityComparer(this) 99038"];
1299 [label="public static IEqualityComparer<SyntaxKind> EqualityComparer { get; } = new SyntaxKindEqualityComparer(); 99039"];
1300 [label="kind = _keywordKindMap.GetOrMakeValue(key); 99040"];
1301 [label="kind = _keywordKindMap.GetOrMakeValue(key); 99041"];
1302 [label="kind = _keywordKindMap.GetOrMakeValue(key); 99042"];
1303 [label="param GetKeywordKind(string text) 99043"];
1304 [label="switch (text)\n            {\n                case 'bool':\n                    return SyntaxKind.BoolKeyword;\n                case 'byte':\n                    return SyntaxKind.ByteKeyword;\n                case 'sbyte':\n                    return SyntaxKind.SByteKeyword;\n                case 'short':\n                    return SyntaxKind.ShortKeyword;\n                case 'ushort':\n                    return SyntaxKind.UShortKeyword;\n                case 'int':\n                    return SyntaxKind.IntKeyword;\n                case 'uint':\n                    return SyntaxKind.UIntKeyword;\n                case 'long':\n                    return SyntaxKind.LongKeyword;\n                case 'ulong':\n                    return SyntaxKind.ULongKeyword;\n                case 'double':\n                    return SyntaxKind.DoubleKeyword;\n                case 'float':\n                    return SyntaxKind.FloatKeyword;\n                case 'decimal':\n                    return SyntaxKind.DecimalKeyword;\n                case 'string':\n                    return SyntaxKind.StringKeyword;\n                case 'char':\n                    return SyntaxKind.CharKeyword;\n                case 'void':\n                    return SyntaxKind.VoidKeyword;\n                case 'object':\n                    return SyntaxKind.ObjectKeyword;\n                case 'typeof':\n                    return SyntaxKind.TypeOfKeyword;\n                case 'sizeof':\n                    return SyntaxKind.SizeOfKeyword;\n                case 'null':\n                    return SyntaxKind.NullKeyword;\n                case 'true':\n                    return SyntaxKind.TrueKeyword;\n                case 'false':\n                    return SyntaxKind.FalseKeyword;\n                case 'if':\n                    return SyntaxKind.IfKeyword;\n                case 'else':\n                    return SyntaxKind.ElseKeyword;\n                case 'while':\n                    return SyntaxKind.WhileKeyword;\n                case 'for':\n                    return SyntaxKind.ForKeyword;\n                case 'foreach':\n                    return SyntaxKind.ForEachKeyword;\n                case 'do':\n                    return SyntaxKind.DoKeyword;\n                case 'switch':\n                    return SyntaxKind.SwitchKeyword;\n                case 'case':\n                    return SyntaxKind.CaseKeyword;\n                case 'default':\n                    return SyntaxKind.DefaultKeyword;\n                case 'lock':\n                    return SyntaxKind.LockKeyword;\n                case 'try':\n                    return SyntaxKind.TryKeyword;\n                case 'throw':\n                    return SyntaxKind.ThrowKeyword;\n                case 'catch':\n                    return SyntaxKind.CatchKeyword;\n                case 'finally':\n                    return SyntaxKind.FinallyKeyword;\n                case 'goto':\n                    return SyntaxKind.GotoKeyword;\n                case 'break':\n                    return SyntaxKind.BreakKeyword;\n                case 'continue':\n                    return SyntaxKind.ContinueKeyword;\n                case 'return':\n                    return SyntaxKind.ReturnKeyword;\n                case 'public':\n                    return SyntaxKind.PublicKeyword;\n                case 'private':\n                    return SyntaxKind.PrivateKeyword;\n                case 'internal':\n                    return SyntaxKind.InternalKeyword;\n                case 'protected':\n                    return SyntaxKind.ProtectedKeyword;\n                case 'static':\n                    return SyntaxKind.StaticKeyword;\n                case 'readonly':\n                    return SyntaxKind.ReadOnlyKeyword;\n                case 'sealed':\n                    return SyntaxKind.SealedKeyword;\n                case 'const':\n                    return SyntaxKind.ConstKeyword;\n                case 'fixed':\n                    return SyntaxKind.FixedKeyword;\n                case 'stackalloc':\n                    return SyntaxKind.StackAllocKeyword;\n                case 'volatile':\n                    return SyntaxKind.VolatileKeyword;\n                case 'new':\n                    return SyntaxKind.NewKeyword;\n                case 'override':\n                    return SyntaxKind.OverrideKeyword;\n                case 'abstract':\n                    return SyntaxKind.AbstractKeyword;\n                case 'virtual':\n                    return SyntaxKind.VirtualKeyword;\n                case 'event':\n                    return SyntaxKind.EventKeyword;\n                case 'extern':\n                    return SyntaxKind.ExternKeyword;\n                case 'ref':\n                    return SyntaxKind.RefKeyword;\n                case 'out':\n                    return SyntaxKind.OutKeyword;\n                case 'in':\n                    return SyntaxKind.InKeyword;\n                case 'is':\n                    return SyntaxKind.IsKeyword;\n                case 'as':\n                    return SyntaxKind.AsKeyword;\n                case 'params':\n                    return SyntaxKind.ParamsKeyword;\n                case '__arglist':\n                    return SyntaxKind.ArgListKeyword;\n                case '__makeref':\n                    return SyntaxKind.MakeRefKeyword;\n                case '__reftype':\n                    return SyntaxKind.RefTypeKeyword;\n                case '__refvalue':\n                    return SyntaxKind.RefValueKeyword;\n                case 'this':\n                    return SyntaxKind.ThisKeyword;\n                case 'base':\n                    return SyntaxKind.BaseKeyword;\n                case 'namespace':\n                    return SyntaxKind.NamespaceKeyword;\n                case 'using':\n                    return SyntaxKind.UsingKeyword;\n                case 'class':\n                    return SyntaxKind.ClassKeyword;\n                case 'struct':\n                    return SyntaxKind.StructKeyword;\n                case 'interface':\n                    return SyntaxKind.InterfaceKeyword;\n                case 'enum':\n                    return SyntaxKind.EnumKeyword;\n                case 'delegate':\n                    return SyntaxKind.DelegateKeyword;\n                case 'checked':\n                    return SyntaxKind.CheckedKeyword;\n                case 'unchecked':\n                    return SyntaxKind.UncheckedKeyword;\n                case 'unsafe':\n                    return SyntaxKind.UnsafeKeyword;\n                case 'operator':\n                    return SyntaxKind.OperatorKeyword;\n                case 'implicit':\n                    return SyntaxKind.ImplicitKeyword;\n                case 'explicit':\n                    return SyntaxKind.ExplicitKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 99044"];
1305 [label="return SyntaxKind.ForKeyword; 99045"];
1306 [label="return kind != SyntaxKind.None; 99046"];
1307 [label="if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        } 99047"];
1308 [label="SyntaxFacts.IsContextualKeyword(info.Kind) 99048"];
1309 [label="param IsContextualKeyword(SyntaxKind kind) 99049"];
1310 [label="switch (kind)\n            {\n                case SyntaxKind.YieldKeyword:\n                case SyntaxKind.PartialKeyword:\n                case SyntaxKind.FromKeyword:\n                case SyntaxKind.GroupKeyword:\n                case SyntaxKind.JoinKeyword:\n                case SyntaxKind.IntoKeyword:\n                case SyntaxKind.LetKeyword:\n                case SyntaxKind.ByKeyword:\n                case SyntaxKind.WhereKeyword:\n                case SyntaxKind.SelectKeyword:\n                case SyntaxKind.GetKeyword:\n                case SyntaxKind.SetKeyword:\n                case SyntaxKind.AddKeyword:\n                case SyntaxKind.RemoveKeyword:\n                case SyntaxKind.OrderByKeyword:\n                case SyntaxKind.AliasKeyword:\n                case SyntaxKind.OnKeyword:\n                case SyntaxKind.EqualsKeyword:\n                case SyntaxKind.AscendingKeyword:\n                case SyntaxKind.DescendingKeyword:\n                case SyntaxKind.AssemblyKeyword:\n                case SyntaxKind.ModuleKeyword:\n                case SyntaxKind.TypeKeyword:\n                case SyntaxKind.GlobalKeyword:\n                case SyntaxKind.FieldKeyword:\n                case SyntaxKind.MethodKeyword:\n                case SyntaxKind.ParamKeyword:\n                case SyntaxKind.PropertyKeyword:\n                case SyntaxKind.TypeVarKeyword:\n                case SyntaxKind.NameOfKeyword:\n                case SyntaxKind.AsyncKeyword:\n                case SyntaxKind.AwaitKeyword:\n                case SyntaxKind.WhenKeyword:\n                case SyntaxKind.UnderscoreToken:\n                case SyntaxKind.VarKeyword:\n                case SyntaxKind.OrKeyword:\n                case SyntaxKind.AndKeyword:\n                case SyntaxKind.NotKeyword:\n                case SyntaxKind.DataKeyword:\n                case SyntaxKind.WithKeyword:\n                case SyntaxKind.InitKeyword:\n                case SyntaxKind.RecordKeyword:\n                case SyntaxKind.ManagedKeyword:\n                case SyntaxKind.UnmanagedKeyword:\n                    return true;\n                default:\n                    return false;\n            } 99050"];
1311 [label="return false; 99051"];
1312 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 99052"];
1313 [label="return true; 99053"];
1314 [label="this.ScanSyntaxToken(ref tokenInfo); 99054"];
1315 [label="var errors = this.GetErrors(GetFullWidth(leading)); 99055"];
1316 [label="GetFullWidth(leading) 99056"];
1317 [label="param GetFullWidth(SyntaxListBuilder builder) 99057"];
1318 [label="int width = 0; 99058"];
1319 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 99059"];
1320 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 99060"];
1321 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 99061"];
1322 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 99062"];
1323 [label="return width; 99063"];
1324 [label="var errors = this.GetErrors(GetFullWidth(leading)); 99064"];
1325 [label="this.GetErrors(GetFullWidth(leading)) 99065"];
1326 [label="param GetErrors(int leadingTriviaWidth) 99066"];
1327 [label="param GetErrors(this) 99067"];
1328 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 99068"];
1329 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 99069"];
1330 [label="return null; 99070"];
1331 [label="var errors = this.GetErrors(GetFullWidth(leading)); 99071"];
1332 [label="_trailingTriviaCache.Clear(); 99072"];
1333 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 99073"];
1334 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache); 99074"];
1335 [label="this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache) 99075"];
1336 [label="param LexSyntaxTrivia(bool afterFirstToken) 99076"];
1337 [label="param LexSyntaxTrivia(bool isTrailing) 99077"];
1338 [label="param LexSyntaxTrivia(ref SyntaxListBuilder triviaList) 99078"];
1339 [label="param LexSyntaxTrivia(this) 99079"];
1340 [label="bool onlyWhitespaceOnLine = !isTrailing; 99080"];
1341 [label="while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                }\n            } 99081"];
1342 [label="this.Start() 99082"];
1343 [label="param Start(this) 99083"];
1344 [label="TextWindow.Start() 99084"];
1345 [label="param Start(this) 99085"];
1346 [label="TextWindow.Start(); 99086"];
1347 [label="_errors = null; 99087"];
1348 [label="_errors 99088"];
1349 [label="this.Start(); 99089"];
1350 [label="TextWindow.PeekChar() 99090"];
1351 [label="param PeekChar(this) 99091"];
1352 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 99092"];
1353 [label="char ch = TextWindow.PeekChar(); 99093"];
1354 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 99094"];
1355 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 99095"];
1356 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 99096"];
1357 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 99097"];
1358 [label="return; 99098"];
1359 [label="var trailing = _trailingTriviaCache; 99099"];
1360 [label="return Create(ref tokenInfo, leading, trailing, errors); 99100"];
1361 [label="return Create(ref tokenInfo, leading, trailing, errors); 99101"];
1362 [label="return Create(ref tokenInfo, leading, trailing, errors); 99102"];
1363 [label="return Create(ref tokenInfo, leading, trailing, errors); 99103"];
1364 [label="Create(ref tokenInfo, leading, trailing, errors) 99104"];
1365 [label="param Create(ref TokenInfo info) 99105"];
1366 [label="param Create(SyntaxListBuilder leading) 99106"];
1367 [label="param Create(SyntaxListBuilder trailing) 99107"];
1368 [label="param Create(SyntaxDiagnosticInfo[] errors) 99108"];
1369 [label="param Create(this) 99109"];
1370 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 99110"];
1371 [label="var leadingNode = leading?.ToListNode(); 99111"];
1372 [label="var trailingNode = trailing?.ToListNode(); 99112"];
1373 [label="SyntaxToken token; 99113"];
1374 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 99114"];
1375 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 99115"];
1376 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 99116"];
1377 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 99117"];
1378 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 99118"];
1379 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 99119"];
1380 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 99120"];
1381 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 99121"];
1382 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 99122"];
1383 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 99123"];
1384 [label="param Token(GreenNode leading) 99124"];
1385 [label="param Token(SyntaxKind kind) 99125"];
1386 [label="param Token(GreenNode trailing) 99126"];
1387 [label="FirstTokenWithWellKnownText = SyntaxKind.TildeToken 99127"];
1388 [label="LastTokenWithWellKnownText = SyntaxKind.EndOfFileToken 99128"];
1389 [label="1 99129"];
1390 [label="(int)LastTokenWithWellKnownText + 1 99130"];
1391 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99131"];
1392 [label="s_tokensWithNoTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99132"];
1393 [label="1 99133"];
1394 [label="(int)LastTokenWithWellKnownText + 1 99134"];
1395 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99135"];
1396 [label="s_tokensWithElasticTrivia = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99136"];
1397 [label="1 99137"];
1398 [label="(int)LastTokenWithWellKnownText + 1 99138"];
1399 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99139"];
1400 [label="s_tokensWithSingleTrailingSpace = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99140"];
1401 [label="1 99141"];
1402 [label="(int)LastTokenWithWellKnownText + 1 99142"];
1403 [label="new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99143"];
1404 [label="s_tokensWithSingleTrailingCRLF = new ArrayElement<SyntaxToken>[(int)LastTokenWithWellKnownText + 1] 99144"];
1405 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxToken), r => new SyntaxToken(r)); 99145"];
1406 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 99146"];
1407 [label="for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)\n            {\n                s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind);\n                s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace);\n                s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space);\n                s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed);\n            } 99147"];
1408 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 99148"];
1409 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 99149"];
1410 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 99150"];
1411 [label="new SyntaxToken(kind) 99151"];
1412 [label="param SyntaxToken(SyntaxKind kind) 99152"];
1413 [label="param SyntaxToken(this) 99153"];
1414 [label="kind 99154"];
1415 [label="param SyntaxToken(this) 99155"];
1416 [label="param CSharpSyntaxNode(SyntaxKind kind) 99156"];
1417 [label="param CSharpSyntaxNode(this) 99157"];
1418 [label="kind 99158"];
1419 [label="param CSharpSyntaxNode(this) 99159"];
1420 [label="param CSharpSyntaxNode(this) 99160"];
1421 [label="GreenStats.NoteGreen(this); 99161"];
1422 [label="GreenStats.NoteGreen(this); 99162"];
1423 [label="this.Text 99163"];
1424 [label="get { return SyntaxFacts.GetText(this.Kind); } 99164"];
1425 [label="this.Kind 99165"];
1426 [label="get { return (SyntaxKind)this.RawKind; } 99166"];
1427 [label="return (SyntaxKind)this.RawKind; 99167"];
1428 [label="return SyntaxFacts.GetText(this.Kind); 99168"];
1429 [label="SyntaxFacts.GetText(this.Kind) 99169"];
1430 [label="param GetText(SyntaxKind kind) 99170"];
1431 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99171"];
1432 [label="return '~'; 99172"];
1433 [label="FullWidth = this.Text.Length; 99173"];
1434 [label="FullWidth 99174"];
1435 [label="this.flags |= NodeFlags.IsNotMissing; 99175"];
1436 [label="this.flags 99176"];
1437 [label="s_tokensWithNoTrivia[(int)kind].Value 99177"];
1438 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r)); 99178"];
1439 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 99179"];
1440 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 99180"];
1441 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 99181"];
1442 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 99182"];
1443 [label="new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace) 99183"];
1444 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99184"];
1445 [label="param SyntaxTokenWithTrivia(GreenNode leading) 99185"];
1446 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 99186"];
1447 [label="param SyntaxTokenWithTrivia(this) 99187"];
1448 [label="kind 99188"];
1449 [label="param SyntaxTokenWithTrivia(this) 99189"];
1450 [label="param SyntaxToken(SyntaxKind kind) 99190"];
1451 [label="param SyntaxToken(this) 99191"];
1452 [label="kind 99192"];
1453 [label="param SyntaxToken(this) 99193"];
1454 [label="param CSharpSyntaxNode(SyntaxKind kind) 99194"];
1455 [label="param CSharpSyntaxNode(this) 99195"];
1456 [label="kind 99196"];
1457 [label="param CSharpSyntaxNode(this) 99197"];
1458 [label="param CSharpSyntaxNode(this) 99198"];
1459 [label="GreenStats.NoteGreen(this); 99199"];
1460 [label="GreenStats.NoteGreen(this); 99200"];
1461 [label="this.Text 99201"];
1462 [label="get { return SyntaxFacts.GetText(this.Kind); } 99202"];
1463 [label="this.Kind 99203"];
1464 [label="get { return (SyntaxKind)this.RawKind; } 99204"];
1465 [label="return (SyntaxKind)this.RawKind; 99205"];
1466 [label="return SyntaxFacts.GetText(this.Kind); 99206"];
1467 [label="SyntaxFacts.GetText(this.Kind) 99207"];
1468 [label="param GetText(SyntaxKind kind) 99208"];
1469 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99209"];
1470 [label="return '~'; 99210"];
1471 [label="FullWidth = this.Text.Length; 99211"];
1472 [label="FullWidth 99212"];
1473 [label="this.flags |= NodeFlags.IsNotMissing; 99213"];
1474 [label="this.flags 99214"];
1475 [label="LeadingField 99215"];
1476 [label="TrailingField 99216"];
1477 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99217"];
1478 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99218"];
1479 [label="this.AdjustFlagsAndWidth(leading); 99219"];
1480 [label="this.AdjustFlagsAndWidth(leading); 99220"];
1481 [label="this.LeadingField 99221"];
1482 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99222"];
1483 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99223"];
1484 [label="this.AdjustFlagsAndWidth(trailing); 99224"];
1485 [label="this.AdjustFlagsAndWidth(trailing); 99225"];
1486 [label="this.TrailingField 99226"];
1487 [label="s_tokensWithElasticTrivia[(int)kind].Value 99227"];
1488 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 99228"];
1489 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 99229"];
1490 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 99230"];
1491 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 99231"];
1492 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space) 99232"];
1493 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99233"];
1494 [label="param SyntaxTokenWithTrivia(GreenNode leading) 99234"];
1495 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 99235"];
1496 [label="param SyntaxTokenWithTrivia(this) 99236"];
1497 [label="kind 99237"];
1498 [label="param SyntaxTokenWithTrivia(this) 99238"];
1499 [label="param SyntaxToken(SyntaxKind kind) 99239"];
1500 [label="param SyntaxToken(this) 99240"];
1501 [label="kind 99241"];
1502 [label="param SyntaxToken(this) 99242"];
1503 [label="param CSharpSyntaxNode(SyntaxKind kind) 99243"];
1504 [label="param CSharpSyntaxNode(this) 99244"];
1505 [label="kind 99245"];
1506 [label="param CSharpSyntaxNode(this) 99246"];
1507 [label="param CSharpSyntaxNode(this) 99247"];
1508 [label="GreenStats.NoteGreen(this); 99248"];
1509 [label="GreenStats.NoteGreen(this); 99249"];
1510 [label="this.Text 99250"];
1511 [label="get { return SyntaxFacts.GetText(this.Kind); } 99251"];
1512 [label="this.Kind 99252"];
1513 [label="get { return (SyntaxKind)this.RawKind; } 99253"];
1514 [label="return (SyntaxKind)this.RawKind; 99254"];
1515 [label="return SyntaxFacts.GetText(this.Kind); 99255"];
1516 [label="SyntaxFacts.GetText(this.Kind) 99256"];
1517 [label="param GetText(SyntaxKind kind) 99257"];
1518 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99258"];
1519 [label="return '~'; 99259"];
1520 [label="FullWidth = this.Text.Length; 99260"];
1521 [label="FullWidth 99261"];
1522 [label="this.flags |= NodeFlags.IsNotMissing; 99262"];
1523 [label="this.flags 99263"];
1524 [label="LeadingField 99264"];
1525 [label="TrailingField 99265"];
1526 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99266"];
1527 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99267"];
1528 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99268"];
1529 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99269"];
1530 [label="this.AdjustFlagsAndWidth(trailing); 99270"];
1531 [label="this.AdjustFlagsAndWidth(trailing); 99271"];
1532 [label="this.TrailingField 99272"];
1533 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 99273"];
1534 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 99274"];
1535 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 99275"];
1536 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 99276"];
1537 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 99277"];
1538 [label="new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed) 99278"];
1539 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99279"];
1540 [label="param SyntaxTokenWithTrivia(GreenNode leading) 99280"];
1541 [label="param SyntaxTokenWithTrivia(GreenNode trailing) 99281"];
1542 [label="param SyntaxTokenWithTrivia(this) 99282"];
1543 [label="kind 99283"];
1544 [label="param SyntaxTokenWithTrivia(this) 99284"];
1545 [label="param SyntaxToken(SyntaxKind kind) 99285"];
1546 [label="param SyntaxToken(this) 99286"];
1547 [label="kind 99287"];
1548 [label="param SyntaxToken(this) 99288"];
1549 [label="param CSharpSyntaxNode(SyntaxKind kind) 99289"];
1550 [label="param CSharpSyntaxNode(this) 99290"];
1551 [label="kind 99291"];
1552 [label="param CSharpSyntaxNode(this) 99292"];
1553 [label="param CSharpSyntaxNode(this) 99293"];
1554 [label="GreenStats.NoteGreen(this); 99294"];
1555 [label="GreenStats.NoteGreen(this); 99295"];
1556 [label="this.Text 99296"];
1557 [label="get { return SyntaxFacts.GetText(this.Kind); } 99297"];
1558 [label="this.Kind 99298"];
1559 [label="get { return (SyntaxKind)this.RawKind; } 99299"];
1560 [label="return (SyntaxKind)this.RawKind; 99300"];
1561 [label="return SyntaxFacts.GetText(this.Kind); 99301"];
1562 [label="SyntaxFacts.GetText(this.Kind) 99302"];
1563 [label="param GetText(SyntaxKind kind) 99303"];
1564 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99304"];
1565 [label="return '~'; 99305"];
1566 [label="FullWidth = this.Text.Length; 99306"];
1567 [label="FullWidth 99307"];
1568 [label="this.flags |= NodeFlags.IsNotMissing; 99308"];
1569 [label="this.flags 99309"];
1570 [label="LeadingField 99310"];
1571 [label="TrailingField 99311"];
1572 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99312"];
1573 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    this.LeadingField = leading;\n                } 99313"];
1574 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99314"];
1575 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    this.TrailingField = trailing;\n                } 99315"];
1576 [label="this.AdjustFlagsAndWidth(trailing); 99316"];
1577 [label="this.AdjustFlagsAndWidth(trailing); 99317"];
1578 [label="this.TrailingField 99318"];
1579 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 99319"];
1580 [label="s_tokensWithNoTrivia[(int)kind].Value = new SyntaxToken(kind); 99320"];
1581 [label="param SyntaxToken(SyntaxKind kind) 99321"];
1582 [label="kind 99322"];
1583 [label="param CSharpSyntaxNode(SyntaxKind kind) 99323"];
1584 [label="kind 99324"];
1585 [label="param CSharpSyntaxNode(this) 99325"];
1586 [label="GreenStats.NoteGreen(this); 99326"];
1587 [label="return (SyntaxKind)this.RawKind; 99327"];
1588 [label="return SyntaxFacts.GetText(this.Kind); 99328"];
1589 [label="param GetText(SyntaxKind kind) 99329"];
1590 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99330"];
1591 [label="return '!'; 99331"];
1592 [label="FullWidth = this.Text.Length; 99332"];
1593 [label="FullWidth 99333"];
1594 [label="this.flags |= NodeFlags.IsNotMissing; 99334"];
1595 [label="this.flags 99335"];
1596 [label="s_tokensWithNoTrivia[(int)kind].Value 99336"];
1597 [label="s_tokensWithElasticTrivia[(int)kind].Value = new SyntaxTokenWithTrivia(kind, SyntaxFactory.ElasticZeroSpace, SyntaxFactory.ElasticZeroSpace); 99337"];
1598 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99338"];
1599 [label="kind 99339"];
1600 [label="param SyntaxToken(SyntaxKind kind) 99340"];
1601 [label="kind 99341"];
1602 [label="param CSharpSyntaxNode(SyntaxKind kind) 99342"];
1603 [label="kind 99343"];
1604 [label="param CSharpSyntaxNode(this) 99344"];
1605 [label="GreenStats.NoteGreen(this); 99345"];
1606 [label="return (SyntaxKind)this.RawKind; 99346"];
1607 [label="return SyntaxFacts.GetText(this.Kind); 99347"];
1608 [label="param GetText(SyntaxKind kind) 99348"];
1609 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99349"];
1610 [label="return '!'; 99350"];
1611 [label="FullWidth = this.Text.Length; 99351"];
1612 [label="FullWidth 99352"];
1613 [label="this.flags |= NodeFlags.IsNotMissing; 99353"];
1614 [label="this.flags 99354"];
1615 [label="this.AdjustFlagsAndWidth(leading); 99355"];
1616 [label="s_tokensWithElasticTrivia[(int)kind].Value 99356"];
1617 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.Space); 99357"];
1618 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99358"];
1619 [label="kind 99359"];
1620 [label="param SyntaxToken(SyntaxKind kind) 99360"];
1621 [label="kind 99361"];
1622 [label="param CSharpSyntaxNode(SyntaxKind kind) 99362"];
1623 [label="kind 99363"];
1624 [label="param CSharpSyntaxNode(this) 99364"];
1625 [label="GreenStats.NoteGreen(this); 99365"];
1626 [label="return (SyntaxKind)this.RawKind; 99366"];
1627 [label="return SyntaxFacts.GetText(this.Kind); 99367"];
1628 [label="param GetText(SyntaxKind kind) 99368"];
1629 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99369"];
1630 [label="return '!'; 99370"];
1631 [label="FullWidth = this.Text.Length; 99371"];
1632 [label="FullWidth 99372"];
1633 [label="this.flags |= NodeFlags.IsNotMissing; 99373"];
1634 [label="this.flags 99374"];
1635 [label="this.AdjustFlagsAndWidth(trailing); 99375"];
1636 [label="s_tokensWithSingleTrailingSpace[(int)kind].Value 99376"];
1637 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value = new SyntaxTokenWithTrivia(kind, null, SyntaxFactory.CarriageReturnLineFeed); 99377"];
1638 [label="param SyntaxTokenWithTrivia(SyntaxKind kind) 99378"];
1639 [label="kind 99379"];
1640 [label="param SyntaxToken(SyntaxKind kind) 99380"];
1641 [label="kind 99381"];
1642 [label="param CSharpSyntaxNode(SyntaxKind kind) 99382"];
1643 [label="kind 99383"];
1644 [label="param CSharpSyntaxNode(this) 99384"];
1645 [label="GreenStats.NoteGreen(this); 99385"];
1646 [label="return (SyntaxKind)this.RawKind; 99386"];
1647 [label="return SyntaxFacts.GetText(this.Kind); 99387"];
1648 [label="param GetText(SyntaxKind kind) 99388"];
1649 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 99389"];
1650 [label="return '!'; 99390"];
1651 [label="FullWidth = this.Text.Length; 99391"];
1652 [label="FullWidth 99392"];
1653 [label="this.flags |= NodeFlags.IsNotMissing; 99393"];
1654 [label="this.flags 99394"];
1655 [label="this.AdjustFlagsAndWidth(trailing); 99395"];
1656 [label="s_tokensWithSingleTrailingCRLF[(int)kind].Value 99396"];
1657 [label="return '$'; 99397"];
1658 [label="FullWidth = this.Text.Length; 99398"];
1659 [label="FullWidth 99399"];
1660 [label="return '$'; 99400"];
1661 [label="FullWidth = this.Text.Length; 99401"];
1662 [label="FullWidth 99402"];
1663 [label="this.AdjustFlagsAndWidth(leading); 99403"];
1664 [label="return '$'; 99404"];
1665 [label="FullWidth = this.Text.Length; 99405"];
1666 [label="FullWidth 99406"];
1667 [label="this.AdjustFlagsAndWidth(trailing); 99407"];
1668 [label="return '$'; 99408"];
1669 [label="FullWidth = this.Text.Length; 99409"];
1670 [label="FullWidth 99410"];
1671 [label="this.AdjustFlagsAndWidth(trailing); 99411"];
1672 [label="return '%'; 99412"];
1673 [label="FullWidth = this.Text.Length; 99413"];
1674 [label="FullWidth 99414"];
1675 [label="return '%'; 99415"];
1676 [label="FullWidth = this.Text.Length; 99416"];
1677 [label="FullWidth 99417"];
1678 [label="this.AdjustFlagsAndWidth(leading); 99418"];
1679 [label="return '%'; 99419"];
1680 [label="FullWidth = this.Text.Length; 99420"];
1681 [label="FullWidth 99421"];
1682 [label="this.AdjustFlagsAndWidth(trailing); 99422"];
1683 [label="return '%'; 99423"];
1684 [label="FullWidth = this.Text.Length; 99424"];
1685 [label="FullWidth 99425"];
1686 [label="this.AdjustFlagsAndWidth(trailing); 99426"];
1687 [label="return '^'; 99427"];
1688 [label="FullWidth = this.Text.Length; 99428"];
1689 [label="FullWidth 99429"];
1690 [label="return '^'; 99430"];
1691 [label="FullWidth = this.Text.Length; 99431"];
1692 [label="FullWidth 99432"];
1693 [label="this.AdjustFlagsAndWidth(leading); 99433"];
1694 [label="return '^'; 99434"];
1695 [label="FullWidth = this.Text.Length; 99435"];
1696 [label="FullWidth 99436"];
1697 [label="this.AdjustFlagsAndWidth(trailing); 99437"];
1698 [label="return '^'; 99438"];
1699 [label="FullWidth = this.Text.Length; 99439"];
1700 [label="FullWidth 99440"];
1701 [label="this.AdjustFlagsAndWidth(trailing); 99441"];
1702 [label="return '&'; 99442"];
1703 [label="FullWidth = this.Text.Length; 99443"];
1704 [label="FullWidth 99444"];
1705 [label="return '&'; 99445"];
1706 [label="FullWidth = this.Text.Length; 99446"];
1707 [label="FullWidth 99447"];
1708 [label="this.AdjustFlagsAndWidth(leading); 99448"];
1709 [label="return '&'; 99449"];
1710 [label="FullWidth = this.Text.Length; 99450"];
1711 [label="FullWidth 99451"];
1712 [label="this.AdjustFlagsAndWidth(trailing); 99452"];
1713 [label="return '&'; 99453"];
1714 [label="FullWidth = this.Text.Length; 99454"];
1715 [label="FullWidth 99455"];
1716 [label="this.AdjustFlagsAndWidth(trailing); 99456"];
1717 [label="return '*'; 99457"];
1718 [label="FullWidth = this.Text.Length; 99458"];
1719 [label="FullWidth 99459"];
1720 [label="return '*'; 99460"];
1721 [label="FullWidth = this.Text.Length; 99461"];
1722 [label="FullWidth 99462"];
1723 [label="this.AdjustFlagsAndWidth(leading); 99463"];
1724 [label="return '*'; 99464"];
1725 [label="FullWidth = this.Text.Length; 99465"];
1726 [label="FullWidth 99466"];
1727 [label="this.AdjustFlagsAndWidth(trailing); 99467"];
1728 [label="return '*'; 99468"];
1729 [label="FullWidth = this.Text.Length; 99469"];
1730 [label="FullWidth 99470"];
1731 [label="this.AdjustFlagsAndWidth(trailing); 99471"];
1732 [label="return '('; 99472"];
1733 [label="FullWidth = this.Text.Length; 99473"];
1734 [label="FullWidth 99474"];
1735 [label="return '('; 99475"];
1736 [label="FullWidth = this.Text.Length; 99476"];
1737 [label="FullWidth 99477"];
1738 [label="this.AdjustFlagsAndWidth(leading); 99478"];
1739 [label="return '('; 99479"];
1740 [label="FullWidth = this.Text.Length; 99480"];
1741 [label="FullWidth 99481"];
1742 [label="this.AdjustFlagsAndWidth(trailing); 99482"];
1743 [label="return '('; 99483"];
1744 [label="FullWidth = this.Text.Length; 99484"];
1745 [label="FullWidth 99485"];
1746 [label="this.AdjustFlagsAndWidth(trailing); 99486"];
1747 [label="return ')'; 99487"];
1748 [label="FullWidth = this.Text.Length; 99488"];
1749 [label="FullWidth 99489"];
1750 [label="return ')'; 99490"];
1751 [label="FullWidth = this.Text.Length; 99491"];
1752 [label="FullWidth 99492"];
1753 [label="this.AdjustFlagsAndWidth(leading); 99493"];
1754 [label="return ')'; 99494"];
1755 [label="FullWidth = this.Text.Length; 99495"];
1756 [label="FullWidth 99496"];
1757 [label="this.AdjustFlagsAndWidth(trailing); 99497"];
1758 [label="return ')'; 99498"];
1759 [label="FullWidth = this.Text.Length; 99499"];
1760 [label="FullWidth 99500"];
1761 [label="this.AdjustFlagsAndWidth(trailing); 99501"];
1762 [label="return '-'; 99502"];
1763 [label="FullWidth = this.Text.Length; 99503"];
1764 [label="FullWidth 99504"];
1765 [label="return '-'; 99505"];
1766 [label="FullWidth = this.Text.Length; 99506"];
1767 [label="FullWidth 99507"];
1768 [label="this.AdjustFlagsAndWidth(leading); 99508"];
1769 [label="return '-'; 99509"];
1770 [label="FullWidth = this.Text.Length; 99510"];
1771 [label="FullWidth 99511"];
1772 [label="this.AdjustFlagsAndWidth(trailing); 99512"];
1773 [label="return '-'; 99513"];
1774 [label="FullWidth = this.Text.Length; 99514"];
1775 [label="FullWidth 99515"];
1776 [label="this.AdjustFlagsAndWidth(trailing); 99516"];
1777 [label="return '+'; 99517"];
1778 [label="FullWidth = this.Text.Length; 99518"];
1779 [label="FullWidth 99519"];
1780 [label="return '+'; 99520"];
1781 [label="FullWidth = this.Text.Length; 99521"];
1782 [label="FullWidth 99522"];
1783 [label="this.AdjustFlagsAndWidth(leading); 99523"];
1784 [label="return '+'; 99524"];
1785 [label="FullWidth = this.Text.Length; 99525"];
1786 [label="FullWidth 99526"];
1787 [label="this.AdjustFlagsAndWidth(trailing); 99527"];
1788 [label="return '+'; 99528"];
1789 [label="FullWidth = this.Text.Length; 99529"];
1790 [label="FullWidth 99530"];
1791 [label="this.AdjustFlagsAndWidth(trailing); 99531"];
1792 [label="return '='; 99532"];
1793 [label="FullWidth = this.Text.Length; 99533"];
1794 [label="FullWidth 99534"];
1795 [label="return '='; 99535"];
1796 [label="FullWidth = this.Text.Length; 99536"];
1797 [label="FullWidth 99537"];
1798 [label="this.AdjustFlagsAndWidth(leading); 99538"];
1799 [label="return '='; 99539"];
1800 [label="FullWidth = this.Text.Length; 99540"];
1801 [label="FullWidth 99541"];
1802 [label="this.AdjustFlagsAndWidth(trailing); 99542"];
1803 [label="return '='; 99543"];
1804 [label="FullWidth = this.Text.Length; 99544"];
1805 [label="FullWidth 99545"];
1806 [label="this.AdjustFlagsAndWidth(trailing); 99546"];
1807 [label="return '{'; 99547"];
1808 [label="FullWidth = this.Text.Length; 99548"];
1809 [label="FullWidth 99549"];
1810 [label="return '{'; 99550"];
1811 [label="FullWidth = this.Text.Length; 99551"];
1812 [label="FullWidth 99552"];
1813 [label="this.AdjustFlagsAndWidth(leading); 99553"];
1814 [label="return '{'; 99554"];
1815 [label="FullWidth = this.Text.Length; 99555"];
1816 [label="FullWidth 99556"];
1817 [label="this.AdjustFlagsAndWidth(trailing); 99557"];
1818 [label="return '{'; 99558"];
1819 [label="FullWidth = this.Text.Length; 99559"];
1820 [label="FullWidth 99560"];
1821 [label="this.AdjustFlagsAndWidth(trailing); 99561"];
1822 [label="return '}'; 99562"];
1823 [label="FullWidth = this.Text.Length; 99563"];
1824 [label="FullWidth 99564"];
1825 [label="return '}'; 99565"];
1826 [label="FullWidth = this.Text.Length; 99566"];
1827 [label="FullWidth 99567"];
1828 [label="this.AdjustFlagsAndWidth(leading); 99568"];
1829 [label="return '}'; 99569"];
1830 [label="FullWidth = this.Text.Length; 99570"];
1831 [label="FullWidth 99571"];
1832 [label="this.AdjustFlagsAndWidth(trailing); 99572"];
1833 [label="return '}'; 99573"];
1834 [label="FullWidth = this.Text.Length; 99574"];
1835 [label="FullWidth 99575"];
1836 [label="this.AdjustFlagsAndWidth(trailing); 99576"];
1837 [label="return '['; 99577"];
1838 [label="FullWidth = this.Text.Length; 99578"];
1839 [label="FullWidth 99579"];
1840 [label="return '['; 99580"];
1841 [label="FullWidth = this.Text.Length; 99581"];
1842 [label="FullWidth 99582"];
1843 [label="this.AdjustFlagsAndWidth(leading); 99583"];
1844 [label="return '['; 99584"];
1845 [label="FullWidth = this.Text.Length; 99585"];
1846 [label="FullWidth 99586"];
1847 [label="this.AdjustFlagsAndWidth(trailing); 99587"];
1848 [label="return '['; 99588"];
1849 [label="FullWidth = this.Text.Length; 99589"];
1850 [label="FullWidth 99590"];
1851 [label="this.AdjustFlagsAndWidth(trailing); 99591"];
1852 [label="return ']'; 99592"];
1853 [label="FullWidth = this.Text.Length; 99593"];
1854 [label="FullWidth 99594"];
1855 [label="return ']'; 99595"];
1856 [label="FullWidth = this.Text.Length; 99596"];
1857 [label="FullWidth 99597"];
1858 [label="this.AdjustFlagsAndWidth(leading); 99598"];
1859 [label="return ']'; 99599"];
1860 [label="FullWidth = this.Text.Length; 99600"];
1861 [label="FullWidth 99601"];
1862 [label="this.AdjustFlagsAndWidth(trailing); 99602"];
1863 [label="return ']'; 99603"];
1864 [label="FullWidth = this.Text.Length; 99604"];
1865 [label="FullWidth 99605"];
1866 [label="this.AdjustFlagsAndWidth(trailing); 99606"];
1867 [label="return '|'; 99607"];
1868 [label="FullWidth = this.Text.Length; 99608"];
1869 [label="FullWidth 99609"];
1870 [label="return '|'; 99610"];
1871 [label="FullWidth = this.Text.Length; 99611"];
1872 [label="FullWidth 99612"];
1873 [label="this.AdjustFlagsAndWidth(leading); 99613"];
1874 [label="return '|'; 99614"];
1875 [label="FullWidth = this.Text.Length; 99615"];
1876 [label="FullWidth 99616"];
1877 [label="this.AdjustFlagsAndWidth(trailing); 99617"];
1878 [label="return '|'; 99618"];
1879 [label="FullWidth = this.Text.Length; 99619"];
1880 [label="FullWidth 99620"];
1881 [label="this.AdjustFlagsAndWidth(trailing); 99621"];
1882 [label="return '\\\\'; 99622"];
1883 [label="FullWidth = this.Text.Length; 99623"];
1884 [label="FullWidth 99624"];
1885 [label="return '\\\\'; 99625"];
1886 [label="FullWidth = this.Text.Length; 99626"];
1887 [label="FullWidth 99627"];
1888 [label="this.AdjustFlagsAndWidth(leading); 99628"];
1889 [label="return '\\\\'; 99629"];
1890 [label="FullWidth = this.Text.Length; 99630"];
1891 [label="FullWidth 99631"];
1892 [label="this.AdjustFlagsAndWidth(trailing); 99632"];
1893 [label="return '\\\\'; 99633"];
1894 [label="FullWidth = this.Text.Length; 99634"];
1895 [label="FullWidth 99635"];
1896 [label="this.AdjustFlagsAndWidth(trailing); 99636"];
1897 [label="return ':'; 99637"];
1898 [label="FullWidth = this.Text.Length; 99638"];
1899 [label="FullWidth 99639"];
1900 [label="return ':'; 99640"];
1901 [label="FullWidth = this.Text.Length; 99641"];
1902 [label="FullWidth 99642"];
1903 [label="this.AdjustFlagsAndWidth(leading); 99643"];
1904 [label="return ':'; 99644"];
1905 [label="FullWidth = this.Text.Length; 99645"];
1906 [label="FullWidth 99646"];
1907 [label="this.AdjustFlagsAndWidth(trailing); 99647"];
1908 [label="return ':'; 99648"];
1909 [label="FullWidth = this.Text.Length; 99649"];
1910 [label="FullWidth 99650"];
1911 [label="this.AdjustFlagsAndWidth(trailing); 99651"];
1912 [label="return ';'; 99652"];
1913 [label="FullWidth = this.Text.Length; 99653"];
1914 [label="FullWidth 99654"];
1915 [label="return ';'; 99655"];
1916 [label="FullWidth = this.Text.Length; 99656"];
1917 [label="FullWidth 99657"];
1918 [label="this.AdjustFlagsAndWidth(leading); 99658"];
1919 [label="return ';'; 99659"];
1920 [label="FullWidth = this.Text.Length; 99660"];
1921 [label="FullWidth 99661"];
1922 [label="this.AdjustFlagsAndWidth(trailing); 99662"];
1923 [label="return ';'; 99663"];
1924 [label="FullWidth = this.Text.Length; 99664"];
1925 [label="FullWidth 99665"];
1926 [label="this.AdjustFlagsAndWidth(trailing); 99666"];
1927 [label="return '\\''; 99667"];
1928 [label="FullWidth = this.Text.Length; 99668"];
1929 [label="FullWidth 99669"];
1930 [label="return '\\''; 99670"];
1931 [label="FullWidth = this.Text.Length; 99671"];
1932 [label="FullWidth 99672"];
1933 [label="this.AdjustFlagsAndWidth(leading); 99673"];
1934 [label="return '\\''; 99674"];
1935 [label="FullWidth = this.Text.Length; 99675"];
1936 [label="FullWidth 99676"];
1937 [label="this.AdjustFlagsAndWidth(trailing); 99677"];
1938 [label="return '\\''; 99678"];
1939 [label="FullWidth = this.Text.Length; 99679"];
1940 [label="FullWidth 99680"];
1941 [label="this.AdjustFlagsAndWidth(trailing); 99681"];
1942 [label="return '''; 99682"];
1943 [label="FullWidth = this.Text.Length; 99683"];
1944 [label="FullWidth 99684"];
1945 [label="return '''; 99685"];
1946 [label="FullWidth = this.Text.Length; 99686"];
1947 [label="FullWidth 99687"];
1948 [label="this.AdjustFlagsAndWidth(leading); 99688"];
1949 [label="return '''; 99689"];
1950 [label="FullWidth = this.Text.Length; 99690"];
1951 [label="FullWidth 99691"];
1952 [label="this.AdjustFlagsAndWidth(trailing); 99692"];
1953 [label="return '''; 99693"];
1954 [label="FullWidth = this.Text.Length; 99694"];
1955 [label="FullWidth 99695"];
1956 [label="this.AdjustFlagsAndWidth(trailing); 99696"];
1957 [label="return '<'; 99697"];
1958 [label="FullWidth = this.Text.Length; 99698"];
1959 [label="FullWidth 99699"];
1960 [label="return '<'; 99700"];
1961 [label="FullWidth = this.Text.Length; 99701"];
1962 [label="FullWidth 99702"];
1963 [label="this.AdjustFlagsAndWidth(leading); 99703"];
1964 [label="return '<'; 99704"];
1965 [label="FullWidth = this.Text.Length; 99705"];
1966 [label="FullWidth 99706"];
1967 [label="this.AdjustFlagsAndWidth(trailing); 99707"];
1968 [label="return '<'; 99708"];
1969 [label="FullWidth = this.Text.Length; 99709"];
1970 [label="FullWidth 99710"];
1971 [label="this.AdjustFlagsAndWidth(trailing); 99711"];
1972 [label="return ','; 99712"];
1973 [label="FullWidth = this.Text.Length; 99713"];
1974 [label="FullWidth 99714"];
1975 [label="return ','; 99715"];
1976 [label="FullWidth = this.Text.Length; 99716"];
1977 [label="FullWidth 99717"];
1978 [label="this.AdjustFlagsAndWidth(leading); 99718"];
1979 [label="return ','; 99719"];
1980 [label="FullWidth = this.Text.Length; 99720"];
1981 [label="FullWidth 99721"];
1982 [label="this.AdjustFlagsAndWidth(trailing); 99722"];
1983 [label="return ','; 99723"];
1984 [label="FullWidth = this.Text.Length; 99724"];
1985 [label="FullWidth 99725"];
1986 [label="this.AdjustFlagsAndWidth(trailing); 99726"];
1987 [label="return '>'; 99727"];
1988 [label="FullWidth = this.Text.Length; 99728"];
1989 [label="FullWidth 99729"];
1990 [label="return '>'; 99730"];
1991 [label="FullWidth = this.Text.Length; 99731"];
1992 [label="FullWidth 99732"];
1993 [label="this.AdjustFlagsAndWidth(leading); 99733"];
1994 [label="return '>'; 99734"];
1995 [label="FullWidth = this.Text.Length; 99735"];
1996 [label="FullWidth 99736"];
1997 [label="this.AdjustFlagsAndWidth(trailing); 99737"];
1998 [label="return '>'; 99738"];
1999 [label="FullWidth = this.Text.Length; 99739"];
2000 [label="FullWidth 99740"];
2001 [label="this.AdjustFlagsAndWidth(trailing); 99741"];
2002 [label="return '.'; 99742"];
2003 [label="FullWidth = this.Text.Length; 99743"];
2004 [label="FullWidth 99744"];
2005 [label="return '.'; 99745"];
2006 [label="FullWidth = this.Text.Length; 99746"];
2007 [label="FullWidth 99747"];
2008 [label="this.AdjustFlagsAndWidth(leading); 99748"];
2009 [label="return '.'; 99749"];
2010 [label="FullWidth = this.Text.Length; 99750"];
2011 [label="FullWidth 99751"];
2012 [label="this.AdjustFlagsAndWidth(trailing); 99752"];
2013 [label="return '.'; 99753"];
2014 [label="FullWidth = this.Text.Length; 99754"];
2015 [label="FullWidth 99755"];
2016 [label="this.AdjustFlagsAndWidth(trailing); 99756"];
2017 [label="return '?'; 99757"];
2018 [label="FullWidth = this.Text.Length; 99758"];
2019 [label="FullWidth 99759"];
2020 [label="return '?'; 99760"];
2021 [label="FullWidth = this.Text.Length; 99761"];
2022 [label="FullWidth 99762"];
2023 [label="this.AdjustFlagsAndWidth(leading); 99763"];
2024 [label="return '?'; 99764"];
2025 [label="FullWidth = this.Text.Length; 99765"];
2026 [label="FullWidth 99766"];
2027 [label="this.AdjustFlagsAndWidth(trailing); 99767"];
2028 [label="return '?'; 99768"];
2029 [label="FullWidth = this.Text.Length; 99769"];
2030 [label="FullWidth 99770"];
2031 [label="this.AdjustFlagsAndWidth(trailing); 99771"];
2032 [label="return '#'; 99772"];
2033 [label="FullWidth = this.Text.Length; 99773"];
2034 [label="FullWidth 99774"];
2035 [label="return '#'; 99775"];
2036 [label="FullWidth = this.Text.Length; 99776"];
2037 [label="FullWidth 99777"];
2038 [label="this.AdjustFlagsAndWidth(leading); 99778"];
2039 [label="return '#'; 99779"];
2040 [label="FullWidth = this.Text.Length; 99780"];
2041 [label="FullWidth 99781"];
2042 [label="this.AdjustFlagsAndWidth(trailing); 99782"];
2043 [label="return '#'; 99783"];
2044 [label="FullWidth = this.Text.Length; 99784"];
2045 [label="FullWidth 99785"];
2046 [label="this.AdjustFlagsAndWidth(trailing); 99786"];
2047 [label="return '/'; 99787"];
2048 [label="FullWidth = this.Text.Length; 99788"];
2049 [label="FullWidth 99789"];
2050 [label="return '/'; 99790"];
2051 [label="FullWidth = this.Text.Length; 99791"];
2052 [label="FullWidth 99792"];
2053 [label="this.AdjustFlagsAndWidth(leading); 99793"];
2054 [label="return '/'; 99794"];
2055 [label="FullWidth = this.Text.Length; 99795"];
2056 [label="FullWidth 99796"];
2057 [label="this.AdjustFlagsAndWidth(trailing); 99797"];
2058 [label="return '/'; 99798"];
2059 [label="FullWidth = this.Text.Length; 99799"];
2060 [label="FullWidth 99800"];
2061 [label="this.AdjustFlagsAndWidth(trailing); 99801"];
2062 [label="return '..'; 99802"];
2063 [label="FullWidth = this.Text.Length; 99803"];
2064 [label="FullWidth 99804"];
2065 [label="return '..'; 99805"];
2066 [label="FullWidth = this.Text.Length; 99806"];
2067 [label="FullWidth 99807"];
2068 [label="this.AdjustFlagsAndWidth(leading); 99808"];
2069 [label="return '..'; 99809"];
2070 [label="FullWidth = this.Text.Length; 99810"];
2071 [label="FullWidth 99811"];
2072 [label="this.AdjustFlagsAndWidth(trailing); 99812"];
2073 [label="return '..'; 99813"];
2074 [label="FullWidth = this.Text.Length; 99814"];
2075 [label="FullWidth 99815"];
2076 [label="this.AdjustFlagsAndWidth(trailing); 99816"];
2077 [label="return string.Empty; 99817"];
2078 [label="FullWidth = this.Text.Length; 99818"];
2079 [label="FullWidth 99819"];
2080 [label="return string.Empty; 99820"];
2081 [label="FullWidth = this.Text.Length; 99821"];
2082 [label="FullWidth 99822"];
2083 [label="this.AdjustFlagsAndWidth(leading); 99823"];
2084 [label="return string.Empty; 99824"];
2085 [label="FullWidth = this.Text.Length; 99825"];
2086 [label="FullWidth 99826"];
2087 [label="this.AdjustFlagsAndWidth(trailing); 99827"];
2088 [label="return string.Empty; 99828"];
2089 [label="FullWidth = this.Text.Length; 99829"];
2090 [label="FullWidth 99830"];
2091 [label="this.AdjustFlagsAndWidth(trailing); 99831"];
2092 [label="return '/>'; 99832"];
2093 [label="FullWidth = this.Text.Length; 99833"];
2094 [label="FullWidth 99834"];
2095 [label="return '/>'; 99835"];
2096 [label="FullWidth = this.Text.Length; 99836"];
2097 [label="FullWidth 99837"];
2098 [label="this.AdjustFlagsAndWidth(leading); 99838"];
2099 [label="return '/>'; 99839"];
2100 [label="FullWidth = this.Text.Length; 99840"];
2101 [label="FullWidth 99841"];
2102 [label="this.AdjustFlagsAndWidth(trailing); 99842"];
2103 [label="return '/>'; 99843"];
2104 [label="FullWidth = this.Text.Length; 99844"];
2105 [label="FullWidth 99845"];
2106 [label="this.AdjustFlagsAndWidth(trailing); 99846"];
2107 [label="return '</'; 99847"];
2108 [label="FullWidth = this.Text.Length; 99848"];
2109 [label="FullWidth 99849"];
2110 [label="return '</'; 99850"];
2111 [label="FullWidth = this.Text.Length; 99851"];
2112 [label="FullWidth 99852"];
2113 [label="this.AdjustFlagsAndWidth(leading); 99853"];
2114 [label="return '</'; 99854"];
2115 [label="FullWidth = this.Text.Length; 99855"];
2116 [label="FullWidth 99856"];
2117 [label="this.AdjustFlagsAndWidth(trailing); 99857"];
2118 [label="return '</'; 99858"];
2119 [label="FullWidth = this.Text.Length; 99859"];
2120 [label="FullWidth 99860"];
2121 [label="this.AdjustFlagsAndWidth(trailing); 99861"];
2122 [label="return '<!--'; 99862"];
2123 [label="FullWidth = this.Text.Length; 99863"];
2124 [label="FullWidth 99864"];
2125 [label="return '<!--'; 99865"];
2126 [label="FullWidth = this.Text.Length; 99866"];
2127 [label="FullWidth 99867"];
2128 [label="this.AdjustFlagsAndWidth(leading); 99868"];
2129 [label="return '<!--'; 99869"];
2130 [label="FullWidth = this.Text.Length; 99870"];
2131 [label="FullWidth 99871"];
2132 [label="this.AdjustFlagsAndWidth(trailing); 99872"];
2133 [label="return '<!--'; 99873"];
2134 [label="FullWidth = this.Text.Length; 99874"];
2135 [label="FullWidth 99875"];
2136 [label="this.AdjustFlagsAndWidth(trailing); 99876"];
2137 [label="return '-->'; 99877"];
2138 [label="FullWidth = this.Text.Length; 99878"];
2139 [label="FullWidth 99879"];
2140 [label="return '-->'; 99880"];
2141 [label="FullWidth = this.Text.Length; 99881"];
2142 [label="FullWidth 99882"];
2143 [label="this.AdjustFlagsAndWidth(leading); 99883"];
2144 [label="return '-->'; 99884"];
2145 [label="FullWidth = this.Text.Length; 99885"];
2146 [label="FullWidth 99886"];
2147 [label="this.AdjustFlagsAndWidth(trailing); 99887"];
2148 [label="return '-->'; 99888"];
2149 [label="FullWidth = this.Text.Length; 99889"];
2150 [label="FullWidth 99890"];
2151 [label="this.AdjustFlagsAndWidth(trailing); 99891"];
2152 [label="return '<![CDATA['; 99892"];
2153 [label="FullWidth = this.Text.Length; 99893"];
2154 [label="FullWidth 99894"];
2155 [label="return '<![CDATA['; 99895"];
2156 [label="FullWidth = this.Text.Length; 99896"];
2157 [label="FullWidth 99897"];
2158 [label="this.AdjustFlagsAndWidth(leading); 99898"];
2159 [label="return '<![CDATA['; 99899"];
2160 [label="FullWidth = this.Text.Length; 99900"];
2161 [label="FullWidth 99901"];
2162 [label="this.AdjustFlagsAndWidth(trailing); 99902"];
2163 [label="return '<![CDATA['; 99903"];
2164 [label="FullWidth = this.Text.Length; 99904"];
2165 [label="FullWidth 99905"];
2166 [label="this.AdjustFlagsAndWidth(trailing); 99906"];
2167 [label="return ']]>'; 99907"];
2168 [label="FullWidth = this.Text.Length; 99908"];
2169 [label="FullWidth 99909"];
2170 [label="return ']]>'; 99910"];
2171 [label="FullWidth = this.Text.Length; 99911"];
2172 [label="FullWidth 99912"];
2173 [label="this.AdjustFlagsAndWidth(leading); 99913"];
2174 [label="return ']]>'; 99914"];
2175 [label="FullWidth = this.Text.Length; 99915"];
2176 [label="FullWidth 99916"];
2177 [label="this.AdjustFlagsAndWidth(trailing); 99917"];
2178 [label="return ']]>'; 99918"];
2179 [label="FullWidth = this.Text.Length; 99919"];
2180 [label="FullWidth 99920"];
2181 [label="this.AdjustFlagsAndWidth(trailing); 99921"];
2182 [label="return '<?'; 99922"];
2183 [label="FullWidth = this.Text.Length; 99923"];
2184 [label="FullWidth 99924"];
2185 [label="return '<?'; 99925"];
2186 [label="FullWidth = this.Text.Length; 99926"];
2187 [label="FullWidth 99927"];
2188 [label="this.AdjustFlagsAndWidth(leading); 99928"];
2189 [label="return '<?'; 99929"];
2190 [label="FullWidth = this.Text.Length; 99930"];
2191 [label="FullWidth 99931"];
2192 [label="this.AdjustFlagsAndWidth(trailing); 99932"];
2193 [label="return '<?'; 99933"];
2194 [label="FullWidth = this.Text.Length; 99934"];
2195 [label="FullWidth 99935"];
2196 [label="this.AdjustFlagsAndWidth(trailing); 99936"];
2197 [label="return '?>'; 99937"];
2198 [label="FullWidth = this.Text.Length; 99938"];
2199 [label="FullWidth 99939"];
2200 [label="return '?>'; 99940"];
2201 [label="FullWidth = this.Text.Length; 99941"];
2202 [label="FullWidth 99942"];
2203 [label="this.AdjustFlagsAndWidth(leading); 99943"];
2204 [label="return '?>'; 99944"];
2205 [label="FullWidth = this.Text.Length; 99945"];
2206 [label="FullWidth 99946"];
2207 [label="this.AdjustFlagsAndWidth(trailing); 99947"];
2208 [label="return '?>'; 99948"];
2209 [label="FullWidth = this.Text.Length; 99949"];
2210 [label="FullWidth 99950"];
2211 [label="this.AdjustFlagsAndWidth(trailing); 99951"];
2212 [label="return '||'; 99952"];
2213 [label="FullWidth = this.Text.Length; 99953"];
2214 [label="FullWidth 99954"];
2215 [label="return '||'; 99955"];
2216 [label="FullWidth = this.Text.Length; 99956"];
2217 [label="FullWidth 99957"];
2218 [label="this.AdjustFlagsAndWidth(leading); 99958"];
2219 [label="return '||'; 99959"];
2220 [label="FullWidth = this.Text.Length; 99960"];
2221 [label="FullWidth 99961"];
2222 [label="this.AdjustFlagsAndWidth(trailing); 99962"];
2223 [label="return '||'; 99963"];
2224 [label="FullWidth = this.Text.Length; 99964"];
2225 [label="FullWidth 99965"];
2226 [label="this.AdjustFlagsAndWidth(trailing); 99966"];
2227 [label="return '&&'; 99967"];
2228 [label="FullWidth = this.Text.Length; 99968"];
2229 [label="FullWidth 99969"];
2230 [label="return '&&'; 99970"];
2231 [label="FullWidth = this.Text.Length; 99971"];
2232 [label="FullWidth 99972"];
2233 [label="this.AdjustFlagsAndWidth(leading); 99973"];
2234 [label="return '&&'; 99974"];
2235 [label="FullWidth = this.Text.Length; 99975"];
2236 [label="FullWidth 99976"];
2237 [label="this.AdjustFlagsAndWidth(trailing); 99977"];
2238 [label="return '&&'; 99978"];
2239 [label="FullWidth = this.Text.Length; 99979"];
2240 [label="FullWidth 99980"];
2241 [label="this.AdjustFlagsAndWidth(trailing); 99981"];
2242 [label="return '--'; 99982"];
2243 [label="FullWidth = this.Text.Length; 99983"];
2244 [label="FullWidth 99984"];
2245 [label="return '--'; 99985"];
2246 [label="FullWidth = this.Text.Length; 99986"];
2247 [label="FullWidth 99987"];
2248 [label="this.AdjustFlagsAndWidth(leading); 99988"];
2249 [label="return '--'; 99989"];
2250 [label="FullWidth = this.Text.Length; 99990"];
2251 [label="FullWidth 99991"];
2252 [label="this.AdjustFlagsAndWidth(trailing); 99992"];
2253 [label="return '--'; 99993"];
2254 [label="FullWidth = this.Text.Length; 99994"];
2255 [label="FullWidth 99995"];
2256 [label="this.AdjustFlagsAndWidth(trailing); 99996"];
2257 [label="return '++'; 99997"];
2258 [label="FullWidth = this.Text.Length; 99998"];
2259 [label="FullWidth 99999"];
2260 [label="return '++'; 100000"];
2261 [label="FullWidth = this.Text.Length; 100001"];
2262 [label="FullWidth 100002"];
2263 [label="this.AdjustFlagsAndWidth(leading); 100003"];
2264 [label="return '++'; 100004"];
2265 [label="FullWidth = this.Text.Length; 100005"];
2266 [label="FullWidth 100006"];
2267 [label="this.AdjustFlagsAndWidth(trailing); 100007"];
2268 [label="return '++'; 100008"];
2269 [label="FullWidth = this.Text.Length; 100009"];
2270 [label="FullWidth 100010"];
2271 [label="this.AdjustFlagsAndWidth(trailing); 100011"];
2272 [label="return '::'; 100012"];
2273 [label="FullWidth = this.Text.Length; 100013"];
2274 [label="FullWidth 100014"];
2275 [label="return '::'; 100015"];
2276 [label="FullWidth = this.Text.Length; 100016"];
2277 [label="FullWidth 100017"];
2278 [label="this.AdjustFlagsAndWidth(leading); 100018"];
2279 [label="return '::'; 100019"];
2280 [label="FullWidth = this.Text.Length; 100020"];
2281 [label="FullWidth 100021"];
2282 [label="this.AdjustFlagsAndWidth(trailing); 100022"];
2283 [label="return '::'; 100023"];
2284 [label="FullWidth = this.Text.Length; 100024"];
2285 [label="FullWidth 100025"];
2286 [label="this.AdjustFlagsAndWidth(trailing); 100026"];
2287 [label="return '??'; 100027"];
2288 [label="FullWidth = this.Text.Length; 100028"];
2289 [label="FullWidth 100029"];
2290 [label="return '??'; 100030"];
2291 [label="FullWidth = this.Text.Length; 100031"];
2292 [label="FullWidth 100032"];
2293 [label="this.AdjustFlagsAndWidth(leading); 100033"];
2294 [label="return '??'; 100034"];
2295 [label="FullWidth = this.Text.Length; 100035"];
2296 [label="FullWidth 100036"];
2297 [label="this.AdjustFlagsAndWidth(trailing); 100037"];
2298 [label="return '??'; 100038"];
2299 [label="FullWidth = this.Text.Length; 100039"];
2300 [label="FullWidth 100040"];
2301 [label="this.AdjustFlagsAndWidth(trailing); 100041"];
2302 [label="return '->'; 100042"];
2303 [label="FullWidth = this.Text.Length; 100043"];
2304 [label="FullWidth 100044"];
2305 [label="return '->'; 100045"];
2306 [label="FullWidth = this.Text.Length; 100046"];
2307 [label="FullWidth 100047"];
2308 [label="this.AdjustFlagsAndWidth(leading); 100048"];
2309 [label="return '->'; 100049"];
2310 [label="FullWidth = this.Text.Length; 100050"];
2311 [label="FullWidth 100051"];
2312 [label="this.AdjustFlagsAndWidth(trailing); 100052"];
2313 [label="return '->'; 100053"];
2314 [label="FullWidth = this.Text.Length; 100054"];
2315 [label="FullWidth 100055"];
2316 [label="this.AdjustFlagsAndWidth(trailing); 100056"];
2317 [label="return '!='; 100057"];
2318 [label="FullWidth = this.Text.Length; 100058"];
2319 [label="FullWidth 100059"];
2320 [label="return '!='; 100060"];
2321 [label="FullWidth = this.Text.Length; 100061"];
2322 [label="FullWidth 100062"];
2323 [label="this.AdjustFlagsAndWidth(leading); 100063"];
2324 [label="return '!='; 100064"];
2325 [label="FullWidth = this.Text.Length; 100065"];
2326 [label="FullWidth 100066"];
2327 [label="this.AdjustFlagsAndWidth(trailing); 100067"];
2328 [label="return '!='; 100068"];
2329 [label="FullWidth = this.Text.Length; 100069"];
2330 [label="FullWidth 100070"];
2331 [label="this.AdjustFlagsAndWidth(trailing); 100071"];
2332 [label="return '=='; 100072"];
2333 [label="FullWidth = this.Text.Length; 100073"];
2334 [label="FullWidth 100074"];
2335 [label="return '=='; 100075"];
2336 [label="FullWidth = this.Text.Length; 100076"];
2337 [label="FullWidth 100077"];
2338 [label="this.AdjustFlagsAndWidth(leading); 100078"];
2339 [label="return '=='; 100079"];
2340 [label="FullWidth = this.Text.Length; 100080"];
2341 [label="FullWidth 100081"];
2342 [label="this.AdjustFlagsAndWidth(trailing); 100082"];
2343 [label="return '=='; 100083"];
2344 [label="FullWidth = this.Text.Length; 100084"];
2345 [label="FullWidth 100085"];
2346 [label="this.AdjustFlagsAndWidth(trailing); 100086"];
2347 [label="return '=>'; 100087"];
2348 [label="FullWidth = this.Text.Length; 100088"];
2349 [label="FullWidth 100089"];
2350 [label="return '=>'; 100090"];
2351 [label="FullWidth = this.Text.Length; 100091"];
2352 [label="FullWidth 100092"];
2353 [label="this.AdjustFlagsAndWidth(leading); 100093"];
2354 [label="return '=>'; 100094"];
2355 [label="FullWidth = this.Text.Length; 100095"];
2356 [label="FullWidth 100096"];
2357 [label="this.AdjustFlagsAndWidth(trailing); 100097"];
2358 [label="return '=>'; 100098"];
2359 [label="FullWidth = this.Text.Length; 100099"];
2360 [label="FullWidth 100100"];
2361 [label="this.AdjustFlagsAndWidth(trailing); 100101"];
2362 [label="return '<='; 100102"];
2363 [label="FullWidth = this.Text.Length; 100103"];
2364 [label="FullWidth 100104"];
2365 [label="return '<='; 100105"];
2366 [label="FullWidth = this.Text.Length; 100106"];
2367 [label="FullWidth 100107"];
2368 [label="this.AdjustFlagsAndWidth(leading); 100108"];
2369 [label="return '<='; 100109"];
2370 [label="FullWidth = this.Text.Length; 100110"];
2371 [label="FullWidth 100111"];
2372 [label="this.AdjustFlagsAndWidth(trailing); 100112"];
2373 [label="return '<='; 100113"];
2374 [label="FullWidth = this.Text.Length; 100114"];
2375 [label="FullWidth 100115"];
2376 [label="this.AdjustFlagsAndWidth(trailing); 100116"];
2377 [label="return '<<'; 100117"];
2378 [label="FullWidth = this.Text.Length; 100118"];
2379 [label="FullWidth 100119"];
2380 [label="return '<<'; 100120"];
2381 [label="FullWidth = this.Text.Length; 100121"];
2382 [label="FullWidth 100122"];
2383 [label="this.AdjustFlagsAndWidth(leading); 100123"];
2384 [label="return '<<'; 100124"];
2385 [label="FullWidth = this.Text.Length; 100125"];
2386 [label="FullWidth 100126"];
2387 [label="this.AdjustFlagsAndWidth(trailing); 100127"];
2388 [label="return '<<'; 100128"];
2389 [label="FullWidth = this.Text.Length; 100129"];
2390 [label="FullWidth 100130"];
2391 [label="this.AdjustFlagsAndWidth(trailing); 100131"];
2392 [label="return '<<='; 100132"];
2393 [label="FullWidth = this.Text.Length; 100133"];
2394 [label="FullWidth 100134"];
2395 [label="return '<<='; 100135"];
2396 [label="FullWidth = this.Text.Length; 100136"];
2397 [label="FullWidth 100137"];
2398 [label="this.AdjustFlagsAndWidth(leading); 100138"];
2399 [label="return '<<='; 100139"];
2400 [label="FullWidth = this.Text.Length; 100140"];
2401 [label="FullWidth 100141"];
2402 [label="this.AdjustFlagsAndWidth(trailing); 100142"];
2403 [label="return '<<='; 100143"];
2404 [label="FullWidth = this.Text.Length; 100144"];
2405 [label="FullWidth 100145"];
2406 [label="this.AdjustFlagsAndWidth(trailing); 100146"];
2407 [label="return '>='; 100147"];
2408 [label="FullWidth = this.Text.Length; 100148"];
2409 [label="FullWidth 100149"];
2410 [label="return '>='; 100150"];
2411 [label="FullWidth = this.Text.Length; 100151"];
2412 [label="FullWidth 100152"];
2413 [label="this.AdjustFlagsAndWidth(leading); 100153"];
2414 [label="return '>='; 100154"];
2415 [label="FullWidth = this.Text.Length; 100155"];
2416 [label="FullWidth 100156"];
2417 [label="this.AdjustFlagsAndWidth(trailing); 100157"];
2418 [label="return '>='; 100158"];
2419 [label="FullWidth = this.Text.Length; 100159"];
2420 [label="FullWidth 100160"];
2421 [label="this.AdjustFlagsAndWidth(trailing); 100161"];
2422 [label="return '>>'; 100162"];
2423 [label="FullWidth = this.Text.Length; 100163"];
2424 [label="FullWidth 100164"];
2425 [label="return '>>'; 100165"];
2426 [label="FullWidth = this.Text.Length; 100166"];
2427 [label="FullWidth 100167"];
2428 [label="this.AdjustFlagsAndWidth(leading); 100168"];
2429 [label="return '>>'; 100169"];
2430 [label="FullWidth = this.Text.Length; 100170"];
2431 [label="FullWidth 100171"];
2432 [label="this.AdjustFlagsAndWidth(trailing); 100172"];
2433 [label="return '>>'; 100173"];
2434 [label="FullWidth = this.Text.Length; 100174"];
2435 [label="FullWidth 100175"];
2436 [label="this.AdjustFlagsAndWidth(trailing); 100176"];
2437 [label="return '>>='; 100177"];
2438 [label="FullWidth = this.Text.Length; 100178"];
2439 [label="FullWidth 100179"];
2440 [label="return '>>='; 100180"];
2441 [label="FullWidth = this.Text.Length; 100181"];
2442 [label="FullWidth 100182"];
2443 [label="this.AdjustFlagsAndWidth(leading); 100183"];
2444 [label="return '>>='; 100184"];
2445 [label="FullWidth = this.Text.Length; 100185"];
2446 [label="FullWidth 100186"];
2447 [label="this.AdjustFlagsAndWidth(trailing); 100187"];
2448 [label="return '>>='; 100188"];
2449 [label="FullWidth = this.Text.Length; 100189"];
2450 [label="FullWidth 100190"];
2451 [label="this.AdjustFlagsAndWidth(trailing); 100191"];
2452 [label="return '/='; 100192"];
2453 [label="FullWidth = this.Text.Length; 100193"];
2454 [label="FullWidth 100194"];
2455 [label="return '/='; 100195"];
2456 [label="FullWidth = this.Text.Length; 100196"];
2457 [label="FullWidth 100197"];
2458 [label="this.AdjustFlagsAndWidth(leading); 100198"];
2459 [label="return '/='; 100199"];
2460 [label="FullWidth = this.Text.Length; 100200"];
2461 [label="FullWidth 100201"];
2462 [label="this.AdjustFlagsAndWidth(trailing); 100202"];
2463 [label="return '/='; 100203"];
2464 [label="FullWidth = this.Text.Length; 100204"];
2465 [label="FullWidth 100205"];
2466 [label="this.AdjustFlagsAndWidth(trailing); 100206"];
2467 [label="return '*='; 100207"];
2468 [label="FullWidth = this.Text.Length; 100208"];
2469 [label="FullWidth 100209"];
2470 [label="return '*='; 100210"];
2471 [label="FullWidth = this.Text.Length; 100211"];
2472 [label="FullWidth 100212"];
2473 [label="this.AdjustFlagsAndWidth(leading); 100213"];
2474 [label="return '*='; 100214"];
2475 [label="FullWidth = this.Text.Length; 100215"];
2476 [label="FullWidth 100216"];
2477 [label="this.AdjustFlagsAndWidth(trailing); 100217"];
2478 [label="return '*='; 100218"];
2479 [label="FullWidth = this.Text.Length; 100219"];
2480 [label="FullWidth 100220"];
2481 [label="this.AdjustFlagsAndWidth(trailing); 100221"];
2482 [label="return '|='; 100222"];
2483 [label="FullWidth = this.Text.Length; 100223"];
2484 [label="FullWidth 100224"];
2485 [label="return '|='; 100225"];
2486 [label="FullWidth = this.Text.Length; 100226"];
2487 [label="FullWidth 100227"];
2488 [label="this.AdjustFlagsAndWidth(leading); 100228"];
2489 [label="return '|='; 100229"];
2490 [label="FullWidth = this.Text.Length; 100230"];
2491 [label="FullWidth 100231"];
2492 [label="this.AdjustFlagsAndWidth(trailing); 100232"];
2493 [label="return '|='; 100233"];
2494 [label="FullWidth = this.Text.Length; 100234"];
2495 [label="FullWidth 100235"];
2496 [label="this.AdjustFlagsAndWidth(trailing); 100236"];
2497 [label="return '&='; 100237"];
2498 [label="FullWidth = this.Text.Length; 100238"];
2499 [label="FullWidth 100239"];
2500 [label="return '&='; 100240"];
2501 [label="FullWidth = this.Text.Length; 100241"];
2502 [label="FullWidth 100242"];
2503 [label="this.AdjustFlagsAndWidth(leading); 100243"];
2504 [label="return '&='; 100244"];
2505 [label="FullWidth = this.Text.Length; 100245"];
2506 [label="FullWidth 100246"];
2507 [label="this.AdjustFlagsAndWidth(trailing); 100247"];
2508 [label="return '&='; 100248"];
2509 [label="FullWidth = this.Text.Length; 100249"];
2510 [label="FullWidth 100250"];
2511 [label="this.AdjustFlagsAndWidth(trailing); 100251"];
2512 [label="return '+='; 100252"];
2513 [label="FullWidth = this.Text.Length; 100253"];
2514 [label="FullWidth 100254"];
2515 [label="return '+='; 100255"];
2516 [label="FullWidth = this.Text.Length; 100256"];
2517 [label="FullWidth 100257"];
2518 [label="this.AdjustFlagsAndWidth(leading); 100258"];
2519 [label="return '+='; 100259"];
2520 [label="FullWidth = this.Text.Length; 100260"];
2521 [label="FullWidth 100261"];
2522 [label="this.AdjustFlagsAndWidth(trailing); 100262"];
2523 [label="return '+='; 100263"];
2524 [label="FullWidth = this.Text.Length; 100264"];
2525 [label="FullWidth 100265"];
2526 [label="this.AdjustFlagsAndWidth(trailing); 100266"];
2527 [label="return '-='; 100267"];
2528 [label="FullWidth = this.Text.Length; 100268"];
2529 [label="FullWidth 100269"];
2530 [label="return '-='; 100270"];
2531 [label="FullWidth = this.Text.Length; 100271"];
2532 [label="FullWidth 100272"];
2533 [label="this.AdjustFlagsAndWidth(leading); 100273"];
2534 [label="return '-='; 100274"];
2535 [label="FullWidth = this.Text.Length; 100275"];
2536 [label="FullWidth 100276"];
2537 [label="this.AdjustFlagsAndWidth(trailing); 100277"];
2538 [label="return '-='; 100278"];
2539 [label="FullWidth = this.Text.Length; 100279"];
2540 [label="FullWidth 100280"];
2541 [label="this.AdjustFlagsAndWidth(trailing); 100281"];
2542 [label="return '^='; 100282"];
2543 [label="FullWidth = this.Text.Length; 100283"];
2544 [label="FullWidth 100284"];
2545 [label="return '^='; 100285"];
2546 [label="FullWidth = this.Text.Length; 100286"];
2547 [label="FullWidth 100287"];
2548 [label="this.AdjustFlagsAndWidth(leading); 100288"];
2549 [label="return '^='; 100289"];
2550 [label="FullWidth = this.Text.Length; 100290"];
2551 [label="FullWidth 100291"];
2552 [label="this.AdjustFlagsAndWidth(trailing); 100292"];
2553 [label="return '^='; 100293"];
2554 [label="FullWidth = this.Text.Length; 100294"];
2555 [label="FullWidth 100295"];
2556 [label="this.AdjustFlagsAndWidth(trailing); 100296"];
2557 [label="return '%='; 100297"];
2558 [label="FullWidth = this.Text.Length; 100298"];
2559 [label="FullWidth 100299"];
2560 [label="return '%='; 100300"];
2561 [label="FullWidth = this.Text.Length; 100301"];
2562 [label="FullWidth 100302"];
2563 [label="this.AdjustFlagsAndWidth(leading); 100303"];
2564 [label="return '%='; 100304"];
2565 [label="FullWidth = this.Text.Length; 100305"];
2566 [label="FullWidth 100306"];
2567 [label="this.AdjustFlagsAndWidth(trailing); 100307"];
2568 [label="return '%='; 100308"];
2569 [label="FullWidth = this.Text.Length; 100309"];
2570 [label="FullWidth 100310"];
2571 [label="this.AdjustFlagsAndWidth(trailing); 100311"];
2572 [label="return '??='; 100312"];
2573 [label="FullWidth = this.Text.Length; 100313"];
2574 [label="FullWidth 100314"];
2575 [label="return '??='; 100315"];
2576 [label="FullWidth = this.Text.Length; 100316"];
2577 [label="FullWidth 100317"];
2578 [label="this.AdjustFlagsAndWidth(leading); 100318"];
2579 [label="return '??='; 100319"];
2580 [label="FullWidth = this.Text.Length; 100320"];
2581 [label="FullWidth 100321"];
2582 [label="this.AdjustFlagsAndWidth(trailing); 100322"];
2583 [label="return '??='; 100323"];
2584 [label="FullWidth = this.Text.Length; 100324"];
2585 [label="FullWidth 100325"];
2586 [label="this.AdjustFlagsAndWidth(trailing); 100326"];
2587 [label="return 'bool'; 100327"];
2588 [label="FullWidth = this.Text.Length; 100328"];
2589 [label="FullWidth 100329"];
2590 [label="return 'bool'; 100330"];
2591 [label="FullWidth = this.Text.Length; 100331"];
2592 [label="FullWidth 100332"];
2593 [label="this.AdjustFlagsAndWidth(leading); 100333"];
2594 [label="return 'bool'; 100334"];
2595 [label="FullWidth = this.Text.Length; 100335"];
2596 [label="FullWidth 100336"];
2597 [label="this.AdjustFlagsAndWidth(trailing); 100337"];
2598 [label="return 'bool'; 100338"];
2599 [label="FullWidth = this.Text.Length; 100339"];
2600 [label="FullWidth 100340"];
2601 [label="this.AdjustFlagsAndWidth(trailing); 100341"];
2602 [label="return 'byte'; 100342"];
2603 [label="FullWidth = this.Text.Length; 100343"];
2604 [label="FullWidth 100344"];
2605 [label="return 'byte'; 100345"];
2606 [label="FullWidth = this.Text.Length; 100346"];
2607 [label="FullWidth 100347"];
2608 [label="this.AdjustFlagsAndWidth(leading); 100348"];
2609 [label="return 'byte'; 100349"];
2610 [label="FullWidth = this.Text.Length; 100350"];
2611 [label="FullWidth 100351"];
2612 [label="this.AdjustFlagsAndWidth(trailing); 100352"];
2613 [label="return 'byte'; 100353"];
2614 [label="FullWidth = this.Text.Length; 100354"];
2615 [label="FullWidth 100355"];
2616 [label="this.AdjustFlagsAndWidth(trailing); 100356"];
2617 [label="return 'sbyte'; 100357"];
2618 [label="FullWidth = this.Text.Length; 100358"];
2619 [label="FullWidth 100359"];
2620 [label="return 'sbyte'; 100360"];
2621 [label="FullWidth = this.Text.Length; 100361"];
2622 [label="FullWidth 100362"];
2623 [label="this.AdjustFlagsAndWidth(leading); 100363"];
2624 [label="return 'sbyte'; 100364"];
2625 [label="FullWidth = this.Text.Length; 100365"];
2626 [label="FullWidth 100366"];
2627 [label="this.AdjustFlagsAndWidth(trailing); 100367"];
2628 [label="return 'sbyte'; 100368"];
2629 [label="FullWidth = this.Text.Length; 100369"];
2630 [label="FullWidth 100370"];
2631 [label="this.AdjustFlagsAndWidth(trailing); 100371"];
2632 [label="return 'short'; 100372"];
2633 [label="FullWidth = this.Text.Length; 100373"];
2634 [label="FullWidth 100374"];
2635 [label="return 'short'; 100375"];
2636 [label="FullWidth = this.Text.Length; 100376"];
2637 [label="FullWidth 100377"];
2638 [label="this.AdjustFlagsAndWidth(leading); 100378"];
2639 [label="return 'short'; 100379"];
2640 [label="FullWidth = this.Text.Length; 100380"];
2641 [label="FullWidth 100381"];
2642 [label="this.AdjustFlagsAndWidth(trailing); 100382"];
2643 [label="return 'short'; 100383"];
2644 [label="FullWidth = this.Text.Length; 100384"];
2645 [label="FullWidth 100385"];
2646 [label="this.AdjustFlagsAndWidth(trailing); 100386"];
2647 [label="return 'ushort'; 100387"];
2648 [label="FullWidth = this.Text.Length; 100388"];
2649 [label="FullWidth 100389"];
2650 [label="return 'ushort'; 100390"];
2651 [label="FullWidth = this.Text.Length; 100391"];
2652 [label="FullWidth 100392"];
2653 [label="this.AdjustFlagsAndWidth(leading); 100393"];
2654 [label="return 'ushort'; 100394"];
2655 [label="FullWidth = this.Text.Length; 100395"];
2656 [label="FullWidth 100396"];
2657 [label="this.AdjustFlagsAndWidth(trailing); 100397"];
2658 [label="return 'ushort'; 100398"];
2659 [label="FullWidth = this.Text.Length; 100399"];
2660 [label="FullWidth 100400"];
2661 [label="this.AdjustFlagsAndWidth(trailing); 100401"];
2662 [label="return 'int'; 100402"];
2663 [label="FullWidth = this.Text.Length; 100403"];
2664 [label="FullWidth 100404"];
2665 [label="return 'int'; 100405"];
2666 [label="FullWidth = this.Text.Length; 100406"];
2667 [label="FullWidth 100407"];
2668 [label="this.AdjustFlagsAndWidth(leading); 100408"];
2669 [label="return 'int'; 100409"];
2670 [label="FullWidth = this.Text.Length; 100410"];
2671 [label="FullWidth 100411"];
2672 [label="this.AdjustFlagsAndWidth(trailing); 100412"];
2673 [label="return 'int'; 100413"];
2674 [label="FullWidth = this.Text.Length; 100414"];
2675 [label="FullWidth 100415"];
2676 [label="this.AdjustFlagsAndWidth(trailing); 100416"];
2677 [label="return 'uint'; 100417"];
2678 [label="FullWidth = this.Text.Length; 100418"];
2679 [label="FullWidth 100419"];
2680 [label="return 'uint'; 100420"];
2681 [label="FullWidth = this.Text.Length; 100421"];
2682 [label="FullWidth 100422"];
2683 [label="this.AdjustFlagsAndWidth(leading); 100423"];
2684 [label="return 'uint'; 100424"];
2685 [label="FullWidth = this.Text.Length; 100425"];
2686 [label="FullWidth 100426"];
2687 [label="this.AdjustFlagsAndWidth(trailing); 100427"];
2688 [label="return 'uint'; 100428"];
2689 [label="FullWidth = this.Text.Length; 100429"];
2690 [label="FullWidth 100430"];
2691 [label="this.AdjustFlagsAndWidth(trailing); 100431"];
2692 [label="return 'long'; 100432"];
2693 [label="FullWidth = this.Text.Length; 100433"];
2694 [label="FullWidth 100434"];
2695 [label="return 'long'; 100435"];
2696 [label="FullWidth = this.Text.Length; 100436"];
2697 [label="FullWidth 100437"];
2698 [label="this.AdjustFlagsAndWidth(leading); 100438"];
2699 [label="return 'long'; 100439"];
2700 [label="FullWidth = this.Text.Length; 100440"];
2701 [label="FullWidth 100441"];
2702 [label="this.AdjustFlagsAndWidth(trailing); 100442"];
2703 [label="return 'long'; 100443"];
2704 [label="FullWidth = this.Text.Length; 100444"];
2705 [label="FullWidth 100445"];
2706 [label="this.AdjustFlagsAndWidth(trailing); 100446"];
2707 [label="return 'ulong'; 100447"];
2708 [label="FullWidth = this.Text.Length; 100448"];
2709 [label="FullWidth 100449"];
2710 [label="return 'ulong'; 100450"];
2711 [label="FullWidth = this.Text.Length; 100451"];
2712 [label="FullWidth 100452"];
2713 [label="this.AdjustFlagsAndWidth(leading); 100453"];
2714 [label="return 'ulong'; 100454"];
2715 [label="FullWidth = this.Text.Length; 100455"];
2716 [label="FullWidth 100456"];
2717 [label="this.AdjustFlagsAndWidth(trailing); 100457"];
2718 [label="return 'ulong'; 100458"];
2719 [label="FullWidth = this.Text.Length; 100459"];
2720 [label="FullWidth 100460"];
2721 [label="this.AdjustFlagsAndWidth(trailing); 100461"];
2722 [label="return 'double'; 100462"];
2723 [label="FullWidth = this.Text.Length; 100463"];
2724 [label="FullWidth 100464"];
2725 [label="return 'double'; 100465"];
2726 [label="FullWidth = this.Text.Length; 100466"];
2727 [label="FullWidth 100467"];
2728 [label="this.AdjustFlagsAndWidth(leading); 100468"];
2729 [label="return 'double'; 100469"];
2730 [label="FullWidth = this.Text.Length; 100470"];
2731 [label="FullWidth 100471"];
2732 [label="this.AdjustFlagsAndWidth(trailing); 100472"];
2733 [label="return 'double'; 100473"];
2734 [label="FullWidth = this.Text.Length; 100474"];
2735 [label="FullWidth 100475"];
2736 [label="this.AdjustFlagsAndWidth(trailing); 100476"];
2737 [label="return 'float'; 100477"];
2738 [label="FullWidth = this.Text.Length; 100478"];
2739 [label="FullWidth 100479"];
2740 [label="return 'float'; 100480"];
2741 [label="FullWidth = this.Text.Length; 100481"];
2742 [label="FullWidth 100482"];
2743 [label="this.AdjustFlagsAndWidth(leading); 100483"];
2744 [label="return 'float'; 100484"];
2745 [label="FullWidth = this.Text.Length; 100485"];
2746 [label="FullWidth 100486"];
2747 [label="this.AdjustFlagsAndWidth(trailing); 100487"];
2748 [label="return 'float'; 100488"];
2749 [label="FullWidth = this.Text.Length; 100489"];
2750 [label="FullWidth 100490"];
2751 [label="this.AdjustFlagsAndWidth(trailing); 100491"];
2752 [label="return 'decimal'; 100492"];
2753 [label="FullWidth = this.Text.Length; 100493"];
2754 [label="FullWidth 100494"];
2755 [label="return 'decimal'; 100495"];
2756 [label="FullWidth = this.Text.Length; 100496"];
2757 [label="FullWidth 100497"];
2758 [label="this.AdjustFlagsAndWidth(leading); 100498"];
2759 [label="return 'decimal'; 100499"];
2760 [label="FullWidth = this.Text.Length; 100500"];
2761 [label="FullWidth 100501"];
2762 [label="this.AdjustFlagsAndWidth(trailing); 100502"];
2763 [label="return 'decimal'; 100503"];
2764 [label="FullWidth = this.Text.Length; 100504"];
2765 [label="FullWidth 100505"];
2766 [label="this.AdjustFlagsAndWidth(trailing); 100506"];
2767 [label="return 'string'; 100507"];
2768 [label="FullWidth = this.Text.Length; 100508"];
2769 [label="FullWidth 100509"];
2770 [label="return 'string'; 100510"];
2771 [label="FullWidth = this.Text.Length; 100511"];
2772 [label="FullWidth 100512"];
2773 [label="this.AdjustFlagsAndWidth(leading); 100513"];
2774 [label="return 'string'; 100514"];
2775 [label="FullWidth = this.Text.Length; 100515"];
2776 [label="FullWidth 100516"];
2777 [label="this.AdjustFlagsAndWidth(trailing); 100517"];
2778 [label="return 'string'; 100518"];
2779 [label="FullWidth = this.Text.Length; 100519"];
2780 [label="FullWidth 100520"];
2781 [label="this.AdjustFlagsAndWidth(trailing); 100521"];
2782 [label="return 'char'; 100522"];
2783 [label="FullWidth = this.Text.Length; 100523"];
2784 [label="FullWidth 100524"];
2785 [label="return 'char'; 100525"];
2786 [label="FullWidth = this.Text.Length; 100526"];
2787 [label="FullWidth 100527"];
2788 [label="this.AdjustFlagsAndWidth(leading); 100528"];
2789 [label="return 'char'; 100529"];
2790 [label="FullWidth = this.Text.Length; 100530"];
2791 [label="FullWidth 100531"];
2792 [label="this.AdjustFlagsAndWidth(trailing); 100532"];
2793 [label="return 'char'; 100533"];
2794 [label="FullWidth = this.Text.Length; 100534"];
2795 [label="FullWidth 100535"];
2796 [label="this.AdjustFlagsAndWidth(trailing); 100536"];
2797 [label="return 'void'; 100537"];
2798 [label="FullWidth = this.Text.Length; 100538"];
2799 [label="FullWidth 100539"];
2800 [label="return 'void'; 100540"];
2801 [label="FullWidth = this.Text.Length; 100541"];
2802 [label="FullWidth 100542"];
2803 [label="this.AdjustFlagsAndWidth(leading); 100543"];
2804 [label="return 'void'; 100544"];
2805 [label="FullWidth = this.Text.Length; 100545"];
2806 [label="FullWidth 100546"];
2807 [label="this.AdjustFlagsAndWidth(trailing); 100547"];
2808 [label="return 'void'; 100548"];
2809 [label="FullWidth = this.Text.Length; 100549"];
2810 [label="FullWidth 100550"];
2811 [label="this.AdjustFlagsAndWidth(trailing); 100551"];
2812 [label="return 'object'; 100552"];
2813 [label="FullWidth = this.Text.Length; 100553"];
2814 [label="FullWidth 100554"];
2815 [label="return 'object'; 100555"];
2816 [label="FullWidth = this.Text.Length; 100556"];
2817 [label="FullWidth 100557"];
2818 [label="this.AdjustFlagsAndWidth(leading); 100558"];
2819 [label="return 'object'; 100559"];
2820 [label="FullWidth = this.Text.Length; 100560"];
2821 [label="FullWidth 100561"];
2822 [label="this.AdjustFlagsAndWidth(trailing); 100562"];
2823 [label="return 'object'; 100563"];
2824 [label="FullWidth = this.Text.Length; 100564"];
2825 [label="FullWidth 100565"];
2826 [label="this.AdjustFlagsAndWidth(trailing); 100566"];
2827 [label="return 'typeof'; 100567"];
2828 [label="FullWidth = this.Text.Length; 100568"];
2829 [label="FullWidth 100569"];
2830 [label="return 'typeof'; 100570"];
2831 [label="FullWidth = this.Text.Length; 100571"];
2832 [label="FullWidth 100572"];
2833 [label="this.AdjustFlagsAndWidth(leading); 100573"];
2834 [label="return 'typeof'; 100574"];
2835 [label="FullWidth = this.Text.Length; 100575"];
2836 [label="FullWidth 100576"];
2837 [label="this.AdjustFlagsAndWidth(trailing); 100577"];
2838 [label="return 'typeof'; 100578"];
2839 [label="FullWidth = this.Text.Length; 100579"];
2840 [label="FullWidth 100580"];
2841 [label="this.AdjustFlagsAndWidth(trailing); 100581"];
2842 [label="return 'sizeof'; 100582"];
2843 [label="FullWidth = this.Text.Length; 100583"];
2844 [label="FullWidth 100584"];
2845 [label="return 'sizeof'; 100585"];
2846 [label="FullWidth = this.Text.Length; 100586"];
2847 [label="FullWidth 100587"];
2848 [label="this.AdjustFlagsAndWidth(leading); 100588"];
2849 [label="return 'sizeof'; 100589"];
2850 [label="FullWidth = this.Text.Length; 100590"];
2851 [label="FullWidth 100591"];
2852 [label="this.AdjustFlagsAndWidth(trailing); 100592"];
2853 [label="return 'sizeof'; 100593"];
2854 [label="FullWidth = this.Text.Length; 100594"];
2855 [label="FullWidth 100595"];
2856 [label="this.AdjustFlagsAndWidth(trailing); 100596"];
2857 [label="return 'null'; 100597"];
2858 [label="FullWidth = this.Text.Length; 100598"];
2859 [label="FullWidth 100599"];
2860 [label="return 'null'; 100600"];
2861 [label="FullWidth = this.Text.Length; 100601"];
2862 [label="FullWidth 100602"];
2863 [label="this.AdjustFlagsAndWidth(leading); 100603"];
2864 [label="return 'null'; 100604"];
2865 [label="FullWidth = this.Text.Length; 100605"];
2866 [label="FullWidth 100606"];
2867 [label="this.AdjustFlagsAndWidth(trailing); 100607"];
2868 [label="return 'null'; 100608"];
2869 [label="FullWidth = this.Text.Length; 100609"];
2870 [label="FullWidth 100610"];
2871 [label="this.AdjustFlagsAndWidth(trailing); 100611"];
2872 [label="return 'true'; 100612"];
2873 [label="FullWidth = this.Text.Length; 100613"];
2874 [label="FullWidth 100614"];
2875 [label="return 'true'; 100615"];
2876 [label="FullWidth = this.Text.Length; 100616"];
2877 [label="FullWidth 100617"];
2878 [label="this.AdjustFlagsAndWidth(leading); 100618"];
2879 [label="return 'true'; 100619"];
2880 [label="FullWidth = this.Text.Length; 100620"];
2881 [label="FullWidth 100621"];
2882 [label="this.AdjustFlagsAndWidth(trailing); 100622"];
2883 [label="return 'true'; 100623"];
2884 [label="FullWidth = this.Text.Length; 100624"];
2885 [label="FullWidth 100625"];
2886 [label="this.AdjustFlagsAndWidth(trailing); 100626"];
2887 [label="return 'false'; 100627"];
2888 [label="FullWidth = this.Text.Length; 100628"];
2889 [label="FullWidth 100629"];
2890 [label="return 'false'; 100630"];
2891 [label="FullWidth = this.Text.Length; 100631"];
2892 [label="FullWidth 100632"];
2893 [label="this.AdjustFlagsAndWidth(leading); 100633"];
2894 [label="return 'false'; 100634"];
2895 [label="FullWidth = this.Text.Length; 100635"];
2896 [label="FullWidth 100636"];
2897 [label="this.AdjustFlagsAndWidth(trailing); 100637"];
2898 [label="return 'false'; 100638"];
2899 [label="FullWidth = this.Text.Length; 100639"];
2900 [label="FullWidth 100640"];
2901 [label="this.AdjustFlagsAndWidth(trailing); 100641"];
2902 [label="return 'if'; 100642"];
2903 [label="FullWidth = this.Text.Length; 100643"];
2904 [label="FullWidth 100644"];
2905 [label="return 'if'; 100645"];
2906 [label="FullWidth = this.Text.Length; 100646"];
2907 [label="FullWidth 100647"];
2908 [label="this.AdjustFlagsAndWidth(leading); 100648"];
2909 [label="return 'if'; 100649"];
2910 [label="FullWidth = this.Text.Length; 100650"];
2911 [label="FullWidth 100651"];
2912 [label="this.AdjustFlagsAndWidth(trailing); 100652"];
2913 [label="return 'if'; 100653"];
2914 [label="FullWidth = this.Text.Length; 100654"];
2915 [label="FullWidth 100655"];
2916 [label="this.AdjustFlagsAndWidth(trailing); 100656"];
2917 [label="return 'else'; 100657"];
2918 [label="FullWidth = this.Text.Length; 100658"];
2919 [label="FullWidth 100659"];
2920 [label="return 'else'; 100660"];
2921 [label="FullWidth = this.Text.Length; 100661"];
2922 [label="FullWidth 100662"];
2923 [label="this.AdjustFlagsAndWidth(leading); 100663"];
2924 [label="return 'else'; 100664"];
2925 [label="FullWidth = this.Text.Length; 100665"];
2926 [label="FullWidth 100666"];
2927 [label="this.AdjustFlagsAndWidth(trailing); 100667"];
2928 [label="return 'else'; 100668"];
2929 [label="FullWidth = this.Text.Length; 100669"];
2930 [label="FullWidth 100670"];
2931 [label="this.AdjustFlagsAndWidth(trailing); 100671"];
2932 [label="return 'while'; 100672"];
2933 [label="FullWidth = this.Text.Length; 100673"];
2934 [label="FullWidth 100674"];
2935 [label="return 'while'; 100675"];
2936 [label="FullWidth = this.Text.Length; 100676"];
2937 [label="FullWidth 100677"];
2938 [label="this.AdjustFlagsAndWidth(leading); 100678"];
2939 [label="return 'while'; 100679"];
2940 [label="FullWidth = this.Text.Length; 100680"];
2941 [label="FullWidth 100681"];
2942 [label="this.AdjustFlagsAndWidth(trailing); 100682"];
2943 [label="return 'while'; 100683"];
2944 [label="FullWidth = this.Text.Length; 100684"];
2945 [label="FullWidth 100685"];
2946 [label="this.AdjustFlagsAndWidth(trailing); 100686"];
2947 [label="return 'for'; 100687"];
2948 [label="FullWidth = this.Text.Length; 100688"];
2949 [label="FullWidth 100689"];
2950 [label="return 'for'; 100690"];
2951 [label="FullWidth = this.Text.Length; 100691"];
2952 [label="FullWidth 100692"];
2953 [label="this.AdjustFlagsAndWidth(leading); 100693"];
2954 [label="return 'for'; 100694"];
2955 [label="FullWidth = this.Text.Length; 100695"];
2956 [label="FullWidth 100696"];
2957 [label="this.AdjustFlagsAndWidth(trailing); 100697"];
2958 [label="return 'for'; 100698"];
2959 [label="FullWidth = this.Text.Length; 100699"];
2960 [label="FullWidth 100700"];
2961 [label="this.AdjustFlagsAndWidth(trailing); 100701"];
2962 [label="return 'foreach'; 100702"];
2963 [label="FullWidth = this.Text.Length; 100703"];
2964 [label="FullWidth 100704"];
2965 [label="return 'foreach'; 100705"];
2966 [label="FullWidth = this.Text.Length; 100706"];
2967 [label="FullWidth 100707"];
2968 [label="this.AdjustFlagsAndWidth(leading); 100708"];
2969 [label="return 'foreach'; 100709"];
2970 [label="FullWidth = this.Text.Length; 100710"];
2971 [label="FullWidth 100711"];
2972 [label="this.AdjustFlagsAndWidth(trailing); 100712"];
2973 [label="return 'foreach'; 100713"];
2974 [label="FullWidth = this.Text.Length; 100714"];
2975 [label="FullWidth 100715"];
2976 [label="this.AdjustFlagsAndWidth(trailing); 100716"];
2977 [label="return 'do'; 100717"];
2978 [label="FullWidth = this.Text.Length; 100718"];
2979 [label="FullWidth 100719"];
2980 [label="return 'do'; 100720"];
2981 [label="FullWidth = this.Text.Length; 100721"];
2982 [label="FullWidth 100722"];
2983 [label="this.AdjustFlagsAndWidth(leading); 100723"];
2984 [label="return 'do'; 100724"];
2985 [label="FullWidth = this.Text.Length; 100725"];
2986 [label="FullWidth 100726"];
2987 [label="this.AdjustFlagsAndWidth(trailing); 100727"];
2988 [label="return 'do'; 100728"];
2989 [label="FullWidth = this.Text.Length; 100729"];
2990 [label="FullWidth 100730"];
2991 [label="this.AdjustFlagsAndWidth(trailing); 100731"];
2992 [label="return 'switch'; 100732"];
2993 [label="FullWidth = this.Text.Length; 100733"];
2994 [label="FullWidth 100734"];
2995 [label="return 'switch'; 100735"];
2996 [label="FullWidth = this.Text.Length; 100736"];
2997 [label="FullWidth 100737"];
2998 [label="this.AdjustFlagsAndWidth(leading); 100738"];
2999 [label="return 'switch'; 100739"];
3000 [label="FullWidth = this.Text.Length; 100740"];
3001 [label="FullWidth 100741"];
3002 [label="this.AdjustFlagsAndWidth(trailing); 100742"];
3003 [label="return 'switch'; 100743"];
3004 [label="FullWidth = this.Text.Length; 100744"];
3005 [label="FullWidth 100745"];
3006 [label="this.AdjustFlagsAndWidth(trailing); 100746"];
3007 [label="return 'case'; 100747"];
3008 [label="FullWidth = this.Text.Length; 100748"];
3009 [label="FullWidth 100749"];
3010 [label="return 'case'; 100750"];
3011 [label="FullWidth = this.Text.Length; 100751"];
3012 [label="FullWidth 100752"];
3013 [label="this.AdjustFlagsAndWidth(leading); 100753"];
3014 [label="return 'case'; 100754"];
3015 [label="FullWidth = this.Text.Length; 100755"];
3016 [label="FullWidth 100756"];
3017 [label="this.AdjustFlagsAndWidth(trailing); 100757"];
3018 [label="return 'case'; 100758"];
3019 [label="FullWidth = this.Text.Length; 100759"];
3020 [label="FullWidth 100760"];
3021 [label="this.AdjustFlagsAndWidth(trailing); 100761"];
3022 [label="return 'default'; 100762"];
3023 [label="FullWidth = this.Text.Length; 100763"];
3024 [label="FullWidth 100764"];
3025 [label="return 'default'; 100765"];
3026 [label="FullWidth = this.Text.Length; 100766"];
3027 [label="FullWidth 100767"];
3028 [label="this.AdjustFlagsAndWidth(leading); 100768"];
3029 [label="return 'default'; 100769"];
3030 [label="FullWidth = this.Text.Length; 100770"];
3031 [label="FullWidth 100771"];
3032 [label="this.AdjustFlagsAndWidth(trailing); 100772"];
3033 [label="return 'default'; 100773"];
3034 [label="FullWidth = this.Text.Length; 100774"];
3035 [label="FullWidth 100775"];
3036 [label="this.AdjustFlagsAndWidth(trailing); 100776"];
3037 [label="return 'try'; 100777"];
3038 [label="FullWidth = this.Text.Length; 100778"];
3039 [label="FullWidth 100779"];
3040 [label="return 'try'; 100780"];
3041 [label="FullWidth = this.Text.Length; 100781"];
3042 [label="FullWidth 100782"];
3043 [label="this.AdjustFlagsAndWidth(leading); 100783"];
3044 [label="return 'try'; 100784"];
3045 [label="FullWidth = this.Text.Length; 100785"];
3046 [label="FullWidth 100786"];
3047 [label="this.AdjustFlagsAndWidth(trailing); 100787"];
3048 [label="return 'try'; 100788"];
3049 [label="FullWidth = this.Text.Length; 100789"];
3050 [label="FullWidth 100790"];
3051 [label="this.AdjustFlagsAndWidth(trailing); 100791"];
3052 [label="return 'catch'; 100792"];
3053 [label="FullWidth = this.Text.Length; 100793"];
3054 [label="FullWidth 100794"];
3055 [label="return 'catch'; 100795"];
3056 [label="FullWidth = this.Text.Length; 100796"];
3057 [label="FullWidth 100797"];
3058 [label="this.AdjustFlagsAndWidth(leading); 100798"];
3059 [label="return 'catch'; 100799"];
3060 [label="FullWidth = this.Text.Length; 100800"];
3061 [label="FullWidth 100801"];
3062 [label="this.AdjustFlagsAndWidth(trailing); 100802"];
3063 [label="return 'catch'; 100803"];
3064 [label="FullWidth = this.Text.Length; 100804"];
3065 [label="FullWidth 100805"];
3066 [label="this.AdjustFlagsAndWidth(trailing); 100806"];
3067 [label="return 'finally'; 100807"];
3068 [label="FullWidth = this.Text.Length; 100808"];
3069 [label="FullWidth 100809"];
3070 [label="return 'finally'; 100810"];
3071 [label="FullWidth = this.Text.Length; 100811"];
3072 [label="FullWidth 100812"];
3073 [label="this.AdjustFlagsAndWidth(leading); 100813"];
3074 [label="return 'finally'; 100814"];
3075 [label="FullWidth = this.Text.Length; 100815"];
3076 [label="FullWidth 100816"];
3077 [label="this.AdjustFlagsAndWidth(trailing); 100817"];
3078 [label="return 'finally'; 100818"];
3079 [label="FullWidth = this.Text.Length; 100819"];
3080 [label="FullWidth 100820"];
3081 [label="this.AdjustFlagsAndWidth(trailing); 100821"];
3082 [label="return 'lock'; 100822"];
3083 [label="FullWidth = this.Text.Length; 100823"];
3084 [label="FullWidth 100824"];
3085 [label="return 'lock'; 100825"];
3086 [label="FullWidth = this.Text.Length; 100826"];
3087 [label="FullWidth 100827"];
3088 [label="this.AdjustFlagsAndWidth(leading); 100828"];
3089 [label="return 'lock'; 100829"];
3090 [label="FullWidth = this.Text.Length; 100830"];
3091 [label="FullWidth 100831"];
3092 [label="this.AdjustFlagsAndWidth(trailing); 100832"];
3093 [label="return 'lock'; 100833"];
3094 [label="FullWidth = this.Text.Length; 100834"];
3095 [label="FullWidth 100835"];
3096 [label="this.AdjustFlagsAndWidth(trailing); 100836"];
3097 [label="return 'goto'; 100837"];
3098 [label="FullWidth = this.Text.Length; 100838"];
3099 [label="FullWidth 100839"];
3100 [label="return 'goto'; 100840"];
3101 [label="FullWidth = this.Text.Length; 100841"];
3102 [label="FullWidth 100842"];
3103 [label="this.AdjustFlagsAndWidth(leading); 100843"];
3104 [label="return 'goto'; 100844"];
3105 [label="FullWidth = this.Text.Length; 100845"];
3106 [label="FullWidth 100846"];
3107 [label="this.AdjustFlagsAndWidth(trailing); 100847"];
3108 [label="return 'goto'; 100848"];
3109 [label="FullWidth = this.Text.Length; 100849"];
3110 [label="FullWidth 100850"];
3111 [label="this.AdjustFlagsAndWidth(trailing); 100851"];
3112 [label="return 'break'; 100852"];
3113 [label="FullWidth = this.Text.Length; 100853"];
3114 [label="FullWidth 100854"];
3115 [label="return 'break'; 100855"];
3116 [label="FullWidth = this.Text.Length; 100856"];
3117 [label="FullWidth 100857"];
3118 [label="this.AdjustFlagsAndWidth(leading); 100858"];
3119 [label="return 'break'; 100859"];
3120 [label="FullWidth = this.Text.Length; 100860"];
3121 [label="FullWidth 100861"];
3122 [label="this.AdjustFlagsAndWidth(trailing); 100862"];
3123 [label="return 'break'; 100863"];
3124 [label="FullWidth = this.Text.Length; 100864"];
3125 [label="FullWidth 100865"];
3126 [label="this.AdjustFlagsAndWidth(trailing); 100866"];
3127 [label="return 'continue'; 100867"];
3128 [label="FullWidth = this.Text.Length; 100868"];
3129 [label="FullWidth 100869"];
3130 [label="return 'continue'; 100870"];
3131 [label="FullWidth = this.Text.Length; 100871"];
3132 [label="FullWidth 100872"];
3133 [label="this.AdjustFlagsAndWidth(leading); 100873"];
3134 [label="return 'continue'; 100874"];
3135 [label="FullWidth = this.Text.Length; 100875"];
3136 [label="FullWidth 100876"];
3137 [label="this.AdjustFlagsAndWidth(trailing); 100877"];
3138 [label="return 'continue'; 100878"];
3139 [label="FullWidth = this.Text.Length; 100879"];
3140 [label="FullWidth 100880"];
3141 [label="this.AdjustFlagsAndWidth(trailing); 100881"];
3142 [label="return 'return'; 100882"];
3143 [label="FullWidth = this.Text.Length; 100883"];
3144 [label="FullWidth 100884"];
3145 [label="return 'return'; 100885"];
3146 [label="FullWidth = this.Text.Length; 100886"];
3147 [label="FullWidth 100887"];
3148 [label="this.AdjustFlagsAndWidth(leading); 100888"];
3149 [label="return 'return'; 100889"];
3150 [label="FullWidth = this.Text.Length; 100890"];
3151 [label="FullWidth 100891"];
3152 [label="this.AdjustFlagsAndWidth(trailing); 100892"];
3153 [label="return 'return'; 100893"];
3154 [label="FullWidth = this.Text.Length; 100894"];
3155 [label="FullWidth 100895"];
3156 [label="this.AdjustFlagsAndWidth(trailing); 100896"];
3157 [label="return 'throw'; 100897"];
3158 [label="FullWidth = this.Text.Length; 100898"];
3159 [label="FullWidth 100899"];
3160 [label="return 'throw'; 100900"];
3161 [label="FullWidth = this.Text.Length; 100901"];
3162 [label="FullWidth 100902"];
3163 [label="this.AdjustFlagsAndWidth(leading); 100903"];
3164 [label="return 'throw'; 100904"];
3165 [label="FullWidth = this.Text.Length; 100905"];
3166 [label="FullWidth 100906"];
3167 [label="this.AdjustFlagsAndWidth(trailing); 100907"];
3168 [label="return 'throw'; 100908"];
3169 [label="FullWidth = this.Text.Length; 100909"];
3170 [label="FullWidth 100910"];
3171 [label="this.AdjustFlagsAndWidth(trailing); 100911"];
3172 [label="return 'public'; 100912"];
3173 [label="FullWidth = this.Text.Length; 100913"];
3174 [label="FullWidth 100914"];
3175 [label="return 'public'; 100915"];
3176 [label="FullWidth = this.Text.Length; 100916"];
3177 [label="FullWidth 100917"];
3178 [label="this.AdjustFlagsAndWidth(leading); 100918"];
3179 [label="return 'public'; 100919"];
3180 [label="FullWidth = this.Text.Length; 100920"];
3181 [label="FullWidth 100921"];
3182 [label="this.AdjustFlagsAndWidth(trailing); 100922"];
3183 [label="return 'public'; 100923"];
3184 [label="FullWidth = this.Text.Length; 100924"];
3185 [label="FullWidth 100925"];
3186 [label="this.AdjustFlagsAndWidth(trailing); 100926"];
3187 [label="return 'private'; 100927"];
3188 [label="FullWidth = this.Text.Length; 100928"];
3189 [label="FullWidth 100929"];
3190 [label="return 'private'; 100930"];
3191 [label="FullWidth = this.Text.Length; 100931"];
3192 [label="FullWidth 100932"];
3193 [label="this.AdjustFlagsAndWidth(leading); 100933"];
3194 [label="return 'private'; 100934"];
3195 [label="FullWidth = this.Text.Length; 100935"];
3196 [label="FullWidth 100936"];
3197 [label="this.AdjustFlagsAndWidth(trailing); 100937"];
3198 [label="return 'private'; 100938"];
3199 [label="FullWidth = this.Text.Length; 100939"];
3200 [label="FullWidth 100940"];
3201 [label="this.AdjustFlagsAndWidth(trailing); 100941"];
3202 [label="return 'internal'; 100942"];
3203 [label="FullWidth = this.Text.Length; 100943"];
3204 [label="FullWidth 100944"];
3205 [label="return 'internal'; 100945"];
3206 [label="FullWidth = this.Text.Length; 100946"];
3207 [label="FullWidth 100947"];
3208 [label="this.AdjustFlagsAndWidth(leading); 100948"];
3209 [label="return 'internal'; 100949"];
3210 [label="FullWidth = this.Text.Length; 100950"];
3211 [label="FullWidth 100951"];
3212 [label="this.AdjustFlagsAndWidth(trailing); 100952"];
3213 [label="return 'internal'; 100953"];
3214 [label="FullWidth = this.Text.Length; 100954"];
3215 [label="FullWidth 100955"];
3216 [label="this.AdjustFlagsAndWidth(trailing); 100956"];
3217 [label="return 'protected'; 100957"];
3218 [label="FullWidth = this.Text.Length; 100958"];
3219 [label="FullWidth 100959"];
3220 [label="return 'protected'; 100960"];
3221 [label="FullWidth = this.Text.Length; 100961"];
3222 [label="FullWidth 100962"];
3223 [label="this.AdjustFlagsAndWidth(leading); 100963"];
3224 [label="return 'protected'; 100964"];
3225 [label="FullWidth = this.Text.Length; 100965"];
3226 [label="FullWidth 100966"];
3227 [label="this.AdjustFlagsAndWidth(trailing); 100967"];
3228 [label="return 'protected'; 100968"];
3229 [label="FullWidth = this.Text.Length; 100969"];
3230 [label="FullWidth 100970"];
3231 [label="this.AdjustFlagsAndWidth(trailing); 100971"];
3232 [label="return 'static'; 100972"];
3233 [label="FullWidth = this.Text.Length; 100973"];
3234 [label="FullWidth 100974"];
3235 [label="return 'static'; 100975"];
3236 [label="FullWidth = this.Text.Length; 100976"];
3237 [label="FullWidth 100977"];
3238 [label="this.AdjustFlagsAndWidth(leading); 100978"];
3239 [label="return 'static'; 100979"];
3240 [label="FullWidth = this.Text.Length; 100980"];
3241 [label="FullWidth 100981"];
3242 [label="this.AdjustFlagsAndWidth(trailing); 100982"];
3243 [label="return 'static'; 100983"];
3244 [label="FullWidth = this.Text.Length; 100984"];
3245 [label="FullWidth 100985"];
3246 [label="this.AdjustFlagsAndWidth(trailing); 100986"];
3247 [label="return 'readonly'; 100987"];
3248 [label="FullWidth = this.Text.Length; 100988"];
3249 [label="FullWidth 100989"];
3250 [label="return 'readonly'; 100990"];
3251 [label="FullWidth = this.Text.Length; 100991"];
3252 [label="FullWidth 100992"];
3253 [label="this.AdjustFlagsAndWidth(leading); 100993"];
3254 [label="return 'readonly'; 100994"];
3255 [label="FullWidth = this.Text.Length; 100995"];
3256 [label="FullWidth 100996"];
3257 [label="this.AdjustFlagsAndWidth(trailing); 100997"];
3258 [label="return 'readonly'; 100998"];
3259 [label="FullWidth = this.Text.Length; 100999"];
3260 [label="FullWidth 101000"];
3261 [label="this.AdjustFlagsAndWidth(trailing); 101001"];
3262 [label="return 'sealed'; 101002"];
3263 [label="FullWidth = this.Text.Length; 101003"];
3264 [label="FullWidth 101004"];
3265 [label="return 'sealed'; 101005"];
3266 [label="FullWidth = this.Text.Length; 101006"];
3267 [label="FullWidth 101007"];
3268 [label="this.AdjustFlagsAndWidth(leading); 101008"];
3269 [label="return 'sealed'; 101009"];
3270 [label="FullWidth = this.Text.Length; 101010"];
3271 [label="FullWidth 101011"];
3272 [label="this.AdjustFlagsAndWidth(trailing); 101012"];
3273 [label="return 'sealed'; 101013"];
3274 [label="FullWidth = this.Text.Length; 101014"];
3275 [label="FullWidth 101015"];
3276 [label="this.AdjustFlagsAndWidth(trailing); 101016"];
3277 [label="return 'const'; 101017"];
3278 [label="FullWidth = this.Text.Length; 101018"];
3279 [label="FullWidth 101019"];
3280 [label="return 'const'; 101020"];
3281 [label="FullWidth = this.Text.Length; 101021"];
3282 [label="FullWidth 101022"];
3283 [label="this.AdjustFlagsAndWidth(leading); 101023"];
3284 [label="return 'const'; 101024"];
3285 [label="FullWidth = this.Text.Length; 101025"];
3286 [label="FullWidth 101026"];
3287 [label="this.AdjustFlagsAndWidth(trailing); 101027"];
3288 [label="return 'const'; 101028"];
3289 [label="FullWidth = this.Text.Length; 101029"];
3290 [label="FullWidth 101030"];
3291 [label="this.AdjustFlagsAndWidth(trailing); 101031"];
3292 [label="return 'fixed'; 101032"];
3293 [label="FullWidth = this.Text.Length; 101033"];
3294 [label="FullWidth 101034"];
3295 [label="return 'fixed'; 101035"];
3296 [label="FullWidth = this.Text.Length; 101036"];
3297 [label="FullWidth 101037"];
3298 [label="this.AdjustFlagsAndWidth(leading); 101038"];
3299 [label="return 'fixed'; 101039"];
3300 [label="FullWidth = this.Text.Length; 101040"];
3301 [label="FullWidth 101041"];
3302 [label="this.AdjustFlagsAndWidth(trailing); 101042"];
3303 [label="return 'fixed'; 101043"];
3304 [label="FullWidth = this.Text.Length; 101044"];
3305 [label="FullWidth 101045"];
3306 [label="this.AdjustFlagsAndWidth(trailing); 101046"];
3307 [label="return 'stackalloc'; 101047"];
3308 [label="FullWidth = this.Text.Length; 101048"];
3309 [label="FullWidth 101049"];
3310 [label="return 'stackalloc'; 101050"];
3311 [label="FullWidth = this.Text.Length; 101051"];
3312 [label="FullWidth 101052"];
3313 [label="this.AdjustFlagsAndWidth(leading); 101053"];
3314 [label="return 'stackalloc'; 101054"];
3315 [label="FullWidth = this.Text.Length; 101055"];
3316 [label="FullWidth 101056"];
3317 [label="this.AdjustFlagsAndWidth(trailing); 101057"];
3318 [label="return 'stackalloc'; 101058"];
3319 [label="FullWidth = this.Text.Length; 101059"];
3320 [label="FullWidth 101060"];
3321 [label="this.AdjustFlagsAndWidth(trailing); 101061"];
3322 [label="return 'volatile'; 101062"];
3323 [label="FullWidth = this.Text.Length; 101063"];
3324 [label="FullWidth 101064"];
3325 [label="return 'volatile'; 101065"];
3326 [label="FullWidth = this.Text.Length; 101066"];
3327 [label="FullWidth 101067"];
3328 [label="this.AdjustFlagsAndWidth(leading); 101068"];
3329 [label="return 'volatile'; 101069"];
3330 [label="FullWidth = this.Text.Length; 101070"];
3331 [label="FullWidth 101071"];
3332 [label="this.AdjustFlagsAndWidth(trailing); 101072"];
3333 [label="return 'volatile'; 101073"];
3334 [label="FullWidth = this.Text.Length; 101074"];
3335 [label="FullWidth 101075"];
3336 [label="this.AdjustFlagsAndWidth(trailing); 101076"];
3337 [label="return 'new'; 101077"];
3338 [label="FullWidth = this.Text.Length; 101078"];
3339 [label="FullWidth 101079"];
3340 [label="return 'new'; 101080"];
3341 [label="FullWidth = this.Text.Length; 101081"];
3342 [label="FullWidth 101082"];
3343 [label="this.AdjustFlagsAndWidth(leading); 101083"];
3344 [label="return 'new'; 101084"];
3345 [label="FullWidth = this.Text.Length; 101085"];
3346 [label="FullWidth 101086"];
3347 [label="this.AdjustFlagsAndWidth(trailing); 101087"];
3348 [label="return 'new'; 101088"];
3349 [label="FullWidth = this.Text.Length; 101089"];
3350 [label="FullWidth 101090"];
3351 [label="this.AdjustFlagsAndWidth(trailing); 101091"];
3352 [label="return 'override'; 101092"];
3353 [label="FullWidth = this.Text.Length; 101093"];
3354 [label="FullWidth 101094"];
3355 [label="return 'override'; 101095"];
3356 [label="FullWidth = this.Text.Length; 101096"];
3357 [label="FullWidth 101097"];
3358 [label="this.AdjustFlagsAndWidth(leading); 101098"];
3359 [label="return 'override'; 101099"];
3360 [label="FullWidth = this.Text.Length; 101100"];
3361 [label="FullWidth 101101"];
3362 [label="this.AdjustFlagsAndWidth(trailing); 101102"];
3363 [label="return 'override'; 101103"];
3364 [label="FullWidth = this.Text.Length; 101104"];
3365 [label="FullWidth 101105"];
3366 [label="this.AdjustFlagsAndWidth(trailing); 101106"];
3367 [label="return 'abstract'; 101107"];
3368 [label="FullWidth = this.Text.Length; 101108"];
3369 [label="FullWidth 101109"];
3370 [label="return 'abstract'; 101110"];
3371 [label="FullWidth = this.Text.Length; 101111"];
3372 [label="FullWidth 101112"];
3373 [label="this.AdjustFlagsAndWidth(leading); 101113"];
3374 [label="return 'abstract'; 101114"];
3375 [label="FullWidth = this.Text.Length; 101115"];
3376 [label="FullWidth 101116"];
3377 [label="this.AdjustFlagsAndWidth(trailing); 101117"];
3378 [label="return 'abstract'; 101118"];
3379 [label="FullWidth = this.Text.Length; 101119"];
3380 [label="FullWidth 101120"];
3381 [label="this.AdjustFlagsAndWidth(trailing); 101121"];
3382 [label="return 'virtual'; 101122"];
3383 [label="FullWidth = this.Text.Length; 101123"];
3384 [label="FullWidth 101124"];
3385 [label="return 'virtual'; 101125"];
3386 [label="FullWidth = this.Text.Length; 101126"];
3387 [label="FullWidth 101127"];
3388 [label="this.AdjustFlagsAndWidth(leading); 101128"];
3389 [label="return 'virtual'; 101129"];
3390 [label="FullWidth = this.Text.Length; 101130"];
3391 [label="FullWidth 101131"];
3392 [label="this.AdjustFlagsAndWidth(trailing); 101132"];
3393 [label="return 'virtual'; 101133"];
3394 [label="FullWidth = this.Text.Length; 101134"];
3395 [label="FullWidth 101135"];
3396 [label="this.AdjustFlagsAndWidth(trailing); 101136"];
3397 [label="return 'event'; 101137"];
3398 [label="FullWidth = this.Text.Length; 101138"];
3399 [label="FullWidth 101139"];
3400 [label="return 'event'; 101140"];
3401 [label="FullWidth = this.Text.Length; 101141"];
3402 [label="FullWidth 101142"];
3403 [label="this.AdjustFlagsAndWidth(leading); 101143"];
3404 [label="return 'event'; 101144"];
3405 [label="FullWidth = this.Text.Length; 101145"];
3406 [label="FullWidth 101146"];
3407 [label="this.AdjustFlagsAndWidth(trailing); 101147"];
3408 [label="return 'event'; 101148"];
3409 [label="FullWidth = this.Text.Length; 101149"];
3410 [label="FullWidth 101150"];
3411 [label="this.AdjustFlagsAndWidth(trailing); 101151"];
3412 [label="return 'extern'; 101152"];
3413 [label="FullWidth = this.Text.Length; 101153"];
3414 [label="FullWidth 101154"];
3415 [label="return 'extern'; 101155"];
3416 [label="FullWidth = this.Text.Length; 101156"];
3417 [label="FullWidth 101157"];
3418 [label="this.AdjustFlagsAndWidth(leading); 101158"];
3419 [label="return 'extern'; 101159"];
3420 [label="FullWidth = this.Text.Length; 101160"];
3421 [label="FullWidth 101161"];
3422 [label="this.AdjustFlagsAndWidth(trailing); 101162"];
3423 [label="return 'extern'; 101163"];
3424 [label="FullWidth = this.Text.Length; 101164"];
3425 [label="FullWidth 101165"];
3426 [label="this.AdjustFlagsAndWidth(trailing); 101166"];
3427 [label="return 'ref'; 101167"];
3428 [label="FullWidth = this.Text.Length; 101168"];
3429 [label="FullWidth 101169"];
3430 [label="return 'ref'; 101170"];
3431 [label="FullWidth = this.Text.Length; 101171"];
3432 [label="FullWidth 101172"];
3433 [label="this.AdjustFlagsAndWidth(leading); 101173"];
3434 [label="return 'ref'; 101174"];
3435 [label="FullWidth = this.Text.Length; 101175"];
3436 [label="FullWidth 101176"];
3437 [label="this.AdjustFlagsAndWidth(trailing); 101177"];
3438 [label="return 'ref'; 101178"];
3439 [label="FullWidth = this.Text.Length; 101179"];
3440 [label="FullWidth 101180"];
3441 [label="this.AdjustFlagsAndWidth(trailing); 101181"];
3442 [label="return 'out'; 101182"];
3443 [label="FullWidth = this.Text.Length; 101183"];
3444 [label="FullWidth 101184"];
3445 [label="return 'out'; 101185"];
3446 [label="FullWidth = this.Text.Length; 101186"];
3447 [label="FullWidth 101187"];
3448 [label="this.AdjustFlagsAndWidth(leading); 101188"];
3449 [label="return 'out'; 101189"];
3450 [label="FullWidth = this.Text.Length; 101190"];
3451 [label="FullWidth 101191"];
3452 [label="this.AdjustFlagsAndWidth(trailing); 101192"];
3453 [label="return 'out'; 101193"];
3454 [label="FullWidth = this.Text.Length; 101194"];
3455 [label="FullWidth 101195"];
3456 [label="this.AdjustFlagsAndWidth(trailing); 101196"];
3457 [label="return 'in'; 101197"];
3458 [label="FullWidth = this.Text.Length; 101198"];
3459 [label="FullWidth 101199"];
3460 [label="return 'in'; 101200"];
3461 [label="FullWidth = this.Text.Length; 101201"];
3462 [label="FullWidth 101202"];
3463 [label="this.AdjustFlagsAndWidth(leading); 101203"];
3464 [label="return 'in'; 101204"];
3465 [label="FullWidth = this.Text.Length; 101205"];
3466 [label="FullWidth 101206"];
3467 [label="this.AdjustFlagsAndWidth(trailing); 101207"];
3468 [label="return 'in'; 101208"];
3469 [label="FullWidth = this.Text.Length; 101209"];
3470 [label="FullWidth 101210"];
3471 [label="this.AdjustFlagsAndWidth(trailing); 101211"];
3472 [label="return 'is'; 101212"];
3473 [label="FullWidth = this.Text.Length; 101213"];
3474 [label="FullWidth 101214"];
3475 [label="return 'is'; 101215"];
3476 [label="FullWidth = this.Text.Length; 101216"];
3477 [label="FullWidth 101217"];
3478 [label="this.AdjustFlagsAndWidth(leading); 101218"];
3479 [label="return 'is'; 101219"];
3480 [label="FullWidth = this.Text.Length; 101220"];
3481 [label="FullWidth 101221"];
3482 [label="this.AdjustFlagsAndWidth(trailing); 101222"];
3483 [label="return 'is'; 101223"];
3484 [label="FullWidth = this.Text.Length; 101224"];
3485 [label="FullWidth 101225"];
3486 [label="this.AdjustFlagsAndWidth(trailing); 101226"];
3487 [label="return 'as'; 101227"];
3488 [label="FullWidth = this.Text.Length; 101228"];
3489 [label="FullWidth 101229"];
3490 [label="return 'as'; 101230"];
3491 [label="FullWidth = this.Text.Length; 101231"];
3492 [label="FullWidth 101232"];
3493 [label="this.AdjustFlagsAndWidth(leading); 101233"];
3494 [label="return 'as'; 101234"];
3495 [label="FullWidth = this.Text.Length; 101235"];
3496 [label="FullWidth 101236"];
3497 [label="this.AdjustFlagsAndWidth(trailing); 101237"];
3498 [label="return 'as'; 101238"];
3499 [label="FullWidth = this.Text.Length; 101239"];
3500 [label="FullWidth 101240"];
3501 [label="this.AdjustFlagsAndWidth(trailing); 101241"];
3502 [label="return 'params'; 101242"];
3503 [label="FullWidth = this.Text.Length; 101243"];
3504 [label="FullWidth 101244"];
3505 [label="return 'params'; 101245"];
3506 [label="FullWidth = this.Text.Length; 101246"];
3507 [label="FullWidth 101247"];
3508 [label="this.AdjustFlagsAndWidth(leading); 101248"];
3509 [label="return 'params'; 101249"];
3510 [label="FullWidth = this.Text.Length; 101250"];
3511 [label="FullWidth 101251"];
3512 [label="this.AdjustFlagsAndWidth(trailing); 101252"];
3513 [label="return 'params'; 101253"];
3514 [label="FullWidth = this.Text.Length; 101254"];
3515 [label="FullWidth 101255"];
3516 [label="this.AdjustFlagsAndWidth(trailing); 101256"];
3517 [label="return '__arglist'; 101257"];
3518 [label="FullWidth = this.Text.Length; 101258"];
3519 [label="FullWidth 101259"];
3520 [label="return '__arglist'; 101260"];
3521 [label="FullWidth = this.Text.Length; 101261"];
3522 [label="FullWidth 101262"];
3523 [label="this.AdjustFlagsAndWidth(leading); 101263"];
3524 [label="return '__arglist'; 101264"];
3525 [label="FullWidth = this.Text.Length; 101265"];
3526 [label="FullWidth 101266"];
3527 [label="this.AdjustFlagsAndWidth(trailing); 101267"];
3528 [label="return '__arglist'; 101268"];
3529 [label="FullWidth = this.Text.Length; 101269"];
3530 [label="FullWidth 101270"];
3531 [label="this.AdjustFlagsAndWidth(trailing); 101271"];
3532 [label="return '__makeref'; 101272"];
3533 [label="FullWidth = this.Text.Length; 101273"];
3534 [label="FullWidth 101274"];
3535 [label="return '__makeref'; 101275"];
3536 [label="FullWidth = this.Text.Length; 101276"];
3537 [label="FullWidth 101277"];
3538 [label="this.AdjustFlagsAndWidth(leading); 101278"];
3539 [label="return '__makeref'; 101279"];
3540 [label="FullWidth = this.Text.Length; 101280"];
3541 [label="FullWidth 101281"];
3542 [label="this.AdjustFlagsAndWidth(trailing); 101282"];
3543 [label="return '__makeref'; 101283"];
3544 [label="FullWidth = this.Text.Length; 101284"];
3545 [label="FullWidth 101285"];
3546 [label="this.AdjustFlagsAndWidth(trailing); 101286"];
3547 [label="return '__reftype'; 101287"];
3548 [label="FullWidth = this.Text.Length; 101288"];
3549 [label="FullWidth 101289"];
3550 [label="return '__reftype'; 101290"];
3551 [label="FullWidth = this.Text.Length; 101291"];
3552 [label="FullWidth 101292"];
3553 [label="this.AdjustFlagsAndWidth(leading); 101293"];
3554 [label="return '__reftype'; 101294"];
3555 [label="FullWidth = this.Text.Length; 101295"];
3556 [label="FullWidth 101296"];
3557 [label="this.AdjustFlagsAndWidth(trailing); 101297"];
3558 [label="return '__reftype'; 101298"];
3559 [label="FullWidth = this.Text.Length; 101299"];
3560 [label="FullWidth 101300"];
3561 [label="this.AdjustFlagsAndWidth(trailing); 101301"];
3562 [label="return '__refvalue'; 101302"];
3563 [label="FullWidth = this.Text.Length; 101303"];
3564 [label="FullWidth 101304"];
3565 [label="return '__refvalue'; 101305"];
3566 [label="FullWidth = this.Text.Length; 101306"];
3567 [label="FullWidth 101307"];
3568 [label="this.AdjustFlagsAndWidth(leading); 101308"];
3569 [label="return '__refvalue'; 101309"];
3570 [label="FullWidth = this.Text.Length; 101310"];
3571 [label="FullWidth 101311"];
3572 [label="this.AdjustFlagsAndWidth(trailing); 101312"];
3573 [label="return '__refvalue'; 101313"];
3574 [label="FullWidth = this.Text.Length; 101314"];
3575 [label="FullWidth 101315"];
3576 [label="this.AdjustFlagsAndWidth(trailing); 101316"];
3577 [label="return 'this'; 101317"];
3578 [label="FullWidth = this.Text.Length; 101318"];
3579 [label="FullWidth 101319"];
3580 [label="return 'this'; 101320"];
3581 [label="FullWidth = this.Text.Length; 101321"];
3582 [label="FullWidth 101322"];
3583 [label="this.AdjustFlagsAndWidth(leading); 101323"];
3584 [label="return 'this'; 101324"];
3585 [label="FullWidth = this.Text.Length; 101325"];
3586 [label="FullWidth 101326"];
3587 [label="this.AdjustFlagsAndWidth(trailing); 101327"];
3588 [label="return 'this'; 101328"];
3589 [label="FullWidth = this.Text.Length; 101329"];
3590 [label="FullWidth 101330"];
3591 [label="this.AdjustFlagsAndWidth(trailing); 101331"];
3592 [label="return 'base'; 101332"];
3593 [label="FullWidth = this.Text.Length; 101333"];
3594 [label="FullWidth 101334"];
3595 [label="return 'base'; 101335"];
3596 [label="FullWidth = this.Text.Length; 101336"];
3597 [label="FullWidth 101337"];
3598 [label="this.AdjustFlagsAndWidth(leading); 101338"];
3599 [label="return 'base'; 101339"];
3600 [label="FullWidth = this.Text.Length; 101340"];
3601 [label="FullWidth 101341"];
3602 [label="this.AdjustFlagsAndWidth(trailing); 101342"];
3603 [label="return 'base'; 101343"];
3604 [label="FullWidth = this.Text.Length; 101344"];
3605 [label="FullWidth 101345"];
3606 [label="this.AdjustFlagsAndWidth(trailing); 101346"];
3607 [label="return 'namespace'; 101347"];
3608 [label="FullWidth = this.Text.Length; 101348"];
3609 [label="FullWidth 101349"];
3610 [label="return 'namespace'; 101350"];
3611 [label="FullWidth = this.Text.Length; 101351"];
3612 [label="FullWidth 101352"];
3613 [label="this.AdjustFlagsAndWidth(leading); 101353"];
3614 [label="return 'namespace'; 101354"];
3615 [label="FullWidth = this.Text.Length; 101355"];
3616 [label="FullWidth 101356"];
3617 [label="this.AdjustFlagsAndWidth(trailing); 101357"];
3618 [label="return 'namespace'; 101358"];
3619 [label="FullWidth = this.Text.Length; 101359"];
3620 [label="FullWidth 101360"];
3621 [label="this.AdjustFlagsAndWidth(trailing); 101361"];
3622 [label="return 'using'; 101362"];
3623 [label="FullWidth = this.Text.Length; 101363"];
3624 [label="FullWidth 101364"];
3625 [label="return 'using'; 101365"];
3626 [label="FullWidth = this.Text.Length; 101366"];
3627 [label="FullWidth 101367"];
3628 [label="this.AdjustFlagsAndWidth(leading); 101368"];
3629 [label="return 'using'; 101369"];
3630 [label="FullWidth = this.Text.Length; 101370"];
3631 [label="FullWidth 101371"];
3632 [label="this.AdjustFlagsAndWidth(trailing); 101372"];
3633 [label="return 'using'; 101373"];
3634 [label="FullWidth = this.Text.Length; 101374"];
3635 [label="FullWidth 101375"];
3636 [label="this.AdjustFlagsAndWidth(trailing); 101376"];
3637 [label="return 'class'; 101377"];
3638 [label="FullWidth = this.Text.Length; 101378"];
3639 [label="FullWidth 101379"];
3640 [label="return 'class'; 101380"];
3641 [label="FullWidth = this.Text.Length; 101381"];
3642 [label="FullWidth 101382"];
3643 [label="this.AdjustFlagsAndWidth(leading); 101383"];
3644 [label="return 'class'; 101384"];
3645 [label="FullWidth = this.Text.Length; 101385"];
3646 [label="FullWidth 101386"];
3647 [label="this.AdjustFlagsAndWidth(trailing); 101387"];
3648 [label="return 'class'; 101388"];
3649 [label="FullWidth = this.Text.Length; 101389"];
3650 [label="FullWidth 101390"];
3651 [label="this.AdjustFlagsAndWidth(trailing); 101391"];
3652 [label="return 'struct'; 101392"];
3653 [label="FullWidth = this.Text.Length; 101393"];
3654 [label="FullWidth 101394"];
3655 [label="return 'struct'; 101395"];
3656 [label="FullWidth = this.Text.Length; 101396"];
3657 [label="FullWidth 101397"];
3658 [label="this.AdjustFlagsAndWidth(leading); 101398"];
3659 [label="return 'struct'; 101399"];
3660 [label="FullWidth = this.Text.Length; 101400"];
3661 [label="FullWidth 101401"];
3662 [label="this.AdjustFlagsAndWidth(trailing); 101402"];
3663 [label="return 'struct'; 101403"];
3664 [label="FullWidth = this.Text.Length; 101404"];
3665 [label="FullWidth 101405"];
3666 [label="this.AdjustFlagsAndWidth(trailing); 101406"];
3667 [label="return 'interface'; 101407"];
3668 [label="FullWidth = this.Text.Length; 101408"];
3669 [label="FullWidth 101409"];
3670 [label="return 'interface'; 101410"];
3671 [label="FullWidth = this.Text.Length; 101411"];
3672 [label="FullWidth 101412"];
3673 [label="this.AdjustFlagsAndWidth(leading); 101413"];
3674 [label="return 'interface'; 101414"];
3675 [label="FullWidth = this.Text.Length; 101415"];
3676 [label="FullWidth 101416"];
3677 [label="this.AdjustFlagsAndWidth(trailing); 101417"];
3678 [label="return 'interface'; 101418"];
3679 [label="FullWidth = this.Text.Length; 101419"];
3680 [label="FullWidth 101420"];
3681 [label="this.AdjustFlagsAndWidth(trailing); 101421"];
3682 [label="return 'enum'; 101422"];
3683 [label="FullWidth = this.Text.Length; 101423"];
3684 [label="FullWidth 101424"];
3685 [label="return 'enum'; 101425"];
3686 [label="FullWidth = this.Text.Length; 101426"];
3687 [label="FullWidth 101427"];
3688 [label="this.AdjustFlagsAndWidth(leading); 101428"];
3689 [label="return 'enum'; 101429"];
3690 [label="FullWidth = this.Text.Length; 101430"];
3691 [label="FullWidth 101431"];
3692 [label="this.AdjustFlagsAndWidth(trailing); 101432"];
3693 [label="return 'enum'; 101433"];
3694 [label="FullWidth = this.Text.Length; 101434"];
3695 [label="FullWidth 101435"];
3696 [label="this.AdjustFlagsAndWidth(trailing); 101436"];
3697 [label="return 'delegate'; 101437"];
3698 [label="FullWidth = this.Text.Length; 101438"];
3699 [label="FullWidth 101439"];
3700 [label="return 'delegate'; 101440"];
3701 [label="FullWidth = this.Text.Length; 101441"];
3702 [label="FullWidth 101442"];
3703 [label="this.AdjustFlagsAndWidth(leading); 101443"];
3704 [label="return 'delegate'; 101444"];
3705 [label="FullWidth = this.Text.Length; 101445"];
3706 [label="FullWidth 101446"];
3707 [label="this.AdjustFlagsAndWidth(trailing); 101447"];
3708 [label="return 'delegate'; 101448"];
3709 [label="FullWidth = this.Text.Length; 101449"];
3710 [label="FullWidth 101450"];
3711 [label="this.AdjustFlagsAndWidth(trailing); 101451"];
3712 [label="return 'checked'; 101452"];
3713 [label="FullWidth = this.Text.Length; 101453"];
3714 [label="FullWidth 101454"];
3715 [label="return 'checked'; 101455"];
3716 [label="FullWidth = this.Text.Length; 101456"];
3717 [label="FullWidth 101457"];
3718 [label="this.AdjustFlagsAndWidth(leading); 101458"];
3719 [label="return 'checked'; 101459"];
3720 [label="FullWidth = this.Text.Length; 101460"];
3721 [label="FullWidth 101461"];
3722 [label="this.AdjustFlagsAndWidth(trailing); 101462"];
3723 [label="return 'checked'; 101463"];
3724 [label="FullWidth = this.Text.Length; 101464"];
3725 [label="FullWidth 101465"];
3726 [label="this.AdjustFlagsAndWidth(trailing); 101466"];
3727 [label="return 'unchecked'; 101467"];
3728 [label="FullWidth = this.Text.Length; 101468"];
3729 [label="FullWidth 101469"];
3730 [label="return 'unchecked'; 101470"];
3731 [label="FullWidth = this.Text.Length; 101471"];
3732 [label="FullWidth 101472"];
3733 [label="this.AdjustFlagsAndWidth(leading); 101473"];
3734 [label="return 'unchecked'; 101474"];
3735 [label="FullWidth = this.Text.Length; 101475"];
3736 [label="FullWidth 101476"];
3737 [label="this.AdjustFlagsAndWidth(trailing); 101477"];
3738 [label="return 'unchecked'; 101478"];
3739 [label="FullWidth = this.Text.Length; 101479"];
3740 [label="FullWidth 101480"];
3741 [label="this.AdjustFlagsAndWidth(trailing); 101481"];
3742 [label="return 'unsafe'; 101482"];
3743 [label="FullWidth = this.Text.Length; 101483"];
3744 [label="FullWidth 101484"];
3745 [label="return 'unsafe'; 101485"];
3746 [label="FullWidth = this.Text.Length; 101486"];
3747 [label="FullWidth 101487"];
3748 [label="this.AdjustFlagsAndWidth(leading); 101488"];
3749 [label="return 'unsafe'; 101489"];
3750 [label="FullWidth = this.Text.Length; 101490"];
3751 [label="FullWidth 101491"];
3752 [label="this.AdjustFlagsAndWidth(trailing); 101492"];
3753 [label="return 'unsafe'; 101493"];
3754 [label="FullWidth = this.Text.Length; 101494"];
3755 [label="FullWidth 101495"];
3756 [label="this.AdjustFlagsAndWidth(trailing); 101496"];
3757 [label="return 'operator'; 101497"];
3758 [label="FullWidth = this.Text.Length; 101498"];
3759 [label="FullWidth 101499"];
3760 [label="return 'operator'; 101500"];
3761 [label="FullWidth = this.Text.Length; 101501"];
3762 [label="FullWidth 101502"];
3763 [label="this.AdjustFlagsAndWidth(leading); 101503"];
3764 [label="return 'operator'; 101504"];
3765 [label="FullWidth = this.Text.Length; 101505"];
3766 [label="FullWidth 101506"];
3767 [label="this.AdjustFlagsAndWidth(trailing); 101507"];
3768 [label="return 'operator'; 101508"];
3769 [label="FullWidth = this.Text.Length; 101509"];
3770 [label="FullWidth 101510"];
3771 [label="this.AdjustFlagsAndWidth(trailing); 101511"];
3772 [label="return 'explicit'; 101512"];
3773 [label="FullWidth = this.Text.Length; 101513"];
3774 [label="FullWidth 101514"];
3775 [label="return 'explicit'; 101515"];
3776 [label="FullWidth = this.Text.Length; 101516"];
3777 [label="FullWidth 101517"];
3778 [label="this.AdjustFlagsAndWidth(leading); 101518"];
3779 [label="return 'explicit'; 101519"];
3780 [label="FullWidth = this.Text.Length; 101520"];
3781 [label="FullWidth 101521"];
3782 [label="this.AdjustFlagsAndWidth(trailing); 101522"];
3783 [label="return 'explicit'; 101523"];
3784 [label="FullWidth = this.Text.Length; 101524"];
3785 [label="FullWidth 101525"];
3786 [label="this.AdjustFlagsAndWidth(trailing); 101526"];
3787 [label="return 'implicit'; 101527"];
3788 [label="FullWidth = this.Text.Length; 101528"];
3789 [label="FullWidth 101529"];
3790 [label="return 'implicit'; 101530"];
3791 [label="FullWidth = this.Text.Length; 101531"];
3792 [label="FullWidth 101532"];
3793 [label="this.AdjustFlagsAndWidth(leading); 101533"];
3794 [label="return 'implicit'; 101534"];
3795 [label="FullWidth = this.Text.Length; 101535"];
3796 [label="FullWidth 101536"];
3797 [label="this.AdjustFlagsAndWidth(trailing); 101537"];
3798 [label="return 'implicit'; 101538"];
3799 [label="FullWidth = this.Text.Length; 101539"];
3800 [label="FullWidth 101540"];
3801 [label="this.AdjustFlagsAndWidth(trailing); 101541"];
3802 [label="return 'yield'; 101542"];
3803 [label="FullWidth = this.Text.Length; 101543"];
3804 [label="FullWidth 101544"];
3805 [label="return 'yield'; 101545"];
3806 [label="FullWidth = this.Text.Length; 101546"];
3807 [label="FullWidth 101547"];
3808 [label="this.AdjustFlagsAndWidth(leading); 101548"];
3809 [label="return 'yield'; 101549"];
3810 [label="FullWidth = this.Text.Length; 101550"];
3811 [label="FullWidth 101551"];
3812 [label="this.AdjustFlagsAndWidth(trailing); 101552"];
3813 [label="return 'yield'; 101553"];
3814 [label="FullWidth = this.Text.Length; 101554"];
3815 [label="FullWidth 101555"];
3816 [label="this.AdjustFlagsAndWidth(trailing); 101556"];
3817 [label="return 'partial'; 101557"];
3818 [label="FullWidth = this.Text.Length; 101558"];
3819 [label="FullWidth 101559"];
3820 [label="return 'partial'; 101560"];
3821 [label="FullWidth = this.Text.Length; 101561"];
3822 [label="FullWidth 101562"];
3823 [label="this.AdjustFlagsAndWidth(leading); 101563"];
3824 [label="return 'partial'; 101564"];
3825 [label="FullWidth = this.Text.Length; 101565"];
3826 [label="FullWidth 101566"];
3827 [label="this.AdjustFlagsAndWidth(trailing); 101567"];
3828 [label="return 'partial'; 101568"];
3829 [label="FullWidth = this.Text.Length; 101569"];
3830 [label="FullWidth 101570"];
3831 [label="this.AdjustFlagsAndWidth(trailing); 101571"];
3832 [label="return 'alias'; 101572"];
3833 [label="FullWidth = this.Text.Length; 101573"];
3834 [label="FullWidth 101574"];
3835 [label="return 'alias'; 101575"];
3836 [label="FullWidth = this.Text.Length; 101576"];
3837 [label="FullWidth 101577"];
3838 [label="this.AdjustFlagsAndWidth(leading); 101578"];
3839 [label="return 'alias'; 101579"];
3840 [label="FullWidth = this.Text.Length; 101580"];
3841 [label="FullWidth 101581"];
3842 [label="this.AdjustFlagsAndWidth(trailing); 101582"];
3843 [label="return 'alias'; 101583"];
3844 [label="FullWidth = this.Text.Length; 101584"];
3845 [label="FullWidth 101585"];
3846 [label="this.AdjustFlagsAndWidth(trailing); 101586"];
3847 [label="return 'global'; 101587"];
3848 [label="FullWidth = this.Text.Length; 101588"];
3849 [label="FullWidth 101589"];
3850 [label="return 'global'; 101590"];
3851 [label="FullWidth = this.Text.Length; 101591"];
3852 [label="FullWidth 101592"];
3853 [label="this.AdjustFlagsAndWidth(leading); 101593"];
3854 [label="return 'global'; 101594"];
3855 [label="FullWidth = this.Text.Length; 101595"];
3856 [label="FullWidth 101596"];
3857 [label="this.AdjustFlagsAndWidth(trailing); 101597"];
3858 [label="return 'global'; 101598"];
3859 [label="FullWidth = this.Text.Length; 101599"];
3860 [label="FullWidth 101600"];
3861 [label="this.AdjustFlagsAndWidth(trailing); 101601"];
3862 [label="return 'assembly'; 101602"];
3863 [label="FullWidth = this.Text.Length; 101603"];
3864 [label="FullWidth 101604"];
3865 [label="return 'assembly'; 101605"];
3866 [label="FullWidth = this.Text.Length; 101606"];
3867 [label="FullWidth 101607"];
3868 [label="this.AdjustFlagsAndWidth(leading); 101608"];
3869 [label="return 'assembly'; 101609"];
3870 [label="FullWidth = this.Text.Length; 101610"];
3871 [label="FullWidth 101611"];
3872 [label="this.AdjustFlagsAndWidth(trailing); 101612"];
3873 [label="return 'assembly'; 101613"];
3874 [label="FullWidth = this.Text.Length; 101614"];
3875 [label="FullWidth 101615"];
3876 [label="this.AdjustFlagsAndWidth(trailing); 101616"];
3877 [label="return 'module'; 101617"];
3878 [label="FullWidth = this.Text.Length; 101618"];
3879 [label="FullWidth 101619"];
3880 [label="return 'module'; 101620"];
3881 [label="FullWidth = this.Text.Length; 101621"];
3882 [label="FullWidth 101622"];
3883 [label="this.AdjustFlagsAndWidth(leading); 101623"];
3884 [label="return 'module'; 101624"];
3885 [label="FullWidth = this.Text.Length; 101625"];
3886 [label="FullWidth 101626"];
3887 [label="this.AdjustFlagsAndWidth(trailing); 101627"];
3888 [label="return 'module'; 101628"];
3889 [label="FullWidth = this.Text.Length; 101629"];
3890 [label="FullWidth 101630"];
3891 [label="this.AdjustFlagsAndWidth(trailing); 101631"];
3892 [label="return 'type'; 101632"];
3893 [label="FullWidth = this.Text.Length; 101633"];
3894 [label="FullWidth 101634"];
3895 [label="return 'type'; 101635"];
3896 [label="FullWidth = this.Text.Length; 101636"];
3897 [label="FullWidth 101637"];
3898 [label="this.AdjustFlagsAndWidth(leading); 101638"];
3899 [label="return 'type'; 101639"];
3900 [label="FullWidth = this.Text.Length; 101640"];
3901 [label="FullWidth 101641"];
3902 [label="this.AdjustFlagsAndWidth(trailing); 101642"];
3903 [label="return 'type'; 101643"];
3904 [label="FullWidth = this.Text.Length; 101644"];
3905 [label="FullWidth 101645"];
3906 [label="this.AdjustFlagsAndWidth(trailing); 101646"];
3907 [label="return 'field'; 101647"];
3908 [label="FullWidth = this.Text.Length; 101648"];
3909 [label="FullWidth 101649"];
3910 [label="return 'field'; 101650"];
3911 [label="FullWidth = this.Text.Length; 101651"];
3912 [label="FullWidth 101652"];
3913 [label="this.AdjustFlagsAndWidth(leading); 101653"];
3914 [label="return 'field'; 101654"];
3915 [label="FullWidth = this.Text.Length; 101655"];
3916 [label="FullWidth 101656"];
3917 [label="this.AdjustFlagsAndWidth(trailing); 101657"];
3918 [label="return 'field'; 101658"];
3919 [label="FullWidth = this.Text.Length; 101659"];
3920 [label="FullWidth 101660"];
3921 [label="this.AdjustFlagsAndWidth(trailing); 101661"];
3922 [label="return 'method'; 101662"];
3923 [label="FullWidth = this.Text.Length; 101663"];
3924 [label="FullWidth 101664"];
3925 [label="return 'method'; 101665"];
3926 [label="FullWidth = this.Text.Length; 101666"];
3927 [label="FullWidth 101667"];
3928 [label="this.AdjustFlagsAndWidth(leading); 101668"];
3929 [label="return 'method'; 101669"];
3930 [label="FullWidth = this.Text.Length; 101670"];
3931 [label="FullWidth 101671"];
3932 [label="this.AdjustFlagsAndWidth(trailing); 101672"];
3933 [label="return 'method'; 101673"];
3934 [label="FullWidth = this.Text.Length; 101674"];
3935 [label="FullWidth 101675"];
3936 [label="this.AdjustFlagsAndWidth(trailing); 101676"];
3937 [label="return 'param'; 101677"];
3938 [label="FullWidth = this.Text.Length; 101678"];
3939 [label="FullWidth 101679"];
3940 [label="return 'param'; 101680"];
3941 [label="FullWidth = this.Text.Length; 101681"];
3942 [label="FullWidth 101682"];
3943 [label="this.AdjustFlagsAndWidth(leading); 101683"];
3944 [label="return 'param'; 101684"];
3945 [label="FullWidth = this.Text.Length; 101685"];
3946 [label="FullWidth 101686"];
3947 [label="this.AdjustFlagsAndWidth(trailing); 101687"];
3948 [label="return 'param'; 101688"];
3949 [label="FullWidth = this.Text.Length; 101689"];
3950 [label="FullWidth 101690"];
3951 [label="this.AdjustFlagsAndWidth(trailing); 101691"];
3952 [label="return 'property'; 101692"];
3953 [label="FullWidth = this.Text.Length; 101693"];
3954 [label="FullWidth 101694"];
3955 [label="return 'property'; 101695"];
3956 [label="FullWidth = this.Text.Length; 101696"];
3957 [label="FullWidth 101697"];
3958 [label="this.AdjustFlagsAndWidth(leading); 101698"];
3959 [label="return 'property'; 101699"];
3960 [label="FullWidth = this.Text.Length; 101700"];
3961 [label="FullWidth 101701"];
3962 [label="this.AdjustFlagsAndWidth(trailing); 101702"];
3963 [label="return 'property'; 101703"];
3964 [label="FullWidth = this.Text.Length; 101704"];
3965 [label="FullWidth 101705"];
3966 [label="this.AdjustFlagsAndWidth(trailing); 101706"];
3967 [label="return 'typevar'; 101707"];
3968 [label="FullWidth = this.Text.Length; 101708"];
3969 [label="FullWidth 101709"];
3970 [label="return 'typevar'; 101710"];
3971 [label="FullWidth = this.Text.Length; 101711"];
3972 [label="FullWidth 101712"];
3973 [label="this.AdjustFlagsAndWidth(leading); 101713"];
3974 [label="return 'typevar'; 101714"];
3975 [label="FullWidth = this.Text.Length; 101715"];
3976 [label="FullWidth 101716"];
3977 [label="this.AdjustFlagsAndWidth(trailing); 101717"];
3978 [label="return 'typevar'; 101718"];
3979 [label="FullWidth = this.Text.Length; 101719"];
3980 [label="FullWidth 101720"];
3981 [label="this.AdjustFlagsAndWidth(trailing); 101721"];
3982 [label="return 'get'; 101722"];
3983 [label="FullWidth = this.Text.Length; 101723"];
3984 [label="FullWidth 101724"];
3985 [label="return 'get'; 101725"];
3986 [label="FullWidth = this.Text.Length; 101726"];
3987 [label="FullWidth 101727"];
3988 [label="this.AdjustFlagsAndWidth(leading); 101728"];
3989 [label="return 'get'; 101729"];
3990 [label="FullWidth = this.Text.Length; 101730"];
3991 [label="FullWidth 101731"];
3992 [label="this.AdjustFlagsAndWidth(trailing); 101732"];
3993 [label="return 'get'; 101733"];
3994 [label="FullWidth = this.Text.Length; 101734"];
3995 [label="FullWidth 101735"];
3996 [label="this.AdjustFlagsAndWidth(trailing); 101736"];
3997 [label="return 'set'; 101737"];
3998 [label="FullWidth = this.Text.Length; 101738"];
3999 [label="FullWidth 101739"];
4000 [label="return 'set'; 101740"];
4001 [label="FullWidth = this.Text.Length; 101741"];
4002 [label="FullWidth 101742"];
4003 [label="this.AdjustFlagsAndWidth(leading); 101743"];
4004 [label="return 'set'; 101744"];
4005 [label="FullWidth = this.Text.Length; 101745"];
4006 [label="FullWidth 101746"];
4007 [label="this.AdjustFlagsAndWidth(trailing); 101747"];
4008 [label="return 'set'; 101748"];
4009 [label="FullWidth = this.Text.Length; 101749"];
4010 [label="FullWidth 101750"];
4011 [label="this.AdjustFlagsAndWidth(trailing); 101751"];
4012 [label="return 'add'; 101752"];
4013 [label="FullWidth = this.Text.Length; 101753"];
4014 [label="FullWidth 101754"];
4015 [label="return 'add'; 101755"];
4016 [label="FullWidth = this.Text.Length; 101756"];
4017 [label="FullWidth 101757"];
4018 [label="this.AdjustFlagsAndWidth(leading); 101758"];
4019 [label="return 'add'; 101759"];
4020 [label="FullWidth = this.Text.Length; 101760"];
4021 [label="FullWidth 101761"];
4022 [label="this.AdjustFlagsAndWidth(trailing); 101762"];
4023 [label="return 'add'; 101763"];
4024 [label="FullWidth = this.Text.Length; 101764"];
4025 [label="FullWidth 101765"];
4026 [label="this.AdjustFlagsAndWidth(trailing); 101766"];
4027 [label="return 'remove'; 101767"];
4028 [label="FullWidth = this.Text.Length; 101768"];
4029 [label="FullWidth 101769"];
4030 [label="return 'remove'; 101770"];
4031 [label="FullWidth = this.Text.Length; 101771"];
4032 [label="FullWidth 101772"];
4033 [label="this.AdjustFlagsAndWidth(leading); 101773"];
4034 [label="return 'remove'; 101774"];
4035 [label="FullWidth = this.Text.Length; 101775"];
4036 [label="FullWidth 101776"];
4037 [label="this.AdjustFlagsAndWidth(trailing); 101777"];
4038 [label="return 'remove'; 101778"];
4039 [label="FullWidth = this.Text.Length; 101779"];
4040 [label="FullWidth 101780"];
4041 [label="this.AdjustFlagsAndWidth(trailing); 101781"];
4042 [label="return 'where'; 101782"];
4043 [label="FullWidth = this.Text.Length; 101783"];
4044 [label="FullWidth 101784"];
4045 [label="return 'where'; 101785"];
4046 [label="FullWidth = this.Text.Length; 101786"];
4047 [label="FullWidth 101787"];
4048 [label="this.AdjustFlagsAndWidth(leading); 101788"];
4049 [label="return 'where'; 101789"];
4050 [label="FullWidth = this.Text.Length; 101790"];
4051 [label="FullWidth 101791"];
4052 [label="this.AdjustFlagsAndWidth(trailing); 101792"];
4053 [label="return 'where'; 101793"];
4054 [label="FullWidth = this.Text.Length; 101794"];
4055 [label="FullWidth 101795"];
4056 [label="this.AdjustFlagsAndWidth(trailing); 101796"];
4057 [label="return 'from'; 101797"];
4058 [label="FullWidth = this.Text.Length; 101798"];
4059 [label="FullWidth 101799"];
4060 [label="return 'from'; 101800"];
4061 [label="FullWidth = this.Text.Length; 101801"];
4062 [label="FullWidth 101802"];
4063 [label="this.AdjustFlagsAndWidth(leading); 101803"];
4064 [label="return 'from'; 101804"];
4065 [label="FullWidth = this.Text.Length; 101805"];
4066 [label="FullWidth 101806"];
4067 [label="this.AdjustFlagsAndWidth(trailing); 101807"];
4068 [label="return 'from'; 101808"];
4069 [label="FullWidth = this.Text.Length; 101809"];
4070 [label="FullWidth 101810"];
4071 [label="this.AdjustFlagsAndWidth(trailing); 101811"];
4072 [label="return 'group'; 101812"];
4073 [label="FullWidth = this.Text.Length; 101813"];
4074 [label="FullWidth 101814"];
4075 [label="return 'group'; 101815"];
4076 [label="FullWidth = this.Text.Length; 101816"];
4077 [label="FullWidth 101817"];
4078 [label="this.AdjustFlagsAndWidth(leading); 101818"];
4079 [label="return 'group'; 101819"];
4080 [label="FullWidth = this.Text.Length; 101820"];
4081 [label="FullWidth 101821"];
4082 [label="this.AdjustFlagsAndWidth(trailing); 101822"];
4083 [label="return 'group'; 101823"];
4084 [label="FullWidth = this.Text.Length; 101824"];
4085 [label="FullWidth 101825"];
4086 [label="this.AdjustFlagsAndWidth(trailing); 101826"];
4087 [label="return 'join'; 101827"];
4088 [label="FullWidth = this.Text.Length; 101828"];
4089 [label="FullWidth 101829"];
4090 [label="return 'join'; 101830"];
4091 [label="FullWidth = this.Text.Length; 101831"];
4092 [label="FullWidth 101832"];
4093 [label="this.AdjustFlagsAndWidth(leading); 101833"];
4094 [label="return 'join'; 101834"];
4095 [label="FullWidth = this.Text.Length; 101835"];
4096 [label="FullWidth 101836"];
4097 [label="this.AdjustFlagsAndWidth(trailing); 101837"];
4098 [label="return 'join'; 101838"];
4099 [label="FullWidth = this.Text.Length; 101839"];
4100 [label="FullWidth 101840"];
4101 [label="this.AdjustFlagsAndWidth(trailing); 101841"];
4102 [label="return 'into'; 101842"];
4103 [label="FullWidth = this.Text.Length; 101843"];
4104 [label="FullWidth 101844"];
4105 [label="return 'into'; 101845"];
4106 [label="FullWidth = this.Text.Length; 101846"];
4107 [label="FullWidth 101847"];
4108 [label="this.AdjustFlagsAndWidth(leading); 101848"];
4109 [label="return 'into'; 101849"];
4110 [label="FullWidth = this.Text.Length; 101850"];
4111 [label="FullWidth 101851"];
4112 [label="this.AdjustFlagsAndWidth(trailing); 101852"];
4113 [label="return 'into'; 101853"];
4114 [label="FullWidth = this.Text.Length; 101854"];
4115 [label="FullWidth 101855"];
4116 [label="this.AdjustFlagsAndWidth(trailing); 101856"];
4117 [label="return 'let'; 101857"];
4118 [label="FullWidth = this.Text.Length; 101858"];
4119 [label="FullWidth 101859"];
4120 [label="return 'let'; 101860"];
4121 [label="FullWidth = this.Text.Length; 101861"];
4122 [label="FullWidth 101862"];
4123 [label="this.AdjustFlagsAndWidth(leading); 101863"];
4124 [label="return 'let'; 101864"];
4125 [label="FullWidth = this.Text.Length; 101865"];
4126 [label="FullWidth 101866"];
4127 [label="this.AdjustFlagsAndWidth(trailing); 101867"];
4128 [label="return 'let'; 101868"];
4129 [label="FullWidth = this.Text.Length; 101869"];
4130 [label="FullWidth 101870"];
4131 [label="this.AdjustFlagsAndWidth(trailing); 101871"];
4132 [label="return 'by'; 101872"];
4133 [label="FullWidth = this.Text.Length; 101873"];
4134 [label="FullWidth 101874"];
4135 [label="return 'by'; 101875"];
4136 [label="FullWidth = this.Text.Length; 101876"];
4137 [label="FullWidth 101877"];
4138 [label="this.AdjustFlagsAndWidth(leading); 101878"];
4139 [label="return 'by'; 101879"];
4140 [label="FullWidth = this.Text.Length; 101880"];
4141 [label="FullWidth 101881"];
4142 [label="this.AdjustFlagsAndWidth(trailing); 101882"];
4143 [label="return 'by'; 101883"];
4144 [label="FullWidth = this.Text.Length; 101884"];
4145 [label="FullWidth 101885"];
4146 [label="this.AdjustFlagsAndWidth(trailing); 101886"];
4147 [label="return 'select'; 101887"];
4148 [label="FullWidth = this.Text.Length; 101888"];
4149 [label="FullWidth 101889"];
4150 [label="return 'select'; 101890"];
4151 [label="FullWidth = this.Text.Length; 101891"];
4152 [label="FullWidth 101892"];
4153 [label="this.AdjustFlagsAndWidth(leading); 101893"];
4154 [label="return 'select'; 101894"];
4155 [label="FullWidth = this.Text.Length; 101895"];
4156 [label="FullWidth 101896"];
4157 [label="this.AdjustFlagsAndWidth(trailing); 101897"];
4158 [label="return 'select'; 101898"];
4159 [label="FullWidth = this.Text.Length; 101899"];
4160 [label="FullWidth 101900"];
4161 [label="this.AdjustFlagsAndWidth(trailing); 101901"];
4162 [label="return 'orderby'; 101902"];
4163 [label="FullWidth = this.Text.Length; 101903"];
4164 [label="FullWidth 101904"];
4165 [label="return 'orderby'; 101905"];
4166 [label="FullWidth = this.Text.Length; 101906"];
4167 [label="FullWidth 101907"];
4168 [label="this.AdjustFlagsAndWidth(leading); 101908"];
4169 [label="return 'orderby'; 101909"];
4170 [label="FullWidth = this.Text.Length; 101910"];
4171 [label="FullWidth 101911"];
4172 [label="this.AdjustFlagsAndWidth(trailing); 101912"];
4173 [label="return 'orderby'; 101913"];
4174 [label="FullWidth = this.Text.Length; 101914"];
4175 [label="FullWidth 101915"];
4176 [label="this.AdjustFlagsAndWidth(trailing); 101916"];
4177 [label="return 'on'; 101917"];
4178 [label="FullWidth = this.Text.Length; 101918"];
4179 [label="FullWidth 101919"];
4180 [label="return 'on'; 101920"];
4181 [label="FullWidth = this.Text.Length; 101921"];
4182 [label="FullWidth 101922"];
4183 [label="this.AdjustFlagsAndWidth(leading); 101923"];
4184 [label="return 'on'; 101924"];
4185 [label="FullWidth = this.Text.Length; 101925"];
4186 [label="FullWidth 101926"];
4187 [label="this.AdjustFlagsAndWidth(trailing); 101927"];
4188 [label="return 'on'; 101928"];
4189 [label="FullWidth = this.Text.Length; 101929"];
4190 [label="FullWidth 101930"];
4191 [label="this.AdjustFlagsAndWidth(trailing); 101931"];
4192 [label="return 'equals'; 101932"];
4193 [label="FullWidth = this.Text.Length; 101933"];
4194 [label="FullWidth 101934"];
4195 [label="return 'equals'; 101935"];
4196 [label="FullWidth = this.Text.Length; 101936"];
4197 [label="FullWidth 101937"];
4198 [label="this.AdjustFlagsAndWidth(leading); 101938"];
4199 [label="return 'equals'; 101939"];
4200 [label="FullWidth = this.Text.Length; 101940"];
4201 [label="FullWidth 101941"];
4202 [label="this.AdjustFlagsAndWidth(trailing); 101942"];
4203 [label="return 'equals'; 101943"];
4204 [label="FullWidth = this.Text.Length; 101944"];
4205 [label="FullWidth 101945"];
4206 [label="this.AdjustFlagsAndWidth(trailing); 101946"];
4207 [label="return 'ascending'; 101947"];
4208 [label="FullWidth = this.Text.Length; 101948"];
4209 [label="FullWidth 101949"];
4210 [label="return 'ascending'; 101950"];
4211 [label="FullWidth = this.Text.Length; 101951"];
4212 [label="FullWidth 101952"];
4213 [label="this.AdjustFlagsAndWidth(leading); 101953"];
4214 [label="return 'ascending'; 101954"];
4215 [label="FullWidth = this.Text.Length; 101955"];
4216 [label="FullWidth 101956"];
4217 [label="this.AdjustFlagsAndWidth(trailing); 101957"];
4218 [label="return 'ascending'; 101958"];
4219 [label="FullWidth = this.Text.Length; 101959"];
4220 [label="FullWidth 101960"];
4221 [label="this.AdjustFlagsAndWidth(trailing); 101961"];
4222 [label="return 'descending'; 101962"];
4223 [label="FullWidth = this.Text.Length; 101963"];
4224 [label="FullWidth 101964"];
4225 [label="return 'descending'; 101965"];
4226 [label="FullWidth = this.Text.Length; 101966"];
4227 [label="FullWidth 101967"];
4228 [label="this.AdjustFlagsAndWidth(leading); 101968"];
4229 [label="return 'descending'; 101969"];
4230 [label="FullWidth = this.Text.Length; 101970"];
4231 [label="FullWidth 101971"];
4232 [label="this.AdjustFlagsAndWidth(trailing); 101972"];
4233 [label="return 'descending'; 101973"];
4234 [label="FullWidth = this.Text.Length; 101974"];
4235 [label="FullWidth 101975"];
4236 [label="this.AdjustFlagsAndWidth(trailing); 101976"];
4237 [label="return 'nameof'; 101977"];
4238 [label="FullWidth = this.Text.Length; 101978"];
4239 [label="FullWidth 101979"];
4240 [label="return 'nameof'; 101980"];
4241 [label="FullWidth = this.Text.Length; 101981"];
4242 [label="FullWidth 101982"];
4243 [label="this.AdjustFlagsAndWidth(leading); 101983"];
4244 [label="return 'nameof'; 101984"];
4245 [label="FullWidth = this.Text.Length; 101985"];
4246 [label="FullWidth 101986"];
4247 [label="this.AdjustFlagsAndWidth(trailing); 101987"];
4248 [label="return 'nameof'; 101988"];
4249 [label="FullWidth = this.Text.Length; 101989"];
4250 [label="FullWidth 101990"];
4251 [label="this.AdjustFlagsAndWidth(trailing); 101991"];
4252 [label="return 'async'; 101992"];
4253 [label="FullWidth = this.Text.Length; 101993"];
4254 [label="FullWidth 101994"];
4255 [label="return 'async'; 101995"];
4256 [label="FullWidth = this.Text.Length; 101996"];
4257 [label="FullWidth 101997"];
4258 [label="this.AdjustFlagsAndWidth(leading); 101998"];
4259 [label="return 'async'; 101999"];
4260 [label="FullWidth = this.Text.Length; 102000"];
4261 [label="FullWidth 102001"];
4262 [label="this.AdjustFlagsAndWidth(trailing); 102002"];
4263 [label="return 'async'; 102003"];
4264 [label="FullWidth = this.Text.Length; 102004"];
4265 [label="FullWidth 102005"];
4266 [label="this.AdjustFlagsAndWidth(trailing); 102006"];
4267 [label="return 'await'; 102007"];
4268 [label="FullWidth = this.Text.Length; 102008"];
4269 [label="FullWidth 102009"];
4270 [label="return 'await'; 102010"];
4271 [label="FullWidth = this.Text.Length; 102011"];
4272 [label="FullWidth 102012"];
4273 [label="this.AdjustFlagsAndWidth(leading); 102013"];
4274 [label="return 'await'; 102014"];
4275 [label="FullWidth = this.Text.Length; 102015"];
4276 [label="FullWidth 102016"];
4277 [label="this.AdjustFlagsAndWidth(trailing); 102017"];
4278 [label="return 'await'; 102018"];
4279 [label="FullWidth = this.Text.Length; 102019"];
4280 [label="FullWidth 102020"];
4281 [label="this.AdjustFlagsAndWidth(trailing); 102021"];
4282 [label="return 'when'; 102022"];
4283 [label="FullWidth = this.Text.Length; 102023"];
4284 [label="FullWidth 102024"];
4285 [label="return 'when'; 102025"];
4286 [label="FullWidth = this.Text.Length; 102026"];
4287 [label="FullWidth 102027"];
4288 [label="this.AdjustFlagsAndWidth(leading); 102028"];
4289 [label="return 'when'; 102029"];
4290 [label="FullWidth = this.Text.Length; 102030"];
4291 [label="FullWidth 102031"];
4292 [label="this.AdjustFlagsAndWidth(trailing); 102032"];
4293 [label="return 'when'; 102033"];
4294 [label="FullWidth = this.Text.Length; 102034"];
4295 [label="FullWidth 102035"];
4296 [label="this.AdjustFlagsAndWidth(trailing); 102036"];
4297 [label="return 'or'; 102037"];
4298 [label="FullWidth = this.Text.Length; 102038"];
4299 [label="FullWidth 102039"];
4300 [label="return 'or'; 102040"];
4301 [label="FullWidth = this.Text.Length; 102041"];
4302 [label="FullWidth 102042"];
4303 [label="this.AdjustFlagsAndWidth(leading); 102043"];
4304 [label="return 'or'; 102044"];
4305 [label="FullWidth = this.Text.Length; 102045"];
4306 [label="FullWidth 102046"];
4307 [label="this.AdjustFlagsAndWidth(trailing); 102047"];
4308 [label="return 'or'; 102048"];
4309 [label="FullWidth = this.Text.Length; 102049"];
4310 [label="FullWidth 102050"];
4311 [label="this.AdjustFlagsAndWidth(trailing); 102051"];
4312 [label="return 'and'; 102052"];
4313 [label="FullWidth = this.Text.Length; 102053"];
4314 [label="FullWidth 102054"];
4315 [label="return 'and'; 102055"];
4316 [label="FullWidth = this.Text.Length; 102056"];
4317 [label="FullWidth 102057"];
4318 [label="this.AdjustFlagsAndWidth(leading); 102058"];
4319 [label="return 'and'; 102059"];
4320 [label="FullWidth = this.Text.Length; 102060"];
4321 [label="FullWidth 102061"];
4322 [label="this.AdjustFlagsAndWidth(trailing); 102062"];
4323 [label="return 'and'; 102063"];
4324 [label="FullWidth = this.Text.Length; 102064"];
4325 [label="FullWidth 102065"];
4326 [label="this.AdjustFlagsAndWidth(trailing); 102066"];
4327 [label="return 'not'; 102067"];
4328 [label="FullWidth = this.Text.Length; 102068"];
4329 [label="FullWidth 102069"];
4330 [label="return 'not'; 102070"];
4331 [label="FullWidth = this.Text.Length; 102071"];
4332 [label="FullWidth 102072"];
4333 [label="this.AdjustFlagsAndWidth(leading); 102073"];
4334 [label="return 'not'; 102074"];
4335 [label="FullWidth = this.Text.Length; 102075"];
4336 [label="FullWidth 102076"];
4337 [label="this.AdjustFlagsAndWidth(trailing); 102077"];
4338 [label="return 'not'; 102078"];
4339 [label="FullWidth = this.Text.Length; 102079"];
4340 [label="FullWidth 102080"];
4341 [label="this.AdjustFlagsAndWidth(trailing); 102081"];
4342 [label="return 'data'; 102082"];
4343 [label="FullWidth = this.Text.Length; 102083"];
4344 [label="FullWidth 102084"];
4345 [label="return 'data'; 102085"];
4346 [label="FullWidth = this.Text.Length; 102086"];
4347 [label="FullWidth 102087"];
4348 [label="this.AdjustFlagsAndWidth(leading); 102088"];
4349 [label="return 'data'; 102089"];
4350 [label="FullWidth = this.Text.Length; 102090"];
4351 [label="FullWidth 102091"];
4352 [label="this.AdjustFlagsAndWidth(trailing); 102092"];
4353 [label="return 'data'; 102093"];
4354 [label="FullWidth = this.Text.Length; 102094"];
4355 [label="FullWidth 102095"];
4356 [label="this.AdjustFlagsAndWidth(trailing); 102096"];
4357 [label="return 'with'; 102097"];
4358 [label="FullWidth = this.Text.Length; 102098"];
4359 [label="FullWidth 102099"];
4360 [label="return 'with'; 102100"];
4361 [label="FullWidth = this.Text.Length; 102101"];
4362 [label="FullWidth 102102"];
4363 [label="this.AdjustFlagsAndWidth(leading); 102103"];
4364 [label="return 'with'; 102104"];
4365 [label="FullWidth = this.Text.Length; 102105"];
4366 [label="FullWidth 102106"];
4367 [label="this.AdjustFlagsAndWidth(trailing); 102107"];
4368 [label="return 'with'; 102108"];
4369 [label="FullWidth = this.Text.Length; 102109"];
4370 [label="FullWidth 102110"];
4371 [label="this.AdjustFlagsAndWidth(trailing); 102111"];
4372 [label="return 'init'; 102112"];
4373 [label="FullWidth = this.Text.Length; 102113"];
4374 [label="FullWidth 102114"];
4375 [label="return 'init'; 102115"];
4376 [label="FullWidth = this.Text.Length; 102116"];
4377 [label="FullWidth 102117"];
4378 [label="this.AdjustFlagsAndWidth(leading); 102118"];
4379 [label="return 'init'; 102119"];
4380 [label="FullWidth = this.Text.Length; 102120"];
4381 [label="FullWidth 102121"];
4382 [label="this.AdjustFlagsAndWidth(trailing); 102122"];
4383 [label="return 'init'; 102123"];
4384 [label="FullWidth = this.Text.Length; 102124"];
4385 [label="FullWidth 102125"];
4386 [label="this.AdjustFlagsAndWidth(trailing); 102126"];
4387 [label="return 'record'; 102127"];
4388 [label="FullWidth = this.Text.Length; 102128"];
4389 [label="FullWidth 102129"];
4390 [label="return 'record'; 102130"];
4391 [label="FullWidth = this.Text.Length; 102131"];
4392 [label="FullWidth 102132"];
4393 [label="this.AdjustFlagsAndWidth(leading); 102133"];
4394 [label="return 'record'; 102134"];
4395 [label="FullWidth = this.Text.Length; 102135"];
4396 [label="FullWidth 102136"];
4397 [label="this.AdjustFlagsAndWidth(trailing); 102137"];
4398 [label="return 'record'; 102138"];
4399 [label="FullWidth = this.Text.Length; 102139"];
4400 [label="FullWidth 102140"];
4401 [label="this.AdjustFlagsAndWidth(trailing); 102141"];
4402 [label="return 'managed'; 102142"];
4403 [label="FullWidth = this.Text.Length; 102143"];
4404 [label="FullWidth 102144"];
4405 [label="return 'managed'; 102145"];
4406 [label="FullWidth = this.Text.Length; 102146"];
4407 [label="FullWidth 102147"];
4408 [label="this.AdjustFlagsAndWidth(leading); 102148"];
4409 [label="return 'managed'; 102149"];
4410 [label="FullWidth = this.Text.Length; 102150"];
4411 [label="FullWidth 102151"];
4412 [label="this.AdjustFlagsAndWidth(trailing); 102152"];
4413 [label="return 'managed'; 102153"];
4414 [label="FullWidth = this.Text.Length; 102154"];
4415 [label="FullWidth 102155"];
4416 [label="this.AdjustFlagsAndWidth(trailing); 102156"];
4417 [label="return 'unmanaged'; 102157"];
4418 [label="FullWidth = this.Text.Length; 102158"];
4419 [label="FullWidth 102159"];
4420 [label="return 'unmanaged'; 102160"];
4421 [label="FullWidth = this.Text.Length; 102161"];
4422 [label="FullWidth 102162"];
4423 [label="this.AdjustFlagsAndWidth(leading); 102163"];
4424 [label="return 'unmanaged'; 102164"];
4425 [label="FullWidth = this.Text.Length; 102165"];
4426 [label="FullWidth 102166"];
4427 [label="this.AdjustFlagsAndWidth(trailing); 102167"];
4428 [label="return 'unmanaged'; 102168"];
4429 [label="FullWidth = this.Text.Length; 102169"];
4430 [label="FullWidth 102170"];
4431 [label="this.AdjustFlagsAndWidth(trailing); 102171"];
4432 [label="return 'elif'; 102172"];
4433 [label="FullWidth = this.Text.Length; 102173"];
4434 [label="FullWidth 102174"];
4435 [label="return 'elif'; 102175"];
4436 [label="FullWidth = this.Text.Length; 102176"];
4437 [label="FullWidth 102177"];
4438 [label="this.AdjustFlagsAndWidth(leading); 102178"];
4439 [label="return 'elif'; 102179"];
4440 [label="FullWidth = this.Text.Length; 102180"];
4441 [label="FullWidth 102181"];
4442 [label="this.AdjustFlagsAndWidth(trailing); 102182"];
4443 [label="return 'elif'; 102183"];
4444 [label="FullWidth = this.Text.Length; 102184"];
4445 [label="FullWidth 102185"];
4446 [label="this.AdjustFlagsAndWidth(trailing); 102186"];
4447 [label="return 'endif'; 102187"];
4448 [label="FullWidth = this.Text.Length; 102188"];
4449 [label="FullWidth 102189"];
4450 [label="return 'endif'; 102190"];
4451 [label="FullWidth = this.Text.Length; 102191"];
4452 [label="FullWidth 102192"];
4453 [label="this.AdjustFlagsAndWidth(leading); 102193"];
4454 [label="return 'endif'; 102194"];
4455 [label="FullWidth = this.Text.Length; 102195"];
4456 [label="FullWidth 102196"];
4457 [label="this.AdjustFlagsAndWidth(trailing); 102197"];
4458 [label="return 'endif'; 102198"];
4459 [label="FullWidth = this.Text.Length; 102199"];
4460 [label="FullWidth 102200"];
4461 [label="this.AdjustFlagsAndWidth(trailing); 102201"];
4462 [label="return 'region'; 102202"];
4463 [label="FullWidth = this.Text.Length; 102203"];
4464 [label="FullWidth 102204"];
4465 [label="return 'region'; 102205"];
4466 [label="FullWidth = this.Text.Length; 102206"];
4467 [label="FullWidth 102207"];
4468 [label="this.AdjustFlagsAndWidth(leading); 102208"];
4469 [label="return 'region'; 102209"];
4470 [label="FullWidth = this.Text.Length; 102210"];
4471 [label="FullWidth 102211"];
4472 [label="this.AdjustFlagsAndWidth(trailing); 102212"];
4473 [label="return 'region'; 102213"];
4474 [label="FullWidth = this.Text.Length; 102214"];
4475 [label="FullWidth 102215"];
4476 [label="this.AdjustFlagsAndWidth(trailing); 102216"];
4477 [label="return 'endregion'; 102217"];
4478 [label="FullWidth = this.Text.Length; 102218"];
4479 [label="FullWidth 102219"];
4480 [label="return 'endregion'; 102220"];
4481 [label="FullWidth = this.Text.Length; 102221"];
4482 [label="FullWidth 102222"];
4483 [label="this.AdjustFlagsAndWidth(leading); 102223"];
4484 [label="return 'endregion'; 102224"];
4485 [label="FullWidth = this.Text.Length; 102225"];
4486 [label="FullWidth 102226"];
4487 [label="this.AdjustFlagsAndWidth(trailing); 102227"];
4488 [label="return 'endregion'; 102228"];
4489 [label="FullWidth = this.Text.Length; 102229"];
4490 [label="FullWidth 102230"];
4491 [label="this.AdjustFlagsAndWidth(trailing); 102231"];
4492 [label="return 'define'; 102232"];
4493 [label="FullWidth = this.Text.Length; 102233"];
4494 [label="FullWidth 102234"];
4495 [label="return 'define'; 102235"];
4496 [label="FullWidth = this.Text.Length; 102236"];
4497 [label="FullWidth 102237"];
4498 [label="this.AdjustFlagsAndWidth(leading); 102238"];
4499 [label="return 'define'; 102239"];
4500 [label="FullWidth = this.Text.Length; 102240"];
4501 [label="FullWidth 102241"];
4502 [label="this.AdjustFlagsAndWidth(trailing); 102242"];
4503 [label="return 'define'; 102243"];
4504 [label="FullWidth = this.Text.Length; 102244"];
4505 [label="FullWidth 102245"];
4506 [label="this.AdjustFlagsAndWidth(trailing); 102246"];
4507 [label="return 'undef'; 102247"];
4508 [label="FullWidth = this.Text.Length; 102248"];
4509 [label="FullWidth 102249"];
4510 [label="return 'undef'; 102250"];
4511 [label="FullWidth = this.Text.Length; 102251"];
4512 [label="FullWidth 102252"];
4513 [label="this.AdjustFlagsAndWidth(leading); 102253"];
4514 [label="return 'undef'; 102254"];
4515 [label="FullWidth = this.Text.Length; 102255"];
4516 [label="FullWidth 102256"];
4517 [label="this.AdjustFlagsAndWidth(trailing); 102257"];
4518 [label="return 'undef'; 102258"];
4519 [label="FullWidth = this.Text.Length; 102259"];
4520 [label="FullWidth 102260"];
4521 [label="this.AdjustFlagsAndWidth(trailing); 102261"];
4522 [label="return 'warning'; 102262"];
4523 [label="FullWidth = this.Text.Length; 102263"];
4524 [label="FullWidth 102264"];
4525 [label="return 'warning'; 102265"];
4526 [label="FullWidth = this.Text.Length; 102266"];
4527 [label="FullWidth 102267"];
4528 [label="this.AdjustFlagsAndWidth(leading); 102268"];
4529 [label="return 'warning'; 102269"];
4530 [label="FullWidth = this.Text.Length; 102270"];
4531 [label="FullWidth 102271"];
4532 [label="this.AdjustFlagsAndWidth(trailing); 102272"];
4533 [label="return 'warning'; 102273"];
4534 [label="FullWidth = this.Text.Length; 102274"];
4535 [label="FullWidth 102275"];
4536 [label="this.AdjustFlagsAndWidth(trailing); 102276"];
4537 [label="return 'error'; 102277"];
4538 [label="FullWidth = this.Text.Length; 102278"];
4539 [label="FullWidth 102279"];
4540 [label="return 'error'; 102280"];
4541 [label="FullWidth = this.Text.Length; 102281"];
4542 [label="FullWidth 102282"];
4543 [label="this.AdjustFlagsAndWidth(leading); 102283"];
4544 [label="return 'error'; 102284"];
4545 [label="FullWidth = this.Text.Length; 102285"];
4546 [label="FullWidth 102286"];
4547 [label="this.AdjustFlagsAndWidth(trailing); 102287"];
4548 [label="return 'error'; 102288"];
4549 [label="FullWidth = this.Text.Length; 102289"];
4550 [label="FullWidth 102290"];
4551 [label="this.AdjustFlagsAndWidth(trailing); 102291"];
4552 [label="return 'line'; 102292"];
4553 [label="FullWidth = this.Text.Length; 102293"];
4554 [label="FullWidth 102294"];
4555 [label="return 'line'; 102295"];
4556 [label="FullWidth = this.Text.Length; 102296"];
4557 [label="FullWidth 102297"];
4558 [label="this.AdjustFlagsAndWidth(leading); 102298"];
4559 [label="return 'line'; 102299"];
4560 [label="FullWidth = this.Text.Length; 102300"];
4561 [label="FullWidth 102301"];
4562 [label="this.AdjustFlagsAndWidth(trailing); 102302"];
4563 [label="return 'line'; 102303"];
4564 [label="FullWidth = this.Text.Length; 102304"];
4565 [label="FullWidth 102305"];
4566 [label="this.AdjustFlagsAndWidth(trailing); 102306"];
4567 [label="return 'pragma'; 102307"];
4568 [label="FullWidth = this.Text.Length; 102308"];
4569 [label="FullWidth 102309"];
4570 [label="return 'pragma'; 102310"];
4571 [label="FullWidth = this.Text.Length; 102311"];
4572 [label="FullWidth 102312"];
4573 [label="this.AdjustFlagsAndWidth(leading); 102313"];
4574 [label="return 'pragma'; 102314"];
4575 [label="FullWidth = this.Text.Length; 102315"];
4576 [label="FullWidth 102316"];
4577 [label="this.AdjustFlagsAndWidth(trailing); 102317"];
4578 [label="return 'pragma'; 102318"];
4579 [label="FullWidth = this.Text.Length; 102319"];
4580 [label="FullWidth 102320"];
4581 [label="this.AdjustFlagsAndWidth(trailing); 102321"];
4582 [label="return 'hidden'; 102322"];
4583 [label="FullWidth = this.Text.Length; 102323"];
4584 [label="FullWidth 102324"];
4585 [label="return 'hidden'; 102325"];
4586 [label="FullWidth = this.Text.Length; 102326"];
4587 [label="FullWidth 102327"];
4588 [label="this.AdjustFlagsAndWidth(leading); 102328"];
4589 [label="return 'hidden'; 102329"];
4590 [label="FullWidth = this.Text.Length; 102330"];
4591 [label="FullWidth 102331"];
4592 [label="this.AdjustFlagsAndWidth(trailing); 102332"];
4593 [label="return 'hidden'; 102333"];
4594 [label="FullWidth = this.Text.Length; 102334"];
4595 [label="FullWidth 102335"];
4596 [label="this.AdjustFlagsAndWidth(trailing); 102336"];
4597 [label="return 'checksum'; 102337"];
4598 [label="FullWidth = this.Text.Length; 102338"];
4599 [label="FullWidth 102339"];
4600 [label="return 'checksum'; 102340"];
4601 [label="FullWidth = this.Text.Length; 102341"];
4602 [label="FullWidth 102342"];
4603 [label="this.AdjustFlagsAndWidth(leading); 102343"];
4604 [label="return 'checksum'; 102344"];
4605 [label="FullWidth = this.Text.Length; 102345"];
4606 [label="FullWidth 102346"];
4607 [label="this.AdjustFlagsAndWidth(trailing); 102347"];
4608 [label="return 'checksum'; 102348"];
4609 [label="FullWidth = this.Text.Length; 102349"];
4610 [label="FullWidth 102350"];
4611 [label="this.AdjustFlagsAndWidth(trailing); 102351"];
4612 [label="return 'disable'; 102352"];
4613 [label="FullWidth = this.Text.Length; 102353"];
4614 [label="FullWidth 102354"];
4615 [label="return 'disable'; 102355"];
4616 [label="FullWidth = this.Text.Length; 102356"];
4617 [label="FullWidth 102357"];
4618 [label="this.AdjustFlagsAndWidth(leading); 102358"];
4619 [label="return 'disable'; 102359"];
4620 [label="FullWidth = this.Text.Length; 102360"];
4621 [label="FullWidth 102361"];
4622 [label="this.AdjustFlagsAndWidth(trailing); 102362"];
4623 [label="return 'disable'; 102363"];
4624 [label="FullWidth = this.Text.Length; 102364"];
4625 [label="FullWidth 102365"];
4626 [label="this.AdjustFlagsAndWidth(trailing); 102366"];
4627 [label="return 'restore'; 102367"];
4628 [label="FullWidth = this.Text.Length; 102368"];
4629 [label="FullWidth 102369"];
4630 [label="return 'restore'; 102370"];
4631 [label="FullWidth = this.Text.Length; 102371"];
4632 [label="FullWidth 102372"];
4633 [label="this.AdjustFlagsAndWidth(leading); 102373"];
4634 [label="return 'restore'; 102374"];
4635 [label="FullWidth = this.Text.Length; 102375"];
4636 [label="FullWidth 102376"];
4637 [label="this.AdjustFlagsAndWidth(trailing); 102377"];
4638 [label="return 'restore'; 102378"];
4639 [label="FullWidth = this.Text.Length; 102379"];
4640 [label="FullWidth 102380"];
4641 [label="this.AdjustFlagsAndWidth(trailing); 102381"];
4642 [label="return 'r'; 102382"];
4643 [label="FullWidth = this.Text.Length; 102383"];
4644 [label="FullWidth 102384"];
4645 [label="return 'r'; 102385"];
4646 [label="FullWidth = this.Text.Length; 102386"];
4647 [label="FullWidth 102387"];
4648 [label="this.AdjustFlagsAndWidth(leading); 102388"];
4649 [label="return 'r'; 102389"];
4650 [label="FullWidth = this.Text.Length; 102390"];
4651 [label="FullWidth 102391"];
4652 [label="this.AdjustFlagsAndWidth(trailing); 102392"];
4653 [label="return 'r'; 102393"];
4654 [label="FullWidth = this.Text.Length; 102394"];
4655 [label="FullWidth 102395"];
4656 [label="this.AdjustFlagsAndWidth(trailing); 102396"];
4657 [label="return '$\\''; 102397"];
4658 [label="FullWidth = this.Text.Length; 102398"];
4659 [label="FullWidth 102399"];
4660 [label="return '$\\''; 102400"];
4661 [label="FullWidth = this.Text.Length; 102401"];
4662 [label="FullWidth 102402"];
4663 [label="this.AdjustFlagsAndWidth(leading); 102403"];
4664 [label="return '$\\''; 102404"];
4665 [label="FullWidth = this.Text.Length; 102405"];
4666 [label="FullWidth 102406"];
4667 [label="this.AdjustFlagsAndWidth(trailing); 102407"];
4668 [label="return '$\\''; 102408"];
4669 [label="FullWidth = this.Text.Length; 102409"];
4670 [label="FullWidth 102410"];
4671 [label="this.AdjustFlagsAndWidth(trailing); 102411"];
4672 [label="return '\\''; 102412"];
4673 [label="FullWidth = this.Text.Length; 102413"];
4674 [label="FullWidth 102414"];
4675 [label="return '\\''; 102415"];
4676 [label="FullWidth = this.Text.Length; 102416"];
4677 [label="FullWidth 102417"];
4678 [label="this.AdjustFlagsAndWidth(leading); 102418"];
4679 [label="return '\\''; 102419"];
4680 [label="FullWidth = this.Text.Length; 102420"];
4681 [label="FullWidth 102421"];
4682 [label="this.AdjustFlagsAndWidth(trailing); 102422"];
4683 [label="return '\\''; 102423"];
4684 [label="FullWidth = this.Text.Length; 102424"];
4685 [label="FullWidth 102425"];
4686 [label="this.AdjustFlagsAndWidth(trailing); 102426"];
4687 [label="return '$@\\''; 102427"];
4688 [label="FullWidth = this.Text.Length; 102428"];
4689 [label="FullWidth 102429"];
4690 [label="return '$@\\''; 102430"];
4691 [label="FullWidth = this.Text.Length; 102431"];
4692 [label="FullWidth 102432"];
4693 [label="this.AdjustFlagsAndWidth(leading); 102433"];
4694 [label="return '$@\\''; 102434"];
4695 [label="FullWidth = this.Text.Length; 102435"];
4696 [label="FullWidth 102436"];
4697 [label="this.AdjustFlagsAndWidth(trailing); 102437"];
4698 [label="return '$@\\''; 102438"];
4699 [label="FullWidth = this.Text.Length; 102439"];
4700 [label="FullWidth 102440"];
4701 [label="this.AdjustFlagsAndWidth(trailing); 102441"];
4702 [label="return 'load'; 102442"];
4703 [label="FullWidth = this.Text.Length; 102443"];
4704 [label="FullWidth 102444"];
4705 [label="return 'load'; 102445"];
4706 [label="FullWidth = this.Text.Length; 102446"];
4707 [label="FullWidth 102447"];
4708 [label="this.AdjustFlagsAndWidth(leading); 102448"];
4709 [label="return 'load'; 102449"];
4710 [label="FullWidth = this.Text.Length; 102450"];
4711 [label="FullWidth 102451"];
4712 [label="this.AdjustFlagsAndWidth(trailing); 102452"];
4713 [label="return 'load'; 102453"];
4714 [label="FullWidth = this.Text.Length; 102454"];
4715 [label="FullWidth 102455"];
4716 [label="this.AdjustFlagsAndWidth(trailing); 102456"];
4717 [label="return 'nullable'; 102457"];
4718 [label="FullWidth = this.Text.Length; 102458"];
4719 [label="FullWidth 102459"];
4720 [label="return 'nullable'; 102460"];
4721 [label="FullWidth = this.Text.Length; 102461"];
4722 [label="FullWidth 102462"];
4723 [label="this.AdjustFlagsAndWidth(leading); 102463"];
4724 [label="return 'nullable'; 102464"];
4725 [label="FullWidth = this.Text.Length; 102465"];
4726 [label="FullWidth 102466"];
4727 [label="this.AdjustFlagsAndWidth(trailing); 102467"];
4728 [label="return 'nullable'; 102468"];
4729 [label="FullWidth = this.Text.Length; 102469"];
4730 [label="FullWidth 102470"];
4731 [label="this.AdjustFlagsAndWidth(trailing); 102471"];
4732 [label="return 'enable'; 102472"];
4733 [label="FullWidth = this.Text.Length; 102473"];
4734 [label="FullWidth 102474"];
4735 [label="return 'enable'; 102475"];
4736 [label="FullWidth = this.Text.Length; 102476"];
4737 [label="FullWidth 102477"];
4738 [label="this.AdjustFlagsAndWidth(leading); 102478"];
4739 [label="return 'enable'; 102479"];
4740 [label="FullWidth = this.Text.Length; 102480"];
4741 [label="FullWidth 102481"];
4742 [label="this.AdjustFlagsAndWidth(trailing); 102482"];
4743 [label="return 'enable'; 102483"];
4744 [label="FullWidth = this.Text.Length; 102484"];
4745 [label="FullWidth 102485"];
4746 [label="this.AdjustFlagsAndWidth(trailing); 102486"];
4747 [label="return 'warnings'; 102487"];
4748 [label="FullWidth = this.Text.Length; 102488"];
4749 [label="FullWidth 102489"];
4750 [label="return 'warnings'; 102490"];
4751 [label="FullWidth = this.Text.Length; 102491"];
4752 [label="FullWidth 102492"];
4753 [label="this.AdjustFlagsAndWidth(leading); 102493"];
4754 [label="return 'warnings'; 102494"];
4755 [label="FullWidth = this.Text.Length; 102495"];
4756 [label="FullWidth 102496"];
4757 [label="this.AdjustFlagsAndWidth(trailing); 102497"];
4758 [label="return 'warnings'; 102498"];
4759 [label="FullWidth = this.Text.Length; 102499"];
4760 [label="FullWidth 102500"];
4761 [label="this.AdjustFlagsAndWidth(trailing); 102501"];
4762 [label="return 'annotations'; 102502"];
4763 [label="FullWidth = this.Text.Length; 102503"];
4764 [label="FullWidth 102504"];
4765 [label="return 'annotations'; 102505"];
4766 [label="FullWidth = this.Text.Length; 102506"];
4767 [label="FullWidth 102507"];
4768 [label="this.AdjustFlagsAndWidth(leading); 102508"];
4769 [label="return 'annotations'; 102509"];
4770 [label="FullWidth = this.Text.Length; 102510"];
4771 [label="FullWidth 102511"];
4772 [label="this.AdjustFlagsAndWidth(trailing); 102512"];
4773 [label="return 'annotations'; 102513"];
4774 [label="FullWidth = this.Text.Length; 102514"];
4775 [label="FullWidth 102515"];
4776 [label="this.AdjustFlagsAndWidth(trailing); 102516"];
4777 [label="return 'var'; 102517"];
4778 [label="FullWidth = this.Text.Length; 102518"];
4779 [label="FullWidth 102519"];
4780 [label="return 'var'; 102520"];
4781 [label="FullWidth = this.Text.Length; 102521"];
4782 [label="FullWidth 102522"];
4783 [label="this.AdjustFlagsAndWidth(leading); 102523"];
4784 [label="return 'var'; 102524"];
4785 [label="FullWidth = this.Text.Length; 102525"];
4786 [label="FullWidth 102526"];
4787 [label="this.AdjustFlagsAndWidth(trailing); 102527"];
4788 [label="return 'var'; 102528"];
4789 [label="FullWidth = this.Text.Length; 102529"];
4790 [label="FullWidth 102530"];
4791 [label="this.AdjustFlagsAndWidth(trailing); 102531"];
4792 [label="return '_'; 102532"];
4793 [label="FullWidth = this.Text.Length; 102533"];
4794 [label="FullWidth 102534"];
4795 [label="return '_'; 102535"];
4796 [label="FullWidth = this.Text.Length; 102536"];
4797 [label="FullWidth 102537"];
4798 [label="this.AdjustFlagsAndWidth(leading); 102538"];
4799 [label="return '_'; 102539"];
4800 [label="FullWidth = this.Text.Length; 102540"];
4801 [label="FullWidth 102541"];
4802 [label="this.AdjustFlagsAndWidth(trailing); 102542"];
4803 [label="return '_'; 102543"];
4804 [label="FullWidth = this.Text.Length; 102544"];
4805 [label="FullWidth 102545"];
4806 [label="this.AdjustFlagsAndWidth(trailing); 102546"];
4807 [label="return SyntaxToken.Create(kind, leading, trailing); 102547"];
4808 [label="return SyntaxToken.Create(kind, leading, trailing); 102548"];
4809 [label="return SyntaxToken.Create(kind, leading, trailing); 102549"];
4810 [label="SyntaxToken.Create(kind, leading, trailing) 102550"];
4811 [label="param Create(SyntaxKind kind) 102551"];
4812 [label="param Create(GreenNode leading) 102552"];
4813 [label="param Create(GreenNode trailing) 102553"];
4814 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 102554"];
4815 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 102555"];
4816 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 102556"];
4817 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 102557"];
4818 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 102558"];
4819 [label="return s_tokensWithNoTrivia[(int)kind].Value; 102559"];
4820 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102560"];
4821 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102561"];
4822 [label="return token; 102562"];
4823 [label="this.AddLexedToken(token); 102563"];
4824 [label="this.AddLexedToken(token) 102564"];
4825 [label="param AddLexedToken(SyntaxToken token) 102565"];
4826 [label="param AddLexedToken(this) 102566"];
4827 [label="Debug.Assert(token != null); 102567"];
4828 [label="Debug.Assert(token != null); 102568"];
4829 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 102569"];
4830 [label="_lexedTokens[_tokenCount].Value = token; 102570"];
4831 [label="_lexedTokens[_tokenCount].Value 102571"];
4832 [label="_tokenCount 102572"];
4833 [label="this.AddLexedToken(token); 102573"];
4834 [label="token.Kind 102574"];
4835 [label="get { return (SyntaxKind)this.RawKind; } 102575"];
4836 [label="return (SyntaxKind)this.RawKind; 102576"];
4837 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 102577"];
4838 [label="TextWindow.Start(); 102578"];
4839 [label="get\n            {\n                return _lexemeStart;\n            } 102579"];
4840 [label="return _lexemeStart; 102580"];
4841 [label="param LookupToken(char[] textBuffer) 102581"];
4842 [label="param LookupToken(int keyStart) 102582"];
4843 [label="param LookupToken(int keyLength) 102583"];
4844 [label="param LookupToken(int hashCode) 102584"];
4845 [label="param LookupToken(Func<SyntaxToken> createTokenFunction) 102585"];
4846 [label="param LookupToken(this) 102586"];
4847 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 102587"];
4848 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 102588"];
4849 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 102589"];
4850 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 102590"];
4851 [label="var value = _tokenMap.FindItem(textBuffer, keyStart, keyLength, hashCode); 102591"];
4852 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 102592"];
4853 [label="if (value == null)\n            {\n#if COLLECT_STATS\n                    Miss();\n#endif\n                value = createTokenFunction();\n                _tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value);\n            }\n            else\n            {\n#if COLLECT_STATS\n                    Hit();\n#endif\n            } 102593"];
4854 [label="value = createTokenFunction(); 102594"];
4855 [label="value = createTokenFunction(); 102595"];
4856 [label="param CreateQuickToken(this) 102596"];
4857 [label="TextWindow.Width 102597"];
4858 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 102598"];
4859 [label="return _offset - _lexemeStart; 102599"];
4860 [label="var quickWidth = TextWindow.Width; 102600"];
4861 [label="TextWindow.LexemeStartPosition 102601"];
4862 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 102602"];
4863 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 102603"];
4864 [label="TextWindow.Reset(TextWindow.LexemeStartPosition) 102604"];
4865 [label="param Reset(int position) 102605"];
4866 [label="param Reset(this) 102606"];
4867 [label="TextWindow.Reset(TextWindow.LexemeStartPosition); 102607"];
4868 [label="this.LexSyntaxToken() 102608"];
4869 [label="param LexSyntaxToken(this) 102609"];
4870 [label="_leadingTriviaCache.Clear(); 102610"];
4871 [label="TextWindow.Position 102611"];
4872 [label="get\n            {\n                return _basis + _offset;\n            } 102612"];
4873 [label="param LexSyntaxTrivia(bool afterFirstToken) 102613"];
4874 [label="param LexSyntaxTrivia(bool isTrailing) 102614"];
4875 [label="bool onlyWhitespaceOnLine = !isTrailing; 102615"];
4876 [label="TextWindow.Start(); 102616"];
4877 [label="this.Start(); 102617"];
4878 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102618"];
4879 [label="char ch = TextWindow.PeekChar(); 102619"];
4880 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102620"];
4881 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102621"];
4882 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102622"];
4883 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102623"];
4884 [label="return; 102624"];
4885 [label="this.Start(); 102625"];
4886 [label="param AdvanceChar(this) 102626"];
4887 [label="_offset 102627"];
4888 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102628"];
4889 [label="GetFullWidth(leading) 102629"];
4890 [label="param GetFullWidth(SyntaxListBuilder builder) 102630"];
4891 [label="int width = 0; 102631"];
4892 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102632"];
4893 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102633"];
4894 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102634"];
4895 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102635"];
4896 [label="return width; 102636"];
4897 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102637"];
4898 [label="this.GetErrors(GetFullWidth(leading)) 102638"];
4899 [label="param GetErrors(int leadingTriviaWidth) 102639"];
4900 [label="param GetErrors(this) 102640"];
4901 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102641"];
4902 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102642"];
4903 [label="return null; 102643"];
4904 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102644"];
4905 [label="param LexSyntaxTrivia(bool afterFirstToken) 102645"];
4906 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102646"];
4907 [label="char ch = TextWindow.PeekChar(); 102647"];
4908 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102648"];
4909 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102649"];
4910 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102650"];
4911 [label="return; 102651"];
4912 [label="param Create(ref TokenInfo info) 102652"];
4913 [label="param Create(SyntaxDiagnosticInfo[] errors) 102653"];
4914 [label="param Create(this) 102654"];
4915 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102655"];
4916 [label="SyntaxToken token; 102656"];
4917 [label="if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            } 102657"];
4918 [label="switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate 'value' for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                } 102658"];
4919 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 102659"];
4920 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 102660"];
4921 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 102661"];
4922 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 102662"];
4923 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 102663"];
4924 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 102664"];
4925 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 102665"];
4926 [label="param Token(GreenNode leading) 102666"];
4927 [label="param Token(SyntaxKind kind) 102667"];
4928 [label="param Token(GreenNode trailing) 102668"];
4929 [label="return SyntaxToken.Create(kind, leading, trailing); 102669"];
4930 [label="return SyntaxToken.Create(kind, leading, trailing); 102670"];
4931 [label="return SyntaxToken.Create(kind, leading, trailing); 102671"];
4932 [label="SyntaxToken.Create(kind, leading, trailing) 102672"];
4933 [label="param Create(SyntaxKind kind) 102673"];
4934 [label="param Create(GreenNode leading) 102674"];
4935 [label="param Create(GreenNode trailing) 102675"];
4936 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 102676"];
4937 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 102677"];
4938 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                }\n            } 102678"];
4939 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 102679"];
4940 [label="if (trailing == null)\n                {\n                    return s_tokensWithNoTrivia[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 102680"];
4941 [label="return s_tokensWithNoTrivia[(int)kind].Value; 102681"];
4942 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102682"];
4943 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102683"];
4944 [label="return token; 102684"];
4945 [label="var token = this.LexSyntaxToken(); 102685"];
4946 [label="Debug.Assert(quickWidth == token.FullWidth); 102686"];
4947 [label="return token; 102687"];
4948 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 102688"];
4949 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 102689"];
4950 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 102690"];
4951 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 102691"];
4952 [label="_tokenMap.AddItem(textBuffer, keyStart, keyLength, hashCode, value); 102692"];
4953 [label="return value; 102693"];
4954 [label="return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken(); 102694"];
4955 [label="this.AddLexedToken(token); 102695"];
4956 [label="param AddLexedToken(SyntaxToken token) 102696"];
4957 [label="Debug.Assert(token != null); 102697"];
4958 [label="if (_tokenCount >= _lexedTokens.Length)\n            {\n                this.AddLexedTokenSlot();\n            } 102698"];
4959 [label="_lexedTokens[_tokenCount].Value = token; 102699"];
4960 [label="_lexedTokens[_tokenCount].Value 102700"];
4961 [label="get { return (SyntaxKind)this.RawKind; } 102701"];
4962 [label="return (SyntaxKind)this.RawKind; 102702"];
4963 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 102703"];
4964 [label="TextWindow.Start(); 102704"];
4965 [label="TextWindow.Width 102705"];
4966 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 102706"];
4967 [label="return _offset - _lexemeStart; 102707"];
4968 [label="var quickWidth = TextWindow.Width; 102708"];
4969 [label="TextWindow.Position 102709"];
4970 [label="param LexSyntaxTrivia(bool afterFirstToken) 102710"];
4971 [label="param LexSyntaxTrivia(bool isTrailing) 102711"];
4972 [label="bool onlyWhitespaceOnLine = !isTrailing; 102712"];
4973 [label="this.Start(); 102713"];
4974 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102714"];
4975 [label="char ch = TextWindow.PeekChar(); 102715"];
4976 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102716"];
4977 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102717"];
4978 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102718"];
4979 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102719"];
4980 [label="return; 102720"];
4981 [label="this.Start(); 102721"];
4982 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102722"];
4983 [label="param TryGetKeywordKind(out SyntaxKind kind) 102723"];
4984 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 102724"];
4985 [label="return SyntaxKind.None; 102725"];
4986 [label="param GetContextualKeywordKind(string text) 102726"];
4987 [label="switch (text)\n            {\n                case 'yield':\n                    return SyntaxKind.YieldKeyword;\n                case 'partial':\n                    return SyntaxKind.PartialKeyword;\n                case 'from':\n                    return SyntaxKind.FromKeyword;\n                case 'group':\n                    return SyntaxKind.GroupKeyword;\n                case 'join':\n                    return SyntaxKind.JoinKeyword;\n                case 'into':\n                    return SyntaxKind.IntoKeyword;\n                case 'let':\n                    return SyntaxKind.LetKeyword;\n                case 'by':\n                    return SyntaxKind.ByKeyword;\n                case 'where':\n                    return SyntaxKind.WhereKeyword;\n                case 'select':\n                    return SyntaxKind.SelectKeyword;\n                case 'get':\n                    return SyntaxKind.GetKeyword;\n                case 'set':\n                    return SyntaxKind.SetKeyword;\n                case 'add':\n                    return SyntaxKind.AddKeyword;\n                case 'remove':\n                    return SyntaxKind.RemoveKeyword;\n                case 'orderby':\n                    return SyntaxKind.OrderByKeyword;\n                case 'alias':\n                    return SyntaxKind.AliasKeyword;\n                case 'on':\n                    return SyntaxKind.OnKeyword;\n                case 'equals':\n                    return SyntaxKind.EqualsKeyword;\n                case 'ascending':\n                    return SyntaxKind.AscendingKeyword;\n                case 'descending':\n                    return SyntaxKind.DescendingKeyword;\n                case 'assembly':\n                    return SyntaxKind.AssemblyKeyword;\n                case 'module':\n                    return SyntaxKind.ModuleKeyword;\n                case 'type':\n                    return SyntaxKind.TypeKeyword;\n                case 'field':\n                    return SyntaxKind.FieldKeyword;\n                case 'method':\n                    return SyntaxKind.MethodKeyword;\n                case 'param':\n                    return SyntaxKind.ParamKeyword;\n                case 'property':\n                    return SyntaxKind.PropertyKeyword;\n                case 'typevar':\n                    return SyntaxKind.TypeVarKeyword;\n                case 'global':\n                    return SyntaxKind.GlobalKeyword;\n                case 'async':\n                    return SyntaxKind.AsyncKeyword;\n                case 'await':\n                    return SyntaxKind.AwaitKeyword;\n                case 'when':\n                    return SyntaxKind.WhenKeyword;\n                case 'nameof':\n                    return SyntaxKind.NameOfKeyword;\n                case '_':\n                    return SyntaxKind.UnderscoreToken;\n                case 'var':\n                    return SyntaxKind.VarKeyword;\n                case 'and':\n                    return SyntaxKind.AndKeyword;\n                case 'or':\n                    return SyntaxKind.OrKeyword;\n                case 'not':\n                    return SyntaxKind.NotKeyword;\n                case 'data':\n                    return SyntaxKind.DataKeyword;\n                case 'with':\n                    return SyntaxKind.WithKeyword;\n                case 'init':\n                    return SyntaxKind.InitKeyword;\n                case 'record':\n                    return SyntaxKind.RecordKeyword;\n                case 'managed':\n                    return SyntaxKind.ManagedKeyword;\n                case 'unmanaged':\n                    return SyntaxKind.UnmanagedKeyword;\n                default:\n                    return SyntaxKind.None;\n            } 102727"];
4988 [label="return SyntaxKind.None; 102728"];
4989 [label="kind = _keywordKindMap.GetOrMakeValue(key); 102729"];
4990 [label="return kind != SyntaxKind.None; 102730"];
4991 [label="info.Kind 102731"];
4992 [label="info.ContextualKind 102732"];
4993 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 102733"];
4994 [label="this.ScanSyntaxToken(ref tokenInfo); 102734"];
4995 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102735"];
4996 [label="GetFullWidth(leading) 102736"];
4997 [label="param GetFullWidth(SyntaxListBuilder builder) 102737"];
4998 [label="int width = 0; 102738"];
4999 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102739"];
5000 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102740"];
5001 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102741"];
5002 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102742"];
5003 [label="return width; 102743"];
5004 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102744"];
5005 [label="this.GetErrors(GetFullWidth(leading)) 102745"];
5006 [label="param GetErrors(int leadingTriviaWidth) 102746"];
5007 [label="param GetErrors(this) 102747"];
5008 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102748"];
5009 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102749"];
5010 [label="return null; 102750"];
5011 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102751"];
5012 [label="param LexSyntaxTrivia(bool afterFirstToken) 102752"];
5013 [label="param LexSyntaxTrivia(bool isTrailing) 102753"];
5014 [label="bool onlyWhitespaceOnLine = !isTrailing; 102754"];
5015 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102755"];
5016 [label="char ch = TextWindow.PeekChar(); 102756"];
5017 [label="if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102757"];
5018 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 102758"];
5019 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 102759"];
5020 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102760"];
5021 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 102761"];
5022 [label="return _offset - _lexemeStart; 102762"];
5023 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList); 102763"];
5024 [label="this.AddTrivia(this.ScanWhitespace(), ref triviaList) 102764"];
5025 [label="param AddTrivia(CSharpSyntaxNode trivia) 102765"];
5026 [label="param AddTrivia(ref SyntaxListBuilder list) 102766"];
5027 [label="param AddTrivia(this) 102767"];
5028 [label="this.HasErrors 102768"];
5029 [label="get { return _errors != null; } 102769"];
5030 [label="return _errors != null; 102770"];
5031 [label="return _errors != null; 102771"];
5032 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 102772"];
5033 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 102773"];
5034 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 102774"];
5035 [label="list.Add(trivia); 102775"];
5036 [label="list.Add(trivia); 102776"];
5037 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102777"];
5038 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102778"];
5039 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102779"];
5040 [label="return; 102780"];
5041 [label="param Create(SyntaxDiagnosticInfo[] errors) 102781"];
5042 [label="param Create(this) 102782"];
5043 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102783"];
5044 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102784"];
5045 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102785"];
5046 [label="SyntaxToken token; 102786"];
5047 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 102787"];
5048 [label="token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode); 102788"];
5049 [label="SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode) 102789"];
5050 [label="param Identifier(SyntaxKind contextualKind) 102790"];
5051 [label="param Identifier(GreenNode leading) 102791"];
5052 [label="param Identifier(string text) 102792"];
5053 [label="param Identifier(string valueText) 102793"];
5054 [label="param Identifier(GreenNode trailing) 102794"];
5055 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 102795"];
5056 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 102796"];
5057 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 102797"];
5058 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 102798"];
5059 [label="return SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing); 102799"];
5060 [label="SyntaxToken.Identifier(contextualKind, leading, text, valueText, trailing) 102800"];
5061 [label="param Identifier(SyntaxKind contextualKind) 102801"];
5062 [label="param Identifier(GreenNode leading) 102802"];
5063 [label="param Identifier(string text) 102803"];
5064 [label="param Identifier(string valueText) 102804"];
5065 [label="param Identifier(GreenNode trailing) 102805"];
5066 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 102806"];
5067 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 102807"];
5068 [label="if (contextualKind == SyntaxKind.IdentifierToken && valueText == text)\n            {\n                return Identifier(leading, text, trailing);\n            } 102808"];
5069 [label="return Identifier(leading, text, trailing); 102809"];
5070 [label="return Identifier(leading, text, trailing); 102810"];
5071 [label="return Identifier(leading, text, trailing); 102811"];
5072 [label="Identifier(leading, text, trailing) 102812"];
5073 [label="param Identifier(GreenNode leading) 102813"];
5074 [label="param Identifier(string text) 102814"];
5075 [label="param Identifier(GreenNode trailing) 102815"];
5076 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 102816"];
5077 [label="if (leading == null)\n            {\n                if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                }\n            } 102817"];
5078 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 102818"];
5079 [label="if (trailing == null)\n                {\n                    return Identifier(text);\n                }\n                else\n                {\n                    return new SyntaxIdentifierWithTrailingTrivia(text, trailing);\n                } 102819"];
5080 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrailingTrivia), r => new SyntaxIdentifierWithTrailingTrivia(r)); 102820"];
5081 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 102821"];
5082 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 102822"];
5083 [label="return new SyntaxIdentifierWithTrailingTrivia(text, trailing); 102823"];
5084 [label="new SyntaxIdentifierWithTrailingTrivia(text, trailing) 102824"];
5085 [label="param SyntaxIdentifierWithTrailingTrivia(string text) 102825"];
5086 [label="param SyntaxIdentifierWithTrailingTrivia(GreenNode trailing) 102826"];
5087 [label="param SyntaxIdentifierWithTrailingTrivia(this) 102827"];
5088 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r)); 102828"];
5089 [label="text 102829"];
5090 [label="param SyntaxIdentifierWithTrailingTrivia(this) 102830"];
5091 [label="param SyntaxIdentifier(string text) 102831"];
5092 [label="param SyntaxIdentifier(this) 102832"];
5093 [label="SyntaxKind.IdentifierToken 102833"];
5094 [label="text 102834"];
5095 [label="param SyntaxIdentifier(this) 102835"];
5096 [label="param SyntaxToken(SyntaxKind kind) 102836"];
5097 [label="param SyntaxToken(int fullWidth) 102837"];
5098 [label="param SyntaxToken(this) 102838"];
5099 [label="kind 102839"];
5100 [label="fullWidth 102840"];
5101 [label="param SyntaxToken(this) 102841"];
5102 [label="param CSharpSyntaxNode(SyntaxKind kind) 102842"];
5103 [label="param CSharpSyntaxNode(int fullWidth) 102843"];
5104 [label="param CSharpSyntaxNode(this) 102844"];
5105 [label="kind 102845"];
5106 [label="fullWidth 102846"];
5107 [label="param CSharpSyntaxNode(this) 102847"];
5108 [label="param CSharpSyntaxNode(this) 102848"];
5109 [label="GreenStats.NoteGreen(this); 102849"];
5110 [label="GreenStats.NoteGreen(this); 102850"];
5111 [label="this.flags |= NodeFlags.IsNotMissing; 102851"];
5112 [label="this.flags 102852"];
5113 [label="TextField 102853"];
5114 [label="this.TextField 102854"];
5115 [label="_trailing 102855"];
5116 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 102856"];
5117 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 102857"];
5118 [label="this.AdjustFlagsAndWidth(trailing); 102858"];
5119 [label="this.AdjustFlagsAndWidth(trailing); 102859"];
5120 [label="_trailing 102860"];
5121 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102861"];
5122 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102862"];
5123 [label="Debug.Assert(quickWidth == token.FullWidth); 102863"];
5124 [label="value = createTokenFunction(); 102864"];
5125 [label="this.AddLexedToken(token); 102865"];
5126 [label="param AddLexedToken(SyntaxToken token) 102866"];
5127 [label="Debug.Assert(token != null); 102867"];
5128 [label="_lexedTokens[_tokenCount].Value 102868"];
5129 [label="get { return (SyntaxKind)this.RawKind; } 102869"];
5130 [label="return (SyntaxKind)this.RawKind; 102870"];
5131 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 102871"];
5132 [label="TextWindow.Start(); 102872"];
5133 [label="TextWindow.Width 102873"];
5134 [label="var quickWidth = TextWindow.Width; 102874"];
5135 [label="param LexSyntaxTrivia(bool afterFirstToken) 102875"];
5136 [label="param LexSyntaxTrivia(bool isTrailing) 102876"];
5137 [label="bool onlyWhitespaceOnLine = !isTrailing; 102877"];
5138 [label="this.Start(); 102878"];
5139 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102879"];
5140 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102880"];
5141 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102881"];
5142 [label="return; 102882"];
5143 [label="this.Start(); 102883"];
5144 [label="param TryGetKeywordKind(out SyntaxKind kind) 102884"];
5145 [label="if (key.Length > MaxKeywordLength)\n            {\n                kind = SyntaxKind.None;\n                return false;\n            } 102885"];
5146 [label="if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    } 102886"];
5147 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102887"];
5148 [label="GetFullWidth(leading) 102888"];
5149 [label="param GetFullWidth(SyntaxListBuilder builder) 102889"];
5150 [label="int width = 0; 102890"];
5151 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102891"];
5152 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102892"];
5153 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102893"];
5154 [label="return width; 102894"];
5155 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102895"];
5156 [label="this.GetErrors(GetFullWidth(leading)) 102896"];
5157 [label="param GetErrors(int leadingTriviaWidth) 102897"];
5158 [label="param GetErrors(this) 102898"];
5159 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102899"];
5160 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102900"];
5161 [label="return null; 102901"];
5162 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102902"];
5163 [label="param AddTrivia(this) 102903"];
5164 [label="this.HasErrors 102904"];
5165 [label="get { return _errors != null; } 102905"];
5166 [label="return _errors != null; 102906"];
5167 [label="return _errors != null; 102907"];
5168 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 102908"];
5169 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 102909"];
5170 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 102910"];
5171 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102911"];
5172 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102912"];
5173 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102913"];
5174 [label="if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        } 102914"];
5175 [label="return; 102915"];
5176 [label="param Create(SyntaxDiagnosticInfo[] errors) 102916"];
5177 [label="param Create(this) 102917"];
5178 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102918"];
5179 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102919"];
5180 [label="SyntaxToken token; 102920"];
5181 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102921"];
5182 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102922"];
5183 [label="Debug.Assert(quickWidth == token.FullWidth); 102923"];
5184 [label="this.AddLexedToken(token); 102924"];
5185 [label="param AddLexedToken(SyntaxToken token) 102925"];
5186 [label="Debug.Assert(token != null); 102926"];
5187 [label="_lexedTokens[_tokenCount].Value 102927"];
5188 [label="get { return (SyntaxKind)this.RawKind; } 102928"];
5189 [label="return (SyntaxKind)this.RawKind; 102929"];
5190 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 102930"];
5191 [label="TextWindow.Start(); 102931"];
5192 [label="var quickWidth = TextWindow.Width; 102932"];
5193 [label="param LexSyntaxTrivia(bool afterFirstToken) 102933"];
5194 [label="param LexSyntaxTrivia(bool isTrailing) 102934"];
5195 [label="bool onlyWhitespaceOnLine = !isTrailing; 102935"];
5196 [label="this.Start(); 102936"];
5197 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102937"];
5198 [label="switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n\n                    // Note: we specifically do not look for the >>>>>>> pattern as the start of\n                    // a conflict marker trivia.  That's because *technically* (albeit unlikely)\n                    // >>>>>>> could be the end of a very generic construct.  So, instead, we only\n                    // recognize >>>>>>> as we are scanning the trivia after a ======= marker \n                    // (which can never be part of legal code).\n                    // case '>':\n                    case '=':\n                    case '<':\n                        if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        }\n\n                        return;\n\n                    default:\n                        return;\n                } 102938"];
5199 [label="if (!isTrailing)\n                        {\n                            if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            }\n                        } 102939"];
5200 [label="IsConflictMarkerTrivia() 102940"];
5201 [label="param IsConflictMarkerTrivia(this) 102941"];
5202 [label="TextWindow.Position 102942"];
5203 [label="get\n            {\n                return _basis + _offset;\n            } 102943"];
5204 [label="var position = TextWindow.Position; 102944"];
5205 [label="TextWindow.Text 102945"];
5206 [label="=> _text 102946"];
5207 [label="var text = TextWindow.Text; 102947"];
5208 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 102948"];
5209 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 102949"];
5210 [label="if (position == 0 || SyntaxFacts.IsNewLine(text[position - 1]))\n            {\n                var firstCh = text[position];\n                Debug.Assert(firstCh == '<' || firstCh == '=' || firstCh == '>');\n\n                if ((position + s_conflictMarkerLength) <= text.Length)\n                {\n                    for (int i = 0, n = s_conflictMarkerLength; i < n; i++)\n                    {\n                        if (text[position + i] != firstCh)\n                        {\n                            return false;\n                        }\n                    }\n\n                    if (firstCh == '=')\n                    {\n                        return true;\n                    }\n\n                    return (position + s_conflictMarkerLength) < text.Length &&\n                        text[position + s_conflictMarkerLength] == ' ';\n                }\n            } 102950"];
5211 [label="SyntaxFacts.IsNewLine(text[position - 1]) 102951"];
5212 [label="param IsNewLine(char ch) 102952"];
5213 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 102953"];
5214 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 102954"];
5215 [label="return false; 102955"];
5216 [label="if (IsConflictMarkerTrivia())\n                            {\n                                this.LexConflictMarkerTrivia(ref triviaList);\n                                break;\n                            } 102956"];
5217 [label="return; 102957"];
5218 [label="this.Start(); 102958"];
5219 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102959"];
5220 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102960"];
5221 [label="GetFullWidth(leading) 102961"];
5222 [label="param GetFullWidth(SyntaxListBuilder builder) 102962"];
5223 [label="int width = 0; 102963"];
5224 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102964"];
5225 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 102965"];
5226 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 102966"];
5227 [label="return width; 102967"];
5228 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102968"];
5229 [label="this.GetErrors(GetFullWidth(leading)) 102969"];
5230 [label="param GetErrors(int leadingTriviaWidth) 102970"];
5231 [label="param GetErrors(this) 102971"];
5232 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102972"];
5233 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 102973"];
5234 [label="return null; 102974"];
5235 [label="var errors = this.GetErrors(GetFullWidth(leading)); 102975"];
5236 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 102976"];
5237 [label="param AddTrivia(this) 102977"];
5238 [label="this.HasErrors 102978"];
5239 [label="get { return _errors != null; } 102979"];
5240 [label="return _errors != null; 102980"];
5241 [label="return _errors != null; 102981"];
5242 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 102982"];
5243 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 102983"];
5244 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 102984"];
5245 [label="return; 102985"];
5246 [label="param Create(SyntaxDiagnosticInfo[] errors) 102986"];
5247 [label="param Create(this) 102987"];
5248 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 102988"];
5249 [label="SyntaxToken token; 102989"];
5250 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 102990"];
5251 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 102991"];
5252 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 102992"];
5253 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 102993"];
5254 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 102994"];
5255 [label="if (trailing == SyntaxFactory.Space)\n                {\n                    return s_tokensWithSingleTrailingSpace[(int)kind].Value;\n                }\n                else if (trailing == SyntaxFactory.CarriageReturnLineFeed)\n                {\n                    return s_tokensWithSingleTrailingCRLF[(int)kind].Value;\n                } 102995"];
5256 [label="return s_tokensWithSingleTrailingSpace[(int)kind].Value; 102996"];
5257 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102997"];
5258 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 102998"];
5259 [label="Debug.Assert(quickWidth == token.FullWidth); 102999"];
5260 [label="this.AddLexedToken(token); 103000"];
5261 [label="param AddLexedToken(SyntaxToken token) 103001"];
5262 [label="Debug.Assert(token != null); 103002"];
5263 [label="_lexedTokens[_tokenCount].Value 103003"];
5264 [label="get { return (SyntaxKind)this.RawKind; } 103004"];
5265 [label="return (SyntaxKind)this.RawKind; 103005"];
5266 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 103006"];
5267 [label="TextWindow.Start(); 103007"];
5268 [label="var quickWidth = TextWindow.Width; 103008"];
5269 [label="param LexSyntaxTrivia(bool afterFirstToken) 103009"];
5270 [label="bool onlyWhitespaceOnLine = !isTrailing; 103010"];
5271 [label="this.Start(); 103011"];
5272 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103012"];
5273 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 103013"];
5274 [label="return; 103014"];
5275 [label="this.Start(); 103015"];
5276 [label="param ScanNumericLiteral(ref TokenInfo info) 103016"];
5277 [label="param ScanNumericLiteral(this) 103017"];
5278 [label="TextWindow.Position 103018"];
5279 [label="get\n            {\n                return _basis + _offset;\n            } 103019"];
5280 [label="int start = TextWindow.Position; 103020"];
5281 [label="char ch; 103021"];
5282 [label="bool isHex = false; 103022"];
5283 [label="bool isBinary = false; 103023"];
5284 [label="bool hasDecimal = false; 103024"];
5285 [label="bool hasExponent = false; 103025"];
5286 [label="info.Text = null; 103026"];
5287 [label="info.Text 103027"];
5288 [label="info.ValueKind 103028"];
5289 [label="_builder.Clear(); 103029"];
5290 [label="bool hasUSuffix = false; 103030"];
5291 [label="bool hasLSuffix = false; 103031"];
5292 [label="bool underscoreInWrongPlace = false; 103032"];
5293 [label="bool usedUnderscore = false; 103033"];
5294 [label="bool firstCharWasUnderscore = false; 103034"];
5295 [label="TextWindow.PeekChar() 103035"];
5296 [label="param PeekChar(this) 103036"];
5297 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103037"];
5298 [label="ch = TextWindow.PeekChar(); 103038"];
5299 [label="if (ch == '0')\n            {\n                ch = TextWindow.PeekChar(1);\n                if (ch == 'x' || ch == 'X')\n                {\n                    TextWindow.AdvanceChar(2);\n                    isHex = true;\n                }\n                else if (ch == 'b' || ch == 'B')\n                {\n                    CheckFeatureAvailability(MessageID.IDS_FeatureBinaryLiteral);\n                    TextWindow.AdvanceChar(2);\n                    isBinary = true;\n                }\n            } 103039"];
5300 [label="if (ch == '0')\n            {\n                ch = TextWindow.PeekChar(1);\n                if (ch == 'x' || ch == 'X')\n                {\n                    TextWindow.AdvanceChar(2);\n                    isHex = true;\n                }\n                else if (ch == 'b' || ch == 'B')\n                {\n                    CheckFeatureAvailability(MessageID.IDS_FeatureBinaryLiteral);\n                    TextWindow.AdvanceChar(2);\n                    isBinary = true;\n                }\n            } 103040"];
5301 [label="ch = TextWindow.PeekChar(1); 103041"];
5302 [label="TextWindow.PeekChar(1) 103042"];
5303 [label="param PeekChar(int delta) 103043"];
5304 [label="param PeekChar(this) 103044"];
5305 [label="this.Position 103045"];
5306 [label="get\n            {\n                return _basis + _offset;\n            } 103046"];
5307 [label="int position = this.Position; 103047"];
5308 [label="this.AdvanceChar(delta); 103048"];
5309 [label="this.AdvanceChar(delta) 103049"];
5310 [label="param AdvanceChar(int n) 103050"];
5311 [label="param AdvanceChar(this) 103051"];
5312 [label="_offset += n; 103052"];
5313 [label="this.AdvanceChar(delta); 103053"];
5314 [label="char ch; 103054"];
5315 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                ch = InvalidCharacter;\n            }\n            else\n            {\n                // N.B. MoreChars may update the offset.\n                ch = _characterWindow[_offset];\n            } 103055"];
5316 [label="ch = _characterWindow[_offset]; 103056"];
5317 [label="this.Reset(position); 103057"];
5318 [label="this.Reset(position) 103058"];
5319 [label="param Reset(int position) 103059"];
5320 [label="param Reset(this) 103060"];
5321 [label="this.Reset(position); 103061"];
5322 [label="return ch; 103062"];
5323 [label="if (ch == 'x' || ch == 'X')\n                {\n                    TextWindow.AdvanceChar(2);\n                    isHex = true;\n                }\n                else if (ch == 'b' || ch == 'B')\n                {\n                    CheckFeatureAvailability(MessageID.IDS_FeatureBinaryLiteral);\n                    TextWindow.AdvanceChar(2);\n                    isBinary = true;\n                } 103063"];
5324 [label="if (ch == 'x' || ch == 'X')\n                {\n                    TextWindow.AdvanceChar(2);\n                    isHex = true;\n                }\n                else if (ch == 'b' || ch == 'B')\n                {\n                    CheckFeatureAvailability(MessageID.IDS_FeatureBinaryLiteral);\n                    TextWindow.AdvanceChar(2);\n                    isBinary = true;\n                } 103064"];
5325 [label="if (ch == 'b' || ch == 'B')\n                {\n                    CheckFeatureAvailability(MessageID.IDS_FeatureBinaryLiteral);\n                    TextWindow.AdvanceChar(2);\n                    isBinary = true;\n                } 103065"];
5326 [label="if (isHex || isBinary)\n            {\n                // It's OK if it has no digits after the '0x' -- we'll catch it in ScanNumericLiteral\n                // and give a proper error then.\n                ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex, isBinary);\n\n                if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                {\n                    TextWindow.AdvanceChar();\n                    hasUSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                }\n            }\n            else\n            {\n                ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n\n                if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar() == '#')\n                {\n                    // Previously, in DebuggerSyntax mode, '123#' was a valid identifier.\n                    TextWindow.AdvanceChar();\n                    info.StringValue = info.Text = TextWindow.GetText(intern: true);\n                    info.Kind = SyntaxKind.IdentifierToken;\n                    this.AddError(MakeError(ErrorCode.ERR_LegacyObjectIdSyntax));\n                    return true;\n                }\n\n                if ((ch = TextWindow.PeekChar()) == '.')\n                {\n                    var ch2 = TextWindow.PeekChar(1);\n                    if (ch2 >= '0' && ch2 <= '9')\n                    {\n                        hasDecimal = true;\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                    else if (_builder.Length == 0)\n                    {\n                        // we only have the dot so far.. (no preceding number or following number)\n                        TextWindow.Reset(start);\n                        return false;\n                    }\n                }\n\n                if ((ch = TextWindow.PeekChar()) == 'E' || ch == 'e')\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                    hasExponent = true;\n                    if ((ch = TextWindow.PeekChar()) == '-' || ch == '+')\n                    {\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n                    }\n\n                    if (!(((ch = TextWindow.PeekChar()) >= '0' && ch <= '9') || ch == '_'))\n                    {\n                        // use this for now (CS0595), cant use CS0594 as we dont know 'type'\n                        this.AddError(MakeError(ErrorCode.ERR_InvalidReal));\n                        // add dummy exponent, so parser does not blow up\n                        _builder.Append('0');\n                    }\n                    else\n                    {\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                }\n\n                if (hasExponent || hasDecimal)\n                {\n                    if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Single;\n                    }\n                    else if (ch == 'D' || ch == 'd')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                    else if (ch == 'm' || ch == 'M')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Decimal;\n                    }\n                    else\n                    {\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                }\n                else if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Single;\n                }\n                else if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                }\n            } 103066"];
5327 [label="ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false); 103067"];
5328 [label="ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false); 103068"];
5329 [label="ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false); 103069"];
5330 [label="ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false); 103070"];
5331 [label="ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false) 103071"];
5332 [label="param ScanNumericLiteralSingleInteger(ref bool underscoreInWrongPlace) 103072"];
5333 [label="param ScanNumericLiteralSingleInteger(ref bool usedUnderscore) 103073"];
5334 [label="param ScanNumericLiteralSingleInteger(ref bool firstCharWasUnderscore) 103074"];
5335 [label="param ScanNumericLiteralSingleInteger(bool isHex) 103075"];
5336 [label="param ScanNumericLiteralSingleInteger(bool isBinary) 103076"];
5337 [label="param ScanNumericLiteralSingleInteger(this) 103077"];
5338 [label="TextWindow.PeekChar() 103078"];
5339 [label="param PeekChar(this) 103079"];
5340 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103080"];
5341 [label="return _characterWindow[_offset]; 103081"];
5342 [label="if (TextWindow.PeekChar() == '_')\n            {\n                if (isHex || isBinary)\n                {\n                    firstCharWasUnderscore = true;\n                }\n                else\n                {\n                    underscoreInWrongPlace = true;\n                }\n            } 103082"];
5343 [label="if (TextWindow.PeekChar() == '_')\n            {\n                if (isHex || isBinary)\n                {\n                    firstCharWasUnderscore = true;\n                }\n                else\n                {\n                    underscoreInWrongPlace = true;\n                }\n            } 103083"];
5344 [label="bool lastCharWasUnderscore = false; 103084"];
5345 [label="while (true)\n            {\n                char ch = TextWindow.PeekChar();\n                if (ch == '_')\n                {\n                    usedUnderscore = true;\n                    lastCharWasUnderscore = true;\n                }\n                else if (!(isHex ? SyntaxFacts.IsHexDigit(ch) :\n                           isBinary ? SyntaxFacts.IsBinaryDigit(ch) :\n                           SyntaxFacts.IsDecDigit(ch)))\n                {\n                    break;\n                }\n                else\n                {\n                    _builder.Append(ch);\n                    lastCharWasUnderscore = false;\n                }\n                TextWindow.AdvanceChar();\n            } 103085"];
5346 [label="TextWindow.PeekChar() 103086"];
5347 [label="param PeekChar(this) 103087"];
5348 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103088"];
5349 [label="return _characterWindow[_offset]; 103089"];
5350 [label="char ch = TextWindow.PeekChar(); 103090"];
5351 [label="if (ch == '_')\n                {\n                    usedUnderscore = true;\n                    lastCharWasUnderscore = true;\n                }\n                else if (!(isHex ? SyntaxFacts.IsHexDigit(ch) :\n                           isBinary ? SyntaxFacts.IsBinaryDigit(ch) :\n                           SyntaxFacts.IsDecDigit(ch)))\n                {\n                    break;\n                }\n                else\n                {\n                    _builder.Append(ch);\n                    lastCharWasUnderscore = false;\n                } 103091"];
5352 [label="if (ch == '_')\n                {\n                    usedUnderscore = true;\n                    lastCharWasUnderscore = true;\n                }\n                else if (!(isHex ? SyntaxFacts.IsHexDigit(ch) :\n                           isBinary ? SyntaxFacts.IsBinaryDigit(ch) :\n                           SyntaxFacts.IsDecDigit(ch)))\n                {\n                    break;\n                }\n                else\n                {\n                    _builder.Append(ch);\n                    lastCharWasUnderscore = false;\n                } 103092"];
5353 [label="isHex 103093"];
5354 [label="isBinary 103094"];
5355 [label="if (!(isHex ? SyntaxFacts.IsHexDigit(ch) :\n                           isBinary ? SyntaxFacts.IsBinaryDigit(ch) :\n                           SyntaxFacts.IsDecDigit(ch)))\n                {\n                    break;\n                }\n                else\n                {\n                    _builder.Append(ch);\n                    lastCharWasUnderscore = false;\n                } 103095"];
5356 [label="SyntaxFacts.IsDecDigit(ch) 103096"];
5357 [label="param IsDecDigit(char c) 103097"];
5358 [label="return c >= '0' && c <= '9'; 103098"];
5359 [label="return c >= '0' && c <= '9'; 103099"];
5360 [label="_builder.Append(ch); 103100"];
5361 [label="lastCharWasUnderscore = false; 103101"];
5362 [label="TextWindow.AdvanceChar() 103102"];
5363 [label="param AdvanceChar(this) 103103"];
5364 [label="TextWindow.AdvanceChar(); 103104"];
5365 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103105"];
5366 [label="if (lastCharWasUnderscore)\n            {\n                underscoreInWrongPlace = true;\n            } 103106"];
5367 [label="if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar() == '#')\n                {\n                    // Previously, in DebuggerSyntax mode, '123#' was a valid identifier.\n                    TextWindow.AdvanceChar();\n                    info.StringValue = info.Text = TextWindow.GetText(intern: true);\n                    info.Kind = SyntaxKind.IdentifierToken;\n                    this.AddError(MakeError(ErrorCode.ERR_LegacyObjectIdSyntax));\n                    return true;\n                } 103107"];
5368 [label="this.ModeIs(LexerMode.DebuggerSyntax) 103108"];
5369 [label="param ModeIs(LexerMode mode) 103109"];
5370 [label="param ModeIs(this) 103110"];
5371 [label="return ModeOf(_mode) == mode; 103111"];
5372 [label="return ModeOf(_mode) == mode; 103112"];
5373 [label="TextWindow.PeekChar() 103113"];
5374 [label="param PeekChar(this) 103114"];
5375 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103115"];
5376 [label="return _characterWindow[_offset]; 103116"];
5377 [label="if ((ch = TextWindow.PeekChar()) == '.')\n                {\n                    var ch2 = TextWindow.PeekChar(1);\n                    if (ch2 >= '0' && ch2 <= '9')\n                    {\n                        hasDecimal = true;\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                    else if (_builder.Length == 0)\n                    {\n                        // we only have the dot so far.. (no preceding number or following number)\n                        TextWindow.Reset(start);\n                        return false;\n                    }\n                } 103117"];
5378 [label="if ((ch = TextWindow.PeekChar()) == '.')\n                {\n                    var ch2 = TextWindow.PeekChar(1);\n                    if (ch2 >= '0' && ch2 <= '9')\n                    {\n                        hasDecimal = true;\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                    else if (_builder.Length == 0)\n                    {\n                        // we only have the dot so far.. (no preceding number or following number)\n                        TextWindow.Reset(start);\n                        return false;\n                    }\n                } 103118"];
5379 [label="TextWindow.PeekChar() 103119"];
5380 [label="param PeekChar(this) 103120"];
5381 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103121"];
5382 [label="return _characterWindow[_offset]; 103122"];
5383 [label="if ((ch = TextWindow.PeekChar()) == 'E' || ch == 'e')\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                    hasExponent = true;\n                    if ((ch = TextWindow.PeekChar()) == '-' || ch == '+')\n                    {\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n                    }\n\n                    if (!(((ch = TextWindow.PeekChar()) >= '0' && ch <= '9') || ch == '_'))\n                    {\n                        // use this for now (CS0595), cant use CS0594 as we dont know 'type'\n                        this.AddError(MakeError(ErrorCode.ERR_InvalidReal));\n                        // add dummy exponent, so parser does not blow up\n                        _builder.Append('0');\n                    }\n                    else\n                    {\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                } 103123"];
5384 [label="if ((ch = TextWindow.PeekChar()) == 'E' || ch == 'e')\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                    hasExponent = true;\n                    if ((ch = TextWindow.PeekChar()) == '-' || ch == '+')\n                    {\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n                    }\n\n                    if (!(((ch = TextWindow.PeekChar()) >= '0' && ch <= '9') || ch == '_'))\n                    {\n                        // use this for now (CS0595), cant use CS0594 as we dont know 'type'\n                        this.AddError(MakeError(ErrorCode.ERR_InvalidReal));\n                        // add dummy exponent, so parser does not blow up\n                        _builder.Append('0');\n                    }\n                    else\n                    {\n                        ScanNumericLiteralSingleInteger(ref underscoreInWrongPlace, ref usedUnderscore, ref firstCharWasUnderscore, isHex: false, isBinary: false);\n                    }\n                } 103124"];
5385 [label="if (hasExponent || hasDecimal)\n                {\n                    if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Single;\n                    }\n                    else if (ch == 'D' || ch == 'd')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                    else if (ch == 'm' || ch == 'M')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Decimal;\n                    }\n                    else\n                    {\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                }\n                else if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Single;\n                }\n                else if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103125"];
5386 [label="TextWindow.PeekChar() 103126"];
5387 [label="param PeekChar(this) 103127"];
5388 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103128"];
5389 [label="return _characterWindow[_offset]; 103129"];
5390 [label="if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Single;\n                }\n                else if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103130"];
5391 [label="if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Single;\n                }\n                else if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103131"];
5392 [label="if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103132"];
5393 [label="if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103133"];
5394 [label="if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103134"];
5395 [label="if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                } 103135"];
5396 [label="if (underscoreInWrongPlace)\n            {\n                this.AddError(MakeError(start, TextWindow.Position - start, ErrorCode.ERR_InvalidNumber));\n            }\n            else if (firstCharWasUnderscore)\n            {\n                CheckFeatureAvailability(MessageID.IDS_FeatureLeadingDigitSeparator);\n            }\n            else if (usedUnderscore)\n            {\n                CheckFeatureAvailability(MessageID.IDS_FeatureDigitSeparator);\n            } 103136"];
5397 [label="if (firstCharWasUnderscore)\n            {\n                CheckFeatureAvailability(MessageID.IDS_FeatureLeadingDigitSeparator);\n            }\n            else if (usedUnderscore)\n            {\n                CheckFeatureAvailability(MessageID.IDS_FeatureDigitSeparator);\n            } 103137"];
5398 [label="if (usedUnderscore)\n            {\n                CheckFeatureAvailability(MessageID.IDS_FeatureDigitSeparator);\n            } 103138"];
5399 [label="info.Kind 103139"];
5400 [label="info.Text = TextWindow.GetText(true); 103140"];
5401 [label="TextWindow.GetText(true) 103141"];
5402 [label="param GetText(bool intern) 103142"];
5403 [label="param GetText(this) 103143"];
5404 [label="this.LexemeStartPosition 103144"];
5405 [label="get\n            {\n                return _basis + _lexemeStart;\n            } 103145"];
5406 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 103146"];
5407 [label="this.Width 103147"];
5408 [label="get\n            {\n                return _offset - _lexemeStart;\n            } 103148"];
5409 [label="return _offset - _lexemeStart; 103149"];
5410 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 103150"];
5411 [label="return this.GetText(this.LexemeStartPosition, this.Width, intern); 103151"];
5412 [label="this.GetText(this.LexemeStartPosition, this.Width, intern) 103152"];
5413 [label="param GetText(int position) 103153"];
5414 [label="param GetText(int length) 103154"];
5415 [label="param GetText(bool intern) 103155"];
5416 [label="param GetText(this) 103156"];
5417 [label="int offset = position - _basis; 103157"];
5418 [label="switch (length)\n            {\n                case 0:\n                    return string.Empty;\n\n                case 1:\n                    if (_characterWindow[offset] == ' ')\n                    {\n                        return ' ';\n                    }\n                    if (_characterWindow[offset] == '\\n')\n                    {\n                        return '\\n';\n                    }\n                    break;\n\n                case 2:\n                    char firstChar = _characterWindow[offset];\n                    if (firstChar == '\\r' && _characterWindow[offset + 1] == '\\n')\n                    {\n                        return '\\r\\n';\n                    }\n                    if (firstChar == '/' && _characterWindow[offset + 1] == '/')\n                    {\n                        return '//';\n                    }\n                    break;\n\n                case 3:\n                    if (_characterWindow[offset] == '/' && _characterWindow[offset + 1] == '/' && _characterWindow[offset + 2] == ' ')\n                    {\n                        return '// ';\n                    }\n                    break;\n            } 103158"];
5419 [label="if (_characterWindow[offset] == ' ')\n                    {\n                        return ' ';\n                    } 103159"];
5420 [label="if (_characterWindow[offset] == ' ')\n                    {\n                        return ' ';\n                    } 103160"];
5421 [label="if (_characterWindow[offset] == '\\n')\n                    {\n                        return '\\n';\n                    } 103161"];
5422 [label="if (_characterWindow[offset] == '\\n')\n                    {\n                        return '\\n';\n                    } 103162"];
5423 [label="if (intern)\n            {\n                return this.Intern(_characterWindow, offset, length);\n            }\n            else\n            {\n                return new string(_characterWindow, offset, length);\n            } 103163"];
5424 [label="return this.Intern(_characterWindow, offset, length); 103164"];
5425 [label="return this.Intern(_characterWindow, offset, length); 103165"];
5426 [label="return this.Intern(_characterWindow, offset, length); 103166"];
5427 [label="this.Intern(_characterWindow, offset, length) 103167"];
5428 [label="param Intern(char[] array) 103168"];
5429 [label="param Intern(int start) 103169"];
5430 [label="param Intern(int length) 103170"];
5431 [label="param Intern(this) 103171"];
5432 [label="return _strings.Add(array, start, length); 103172"];
5433 [label="info.Text 103173"];
5434 [label="Debug.Assert(info.Text != null); 103174"];
5435 [label="Debug.Assert(info.Text != null); 103175"];
5436 [label="var valueText = TextWindow.Intern(_builder); 103176"];
5437 [label="TextWindow.Intern(_builder) 103177"];
5438 [label="param Intern(StringBuilder text) 103178"];
5439 [label="param Intern(this) 103179"];
5440 [label="return _strings.Add(text); 103180"];
5441 [label="return _strings.Add(text); 103181"];
5442 [label="ulong val; 103182"];
5443 [label="switch (info.ValueKind)\n            {\n                case SpecialType.System_Single:\n                    info.FloatValue = this.GetValueSingle(valueText);\n                    break;\n                case SpecialType.System_Double:\n                    info.DoubleValue = this.GetValueDouble(valueText);\n                    break;\n                case SpecialType.System_Decimal:\n                    info.DecimalValue = this.GetValueDecimal(valueText, start, TextWindow.Position);\n                    break;\n                default:\n                    if (string.IsNullOrEmpty(valueText))\n                    {\n                        if (!underscoreInWrongPlace)\n                        {\n                            this.AddError(MakeError(ErrorCode.ERR_InvalidNumber));\n                        }\n                        val = 0; //safe default\n                    }\n                    else\n                    {\n                        val = this.GetValueUInt64(valueText, isHex, isBinary);\n                    }\n\n                    // 2.4.4.2 Integer literals\n                    // ...\n                    // The type of an integer literal is determined as follows:\n\n                    // * If the literal has no suffix, it has the first of these types in which its value can be represented: int, uint, long, ulong.\n                    if (!hasUSuffix && !hasLSuffix)\n                    {\n                        if (val <= Int32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int32;\n                            info.IntValue = (int)val;\n                        }\n                        else if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 2147483648.\n                        }\n                        else if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n                    else if (hasUSuffix && !hasLSuffix)\n                    {\n                        // * If the literal is suffixed by U or u, it has the first of these types in which its value can be represented: uint, ulong.\n                        if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n                        }\n                    }\n\n                    // * If the literal is suffixed by L or l, it has the first of these types in which its value can be represented: long, ulong.\n                    else if (!hasUSuffix & hasLSuffix)\n                    {\n                        if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n\n                    // * If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, it is of type ulong.\n                    else\n                    {\n                        Debug.Assert(hasUSuffix && hasLSuffix);\n                        info.ValueKind = SpecialType.System_UInt64;\n                        info.UlongValue = val;\n                    }\n\n                    break;\n\n                    // Note, the following portion of the spec is not implemented here. It is implemented\n                    // in the unary minus analysis.\n\n                    // * When a decimal-integer-literal with the value 2147483648 (231) and no integer-type-suffix appears\n                    //   as the token immediately following a unary minus operator token (§7.7.2), the result is a constant\n                    //   of type int with the value −2147483648 (−231). In all other situations, such a decimal-integer-\n                    //   literal is of type uint.\n                    // * When a decimal-integer-literal with the value 9223372036854775808 (263) and no integer-type-suffix\n                    //   or the integer-type-suffix L or l appears as the token immediately following a unary minus operator\n                    //   token (§7.7.2), the result is a constant of type long with the value −9223372036854775808 (−263).\n                    //   In all other situations, such a decimal-integer-literal is of type ulong.\n            } 103183"];
5444 [label="if (string.IsNullOrEmpty(valueText))\n                    {\n                        if (!underscoreInWrongPlace)\n                        {\n                            this.AddError(MakeError(ErrorCode.ERR_InvalidNumber));\n                        }\n                        val = 0; //safe default\n                    }\n                    else\n                    {\n                        val = this.GetValueUInt64(valueText, isHex, isBinary);\n                    } 103184"];
5445 [label="val = this.GetValueUInt64(valueText, isHex, isBinary); 103185"];
5446 [label="val = this.GetValueUInt64(valueText, isHex, isBinary); 103186"];
5447 [label="val = this.GetValueUInt64(valueText, isHex, isBinary); 103187"];
5448 [label="this.GetValueUInt64(valueText, isHex, isBinary) 103188"];
5449 [label="param GetValueUInt64(string text) 103189"];
5450 [label="param GetValueUInt64(bool isHex) 103190"];
5451 [label="param GetValueUInt64(bool isBinary) 103191"];
5452 [label="param GetValueUInt64(this) 103192"];
5453 [label="ulong result; 103193"];
5454 [label="if (isBinary)\n            {\n                if (!TryParseBinaryUInt64(text, out result))\n                {\n                    this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n                }\n            }\n            else if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103194"];
5455 [label="if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103195"];
5456 [label="isHex 103196"];
5457 [label="if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103197"];
5458 [label="if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103198"];
5459 [label="if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103199"];
5460 [label="if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            } 103200"];
5461 [label="return result; 103201"];
5462 [label="if (!hasUSuffix && !hasLSuffix)\n                    {\n                        if (val <= Int32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int32;\n                            info.IntValue = (int)val;\n                        }\n                        else if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 2147483648.\n                        }\n                        else if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n                    else if (hasUSuffix && !hasLSuffix)\n                    {\n                        // * If the literal is suffixed by U or u, it has the first of these types in which its value can be represented: uint, ulong.\n                        if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n                        }\n                    }\n\n                    // * If the literal is suffixed by L or l, it has the first of these types in which its value can be represented: long, ulong.\n                    else if (!hasUSuffix & hasLSuffix)\n                    {\n                        if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n\n                    // * If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, it is of type ulong.\n                    else\n                    {\n                        Debug.Assert(hasUSuffix && hasLSuffix);\n                        info.ValueKind = SpecialType.System_UInt64;\n                        info.UlongValue = val;\n                    } 103202"];
5463 [label="if (val <= Int32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int32;\n                            info.IntValue = (int)val;\n                        }\n                        else if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 2147483648.\n                        }\n                        else if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        } 103203"];
5464 [label="info.ValueKind 103204"];
5465 [label="info.IntValue 103205"];
5466 [label="return true; 103206"];
5467 [label="this.ScanSyntaxToken(ref tokenInfo); 103207"];
5468 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103208"];
5469 [label="GetFullWidth(leading) 103209"];
5470 [label="param GetFullWidth(SyntaxListBuilder builder) 103210"];
5471 [label="int width = 0; 103211"];
5472 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 103212"];
5473 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 103213"];
5474 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 103214"];
5475 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 103215"];
5476 [label="return width; 103216"];
5477 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103217"];
5478 [label="this.GetErrors(GetFullWidth(leading)) 103218"];
5479 [label="param GetErrors(int leadingTriviaWidth) 103219"];
5480 [label="param GetErrors(this) 103220"];
5481 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 103221"];
5482 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 103222"];
5483 [label="return null; 103223"];
5484 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103224"];
5485 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103225"];
5486 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 103226"];
5487 [label="return; 103227"];
5488 [label="param Create(SyntaxDiagnosticInfo[] errors) 103228"];
5489 [label="param Create(this) 103229"];
5490 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 103230"];
5491 [label="SyntaxToken token; 103231"];
5492 [label="switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        } 103232"];
5493 [label="token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode); 103233"];
5494 [label="SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode) 103234"];
5495 [label="param Literal(GreenNode leading) 103235"];
5496 [label="param Literal(string text) 103236"];
5497 [label="param Literal(int value) 103237"];
5498 [label="param Literal(GreenNode trailing) 103238"];
5499 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103239"];
5500 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103240"];
5501 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103241"];
5502 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103242"];
5503 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103243"];
5504 [label="SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing) 103244"];
5505 [label="param WithValue(SyntaxKind kind) 103245"];
5506 [label="param WithValue(GreenNode leading) 103246"];
5507 [label="param WithValue(string text) 103247"];
5508 [label="param WithValue(T value) 103248"];
5509 [label="param WithValue(GreenNode trailing) 103249"];
5510 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValueAndTrivia<T>), r => new SyntaxTokenWithValueAndTrivia<T>(r)); 103250"];
5511 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103251"];
5512 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103252"];
5513 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103253"];
5514 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103254"];
5515 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103255"];
5516 [label="return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing); 103256"];
5517 [label="new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing) 103257"];
5518 [label="param SyntaxTokenWithValueAndTrivia(SyntaxKind kind) 103258"];
5519 [label="param SyntaxTokenWithValueAndTrivia(string text) 103259"];
5520 [label="param SyntaxTokenWithValueAndTrivia(T value) 103260"];
5521 [label="param SyntaxTokenWithValueAndTrivia(GreenNode leading) 103261"];
5522 [label="param SyntaxTokenWithValueAndTrivia(GreenNode trailing) 103262"];
5523 [label="param SyntaxTokenWithValueAndTrivia(this) 103263"];
5524 [label="ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValue<T>), r => new SyntaxTokenWithValue<T>(r)); 103264"];
5525 [label="kind 103265"];
5526 [label="text 103266"];
5527 [label="value 103267"];
5528 [label="param SyntaxTokenWithValueAndTrivia(this) 103268"];
5529 [label="param SyntaxTokenWithValue(SyntaxKind kind) 103269"];
5530 [label="param SyntaxTokenWithValue(string text) 103270"];
5531 [label="param SyntaxTokenWithValue(T value) 103271"];
5532 [label="param SyntaxTokenWithValue(this) 103272"];
5533 [label="kind 103273"];
5534 [label="text 103274"];
5535 [label="param SyntaxTokenWithValue(this) 103275"];
5536 [label="param SyntaxToken(SyntaxKind kind) 103276"];
5537 [label="param SyntaxToken(int fullWidth) 103277"];
5538 [label="param CSharpSyntaxNode(this) 103278"];
5539 [label="TextField 103279"];
5540 [label="ValueField 103280"];
5541 [label="this.TextField 103281"];
5542 [label="this.ValueField 103282"];
5543 [label="_leading 103283"];
5544 [label="_trailing 103284"];
5545 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    _leading = leading;\n                } 103285"];
5546 [label="if (leading != null)\n                {\n                    this.AdjustFlagsAndWidth(leading);\n                    _leading = leading;\n                } 103286"];
5547 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 103287"];
5548 [label="if (trailing != null)\n                {\n                    this.AdjustFlagsAndWidth(trailing);\n                    _trailing = trailing;\n                } 103288"];
5549 [label="return SyntaxToken.WithValue(SyntaxKind.NumericLiteralToken, leading, text, value, trailing); 103289"];
5550 [label="token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode); 103290"];
5551 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 103291"];
5552 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 103292"];
5553 [label="Debug.Assert(quickWidth == token.FullWidth); 103293"];
5554 [label="value = createTokenFunction(); 103294"];
5555 [label="this.AddLexedToken(token); 103295"];
5556 [label="param AddLexedToken(SyntaxToken token) 103296"];
5557 [label="Debug.Assert(token != null); 103297"];
5558 [label="_lexedTokens[_tokenCount].Value 103298"];
5559 [label="get { return (SyntaxKind)this.RawKind; } 103299"];
5560 [label="return (SyntaxKind)this.RawKind; 103300"];
5561 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 103301"];
5562 [label="TextWindow.Start(); 103302"];
5563 [label="var quickWidth = TextWindow.Width; 103303"];
5564 [label="param LexSyntaxTrivia(bool afterFirstToken) 103304"];
5565 [label="bool onlyWhitespaceOnLine = !isTrailing; 103305"];
5566 [label="this.Start(); 103306"];
5567 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103307"];
5568 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 103308"];
5569 [label="return; 103309"];
5570 [label="this.Start(); 103310"];
5571 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103311"];
5572 [label="GetFullWidth(leading) 103312"];
5573 [label="param GetFullWidth(SyntaxListBuilder builder) 103313"];
5574 [label="int width = 0; 103314"];
5575 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 103315"];
5576 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 103316"];
5577 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 103317"];
5578 [label="return width; 103318"];
5579 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103319"];
5580 [label="this.GetErrors(GetFullWidth(leading)) 103320"];
5581 [label="param GetErrors(int leadingTriviaWidth) 103321"];
5582 [label="param GetErrors(this) 103322"];
5583 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 103323"];
5584 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 103324"];
5585 [label="return null; 103325"];
5586 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103326"];
5587 [label="param Create(SyntaxDiagnosticInfo[] errors) 103327"];
5588 [label="param Create(this) 103328"];
5589 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 103329"];
5590 [label="SyntaxToken token; 103330"];
5591 [label="Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind)); 103331"];
5592 [label="SyntaxFacts.IsPunctuationOrKeyword(info.Kind) 103332"];
5593 [label="param IsPunctuationOrKeyword(SyntaxKind kind) 103333"];
5594 [label="return kind >= SyntaxKind.TildeToken && kind <= SyntaxKind.EndOfFileToken; 103334"];
5595 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 103335"];
5596 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 103336"];
5597 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 103337"];
5598 [label="Debug.Assert(quickWidth == token.FullWidth); 103338"];
5599 [label="param AddTrivia(this) 103339"];
5600 [label="this.HasErrors 103340"];
5601 [label="get { return _errors != null; } 103341"];
5602 [label="return _errors != null; 103342"];
5603 [label="return _errors != null; 103343"];
5604 [label="if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            } 103344"];
5605 [label="if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            } 103345"];
5606 [label="this.Position 103346"];
5607 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 103347"];
5608 [label="return false; 103348"];
5609 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103349"];
5610 [label="return InvalidCharacter; 103350"];
5611 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 103351"];
5612 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 103352"];
5613 [label="SyntaxFacts.IsWhitespace(ch) 103353"];
5614 [label="param IsWhitespace(char ch) 103354"];
5615 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103355"];
5616 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103356"];
5617 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103357"];
5618 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 103358"];
5619 [label="SyntaxFacts.IsNewLine(ch) 103359"];
5620 [label="param IsNewLine(char ch) 103360"];
5621 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 103361"];
5622 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 103362"];
5623 [label="return; 103363"];
5624 [label="return (SyntaxKind)this.RawKind; 103364"];
5625 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 103365"];
5626 [label="param LexSyntaxTrivia(bool afterFirstToken) 103366"];
5627 [label="bool onlyWhitespaceOnLine = !isTrailing; 103367"];
5628 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103368"];
5629 [label="if (this.Position >= _textEnd)\n                {\n                    return false;\n                } 103369"];
5630 [label="return false; 103370"];
5631 [label="if (_offset >= _characterWindowCount\n                && !MoreChars())\n            {\n                return InvalidCharacter;\n            } 103371"];
5632 [label="return InvalidCharacter; 103372"];
5633 [label="param IsReallyAtEnd(this) 103373"];
5634 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 103374"];
5635 [label="Position 103375"];
5636 [label="get\n            {\n                return _basis + _offset;\n            } 103376"];
5637 [label="return _basis + _offset; 103377"];
5638 [label="return _offset >= _characterWindowCount && Position >= _textEnd; 103378"];
5639 [label="ConsList<Directive>.Empty 103379"];
5640 [label="new DirectiveStack(ConsList<Directive>.Empty) 103380"];
5641 [label="param DirectiveStack(ConsList<Directive> directives) 103381"];
5642 [label="param DirectiveStack(this) 103382"];
5643 [label="_directives 103383"];
5644 [label="Empty = new DirectiveStack(ConsList<Directive>.Empty) 103384"];
5645 [label="null 103385"];
5646 [label="new DirectiveStack(null) 103386"];
5647 [label="param DirectiveStack(ConsList<Directive> directives) 103387"];
5648 [label="param DirectiveStack(this) 103388"];
5649 [label="_directives 103389"];
5650 [label="Null = new DirectiveStack(null) 103390"];
5651 [label="param HasUnfinishedIf(this) 103391"];
5652 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 103392"];
5653 [label="GetPreviousIfElifElseOrRegion(_directives) 103393"];
5654 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 103394"];
5655 [label="var current = directives; 103395"];
5656 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 103396"];
5657 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 103397"];
5658 [label="return current; 103398"];
5659 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 103399"];
5660 [label="return prev != null && prev.Any() && prev.Head.Kind != SyntaxKind.RegionDirectiveTrivia; 103400"];
5661 [label="param HasUnfinishedRegion(this) 103401"];
5662 [label="var prev = GetPreviousIfElifElseOrRegion(_directives); 103402"];
5663 [label="GetPreviousIfElifElseOrRegion(_directives) 103403"];
5664 [label="param GetPreviousIfElifElseOrRegion(ConsList<Directive> directives) 103404"];
5665 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 103405"];
5666 [label="while (current != null && current.Any())\n            {\n                switch (current.Head.Kind)\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                    case SyntaxKind.ElifDirectiveTrivia:\n                    case SyntaxKind.ElseDirectiveTrivia:\n                    case SyntaxKind.RegionDirectiveTrivia:\n                        return current;\n                }\n\n                current = current.Tail;\n            } 103406"];
5667 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 103407"];
5668 [label="return prev != null && prev.Any() && prev.Head.Kind == SyntaxKind.RegionDirectiveTrivia; 103408"];
5669 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103409"];
5670 [label="param GetFullWidth(SyntaxListBuilder builder) 103410"];
5671 [label="if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            } 103411"];
5672 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 103412"];
5673 [label="for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                } 103413"];
5674 [label="if (_errors != null)\n            {\n                if (leadingTriviaWidth > 0)\n                {\n                    var array = new SyntaxDiagnosticInfo[_errors.Count];\n                    for (int i = 0; i < _errors.Count; i++)\n                    {\n                        // fixup error positioning to account for leading trivia\n                        array[i] = _errors[i].WithOffset(_errors[i].Offset + leadingTriviaWidth);\n                    }\n\n                    return array;\n                }\n                else\n                {\n                    return _errors.ToArray();\n                }\n            }\n            else\n            {\n                return null;\n            } 103414"];
5675 [label="return null; 103415"];
5676 [label="var errors = this.GetErrors(GetFullWidth(leading)); 103416"];
5677 [label="if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                } 103417"];
5678 [label="if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 103418"];
5679 [label="SyntaxFacts.IsWhitespace(ch) 103419"];
5680 [label="param IsWhitespace(char ch) 103420"];
5681 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103421"];
5682 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103422"];
5683 [label="return ch == ' '\n                || ch == '\\t'\n                || ch == '\\v'\n                || ch == '\\f'\n                || ch == '\\u00A0' // NO-BREAK SPACE\n                                  // The native compiler, in ScanToken, recognized both the byte-order\n                                  // marker '\\uFEFF' as well as ^Z '\\u001A' as whitespace, although\n                                  // this is not to spec since neither of these are in Zs. For the\n                                  // sake of compatibility, we recognize them both here. Note: '\\uFEFF'\n                                  // also happens to be a formatting character (class Cf), which means\n                                  // that it is a legal non-initial identifier character. So it's\n                                  // especially funny, because it will be whitespace UNLESS we happen\n                                  // to be scanning an identifier or keyword, in which case it winds\n                                  // up in the identifier or keyword.\n                || ch == '\\uFEFF'\n                || ch == '\\u001A'\n                || (ch > 255 && CharUnicodeInfo.GetUnicodeCategory(ch) == UnicodeCategory.SpaceSeparator); 103423"];
5684 [label="if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    } 103424"];
5685 [label="SyntaxFacts.IsNewLine(ch) 103425"];
5686 [label="param IsNewLine(char ch) 103426"];
5687 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 103427"];
5688 [label="return ch == '\\r'\n                || ch == '\\n'\n                || ch == '\\u0085'\n                || ch == '\\u2028'\n                || ch == '\\u2029'; 103428"];
5689 [label="return; 103429"];
5690 [label="param Create(SyntaxDiagnosticInfo[] errors) 103430"];
5691 [label="Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null); 103431"];
5692 [label="token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode); 103432"];
5693 [label="SyntaxFactory.Token(leadingNode, info.Kind, trailingNode) 103433"];
5694 [label="param Token(GreenNode leading) 103434"];
5695 [label="param Token(SyntaxKind kind) 103435"];
5696 [label="param Token(GreenNode trailing) 103436"];
5697 [label="if (kind > LastTokenWithWellKnownText)\n            {\n                if (!SyntaxFacts.IsAnyToken(kind))\n                {\n                    throw new ArgumentException(string.Format(CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens, kind), nameof(kind));\n                }\n\n                return CreateMissing(kind, leading, trailing);\n            } 103437"];
5698 [label="if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            } 103438"];
5699 [label="this.AddLexedToken(token); 103439"];
5700 [label="param AddLexedToken(SyntaxToken token) 103440"];
5701 [label="Debug.Assert(token != null); 103441"];
5702 [label="_lexedTokens[_tokenCount].Value 103442"];
5703 [label="get { return (SyntaxKind)this.RawKind; } 103443"];
5704 [label="return (SyntaxKind)this.RawKind; 103444"];
5705 [label="if (token.Kind == SyntaxKind.EndOfFileToken)\n                {\n                    break;\n                } 103445"];
5706 [label="this.PreLex(); 103446"];
5707 [label="new SyntaxListPool() 103447"];
5708 [label="_pool = new SyntaxListPool() 103448"];
5709 [label="_syntaxFactoryContext 103449"];
5710 [label="_syntaxFactory 103450"];
5711 [label="_recursionDepth 103451"];
5712 [label="_termState 103452"];
5713 [label="_isInTry 103453"];
5714 [label="_checkedTopLevelStatementsFeatureAvailability 103454"];
5715 [label="_syntaxFactoryContext = new SyntaxFactoryContext(); 103455"];
5716 [label="_syntaxFactoryContext 103456"];
5717 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 103457"];
5718 [label="_syntaxFactory = new ContextAwareSyntax(_syntaxFactoryContext); 103458"];
5719 [label="_syntaxFactory 103459"];
5720 [label="using (var parser = MakeParser(lexer))\n            {\n                var node = parser.ParseStatement();\n                if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);\n                return (StatementSyntax)node.CreateRed();\n            } 103460"];
5721 [label="parser.ParseStatement() 103461"];
5722 [label="param ParseStatement(this) 103462"];
5723 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 103463"];
5724 [label="return ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))); 103464"];
5725 [label="ParseWithStackGuard(\n                () => ParsePossiblyAttributedStatement() ?? ParseExpressionStatement(attributes: default),\n                () => SyntaxFactory.EmptyStatement(attributeLists: default, SyntaxFactory.MissingToken(SyntaxKind.SemicolonToken))) 103465"];
5726 [label="param ParseWithStackGuard(Func<TNode> parseFunc) 103466"];
5727 [label="param ParseWithStackGuard(Func<TNode> createEmptyNodeFunc) 103467"];
5728 [label="param ParseWithStackGuard(this) 103468"];
5729 [label="Debug.Assert(_recursionDepth == 0); 103469"];
5730 [label="Debug.Assert(_recursionDepth == 0); 103470"];
5731 [label="return parseFunc(); 103471"];
5732 [label="return parseFunc(); 103472"];
5733 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 103473"];
5734 [label="ParseAttributeDeclarations() 103474"];
5735 [label="param ParseAttributeDeclarations(this) 103475"];
5736 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 103476"];
5737 [label="var saveTerm = _termState; 103477"];
5738 [label="_termState |= TerminatorState.IsAttributeDeclarationTerminator; 103478"];
5739 [label="_termState 103479"];
5740 [label="this.IsPossibleAttributeDeclaration() 103480"];
5741 [label="param IsPossibleAttributeDeclaration(this) 103481"];
5742 [label="this.CurrentToken 103482"];
5743 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103483"];
5744 [label="this.FetchCurrentToken() 103484"];
5745 [label="param FetchCurrentToken(this) 103485"];
5746 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103486"];
5747 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103487"];
5748 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103488"];
5749 [label="return _lexedTokens[_tokenOffset]; 103489"];
5750 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103490"];
5751 [label="_currentToken 103491"];
5752 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 103492"];
5753 [label="this.CurrentToken.Kind 103493"];
5754 [label="get { return (SyntaxKind)this.RawKind; } 103494"];
5755 [label="return (SyntaxKind)this.RawKind; 103495"];
5756 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 103496"];
5757 [label="_termState 103497"];
5758 [label="return attributes.ToList(); 103498"];
5759 [label="_pool.Free(attributes); 103499"];
5760 [label="_pool.Free(attributes); 103500"];
5761 [label="false 103501"];
5762 [label="isGlobal: false 103502"];
5763 [label="ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 103503"];
5764 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 103504"];
5765 [label="param ParseStatementCore(bool isGlobal) 103505"];
5766 [label="param ParseStatementCore(this) 103506"];
5767 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 103507"];
5768 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 103508"];
5769 [label="canReuseStatement(attributes, isGlobal) 103509"];
5770 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 103510"];
5771 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 103511"];
5772 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 103512"];
5773 [label="this.IsIncrementalAndFactoryContextMatches 103513"];
5774 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 103514"];
5775 [label="base.IsIncremental 103515"];
5776 [label="get\n            {\n                return _isIncremental;\n            } 103516"];
5777 [label="return _isIncremental; 103517"];
5778 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 103518"];
5779 [label="return false; 103519"];
5780 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 103520"];
5781 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 103521"];
5782 [label="this.GetResetPoint() 103522"];
5783 [label="param GetResetPoint(this) 103523"];
5784 [label="base.GetResetPoint() 103524"];
5785 [label="param GetResetPoint(this) 103525"];
5786 [label="CurrentTokenPosition 103526"];
5787 [label="=> _firstToken + _tokenOffset 103527"];
5788 [label="_firstToken + _tokenOffset 103528"];
5789 [label="var pos = CurrentTokenPosition; 103529"];
5790 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 103530"];
5791 [label="if (_resetCount == 0)\n            {\n                _resetStart = pos; // low water mark\n            } 103531"];
5792 [label="_resetStart 103532"];
5793 [label="_resetCount 103533"];
5794 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103534"];
5795 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103535"];
5796 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103536"];
5797 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103537"];
5798 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103538"];
5799 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103539"];
5800 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103540"];
5801 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 103541"];
5802 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 103542"];
5803 [label="param ResetPoint(TerminatorState terminatorState) 103543"];
5804 [label="param ResetPoint(bool isInTry) 103544"];
5805 [label="param ResetPoint(bool isInAsync) 103545"];
5806 [label="param ResetPoint(int queryDepth) 103546"];
5807 [label="param ResetPoint(this) 103547"];
5808 [label="this.BaseResetPoint 103548"];
5809 [label="this.TerminatorState 103549"];
5810 [label="this.IsInTry 103550"];
5811 [label="this.IsInAsync 103551"];
5812 [label="this.QueryDepth 103552"];
5813 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 103553"];
5814 [label="_recursionDepth 103554"];
5815 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 103555"];
5816 [label="StatementSyntax result; 103556"];
5817 [label="this.CurrentToken 103557"];
5818 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103558"];
5819 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103559"];
5820 [label="switch (this.CurrentToken.Kind)\n                {\n                    case SyntaxKind.FixedKeyword:\n                        return this.ParseFixedStatement(attributes);\n                    case SyntaxKind.BreakKeyword:\n                        return this.ParseBreakStatement(attributes);\n                    case SyntaxKind.ContinueKeyword:\n                        return this.ParseContinueStatement(attributes);\n                    case SyntaxKind.TryKeyword:\n                    case SyntaxKind.CatchKeyword:\n                    case SyntaxKind.FinallyKeyword:\n                        return this.ParseTryStatement(attributes);\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                        return this.ParseCheckedStatement(attributes);\n                    case SyntaxKind.DoKeyword:\n                        return this.ParseDoStatement(attributes);\n                    case SyntaxKind.ForKeyword:\n                        return this.ParseForOrForEachStatement(attributes);\n                    case SyntaxKind.ForEachKeyword:\n                        return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                    case SyntaxKind.GotoKeyword:\n                        return this.ParseGotoStatement(attributes);\n                    case SyntaxKind.IfKeyword:\n                        return this.ParseIfStatement(attributes);\n                    case SyntaxKind.ElseKeyword:\n                        // Including 'else' keyword to handle 'else without if' error cases \n                        return this.ParseMisplacedElse(attributes);\n                    case SyntaxKind.LockKeyword:\n                        return this.ParseLockStatement(attributes);\n                    case SyntaxKind.ReturnKeyword:\n                        return this.ParseReturnStatement(attributes);\n                    case SyntaxKind.SwitchKeyword:\n                        return this.ParseSwitchStatement(attributes);\n                    case SyntaxKind.ThrowKeyword:\n                        return this.ParseThrowStatement(attributes);\n                    case SyntaxKind.UnsafeKeyword:\n                        result = TryParseStatementStartingWithUnsafe(attributes);\n                        if (result != null)\n                            return result;\n                        break;\n                    case SyntaxKind.UsingKeyword:\n                        return ParseStatementStartingWithUsing(attributes);\n                    case SyntaxKind.WhileKeyword:\n                        return this.ParseWhileStatement(attributes);\n                    case SyntaxKind.OpenBraceToken:\n                        return this.ParseBlock(attributes);\n                    case SyntaxKind.SemicolonToken:\n                        return _syntaxFactory.EmptyStatement(attributes, this.EatToken());\n                    case SyntaxKind.IdentifierToken:\n                        result = TryParseStatementStartingWithIdentifier(attributes, isGlobal);\n                        if (result != null)\n                            return result;\n                        break;\n                } 103560"];
5821 [label="this.CurrentToken.Kind 103561"];
5822 [label="get { return (SyntaxKind)this.RawKind; } 103562"];
5823 [label="return (SyntaxKind)this.RawKind; 103563"];
5824 [label="return this.ParseForOrForEachStatement(attributes); 103564"];
5825 [label="this.ParseForOrForEachStatement(attributes) 103565"];
5826 [label="param ParseForOrForEachStatement(SyntaxList<AttributeListSyntax> attributes) 103566"];
5827 [label="param ParseForOrForEachStatement(this) 103567"];
5828 [label="this.GetResetPoint() 103568"];
5829 [label="param GetResetPoint(this) 103569"];
5830 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103570"];
5831 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103571"];
5832 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103572"];
5833 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103573"];
5834 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 103574"];
5835 [label="param ResetPoint(SyntaxParser.ResetPoint resetPoint) 103575"];
5836 [label="param ResetPoint(TerminatorState terminatorState) 103576"];
5837 [label="param ResetPoint(bool isInTry) 103577"];
5838 [label="param ResetPoint(bool isInAsync) 103578"];
5839 [label="param ResetPoint(int queryDepth) 103579"];
5840 [label="param ResetPoint(this) 103580"];
5841 [label="this.BaseResetPoint 103581"];
5842 [label="this.TerminatorState 103582"];
5843 [label="this.IsInTry 103583"];
5844 [label="this.IsInAsync 103584"];
5845 [label="this.QueryDepth 103585"];
5846 [label="var resetPoint = this.GetResetPoint(); 103586"];
5847 [label="this.CurrentToken 103587"];
5848 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103588"];
5849 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103589"];
5850 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword); 103590"];
5851 [label="this.CurrentToken.Kind 103591"];
5852 [label="get { return (SyntaxKind)this.RawKind; } 103592"];
5853 [label="this.EatToken() 103593"];
5854 [label="param EatToken(this) 103594"];
5855 [label="this.CurrentToken 103595"];
5856 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103596"];
5857 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103597"];
5858 [label="var ct = this.CurrentToken; 103598"];
5859 [label="MoveToNextToken() 103599"];
5860 [label="param MoveToNextToken(this) 103600"];
5861 [label="_currentToken.GetTrailingTrivia() 103601"];
5862 [label="param GetTrailingTrivia(this) 103602"];
5863 [label="return null; 103603"];
5864 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 103604"];
5865 [label="_prevTokenTrailingTrivia 103605"];
5866 [label="_currentToken = null; 103606"];
5867 [label="_currentToken 103607"];
5868 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103608"];
5869 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103609"];
5870 [label="_tokenOffset 103610"];
5871 [label="MoveToNextToken(); 103611"];
5872 [label="return ct; 103612"];
5873 [label="this.EatToken(); 103613"];
5874 [label="this.EatToken() 103614"];
5875 [label="param EatToken(this) 103615"];
5876 [label="this.CurrentToken 103616"];
5877 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103617"];
5878 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103618"];
5879 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103619"];
5880 [label="return _lexedTokens[_tokenOffset]; 103620"];
5881 [label="var ct = this.CurrentToken; 103621"];
5882 [label="MoveToNextToken() 103622"];
5883 [label="param MoveToNextToken(this) 103623"];
5884 [label="_currentToken.GetTrailingTrivia() 103624"];
5885 [label="param GetTrailingTrivia(this) 103625"];
5886 [label="return null; 103626"];
5887 [label="_prevTokenTrailingTrivia = _currentToken.GetTrailingTrivia(); 103627"];
5888 [label="_prevTokenTrailingTrivia 103628"];
5889 [label="_currentToken = null; 103629"];
5890 [label="_currentToken 103630"];
5891 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103631"];
5892 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103632"];
5893 [label="_tokenOffset 103633"];
5894 [label="MoveToNextToken(); 103634"];
5895 [label="return ct; 103635"];
5896 [label="if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                    this.ScanType() != ScanTypeFlags.NotType &&\n                    this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                    this.EatToken().Kind == SyntaxKind.InKeyword)\n                {\n                    // Looks like a foreach statement.  Parse it that way instead\n                    this.Reset(ref resetPoint);\n                    return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                }\n                else\n                {\n                    // Normal for statement.\n                    this.Reset(ref resetPoint);\n                    return this.ParseForStatement(attributes);\n                } 103636"];
5897 [label="this.EatToken().Kind 103637"];
5898 [label="get { return (SyntaxKind)this.RawKind; } 103638"];
5899 [label="if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                    this.ScanType() != ScanTypeFlags.NotType &&\n                    this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                    this.EatToken().Kind == SyntaxKind.InKeyword)\n                {\n                    // Looks like a foreach statement.  Parse it that way instead\n                    this.Reset(ref resetPoint);\n                    return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                }\n                else\n                {\n                    // Normal for statement.\n                    this.Reset(ref resetPoint);\n                    return this.ParseForStatement(attributes);\n                } 103639"];
5900 [label="this.ScanType() 103640"];
5901 [label="param ScanType(bool forPattern = false) 103641"];
5902 [label="param ScanType(this) 103642"];
5903 [label="return ScanType(out _, forPattern); 103643"];
5904 [label="return ScanType(out _, forPattern); 103644"];
5905 [label="ScanType(out _, forPattern) 103645"];
5906 [label="param ScanType(out SyntaxToken lastTokenOfType) 103646"];
5907 [label="param ScanType(bool forPattern = false) 103647"];
5908 [label="param ScanType(this) 103648"];
5909 [label="forPattern 103649"];
5910 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103650"];
5911 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103651"];
5912 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103652"];
5913 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103653"];
5914 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103654"];
5915 [label="param PeekToken(int n) 103655"];
5916 [label="param PeekToken(this) 103656"];
5917 [label="Debug.Assert(n >= 0); 103657"];
5918 [label="Debug.Assert(n >= 0); 103658"];
5919 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103659"];
5920 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 103660"];
5921 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset + n].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset + n];\n            } 103661"];
5922 [label="return _lexedTokens[_tokenOffset + n]; 103662"];
5923 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 103663"];
5924 [label="param ScanNamedTypePart(this) 103664"];
5925 [label="this.CurrentToken 103665"];
5926 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103666"];
5927 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103667"];
5928 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103668"];
5929 [label="this.CurrentToken.Kind 103669"];
5930 [label="get { return (SyntaxKind)this.RawKind; } 103670"];
5931 [label="this.IsTrueIdentifier() 103671"];
5932 [label="param IsTrueIdentifier(this) 103672"];
5933 [label="this.CurrentToken 103673"];
5934 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103674"];
5935 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103675"];
5936 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 103676"];
5937 [label="this.CurrentToken.Kind 103677"];
5938 [label="get { return (SyntaxKind)this.RawKind; } 103678"];
5939 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 103679"];
5940 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 103680"];
5941 [label="this.CurrentToken 103681"];
5942 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103682"];
5943 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 103683"];
5944 [label="this.CurrentToken.ContextualKind 103684"];
5945 [label="get\n            {\n                return this.Kind;\n            } 103685"];
5946 [label="this.Kind 103686"];
5947 [label="get { return (SyntaxKind)this.RawKind; } 103687"];
5948 [label="return this.Kind; 103688"];
5949 [label="return false; 103689"];
5950 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103690"];
5951 [label="IsCurrentTokenQueryKeywordInQuery() 103691"];
5952 [label="param IsCurrentTokenQueryKeywordInQuery(this) 103692"];
5953 [label="this.IsInQuery 103693"];
5954 [label="get { return _syntaxFactoryContext.IsInQuery; } 103694"];
5955 [label="return _syntaxFactoryContext.IsInQuery; 103695"];
5956 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 103696"];
5957 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103697"];
5958 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103698"];
5959 [label="IsCurrentTokenWhereOfConstraintClause() 103699"];
5960 [label="param IsCurrentTokenWhereOfConstraintClause(this) 103700"];
5961 [label="this.CurrentToken 103701"];
5962 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103702"];
5963 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 103703"];
5964 [label="this.CurrentToken.ContextualKind 103704"];
5965 [label="get\n            {\n                return this.Kind;\n            } 103705"];
5966 [label="this.Kind 103706"];
5967 [label="get { return (SyntaxKind)this.RawKind; } 103707"];
5968 [label="return this.Kind; 103708"];
5969 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103709"];
5970 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103710"];
5971 [label="return true; 103711"];
5972 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103712"];
5973 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103713"];
5974 [label="this.EatToken() 103714"];
5975 [label="param EatToken(this) 103715"];
5976 [label="this.CurrentToken 103716"];
5977 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103717"];
5978 [label="var ct = this.CurrentToken; 103718"];
5979 [label="MoveToNextToken() 103719"];
5980 [label="_currentToken.GetTrailingTrivia() 103720"];
5981 [label="param GetTrailingTrivia(this) 103721"];
5982 [label="return _trailing; 103722"];
5983 [label="_currentToken = null; 103723"];
5984 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103724"];
5985 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103725"];
5986 [label="_tokenOffset 103726"];
5987 [label="MoveToNextToken(); 103727"];
5988 [label="return ct; 103728"];
5989 [label="lastTokenOfType = this.EatToken(); 103729"];
5990 [label="this.CurrentToken 103730"];
5991 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103731"];
5992 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103732"];
5993 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103733"];
5994 [label="return _lexedTokens[_tokenOffset]; 103734"];
5995 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                return this.ScanPossibleTypeArgumentList(ref lastTokenOfType, out _);\n            }\n            else\n            {\n                return ScanTypeFlags.NonGenericTypeOrExpression;\n            } 103735"];
5996 [label="this.CurrentToken.Kind 103736"];
5997 [label="get { return (SyntaxKind)this.RawKind; } 103737"];
5998 [label="return ScanTypeFlags.NonGenericTypeOrExpression; 103738"];
5999 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103739"];
6000 [label="param IsDotOrColonColon(this) 103740"];
6001 [label="this.CurrentToken 103741"];
6002 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103742"];
6003 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103743"];
6004 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 103744"];
6005 [label="this.CurrentToken.Kind 103745"];
6006 [label="get { return (SyntaxKind)this.RawKind; } 103746"];
6007 [label="this.CurrentToken 103747"];
6008 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103748"];
6009 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103749"];
6010 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 103750"];
6011 [label="this.CurrentToken.Kind 103751"];
6012 [label="get { return (SyntaxKind)this.RawKind; } 103752"];
6013 [label="return this.CurrentToken.Kind == SyntaxKind.DotToken || this.CurrentToken.Kind == SyntaxKind.ColonColonToken; 103753"];
6014 [label="param IsMakingProgress(ref int lastTokenPosition) 103754"];
6015 [label="param IsMakingProgress(bool assertIfFalse = true) 103755"];
6016 [label="param IsMakingProgress(this) 103756"];
6017 [label="CurrentTokenPosition 103757"];
6018 [label="=> _firstToken + _tokenOffset 103758"];
6019 [label="_firstToken + _tokenOffset 103759"];
6020 [label="var pos = CurrentTokenPosition; 103760"];
6021 [label="if (pos > lastTokenPosition)\n            {\n                lastTokenPosition = pos;\n                return true;\n            } 103761"];
6022 [label="lastTokenPosition = pos; 103762"];
6023 [label="return true; 103763"];
6024 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103764"];
6025 [label="return ScanType(forPattern ? ParseTypeMode.DefinitePattern : ParseTypeMode.Normal, out lastTokenOfType); 103765"];
6026 [label="if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                    this.ScanType() != ScanTypeFlags.NotType &&\n                    this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                    this.EatToken().Kind == SyntaxKind.InKeyword)\n                {\n                    // Looks like a foreach statement.  Parse it that way instead\n                    this.Reset(ref resetPoint);\n                    return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                }\n                else\n                {\n                    // Normal for statement.\n                    this.Reset(ref resetPoint);\n                    return this.ParseForStatement(attributes);\n                } 103766"];
6027 [label="this.EatToken() 103767"];
6028 [label="param EatToken(this) 103768"];
6029 [label="this.CurrentToken 103769"];
6030 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103770"];
6031 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103771"];
6032 [label="MoveToNextToken() 103772"];
6033 [label="param MoveToNextToken(this) 103773"];
6034 [label="_currentToken.GetTrailingTrivia() 103774"];
6035 [label="param GetTrailingTrivia(this) 103775"];
6036 [label="_currentToken = null; 103776"];
6037 [label="_currentToken 103777"];
6038 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103778"];
6039 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103779"];
6040 [label="_tokenOffset 103780"];
6041 [label="MoveToNextToken(); 103781"];
6042 [label="this.EatToken().Kind 103782"];
6043 [label="get { return (SyntaxKind)this.RawKind; } 103783"];
6044 [label="if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                    this.ScanType() != ScanTypeFlags.NotType &&\n                    this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                    this.EatToken().Kind == SyntaxKind.InKeyword)\n                {\n                    // Looks like a foreach statement.  Parse it that way instead\n                    this.Reset(ref resetPoint);\n                    return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                }\n                else\n                {\n                    // Normal for statement.\n                    this.Reset(ref resetPoint);\n                    return this.ParseForStatement(attributes);\n                } 103784"];
6045 [label="this.EatToken() 103785"];
6046 [label="param EatToken(this) 103786"];
6047 [label="this.CurrentToken 103787"];
6048 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103788"];
6049 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103789"];
6050 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103790"];
6051 [label="return _lexedTokens[_tokenOffset]; 103791"];
6052 [label="MoveToNextToken() 103792"];
6053 [label="param MoveToNextToken(this) 103793"];
6054 [label="_currentToken.GetTrailingTrivia() 103794"];
6055 [label="param GetTrailingTrivia(this) 103795"];
6056 [label="return this.TrailingField; 103796"];
6057 [label="_currentToken = null; 103797"];
6058 [label="_currentToken 103798"];
6059 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103799"];
6060 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103800"];
6061 [label="_tokenOffset 103801"];
6062 [label="MoveToNextToken(); 103802"];
6063 [label="this.EatToken().Kind 103803"];
6064 [label="get { return (SyntaxKind)this.RawKind; } 103804"];
6065 [label="if (this.EatToken().Kind == SyntaxKind.OpenParenToken &&\n                    this.ScanType() != ScanTypeFlags.NotType &&\n                    this.EatToken().Kind == SyntaxKind.IdentifierToken &&\n                    this.EatToken().Kind == SyntaxKind.InKeyword)\n                {\n                    // Looks like a foreach statement.  Parse it that way instead\n                    this.Reset(ref resetPoint);\n                    return this.ParseForEachStatement(attributes, awaitTokenOpt: null);\n                }\n                else\n                {\n                    // Normal for statement.\n                    this.Reset(ref resetPoint);\n                    return this.ParseForStatement(attributes);\n                } 103805"];
6066 [label="this.Reset(ref resetPoint); 103806"];
6067 [label="this.Reset(ref resetPoint) 103807"];
6068 [label="param Reset(ref ResetPoint state) 103808"];
6069 [label="param Reset(this) 103809"];
6070 [label="_termState 103810"];
6071 [label="_isInTry 103811"];
6072 [label="_syntaxFactoryContext.IsInAsync 103812"];
6073 [label="_syntaxFactoryContext.QueryDepth 103813"];
6074 [label="base.Reset(ref state.BaseResetPoint); 103814"];
6075 [label="base.Reset(ref state.BaseResetPoint) 103815"];
6076 [label="param Reset(ref ResetPoint point) 103816"];
6077 [label="param Reset(this) 103817"];
6078 [label="var offset = point.Position - _firstToken; 103818"];
6079 [label="Debug.Assert(offset >= 0); 103819"];
6080 [label="Debug.Assert(offset >= 0); 103820"];
6081 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 103821"];
6082 [label="_mode 103822"];
6083 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 103823"];
6084 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 103824"];
6085 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 103825"];
6086 [label="_tokenOffset 103826"];
6087 [label="_currentToken = null; 103827"];
6088 [label="_currentToken 103828"];
6089 [label="_currentNode = default(BlendedNode); 103829"];
6090 [label="_currentNode 103830"];
6091 [label="_prevTokenTrailingTrivia 103831"];
6092 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 103832"];
6093 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 103833"];
6094 [label="base.Reset(ref state.BaseResetPoint); 103834"];
6095 [label="this.Reset(ref resetPoint); 103835"];
6096 [label="return this.ParseForStatement(attributes); 103836"];
6097 [label="this.ParseForStatement(attributes) 103837"];
6098 [label="param ParseForStatement(SyntaxList<AttributeListSyntax> attributes) 103838"];
6099 [label="param ParseForStatement(this) 103839"];
6100 [label="this.CurrentToken 103840"];
6101 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103841"];
6102 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103842"];
6103 [label="return _lexedTokens[_tokenOffset]; 103843"];
6104 [label="Debug.Assert(this.CurrentToken.Kind == SyntaxKind.ForKeyword); 103844"];
6105 [label="this.CurrentToken.Kind 103845"];
6106 [label="get { return (SyntaxKind)this.RawKind; } 103846"];
6107 [label="var forToken = this.EatToken(SyntaxKind.ForKeyword); 103847"];
6108 [label="this.EatToken(SyntaxKind.ForKeyword) 103848"];
6109 [label="param EatToken(SyntaxKind kind) 103849"];
6110 [label="param EatToken(this) 103850"];
6111 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 103851"];
6112 [label="SyntaxFacts.IsAnyToken(kind) 103852"];
6113 [label="param IsAnyToken(SyntaxKind kind) 103853"];
6114 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 103854"];
6115 [label="return true; 103855"];
6116 [label="this.CurrentToken 103856"];
6117 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103857"];
6118 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103858"];
6119 [label="var ct = this.CurrentToken; 103859"];
6120 [label="ct.Kind 103860"];
6121 [label="get { return (SyntaxKind)this.RawKind; } 103861"];
6122 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 103862"];
6123 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 103863"];
6124 [label="MoveToNextToken() 103864"];
6125 [label="param GetTrailingTrivia(this) 103865"];
6126 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103866"];
6127 [label="MoveToNextToken(); 103867"];
6128 [label="return ct; 103868"];
6129 [label="var openParen = this.EatToken(SyntaxKind.OpenParenToken); 103869"];
6130 [label="this.EatToken(SyntaxKind.OpenParenToken) 103870"];
6131 [label="param EatToken(SyntaxKind kind) 103871"];
6132 [label="param EatToken(this) 103872"];
6133 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 103873"];
6134 [label="SyntaxFacts.IsAnyToken(kind) 103874"];
6135 [label="param IsAnyToken(SyntaxKind kind) 103875"];
6136 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 103876"];
6137 [label="return true; 103877"];
6138 [label="this.CurrentToken 103878"];
6139 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103879"];
6140 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103880"];
6141 [label="return _lexedTokens[_tokenOffset]; 103881"];
6142 [label="ct.Kind 103882"];
6143 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 103883"];
6144 [label="param GetTrailingTrivia(this) 103884"];
6145 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103885"];
6146 [label="MoveToNextToken(); 103886"];
6147 [label="return ct; 103887"];
6148 [label="var saveTerm = _termState; 103888"];
6149 [label="_termState |= TerminatorState.IsEndOfForStatementArgument; 103889"];
6150 [label="_termState 103890"];
6151 [label="this.GetResetPoint() 103891"];
6152 [label="param GetResetPoint(this) 103892"];
6153 [label="_firstToken + _tokenOffset 103893"];
6154 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103894"];
6155 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103895"];
6156 [label="return new ResetPoint(_resetCount, _mode, pos, _prevTokenTrailingTrivia); 103896"];
6157 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 103897"];
6158 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 103898"];
6159 [label="param ResetPoint(this) 103899"];
6160 [label="var resetPoint = this.GetResetPoint(); 103900"];
6161 [label="var initializers = _pool.AllocateSeparated<ExpressionSyntax>(); 103901"];
6162 [label="var incrementors = _pool.AllocateSeparated<ExpressionSyntax>(); 103902"];
6163 [label="VariableDeclarationSyntax decl = null; 103903"];
6164 [label="bool isDeclaration = false; 103904"];
6165 [label="this.CurrentToken 103905"];
6166 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103906"];
6167 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103907"];
6168 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 103908"];
6169 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n                {\n                    isDeclaration = true;\n                }\n                else\n                {\n                    isDeclaration = !this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) &&\n                                    this.ScanType() != ScanTypeFlags.NotType &&\n                                    this.IsTrueIdentifier();\n\n                    this.Reset(ref resetPoint);\n                } 103909"];
6170 [label="this.CurrentToken.Kind 103910"];
6171 [label="get { return (SyntaxKind)this.RawKind; } 103911"];
6172 [label="isDeclaration = !this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) &&\n                                    this.ScanType() != ScanTypeFlags.NotType &&\n                                    this.IsTrueIdentifier(); 103912"];
6173 [label="this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) 103913"];
6174 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 103914"];
6175 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 103915"];
6176 [label="param IsQueryExpression(this) 103916"];
6177 [label="this.CurrentToken 103917"];
6178 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103918"];
6179 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 103919"];
6180 [label="this.CurrentToken.ContextualKind 103920"];
6181 [label="get\n            {\n                return this.Kind;\n            } 103921"];
6182 [label="this.Kind 103922"];
6183 [label="get { return (SyntaxKind)this.RawKind; } 103923"];
6184 [label="return this.Kind; 103924"];
6185 [label="return false; 103925"];
6186 [label="isDeclaration = !this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) &&\n                                    this.ScanType() != ScanTypeFlags.NotType &&\n                                    this.IsTrueIdentifier(); 103926"];
6187 [label="this.ScanType() 103927"];
6188 [label="param ScanType(bool forPattern = false) 103928"];
6189 [label="Debug.Assert(n >= 0); 103929"];
6190 [label="Debug.Assert(n >= 0); 103930"];
6191 [label="while (_tokenOffset + n >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103931"];
6192 [label="param ScanNamedTypePart(out SyntaxToken lastTokenOfType) 103932"];
6193 [label="this.CurrentToken 103933"];
6194 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103934"];
6195 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103935"];
6196 [label="this.CurrentToken.Kind 103936"];
6197 [label="get { return (SyntaxKind)this.RawKind; } 103937"];
6198 [label="this.IsTrueIdentifier() 103938"];
6199 [label="param IsTrueIdentifier(this) 103939"];
6200 [label="this.CurrentToken 103940"];
6201 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103941"];
6202 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 103942"];
6203 [label="this.CurrentToken.Kind 103943"];
6204 [label="get { return (SyntaxKind)this.RawKind; } 103944"];
6205 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 103945"];
6206 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 103946"];
6207 [label="this.CurrentToken 103947"];
6208 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103948"];
6209 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 103949"];
6210 [label="this.CurrentToken.ContextualKind 103950"];
6211 [label="get\n            {\n                return this.Kind;\n            } 103951"];
6212 [label="this.Kind 103952"];
6213 [label="get { return (SyntaxKind)this.RawKind; } 103953"];
6214 [label="return this.Kind; 103954"];
6215 [label="return false; 103955"];
6216 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103956"];
6217 [label="IsCurrentTokenQueryKeywordInQuery() 103957"];
6218 [label="param IsCurrentTokenQueryKeywordInQuery(this) 103958"];
6219 [label="this.IsInQuery 103959"];
6220 [label="get { return _syntaxFactoryContext.IsInQuery; } 103960"];
6221 [label="return _syntaxFactoryContext.IsInQuery; 103961"];
6222 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 103962"];
6223 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103963"];
6224 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103964"];
6225 [label="IsCurrentTokenWhereOfConstraintClause() 103965"];
6226 [label="param IsCurrentTokenWhereOfConstraintClause(this) 103966"];
6227 [label="this.CurrentToken 103967"];
6228 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103968"];
6229 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 103969"];
6230 [label="this.CurrentToken.ContextualKind 103970"];
6231 [label="get\n            {\n                return this.Kind;\n            } 103971"];
6232 [label="this.Kind 103972"];
6233 [label="get { return (SyntaxKind)this.RawKind; } 103973"];
6234 [label="return this.Kind; 103974"];
6235 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103975"];
6236 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 103976"];
6237 [label="return true; 103977"];
6238 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103978"];
6239 [label="if (this.CurrentToken.Kind != SyntaxKind.IdentifierToken || !this.IsTrueIdentifier())\n            {\n                lastTokenOfType = null;\n                return ScanTypeFlags.NotType;\n            } 103979"];
6240 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103980"];
6241 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 103981"];
6242 [label="MoveToNextToken(); 103982"];
6243 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 103983"];
6244 [label="param IsMakingProgress(bool assertIfFalse = true) 103984"];
6245 [label="isDeclaration = !this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) &&\n                                    this.ScanType() != ScanTypeFlags.NotType &&\n                                    this.IsTrueIdentifier(); 103985"];
6246 [label="this.IsTrueIdentifier() 103986"];
6247 [label="param IsTrueIdentifier(this) 103987"];
6248 [label="this.CurrentToken 103988"];
6249 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103989"];
6250 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 103990"];
6251 [label="if (this.CurrentToken.Kind == SyntaxKind.IdentifierToken)\n            {\n                if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                }\n            } 103991"];
6252 [label="this.CurrentToken.Kind 103992"];
6253 [label="get { return (SyntaxKind)this.RawKind; } 103993"];
6254 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 103994"];
6255 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 103995"];
6256 [label="this.CurrentToken 103996"];
6257 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 103997"];
6258 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 103998"];
6259 [label="this.CurrentToken.ContextualKind 103999"];
6260 [label="get\n            {\n                return this.Kind;\n            } 104000"];
6261 [label="this.Kind 104001"];
6262 [label="get { return (SyntaxKind)this.RawKind; } 104002"];
6263 [label="return this.Kind; 104003"];
6264 [label="return false; 104004"];
6265 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 104005"];
6266 [label="IsCurrentTokenQueryKeywordInQuery() 104006"];
6267 [label="param IsCurrentTokenQueryKeywordInQuery(this) 104007"];
6268 [label="this.IsInQuery 104008"];
6269 [label="get { return _syntaxFactoryContext.IsInQuery; } 104009"];
6270 [label="return _syntaxFactoryContext.IsInQuery; 104010"];
6271 [label="return this.IsInQuery && this.IsCurrentTokenQueryContextualKeyword; 104011"];
6272 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 104012"];
6273 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 104013"];
6274 [label="IsCurrentTokenWhereOfConstraintClause() 104014"];
6275 [label="param IsCurrentTokenWhereOfConstraintClause(this) 104015"];
6276 [label="this.CurrentToken 104016"];
6277 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104017"];
6278 [label="return\n                this.CurrentToken.ContextualKind == SyntaxKind.WhereKeyword &&\n                this.PeekToken(1).Kind == SyntaxKind.IdentifierToken &&\n                this.PeekToken(2).Kind == SyntaxKind.ColonToken; 104018"];
6279 [label="this.CurrentToken.ContextualKind 104019"];
6280 [label="get\n            {\n                return this.Kind;\n            } 104020"];
6281 [label="this.Kind 104021"];
6282 [label="get { return (SyntaxKind)this.RawKind; } 104022"];
6283 [label="return this.Kind; 104023"];
6284 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 104024"];
6285 [label="if (!IsCurrentTokenPartialKeywordOfPartialMethodOrType() &&\n                    !IsCurrentTokenQueryKeywordInQuery() &&\n                    !IsCurrentTokenWhereOfConstraintClause())\n                {\n                    return true;\n                } 104025"];
6286 [label="return true; 104026"];
6287 [label="isDeclaration = !this.IsQueryExpression(mayBeVariableDeclaration: true, mayBeMemberDeclaration: false) &&\n                                    this.ScanType() != ScanTypeFlags.NotType &&\n                                    this.IsTrueIdentifier(); 104027"];
6288 [label="this.Reset(ref resetPoint); 104028"];
6289 [label="this.Reset(ref resetPoint) 104029"];
6290 [label="param Reset(ref ResetPoint state) 104030"];
6291 [label="_syntaxFactoryContext.IsInAsync 104031"];
6292 [label="_syntaxFactoryContext.QueryDepth 104032"];
6293 [label="var offset = point.Position - _firstToken; 104033"];
6294 [label="Debug.Assert(offset >= 0); 104034"];
6295 [label="Debug.Assert(offset >= 0); 104035"];
6296 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 104036"];
6297 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104037"];
6298 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104038"];
6299 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104039"];
6300 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 104040"];
6301 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 104041"];
6302 [label="this.Reset(ref resetPoint); 104042"];
6303 [label="if (isDeclaration)\n                {\n                    decl = ParseVariableDeclaration();\n                    if (decl.Type.Kind == SyntaxKind.RefType)\n                    {\n                        decl = decl.Update(\n                            CheckFeatureAvailability(decl.Type, MessageID.IDS_FeatureRefFor),\n                            decl.Variables);\n                    }\n                }\n                else if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    // Not a type followed by an identifier, so it must be an expression list.\n                    this.ParseForStatementExpressionList(ref openParen, initializers);\n                } 104043"];
6304 [label="ParseVariableDeclaration() 104044"];
6305 [label="param ParseVariableDeclaration(this) 104045"];
6306 [label="var variables = _pool.AllocateSeparated<VariableDeclaratorSyntax>(); 104046"];
6307 [label="TypeSyntax type; 104047"];
6308 [label="LocalFunctionStatementSyntax localFunction; 104048"];
6309 [label="ParseLocalDeclaration(variables, false, attributes: default, mods: default, out type, out localFunction); 104049"];
6310 [label="ParseLocalDeclaration(variables, false, attributes: default, mods: default, out type, out localFunction); 104050"];
6311 [label="ParseLocalDeclaration(variables, false, attributes: default, mods: default, out type, out localFunction); 104051"];
6312 [label="ParseLocalDeclaration(variables, false, attributes: default, mods: default, out type, out localFunction); 104052"];
6313 [label="ParseLocalDeclaration(variables, false, attributes: default, mods: default, out type, out localFunction) 104053"];
6314 [label="param ParseLocalDeclaration(SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables) 104054"];
6315 [label="param ParseLocalDeclaration(bool allowLocalFunctions) 104055"];
6316 [label="param ParseLocalDeclaration(SyntaxList<AttributeListSyntax> attributes) 104056"];
6317 [label="param ParseLocalDeclaration(SyntaxList<SyntaxToken> mods) 104057"];
6318 [label="param ParseLocalDeclaration(out TypeSyntax type) 104058"];
6319 [label="param ParseLocalDeclaration(out LocalFunctionStatementSyntax localFunction) 104059"];
6320 [label="param ParseLocalDeclaration(this) 104060"];
6321 [label="allowLocalFunctions 104061"];
6322 [label="type = allowLocalFunctions ? ParseReturnType() : this.ParseType(); 104062"];
6323 [label="this.ParseType() 104063"];
6324 [label="param ParseType(ParseTypeMode mode = ParseTypeMode.Normal) 104064"];
6325 [label="param ParseType(this) 104065"];
6326 [label="this.CurrentToken 104066"];
6327 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104067"];
6328 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104068"];
6329 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104069"];
6330 [label="if (this.CurrentToken.Kind == SyntaxKind.RefKeyword)\n            {\n                var refKeyword = this.EatToken();\n                refKeyword = this.CheckFeatureAvailability(refKeyword, MessageID.IDS_FeatureRefLocalsReturns);\n\n                SyntaxToken readonlyKeyword = null;\n                if (this.CurrentToken.Kind == SyntaxKind.ReadOnlyKeyword)\n                {\n                    readonlyKeyword = this.EatToken();\n                    readonlyKeyword = this.CheckFeatureAvailability(readonlyKeyword, MessageID.IDS_FeatureReadOnlyReferences);\n                }\n\n                var type = ParseTypeCore(ParseTypeMode.AfterRef);\n                return _syntaxFactory.RefType(refKeyword, readonlyKeyword, type);\n            } 104070"];
6331 [label="this.CurrentToken.Kind 104071"];
6332 [label="get { return (SyntaxKind)this.RawKind; } 104072"];
6333 [label="return ParseTypeCore(mode); 104073"];
6334 [label="return ParseTypeCore(mode); 104074"];
6335 [label="return ParseTypeCore(mode); 104075"];
6336 [label="param ParseUnderlyingType(ParseTypeMode mode) 104076"];
6337 [label="param ParseUnderlyingType(NameOptions options = NameOptions.None) 104077"];
6338 [label="param ParseUnderlyingType(this) 104078"];
6339 [label="this.CurrentToken 104079"];
6340 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104080"];
6341 [label="if (IsPredefinedType(this.CurrentToken.Kind))\n            {\n                // This is a predefined type\n                var token = this.EatToken();\n                if (token.Kind == SyntaxKind.VoidKeyword && this.CurrentToken.Kind != SyntaxKind.AsteriskToken)\n                {\n                    token = this.AddError(token, mode == ParseTypeMode.Parameter ? ErrorCode.ERR_NoVoidParameter : ErrorCode.ERR_NoVoidHere);\n                }\n\n                return _syntaxFactory.PredefinedType(token);\n            } 104081"];
6342 [label="this.CurrentToken.Kind 104082"];
6343 [label="get { return (SyntaxKind)this.RawKind; } 104083"];
6344 [label="IsPredefinedType(this.CurrentToken.Kind) 104084"];
6345 [label="param IsPredefinedType(SyntaxKind keyword) 104085"];
6346 [label="return SyntaxFacts.IsPredefinedType(keyword); 104086"];
6347 [label="SyntaxFacts.IsPredefinedType(keyword) 104087"];
6348 [label="param IsPredefinedType(SyntaxKind kind) 104088"];
6349 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 104089"];
6350 [label="return false; 104090"];
6351 [label="IsTrueIdentifier() 104091"];
6352 [label="param IsTrueIdentifier(this) 104092"];
6353 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 104093"];
6354 [label="this.CurrentToken 104094"];
6355 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104095"];
6356 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 104096"];
6357 [label="this.CurrentToken.ContextualKind 104097"];
6358 [label="get\n            {\n                return this.Kind;\n            } 104098"];
6359 [label="if (IsTrueIdentifier() || this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                return this.ParseQualifiedName(options);\n            } 104099"];
6360 [label="return this.ParseQualifiedName(options); 104100"];
6361 [label="this.ParseQualifiedName(options) 104101"];
6362 [label="param ParseQualifiedName(NameOptions options = NameOptions.None) 104102"];
6363 [label="param ParseQualifiedName(this) 104103"];
6364 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 104104"];
6365 [label="this.ParseAliasQualifiedName(options) 104105"];
6366 [label="param ParseAliasQualifiedName(NameOptions allowedParts = NameOptions.None) 104106"];
6367 [label="param ParseAliasQualifiedName(this) 104107"];
6368 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 104108"];
6369 [label="this.ParseSimpleName(allowedParts) 104109"];
6370 [label="param ParseSimpleName(NameOptions options = NameOptions.None) 104110"];
6371 [label="param ParseSimpleName(this) 104111"];
6372 [label="var id = this.ParseIdentifierName(); 104112"];
6373 [label="this.ParseIdentifierName() 104113"];
6374 [label="param ParseIdentifierName(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 104114"];
6375 [label="param ParseIdentifierName(this) 104115"];
6376 [label="this.IsIncrementalAndFactoryContextMatches 104116"];
6377 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 104117"];
6378 [label="base.IsIncremental 104118"];
6379 [label="get\n            {\n                return _isIncremental;\n            } 104119"];
6380 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 104120"];
6381 [label="return false; 104121"];
6382 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.IdentifierName)\n            {\n                if (!SyntaxFacts.IsContextualKeyword(((CSharp.Syntax.IdentifierNameSyntax)this.CurrentNode).Identifier.Kind()))\n                {\n                    return (IdentifierNameSyntax)this.EatNode();\n                }\n            } 104122"];
6383 [label="var tk = ParseIdentifierToken(code); 104123"];
6384 [label="ParseIdentifierToken(code) 104124"];
6385 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 104125"];
6386 [label="param ParseIdentifierToken(this) 104126"];
6387 [label="this.CurrentToken 104127"];
6388 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104128"];
6389 [label="var ctk = this.CurrentToken.Kind; 104129"];
6390 [label="this.CurrentToken.Kind 104130"];
6391 [label="get { return (SyntaxKind)this.RawKind; } 104131"];
6392 [label="if (ctk == SyntaxKind.IdentifierToken)\n            {\n                // Error tolerance for IntelliSense. Consider the following case: [EditorBrowsable( partial class Goo {\n                // } Because we're parsing an attribute argument we'll end up consuming the 'partial' identifier and\n                // we'll eventually end up in a pretty confused state.  Because of that it becomes very difficult to\n                // show the correct parameter help in this case.  So, when we see 'partial' we check if it's being used\n                // as an identifier or as a contextual keyword.  If it's the latter then we bail out.  See\n                // Bug: vswhidbey/542125\n                if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                }\n\n                SyntaxToken identifierToken = this.EatToken();\n\n                if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                }\n\n                return identifierToken;\n            }\n            else\n            {\n                var name = CreateMissingIdentifierToken();\n                name = this.AddError(name, code);\n                return name;\n            } 104132"];
6393 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 104133"];
6394 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 104134"];
6395 [label="this.CurrentToken 104135"];
6396 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104136"];
6397 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 104137"];
6398 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104138"];
6399 [label="IsCurrentTokenQueryKeywordInQuery() 104139"];
6400 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104140"];
6401 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104141"];
6402 [label="this.EatToken() 104142"];
6403 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104143"];
6404 [label="MoveToNextToken(); 104144"];
6405 [label="SyntaxToken identifierToken = this.EatToken(); 104145"];
6406 [label="this.IsInAsync 104146"];
6407 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 104147"];
6408 [label="return _syntaxFactoryContext.IsInAsync; 104148"];
6409 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 104149"];
6410 [label="return identifierToken; 104150"];
6411 [label="var tk = ParseIdentifierToken(code); 104151"];
6412 [label="return SyntaxFactory.IdentifierName(tk); 104152"];
6413 [label="return SyntaxFactory.IdentifierName(tk); 104153"];
6414 [label="param CSharpSyntaxNode(SyntaxKind kind) 104154"];
6415 [label="param CSharpSyntaxNode(this) 104155"];
6416 [label="kind 104156"];
6417 [label="param CSharpSyntaxNode(this) 104157"];
6418 [label="param CSharpSyntaxNode(this) 104158"];
6419 [label="GreenStats.NoteGreen(this); 104159"];
6420 [label="GreenStats.NoteGreen(this); 104160"];
6421 [label="var id = this.ParseIdentifierName(); 104161"];
6422 [label="if (id.Identifier.IsMissing)\n            {\n                return id;\n            } 104162"];
6423 [label="SimpleNameSyntax name = id; 104163"];
6424 [label="this.CurrentToken 104164"];
6425 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104165"];
6426 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104166"];
6427 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104167"];
6428 [label="if (this.CurrentToken.Kind == SyntaxKind.LessThanToken)\n            {\n                var pt = this.GetResetPoint();\n                var kind = this.ScanTypeArgumentList(options);\n                this.Reset(ref pt);\n                this.Release(ref pt);\n\n                if (kind == ScanTypeArgumentListKind.DefiniteTypeArgumentList || (kind == ScanTypeArgumentListKind.PossibleTypeArgumentList && (options & NameOptions.InTypeList) != 0))\n                {\n                    Debug.Assert(this.CurrentToken.Kind == SyntaxKind.LessThanToken);\n                    SyntaxToken open;\n                    var types = _pool.AllocateSeparated<TypeSyntax>();\n                    SyntaxToken close;\n                    this.ParseTypeArgumentList(out open, types, out close);\n                    name = _syntaxFactory.GenericName(id.Identifier,\n                        _syntaxFactory.TypeArgumentList(open, types, close));\n                    _pool.Free(types);\n                }\n            } 104168"];
6429 [label="this.CurrentToken.Kind 104169"];
6430 [label="get { return (SyntaxKind)this.RawKind; } 104170"];
6431 [label="return name; 104171"];
6432 [label="NameSyntax name = this.ParseSimpleName(allowedParts); 104172"];
6433 [label="this.CurrentToken 104173"];
6434 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104174"];
6435 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104175"];
6436 [label="if (this.CurrentToken.Kind == SyntaxKind.ColonColonToken)\n            {\n                var token = this.EatToken();\n\n                name = ParseQualifiedNameRight(allowedParts, name, token);\n            } 104176"];
6437 [label="this.CurrentToken.Kind 104177"];
6438 [label="get { return (SyntaxKind)this.RawKind; } 104178"];
6439 [label="return name; 104179"];
6440 [label="NameSyntax name = this.ParseAliasQualifiedName(options); 104180"];
6441 [label="this.IsDotOrColonColon() 104181"];
6442 [label="param IsDotOrColonColon(this) 104182"];
6443 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104183"];
6444 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 104184"];
6445 [label="this.CurrentToken 104185"];
6446 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104186"];
6447 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104187"];
6448 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 104188"];
6449 [label="this.CurrentToken.Kind 104189"];
6450 [label="get { return (SyntaxKind)this.RawKind; } 104190"];
6451 [label="while (this.IsDotOrColonColon() || this.CurrentToken.Kind == SyntaxKind.DotDotToken)\n            {\n                if (this.PeekToken(1).Kind == SyntaxKind.ThisKeyword)\n                {\n                    break;\n                }\n\n                var separator = this.EatToken();\n                name = ParseQualifiedNameRight(options, name, separator);\n            } 104191"];
6452 [label="return name; 104192"];
6453 [label="return this.ParseQualifiedName(options); 104193"];
6454 [label="return ParseTypeCore(mode); 104194"];
6455 [label="param IsMakingProgress(bool assertIfFalse = true) 104195"];
6456 [label="VariableFlags flags = VariableFlags.Local; 104196"];
6457 [label="if (mods.Any((int)SyntaxKind.ConstKeyword))\n            {\n                flags |= VariableFlags.Const;\n            } 104197"];
6458 [label="if (mods.Any((int)SyntaxKind.ConstKeyword))\n            {\n                flags |= VariableFlags.Const;\n            } 104198"];
6459 [label="var saveTerm = _termState; 104199"];
6460 [label="_termState |= TerminatorState.IsEndOfDeclarationClause; 104200"];
6461 [label="_termState 104201"];
6462 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104202"];
6463 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104203"];
6464 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104204"];
6465 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104205"];
6466 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104206"];
6467 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104207"];
6468 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104208"];
6469 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction); 104209"];
6470 [label="this.ParseVariableDeclarators(\n                type,\n                flags,\n                variables,\n                variableDeclarationsExpected: true,\n                allowLocalFunctions: allowLocalFunctions,\n                attributes: attributes,\n                mods: mods,\n                localFunction: out localFunction) 104210"];
6471 [label="param ParseVariableDeclarators(TypeSyntax type) 104211"];
6472 [label="param ParseVariableDeclarators(VariableFlags flags) 104212"];
6473 [label="param ParseVariableDeclarators(SeparatedSyntaxListBuilder<VariableDeclaratorSyntax> variables) 104213"];
6474 [label="param ParseVariableDeclarators(bool variableDeclarationsExpected) 104214"];
6475 [label="param ParseVariableDeclarators(bool allowLocalFunctions) 104215"];
6476 [label="param ParseVariableDeclarators(SyntaxList<AttributeListSyntax> attributes) 104216"];
6477 [label="param ParseVariableDeclarators(SyntaxList<SyntaxToken> mods) 104217"];
6478 [label="param ParseVariableDeclarators(out LocalFunctionStatementSyntax localFunction) 104218"];
6479 [label="param ParseVariableDeclarators(this) 104219"];
6480 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104220"];
6481 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104221"];
6482 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104222"];
6483 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104223"];
6484 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104224"];
6485 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104225"];
6486 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104226"];
6487 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104227"];
6488 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 104228"];
6489 [label="base.IsIncremental 104229"];
6490 [label="get\n            {\n                return _isIncremental;\n            } 104230"];
6491 [label="if (!base.IsIncremental)\n                {\n                    return false;\n                } 104231"];
6492 [label="return false; 104232"];
6493 [label="param GetLastToken(this) 104233"];
6494 [label="return (SyntaxToken)this.GetLastTerminal(); 104234"];
6495 [label="get { return new SyntaxList<CSharpSyntaxNode>(this.GetTrailingTrivia()); } 104235"];
6496 [label="this.GetTrailingTrivia() 104236"];
6497 [label="param GetTrailingTrivia(this) 104237"];
6498 [label="return _trailing; 104238"];
6499 [label="return new SyntaxList<CSharpSyntaxNode>(this.GetTrailingTrivia()); 104239"];
6500 [label="Debug.Assert(offset >= 0); 104240"];
6501 [label="Debug.Assert(offset >= 0); 104241"];
6502 [label="if (offset >= _tokenCount)\n            {\n                // Re-fetch tokens to the position in the reset point\n                PeekToken(offset - _tokenOffset);\n\n                // Re-calculate new offset in case tokens got shifted to the left while we were peeking. \n                offset = point.Position - _firstToken;\n            } 104242"];
6503 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104243"];
6504 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104244"];
6505 [label="Debug.Assert(offset >= 0 && offset < _tokenCount); 104245"];
6506 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 104246"];
6507 [label="if (_blendedTokens != null)\n            {\n                // look forward for slots not holding a token\n                for (int i = _tokenOffset; i < _tokenCount; i++)\n                {\n                    if (_blendedTokens[i].Token == null)\n                    {\n                        // forget anything after and including any slot not holding a token\n                        _tokenCount = i;\n                        if (_tokenCount == _tokenOffset)\n                        {\n                            FetchCurrentToken();\n                        }\n                        break;\n                    }\n                }\n            } 104247"];
6508 [label="param Release(ref ResetPoint state) 104248"];
6509 [label="param Release(this) 104249"];
6510 [label="base.Release(ref state.BaseResetPoint); 104250"];
6511 [label="base.Release(ref state.BaseResetPoint) 104251"];
6512 [label="param Release(ref ResetPoint point) 104252"];
6513 [label="param Release(this) 104253"];
6514 [label="Debug.Assert(_resetCount == point.ResetCount); 104254"];
6515 [label="_resetCount 104255"];
6516 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104256"];
6517 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104257"];
6518 [label="base.Release(ref state.BaseResetPoint); 104258"];
6519 [label="param ParseIdentifierToken(ErrorCode code = ErrorCode.ERR_IdentifierExpected) 104259"];
6520 [label="this.CurrentToken 104260"];
6521 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104261"];
6522 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104262"];
6523 [label="this.CurrentToken.Kind 104263"];
6524 [label="IsCurrentTokenPartialKeywordOfPartialMethodOrType() 104264"];
6525 [label="param IsCurrentTokenPartialKeywordOfPartialMethodOrType(this) 104265"];
6526 [label="this.CurrentToken 104266"];
6527 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104267"];
6528 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.PartialKeyword)\n            {\n                if (this.IsPartialType() || this.IsPartialMember())\n                {\n                    return true;\n                }\n            } 104268"];
6529 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104269"];
6530 [label="IsCurrentTokenQueryKeywordInQuery() 104270"];
6531 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104271"];
6532 [label="if (IsCurrentTokenPartialKeywordOfPartialMethodOrType() || IsCurrentTokenQueryKeywordInQuery())\n                {\n                    var result = CreateMissingIdentifierToken();\n                    result = this.AddError(result, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    return result;\n                } 104272"];
6533 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104273"];
6534 [label="MoveToNextToken(); 104274"];
6535 [label="this.IsInAsync 104275"];
6536 [label="get\n            {\n                return _syntaxFactoryContext.IsInAsync;\n            } 104276"];
6537 [label="return _syntaxFactoryContext.IsInAsync; 104277"];
6538 [label="if (this.IsInAsync && identifierToken.ContextualKind == SyntaxKind.AwaitKeyword)\n                {\n                    identifierToken = this.AddError(identifierToken, ErrorCode.ERR_BadAwaitAsIdentifier);\n                } 104278"];
6539 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104279"];
6540 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104280"];
6541 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104281"];
6542 [label="MoveToNextToken(); 104282"];
6543 [label="param ParseVariableInitializer(this) 104283"];
6544 [label="this.CurrentToken 104284"];
6545 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104285"];
6546 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104286"];
6547 [label="switch (this.CurrentToken.Kind)\n            {\n                case SyntaxKind.OpenBraceToken:\n                    return this.ParseArrayInitializer();\n                default:\n                    return this.ParseExpressionCore();\n            } 104287"];
6548 [label="this.CurrentToken.Kind 104288"];
6549 [label="get { return (SyntaxKind)this.RawKind; } 104289"];
6550 [label="this.ParseExpressionCore() 104290"];
6551 [label="param ParseExpressionCore(this) 104291"];
6552 [label="return this.ParseSubExpression(Precedence.Expression); 104292"];
6553 [label="this.ParseSubExpression(Precedence.Expression) 104293"];
6554 [label="param ParseSubExpression(Precedence precedence) 104294"];
6555 [label="param ParseSubExpression(this) 104295"];
6556 [label="_recursionDepth 104296"];
6557 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 104297"];
6558 [label="var result = ParseSubExpressionCore(precedence); 104298"];
6559 [label="ParseSubExpressionCore(precedence) 104299"];
6560 [label="param ParseSubExpressionCore(Precedence precedence) 104300"];
6561 [label="param ParseSubExpressionCore(this) 104301"];
6562 [label="ExpressionSyntax leftOperand; 104302"];
6563 [label="Precedence newPrecedence = 0; 104303"];
6564 [label="this.CurrentToken 104304"];
6565 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104305"];
6566 [label="var tk = this.CurrentToken.Kind; 104306"];
6567 [label="this.CurrentToken.Kind 104307"];
6568 [label="get { return (SyntaxKind)this.RawKind; } 104308"];
6569 [label="if (IsInvalidSubExpression(tk))\n            {\n                return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            } 104309"];
6570 [label="IsInvalidSubExpression(tk) 104310"];
6571 [label="param IsInvalidSubExpression(SyntaxKind kind) 104311"];
6572 [label="switch (kind)\n            {\n                case SyntaxKind.BreakKeyword:\n                case SyntaxKind.CaseKeyword:\n                case SyntaxKind.CatchKeyword:\n                case SyntaxKind.ConstKeyword:\n                case SyntaxKind.ContinueKeyword:\n                case SyntaxKind.DoKeyword:\n                case SyntaxKind.FinallyKeyword:\n                case SyntaxKind.ForKeyword:\n                case SyntaxKind.ForEachKeyword:\n                case SyntaxKind.GotoKeyword:\n                case SyntaxKind.IfKeyword:\n                case SyntaxKind.ElseKeyword:\n                case SyntaxKind.LockKeyword:\n                case SyntaxKind.ReturnKeyword:\n                case SyntaxKind.SwitchKeyword:\n                case SyntaxKind.TryKeyword:\n                case SyntaxKind.UsingKeyword:\n                case SyntaxKind.WhileKeyword:\n                    return true;\n                default:\n                    return false;\n            } 104312"];
6573 [label="return false; 104313"];
6574 [label="if (IsExpectedPrefixUnaryOperator(tk))\n            {\n                var opKind = SyntaxFacts.GetPrefixUnaryExpression(tk);\n                newPrecedence = GetPrecedence(opKind);\n                var opToken = this.EatToken();\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.PrefixUnaryExpression(opKind, opToken, operand);\n            }\n            else if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104314"];
6575 [label="IsExpectedPrefixUnaryOperator(tk) 104315"];
6576 [label="param IsExpectedPrefixUnaryOperator(SyntaxKind kind) 104316"];
6577 [label="return SyntaxFacts.IsPrefixUnaryExpression(kind) && kind != SyntaxKind.RefKeyword && kind != SyntaxKind.OutKeyword; 104317"];
6578 [label="SyntaxFacts.IsPrefixUnaryExpression(kind) 104318"];
6579 [label="param IsPrefixUnaryExpression(SyntaxKind token) 104319"];
6580 [label="return GetPrefixUnaryExpression(token) != SyntaxKind.None; 104320"];
6581 [label="GetPrefixUnaryExpression(token) 104321"];
6582 [label="param GetPrefixUnaryExpression(SyntaxKind token) 104322"];
6583 [label="switch (token)\n            {\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.UnaryPlusExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.UnaryMinusExpression;\n                case SyntaxKind.TildeToken:\n                    return SyntaxKind.BitwiseNotExpression;\n                case SyntaxKind.ExclamationToken:\n                    return SyntaxKind.LogicalNotExpression;\n                case SyntaxKind.PlusPlusToken:\n                    return SyntaxKind.PreIncrementExpression;\n                case SyntaxKind.MinusMinusToken:\n                    return SyntaxKind.PreDecrementExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.AddressOfExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.PointerIndirectionExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.IndexExpression;\n                default:\n                    return SyntaxKind.None;\n            } 104323"];
6584 [label="return SyntaxKind.None; 104324"];
6585 [label="if (tk == SyntaxKind.DotDotToken)\n            {\n                // Operator '..' here can either be a prefix unary operator or a stand alone empty range:\n                var opToken = this.EatToken();\n                newPrecedence = GetPrecedence(SyntaxKind.RangeExpression);\n\n                ExpressionSyntax rightOperand;\n                if (CanStartExpression())\n                {\n                    rightOperand = this.ParseSubExpression(newPrecedence);\n                }\n                else\n                {\n                    rightOperand = null;\n                }\n\n                leftOperand = _syntaxFactory.RangeExpression(leftOperand: null, opToken, rightOperand);\n            }\n            else if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104325"];
6586 [label="IsAwaitExpression() 104326"];
6587 [label="param IsAwaitExpression(this) 104327"];
6588 [label="this.CurrentToken 104328"];
6589 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104329"];
6590 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.AwaitKeyword)\n            {\n                if (this.IsInAsync)\n                {\n                    // If we see an await in an async function, parse it as an unop.\n                    return true;\n                }\n\n                // If we see an await followed by a token that cannot follow an identifier, parse await as a unop.\n                // BindAwait() catches the cases where await successfully parses as a unop but is not in an async\n                // function, and reports an appropriate ERR_BadAwaitWithoutAsync* error.\n                var next = PeekToken(1);\n                switch (next.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        return next.ContextualKind != SyntaxKind.WithKeyword;\n\n                    // Keywords\n                    case SyntaxKind.NewKeyword:\n                    case SyntaxKind.ThisKeyword:\n                    case SyntaxKind.BaseKeyword:\n                    case SyntaxKind.DelegateKeyword:\n                    case SyntaxKind.TypeOfKeyword:\n                    case SyntaxKind.CheckedKeyword:\n                    case SyntaxKind.UncheckedKeyword:\n                    case SyntaxKind.DefaultKeyword:\n\n                    // Literals\n                    case SyntaxKind.TrueKeyword:\n                    case SyntaxKind.FalseKeyword:\n                    case SyntaxKind.StringLiteralToken:\n                    case SyntaxKind.InterpolatedStringStartToken:\n                    case SyntaxKind.InterpolatedStringToken:\n                    case SyntaxKind.NumericLiteralToken:\n                    case SyntaxKind.NullKeyword:\n                    case SyntaxKind.CharacterLiteralToken:\n                        return true;\n                }\n            } 104330"];
6591 [label="this.CurrentToken.ContextualKind 104331"];
6592 [label="get\n            {\n                return this.Kind;\n            } 104332"];
6593 [label="return false; 104333"];
6594 [label="if (IsAwaitExpression())\n            {\n                newPrecedence = GetPrecedence(SyntaxKind.AwaitExpression);\n                var awaitToken = this.EatContextualToken(SyntaxKind.AwaitKeyword);\n                awaitToken = CheckFeatureAvailability(awaitToken, MessageID.IDS_FeatureAsync);\n                var operand = this.ParseSubExpression(newPrecedence);\n                leftOperand = _syntaxFactory.AwaitExpression(awaitToken, operand);\n            }\n            else if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104334"];
6595 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104335"];
6596 [label="this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false) 104336"];
6597 [label="param IsQueryExpression(bool mayBeVariableDeclaration) 104337"];
6598 [label="param IsQueryExpression(bool mayBeMemberDeclaration) 104338"];
6599 [label="param IsQueryExpression(this) 104339"];
6600 [label="this.CurrentToken 104340"];
6601 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104341"];
6602 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword)\n            {\n                return this.IsQueryExpressionAfterFrom(mayBeVariableDeclaration, mayBeMemberDeclaration);\n            } 104342"];
6603 [label="this.CurrentToken.ContextualKind 104343"];
6604 [label="get\n            {\n                return this.Kind;\n            } 104344"];
6605 [label="if (this.IsQueryExpression(mayBeVariableDeclaration: false, mayBeMemberDeclaration: false))\n            {\n                leftOperand = this.ParseQueryExpression(precedence);\n            }\n            else if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104345"];
6606 [label="this.CurrentToken 104346"];
6607 [label="if (this.CurrentToken.ContextualKind == SyntaxKind.FromKeyword && IsInQuery)\n            {\n                // If this 'from' token wasn't the start of a query then it's not really an expression.\n                // Consume it so that we don't try to parse it again as the next argument in an\n                // argument list.\n                SyntaxToken skipped = this.EatToken(); // consume but skip 'from'\n                skipped = this.AddError(skipped, ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                leftOperand = AddTrailingSkippedSyntax(this.CreateMissingIdentifierName(), skipped);\n            }\n            else if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104347"];
6608 [label="this.CurrentToken.ContextualKind 104348"];
6609 [label="get\n            {\n                return this.Kind;\n            } 104349"];
6610 [label="if (tk == SyntaxKind.ThrowKeyword)\n            {\n                var result = ParseThrowExpression();\n                // we parse a throw expression even at the wrong precedence for better recovery\n                return (precedence <= Precedence.Coalescing) ? result :\n                    this.AddError(result, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n            }\n            else if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104350"];
6611 [label="if (this.IsPossibleDeconstructionLeft(precedence))\n            {\n                leftOperand = ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n            }\n            else\n            {\n                // Not a unary operator - get a primary expression.\n                leftOperand = this.ParseTerm(precedence);\n            } 104351"];
6612 [label="this.IsPossibleDeconstructionLeft(precedence) 104352"];
6613 [label="param IsPossibleDeconstructionLeft(Precedence precedence) 104353"];
6614 [label="param IsPossibleDeconstructionLeft(this) 104354"];
6615 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 104355"];
6616 [label="this.CurrentToken 104356"];
6617 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104357"];
6618 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 104358"];
6619 [label="this.CurrentToken.IsIdentifierVar() 104359"];
6620 [label="param IsIdentifierVar(this Syntax.InternalSyntax.SyntaxToken node) 104360"];
6621 [label="node.ContextualKind 104361"];
6622 [label="get\n            {\n                return this.Kind;\n            } 104362"];
6623 [label="return node.ContextualKind == SyntaxKind.VarKeyword; 104363"];
6624 [label="this.CurrentToken 104364"];
6625 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104365"];
6626 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 104366"];
6627 [label="this.CurrentToken.Kind 104367"];
6628 [label="get { return (SyntaxKind)this.RawKind; } 104368"];
6629 [label="IsPredefinedType(this.CurrentToken.Kind) 104369"];
6630 [label="param IsPredefinedType(SyntaxKind keyword) 104370"];
6631 [label="return SyntaxFacts.IsPredefinedType(keyword); 104371"];
6632 [label="SyntaxFacts.IsPredefinedType(keyword) 104372"];
6633 [label="param IsPredefinedType(SyntaxKind kind) 104373"];
6634 [label="switch (kind)\n            {\n                case SyntaxKind.BoolKeyword:\n                case SyntaxKind.ByteKeyword:\n                case SyntaxKind.SByteKeyword:\n                case SyntaxKind.IntKeyword:\n                case SyntaxKind.UIntKeyword:\n                case SyntaxKind.ShortKeyword:\n                case SyntaxKind.UShortKeyword:\n                case SyntaxKind.LongKeyword:\n                case SyntaxKind.ULongKeyword:\n                case SyntaxKind.FloatKeyword:\n                case SyntaxKind.DoubleKeyword:\n                case SyntaxKind.DecimalKeyword:\n                case SyntaxKind.StringKeyword:\n                case SyntaxKind.CharKeyword:\n                case SyntaxKind.ObjectKeyword:\n                case SyntaxKind.VoidKeyword:\n                    return true;\n                default:\n                    return false;\n            } 104374"];
6635 [label="return false; 104375"];
6636 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 104376"];
6637 [label="if (precedence > Precedence.Assignment || !(this.CurrentToken.IsIdentifierVar() || IsPredefinedType(this.CurrentToken.Kind)))\n            {\n                return false;\n            } 104377"];
6638 [label="return false; 104378"];
6639 [label="leftOperand = this.ParseTerm(precedence); 104379"];
6640 [label="this.ParseTerm(precedence) 104380"];
6641 [label="param ParseTerm(Precedence precedence) 104381"];
6642 [label="=> this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 104382"];
6643 [label="precedence 104383"];
6644 [label="ParseTermWithoutPostfix(precedence) 104384"];
6645 [label="param ParseTermWithoutPostfix(Precedence precedence) 104385"];
6646 [label="param ParseTermWithoutPostfix(this) 104386"];
6647 [label="this.CurrentToken 104387"];
6648 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104388"];
6649 [label="var tk = this.CurrentToken.Kind; 104389"];
6650 [label="this.CurrentToken.Kind 104390"];
6651 [label="get { return (SyntaxKind)this.RawKind; } 104391"];
6652 [label="switch (tk)\n            {\n                case SyntaxKind.TypeOfKeyword:\n                    return this.ParseTypeOfExpression();\n                case SyntaxKind.DefaultKeyword:\n                    return this.ParseDefaultExpression();\n                case SyntaxKind.SizeOfKeyword:\n                    return this.ParseSizeOfExpression();\n                case SyntaxKind.MakeRefKeyword:\n                    return this.ParseMakeRefExpression();\n                case SyntaxKind.RefTypeKeyword:\n                    return this.ParseRefTypeExpression();\n                case SyntaxKind.CheckedKeyword:\n                case SyntaxKind.UncheckedKeyword:\n                    return this.ParseCheckedOrUncheckedExpression();\n                case SyntaxKind.RefValueKeyword:\n                    return this.ParseRefValueExpression();\n                case SyntaxKind.ColonColonToken:\n                    // misplaced ::\n                    // Calling ParseAliasQualifiedName will cause us to create a missing identifier node that then\n                    // properly consumes the :: and the reset of the alias name afterwards.\n                    return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return this.ParseLambdaExpression();\n                case SyntaxKind.StaticKeyword:\n                    if (this.IsPossibleAnonymousMethodExpression())\n                    {\n                        return this.ParseAnonymousMethodExpression();\n                    }\n                    else if (this.IsPossibleLambdaExpression(precedence))\n                    {\n                        return this.ParseLambdaExpression();\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.IdentifierToken:\n                    if (this.IsTrueIdentifier())\n                    {\n                        if (this.IsPossibleAnonymousMethodExpression())\n                        {\n                            return this.ParseAnonymousMethodExpression();\n                        }\n                        else if (this.IsPossibleLambdaExpression(precedence))\n                        {\n                            return this.ParseLambdaExpression();\n                        }\n                        else if (this.IsPossibleDeconstructionLeft(precedence))\n                        {\n                            return ParseDeclarationExpression(ParseTypeMode.Normal, MessageID.IDS_FeatureTuples);\n                        }\n                        else\n                        {\n                            return this.ParseAliasQualifiedName(NameOptions.InExpression);\n                        }\n                    }\n                    else\n                    {\n                        return this.AddError(this.CreateMissingIdentifierName(), ErrorCode.ERR_InvalidExprTerm, this.CurrentToken.Text);\n                    }\n                case SyntaxKind.ThisKeyword:\n                    return _syntaxFactory.ThisExpression(this.EatToken());\n                case SyntaxKind.BaseKeyword:\n                    return ParseBaseExpression();\n\n                case SyntaxKind.ArgListKeyword:\n                case SyntaxKind.FalseKeyword:\n                case SyntaxKind.TrueKeyword:\n                case SyntaxKind.NullKeyword:\n                case SyntaxKind.NumericLiteralToken:\n                case SyntaxKind.StringLiteralToken:\n                case SyntaxKind.CharacterLiteralToken:\n                    return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken());\n                case SyntaxKind.InterpolatedStringStartToken:\n                    throw new NotImplementedException(); // this should not occur because these tokens are produced and parsed immediately\n                case SyntaxKind.InterpolatedStringToken:\n                    return this.ParseInterpolatedStringToken();\n                case SyntaxKind.OpenParenToken:\n                    return this.ParseCastOrParenExpressionOrLambdaOrTuple(precedence);\n                case SyntaxKind.NewKeyword:\n                    return this.ParseNewExpression();\n                case SyntaxKind.StackAllocKeyword:\n                    return this.ParseStackAllocExpression();\n                case SyntaxKind.DelegateKeyword:\n                    return this.ParseAnonymousMethodExpression();\n                case SyntaxKind.RefKeyword:\n                    // ref is not expected to appear in this position.\n                    return this.AddError(ParsePossibleRefExpression(), ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                default:\n                    // check for intrinsic type followed by '.'\n                    if (IsPredefinedType(tk))\n                    {\n                        var expr = _syntaxFactory.PredefinedType(this.EatToken());\n\n                        if (this.CurrentToken.Kind != SyntaxKind.DotToken || tk == SyntaxKind.VoidKeyword)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n                    else\n                    {\n                        var expr = this.CreateMissingIdentifierName();\n\n                        if (tk == SyntaxKind.EndOfFileToken)\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_ExpressionExpected);\n                        }\n                        else\n                        {\n                            expr = this.AddError(expr, ErrorCode.ERR_InvalidExprTerm, SyntaxFacts.GetText(tk));\n                        }\n\n                        return expr;\n                    }\n            } 104392"];
6653 [label="return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken()); 104393"];
6654 [label="SyntaxFacts.GetLiteralExpression(tk) 104394"];
6655 [label="param GetLiteralExpression(SyntaxKind token) 104395"];
6656 [label="switch (token)\n            {\n                case SyntaxKind.StringLiteralToken:\n                    return SyntaxKind.StringLiteralExpression;\n                case SyntaxKind.CharacterLiteralToken:\n                    return SyntaxKind.CharacterLiteralExpression;\n                case SyntaxKind.NumericLiteralToken:\n                    return SyntaxKind.NumericLiteralExpression;\n                case SyntaxKind.NullKeyword:\n                    return SyntaxKind.NullLiteralExpression;\n                case SyntaxKind.TrueKeyword:\n                    return SyntaxKind.TrueLiteralExpression;\n                case SyntaxKind.FalseKeyword:\n                    return SyntaxKind.FalseLiteralExpression;\n                case SyntaxKind.ArgListKeyword:\n                    return SyntaxKind.ArgListExpression;\n                default:\n                    return SyntaxKind.None;\n            } 104396"];
6657 [label="return SyntaxKind.NumericLiteralExpression; 104397"];
6658 [label="this.EatToken() 104398"];
6659 [label="param GetTrailingTrivia(this) 104399"];
6660 [label="return _trailing; 104400"];
6661 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104401"];
6662 [label="MoveToNextToken(); 104402"];
6663 [label="return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken()); 104403"];
6664 [label="return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken()); 104404"];
6665 [label="return _syntaxFactory.LiteralExpression(SyntaxFacts.GetLiteralExpression(tk), this.EatToken()); 104405"];
6666 [label="param TryGetNode(int kind) 104406"];
6667 [label="param TryGetNode(GreenNode child1) 104407"];
6668 [label="param TryGetNode(SyntaxFactoryContext context) 104408"];
6669 [label="param TryGetNode(out int hash) 104409"];
6670 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104410"];
6671 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104411"];
6672 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104412"];
6673 [label="GetNodeFlags(context) 104413"];
6674 [label="param GetNodeFlags(SyntaxFactoryContext context) 104414"];
6675 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 104415"];
6676 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 104416"];
6677 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 104417"];
6678 [label="return flags; 104418"];
6679 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104419"];
6680 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104420"];
6681 [label="return SyntaxNodeCache.TryGetNode(kind, child1, GetNodeFlags(context), out hash); 104421"];
6682 [label="param SetFactoryContext(SyntaxFactoryContext context) 104422"];
6683 [label="param SetFactoryContext(this) 104423"];
6684 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104424"];
6685 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104425"];
6686 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 104426"];
6687 [label="this.ParsePostFixExpression(ParseTermWithoutPostfix(precedence)) 104427"];
6688 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104428"];
6689 [label="leftOperand = this.ParseTerm(precedence); 104429"];
6690 [label="return ParseExpressionContinued(leftOperand, precedence); 104430"];
6691 [label="return ParseExpressionContinued(leftOperand, precedence); 104431"];
6692 [label="ParseExpressionContinued(leftOperand, precedence) 104432"];
6693 [label="param ParseExpressionContinued(ExpressionSyntax leftOperand) 104433"];
6694 [label="param ParseExpressionContinued(Precedence precedence) 104434"];
6695 [label="param ParseExpressionContinued(this) 104435"];
6696 [label="while (true)\n            {\n                // We either have a binary or assignment operator here, or we're finished.\n                var tk = this.CurrentToken.ContextualKind;\n\n                bool isAssignmentOperator = false;\n                SyntaxKind opKind;\n                if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                }\n\n                var newPrecedence = GetPrecedence(opKind);\n\n                // check for >> or >>=\n                bool doubleOp = false;\n                if (tk == SyntaxKind.GreaterThanToken\n                    && (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken || this.PeekToken(1).Kind == SyntaxKind.GreaterThanEqualsToken))\n                {\n                    // check to see if they really are adjacent\n                    if (this.CurrentToken.GetTrailingTriviaWidth() == 0 && this.PeekToken(1).GetLeadingTriviaWidth() == 0)\n                    {\n                        if (this.PeekToken(1).Kind == SyntaxKind.GreaterThanToken)\n                        {\n                            opKind = SyntaxFacts.GetBinaryExpression(SyntaxKind.GreaterThanGreaterThanToken);\n                        }\n                        else\n                        {\n                            opKind = SyntaxFacts.GetAssignmentExpression(SyntaxKind.GreaterThanGreaterThanEqualsToken);\n                            isAssignmentOperator = true;\n                        }\n                        newPrecedence = GetPrecedence(opKind);\n                        doubleOp = true;\n                    }\n                }\n\n                // Check the precedence to see if we should 'take' this operator\n                if (newPrecedence < precedence)\n                {\n                    break;\n                }\n\n                // Same precedence, but not right-associative -- deal with this 'later'\n                if ((newPrecedence == precedence) && !IsRightAssociative(opKind))\n                {\n                    break;\n                }\n\n                // We'll 'take' this operator, as precedence is tentatively OK.\n                var opToken = this.EatContextualToken(tk);\n\n                var leftPrecedence = GetPrecedence(leftOperand.Kind);\n                if (newPrecedence > leftPrecedence)\n                {\n                    // Normally, a left operand with a looser precedence will consume all right operands that\n                    // have a tighter precedence.  For example, in the expression `a + b * c`, the `* c` part\n                    // will be consumed as part of the right operand of the addition.  However, there are a\n                    // few circumstances in which a tighter precedence is not consumed: that occurs when the\n                    // left hand operator does not have an expression as its right operand.  This occurs for\n                    // the is-type operator and the is-pattern operator.  Source text such as\n                    // `a is {} + b` should produce a syntax error, as parsing the `+` with an `is`\n                    // expression as its left operand would be a precedence inversion.  Similarly, it occurs\n                    // with an anonymous method expression or a lambda expression with a block body.  No\n                    // further parsing will find a way to fix things up, so we accept the operator but issue\n                    // a diagnostic.\n                    ErrorCode errorCode = leftOperand.Kind == SyntaxKind.IsPatternExpression ? ErrorCode.ERR_UnexpectedToken : ErrorCode.WRN_PrecedenceInversion;\n                    opToken = this.AddError(opToken, errorCode, opToken.Text);\n                }\n\n                if (doubleOp)\n                {\n                    // combine tokens into a single token\n                    var opToken2 = this.EatToken();\n                    var kind = opToken2.Kind == SyntaxKind.GreaterThanToken ? SyntaxKind.GreaterThanGreaterThanToken : SyntaxKind.GreaterThanGreaterThanEqualsToken;\n                    opToken = SyntaxFactory.Token(opToken.GetLeadingTrivia(), kind, opToken2.GetTrailingTrivia());\n                }\n\n                if (opKind == SyntaxKind.AsExpression)\n                {\n                    var type = this.ParseType(ParseTypeMode.AsExpression);\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, type);\n                }\n                else if (opKind == SyntaxKind.IsExpression)\n                {\n                    leftOperand = ParseIsExpression(leftOperand, opToken);\n                }\n                else if (isAssignmentOperator)\n                {\n                    ExpressionSyntax rhs = opKind == SyntaxKind.SimpleAssignmentExpression && CurrentToken.Kind == SyntaxKind.RefKeyword\n                        ? rhs = CheckFeatureAvailability(ParsePossibleRefExpression(), MessageID.IDS_FeatureRefReassignment)\n                        : rhs = this.ParseSubExpression(newPrecedence);\n\n                    if (opKind == SyntaxKind.CoalesceAssignmentExpression)\n                    {\n                        opToken = CheckFeatureAvailability(opToken, MessageID.IDS_FeatureCoalesceAssignmentExpression);\n                    }\n\n                    leftOperand = _syntaxFactory.AssignmentExpression(opKind, leftOperand, opToken, rhs);\n                }\n                else if (opKind == SyntaxKind.SwitchExpression)\n                {\n                    leftOperand = ParseSwitchExpression(leftOperand, opToken);\n                }\n                else if (opKind == SyntaxKind.WithExpression)\n                {\n                    leftOperand = ParseWithExpression(leftOperand, opToken);\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    // Operator '..' here can either be a binary or a postfix unary operator:\n                    Debug.Assert(opKind == SyntaxKind.RangeExpression);\n\n                    ExpressionSyntax rightOperand;\n                    if (CanStartExpression())\n                    {\n                        newPrecedence = GetPrecedence(opKind);\n                        rightOperand = this.ParseSubExpression(newPrecedence);\n                    }\n                    else\n                    {\n                        rightOperand = null;\n                    }\n\n                    leftOperand = _syntaxFactory.RangeExpression(leftOperand, opToken, rightOperand);\n                }\n                else\n                {\n                    Debug.Assert(IsExpectedBinaryOperator(tk));\n                    leftOperand = _syntaxFactory.BinaryExpression(opKind, leftOperand, opToken, this.ParseSubExpression(newPrecedence));\n                }\n            } 104436"];
6697 [label="this.CurrentToken 104437"];
6698 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104438"];
6699 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104439"];
6700 [label="var tk = this.CurrentToken.ContextualKind; 104440"];
6701 [label="this.CurrentToken.ContextualKind 104441"];
6702 [label="get\n            {\n                return this.Kind;\n            } 104442"];
6703 [label="bool isAssignmentOperator = false; 104443"];
6704 [label="SyntaxKind opKind; 104444"];
6705 [label="if (IsExpectedBinaryOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetBinaryExpression(tk);\n                }\n                else if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 104445"];
6706 [label="IsExpectedBinaryOperator(tk) 104446"];
6707 [label="param IsExpectedBinaryOperator(SyntaxKind kind) 104447"];
6708 [label="return SyntaxFacts.IsBinaryExpression(kind); 104448"];
6709 [label="SyntaxFacts.IsBinaryExpression(kind) 104449"];
6710 [label="param IsBinaryExpression(SyntaxKind token) 104450"];
6711 [label="return GetBinaryExpression(token) != SyntaxKind.None; 104451"];
6712 [label="GetBinaryExpression(token) 104452"];
6713 [label="param GetBinaryExpression(SyntaxKind token) 104453"];
6714 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionToken:\n                    return SyntaxKind.CoalesceExpression;\n                case SyntaxKind.IsKeyword:\n                    return SyntaxKind.IsExpression;\n                case SyntaxKind.AsKeyword:\n                    return SyntaxKind.AsExpression;\n                case SyntaxKind.BarToken:\n                    return SyntaxKind.BitwiseOrExpression;\n                case SyntaxKind.CaretToken:\n                    return SyntaxKind.ExclusiveOrExpression;\n                case SyntaxKind.AmpersandToken:\n                    return SyntaxKind.BitwiseAndExpression;\n                case SyntaxKind.EqualsEqualsToken:\n                    return SyntaxKind.EqualsExpression;\n                case SyntaxKind.ExclamationEqualsToken:\n                    return SyntaxKind.NotEqualsExpression;\n                case SyntaxKind.LessThanToken:\n                    return SyntaxKind.LessThanExpression;\n                case SyntaxKind.LessThanEqualsToken:\n                    return SyntaxKind.LessThanOrEqualExpression;\n                case SyntaxKind.GreaterThanToken:\n                    return SyntaxKind.GreaterThanExpression;\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return SyntaxKind.GreaterThanOrEqualExpression;\n                case SyntaxKind.LessThanLessThanToken:\n                    return SyntaxKind.LeftShiftExpression;\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return SyntaxKind.RightShiftExpression;\n                case SyntaxKind.PlusToken:\n                    return SyntaxKind.AddExpression;\n                case SyntaxKind.MinusToken:\n                    return SyntaxKind.SubtractExpression;\n                case SyntaxKind.AsteriskToken:\n                    return SyntaxKind.MultiplyExpression;\n                case SyntaxKind.SlashToken:\n                    return SyntaxKind.DivideExpression;\n                case SyntaxKind.PercentToken:\n                    return SyntaxKind.ModuloExpression;\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return SyntaxKind.LogicalAndExpression;\n                case SyntaxKind.BarBarToken:\n                    return SyntaxKind.LogicalOrExpression;\n                default:\n                    return SyntaxKind.None;\n            } 104454"];
6715 [label="return SyntaxKind.None; 104455"];
6716 [label="if (IsExpectedAssignmentOperator(tk))\n                {\n                    opKind = SyntaxFacts.GetAssignmentExpression(tk);\n                    isAssignmentOperator = true;\n                }\n                else if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 104456"];
6717 [label="IsExpectedAssignmentOperator(tk) 104457"];
6718 [label="param IsExpectedAssignmentOperator(SyntaxKind kind) 104458"];
6719 [label="return SyntaxFacts.IsAssignmentExpressionOperatorToken(kind); 104459"];
6720 [label="SyntaxFacts.IsAssignmentExpressionOperatorToken(kind) 104460"];
6721 [label="param IsAssignmentExpressionOperatorToken(SyntaxKind token) 104461"];
6722 [label="switch (token)\n            {\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                case SyntaxKind.BarEqualsToken:\n                case SyntaxKind.AmpersandEqualsToken:\n                case SyntaxKind.CaretEqualsToken:\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                case SyntaxKind.PlusEqualsToken:\n                case SyntaxKind.MinusEqualsToken:\n                case SyntaxKind.AsteriskEqualsToken:\n                case SyntaxKind.SlashEqualsToken:\n                case SyntaxKind.PercentEqualsToken:\n                case SyntaxKind.EqualsToken:\n                    return true;\n                default:\n                    return false;\n            } 104462"];
6723 [label="return false; 104463"];
6724 [label="if (tk == SyntaxKind.DotDotToken)\n                {\n                    opKind = SyntaxKind.RangeExpression;\n                }\n                else if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 104464"];
6725 [label="if (tk == SyntaxKind.SwitchKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.SwitchExpression;\n                }\n                else if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 104465"];
6726 [label="if (tk == SyntaxKind.WithKeyword && this.PeekToken(1).Kind == SyntaxKind.OpenBraceToken)\n                {\n                    opKind = SyntaxKind.WithExpression;\n                }\n                else\n                {\n                    break;\n                } 104466"];
6727 [label="CurrentToken 104467"];
6728 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104468"];
6729 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104469"];
6730 [label="if (CurrentToken.Kind == SyntaxKind.QuestionToken && precedence <= Precedence.Conditional)\n            {\n                var questionToken = this.EatToken();\n                var colonLeft = this.ParsePossibleRefExpression();\n                if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken && this.lexer.InterpolationFollowedByColon)\n                {\n                    // We have an interpolated string with an interpolation that contains a conditional expression.\n                    // Unfortunately, the precedence demands that the colon is considered to signal the start of the\n                    // format string. Without this code, the compiler would complain about a missing colon, and point\n                    // to the colon that is present, which would be confusing. We aim to give a better error message.\n                    var colon = SyntaxFactory.MissingToken(SyntaxKind.ColonToken);\n                    var colonRight = _syntaxFactory.IdentifierName(SyntaxFactory.MissingToken(SyntaxKind.IdentifierToken));\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                    leftOperand = this.AddError(leftOperand, ErrorCode.ERR_ConditionalInInterpolation);\n                }\n                else\n                {\n                    var colon = this.EatToken(SyntaxKind.ColonToken);\n                    var colonRight = this.ParsePossibleRefExpression();\n                    leftOperand = _syntaxFactory.ConditionalExpression(leftOperand, questionToken, colonLeft, colon, colonRight);\n                }\n            } 104470"];
6731 [label="CurrentToken.Kind 104471"];
6732 [label="get { return (SyntaxKind)this.RawKind; } 104472"];
6733 [label="return leftOperand; 104473"];
6734 [label="_ = GetPrecedence(result.Kind); 104474"];
6735 [label="result.Kind 104475"];
6736 [label="get { return (SyntaxKind)this.RawKind; } 104476"];
6737 [label="_ = GetPrecedence(result.Kind); 104477"];
6738 [label="GetPrecedence(result.Kind) 104478"];
6739 [label="param GetPrecedence(SyntaxKind op) 104479"];
6740 [label="switch (op)\n            {\n                case SyntaxKind.QueryExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.ParenthesizedLambdaExpression:\n                case SyntaxKind.SimpleLambdaExpression:\n                case SyntaxKind.AnonymousMethodExpression:\n                    return Precedence.Lambda;\n                case SyntaxKind.SimpleAssignmentExpression:\n                case SyntaxKind.AddAssignmentExpression:\n                case SyntaxKind.SubtractAssignmentExpression:\n                case SyntaxKind.MultiplyAssignmentExpression:\n                case SyntaxKind.DivideAssignmentExpression:\n                case SyntaxKind.ModuloAssignmentExpression:\n                case SyntaxKind.AndAssignmentExpression:\n                case SyntaxKind.ExclusiveOrAssignmentExpression:\n                case SyntaxKind.OrAssignmentExpression:\n                case SyntaxKind.LeftShiftAssignmentExpression:\n                case SyntaxKind.RightShiftAssignmentExpression:\n                case SyntaxKind.CoalesceAssignmentExpression:\n                    return Precedence.Assignment;\n                case SyntaxKind.CoalesceExpression:\n                case SyntaxKind.ThrowExpression:\n                    return Precedence.Coalescing;\n                case SyntaxKind.LogicalOrExpression:\n                    return Precedence.ConditionalOr;\n                case SyntaxKind.LogicalAndExpression:\n                    return Precedence.ConditionalAnd;\n                case SyntaxKind.BitwiseOrExpression:\n                    return Precedence.LogicalOr;\n                case SyntaxKind.ExclusiveOrExpression:\n                    return Precedence.LogicalXor;\n                case SyntaxKind.BitwiseAndExpression:\n                    return Precedence.LogicalAnd;\n                case SyntaxKind.EqualsExpression:\n                case SyntaxKind.NotEqualsExpression:\n                    return Precedence.Equality;\n                case SyntaxKind.LessThanExpression:\n                case SyntaxKind.LessThanOrEqualExpression:\n                case SyntaxKind.GreaterThanExpression:\n                case SyntaxKind.GreaterThanOrEqualExpression:\n                case SyntaxKind.IsExpression:\n                case SyntaxKind.AsExpression:\n                case SyntaxKind.IsPatternExpression:\n                    return Precedence.Relational;\n                case SyntaxKind.SwitchExpression:\n                case SyntaxKind.WithExpression:\n                    return Precedence.Switch;\n                case SyntaxKind.LeftShiftExpression:\n                case SyntaxKind.RightShiftExpression:\n                    return Precedence.Shift;\n                case SyntaxKind.AddExpression:\n                case SyntaxKind.SubtractExpression:\n                    return Precedence.Additive;\n                case SyntaxKind.MultiplyExpression:\n                case SyntaxKind.DivideExpression:\n                case SyntaxKind.ModuloExpression:\n                    return Precedence.Mutiplicative;\n                case SyntaxKind.UnaryPlusExpression:\n                case SyntaxKind.UnaryMinusExpression:\n                case SyntaxKind.BitwiseNotExpression:\n                case SyntaxKind.LogicalNotExpression:\n                case SyntaxKind.PreIncrementExpression:\n                case SyntaxKind.PreDecrementExpression:\n                case SyntaxKind.TypeOfExpression:\n                case SyntaxKind.SizeOfExpression:\n                case SyntaxKind.CheckedExpression:\n                case SyntaxKind.UncheckedExpression:\n                case SyntaxKind.MakeRefExpression:\n                case SyntaxKind.RefValueExpression:\n                case SyntaxKind.RefTypeExpression:\n                case SyntaxKind.AwaitExpression:\n                case SyntaxKind.IndexExpression:\n                    return Precedence.Unary;\n                case SyntaxKind.CastExpression:\n                    return Precedence.Cast;\n                case SyntaxKind.PointerIndirectionExpression:\n                    return Precedence.PointerIndirection;\n                case SyntaxKind.AddressOfExpression:\n                    return Precedence.AddressOf;\n                case SyntaxKind.RangeExpression:\n                    return Precedence.Range;\n                case SyntaxKind.ConditionalExpression:\n                    return Precedence.Expression;\n                case SyntaxKind.AliasQualifiedName:\n                case SyntaxKind.AnonymousObjectCreationExpression:\n                case SyntaxKind.ArgListExpression:\n                case SyntaxKind.ArrayCreationExpression:\n                case SyntaxKind.BaseExpression:\n                case SyntaxKind.CharacterLiteralExpression:\n                case SyntaxKind.ConditionalAccessExpression:\n                case SyntaxKind.DeclarationExpression:\n                case SyntaxKind.DefaultExpression:\n                case SyntaxKind.DefaultLiteralExpression:\n                case SyntaxKind.ElementAccessExpression:\n                case SyntaxKind.FalseLiteralExpression:\n                case SyntaxKind.GenericName:\n                case SyntaxKind.IdentifierName:\n                case SyntaxKind.ImplicitArrayCreationExpression:\n                case SyntaxKind.ImplicitStackAllocArrayCreationExpression:\n                case SyntaxKind.ImplicitObjectCreationExpression:\n                case SyntaxKind.InterpolatedStringExpression:\n                case SyntaxKind.InvocationExpression:\n                case SyntaxKind.NullLiteralExpression:\n                case SyntaxKind.NumericLiteralExpression:\n                case SyntaxKind.ObjectCreationExpression:\n                case SyntaxKind.ParenthesizedExpression:\n                case SyntaxKind.PointerMemberAccessExpression:\n                case SyntaxKind.PostDecrementExpression:\n                case SyntaxKind.PostIncrementExpression:\n                case SyntaxKind.PredefinedType:\n                case SyntaxKind.RefExpression:\n                case SyntaxKind.SimpleMemberAccessExpression:\n                case SyntaxKind.StackAllocArrayCreationExpression:\n                case SyntaxKind.StringLiteralExpression:\n                case SyntaxKind.SuppressNullableWarningExpression:\n                case SyntaxKind.ThisExpression:\n                case SyntaxKind.TrueLiteralExpression:\n                case SyntaxKind.TupleExpression:\n                    return Precedence.Primary;\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(op);\n            } 104480"];
6741 [label="return Precedence.Primary; 104481"];
6742 [label="_recursionDepth 104482"];
6743 [label="return result; 104483"];
6744 [label="return this.ParseExpressionCore(); 104484"];
6745 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104485"];
6746 [label="param TryGetNode(int kind) 104486"];
6747 [label="param TryGetNode(GreenNode child1) 104487"];
6748 [label="param TryGetNode(GreenNode child2) 104488"];
6749 [label="param TryGetNode(SyntaxFactoryContext context) 104489"];
6750 [label="param TryGetNode(out int hash) 104490"];
6751 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104491"];
6752 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104492"];
6753 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104493"];
6754 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104494"];
6755 [label="GetNodeFlags(context) 104495"];
6756 [label="param GetNodeFlags(SyntaxFactoryContext context) 104496"];
6757 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 104497"];
6758 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 104498"];
6759 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 104499"];
6760 [label="return flags; 104500"];
6761 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104501"];
6762 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104502"];
6763 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104503"];
6764 [label="param CSharpSyntaxNode(this) 104504"];
6765 [label="GreenStats.NoteGreen(this); 104505"];
6766 [label="param SetFactoryContext(SyntaxFactoryContext context) 104506"];
6767 [label="param SetFactoryContext(this) 104507"];
6768 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104508"];
6769 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104509"];
6770 [label="param TryGetNode(int kind) 104510"];
6771 [label="param TryGetNode(GreenNode child1) 104511"];
6772 [label="param TryGetNode(GreenNode child2) 104512"];
6773 [label="param TryGetNode(GreenNode child3) 104513"];
6774 [label="param TryGetNode(SyntaxFactoryContext context) 104514"];
6775 [label="param TryGetNode(out int hash) 104515"];
6776 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104516"];
6777 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104517"];
6778 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104518"];
6779 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104519"];
6780 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104520"];
6781 [label="GetNodeFlags(context) 104521"];
6782 [label="param GetNodeFlags(SyntaxFactoryContext context) 104522"];
6783 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 104523"];
6784 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 104524"];
6785 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 104525"];
6786 [label="return flags; 104526"];
6787 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104527"];
6788 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104528"];
6789 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, child3, GetNodeFlags(context), out hash); 104529"];
6790 [label="param SetFactoryContext(SyntaxFactoryContext context) 104530"];
6791 [label="param SetFactoryContext(this) 104531"];
6792 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104532"];
6793 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104533"];
6794 [label="variables.Add(\n                this.ParseVariableDeclarator(\n                    type,\n                    flags,\n                    isFirst: true,\n                    allowLocalFunctions: allowLocalFunctions,\n                    attributes: attributes,\n                    mods: mods,\n                    localFunction: out localFunction)); 104534"];
6795 [label="if (localFunction != null)\n            {\n                // ParseVariableDeclarator returns null, so it is not added to variables\n                Debug.Assert(variables.Count == 0);\n                return;\n            } 104535"];
6796 [label="if (localFunction != null)\n            {\n                // ParseVariableDeclarator returns null, so it is not added to variables\n                Debug.Assert(variables.Count == 0);\n                return;\n            } 104536"];
6797 [label="while (true)\n            {\n                if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    variables.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    variables.Add(\n                        this.ParseVariableDeclarator(\n                            type,\n                            flags,\n                            isFirst: false,\n                            allowLocalFunctions: false,\n                            attributes: attributes,\n                            mods: mods,\n                            localFunction: out localFunction));\n                }\n                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 104537"];
6798 [label="this.CurrentToken 104538"];
6799 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104539"];
6800 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104540"];
6801 [label="if (this.CurrentToken.Kind == SyntaxKind.SemicolonToken)\n                {\n                    break;\n                }\n                else if (this.CurrentToken.Kind == SyntaxKind.CommaToken)\n                {\n                    variables.AddSeparator(this.EatToken(SyntaxKind.CommaToken));\n                    variables.Add(\n                        this.ParseVariableDeclarator(\n                            type,\n                            flags,\n                            isFirst: false,\n                            allowLocalFunctions: false,\n                            attributes: attributes,\n                            mods: mods,\n                            localFunction: out localFunction));\n                }\n                else if (!variableDeclarationsExpected || this.SkipBadVariableListTokens(variables, SyntaxKind.CommaToken) == PostSkipAction.Abort)\n                {\n                    break;\n                } 104541"];
6802 [label="this.CurrentToken.Kind 104542"];
6803 [label="get { return (SyntaxKind)this.RawKind; } 104543"];
6804 [label="_termState 104544"];
6805 [label="if (allowLocalFunctions && localFunction == null && \n                (type is PredefinedTypeSyntax) &&\n                ((PredefinedTypeSyntax)type).Keyword.Kind == SyntaxKind.VoidKeyword)\n            {\n                type = this.AddError(type, ErrorCode.ERR_NoVoidHere);\n            } 104545"];
6806 [label="Debug.Assert(localFunction == null); 104546"];
6807 [label="Debug.Assert(localFunction == null); 104547"];
6808 [label="var result = _syntaxFactory.VariableDeclaration(type, variables); 104548"];
6809 [label="var result = _syntaxFactory.VariableDeclaration(type, variables); 104549"];
6810 [label="var result = _syntaxFactory.VariableDeclaration(type, variables); 104550"];
6811 [label="var result = _syntaxFactory.VariableDeclaration(type, variables); 104551"];
6812 [label="param TryGetNode(SyntaxFactoryContext context) 104552"];
6813 [label="GetNodeFlags(context) 104553"];
6814 [label="param GetNodeFlags(SyntaxFactoryContext context) 104554"];
6815 [label="var flags = SyntaxNodeCache.GetDefaultNodeFlags(); 104555"];
6816 [label="if (context.IsInAsync)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInAsync;\n            } 104556"];
6817 [label="if (context.IsInQuery)\n            {\n                flags |= GreenNode.NodeFlags.FactoryContextIsInQuery;\n            } 104557"];
6818 [label="return flags; 104558"];
6819 [label="return SyntaxNodeCache.TryGetNode(kind, child1, child2, GetNodeFlags(context), out hash); 104559"];
6820 [label="param CSharpSyntaxNode(this) 104560"];
6821 [label="GreenStats.NoteGreen(this); 104561"];
6822 [label="param SetFactoryContext(SyntaxFactoryContext context) 104562"];
6823 [label="param SetFactoryContext(this) 104563"];
6824 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104564"];
6825 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104565"];
6826 [label="_pool.Free(variables); 104566"];
6827 [label="_pool.Free(variables); 104567"];
6828 [label="return result; 104568"];
6829 [label="decl = ParseVariableDeclaration(); 104569"];
6830 [label="decl.Type.Kind 104570"];
6831 [label="get { return (SyntaxKind)this.RawKind; } 104571"];
6832 [label="if (decl.Type.Kind == SyntaxKind.RefType)\n                    {\n                        decl = decl.Update(\n                            CheckFeatureAvailability(decl.Type, MessageID.IDS_FeatureRefFor),\n                            decl.Variables);\n                    } 104572"];
6833 [label="var semi = this.EatToken(SyntaxKind.SemicolonToken); 104573"];
6834 [label="this.EatToken(SyntaxKind.SemicolonToken) 104574"];
6835 [label="param EatToken(SyntaxKind kind) 104575"];
6836 [label="param EatToken(this) 104576"];
6837 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 104577"];
6838 [label="SyntaxFacts.IsAnyToken(kind) 104578"];
6839 [label="param IsAnyToken(SyntaxKind kind) 104579"];
6840 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 104580"];
6841 [label="return true; 104581"];
6842 [label="this.CurrentToken 104582"];
6843 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104583"];
6844 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104584"];
6845 [label="ct.Kind 104585"];
6846 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 104586"];
6847 [label="param GetTrailingTrivia(this) 104587"];
6848 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104588"];
6849 [label="MoveToNextToken(); 104589"];
6850 [label="return ct; 104590"];
6851 [label="ExpressionSyntax condition = null; 104591"];
6852 [label="this.CurrentToken 104592"];
6853 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104593"];
6854 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104594"];
6855 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104595"];
6856 [label="return _lexedTokens[_tokenOffset]; 104596"];
6857 [label="if (this.CurrentToken.Kind != SyntaxKind.SemicolonToken)\n                {\n                    condition = this.ParseExpressionCore();\n                } 104597"];
6858 [label="this.CurrentToken.Kind 104598"];
6859 [label="get { return (SyntaxKind)this.RawKind; } 104599"];
6860 [label="var semi2 = this.EatToken(SyntaxKind.SemicolonToken); 104600"];
6861 [label="this.EatToken(SyntaxKind.SemicolonToken) 104601"];
6862 [label="param EatToken(SyntaxKind kind) 104602"];
6863 [label="param EatToken(this) 104603"];
6864 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 104604"];
6865 [label="SyntaxFacts.IsAnyToken(kind) 104605"];
6866 [label="param IsAnyToken(SyntaxKind kind) 104606"];
6867 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 104607"];
6868 [label="return true; 104608"];
6869 [label="this.CurrentToken 104609"];
6870 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104610"];
6871 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104611"];
6872 [label="ct.Kind 104612"];
6873 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 104613"];
6874 [label="param GetTrailingTrivia(this) 104614"];
6875 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104615"];
6876 [label="MoveToNextToken(); 104616"];
6877 [label="return ct; 104617"];
6878 [label="this.CurrentToken 104618"];
6879 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104619"];
6880 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104620"];
6881 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104621"];
6882 [label="return _lexedTokens[_tokenOffset]; 104622"];
6883 [label="if (this.CurrentToken.Kind != SyntaxKind.CloseParenToken)\n                {\n                    this.ParseForStatementExpressionList(ref semi2, incrementors);\n                } 104623"];
6884 [label="this.CurrentToken.Kind 104624"];
6885 [label="get { return (SyntaxKind)this.RawKind; } 104625"];
6886 [label="var closeParen = this.EatToken(SyntaxKind.CloseParenToken); 104626"];
6887 [label="this.EatToken(SyntaxKind.CloseParenToken) 104627"];
6888 [label="param EatToken(SyntaxKind kind) 104628"];
6889 [label="param EatToken(this) 104629"];
6890 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 104630"];
6891 [label="SyntaxFacts.IsAnyToken(kind) 104631"];
6892 [label="param IsAnyToken(SyntaxKind kind) 104632"];
6893 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 104633"];
6894 [label="return true; 104634"];
6895 [label="this.CurrentToken 104635"];
6896 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104636"];
6897 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104637"];
6898 [label="ct.Kind 104638"];
6899 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 104639"];
6900 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104640"];
6901 [label="MoveToNextToken(); 104641"];
6902 [label="return ct; 104642"];
6903 [label="ParseEmbeddedStatement() 104643"];
6904 [label="param ParseEmbeddedStatement(this) 104644"];
6905 [label="this.ParsePossiblyAttributedStatement() 104645"];
6906 [label="=> ParseStatementCore(ParseAttributeDeclarations(), isGlobal: false) 104646"];
6907 [label="var attributes = _pool.Allocate<AttributeListSyntax>(); 104647"];
6908 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104648"];
6909 [label="return this.CurrentToken.Kind == SyntaxKind.OpenBracketToken; 104649"];
6910 [label="this.CurrentToken.Kind 104650"];
6911 [label="get { return (SyntaxKind)this.RawKind; } 104651"];
6912 [label="while (this.IsPossibleAttributeDeclaration())\n                {\n                    attributes.Add(this.ParseAttributeDeclaration());\n                } 104652"];
6913 [label="false 104653"];
6914 [label="isGlobal: false 104654"];
6915 [label="param ParseStatementCore(SyntaxList<AttributeListSyntax> attributes) 104655"];
6916 [label="param ParseStatementCore(bool isGlobal) 104656"];
6917 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 104657"];
6918 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 104658"];
6919 [label="canReuseStatement(attributes, isGlobal) 104659"];
6920 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 104660"];
6921 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 104661"];
6922 [label="bool canReuseStatement(SyntaxList<AttributeListSyntax> attributes, bool isGlobal)\n            {\n                return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0;\n            } 104662"];
6923 [label="this.IsIncrementalAndFactoryContextMatches 104663"];
6924 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 104664"];
6925 [label="base.IsIncremental 104665"];
6926 [label="get\n            {\n                return _isIncremental;\n            } 104666"];
6927 [label="return _isIncremental; 104667"];
6928 [label="return this.IsIncrementalAndFactoryContextMatches &&\n                       this.CurrentNode is Syntax.StatementSyntax &&\n                       !isGlobal && // Top-level statements are reused by ParseMemberDeclarationOrStatementCore when possible.\n                       attributes.Count == 0; 104668"];
6929 [label="if (canReuseStatement(attributes, isGlobal))\n            {\n                return (StatementSyntax)this.EatNode();\n            } 104669"];
6930 [label="return new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth); 104670"];
6931 [label="new ResetPoint(\n                base.GetResetPoint(),\n                _termState,\n                _isInTry,\n                _syntaxFactoryContext.IsInAsync,\n                _syntaxFactoryContext.QueryDepth) 104671"];
6932 [label="param ResetPoint(this) 104672"];
6933 [label="ResetPoint resetPointBeforeStatement = this.GetResetPoint(); 104673"];
6934 [label="StackGuard.EnsureSufficientExecutionStack(_recursionDepth); 104674"];
6935 [label="StatementSyntax result; 104675"];
6936 [label="return this.ParseBlock(attributes); 104676"];
6937 [label="this.ParseBlock(attributes) 104677"];
6938 [label="param ParseBlock(SyntaxList<AttributeListSyntax> attributes) 104678"];
6939 [label="param ParseBlock(this) 104679"];
6940 [label="this.IsIncrementalAndFactoryContextMatches 104680"];
6941 [label="get\n            {\n                if (!base.IsIncremental)\n                {\n                    return false;\n                }\n\n                CSharp.CSharpSyntaxNode current = this.CurrentNode;\n                return current != null && MatchesFactoryContext(current.Green, _syntaxFactoryContext);\n            } 104681"];
6942 [label="if (this.IsIncrementalAndFactoryContextMatches && this.CurrentNodeKind == SyntaxKind.Block)\n                return (BlockSyntax)this.EatNode(); 104682"];
6943 [label="CSharpSyntaxNode openBrace = this.EatToken(SyntaxKind.OpenBraceToken); 104683"];
6944 [label="this.EatToken(SyntaxKind.OpenBraceToken) 104684"];
6945 [label="param EatToken(SyntaxKind kind) 104685"];
6946 [label="param EatToken(this) 104686"];
6947 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 104687"];
6948 [label="SyntaxFacts.IsAnyToken(kind) 104688"];
6949 [label="param IsAnyToken(SyntaxKind kind) 104689"];
6950 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 104690"];
6951 [label="return true; 104691"];
6952 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 104692"];
6953 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104693"];
6954 [label="MoveToNextToken(); 104694"];
6955 [label="return ct; 104695"];
6956 [label="var statements = _pool.Allocate<StatementSyntax>(); 104696"];
6957 [label="this.ParseStatements(ref openBrace, statements, stopOnSwitchSections: false); 104697"];
6958 [label="this.ParseStatements(ref openBrace, statements, stopOnSwitchSections: false); 104698"];
6959 [label="this.ParseStatements(ref openBrace, statements, stopOnSwitchSections: false); 104699"];
6960 [label="this.ParseStatements(ref openBrace, statements, stopOnSwitchSections: false) 104700"];
6961 [label="param ParseStatements(ref CSharpSyntaxNode previousNode) 104701"];
6962 [label="param ParseStatements(SyntaxListBuilder<StatementSyntax> statements) 104702"];
6963 [label="param ParseStatements(bool stopOnSwitchSections) 104703"];
6964 [label="param ParseStatements(this) 104704"];
6965 [label="var saveTerm = _termState; 104705"];
6966 [label="_termState |= TerminatorState.IsPossibleStatementStartOrStop; 104706"];
6967 [label="_termState 104707"];
6968 [label="if (stopOnSwitchSections)\n            {\n                _termState |= TerminatorState.IsSwitchSectionStart;\n            } 104708"];
6969 [label="int lastTokenPosition = -1; 104709"];
6970 [label="this.CurrentToken 104710"];
6971 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104711"];
6972 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104712"];
6973 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104713"];
6974 [label="return _lexedTokens[_tokenOffset]; 104714"];
6975 [label="while (this.CurrentToken.Kind != SyntaxKind.CloseBraceToken\n                && this.CurrentToken.Kind != SyntaxKind.EndOfFileToken\n                && !(stopOnSwitchSections && this.IsPossibleSwitchSection())\n                && IsMakingProgress(ref lastTokenPosition))\n            {\n                if (this.IsPossibleStatement(acceptAccessibilityMods: true))\n                {\n                    var statement = this.ParsePossiblyAttributedStatement();\n                    if (statement != null)\n                    {\n                        statements.Add(statement);\n                        continue;\n                    }\n                }\n\n                GreenNode trailingTrivia;\n                var action = this.SkipBadStatementListTokens(statements, SyntaxKind.CloseBraceToken, out trailingTrivia);\n                if (trailingTrivia != null)\n                {\n                    previousNode = AddTrailingSkippedSyntax(previousNode, trailingTrivia);\n                }\n\n                if (action == PostSkipAction.Abort)\n                {\n                    break;\n                }\n            } 104715"];
6976 [label="this.CurrentToken.Kind 104716"];
6977 [label="get { return (SyntaxKind)this.RawKind; } 104717"];
6978 [label="_termState 104718"];
6979 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104719"];
6980 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104720"];
6981 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104721"];
6982 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104722"];
6983 [label="this.EatToken(SyntaxKind.CloseBraceToken) 104723"];
6984 [label="param EatToken(SyntaxKind kind) 104724"];
6985 [label="param EatToken(this) 104725"];
6986 [label="Debug.Assert(SyntaxFacts.IsAnyToken(kind)); 104726"];
6987 [label="SyntaxFacts.IsAnyToken(kind) 104727"];
6988 [label="param IsAnyToken(SyntaxKind kind) 104728"];
6989 [label="if (kind >= SyntaxKind.TildeToken && kind < SyntaxKind.EndOfLineTrivia) return true; 104729"];
6990 [label="return true; 104730"];
6991 [label="return _currentToken ?? (_currentToken = this.FetchCurrentToken()); 104731"];
6992 [label="if (ct.Kind == kind)\n            {\n                MoveToNextToken();\n                return ct;\n            } 104732"];
6993 [label="param GetTrailingTrivia(this) 104733"];
6994 [label="if (_blendedTokens != null)\n            {\n                _currentNode = default(BlendedNode);\n            } 104734"];
6995 [label="MoveToNextToken(); 104735"];
6996 [label="return ct; 104736"];
6997 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104737"];
6998 [label="var block = _syntaxFactory.Block(\n                attributes,\n                (SyntaxToken)openBrace,\n                statements,\n                this.EatToken(SyntaxKind.CloseBraceToken)); 104738"];
6999 [label="param SetFactoryContext(SyntaxFactoryContext context) 104739"];
7000 [label="param SetFactoryContext(this) 104740"];
7001 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104741"];
7002 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104742"];
7003 [label="_pool.Free(statements); 104743"];
7004 [label="_pool.Free(statements); 104744"];
7005 [label="return block; 104745"];
7006 [label="_recursionDepth 104746"];
7007 [label="this.Release(ref resetPointBeforeStatement); 104747"];
7008 [label="this.Release(ref resetPointBeforeStatement) 104748"];
7009 [label="param Release(ref ResetPoint state) 104749"];
7010 [label="param Release(this) 104750"];
7011 [label="param Release(this) 104751"];
7012 [label="Debug.Assert(_resetCount == point.ResetCount); 104752"];
7013 [label="_resetCount 104753"];
7014 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104754"];
7015 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104755"];
7016 [label="this.Release(ref resetPointBeforeStatement); 104756"];
7017 [label="return parseEmbeddedStatementRest(this.ParsePossiblyAttributedStatement()); 104757"];
7018 [label="parseEmbeddedStatementRest(this.ParsePossiblyAttributedStatement()) 104758"];
7019 [label="StatementSyntax parseEmbeddedStatementRest(StatementSyntax statement)\n            {\n                if (statement == null)\n                {\n                    // The consumers of embedded statements are expecting to receive a non-null statement \n                    // yet there are several error conditions that can lead ParseStatementCore to return \n                    // null.  When that occurs create an error empty Statement and return it to the caller.\n                    return SyntaxFactory.EmptyStatement(attributeLists: default, EatToken(SyntaxKind.SemicolonToken));\n                }\n\n                // In scripts, stand-alone expression statements may not be followed by semicolons.\n                // ParseExpressionStatement hides the error.\n                // However, embedded expression statements are required to be followed by semicolon. \n                if (statement.Kind == SyntaxKind.ExpressionStatement &&\n                    IsScript)\n                {\n                    var expressionStatementSyntax = (ExpressionStatementSyntax)statement;\n                    var semicolonToken = expressionStatementSyntax.SemicolonToken;\n\n                    // Do not add a new error if the same error was already added.\n                    if (semicolonToken.IsMissing &&\n                        !semicolonToken.GetDiagnostics().Contains(diagnosticInfo => (ErrorCode)diagnosticInfo.Code == ErrorCode.ERR_SemicolonExpected))\n                    {\n                        semicolonToken = this.AddError(semicolonToken, ErrorCode.ERR_SemicolonExpected);\n                        return expressionStatementSyntax.Update(expressionStatementSyntax.AttributeLists, expressionStatementSyntax.Expression, semicolonToken);\n                    }\n                }\n\n                return statement;\n            } 104759"];
7020 [label="StatementSyntax parseEmbeddedStatementRest(StatementSyntax statement)\n            {\n                if (statement == null)\n                {\n                    // The consumers of embedded statements are expecting to receive a non-null statement \n                    // yet there are several error conditions that can lead ParseStatementCore to return \n                    // null.  When that occurs create an error empty Statement and return it to the caller.\n                    return SyntaxFactory.EmptyStatement(attributeLists: default, EatToken(SyntaxKind.SemicolonToken));\n                }\n\n                // In scripts, stand-alone expression statements may not be followed by semicolons.\n                // ParseExpressionStatement hides the error.\n                // However, embedded expression statements are required to be followed by semicolon. \n                if (statement.Kind == SyntaxKind.ExpressionStatement &&\n                    IsScript)\n                {\n                    var expressionStatementSyntax = (ExpressionStatementSyntax)statement;\n                    var semicolonToken = expressionStatementSyntax.SemicolonToken;\n\n                    // Do not add a new error if the same error was already added.\n                    if (semicolonToken.IsMissing &&\n                        !semicolonToken.GetDiagnostics().Contains(diagnosticInfo => (ErrorCode)diagnosticInfo.Code == ErrorCode.ERR_SemicolonExpected))\n                    {\n                        semicolonToken = this.AddError(semicolonToken, ErrorCode.ERR_SemicolonExpected);\n                        return expressionStatementSyntax.Update(expressionStatementSyntax.AttributeLists, expressionStatementSyntax.Expression, semicolonToken);\n                    }\n                }\n\n                return statement;\n            } 104760"];
7021 [label="if (statement == null)\n                {\n                    // The consumers of embedded statements are expecting to receive a non-null statement \n                    // yet there are several error conditions that can lead ParseStatementCore to return \n                    // null.  When that occurs create an error empty Statement and return it to the caller.\n                    return SyntaxFactory.EmptyStatement(attributeLists: default, EatToken(SyntaxKind.SemicolonToken));\n                } 104761"];
7022 [label="if (statement == null)\n                {\n                    // The consumers of embedded statements are expecting to receive a non-null statement \n                    // yet there are several error conditions that can lead ParseStatementCore to return \n                    // null.  When that occurs create an error empty Statement and return it to the caller.\n                    return SyntaxFactory.EmptyStatement(attributeLists: default, EatToken(SyntaxKind.SemicolonToken));\n                } 104762"];
7023 [label="statement.Kind 104763"];
7024 [label="get { return (SyntaxKind)this.RawKind; } 104764"];
7025 [label="return (SyntaxKind)this.RawKind; 104765"];
7026 [label="if (statement.Kind == SyntaxKind.ExpressionStatement &&\n                    IsScript)\n                {\n                    var expressionStatementSyntax = (ExpressionStatementSyntax)statement;\n                    var semicolonToken = expressionStatementSyntax.SemicolonToken;\n\n                    // Do not add a new error if the same error was already added.\n                    if (semicolonToken.IsMissing &&\n                        !semicolonToken.GetDiagnostics().Contains(diagnosticInfo => (ErrorCode)diagnosticInfo.Code == ErrorCode.ERR_SemicolonExpected))\n                    {\n                        semicolonToken = this.AddError(semicolonToken, ErrorCode.ERR_SemicolonExpected);\n                        return expressionStatementSyntax.Update(expressionStatementSyntax.AttributeLists, expressionStatementSyntax.Expression, semicolonToken);\n                    }\n                } 104766"];
7027 [label="return statement; 104767"];
7028 [label="var statement = ParseEmbeddedStatement(); 104768"];
7029 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104769"];
7030 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104770"];
7031 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104771"];
7032 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104772"];
7033 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104773"];
7034 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104774"];
7035 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104775"];
7036 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104776"];
7037 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104777"];
7038 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104778"];
7039 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104779"];
7040 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104780"];
7041 [label="return _syntaxFactory.ForStatement(attributes, forToken, openParen, decl, initializers, semi, condition, semi2, incrementors, closeParen, statement); 104781"];
7042 [label="param CSharpSyntaxNode(this) 104782"];
7043 [label="GreenStats.NoteGreen(this); 104783"];
7044 [label="param SetFactoryContext(SyntaxFactoryContext context) 104784"];
7045 [label="param SetFactoryContext(this) 104785"];
7046 [label="if (context.IsInAsync)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInAsync;\n            } 104786"];
7047 [label="if (context.IsInQuery)\n            {\n                this.flags |= NodeFlags.FactoryContextIsInQuery;\n            } 104787"];
7048 [label="_termState 104788"];
7049 [label="this.Release(ref resetPoint); 104789"];
7050 [label="this.Release(ref resetPoint) 104790"];
7051 [label="param Release(ref ResetPoint state) 104791"];
7052 [label="param Release(this) 104792"];
7053 [label="base.Release(ref state.BaseResetPoint); 104793"];
7054 [label="base.Release(ref state.BaseResetPoint) 104794"];
7055 [label="param Release(ref ResetPoint point) 104795"];
7056 [label="param Release(this) 104796"];
7057 [label="Debug.Assert(_resetCount == point.ResetCount); 104797"];
7058 [label="_resetCount 104798"];
7059 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104799"];
7060 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104800"];
7061 [label="base.Release(ref state.BaseResetPoint); 104801"];
7062 [label="this.Release(ref resetPoint); 104802"];
7063 [label="_pool.Free(incrementors); 104803"];
7064 [label="_pool.Free(incrementors); 104804"];
7065 [label="_pool.Free(initializers); 104805"];
7066 [label="_pool.Free(initializers); 104806"];
7067 [label="this.Release(ref resetPoint); 104807"];
7068 [label="this.Release(ref resetPoint) 104808"];
7069 [label="param Release(ref ResetPoint state) 104809"];
7070 [label="param Release(this) 104810"];
7071 [label="base.Release(ref state.BaseResetPoint); 104811"];
7072 [label="base.Release(ref state.BaseResetPoint) 104812"];
7073 [label="param Release(ref ResetPoint point) 104813"];
7074 [label="param Release(this) 104814"];
7075 [label="Debug.Assert(_resetCount == point.ResetCount); 104815"];
7076 [label="_resetCount 104816"];
7077 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104817"];
7078 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104818"];
7079 [label="base.Release(ref state.BaseResetPoint); 104819"];
7080 [label="this.Release(ref resetPoint); 104820"];
7081 [label="this.Release(ref resetPointBeforeStatement); 104821"];
7082 [label="this.Release(ref resetPointBeforeStatement) 104822"];
7083 [label="param Release(ref ResetPoint state) 104823"];
7084 [label="param Release(this) 104824"];
7085 [label="base.Release(ref state.BaseResetPoint); 104825"];
7086 [label="base.Release(ref state.BaseResetPoint) 104826"];
7087 [label="param Release(ref ResetPoint point) 104827"];
7088 [label="param Release(this) 104828"];
7089 [label="Debug.Assert(_resetCount == point.ResetCount); 104829"];
7090 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104830"];
7091 [label="if (_resetCount == 0)\n            {\n                _resetStart = -1;\n            } 104831"];
7092 [label="_resetStart = -1; 104832"];
7093 [label="_resetStart 104833"];
7094 [label="base.Release(ref state.BaseResetPoint); 104834"];
7095 [label="this.Release(ref resetPointBeforeStatement); 104835"];
7096 [label="var node = parser.ParseStatement(); 104836"];
7097 [label="if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node); 104837"];
7098 [label="node = parser.ConsumeUnexpectedTokens(node); 104838"];
7099 [label="parser.ConsumeUnexpectedTokens(node) 104839"];
7100 [label="param ConsumeUnexpectedTokens(TNode node) 104840"];
7101 [label="param ConsumeUnexpectedTokens(this) 104841"];
7102 [label="this.CurrentToken 104842"];
7103 [label="get\n            {\n                return _currentToken ?? (_currentToken = this.FetchCurrentToken());\n            } 104843"];
7104 [label="this.FetchCurrentToken() 104844"];
7105 [label="param FetchCurrentToken(this) 104845"];
7106 [label="if (_tokenOffset >= _tokenCount)\n            {\n                this.AddNewToken();\n            } 104846"];
7107 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104847"];
7108 [label="if (_blendedTokens != null)\n            {\n                return _blendedTokens[_tokenOffset].Token;\n            }\n            else\n            {\n                return _lexedTokens[_tokenOffset];\n            } 104848"];
7109 [label="if (this.CurrentToken.Kind == SyntaxKind.EndOfFileToken) return node; 104849"];
7110 [label="this.CurrentToken.Kind 104850"];
7111 [label="get { return (SyntaxKind)this.RawKind; } 104851"];
7112 [label="return node; 104852"];
7113 [label="return (StatementSyntax)node.CreateRed(); 104853"];
7114 [label="return (StatementSyntax)node.CreateRed(); 104854"];
7115 [label="return (StatementSyntax)node.CreateRed(); 104855"];
7116 [label="param CSharpSyntaxNode(GreenNode green) 104856"];
7117 [label="param CSharpSyntaxNode(SyntaxNode? parent) 104857"];
7118 [label="param CSharpSyntaxNode(int position) 104858"];
7119 [label="param CSharpSyntaxNode(this) 104859"];
7120 [label="green 104860"];
7121 [label="parent 104861"];
7122 [label="position 104862"];
7123 [label="param CSharpSyntaxNode(this) 104863"];
7124 [label="param CSharpSyntaxNode(this) 104864"];
7125 [label="CustomAssert.NotNull(statement); 104865"];
7126 [label="CustomAssert.Equal(SyntaxKind.ForStatement, statement.Kind()); 104866"];
7127 [label="statement.Kind() 104867"];
7128 [label="param Kind(this) 104868"];
7129 [label="return (SyntaxKind)this.Green.RawKind; 104869"];
7130 [label="CustomAssert.Equal(SyntaxKind.ForStatement, statement.Kind()); 104870"];
7131 [label="CustomAssert.Equal(text, statement.ToString()); 104871"];
7132 [label="CustomAssert.Equal(text, statement.ToString()); 104872"];
7133 [label="CustomAssert.Equal(text, statement.ToString()); 104873"];
7134 [label="=> true 104874"];
7135 [label="true 104875"];
7136 [label="CustomAssert.Equal(text, statement.ToString()); 104876"];
7137 [label="param WriteTokenTo(System.IO.TextWriter writer) 104877"];
7138 [label="param WriteTokenTo(bool leading) 104878"];
7139 [label="param WriteTokenTo(bool trailing) 104879"];
7140 [label="param WriteTokenTo(this) 104880"];
7141 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 104881"];
7142 [label="this.Text 104882"];
7143 [label="get { return SyntaxFacts.GetText(this.Kind); } 104883"];
7144 [label="this.Kind 104884"];
7145 [label="get { return (SyntaxKind)this.RawKind; } 104885"];
7146 [label="return (SyntaxKind)this.RawKind; 104886"];
7147 [label="return SyntaxFacts.GetText(this.Kind); 104887"];
7148 [label="SyntaxFacts.GetText(this.Kind) 104888"];
7149 [label="param GetText(SyntaxKind kind) 104889"];
7150 [label="switch (kind)\n            {\n                case SyntaxKind.TildeToken:\n                    return '~';\n                case SyntaxKind.ExclamationToken:\n                    return '!';\n                case SyntaxKind.DollarToken:\n                    return '$';\n                case SyntaxKind.PercentToken:\n                    return '%';\n                case SyntaxKind.CaretToken:\n                    return '^';\n                case SyntaxKind.AmpersandToken:\n                    return '&';\n                case SyntaxKind.AsteriskToken:\n                    return '*';\n                case SyntaxKind.OpenParenToken:\n                    return '(';\n                case SyntaxKind.CloseParenToken:\n                    return ')';\n                case SyntaxKind.MinusToken:\n                    return '-';\n                case SyntaxKind.PlusToken:\n                    return '+';\n                case SyntaxKind.EqualsToken:\n                    return '=';\n                case SyntaxKind.OpenBraceToken:\n                    return '{';\n                case SyntaxKind.CloseBraceToken:\n                    return '}';\n                case SyntaxKind.OpenBracketToken:\n                    return '[';\n                case SyntaxKind.CloseBracketToken:\n                    return ']';\n                case SyntaxKind.BarToken:\n                    return '|';\n                case SyntaxKind.BackslashToken:\n                    return '\\\\';\n                case SyntaxKind.ColonToken:\n                    return ':';\n                case SyntaxKind.SemicolonToken:\n                    return ';';\n                case SyntaxKind.DoubleQuoteToken:\n                    return '\\'';\n                case SyntaxKind.SingleQuoteToken:\n                    return ''';\n                case SyntaxKind.LessThanToken:\n                    return '<';\n                case SyntaxKind.CommaToken:\n                    return ',';\n                case SyntaxKind.GreaterThanToken:\n                    return '>';\n                case SyntaxKind.DotToken:\n                    return '.';\n                case SyntaxKind.QuestionToken:\n                    return '?';\n                case SyntaxKind.HashToken:\n                    return '#';\n                case SyntaxKind.SlashToken:\n                    return '/';\n                case SyntaxKind.SlashGreaterThanToken:\n                    return '/>';\n                case SyntaxKind.LessThanSlashToken:\n                    return '</';\n                case SyntaxKind.XmlCommentStartToken:\n                    return '<!--';\n                case SyntaxKind.XmlCommentEndToken:\n                    return '-->';\n                case SyntaxKind.XmlCDataStartToken:\n                    return '<![CDATA[';\n                case SyntaxKind.XmlCDataEndToken:\n                    return ']]>';\n                case SyntaxKind.XmlProcessingInstructionStartToken:\n                    return '<?';\n                case SyntaxKind.XmlProcessingInstructionEndToken:\n                    return '?>';\n\n                // compound\n                case SyntaxKind.BarBarToken:\n                    return '||';\n                case SyntaxKind.AmpersandAmpersandToken:\n                    return '&&';\n                case SyntaxKind.MinusMinusToken:\n                    return '--';\n                case SyntaxKind.PlusPlusToken:\n                    return '++';\n                case SyntaxKind.ColonColonToken:\n                    return '::';\n                case SyntaxKind.QuestionQuestionToken:\n                    return '??';\n                case SyntaxKind.MinusGreaterThanToken:\n                    return '->';\n                case SyntaxKind.ExclamationEqualsToken:\n                    return '!=';\n                case SyntaxKind.EqualsEqualsToken:\n                    return '==';\n                case SyntaxKind.EqualsGreaterThanToken:\n                    return '=>';\n                case SyntaxKind.LessThanEqualsToken:\n                    return '<=';\n                case SyntaxKind.LessThanLessThanToken:\n                    return '<<';\n                case SyntaxKind.LessThanLessThanEqualsToken:\n                    return '<<=';\n                case SyntaxKind.GreaterThanEqualsToken:\n                    return '>=';\n                case SyntaxKind.GreaterThanGreaterThanToken:\n                    return '>>';\n                case SyntaxKind.GreaterThanGreaterThanEqualsToken:\n                    return '>>=';\n                case SyntaxKind.SlashEqualsToken:\n                    return '/=';\n                case SyntaxKind.AsteriskEqualsToken:\n                    return '*=';\n                case SyntaxKind.BarEqualsToken:\n                    return '|=';\n                case SyntaxKind.AmpersandEqualsToken:\n                    return '&=';\n                case SyntaxKind.PlusEqualsToken:\n                    return '+=';\n                case SyntaxKind.MinusEqualsToken:\n                    return '-=';\n                case SyntaxKind.CaretEqualsToken:\n                    return '^=';\n                case SyntaxKind.PercentEqualsToken:\n                    return '%=';\n                case SyntaxKind.QuestionQuestionEqualsToken:\n                    return '??=';\n                case SyntaxKind.DotDotToken:\n                    return '..';\n\n                // Keywords\n                case SyntaxKind.BoolKeyword:\n                    return 'bool';\n                case SyntaxKind.ByteKeyword:\n                    return 'byte';\n                case SyntaxKind.SByteKeyword:\n                    return 'sbyte';\n                case SyntaxKind.ShortKeyword:\n                    return 'short';\n                case SyntaxKind.UShortKeyword:\n                    return 'ushort';\n                case SyntaxKind.IntKeyword:\n                    return 'int';\n                case SyntaxKind.UIntKeyword:\n                    return 'uint';\n                case SyntaxKind.LongKeyword:\n                    return 'long';\n                case SyntaxKind.ULongKeyword:\n                    return 'ulong';\n                case SyntaxKind.DoubleKeyword:\n                    return 'double';\n                case SyntaxKind.FloatKeyword:\n                    return 'float';\n                case SyntaxKind.DecimalKeyword:\n                    return 'decimal';\n                case SyntaxKind.StringKeyword:\n                    return 'string';\n                case SyntaxKind.CharKeyword:\n                    return 'char';\n                case SyntaxKind.VoidKeyword:\n                    return 'void';\n                case SyntaxKind.ObjectKeyword:\n                    return 'object';\n                case SyntaxKind.TypeOfKeyword:\n                    return 'typeof';\n                case SyntaxKind.SizeOfKeyword:\n                    return 'sizeof';\n                case SyntaxKind.NullKeyword:\n                    return 'null';\n                case SyntaxKind.TrueKeyword:\n                    return 'true';\n                case SyntaxKind.FalseKeyword:\n                    return 'false';\n                case SyntaxKind.IfKeyword:\n                    return 'if';\n                case SyntaxKind.ElseKeyword:\n                    return 'else';\n                case SyntaxKind.WhileKeyword:\n                    return 'while';\n                case SyntaxKind.ForKeyword:\n                    return 'for';\n                case SyntaxKind.ForEachKeyword:\n                    return 'foreach';\n                case SyntaxKind.DoKeyword:\n                    return 'do';\n                case SyntaxKind.SwitchKeyword:\n                    return 'switch';\n                case SyntaxKind.CaseKeyword:\n                    return 'case';\n                case SyntaxKind.DefaultKeyword:\n                    return 'default';\n                case SyntaxKind.TryKeyword:\n                    return 'try';\n                case SyntaxKind.CatchKeyword:\n                    return 'catch';\n                case SyntaxKind.FinallyKeyword:\n                    return 'finally';\n                case SyntaxKind.LockKeyword:\n                    return 'lock';\n                case SyntaxKind.GotoKeyword:\n                    return 'goto';\n                case SyntaxKind.BreakKeyword:\n                    return 'break';\n                case SyntaxKind.ContinueKeyword:\n                    return 'continue';\n                case SyntaxKind.ReturnKeyword:\n                    return 'return';\n                case SyntaxKind.ThrowKeyword:\n                    return 'throw';\n                case SyntaxKind.PublicKeyword:\n                    return 'public';\n                case SyntaxKind.PrivateKeyword:\n                    return 'private';\n                case SyntaxKind.InternalKeyword:\n                    return 'internal';\n                case SyntaxKind.ProtectedKeyword:\n                    return 'protected';\n                case SyntaxKind.StaticKeyword:\n                    return 'static';\n                case SyntaxKind.ReadOnlyKeyword:\n                    return 'readonly';\n                case SyntaxKind.SealedKeyword:\n                    return 'sealed';\n                case SyntaxKind.ConstKeyword:\n                    return 'const';\n                case SyntaxKind.FixedKeyword:\n                    return 'fixed';\n                case SyntaxKind.StackAllocKeyword:\n                    return 'stackalloc';\n                case SyntaxKind.VolatileKeyword:\n                    return 'volatile';\n                case SyntaxKind.NewKeyword:\n                    return 'new';\n                case SyntaxKind.OverrideKeyword:\n                    return 'override';\n                case SyntaxKind.AbstractKeyword:\n                    return 'abstract';\n                case SyntaxKind.VirtualKeyword:\n                    return 'virtual';\n                case SyntaxKind.EventKeyword:\n                    return 'event';\n                case SyntaxKind.ExternKeyword:\n                    return 'extern';\n                case SyntaxKind.RefKeyword:\n                    return 'ref';\n                case SyntaxKind.OutKeyword:\n                    return 'out';\n                case SyntaxKind.InKeyword:\n                    return 'in';\n                case SyntaxKind.IsKeyword:\n                    return 'is';\n                case SyntaxKind.AsKeyword:\n                    return 'as';\n                case SyntaxKind.ParamsKeyword:\n                    return 'params';\n                case SyntaxKind.ArgListKeyword:\n                    return '__arglist';\n                case SyntaxKind.MakeRefKeyword:\n                    return '__makeref';\n                case SyntaxKind.RefTypeKeyword:\n                    return '__reftype';\n                case SyntaxKind.RefValueKeyword:\n                    return '__refvalue';\n                case SyntaxKind.ThisKeyword:\n                    return 'this';\n                case SyntaxKind.BaseKeyword:\n                    return 'base';\n                case SyntaxKind.NamespaceKeyword:\n                    return 'namespace';\n                case SyntaxKind.UsingKeyword:\n                    return 'using';\n                case SyntaxKind.ClassKeyword:\n                    return 'class';\n                case SyntaxKind.StructKeyword:\n                    return 'struct';\n                case SyntaxKind.InterfaceKeyword:\n                    return 'interface';\n                case SyntaxKind.EnumKeyword:\n                    return 'enum';\n                case SyntaxKind.DelegateKeyword:\n                    return 'delegate';\n                case SyntaxKind.CheckedKeyword:\n                    return 'checked';\n                case SyntaxKind.UncheckedKeyword:\n                    return 'unchecked';\n                case SyntaxKind.UnsafeKeyword:\n                    return 'unsafe';\n                case SyntaxKind.OperatorKeyword:\n                    return 'operator';\n                case SyntaxKind.ImplicitKeyword:\n                    return 'implicit';\n                case SyntaxKind.ExplicitKeyword:\n                    return 'explicit';\n                case SyntaxKind.ElifKeyword:\n                    return 'elif';\n                case SyntaxKind.EndIfKeyword:\n                    return 'endif';\n                case SyntaxKind.RegionKeyword:\n                    return 'region';\n                case SyntaxKind.EndRegionKeyword:\n                    return 'endregion';\n                case SyntaxKind.DefineKeyword:\n                    return 'define';\n                case SyntaxKind.UndefKeyword:\n                    return 'undef';\n                case SyntaxKind.WarningKeyword:\n                    return 'warning';\n                case SyntaxKind.ErrorKeyword:\n                    return 'error';\n                case SyntaxKind.LineKeyword:\n                    return 'line';\n                case SyntaxKind.PragmaKeyword:\n                    return 'pragma';\n                case SyntaxKind.HiddenKeyword:\n                    return 'hidden';\n                case SyntaxKind.ChecksumKeyword:\n                    return 'checksum';\n                case SyntaxKind.DisableKeyword:\n                    return 'disable';\n                case SyntaxKind.RestoreKeyword:\n                    return 'restore';\n                case SyntaxKind.ReferenceKeyword:\n                    return 'r';\n                case SyntaxKind.LoadKeyword:\n                    return 'load';\n                case SyntaxKind.NullableKeyword:\n                    return 'nullable';\n                case SyntaxKind.EnableKeyword:\n                    return 'enable';\n                case SyntaxKind.WarningsKeyword:\n                    return 'warnings';\n                case SyntaxKind.AnnotationsKeyword:\n                    return 'annotations';\n\n                // contextual keywords\n                case SyntaxKind.YieldKeyword:\n                    return 'yield';\n                case SyntaxKind.PartialKeyword:\n                    return 'partial';\n                case SyntaxKind.FromKeyword:\n                    return 'from';\n                case SyntaxKind.GroupKeyword:\n                    return 'group';\n                case SyntaxKind.JoinKeyword:\n                    return 'join';\n                case SyntaxKind.IntoKeyword:\n                    return 'into';\n                case SyntaxKind.LetKeyword:\n                    return 'let';\n                case SyntaxKind.ByKeyword:\n                    return 'by';\n                case SyntaxKind.WhereKeyword:\n                    return 'where';\n                case SyntaxKind.SelectKeyword:\n                    return 'select';\n                case SyntaxKind.GetKeyword:\n                    return 'get';\n                case SyntaxKind.SetKeyword:\n                    return 'set';\n                case SyntaxKind.AddKeyword:\n                    return 'add';\n                case SyntaxKind.RemoveKeyword:\n                    return 'remove';\n                case SyntaxKind.OrderByKeyword:\n                    return 'orderby';\n                case SyntaxKind.AliasKeyword:\n                    return 'alias';\n                case SyntaxKind.OnKeyword:\n                    return 'on';\n                case SyntaxKind.EqualsKeyword:\n                    return 'equals';\n                case SyntaxKind.AscendingKeyword:\n                    return 'ascending';\n                case SyntaxKind.DescendingKeyword:\n                    return 'descending';\n                case SyntaxKind.AssemblyKeyword:\n                    return 'assembly';\n                case SyntaxKind.ModuleKeyword:\n                    return 'module';\n                case SyntaxKind.TypeKeyword:\n                    return 'type';\n                case SyntaxKind.FieldKeyword:\n                    return 'field';\n                case SyntaxKind.MethodKeyword:\n                    return 'method';\n                case SyntaxKind.ParamKeyword:\n                    return 'param';\n                case SyntaxKind.PropertyKeyword:\n                    return 'property';\n                case SyntaxKind.TypeVarKeyword:\n                    return 'typevar';\n                case SyntaxKind.GlobalKeyword:\n                    return 'global';\n                case SyntaxKind.NameOfKeyword:\n                    return 'nameof';\n                case SyntaxKind.AsyncKeyword:\n                    return 'async';\n                case SyntaxKind.AwaitKeyword:\n                    return 'await';\n                case SyntaxKind.WhenKeyword:\n                    return 'when';\n                case SyntaxKind.InterpolatedStringStartToken:\n                    return '$\\'';\n                case SyntaxKind.InterpolatedStringEndToken:\n                    return '\\'';\n                case SyntaxKind.InterpolatedVerbatimStringStartToken:\n                    return '$@\\'';\n                case SyntaxKind.UnderscoreToken:\n                    return '_';\n                case SyntaxKind.VarKeyword:\n                    return 'var';\n                case SyntaxKind.AndKeyword:\n                    return 'and';\n                case SyntaxKind.OrKeyword:\n                    return 'or';\n                case SyntaxKind.NotKeyword:\n                    return 'not';\n                case SyntaxKind.DataKeyword:\n                    return 'data';\n                case SyntaxKind.WithKeyword:\n                    return 'with';\n                case SyntaxKind.InitKeyword:\n                    return 'init';\n                case SyntaxKind.RecordKeyword:\n                    return 'record';\n                case SyntaxKind.ManagedKeyword:\n                    return 'managed';\n                case SyntaxKind.UnmanagedKeyword:\n                    return 'unmanaged';\n                default:\n                    return string.Empty;\n            } 104890"];
7151 [label="return 'for'; 104891"];
7152 [label="writer.Write(this.Text); 104892"];
7153 [label="writer.Write(this.Text); 104893"];
7154 [label="if (trailing)\n            {\n                var trivia = this.GetTrailingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 104894"];
7155 [label="this.GetTrailingTrivia() 104895"];
7156 [label="param GetTrailingTrivia(this) 104896"];
7157 [label="var trivia = this.GetTrailingTrivia(); 104897"];
7158 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104898"];
7159 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104899"];
7160 [label="this.GetLeadingTrivia() 104900"];
7161 [label="param GetLeadingTrivia(this) 104901"];
7162 [label="return null; 104902"];
7163 [label="var trivia = this.GetLeadingTrivia(); 104903"];
7164 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104904"];
7165 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104905"];
7166 [label="return '('; 104906"];
7167 [label="get { return this.TextField; } 104907"];
7168 [label="return this.TextField; 104908"];
7169 [label="param GetTrailingTrivia(this) 104909"];
7170 [label="return _trailing; 104910"];
7171 [label="var trivia = this.GetTrailingTrivia(); 104911"];
7172 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104912"];
7173 [label="trivia.WriteTo(writer, true, true); 104913"];
7174 [label="trivia.WriteTo(writer, true, true); 104914"];
7175 [label="=> true 104915"];
7176 [label="true 104916"];
7177 [label="param WriteTriviaTo(System.IO.TextWriter writer) 104917"];
7178 [label="param WriteTriviaTo(this) 104918"];
7179 [label="writer.Write(Text); 104919"];
7180 [label="writer.Write(Text); 104920"];
7181 [label="=> true 104921"];
7182 [label="param GetLeadingTrivia(this) 104922"];
7183 [label="return this.LeadingField; 104923"];
7184 [label="var trivia = this.GetLeadingTrivia(); 104924"];
7185 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104925"];
7186 [label="return '='; 104926"];
7187 [label="param GetTrailingTrivia(this) 104927"];
7188 [label="=> true 104928"];
7189 [label="param GetLeadingTrivia(this) 104929"];
7190 [label="return _leading; 104930"];
7191 [label="var trivia = this.GetLeadingTrivia(); 104931"];
7192 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104932"];
7193 [label="get\n                {\n                    return this.TextField;\n                } 104933"];
7194 [label="return this.TextField; 104934"];
7195 [label="param GetTrailingTrivia(this) 104935"];
7196 [label="return ';'; 104936"];
7197 [label="return this.LeadingField; 104937"];
7198 [label="var trivia = this.GetLeadingTrivia(); 104938"];
7199 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104939"];
7200 [label="return ')'; 104940"];
7201 [label="=> true 104941"];
7202 [label="return this.LeadingField; 104942"];
7203 [label="var trivia = this.GetLeadingTrivia(); 104943"];
7204 [label="if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                } 104944"];
7205 [label="return '{'; 104945"];
7206 [label="=> true 104946"];
7207 [label="return '}'; 104947"];
7208 [label="CustomAssert.Equal(0, statement.Errors().Length); 104948"];
7209 [label="CustomAssert.Equal(0, statement.Errors().Length); 104949"];
7210 [label="statement.Errors() 104950"];
7211 [label="param Errors(this SyntaxNode node) 104951"];
7212 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 104952"];
7213 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 104953"];
7214 [label="node.Green.ErrorsOrWarnings(errorsOnly: true) 104954"];
7215 [label="param ErrorsOrWarnings(this GreenNode node) 104955"];
7216 [label="param ErrorsOrWarnings(bool errorsOnly) 104956"];
7217 [label="ArrayBuilder<DiagnosticInfo> b = ArrayBuilder<DiagnosticInfo>.GetInstance(); 104957"];
7218 [label="var l = new SyntaxDiagnosticInfoList(node); 104958"];
7219 [label="foreach (var item in l)\n            {\n                if (item.Severity == (errorsOnly ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning))\n                    b.Add(item);\n            } 104959"];
7220 [label="return b.ToImmutableAndFree(); 104960"];
7221 [label="return node.Green.ErrorsOrWarnings(errorsOnly: true); 104961"];
7222 [label="CustomAssert.Equal(0, statement.Errors().Length); 104962"];
7223 [label="var fs = (ForStatementSyntax)statement; 104963"];
7224 [label="CustomAssert.NotEqual(default, fs.ForKeyword); 104964"];
7225 [label="CustomAssert.NotEqual(default, fs.ForKeyword); 104965"];
7226 [label="fs.ForKeyword 104966"];
7227 [label="=> true 104967"];
7228 [label="true 104968"];
7229 [label="CustomAssert.NotEqual(default, fs.ForKeyword); 104969"];
7230 [label="CustomAssert.NotEqual(default, fs.ForKeyword); 104970"];
7231 [label="CustomAssert.False(fs.ForKeyword.IsMissing); 104971"];
7232 [label="fs.ForKeyword 104972"];
7233 [label="=> true 104973"];
7234 [label="true 104974"];
7235 [label="CustomAssert.False(fs.ForKeyword.IsMissing); 104975"];
7236 [label="CustomAssert.False(fs.ForKeyword.IsMissing); 104976"];
7237 [label="CustomAssert.Equal(SyntaxKind.ForKeyword, fs.ForKeyword.Kind()); 104977"];
7238 [label="CustomAssert.Equal(SyntaxKind.ForKeyword, fs.ForKeyword.Kind()); 104978"];
7239 [label="fs.ForKeyword 104979"];
7240 [label="=> true 104980"];
7241 [label="true 104981"];
7242 [label="CustomAssert.Equal(SyntaxKind.ForKeyword, fs.ForKeyword.Kind()); 104982"];
7243 [label="CustomAssert.Equal(SyntaxKind.ForKeyword, fs.ForKeyword.Kind()); 104983"];
7244 [label="param Kind(this SyntaxToken token) 104984"];
7245 [label="var rawKind = token.RawKind; 104985"];
7246 [label="return IsCSharpKind(rawKind) ? (SyntaxKind)rawKind : SyntaxKind.None; 104986"];
7247 [label="IsCSharpKind(rawKind) 104987"];
7248 [label="param IsCSharpKind(int rawKind) 104988"];
7249 [label="const int FirstVisualBasicKind = (int)SyntaxKind.List + 1; 104989"];
7250 [label="const int FirstCSharpKind = (int)SyntaxKind.TildeToken; 104990"];
7251 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 104991"];
7252 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 104992"];
7253 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 104993"];
7254 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 104994"];
7255 [label="return unchecked((uint)(rawKind - FirstVisualBasicKind)) > (FirstCSharpKind - 1 - FirstVisualBasicKind); 104995"];
7256 [label="CustomAssert.NotEqual(default, fs.OpenParenToken); 104996"];
7257 [label="CustomAssert.NotEqual(default, fs.OpenParenToken); 104997"];
7258 [label="fs.OpenParenToken 104998"];
7259 [label="=> true 104999"];
7260 [label="true 105000"];
7261 [label="CustomAssert.NotEqual(default, fs.OpenParenToken); 105001"];
7262 [label="CustomAssert.NotEqual(default, fs.OpenParenToken); 105002"];
7263 [label="CustomAssert.NotNull(fs.Declaration); 105003"];
7264 [label="fs.Declaration 105004"];
7265 [label="param CSharpSyntaxNode(GreenNode green) 105005"];
7266 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105006"];
7267 [label="param CSharpSyntaxNode(int position) 105007"];
7268 [label="param CSharpSyntaxNode(this) 105008"];
7269 [label="param CSharpSyntaxNode(this) 105009"];
7270 [label="CustomAssert.NotNull(fs.Declaration.Type); 105010"];
7271 [label="fs.Declaration.Type 105011"];
7272 [label="param CSharpSyntaxNode(GreenNode green) 105012"];
7273 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105013"];
7274 [label="param CSharpSyntaxNode(int position) 105014"];
7275 [label="param CSharpSyntaxNode(this) 105015"];
7276 [label="param CSharpSyntaxNode(this) 105016"];
7277 [label="CustomAssert.Equal('T', fs.Declaration.Type.ToString()); 105017"];
7278 [label="fs.Declaration.Type.ToString() 105018"];
7279 [label="param ToString(this) 105019"];
7280 [label="this.Identifier.Text 105020"];
7281 [label="get { return this.TextField; } 105021"];
7282 [label="return this.Identifier.Text; 105022"];
7283 [label="CustomAssert.Equal('T', fs.Declaration.Type.ToString()); 105023"];
7284 [label="CustomAssert.Equal(1, fs.Declaration.Variables.Count); 105024"];
7285 [label="CustomAssert.Equal(1, fs.Declaration.Variables.Count); 105025"];
7286 [label="fs.Declaration.Variables 105026"];
7287 [label="param CSharpSyntaxNode(GreenNode green) 105027"];
7288 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105028"];
7289 [label="param CSharpSyntaxNode(int position) 105029"];
7290 [label="param CSharpSyntaxNode(this) 105030"];
7291 [label="param CSharpSyntaxNode(this) 105031"];
7292 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Identifier); 105032"];
7293 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Identifier); 105033"];
7294 [label="fs.Declaration.Variables[0].Identifier 105034"];
7295 [label="=> true 105035"];
7296 [label="true 105036"];
7297 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Identifier); 105037"];
7298 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Identifier); 105038"];
7299 [label="CustomAssert.Equal('a', fs.Declaration.Variables[0].Identifier.ToString()); 105039"];
7300 [label="CustomAssert.Equal('a', fs.Declaration.Variables[0].Identifier.ToString()); 105040"];
7301 [label="fs.Declaration.Variables[0].Identifier 105041"];
7302 [label="=> true 105042"];
7303 [label="true 105043"];
7304 [label="CustomAssert.Equal('a', fs.Declaration.Variables[0].Identifier.ToString()); 105044"];
7305 [label="CustomAssert.Equal('a', fs.Declaration.Variables[0].Identifier.ToString()); 105045"];
7306 [label="param ToString(this) 105046"];
7307 [label="this.Text 105047"];
7308 [label="get { return this.TextField; } 105048"];
7309 [label="return this.Text; 105049"];
7310 [label="CustomAssert.NotNull(fs.Declaration.Variables[0].Initializer); 105050"];
7311 [label="CustomAssert.NotNull(fs.Declaration.Variables[0].Initializer); 105051"];
7312 [label="fs.Declaration.Variables[0].Initializer 105052"];
7313 [label="param CSharpSyntaxNode(GreenNode green) 105053"];
7314 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105054"];
7315 [label="param CSharpSyntaxNode(int position) 105055"];
7316 [label="param CSharpSyntaxNode(this) 105056"];
7317 [label="param CSharpSyntaxNode(this) 105057"];
7318 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Initializer.EqualsToken); 105058"];
7319 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Initializer.EqualsToken); 105059"];
7320 [label="fs.Declaration.Variables[0].Initializer.EqualsToken 105060"];
7321 [label="=> true 105061"];
7322 [label="true 105062"];
7323 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Initializer.EqualsToken); 105063"];
7324 [label="CustomAssert.NotEqual(default, fs.Declaration.Variables[0].Initializer.EqualsToken); 105064"];
7325 [label="CustomAssert.NotNull(fs.Declaration.Variables[0].Initializer.Value); 105065"];
7326 [label="CustomAssert.NotNull(fs.Declaration.Variables[0].Initializer.Value); 105066"];
7327 [label="fs.Declaration.Variables[0].Initializer.Value 105067"];
7328 [label="param CSharpSyntaxNode(GreenNode green) 105068"];
7329 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105069"];
7330 [label="param CSharpSyntaxNode(int position) 105070"];
7331 [label="param CSharpSyntaxNode(this) 105071"];
7332 [label="param CSharpSyntaxNode(this) 105072"];
7333 [label="CustomAssert.Equal('0', fs.Declaration.Variables[0].Initializer.Value.ToString()); 105073"];
7334 [label="CustomAssert.Equal('0', fs.Declaration.Variables[0].Initializer.Value.ToString()); 105074"];
7335 [label="=> true 105075"];
7336 [label="true 105076"];
7337 [label="param WriteTokenTo(bool leading) 105077"];
7338 [label="if (leading)\n            {\n                var trivia = this.GetLeadingTrivia();\n                if (trivia != null)\n                {\n                    trivia.WriteTo(writer, true, true);\n                }\n            } 105078"];
7339 [label="this.Text 105079"];
7340 [label="CustomAssert.Equal(0, fs.Initializers.Count); 105080"];
7341 [label="CustomAssert.Equal(0, fs.Initializers.Count); 105081"];
7342 [label="CustomAssert.NotEqual(default, fs.FirstSemicolonToken); 105082"];
7343 [label="CustomAssert.NotEqual(default, fs.FirstSemicolonToken); 105083"];
7344 [label="fs.FirstSemicolonToken 105084"];
7345 [label="=> true 105085"];
7346 [label="true 105086"];
7347 [label="CustomAssert.NotEqual(default, fs.FirstSemicolonToken); 105087"];
7348 [label="CustomAssert.NotEqual(default, fs.FirstSemicolonToken); 105088"];
7349 [label="CustomAssert.Null(fs.Condition); 105089"];
7350 [label="CustomAssert.NotEqual(default, fs.SecondSemicolonToken); 105090"];
7351 [label="CustomAssert.NotEqual(default, fs.SecondSemicolonToken); 105091"];
7352 [label="fs.SecondSemicolonToken 105092"];
7353 [label="=> true 105093"];
7354 [label="true 105094"];
7355 [label="CustomAssert.NotEqual(default, fs.SecondSemicolonToken); 105095"];
7356 [label="CustomAssert.NotEqual(default, fs.SecondSemicolonToken); 105096"];
7357 [label="CustomAssert.Equal(0, fs.Incrementors.Count); 105097"];
7358 [label="CustomAssert.Equal(0, fs.Incrementors.Count); 105098"];
7359 [label="CustomAssert.NotEqual(default, fs.CloseParenToken); 105099"];
7360 [label="CustomAssert.NotEqual(default, fs.CloseParenToken); 105100"];
7361 [label="fs.CloseParenToken 105101"];
7362 [label="=> true 105102"];
7363 [label="true 105103"];
7364 [label="CustomAssert.NotEqual(default, fs.CloseParenToken); 105104"];
7365 [label="CustomAssert.NotEqual(default, fs.CloseParenToken); 105105"];
7366 [label="CustomAssert.NotNull(fs.Statement); 105106"];
7367 [label="fs.Statement 105107"];
7368 [label="param CSharpSyntaxNode(GreenNode green) 105108"];
7369 [label="param CSharpSyntaxNode(SyntaxNode? parent) 105109"];
7370 [label="param CSharpSyntaxNode(int position) 105110"];
7371 [label="param CSharpSyntaxNode(this) 105111"];
7372 [label="param CSharpSyntaxNode(this) 105112"];
2 -> 0;
2 -> 1;
3 -> 1;
5 -> 4;
7 -> 6;
9 -> 8;
11 -> 10;
13 -> 12;
15 -> 14;
17 -> 16;
19 -> 18;
21 -> 20;
23 -> 22;
25 -> 24;
27 -> 26;
29 -> 28;
31 -> 30;
33 -> 32;
35 -> 34;
37 -> 36;
39 -> 38;
41 -> 40;
42 -> 0;
43 -> 0;
44 -> 42;
44 -> 43;
44 -> 0;
45 -> 44;
46 -> 0;
47 -> 0;
48 -> 46;
48 -> 47;
48 -> 44;
49 -> 48;
50 -> 0;
51 -> 50;
52 -> 51;
52 -> 50;
53 -> 52;
55 -> 0;
56 -> 54;
56 -> 55;
57 -> 56;
58 -> 0;
59 -> 0;
60 -> 58;
60 -> 59;
60 -> 0;
61 -> 60;
62 -> 0;
63 -> 0;
64 -> 62;
64 -> 63;
64 -> 48;
65 -> 64;
66 -> 0;
67 -> 0;
68 -> 66;
68 -> 67;
68 -> 64;
69 -> 68;
70 -> 0;
71 -> 0;
72 -> 70;
72 -> 71;
72 -> 68;
73 -> 72;
74 -> 0;
75 -> 0;
76 -> 74;
76 -> 75;
76 -> 0;
77 -> 76;
78 -> 0;
79 -> 0;
80 -> 78;
80 -> 79;
80 -> 0;
81 -> 80;
82 -> 0;
83 -> 0;
84 -> 82;
84 -> 83;
84 -> 0;
85 -> 84;
86 -> 0;
87 -> 0;
88 -> 86;
88 -> 87;
88 -> 72;
89 -> 88;
90 -> 0;
91 -> 0;
92 -> 90;
92 -> 91;
92 -> 0;
93 -> 92;
95 -> 0;
96 -> 94;
96 -> 95;
97 -> 96;
98 -> 0;
99 -> 0;
100 -> 98;
100 -> 99;
100 -> 88;
101 -> 100;
102 -> 0;
103 -> 0;
104 -> 102;
104 -> 103;
104 -> 0;
105 -> 104;
106 -> 0;
107 -> 0;
108 -> 106;
108 -> 107;
108 -> 0;
109 -> 108;
110 -> 0;
111 -> 0;
112 -> 110;
112 -> 111;
112 -> 0;
113 -> 112;
114 -> 0;
115 -> 0;
116 -> 114;
116 -> 115;
116 -> 0;
117 -> 116;
118 -> 0;
119 -> 0;
120 -> 118;
120 -> 119;
120 -> 0;
121 -> 120;
122 -> 0;
123 -> 0;
124 -> 122;
124 -> 123;
124 -> 100;
125 -> 124;
126 -> 0;
127 -> 0;
128 -> 126;
128 -> 127;
128 -> 124;
129 -> 128;
130 -> 0;
131 -> 0;
132 -> 130;
132 -> 131;
132 -> 128;
133 -> 132;
134 -> 0;
135 -> 0;
136 -> 134;
136 -> 135;
136 -> 132;
137 -> 136;
138 -> 0;
139 -> 0;
140 -> 138;
140 -> 139;
140 -> 0;
141 -> 140;
142 -> 0;
143 -> 0;
144 -> 142;
144 -> 143;
144 -> 0;
145 -> 144;
146 -> 0;
147 -> 0;
148 -> 146;
148 -> 147;
148 -> 136;
149 -> 148;
150 -> 0;
151 -> 0;
152 -> 150;
152 -> 151;
152 -> 0;
153 -> 152;
154 -> 0;
155 -> 0;
156 -> 154;
156 -> 155;
156 -> 0;
157 -> 156;
158 -> 0;
159 -> 0;
160 -> 158;
160 -> 159;
160 -> 0;
161 -> 160;
162 -> 0;
163 -> 0;
164 -> 162;
164 -> 163;
164 -> 148;
165 -> 164;
166 -> 0;
167 -> 0;
168 -> 166;
168 -> 167;
168 -> 0;
169 -> 168;
170 -> 0;
171 -> 0;
172 -> 170;
172 -> 171;
172 -> 0;
173 -> 172;
175 -> 174;
177 -> 175;
177 -> 176;
178 -> 177;
180 -> 0;
180 -> 179;
181 -> 180;
181 -> 0;
182 -> 181;
184 -> 183;
186 -> 185;
188 -> 187;
190 -> 189;
191 -> 1;
192 -> 1;
193 -> 191;
193 -> 1;
194 -> 193;
194 -> 192;
195 -> 192;
196 -> 195;
197 -> 196;
198 -> 197;
199 -> 198;
199 -> 197;
200 -> 195;
200 -> 192;
201 -> 195;
201 -> 192;
202 -> 195;
202 -> 192;
203 -> 194;
203 -> 195;
203 -> 192;
204 -> 1;
204 -> 2;
204 -> 199;
204 -> 200;
204 -> 201;
204 -> 203;
205 -> 1;
206 -> 1;
207 -> 206;
207 -> 1;
208 -> 1;
209 -> 1;
210 -> 207;
210 -> 209;
211 -> 208;
211 -> 209;
212 -> 208;
212 -> 209;
213 -> 205;
213 -> 209;
215 -> 214;
216 -> 215;
218 -> 216;
218 -> 217;
219 -> 217;
220 -> 217;
221 -> 218;
221 -> 217;
222 -> 219;
222 -> 221;
223 -> 0;
223 -> 222;
224 -> 217;
225 -> 223;
225 -> 224;
225 -> 217;
227 -> 0;
227 -> 217;
228 -> 218;
228 -> 217;
229 -> 217;
230 -> 227;
230 -> 229;
231 -> 228;
231 -> 229;
232 -> 230;
232 -> 229;
233 -> 231;
233 -> 229;
234 -> 229;
235 -> 229;
236 -> 232;
236 -> 235;
237 -> 233;
237 -> 235;
238 -> 234;
238 -> 235;
239 -> 234;
239 -> 235;
240 -> 234;
240 -> 235;
241 -> 236;
241 -> 235;
242 -> 238;
242 -> 235;
243 -> 239;
243 -> 235;
245 -> 244;
246 -> 237;
246 -> 235;
247 -> 235;
248 -> 241;
248 -> 247;
249 -> 242;
249 -> 247;
250 -> 243;
250 -> 247;
251 -> 246;
251 -> 247;
252 -> 240;
252 -> 247;
253 -> 248;
253 -> 247;
254 -> 249;
254 -> 247;
255 -> 250;
255 -> 247;
256 -> 251;
256 -> 247;
257 -> 247;
258 -> 257;
258 -> 253;
258 -> 254;
258 -> 255;
258 -> 256;
258 -> 247;
259 -> 257;
259 -> 247;
260 -> 259;
260 -> 258;
260 -> 247;
261 -> 240;
261 -> 235;
262 -> 237;
262 -> 240;
262 -> 235;
263 -> 236;
263 -> 0;
263 -> 235;
264 -> 234;
264 -> 217;
265 -> 219;
265 -> 217;
266 -> 264;
266 -> 265;
267 -> 266;
270 -> 268;
270 -> 269;
271 -> 269;
272 -> 269;
273 -> 270;
273 -> 269;
274 -> 271;
274 -> 273;
275 -> 0;
275 -> 274;
276 -> 269;
277 -> 275;
277 -> 276;
277 -> 269;
278 -> 0;
278 -> 269;
279 -> 270;
279 -> 269;
280 -> 269;
281 -> 278;
281 -> 280;
282 -> 279;
282 -> 280;
283 -> 281;
283 -> 280;
284 -> 282;
284 -> 280;
285 -> 280;
286 -> 280;
287 -> 283;
287 -> 286;
288 -> 284;
288 -> 286;
289 -> 285;
289 -> 286;
290 -> 285;
290 -> 286;
291 -> 285;
291 -> 286;
292 -> 287;
292 -> 286;
293 -> 289;
293 -> 286;
294 -> 290;
294 -> 286;
295 -> 288;
295 -> 286;
296 -> 286;
297 -> 292;
297 -> 296;
298 -> 293;
298 -> 296;
299 -> 294;
299 -> 296;
300 -> 295;
300 -> 296;
301 -> 291;
301 -> 296;
302 -> 297;
302 -> 296;
303 -> 298;
303 -> 296;
304 -> 299;
304 -> 296;
305 -> 300;
305 -> 296;
306 -> 296;
307 -> 306;
307 -> 302;
307 -> 303;
307 -> 304;
307 -> 305;
307 -> 296;
308 -> 306;
308 -> 296;
309 -> 308;
309 -> 307;
309 -> 296;
310 -> 291;
310 -> 286;
311 -> 288;
311 -> 291;
311 -> 286;
312 -> 287;
312 -> 0;
312 -> 286;
313 -> 285;
313 -> 269;
314 -> 271;
314 -> 269;
315 -> 313;
315 -> 314;
316 -> 315;
319 -> 317;
319 -> 318;
320 -> 318;
321 -> 318;
322 -> 319;
322 -> 318;
323 -> 320;
323 -> 322;
324 -> 0;
324 -> 323;
325 -> 318;
326 -> 324;
326 -> 325;
326 -> 318;
327 -> 0;
327 -> 318;
328 -> 319;
328 -> 318;
329 -> 318;
330 -> 327;
330 -> 329;
331 -> 328;
331 -> 329;
332 -> 330;
332 -> 329;
333 -> 331;
333 -> 329;
334 -> 329;
335 -> 329;
336 -> 332;
336 -> 335;
337 -> 333;
337 -> 335;
338 -> 334;
338 -> 335;
339 -> 334;
339 -> 335;
340 -> 334;
340 -> 335;
341 -> 336;
341 -> 335;
342 -> 338;
342 -> 335;
343 -> 339;
343 -> 335;
344 -> 337;
344 -> 335;
345 -> 335;
346 -> 341;
346 -> 345;
347 -> 342;
347 -> 345;
348 -> 343;
348 -> 345;
349 -> 344;
349 -> 345;
350 -> 340;
350 -> 345;
351 -> 346;
351 -> 345;
352 -> 347;
352 -> 345;
353 -> 348;
353 -> 345;
354 -> 349;
354 -> 345;
355 -> 345;
356 -> 355;
356 -> 351;
356 -> 352;
356 -> 353;
356 -> 354;
356 -> 345;
357 -> 355;
357 -> 345;
358 -> 357;
358 -> 356;
358 -> 345;
359 -> 340;
359 -> 335;
360 -> 337;
360 -> 340;
360 -> 335;
361 -> 336;
361 -> 0;
361 -> 335;
362 -> 334;
362 -> 318;
363 -> 320;
363 -> 318;
364 -> 362;
364 -> 363;
365 -> 364;
368 -> 366;
368 -> 367;
369 -> 367;
370 -> 0;
370 -> 367;
371 -> 368;
371 -> 367;
372 -> 367;
373 -> 370;
373 -> 372;
374 -> 371;
374 -> 372;
375 -> 373;
375 -> 372;
376 -> 374;
376 -> 372;
377 -> 372;
378 -> 372;
379 -> 375;
379 -> 378;
380 -> 376;
380 -> 378;
381 -> 377;
381 -> 378;
382 -> 377;
382 -> 378;
383 -> 377;
383 -> 378;
384 -> 379;
384 -> 378;
385 -> 381;
385 -> 378;
386 -> 382;
386 -> 378;
387 -> 380;
387 -> 378;
388 -> 378;
389 -> 384;
389 -> 388;
390 -> 385;
390 -> 388;
391 -> 386;
391 -> 388;
392 -> 387;
392 -> 388;
393 -> 383;
393 -> 388;
394 -> 389;
394 -> 388;
395 -> 390;
395 -> 388;
396 -> 391;
396 -> 388;
397 -> 392;
397 -> 388;
398 -> 388;
399 -> 398;
399 -> 394;
399 -> 395;
399 -> 396;
399 -> 397;
399 -> 388;
400 -> 398;
400 -> 388;
401 -> 400;
401 -> 399;
401 -> 388;
402 -> 383;
402 -> 378;
403 -> 380;
403 -> 383;
403 -> 378;
404 -> 379;
404 -> 0;
404 -> 378;
405 -> 377;
405 -> 367;
406 -> 369;
406 -> 367;
407 -> 405;
407 -> 406;
408 -> 407;
411 -> 409;
411 -> 410;
412 -> 410;
413 -> 0;
413 -> 410;
414 -> 411;
414 -> 410;
415 -> 410;
416 -> 413;
416 -> 415;
417 -> 414;
417 -> 415;
418 -> 416;
418 -> 415;
419 -> 417;
419 -> 415;
420 -> 415;
421 -> 415;
422 -> 418;
422 -> 421;
423 -> 419;
423 -> 421;
424 -> 420;
424 -> 421;
425 -> 420;
425 -> 421;
426 -> 420;
426 -> 421;
427 -> 422;
427 -> 421;
428 -> 424;
428 -> 421;
429 -> 425;
429 -> 421;
430 -> 423;
430 -> 421;
431 -> 421;
432 -> 427;
432 -> 431;
433 -> 428;
433 -> 431;
434 -> 429;
434 -> 431;
435 -> 430;
435 -> 431;
436 -> 426;
436 -> 431;
437 -> 432;
437 -> 431;
438 -> 433;
438 -> 431;
439 -> 434;
439 -> 431;
440 -> 435;
440 -> 431;
441 -> 431;
442 -> 441;
442 -> 437;
442 -> 438;
442 -> 439;
442 -> 440;
442 -> 431;
443 -> 441;
443 -> 431;
444 -> 443;
444 -> 442;
444 -> 431;
445 -> 426;
445 -> 421;
446 -> 423;
446 -> 426;
446 -> 421;
447 -> 422;
447 -> 0;
447 -> 421;
448 -> 420;
448 -> 410;
449 -> 412;
449 -> 410;
450 -> 448;
450 -> 449;
451 -> 450;
452 -> 215;
454 -> 453;
456 -> 452;
456 -> 455;
457 -> 454;
457 -> 455;
458 -> 455;
459 -> 456;
459 -> 455;
460 -> 457;
460 -> 459;
461 -> 0;
461 -> 460;
462 -> 455;
463 -> 461;
463 -> 462;
463 -> 455;
464 -> 0;
464 -> 455;
465 -> 456;
465 -> 455;
466 -> 455;
467 -> 464;
467 -> 466;
468 -> 465;
468 -> 466;
469 -> 467;
469 -> 466;
470 -> 468;
470 -> 466;
471 -> 466;
472 -> 466;
473 -> 469;
473 -> 472;
474 -> 470;
474 -> 472;
475 -> 471;
475 -> 472;
476 -> 471;
476 -> 472;
477 -> 471;
477 -> 472;
478 -> 473;
478 -> 472;
479 -> 475;
479 -> 472;
480 -> 476;
480 -> 472;
481 -> 474;
481 -> 472;
482 -> 472;
483 -> 478;
483 -> 482;
484 -> 479;
484 -> 482;
485 -> 480;
485 -> 482;
486 -> 481;
486 -> 482;
487 -> 477;
487 -> 482;
488 -> 483;
488 -> 482;
489 -> 484;
489 -> 482;
490 -> 485;
490 -> 482;
491 -> 486;
491 -> 482;
492 -> 482;
493 -> 492;
493 -> 488;
493 -> 489;
493 -> 490;
493 -> 491;
493 -> 482;
494 -> 492;
494 -> 482;
495 -> 494;
495 -> 493;
495 -> 482;
496 -> 477;
496 -> 472;
497 -> 474;
497 -> 477;
497 -> 472;
498 -> 473;
498 -> 0;
498 -> 472;
499 -> 471;
499 -> 455;
500 -> 457;
500 -> 455;
501 -> 499;
501 -> 455;
502 -> 455;
503 -> 0;
503 -> 502;
503 -> 455;
504 -> 501;
504 -> 502;
504 -> 495;
504 -> 496;
504 -> 497;
504 -> 503;
504 -> 0;
504 -> 455;
505 -> 504;
505 -> 502;
506 -> 504;
506 -> 502;
507 -> 502;
508 -> 506;
508 -> 507;
509 -> 508;
509 -> 504;
509 -> 507;
510 -> 509;
510 -> 502;
511 -> 506;
511 -> 504;
511 -> 502;
512 -> 505;
512 -> 502;
513 -> 502;
514 -> 502;
515 -> 510;
515 -> 514;
516 -> 511;
516 -> 514;
517 -> 511;
517 -> 514;
518 -> 512;
518 -> 514;
519 -> 513;
519 -> 514;
520 -> 514;
521 -> 519;
521 -> 520;
522 -> 520;
523 -> 522;
523 -> 515;
523 -> 517;
523 -> 518;
523 -> 516;
523 -> 511;
523 -> 520;
524 -> 522;
524 -> 520;
525 -> 519;
525 -> 514;
526 -> 515;
526 -> 0;
526 -> 514;
527 -> 523;
530 -> 529;
532 -> 528;
532 -> 531;
533 -> 530;
533 -> 531;
534 -> 531;
535 -> 532;
535 -> 531;
536 -> 533;
536 -> 535;
537 -> 0;
537 -> 536;
538 -> 531;
539 -> 537;
539 -> 538;
539 -> 531;
540 -> 0;
540 -> 531;
541 -> 532;
541 -> 531;
542 -> 531;
543 -> 540;
543 -> 542;
544 -> 541;
544 -> 542;
545 -> 543;
545 -> 542;
546 -> 544;
546 -> 542;
547 -> 542;
548 -> 542;
549 -> 545;
549 -> 548;
550 -> 546;
550 -> 548;
551 -> 547;
551 -> 548;
552 -> 547;
552 -> 548;
553 -> 547;
553 -> 548;
554 -> 549;
554 -> 548;
555 -> 551;
555 -> 548;
556 -> 552;
556 -> 548;
557 -> 550;
557 -> 548;
558 -> 548;
559 -> 554;
559 -> 558;
560 -> 555;
560 -> 558;
561 -> 556;
561 -> 558;
562 -> 557;
562 -> 558;
563 -> 553;
563 -> 558;
564 -> 559;
564 -> 558;
565 -> 560;
565 -> 558;
566 -> 561;
566 -> 558;
567 -> 562;
567 -> 558;
568 -> 558;
569 -> 568;
569 -> 564;
569 -> 565;
569 -> 566;
569 -> 567;
569 -> 558;
570 -> 568;
570 -> 558;
571 -> 570;
571 -> 569;
571 -> 558;
572 -> 553;
572 -> 548;
573 -> 550;
573 -> 553;
573 -> 548;
574 -> 549;
574 -> 0;
574 -> 548;
575 -> 547;
575 -> 531;
576 -> 533;
576 -> 531;
577 -> 575;
577 -> 531;
578 -> 531;
579 -> 0;
579 -> 578;
579 -> 531;
580 -> 577;
580 -> 578;
580 -> 571;
580 -> 572;
580 -> 573;
580 -> 579;
580 -> 523;
580 -> 531;
581 -> 578;
582 -> 578;
583 -> 578;
584 -> 582;
584 -> 583;
585 -> 583;
586 -> 584;
586 -> 585;
587 -> 585;
588 -> 587;
588 -> 585;
589 -> 584;
589 -> 583;
590 -> 580;
590 -> 0;
590 -> 583;
591 -> 580;
594 -> 593;
596 -> 592;
596 -> 595;
597 -> 594;
597 -> 595;
598 -> 595;
599 -> 596;
599 -> 595;
600 -> 597;
600 -> 599;
601 -> 0;
601 -> 600;
602 -> 595;
603 -> 601;
603 -> 602;
603 -> 595;
604 -> 0;
604 -> 595;
605 -> 596;
605 -> 595;
606 -> 595;
607 -> 604;
607 -> 606;
608 -> 605;
608 -> 606;
609 -> 607;
609 -> 606;
610 -> 608;
610 -> 606;
611 -> 606;
612 -> 606;
613 -> 609;
613 -> 612;
614 -> 610;
614 -> 612;
615 -> 611;
615 -> 612;
616 -> 611;
616 -> 612;
617 -> 611;
617 -> 612;
618 -> 613;
618 -> 612;
619 -> 615;
619 -> 612;
620 -> 616;
620 -> 612;
621 -> 614;
621 -> 612;
622 -> 612;
623 -> 618;
623 -> 622;
624 -> 619;
624 -> 622;
625 -> 620;
625 -> 622;
626 -> 621;
626 -> 622;
627 -> 617;
627 -> 622;
628 -> 623;
628 -> 622;
629 -> 624;
629 -> 622;
630 -> 625;
630 -> 622;
631 -> 626;
631 -> 622;
632 -> 622;
633 -> 632;
633 -> 628;
633 -> 629;
633 -> 630;
633 -> 631;
633 -> 622;
634 -> 632;
634 -> 622;
635 -> 634;
635 -> 633;
635 -> 622;
636 -> 617;
636 -> 612;
637 -> 614;
637 -> 617;
637 -> 612;
638 -> 613;
638 -> 0;
638 -> 612;
639 -> 611;
639 -> 595;
640 -> 597;
640 -> 595;
641 -> 639;
641 -> 595;
642 -> 595;
643 -> 0;
643 -> 642;
643 -> 595;
644 -> 641;
644 -> 642;
644 -> 635;
644 -> 636;
644 -> 637;
644 -> 643;
644 -> 580;
644 -> 595;
645 -> 642;
646 -> 642;
647 -> 642;
648 -> 646;
648 -> 647;
649 -> 647;
650 -> 648;
650 -> 649;
651 -> 649;
652 -> 651;
652 -> 649;
653 -> 648;
653 -> 647;
654 -> 644;
654 -> 0;
654 -> 647;
655 -> 644;
658 -> 657;
660 -> 656;
660 -> 659;
661 -> 658;
661 -> 659;
662 -> 0;
662 -> 659;
663 -> 660;
663 -> 659;
664 -> 659;
665 -> 662;
665 -> 664;
666 -> 663;
666 -> 664;
667 -> 665;
667 -> 664;
668 -> 666;
668 -> 664;
669 -> 664;
670 -> 664;
671 -> 667;
671 -> 670;
672 -> 668;
672 -> 670;
673 -> 669;
673 -> 670;
674 -> 669;
674 -> 670;
675 -> 669;
675 -> 670;
676 -> 671;
676 -> 670;
677 -> 673;
677 -> 670;
678 -> 674;
678 -> 670;
679 -> 672;
679 -> 670;
680 -> 670;
681 -> 676;
681 -> 680;
682 -> 677;
682 -> 680;
683 -> 678;
683 -> 680;
684 -> 679;
684 -> 680;
685 -> 675;
685 -> 680;
686 -> 681;
686 -> 680;
687 -> 682;
687 -> 680;
688 -> 683;
688 -> 680;
689 -> 684;
689 -> 680;
690 -> 680;
691 -> 690;
691 -> 686;
691 -> 687;
691 -> 688;
691 -> 689;
691 -> 680;
692 -> 690;
692 -> 680;
693 -> 692;
693 -> 691;
693 -> 680;
694 -> 675;
694 -> 670;
695 -> 672;
695 -> 675;
695 -> 670;
696 -> 671;
696 -> 0;
696 -> 670;
697 -> 669;
697 -> 659;
698 -> 661;
698 -> 659;
699 -> 697;
699 -> 659;
700 -> 659;
701 -> 0;
701 -> 700;
701 -> 659;
702 -> 699;
702 -> 700;
702 -> 693;
702 -> 694;
702 -> 695;
702 -> 701;
702 -> 644;
702 -> 659;
703 -> 700;
704 -> 700;
705 -> 700;
706 -> 704;
706 -> 705;
707 -> 705;
708 -> 706;
708 -> 707;
709 -> 707;
710 -> 709;
710 -> 707;
711 -> 706;
711 -> 705;
712 -> 702;
712 -> 0;
712 -> 705;
713 -> 702;
716 -> 715;
718 -> 714;
718 -> 717;
719 -> 716;
719 -> 717;
720 -> 0;
720 -> 717;
721 -> 718;
721 -> 717;
722 -> 717;
723 -> 720;
723 -> 722;
724 -> 721;
724 -> 722;
725 -> 723;
725 -> 722;
726 -> 724;
726 -> 722;
727 -> 722;
728 -> 722;
729 -> 725;
729 -> 728;
730 -> 726;
730 -> 728;
731 -> 727;
731 -> 728;
732 -> 727;
732 -> 728;
733 -> 727;
733 -> 728;
734 -> 729;
734 -> 728;
735 -> 731;
735 -> 728;
736 -> 732;
736 -> 728;
737 -> 730;
737 -> 728;
738 -> 728;
739 -> 734;
739 -> 738;
740 -> 735;
740 -> 738;
741 -> 736;
741 -> 738;
742 -> 737;
742 -> 738;
743 -> 733;
743 -> 738;
744 -> 739;
744 -> 738;
745 -> 740;
745 -> 738;
746 -> 741;
746 -> 738;
747 -> 742;
747 -> 738;
748 -> 738;
749 -> 748;
749 -> 744;
749 -> 745;
749 -> 746;
749 -> 747;
749 -> 738;
750 -> 748;
750 -> 738;
751 -> 750;
751 -> 749;
751 -> 738;
752 -> 733;
752 -> 728;
753 -> 730;
753 -> 733;
753 -> 728;
754 -> 729;
754 -> 0;
754 -> 728;
755 -> 727;
755 -> 717;
756 -> 719;
756 -> 717;
757 -> 755;
757 -> 717;
758 -> 717;
759 -> 0;
759 -> 758;
759 -> 717;
760 -> 757;
760 -> 758;
760 -> 751;
760 -> 752;
760 -> 753;
760 -> 759;
760 -> 702;
760 -> 717;
761 -> 758;
762 -> 758;
763 -> 758;
764 -> 762;
764 -> 763;
765 -> 763;
766 -> 764;
766 -> 765;
767 -> 765;
768 -> 767;
768 -> 765;
769 -> 764;
769 -> 763;
770 -> 760;
770 -> 0;
770 -> 763;
771 -> 760;
772 -> 0;
774 -> 773;
776 -> 772;
776 -> 775;
777 -> 774;
777 -> 775;
778 -> 0;
778 -> 775;
779 -> 776;
779 -> 775;
780 -> 775;
781 -> 778;
781 -> 780;
782 -> 779;
782 -> 780;
783 -> 781;
783 -> 780;
784 -> 782;
784 -> 780;
785 -> 780;
786 -> 780;
787 -> 783;
787 -> 786;
788 -> 784;
788 -> 786;
789 -> 785;
789 -> 786;
790 -> 785;
790 -> 786;
791 -> 785;
791 -> 786;
792 -> 787;
792 -> 786;
793 -> 789;
793 -> 786;
794 -> 790;
794 -> 786;
795 -> 788;
795 -> 786;
796 -> 786;
797 -> 792;
797 -> 796;
798 -> 793;
798 -> 796;
799 -> 794;
799 -> 796;
800 -> 795;
800 -> 796;
801 -> 791;
801 -> 796;
802 -> 797;
802 -> 796;
803 -> 798;
803 -> 796;
804 -> 799;
804 -> 796;
805 -> 800;
805 -> 796;
806 -> 796;
807 -> 806;
807 -> 802;
807 -> 803;
807 -> 804;
807 -> 805;
807 -> 796;
808 -> 806;
808 -> 796;
809 -> 808;
809 -> 807;
809 -> 796;
810 -> 791;
810 -> 786;
811 -> 788;
811 -> 791;
811 -> 786;
812 -> 787;
812 -> 0;
812 -> 786;
813 -> 785;
813 -> 775;
814 -> 777;
814 -> 775;
815 -> 813;
815 -> 775;
816 -> 775;
817 -> 0;
817 -> 816;
817 -> 775;
818 -> 815;
818 -> 816;
818 -> 809;
818 -> 810;
818 -> 811;
818 -> 817;
818 -> 760;
818 -> 775;
819 -> 816;
820 -> 816;
821 -> 816;
822 -> 820;
822 -> 821;
823 -> 821;
824 -> 822;
824 -> 823;
825 -> 823;
826 -> 825;
826 -> 823;
827 -> 822;
827 -> 821;
828 -> 818;
828 -> 0;
828 -> 821;
829 -> 818;
832 -> 267;
832 -> 831;
833 -> 831;
834 -> 832;
834 -> 831;
835 -> 833;
835 -> 834;
835 -> 260;
835 -> 261;
835 -> 262;
835 -> 831;
837 -> 316;
837 -> 836;
838 -> 836;
839 -> 837;
839 -> 836;
840 -> 838;
840 -> 839;
840 -> 309;
840 -> 310;
840 -> 311;
840 -> 836;
842 -> 365;
842 -> 841;
843 -> 841;
844 -> 842;
844 -> 841;
845 -> 843;
845 -> 844;
845 -> 358;
845 -> 359;
845 -> 360;
845 -> 841;
847 -> 408;
847 -> 846;
848 -> 846;
849 -> 847;
849 -> 846;
850 -> 848;
850 -> 849;
850 -> 401;
850 -> 402;
850 -> 403;
850 -> 846;
852 -> 451;
852 -> 851;
853 -> 851;
854 -> 852;
854 -> 851;
855 -> 853;
855 -> 854;
855 -> 444;
855 -> 445;
855 -> 446;
855 -> 851;
857 -> 527;
857 -> 856;
858 -> 856;
859 -> 857;
859 -> 856;
860 -> 858;
860 -> 859;
860 -> 818;
860 -> 856;
862 -> 591;
862 -> 861;
863 -> 861;
864 -> 862;
864 -> 861;
865 -> 863;
865 -> 864;
865 -> 860;
865 -> 861;
867 -> 655;
867 -> 866;
868 -> 866;
869 -> 867;
869 -> 866;
870 -> 868;
870 -> 869;
870 -> 865;
870 -> 866;
872 -> 713;
872 -> 871;
873 -> 871;
874 -> 872;
874 -> 871;
875 -> 873;
875 -> 874;
875 -> 870;
875 -> 871;
877 -> 771;
877 -> 876;
878 -> 876;
879 -> 877;
879 -> 876;
880 -> 878;
880 -> 879;
880 -> 875;
880 -> 876;
882 -> 829;
882 -> 881;
883 -> 881;
884 -> 882;
884 -> 881;
885 -> 883;
885 -> 884;
885 -> 880;
885 -> 881;
886 -> 210;
886 -> 209;
887 -> 211;
887 -> 209;
888 -> 212;
888 -> 209;
889 -> 209;
890 -> 209;
891 -> 886;
891 -> 890;
892 -> 887;
892 -> 890;
893 -> 888;
893 -> 890;
894 -> 889;
894 -> 890;
895 -> 891;
895 -> 890;
896 -> 892;
896 -> 890;
897 -> 893;
897 -> 890;
898 -> 890;
899 -> 895;
899 -> 898;
900 -> 896;
900 -> 898;
901 -> 897;
901 -> 898;
902 -> 899;
902 -> 898;
903 -> 900;
903 -> 898;
904 -> 898;
905 -> 902;
905 -> 904;
906 -> 903;
906 -> 904;
907 -> 905;
907 -> 904;
908 -> 0;
908 -> 904;
909 -> 904;
910 -> 906;
910 -> 904;
911 -> 907;
911 -> 910;
911 -> 904;
913 -> 912;
914 -> 912;
915 -> 912;
916 -> 912;
917 -> 912;
918 -> 913;
918 -> 912;
919 -> 914;
919 -> 912;
920 -> 915;
920 -> 912;
921 -> 916;
921 -> 912;
922 -> 921;
922 -> 912;
923 -> 0;
923 -> 912;
924 -> 918;
924 -> 917;
925 -> 919;
925 -> 917;
926 -> 920;
926 -> 917;
927 -> 922;
927 -> 917;
928 -> 923;
928 -> 917;
929 -> 917;
930 -> 926;
930 -> 917;
931 -> 925;
931 -> 917;
932 -> 929;
932 -> 930;
932 -> 931;
932 -> 917;
933 -> 929;
933 -> 917;
934 -> 929;
934 -> 917;
935 -> 929;
935 -> 917;
936 -> 924;
936 -> 929;
936 -> 917;
937 -> 924;
937 -> 917;
938 -> 917;
939 -> 937;
939 -> 938;
940 -> 939;
940 -> 938;
941 -> 0;
941 -> 940;
942 -> 941;
942 -> 929;
942 -> 917;
943 -> 927;
943 -> 917;
944 -> 943;
944 -> 929;
944 -> 917;
945 -> 928;
945 -> 917;
946 -> 0;
946 -> 917;
947 -> 945;
947 -> 929;
947 -> 917;
948 -> 912;
950 -> 949;
953 -> 952;
955 -> 954;
966 -> 957;
966 -> 956;
967 -> 958;
967 -> 956;
968 -> 959;
968 -> 956;
969 -> 960;
969 -> 956;
970 -> 961;
970 -> 956;
971 -> 962;
971 -> 956;
972 -> 963;
972 -> 956;
973 -> 964;
973 -> 956;
974 -> 965;
974 -> 956;
975 -> 956;
977 -> 976;
978 -> 948;
978 -> 898;
979 -> 978;
979 -> 901;
979 -> 898;
980 -> 898;
981 -> 898;
982 -> 911;
982 -> 981;
983 -> 979;
983 -> 981;
984 -> 980;
984 -> 981;
985 -> 980;
985 -> 981;
986 -> 980;
986 -> 981;
987 -> 982;
987 -> 981;
988 -> 981;
989 -> 987;
989 -> 988;
990 -> 986;
990 -> 988;
991 -> 990;
991 -> 988;
992 -> 990;
992 -> 988;
993 -> 0;
995 -> 994;
997 -> 996;
998 -> 997;
999 -> 989;
999 -> 988;
1000 -> 988;
1001 -> 988;
1002 -> 999;
1002 -> 1001;
1003 -> 1000;
1003 -> 1001;
1004 -> 1003;
1004 -> 1001;
1005 -> 1003;
1005 -> 1001;
1006 -> 1003;
1006 -> 1001;
1007 -> 1003;
1007 -> 1001;
1008 -> 1003;
1008 -> 1001;
1009 -> 1003;
1009 -> 1001;
1010 -> 1003;
1010 -> 1001;
1011 -> 1003;
1011 -> 1001;
1012 -> 1002;
1012 -> 1003;
1012 -> 1001;
1013 -> 1001;
1014 -> 1013;
1014 -> 1003;
1014 -> 1001;
1015 -> 1001;
1016 -> 1015;
1016 -> 1003;
1016 -> 1001;
1017 -> 1002;
1017 -> 911;
1017 -> 1003;
1017 -> 1001;
1018 -> 1001;
1019 -> 1018;
1019 -> 1003;
1019 -> 1001;
1020 -> 998;
1020 -> 997;
1020 -> 1001;
1021 -> 1020;
1021 -> 1003;
1021 -> 1001;
1022 -> 1001;
1023 -> 1022;
1023 -> 1003;
1023 -> 1001;
1024 -> 1000;
1024 -> 990;
1024 -> 988;
1025 -> 986;
1025 -> 981;
1026 -> 986;
1026 -> 981;
1027 -> 986;
1027 -> 981;
1028 -> 986;
1028 -> 981;
1029 -> 986;
1029 -> 981;
1030 -> 986;
1030 -> 981;
1031 -> 986;
1031 -> 981;
1032 -> 986;
1032 -> 981;
1033 -> 986;
1033 -> 981;
1034 -> 986;
1034 -> 981;
1035 -> 981;
1036 -> 1035;
1036 -> 981;
1037 -> 1036;
1037 -> 986;
1037 -> 981;
1038 -> 981;
1039 -> 1038;
1039 -> 981;
1040 -> 1039;
1040 -> 986;
1040 -> 981;
1041 -> 986;
1041 -> 981;
1042 -> 986;
1042 -> 981;
1043 -> 981;
1044 -> 983;
1044 -> 1043;
1044 -> 981;
1045 -> 983;
1045 -> 986;
1045 -> 981;
1046 -> 981;
1047 -> 1046;
1047 -> 986;
1047 -> 981;
1048 -> 981;
1049 -> 1048;
1049 -> 986;
1049 -> 981;
1052 -> 1050;
1052 -> 1051;
1053 -> 1052;
1055 -> 1054;
1056 -> 981;
1057 -> 981;
1058 -> 1056;
1058 -> 1057;
1059 -> 1058;
1059 -> 1057;
1060 -> 1058;
1060 -> 1057;
1061 -> 1058;
1061 -> 1057;
1062 -> 1057;
1063 -> 1062;
1063 -> 1058;
1063 -> 1057;
1064 -> 1057;
1065 -> 1064;
1065 -> 1058;
1065 -> 1057;
1066 -> 1053;
1066 -> 1052;
1066 -> 1057;
1067 -> 1066;
1067 -> 1058;
1067 -> 1057;
1068 -> 1056;
1068 -> 986;
1068 -> 981;
1069 -> 986;
1069 -> 981;
1070 -> 984;
1070 -> 986;
1070 -> 981;
1071 -> 985;
1071 -> 986;
1071 -> 981;
1072 -> 980;
1072 -> 890;
1073 -> 1072;
1073 -> 890;
1074 -> 890;
1075 -> 1073;
1075 -> 1074;
1076 -> 0;
1077 -> 1075;
1077 -> 1074;
1078 -> 1074;
1079 -> 1074;
1080 -> 1077;
1080 -> 1079;
1081 -> 1078;
1081 -> 1079;
1082 -> 1078;
1082 -> 1079;
1083 -> 1078;
1083 -> 1079;
1084 -> 1078;
1084 -> 1079;
1085 -> 1078;
1085 -> 1079;
1088 -> 1086;
1088 -> 1087;
1089 -> 1088;
1090 -> 1080;
1090 -> 1079;
1091 -> 1083;
1091 -> 1079;
1092 -> 1081;
1092 -> 1079;
1093 -> 1082;
1093 -> 1079;
1094 -> 1079;
1095 -> 1079;
1096 -> 1084;
1096 -> 1079;
1097 -> 1079;
1098 -> 1090;
1098 -> 1097;
1099 -> 1091;
1099 -> 1097;
1100 -> 1092;
1100 -> 1097;
1101 -> 1093;
1101 -> 1097;
1102 -> 1094;
1102 -> 1097;
1103 -> 1095;
1103 -> 1097;
1104 -> 1096;
1104 -> 1097;
1105 -> 1085;
1105 -> 1097;
1106 -> 1105;
1106 -> 1097;
1107 -> 1105;
1107 -> 1097;
1108 -> 1105;
1108 -> 1097;
1109 -> 1105;
1109 -> 1097;
1110 -> 1105;
1110 -> 1097;
1111 -> 1105;
1111 -> 1097;
1112 -> 1105;
1112 -> 1097;
1113 -> 1105;
1113 -> 1097;
1114 -> 1105;
1114 -> 1097;
1115 -> 1105;
1115 -> 1097;
1116 -> 1105;
1116 -> 1097;
1117 -> 1105;
1117 -> 1097;
1118 -> 1105;
1118 -> 1097;
1119 -> 1098;
1119 -> 1105;
1119 -> 1097;
1120 -> 1099;
1120 -> 1105;
1120 -> 1097;
1121 -> 1102;
1121 -> 1105;
1121 -> 1097;
1122 -> 1104;
1122 -> 1105;
1122 -> 1097;
1123 -> 1097;
1124 -> 1123;
1124 -> 1105;
1124 -> 1097;
1125 -> 1097;
1126 -> 1100;
1126 -> 1125;
1126 -> 1097;
1127 -> 1126;
1127 -> 1105;
1127 -> 1097;
1128 -> 1097;
1129 -> 1105;
1129 -> 1128;
1130 -> 1129;
1130 -> 1127;
1130 -> 1128;
1131 -> 1130;
1131 -> 1097;
1132 -> 1131;
1132 -> 1102;
1132 -> 1097;
1133 -> 1132;
1134 -> 1133;
1134 -> 1105;
1134 -> 1132;
1135 -> 1132;
1136 -> 1135;
1136 -> 1105;
1136 -> 1132;
1137 -> 1097;
1138 -> 1105;
1138 -> 1137;
1139 -> 1138;
1139 -> 1127;
1139 -> 1137;
1140 -> 1139;
1140 -> 1097;
1141 -> 1103;
1141 -> 1140;
1141 -> 1097;
1142 -> 1141;
1142 -> 1104;
1142 -> 1078;
1142 -> 1097;
1143 -> 1142;
1144 -> 1105;
1144 -> 1143;
1145 -> 1143;
1146 -> 1143;
1147 -> 1144;
1147 -> 1119;
1147 -> 1024;
1147 -> 1146;
1148 -> 1147;
1148 -> 1012;
1148 -> 1146;
1149 -> 1148;
1149 -> 1143;
1150 -> 1149;
1150 -> 1143;
1151 -> 1150;
1151 -> 1144;
1151 -> 1143;
1152 -> 1144;
1152 -> 1119;
1152 -> 1143;
1153 -> 1144;
1153 -> 1120;
1153 -> 1143;
1154 -> 1143;
1155 -> 1154;
1155 -> 1149;
1155 -> 1143;
1156 -> 1153;
1156 -> 1155;
1157 -> 1155;
1158 -> 1156;
1158 -> 1157;
1159 -> 1152;
1159 -> 1157;
1160 -> 951;
1160 -> 1157;
1161 -> 1158;
1161 -> 1159;
1161 -> 1157;
1162 -> 1159;
1162 -> 1161;
1162 -> 1157;
1163 -> 1159;
1163 -> 1024;
1163 -> 992;
1163 -> 1045;
1163 -> 1161;
1163 -> 1047;
1163 -> 1049;
1163 -> 1029;
1163 -> 1068;
1163 -> 1070;
1163 -> 1071;
1163 -> 1033;
1163 -> 1034;
1163 -> 1037;
1163 -> 1040;
1163 -> 1041;
1163 -> 1069;
1163 -> 1012;
1163 -> 1014;
1163 -> 1016;
1163 -> 1017;
1163 -> 1021;
1163 -> 1009;
1163 -> 1023;
1163 -> 1019;
1163 -> 911;
1163 -> 1036;
1163 -> 1039;
1163 -> 932;
1163 -> 933;
1163 -> 947;
1163 -> 934;
1163 -> 942;
1163 -> 935;
1163 -> 936;
1163 -> 944;
1163 -> 945;
1163 -> 943;
1163 -> 1046;
1163 -> 1048;
1163 -> 1063;
1163 -> 1065;
1163 -> 1067;
1163 -> 1066;
1163 -> 1064;
1163 -> 1062;
1163 -> 1018;
1163 -> 1020;
1163 -> 1162;
1164 -> 1162;
1165 -> 1163;
1165 -> 1164;
1166 -> 1164;
1167 -> 1165;
1167 -> 1163;
1167 -> 1166;
1168 -> 1167;
1168 -> 1163;
1168 -> 1166;
1169 -> 1164;
1170 -> 1164;
1171 -> 1170;
1171 -> 1165;
1171 -> 1164;
1172 -> 1163;
1172 -> 1164;
1173 -> 1172;
1173 -> 1163;
1173 -> 1164;
1174 -> 1163;
1174 -> 1173;
1174 -> 1168;
1174 -> 1171;
1174 -> 1162;
1175 -> 1163;
1175 -> 1164;
1176 -> 1175;
1176 -> 1174;
1176 -> 1164;
1177 -> 1163;
1177 -> 1164;
1178 -> 1177;
1178 -> 1176;
1178 -> 1164;
1179 -> 1163;
1179 -> 1164;
1180 -> 1163;
1180 -> 1164;
1181 -> 1180;
1181 -> 1178;
1181 -> 1179;
1181 -> 1164;
1182 -> 1181;
1182 -> 1180;
1182 -> 1164;
1183 -> 1163;
1183 -> 1164;
1184 -> 1183;
1184 -> 1178;
1184 -> 1164;
1185 -> 1163;
1185 -> 1184;
1185 -> 1178;
1185 -> 1182;
1185 -> 1162;
1186 -> 1163;
1186 -> 1164;
1187 -> 1163;
1187 -> 1164;
1188 -> 1186;
1188 -> 1187;
1188 -> 1185;
1188 -> 1164;
1189 -> 1164;
1190 -> 1188;
1190 -> 1189;
1190 -> 1164;
1191 -> 1188;
1191 -> 1187;
1191 -> 1185;
1191 -> 1164;
1192 -> 1188;
1192 -> 1187;
1192 -> 1190;
1193 -> 1162;
1194 -> 1159;
1194 -> 1193;
1195 -> 1194;
1195 -> 1192;
1195 -> 1193;
1196 -> 1193;
1197 -> 1194;
1197 -> 1195;
1197 -> 1196;
1198 -> 1197;
1198 -> 1195;
1198 -> 1196;
1199 -> 1198;
1199 -> 1193;
1200 -> 1193;
1201 -> 1194;
1201 -> 1195;
1201 -> 1193;
1202 -> 1193;
1203 -> 1199;
1203 -> 1202;
1204 -> 1200;
1204 -> 1202;
1205 -> 1201;
1205 -> 1202;
1206 -> 1194;
1206 -> 1202;
1207 -> 1204;
1207 -> 1202;
1208 -> 1202;
1209 -> 1208;
1210 -> 1206;
1210 -> 1209;
1211 -> 1209;
1212 -> 1210;
1212 -> 1195;
1212 -> 1211;
1213 -> 1209;
1214 -> 1209;
1215 -> 1214;
1215 -> 1210;
1215 -> 1209;
1216 -> 1208;
1217 -> 1208;
1218 -> 1206;
1218 -> 1195;
1218 -> 1217;
1219 -> 1218;
1219 -> 1195;
1219 -> 1217;
1220 -> 1217;
1221 -> 1218;
1221 -> 1220;
1222 -> 1221;
1222 -> 1195;
1222 -> 1220;
1223 -> 1222;
1224 -> 1221;
1224 -> 1223;
1225 -> 1224;
1225 -> 1195;
1225 -> 1223;
1226 -> 1225;
1226 -> 1222;
1227 -> 1222;
1228 -> 1221;
1228 -> 1195;
1228 -> 1212;
1228 -> 1227;
1228 -> 1222;
1229 -> 1221;
1229 -> 1195;
1229 -> 1212;
1229 -> 1215;
1229 -> 1222;
1230 -> 1221;
1230 -> 1195;
1230 -> 1222;
1231 -> 1221;
1231 -> 1195;
1231 -> 1212;
1231 -> 1215;
1231 -> 1222;
1232 -> 1221;
1232 -> 1195;
1232 -> 1222;
1233 -> 1231;
1233 -> 1222;
1234 -> 1221;
1234 -> 1233;
1234 -> 1231;
1234 -> 1222;
1235 -> 1234;
1235 -> 1221;
1235 -> 1222;
1236 -> 1222;
1237 -> 1231;
1237 -> 1236;
1237 -> 1222;
1238 -> 1237;
1238 -> 1217;
1239 -> 1218;
1239 -> 1233;
1239 -> 1235;
1239 -> 1217;
1240 -> 1239;
1240 -> 1208;
1241 -> 1208;
1242 -> 1240;
1242 -> 1241;
1242 -> 1208;
1243 -> 1242;
1244 -> 1240;
1244 -> 1208;
1245 -> 1244;
1246 -> 1194;
1246 -> 1233;
1246 -> 1205;
1246 -> 1193;
1247 -> 1193;
1248 -> 1193;
1249 -> 1194;
1249 -> 1248;
1250 -> 1248;
1251 -> 1249;
1251 -> 1233;
1251 -> 1250;
1252 -> 1248;
1253 -> 1248;
1254 -> 1253;
1254 -> 1249;
1254 -> 1248;
1255 -> 1193;
1256 -> 1247;
1256 -> 1193;
1257 -> 1256;
1257 -> 1194;
1257 -> 1233;
1257 -> 1235;
1257 -> 1205;
1257 -> 1251;
1257 -> 1254;
1257 -> 1247;
1257 -> 1193;
1258 -> 1193;
1259 -> 1257;
1259 -> 1258;
1260 -> 1259;
1260 -> 1257;
1260 -> 1258;
1261 -> 1257;
1261 -> 1260;
1261 -> 1258;
1262 -> 1257;
1262 -> 1260;
1262 -> 1258;
1263 -> 1257;
1263 -> 1258;
1264 -> 1257;
1264 -> 1258;
1265 -> 0;
1265 -> 1263;
1265 -> 1258;
1266 -> 1263;
1266 -> 1258;
1267 -> 1258;
1268 -> 1266;
1268 -> 1267;
1269 -> 1264;
1269 -> 1267;
1270 -> 1268;
1270 -> 1267;
1271 -> 1270;
1271 -> 1269;
1271 -> 1262;
1271 -> 1265;
1271 -> 1267;
1272 -> 1267;
1273 -> 1271;
1273 -> 1272;
1274 -> 1271;
1274 -> 1272;
1275 -> 1271;
1275 -> 1272;
1276 -> 1271;
1276 -> 1272;
1277 -> 1273;
1277 -> 1272;
1278 -> 1274;
1278 -> 1272;
1279 -> 1275;
1279 -> 1272;
1280 -> 1276;
1280 -> 1271;
1280 -> 1277;
1280 -> 1278;
1280 -> 1279;
1280 -> 1272;
1281 -> 1280;
1282 -> 0;
1282 -> 1281;
1283 -> 1281;
1284 -> 1282;
1284 -> 1283;
1285 -> 1264;
1285 -> 1283;
1286 -> 1285;
1286 -> 1280;
1286 -> 1283;
1287 -> 1283;
1288 -> 1286;
1288 -> 1287;
1289 -> 1288;
1289 -> 0;
1289 -> 1287;
1290 -> 1289;
1290 -> 1284;
1290 -> 1283;
1291 -> 1280;
1291 -> 1290;
1292 -> 1290;
1293 -> 1291;
1293 -> 1292;
1294 -> 1291;
1294 -> 1292;
1295 -> 1264;
1295 -> 1280;
1295 -> 1292;
1296 -> 1293;
1296 -> 1055;
1296 -> 1292;
1298 -> 1297;
1299 -> 1297;
1300 -> 1293;
1300 -> 1292;
1301 -> 1300;
1301 -> 1295;
1301 -> 1280;
1301 -> 1292;
1302 -> 1292;
1303 -> 1301;
1303 -> 1302;
1304 -> 1303;
1304 -> 1302;
1305 -> 0;
1305 -> 1304;
1306 -> 1305;
1306 -> 0;
1306 -> 1292;
1307 -> 1280;
1307 -> 1305;
1307 -> 1306;
1308 -> 1306;
1309 -> 1307;
1309 -> 1308;
1310 -> 1309;
1310 -> 1308;
1311 -> 1310;
1312 -> 1280;
1312 -> 1305;
1312 -> 0;
1312 -> 1281;
1313 -> 1280;
1314 -> 1280;
1314 -> 1313;
1314 -> 1305;
1314 -> 1193;
1315 -> 1246;
1315 -> 1193;
1316 -> 1193;
1317 -> 1315;
1317 -> 1316;
1318 -> 1316;
1319 -> 1316;
1320 -> 1317;
1320 -> 1319;
1320 -> 1316;
1321 -> 1320;
1322 -> 1321;
1322 -> 1317;
1322 -> 1314;
1322 -> 1320;
1323 -> 1318;
1323 -> 1316;
1324 -> 1323;
1324 -> 1193;
1325 -> 1193;
1326 -> 1324;
1326 -> 1325;
1327 -> 1194;
1327 -> 1325;
1328 -> 1325;
1329 -> 1327;
1329 -> 1314;
1329 -> 1328;
1329 -> 1325;
1330 -> 1329;
1331 -> 1330;
1331 -> 1193;
1332 -> 1194;
1332 -> 1314;
1332 -> 1193;
1333 -> 1193;
1334 -> 1194;
1334 -> 1332;
1334 -> 1193;
1335 -> 1193;
1336 -> 1333;
1336 -> 1335;
1337 -> 1333;
1337 -> 1335;
1338 -> 1334;
1338 -> 1335;
1339 -> 1194;
1339 -> 1335;
1340 -> 1337;
1340 -> 1335;
1341 -> 1335;
1342 -> 1341;
1343 -> 1339;
1343 -> 1342;
1344 -> 1342;
1345 -> 1343;
1345 -> 1332;
1345 -> 1344;
1346 -> 1342;
1347 -> 1342;
1348 -> 1347;
1348 -> 1343;
1348 -> 1342;
1349 -> 1341;
1350 -> 1341;
1351 -> 1339;
1351 -> 1332;
1351 -> 1350;
1352 -> 1351;
1352 -> 1332;
1352 -> 1350;
1353 -> 1351;
1353 -> 1341;
1354 -> 1341;
1355 -> 1353;
1355 -> 1354;
1355 -> 1341;
1356 -> 1355;
1357 -> 1353;
1357 -> 1341;
1358 -> 1357;
1359 -> 1194;
1359 -> 1332;
1359 -> 1338;
1359 -> 1193;
1360 -> 1314;
1360 -> 1193;
1361 -> 1246;
1361 -> 1193;
1362 -> 1359;
1362 -> 1193;
1363 -> 1331;
1363 -> 1193;
1364 -> 1193;
1365 -> 1360;
1365 -> 1364;
1366 -> 1361;
1366 -> 1364;
1367 -> 1362;
1367 -> 1364;
1368 -> 1363;
1368 -> 1364;
1369 -> 1194;
1369 -> 1364;
1370 -> 1365;
1370 -> 1314;
1370 -> 0;
1370 -> 1364;
1371 -> 1366;
1371 -> 1332;
1371 -> 1345;
1371 -> 1348;
1371 -> 1338;
1371 -> 1364;
1372 -> 1367;
1372 -> 1371;
1372 -> 1364;
1373 -> 1364;
1374 -> 1365;
1374 -> 1314;
1374 -> 1364;
1375 -> 1365;
1375 -> 1314;
1375 -> 1374;
1376 -> 1365;
1376 -> 1314;
1376 -> 1375;
1377 -> 1375;
1378 -> 1376;
1378 -> 1377;
1379 -> 1378;
1379 -> 0;
1379 -> 1377;
1380 -> 1371;
1380 -> 1375;
1381 -> 1365;
1381 -> 1314;
1381 -> 1375;
1382 -> 1372;
1382 -> 1375;
1383 -> 1375;
1384 -> 1380;
1384 -> 1383;
1385 -> 1381;
1385 -> 1383;
1386 -> 1382;
1386 -> 1383;
1387 -> 0;
1388 -> 0;
1390 -> 1388;
1390 -> 1389;
1391 -> 1390;
1392 -> 1391;
1394 -> 1388;
1394 -> 1393;
1395 -> 1394;
1396 -> 1395;
1398 -> 1388;
1398 -> 1397;
1399 -> 1398;
1400 -> 1399;
1402 -> 1388;
1402 -> 1401;
1403 -> 1402;
1404 -> 1403;
1406 -> 1387;
1407 -> 1406;
1407 -> 1388;
1408 -> 1392;
1408 -> 1391;
1408 -> 1406;
1408 -> 1407;
1409 -> 1406;
1409 -> 1407;
1410 -> 1407;
1411 -> 1407;
1412 -> 1409;
1412 -> 1411;
1413 -> 1410;
1413 -> 1411;
1414 -> 1412;
1414 -> 1411;
1415 -> 1411;
1416 -> 1414;
1416 -> 1415;
1417 -> 1413;
1417 -> 1415;
1418 -> 1416;
1418 -> 1415;
1419 -> 1415;
1420 -> 1419;
1420 -> 1418;
1420 -> 1415;
1421 -> 1419;
1421 -> 1415;
1422 -> 1421;
1422 -> 1420;
1422 -> 1415;
1423 -> 1411;
1424 -> 1413;
1424 -> 1423;
1425 -> 1423;
1426 -> 1424;
1426 -> 1425;
1427 -> 1426;
1427 -> 1422;
1427 -> 1425;
1428 -> 1427;
1428 -> 1423;
1429 -> 1423;
1430 -> 1428;
1430 -> 1429;
1431 -> 1430;
1431 -> 1429;
1432 -> 1431;
1433 -> 1432;
1433 -> 1411;
1434 -> 1433;
1434 -> 1413;
1434 -> 1411;
1435 -> 1413;
1435 -> 1422;
1435 -> 0;
1435 -> 1411;
1436 -> 1435;
1436 -> 1413;
1436 -> 1411;
1437 -> 1410;
1437 -> 1408;
1437 -> 1407;
1439 -> 1396;
1439 -> 1395;
1439 -> 1406;
1439 -> 1407;
1440 -> 1406;
1440 -> 1407;
1441 -> 829;
1441 -> 1407;
1442 -> 1407;
1443 -> 1407;
1444 -> 1440;
1444 -> 1443;
1445 -> 1441;
1445 -> 1443;
1446 -> 1441;
1446 -> 1443;
1447 -> 1442;
1447 -> 1443;
1448 -> 1444;
1448 -> 1443;
1449 -> 1443;
1450 -> 1448;
1450 -> 1449;
1451 -> 1447;
1451 -> 1449;
1452 -> 1450;
1452 -> 1449;
1453 -> 1449;
1454 -> 1452;
1454 -> 1453;
1455 -> 1451;
1455 -> 1453;
1456 -> 1454;
1456 -> 1453;
1457 -> 1453;
1458 -> 1457;
1458 -> 1456;
1458 -> 1453;
1459 -> 1457;
1459 -> 1453;
1460 -> 1459;
1460 -> 1458;
1460 -> 1453;
1461 -> 1449;
1462 -> 1451;
1462 -> 1461;
1463 -> 1461;
1464 -> 1462;
1464 -> 1463;
1465 -> 1464;
1465 -> 1460;
1465 -> 1463;
1466 -> 1465;
1466 -> 1461;
1467 -> 1461;
1468 -> 1466;
1468 -> 1467;
1469 -> 1468;
1469 -> 1467;
1470 -> 1469;
1471 -> 1470;
1471 -> 1449;
1472 -> 1471;
1472 -> 1451;
1472 -> 1449;
1473 -> 1451;
1473 -> 1460;
1473 -> 0;
1473 -> 1449;
1474 -> 1473;
1474 -> 1451;
1474 -> 1449;
1475 -> 1447;
1475 -> 1443;
1476 -> 1447;
1476 -> 1443;
1477 -> 1443;
1478 -> 1445;
1478 -> 1477;
1478 -> 1443;
1479 -> 1445;
1479 -> 1478;
1480 -> 1447;
1480 -> 1479;
1480 -> 1460;
1480 -> 1472;
1480 -> 1474;
1480 -> 1475;
1480 -> 1476;
1480 -> 885;
1480 -> 1478;
1481 -> 1445;
1481 -> 1447;
1481 -> 1478;
1482 -> 1443;
1483 -> 1446;
1483 -> 1482;
1483 -> 1443;
1484 -> 1446;
1484 -> 1483;
1485 -> 1447;
1485 -> 1484;
1485 -> 1480;
1485 -> 1481;
1485 -> 1483;
1486 -> 1446;
1486 -> 1447;
1486 -> 1483;
1487 -> 1442;
1487 -> 1439;
1487 -> 1407;
1488 -> 1400;
1488 -> 1399;
1488 -> 1406;
1488 -> 1407;
1489 -> 1406;
1489 -> 1407;
1490 -> 1407;
1491 -> 408;
1491 -> 1407;
1492 -> 1407;
1493 -> 1489;
1493 -> 1492;
1494 -> 1490;
1494 -> 1492;
1495 -> 1491;
1495 -> 1492;
1496 -> 1490;
1496 -> 1492;
1497 -> 1493;
1497 -> 1492;
1498 -> 1492;
1499 -> 1497;
1499 -> 1498;
1500 -> 1496;
1500 -> 1498;
1501 -> 1499;
1501 -> 1498;
1502 -> 1498;
1503 -> 1501;
1503 -> 1502;
1504 -> 1500;
1504 -> 1502;
1505 -> 1503;
1505 -> 1502;
1506 -> 1502;
1507 -> 1506;
1507 -> 1505;
1507 -> 1502;
1508 -> 1506;
1508 -> 1502;
1509 -> 1508;
1509 -> 1507;
1509 -> 1502;
1510 -> 1498;
1511 -> 1500;
1511 -> 1510;
1512 -> 1510;
1513 -> 1511;
1513 -> 1512;
1514 -> 1513;
1514 -> 1509;
1514 -> 1512;
1515 -> 1514;
1515 -> 1510;
1516 -> 1510;
1517 -> 1515;
1517 -> 1516;
1518 -> 1517;
1518 -> 1516;
1519 -> 1518;
1520 -> 1519;
1520 -> 1498;
1521 -> 1520;
1521 -> 1500;
1521 -> 1498;
1522 -> 1500;
1522 -> 1509;
1522 -> 0;
1522 -> 1498;
1523 -> 1522;
1523 -> 1500;
1523 -> 1498;
1524 -> 1496;
1524 -> 1492;
1525 -> 1496;
1525 -> 1492;
1526 -> 1492;
1527 -> 1494;
1527 -> 1526;
1527 -> 1492;
1528 -> 1492;
1529 -> 1495;
1529 -> 1528;
1529 -> 1492;
1530 -> 1495;
1530 -> 1529;
1531 -> 1496;
1531 -> 1530;
1531 -> 1509;
1531 -> 1521;
1531 -> 1523;
1531 -> 1524;
1531 -> 1525;
1531 -> 850;
1531 -> 1529;
1532 -> 1495;
1532 -> 1496;
1532 -> 1529;
1533 -> 1490;
1533 -> 1488;
1533 -> 1407;
1534 -> 1404;
1534 -> 1403;
1534 -> 1406;
1534 -> 1407;
1535 -> 1406;
1535 -> 1407;
1536 -> 1407;
1537 -> 267;
1537 -> 1407;
1538 -> 1407;
1539 -> 1535;
1539 -> 1538;
1540 -> 1536;
1540 -> 1538;
1541 -> 1537;
1541 -> 1538;
1542 -> 1536;
1542 -> 1538;
1543 -> 1539;
1543 -> 1538;
1544 -> 1538;
1545 -> 1543;
1545 -> 1544;
1546 -> 1542;
1546 -> 1544;
1547 -> 1545;
1547 -> 1544;
1548 -> 1544;
1549 -> 1547;
1549 -> 1548;
1550 -> 1546;
1550 -> 1548;
1551 -> 1549;
1551 -> 1548;
1552 -> 1548;
1553 -> 1552;
1553 -> 1551;
1553 -> 1548;
1554 -> 1552;
1554 -> 1548;
1555 -> 1554;
1555 -> 1553;
1555 -> 1548;
1556 -> 1544;
1557 -> 1546;
1557 -> 1556;
1558 -> 1556;
1559 -> 1557;
1559 -> 1558;
1560 -> 1559;
1560 -> 1555;
1560 -> 1558;
1561 -> 1560;
1561 -> 1556;
1562 -> 1556;
1563 -> 1561;
1563 -> 1562;
1564 -> 1563;
1564 -> 1562;
1565 -> 1564;
1566 -> 1565;
1566 -> 1544;
1567 -> 1566;
1567 -> 1546;
1567 -> 1544;
1568 -> 1546;
1568 -> 1555;
1568 -> 0;
1568 -> 1544;
1569 -> 1568;
1569 -> 1546;
1569 -> 1544;
1570 -> 1542;
1570 -> 1538;
1571 -> 1542;
1571 -> 1538;
1572 -> 1538;
1573 -> 1540;
1573 -> 1572;
1573 -> 1538;
1574 -> 1538;
1575 -> 1541;
1575 -> 1574;
1575 -> 1538;
1576 -> 1541;
1576 -> 1575;
1577 -> 1542;
1577 -> 1576;
1577 -> 1555;
1577 -> 1567;
1577 -> 1569;
1577 -> 1570;
1577 -> 1571;
1577 -> 835;
1577 -> 1575;
1578 -> 1541;
1578 -> 1542;
1578 -> 1575;
1579 -> 1536;
1579 -> 1534;
1579 -> 1407;
1580 -> 1392;
1580 -> 1391;
1580 -> 1407;
1581 -> 1410;
1581 -> 1411;
1582 -> 1581;
1582 -> 1411;
1583 -> 1582;
1583 -> 1415;
1584 -> 1583;
1584 -> 1415;
1585 -> 1419;
1585 -> 1584;
1585 -> 1415;
1586 -> 1421;
1586 -> 1585;
1586 -> 1415;
1587 -> 1426;
1587 -> 1586;
1587 -> 1425;
1588 -> 1587;
1588 -> 1423;
1589 -> 1588;
1589 -> 1429;
1590 -> 1589;
1590 -> 1429;
1591 -> 1590;
1592 -> 1591;
1592 -> 1411;
1593 -> 1592;
1593 -> 1413;
1593 -> 1411;
1594 -> 1413;
1594 -> 1586;
1594 -> 0;
1594 -> 1411;
1595 -> 1594;
1595 -> 1413;
1595 -> 1411;
1596 -> 1410;
1596 -> 1580;
1596 -> 1407;
1597 -> 1396;
1597 -> 1395;
1597 -> 1407;
1598 -> 1442;
1598 -> 1443;
1599 -> 1598;
1599 -> 1443;
1600 -> 1599;
1600 -> 1449;
1601 -> 1600;
1601 -> 1449;
1602 -> 1601;
1602 -> 1453;
1603 -> 1602;
1603 -> 1453;
1604 -> 1457;
1604 -> 1603;
1604 -> 1453;
1605 -> 1459;
1605 -> 1604;
1605 -> 1453;
1606 -> 1464;
1606 -> 1605;
1606 -> 1463;
1607 -> 1606;
1607 -> 1461;
1608 -> 1607;
1608 -> 1467;
1609 -> 1608;
1609 -> 1467;
1610 -> 1609;
1611 -> 1610;
1611 -> 1449;
1612 -> 1611;
1612 -> 1451;
1612 -> 1449;
1613 -> 1451;
1613 -> 1605;
1613 -> 0;
1613 -> 1449;
1614 -> 1613;
1614 -> 1451;
1614 -> 1449;
1615 -> 1447;
1615 -> 1479;
1615 -> 1605;
1615 -> 1612;
1615 -> 1614;
1615 -> 1475;
1615 -> 1476;
1615 -> 1485;
1615 -> 1486;
1615 -> 1478;
1616 -> 1442;
1616 -> 1597;
1616 -> 1407;
1617 -> 1400;
1617 -> 1399;
1617 -> 1407;
1618 -> 1490;
1618 -> 1492;
1619 -> 1618;
1619 -> 1492;
1620 -> 1619;
1620 -> 1498;
1621 -> 1620;
1621 -> 1498;
1622 -> 1621;
1622 -> 1502;
1623 -> 1622;
1623 -> 1502;
1624 -> 1506;
1624 -> 1623;
1624 -> 1502;
1625 -> 1508;
1625 -> 1624;
1625 -> 1502;
1626 -> 1513;
1626 -> 1625;
1626 -> 1512;
1627 -> 1626;
1627 -> 1510;
1628 -> 1627;
1628 -> 1516;
1629 -> 1628;
1629 -> 1516;
1630 -> 1629;
1631 -> 1630;
1631 -> 1498;
1632 -> 1631;
1632 -> 1500;
1632 -> 1498;
1633 -> 1500;
1633 -> 1625;
1633 -> 0;
1633 -> 1498;
1634 -> 1633;
1634 -> 1500;
1634 -> 1498;
1635 -> 1496;
1635 -> 1530;
1635 -> 1625;
1635 -> 1632;
1635 -> 1634;
1635 -> 1524;
1635 -> 1525;
1635 -> 1531;
1635 -> 1532;
1635 -> 1529;
1636 -> 1490;
1636 -> 1617;
1636 -> 1407;
1637 -> 1404;
1637 -> 1403;
1637 -> 1407;
1638 -> 1536;
1638 -> 1538;
1639 -> 1638;
1639 -> 1538;
1640 -> 1639;
1640 -> 1544;
1641 -> 1640;
1641 -> 1544;
1642 -> 1641;
1642 -> 1548;
1643 -> 1642;
1643 -> 1548;
1644 -> 1552;
1644 -> 1643;
1644 -> 1548;
1645 -> 1554;
1645 -> 1644;
1645 -> 1548;
1646 -> 1559;
1646 -> 1645;
1646 -> 1558;
1647 -> 1646;
1647 -> 1556;
1648 -> 1647;
1648 -> 1562;
1649 -> 1648;
1649 -> 1562;
1650 -> 1649;
1651 -> 1650;
1651 -> 1544;
1652 -> 1651;
1652 -> 1546;
1652 -> 1544;
1653 -> 1546;
1653 -> 1645;
1653 -> 0;
1653 -> 1544;
1654 -> 1653;
1654 -> 1546;
1654 -> 1544;
1655 -> 1542;
1655 -> 1576;
1655 -> 1645;
1655 -> 1652;
1655 -> 1654;
1655 -> 1570;
1655 -> 1571;
1655 -> 1577;
1655 -> 1578;
1655 -> 1575;
1656 -> 1536;
1656 -> 1637;
1656 -> 1407;
1657 -> 1590;
1658 -> 1657;
1658 -> 1411;
1659 -> 1658;
1659 -> 1413;
1659 -> 1411;
1660 -> 1609;
1661 -> 1660;
1661 -> 1449;
1662 -> 1661;
1662 -> 1451;
1662 -> 1449;
1663 -> 1447;
1663 -> 1479;
1663 -> 1605;
1663 -> 1662;
1663 -> 1614;
1663 -> 1475;
1663 -> 1476;
1663 -> 1615;
1663 -> 1486;
1663 -> 1478;
1664 -> 1629;
1665 -> 1664;
1665 -> 1498;
1666 -> 1665;
1666 -> 1500;
1666 -> 1498;
1667 -> 1496;
1667 -> 1530;
1667 -> 1625;
1667 -> 1666;
1667 -> 1634;
1667 -> 1524;
1667 -> 1525;
1667 -> 1635;
1667 -> 1532;
1667 -> 1529;
1668 -> 1649;
1669 -> 1668;
1669 -> 1544;
1670 -> 1669;
1670 -> 1546;
1670 -> 1544;
1671 -> 1542;
1671 -> 1576;
1671 -> 1645;
1671 -> 1670;
1671 -> 1654;
1671 -> 1570;
1671 -> 1571;
1671 -> 1655;
1671 -> 1578;
1671 -> 1575;
1672 -> 1590;
1673 -> 1672;
1673 -> 1411;
1674 -> 1673;
1674 -> 1413;
1674 -> 1411;
1675 -> 1609;
1676 -> 1675;
1676 -> 1449;
1677 -> 1676;
1677 -> 1451;
1677 -> 1449;
1678 -> 1447;
1678 -> 1479;
1678 -> 1605;
1678 -> 1677;
1678 -> 1614;
1678 -> 1475;
1678 -> 1476;
1678 -> 1663;
1678 -> 1486;
1678 -> 1478;
1679 -> 1629;
1680 -> 1679;
1680 -> 1498;
1681 -> 1680;
1681 -> 1500;
1681 -> 1498;
1682 -> 1496;
1682 -> 1530;
1682 -> 1625;
1682 -> 1681;
1682 -> 1634;
1682 -> 1524;
1682 -> 1525;
1682 -> 1667;
1682 -> 1532;
1682 -> 1529;
1683 -> 1649;
1684 -> 1683;
1684 -> 1544;
1685 -> 1684;
1685 -> 1546;
1685 -> 1544;
1686 -> 1542;
1686 -> 1576;
1686 -> 1645;
1686 -> 1685;
1686 -> 1654;
1686 -> 1570;
1686 -> 1571;
1686 -> 1671;
1686 -> 1578;
1686 -> 1575;
1687 -> 1590;
1688 -> 1687;
1688 -> 1411;
1689 -> 1688;
1689 -> 1413;
1689 -> 1411;
1690 -> 1609;
1691 -> 1690;
1691 -> 1449;
1692 -> 1691;
1692 -> 1451;
1692 -> 1449;
1693 -> 1447;
1693 -> 1479;
1693 -> 1605;
1693 -> 1692;
1693 -> 1614;
1693 -> 1475;
1693 -> 1476;
1693 -> 1678;
1693 -> 1486;
1693 -> 1478;
1694 -> 1629;
1695 -> 1694;
1695 -> 1498;
1696 -> 1695;
1696 -> 1500;
1696 -> 1498;
1697 -> 1496;
1697 -> 1530;
1697 -> 1625;
1697 -> 1696;
1697 -> 1634;
1697 -> 1524;
1697 -> 1525;
1697 -> 1682;
1697 -> 1532;
1697 -> 1529;
1698 -> 1649;
1699 -> 1698;
1699 -> 1544;
1700 -> 1699;
1700 -> 1546;
1700 -> 1544;
1701 -> 1542;
1701 -> 1576;
1701 -> 1645;
1701 -> 1700;
1701 -> 1654;
1701 -> 1570;
1701 -> 1571;
1701 -> 1686;
1701 -> 1578;
1701 -> 1575;
1702 -> 1590;
1703 -> 1702;
1703 -> 1411;
1704 -> 1703;
1704 -> 1413;
1704 -> 1411;
1705 -> 1609;
1706 -> 1705;
1706 -> 1449;
1707 -> 1706;
1707 -> 1451;
1707 -> 1449;
1708 -> 1447;
1708 -> 1479;
1708 -> 1605;
1708 -> 1707;
1708 -> 1614;
1708 -> 1475;
1708 -> 1476;
1708 -> 1693;
1708 -> 1486;
1708 -> 1478;
1709 -> 1629;
1710 -> 1709;
1710 -> 1498;
1711 -> 1710;
1711 -> 1500;
1711 -> 1498;
1712 -> 1496;
1712 -> 1530;
1712 -> 1625;
1712 -> 1711;
1712 -> 1634;
1712 -> 1524;
1712 -> 1525;
1712 -> 1697;
1712 -> 1532;
1712 -> 1529;
1713 -> 1649;
1714 -> 1713;
1714 -> 1544;
1715 -> 1714;
1715 -> 1546;
1715 -> 1544;
1716 -> 1542;
1716 -> 1576;
1716 -> 1645;
1716 -> 1715;
1716 -> 1654;
1716 -> 1570;
1716 -> 1571;
1716 -> 1701;
1716 -> 1578;
1716 -> 1575;
1717 -> 1590;
1718 -> 1717;
1718 -> 1411;
1719 -> 1718;
1719 -> 1413;
1719 -> 1411;
1720 -> 1609;
1721 -> 1720;
1721 -> 1449;
1722 -> 1721;
1722 -> 1451;
1722 -> 1449;
1723 -> 1447;
1723 -> 1479;
1723 -> 1605;
1723 -> 1722;
1723 -> 1614;
1723 -> 1475;
1723 -> 1476;
1723 -> 1708;
1723 -> 1486;
1723 -> 1478;
1724 -> 1629;
1725 -> 1724;
1725 -> 1498;
1726 -> 1725;
1726 -> 1500;
1726 -> 1498;
1727 -> 1496;
1727 -> 1530;
1727 -> 1625;
1727 -> 1726;
1727 -> 1634;
1727 -> 1524;
1727 -> 1525;
1727 -> 1712;
1727 -> 1532;
1727 -> 1529;
1728 -> 1649;
1729 -> 1728;
1729 -> 1544;
1730 -> 1729;
1730 -> 1546;
1730 -> 1544;
1731 -> 1542;
1731 -> 1576;
1731 -> 1645;
1731 -> 1730;
1731 -> 1654;
1731 -> 1570;
1731 -> 1571;
1731 -> 1716;
1731 -> 1578;
1731 -> 1575;
1732 -> 1590;
1733 -> 1732;
1733 -> 1411;
1734 -> 1733;
1734 -> 1413;
1734 -> 1411;
1735 -> 1609;
1736 -> 1735;
1736 -> 1449;
1737 -> 1736;
1737 -> 1451;
1737 -> 1449;
1738 -> 1447;
1738 -> 1479;
1738 -> 1605;
1738 -> 1737;
1738 -> 1614;
1738 -> 1475;
1738 -> 1476;
1738 -> 1723;
1738 -> 1486;
1738 -> 1478;
1739 -> 1629;
1740 -> 1739;
1740 -> 1498;
1741 -> 1740;
1741 -> 1500;
1741 -> 1498;
1742 -> 1496;
1742 -> 1530;
1742 -> 1625;
1742 -> 1741;
1742 -> 1634;
1742 -> 1524;
1742 -> 1525;
1742 -> 1727;
1742 -> 1532;
1742 -> 1529;
1743 -> 1649;
1744 -> 1743;
1744 -> 1544;
1745 -> 1744;
1745 -> 1546;
1745 -> 1544;
1746 -> 1542;
1746 -> 1576;
1746 -> 1645;
1746 -> 1745;
1746 -> 1654;
1746 -> 1570;
1746 -> 1571;
1746 -> 1731;
1746 -> 1578;
1746 -> 1575;
1747 -> 1590;
1748 -> 1747;
1748 -> 1411;
1749 -> 1748;
1749 -> 1413;
1749 -> 1411;
1750 -> 1609;
1751 -> 1750;
1751 -> 1449;
1752 -> 1751;
1752 -> 1451;
1752 -> 1449;
1753 -> 1447;
1753 -> 1479;
1753 -> 1605;
1753 -> 1752;
1753 -> 1614;
1753 -> 1475;
1753 -> 1476;
1753 -> 1738;
1753 -> 1486;
1753 -> 1478;
1754 -> 1629;
1755 -> 1754;
1755 -> 1498;
1756 -> 1755;
1756 -> 1500;
1756 -> 1498;
1757 -> 1496;
1757 -> 1530;
1757 -> 1625;
1757 -> 1756;
1757 -> 1634;
1757 -> 1524;
1757 -> 1525;
1757 -> 1742;
1757 -> 1532;
1757 -> 1529;
1758 -> 1649;
1759 -> 1758;
1759 -> 1544;
1760 -> 1759;
1760 -> 1546;
1760 -> 1544;
1761 -> 1542;
1761 -> 1576;
1761 -> 1645;
1761 -> 1760;
1761 -> 1654;
1761 -> 1570;
1761 -> 1571;
1761 -> 1746;
1761 -> 1578;
1761 -> 1575;
1762 -> 1590;
1763 -> 1762;
1763 -> 1411;
1764 -> 1763;
1764 -> 1413;
1764 -> 1411;
1765 -> 1609;
1766 -> 1765;
1766 -> 1449;
1767 -> 1766;
1767 -> 1451;
1767 -> 1449;
1768 -> 1447;
1768 -> 1479;
1768 -> 1605;
1768 -> 1767;
1768 -> 1614;
1768 -> 1475;
1768 -> 1476;
1768 -> 1753;
1768 -> 1486;
1768 -> 1478;
1769 -> 1629;
1770 -> 1769;
1770 -> 1498;
1771 -> 1770;
1771 -> 1500;
1771 -> 1498;
1772 -> 1496;
1772 -> 1530;
1772 -> 1625;
1772 -> 1771;
1772 -> 1634;
1772 -> 1524;
1772 -> 1525;
1772 -> 1757;
1772 -> 1532;
1772 -> 1529;
1773 -> 1649;
1774 -> 1773;
1774 -> 1544;
1775 -> 1774;
1775 -> 1546;
1775 -> 1544;
1776 -> 1542;
1776 -> 1576;
1776 -> 1645;
1776 -> 1775;
1776 -> 1654;
1776 -> 1570;
1776 -> 1571;
1776 -> 1761;
1776 -> 1578;
1776 -> 1575;
1777 -> 1590;
1778 -> 1777;
1778 -> 1411;
1779 -> 1778;
1779 -> 1413;
1779 -> 1411;
1780 -> 1609;
1781 -> 1780;
1781 -> 1449;
1782 -> 1781;
1782 -> 1451;
1782 -> 1449;
1783 -> 1447;
1783 -> 1479;
1783 -> 1605;
1783 -> 1782;
1783 -> 1614;
1783 -> 1475;
1783 -> 1476;
1783 -> 1768;
1783 -> 1486;
1783 -> 1478;
1784 -> 1629;
1785 -> 1784;
1785 -> 1498;
1786 -> 1785;
1786 -> 1500;
1786 -> 1498;
1787 -> 1496;
1787 -> 1530;
1787 -> 1625;
1787 -> 1786;
1787 -> 1634;
1787 -> 1524;
1787 -> 1525;
1787 -> 1772;
1787 -> 1532;
1787 -> 1529;
1788 -> 1649;
1789 -> 1788;
1789 -> 1544;
1790 -> 1789;
1790 -> 1546;
1790 -> 1544;
1791 -> 1542;
1791 -> 1576;
1791 -> 1645;
1791 -> 1790;
1791 -> 1654;
1791 -> 1570;
1791 -> 1571;
1791 -> 1776;
1791 -> 1578;
1791 -> 1575;
1792 -> 1590;
1793 -> 1792;
1793 -> 1411;
1794 -> 1793;
1794 -> 1413;
1794 -> 1411;
1795 -> 1609;
1796 -> 1795;
1796 -> 1449;
1797 -> 1796;
1797 -> 1451;
1797 -> 1449;
1798 -> 1447;
1798 -> 1479;
1798 -> 1605;
1798 -> 1797;
1798 -> 1614;
1798 -> 1475;
1798 -> 1476;
1798 -> 1783;
1798 -> 1486;
1798 -> 1478;
1799 -> 1629;
1800 -> 1799;
1800 -> 1498;
1801 -> 1800;
1801 -> 1500;
1801 -> 1498;
1802 -> 1496;
1802 -> 1530;
1802 -> 1625;
1802 -> 1801;
1802 -> 1634;
1802 -> 1524;
1802 -> 1525;
1802 -> 1787;
1802 -> 1532;
1802 -> 1529;
1803 -> 1649;
1804 -> 1803;
1804 -> 1544;
1805 -> 1804;
1805 -> 1546;
1805 -> 1544;
1806 -> 1542;
1806 -> 1576;
1806 -> 1645;
1806 -> 1805;
1806 -> 1654;
1806 -> 1570;
1806 -> 1571;
1806 -> 1791;
1806 -> 1578;
1806 -> 1575;
1807 -> 1590;
1808 -> 1807;
1808 -> 1411;
1809 -> 1808;
1809 -> 1413;
1809 -> 1411;
1810 -> 1609;
1811 -> 1810;
1811 -> 1449;
1812 -> 1811;
1812 -> 1451;
1812 -> 1449;
1813 -> 1447;
1813 -> 1479;
1813 -> 1605;
1813 -> 1812;
1813 -> 1614;
1813 -> 1475;
1813 -> 1476;
1813 -> 1798;
1813 -> 1486;
1813 -> 1478;
1814 -> 1629;
1815 -> 1814;
1815 -> 1498;
1816 -> 1815;
1816 -> 1500;
1816 -> 1498;
1817 -> 1496;
1817 -> 1530;
1817 -> 1625;
1817 -> 1816;
1817 -> 1634;
1817 -> 1524;
1817 -> 1525;
1817 -> 1802;
1817 -> 1532;
1817 -> 1529;
1818 -> 1649;
1819 -> 1818;
1819 -> 1544;
1820 -> 1819;
1820 -> 1546;
1820 -> 1544;
1821 -> 1542;
1821 -> 1576;
1821 -> 1645;
1821 -> 1820;
1821 -> 1654;
1821 -> 1570;
1821 -> 1571;
1821 -> 1806;
1821 -> 1578;
1821 -> 1575;
1822 -> 1590;
1823 -> 1822;
1823 -> 1411;
1824 -> 1823;
1824 -> 1413;
1824 -> 1411;
1825 -> 1609;
1826 -> 1825;
1826 -> 1449;
1827 -> 1826;
1827 -> 1451;
1827 -> 1449;
1828 -> 1447;
1828 -> 1479;
1828 -> 1605;
1828 -> 1827;
1828 -> 1614;
1828 -> 1475;
1828 -> 1476;
1828 -> 1813;
1828 -> 1486;
1828 -> 1478;
1829 -> 1629;
1830 -> 1829;
1830 -> 1498;
1831 -> 1830;
1831 -> 1500;
1831 -> 1498;
1832 -> 1496;
1832 -> 1530;
1832 -> 1625;
1832 -> 1831;
1832 -> 1634;
1832 -> 1524;
1832 -> 1525;
1832 -> 1817;
1832 -> 1532;
1832 -> 1529;
1833 -> 1649;
1834 -> 1833;
1834 -> 1544;
1835 -> 1834;
1835 -> 1546;
1835 -> 1544;
1836 -> 1542;
1836 -> 1576;
1836 -> 1645;
1836 -> 1835;
1836 -> 1654;
1836 -> 1570;
1836 -> 1571;
1836 -> 1821;
1836 -> 1578;
1836 -> 1575;
1837 -> 1590;
1838 -> 1837;
1838 -> 1411;
1839 -> 1838;
1839 -> 1413;
1839 -> 1411;
1840 -> 1609;
1841 -> 1840;
1841 -> 1449;
1842 -> 1841;
1842 -> 1451;
1842 -> 1449;
1843 -> 1447;
1843 -> 1479;
1843 -> 1605;
1843 -> 1842;
1843 -> 1614;
1843 -> 1475;
1843 -> 1476;
1843 -> 1828;
1843 -> 1486;
1843 -> 1478;
1844 -> 1629;
1845 -> 1844;
1845 -> 1498;
1846 -> 1845;
1846 -> 1500;
1846 -> 1498;
1847 -> 1496;
1847 -> 1530;
1847 -> 1625;
1847 -> 1846;
1847 -> 1634;
1847 -> 1524;
1847 -> 1525;
1847 -> 1832;
1847 -> 1532;
1847 -> 1529;
1848 -> 1649;
1849 -> 1848;
1849 -> 1544;
1850 -> 1849;
1850 -> 1546;
1850 -> 1544;
1851 -> 1542;
1851 -> 1576;
1851 -> 1645;
1851 -> 1850;
1851 -> 1654;
1851 -> 1570;
1851 -> 1571;
1851 -> 1836;
1851 -> 1578;
1851 -> 1575;
1852 -> 1590;
1853 -> 1852;
1853 -> 1411;
1854 -> 1853;
1854 -> 1413;
1854 -> 1411;
1855 -> 1609;
1856 -> 1855;
1856 -> 1449;
1857 -> 1856;
1857 -> 1451;
1857 -> 1449;
1858 -> 1447;
1858 -> 1479;
1858 -> 1605;
1858 -> 1857;
1858 -> 1614;
1858 -> 1475;
1858 -> 1476;
1858 -> 1843;
1858 -> 1486;
1858 -> 1478;
1859 -> 1629;
1860 -> 1859;
1860 -> 1498;
1861 -> 1860;
1861 -> 1500;
1861 -> 1498;
1862 -> 1496;
1862 -> 1530;
1862 -> 1625;
1862 -> 1861;
1862 -> 1634;
1862 -> 1524;
1862 -> 1525;
1862 -> 1847;
1862 -> 1532;
1862 -> 1529;
1863 -> 1649;
1864 -> 1863;
1864 -> 1544;
1865 -> 1864;
1865 -> 1546;
1865 -> 1544;
1866 -> 1542;
1866 -> 1576;
1866 -> 1645;
1866 -> 1865;
1866 -> 1654;
1866 -> 1570;
1866 -> 1571;
1866 -> 1851;
1866 -> 1578;
1866 -> 1575;
1867 -> 1590;
1868 -> 1867;
1868 -> 1411;
1869 -> 1868;
1869 -> 1413;
1869 -> 1411;
1870 -> 1609;
1871 -> 1870;
1871 -> 1449;
1872 -> 1871;
1872 -> 1451;
1872 -> 1449;
1873 -> 1447;
1873 -> 1479;
1873 -> 1605;
1873 -> 1872;
1873 -> 1614;
1873 -> 1475;
1873 -> 1476;
1873 -> 1858;
1873 -> 1486;
1873 -> 1478;
1874 -> 1629;
1875 -> 1874;
1875 -> 1498;
1876 -> 1875;
1876 -> 1500;
1876 -> 1498;
1877 -> 1496;
1877 -> 1530;
1877 -> 1625;
1877 -> 1876;
1877 -> 1634;
1877 -> 1524;
1877 -> 1525;
1877 -> 1862;
1877 -> 1532;
1877 -> 1529;
1878 -> 1649;
1879 -> 1878;
1879 -> 1544;
1880 -> 1879;
1880 -> 1546;
1880 -> 1544;
1881 -> 1542;
1881 -> 1576;
1881 -> 1645;
1881 -> 1880;
1881 -> 1654;
1881 -> 1570;
1881 -> 1571;
1881 -> 1866;
1881 -> 1578;
1881 -> 1575;
1882 -> 1590;
1883 -> 1882;
1883 -> 1411;
1884 -> 1883;
1884 -> 1413;
1884 -> 1411;
1885 -> 1609;
1886 -> 1885;
1886 -> 1449;
1887 -> 1886;
1887 -> 1451;
1887 -> 1449;
1888 -> 1447;
1888 -> 1479;
1888 -> 1605;
1888 -> 1887;
1888 -> 1614;
1888 -> 1475;
1888 -> 1476;
1888 -> 1873;
1888 -> 1486;
1888 -> 1478;
1889 -> 1629;
1890 -> 1889;
1890 -> 1498;
1891 -> 1890;
1891 -> 1500;
1891 -> 1498;
1892 -> 1496;
1892 -> 1530;
1892 -> 1625;
1892 -> 1891;
1892 -> 1634;
1892 -> 1524;
1892 -> 1525;
1892 -> 1877;
1892 -> 1532;
1892 -> 1529;
1893 -> 1649;
1894 -> 1893;
1894 -> 1544;
1895 -> 1894;
1895 -> 1546;
1895 -> 1544;
1896 -> 1542;
1896 -> 1576;
1896 -> 1645;
1896 -> 1895;
1896 -> 1654;
1896 -> 1570;
1896 -> 1571;
1896 -> 1881;
1896 -> 1578;
1896 -> 1575;
1897 -> 1590;
1898 -> 1897;
1898 -> 1411;
1899 -> 1898;
1899 -> 1413;
1899 -> 1411;
1900 -> 1609;
1901 -> 1900;
1901 -> 1449;
1902 -> 1901;
1902 -> 1451;
1902 -> 1449;
1903 -> 1447;
1903 -> 1479;
1903 -> 1605;
1903 -> 1902;
1903 -> 1614;
1903 -> 1475;
1903 -> 1476;
1903 -> 1888;
1903 -> 1486;
1903 -> 1478;
1904 -> 1629;
1905 -> 1904;
1905 -> 1498;
1906 -> 1905;
1906 -> 1500;
1906 -> 1498;
1907 -> 1496;
1907 -> 1530;
1907 -> 1625;
1907 -> 1906;
1907 -> 1634;
1907 -> 1524;
1907 -> 1525;
1907 -> 1892;
1907 -> 1532;
1907 -> 1529;
1908 -> 1649;
1909 -> 1908;
1909 -> 1544;
1910 -> 1909;
1910 -> 1546;
1910 -> 1544;
1911 -> 1542;
1911 -> 1576;
1911 -> 1645;
1911 -> 1910;
1911 -> 1654;
1911 -> 1570;
1911 -> 1571;
1911 -> 1896;
1911 -> 1578;
1911 -> 1575;
1912 -> 1590;
1913 -> 1912;
1913 -> 1411;
1914 -> 1913;
1914 -> 1413;
1914 -> 1411;
1915 -> 1609;
1916 -> 1915;
1916 -> 1449;
1917 -> 1916;
1917 -> 1451;
1917 -> 1449;
1918 -> 1447;
1918 -> 1479;
1918 -> 1605;
1918 -> 1917;
1918 -> 1614;
1918 -> 1475;
1918 -> 1476;
1918 -> 1903;
1918 -> 1486;
1918 -> 1478;
1919 -> 1629;
1920 -> 1919;
1920 -> 1498;
1921 -> 1920;
1921 -> 1500;
1921 -> 1498;
1922 -> 1496;
1922 -> 1530;
1922 -> 1625;
1922 -> 1921;
1922 -> 1634;
1922 -> 1524;
1922 -> 1525;
1922 -> 1907;
1922 -> 1532;
1922 -> 1529;
1923 -> 1649;
1924 -> 1923;
1924 -> 1544;
1925 -> 1924;
1925 -> 1546;
1925 -> 1544;
1926 -> 1542;
1926 -> 1576;
1926 -> 1645;
1926 -> 1925;
1926 -> 1654;
1926 -> 1570;
1926 -> 1571;
1926 -> 1911;
1926 -> 1578;
1926 -> 1575;
1927 -> 1590;
1928 -> 1927;
1928 -> 1411;
1929 -> 1928;
1929 -> 1413;
1929 -> 1411;
1930 -> 1609;
1931 -> 1930;
1931 -> 1449;
1932 -> 1931;
1932 -> 1451;
1932 -> 1449;
1933 -> 1447;
1933 -> 1479;
1933 -> 1605;
1933 -> 1932;
1933 -> 1614;
1933 -> 1475;
1933 -> 1476;
1933 -> 1918;
1933 -> 1486;
1933 -> 1478;
1934 -> 1629;
1935 -> 1934;
1935 -> 1498;
1936 -> 1935;
1936 -> 1500;
1936 -> 1498;
1937 -> 1496;
1937 -> 1530;
1937 -> 1625;
1937 -> 1936;
1937 -> 1634;
1937 -> 1524;
1937 -> 1525;
1937 -> 1922;
1937 -> 1532;
1937 -> 1529;
1938 -> 1649;
1939 -> 1938;
1939 -> 1544;
1940 -> 1939;
1940 -> 1546;
1940 -> 1544;
1941 -> 1542;
1941 -> 1576;
1941 -> 1645;
1941 -> 1940;
1941 -> 1654;
1941 -> 1570;
1941 -> 1571;
1941 -> 1926;
1941 -> 1578;
1941 -> 1575;
1942 -> 1590;
1943 -> 1942;
1943 -> 1411;
1944 -> 1943;
1944 -> 1413;
1944 -> 1411;
1945 -> 1609;
1946 -> 1945;
1946 -> 1449;
1947 -> 1946;
1947 -> 1451;
1947 -> 1449;
1948 -> 1447;
1948 -> 1479;
1948 -> 1605;
1948 -> 1947;
1948 -> 1614;
1948 -> 1475;
1948 -> 1476;
1948 -> 1933;
1948 -> 1486;
1948 -> 1478;
1949 -> 1629;
1950 -> 1949;
1950 -> 1498;
1951 -> 1950;
1951 -> 1500;
1951 -> 1498;
1952 -> 1496;
1952 -> 1530;
1952 -> 1625;
1952 -> 1951;
1952 -> 1634;
1952 -> 1524;
1952 -> 1525;
1952 -> 1937;
1952 -> 1532;
1952 -> 1529;
1953 -> 1649;
1954 -> 1953;
1954 -> 1544;
1955 -> 1954;
1955 -> 1546;
1955 -> 1544;
1956 -> 1542;
1956 -> 1576;
1956 -> 1645;
1956 -> 1955;
1956 -> 1654;
1956 -> 1570;
1956 -> 1571;
1956 -> 1941;
1956 -> 1578;
1956 -> 1575;
1957 -> 1590;
1958 -> 1957;
1958 -> 1411;
1959 -> 1958;
1959 -> 1413;
1959 -> 1411;
1960 -> 1609;
1961 -> 1960;
1961 -> 1449;
1962 -> 1961;
1962 -> 1451;
1962 -> 1449;
1963 -> 1447;
1963 -> 1479;
1963 -> 1605;
1963 -> 1962;
1963 -> 1614;
1963 -> 1475;
1963 -> 1476;
1963 -> 1948;
1963 -> 1486;
1963 -> 1478;
1964 -> 1629;
1965 -> 1964;
1965 -> 1498;
1966 -> 1965;
1966 -> 1500;
1966 -> 1498;
1967 -> 1496;
1967 -> 1530;
1967 -> 1625;
1967 -> 1966;
1967 -> 1634;
1967 -> 1524;
1967 -> 1525;
1967 -> 1952;
1967 -> 1532;
1967 -> 1529;
1968 -> 1649;
1969 -> 1968;
1969 -> 1544;
1970 -> 1969;
1970 -> 1546;
1970 -> 1544;
1971 -> 1542;
1971 -> 1576;
1971 -> 1645;
1971 -> 1970;
1971 -> 1654;
1971 -> 1570;
1971 -> 1571;
1971 -> 1956;
1971 -> 1578;
1971 -> 1575;
1972 -> 1590;
1973 -> 1972;
1973 -> 1411;
1974 -> 1973;
1974 -> 1413;
1974 -> 1411;
1975 -> 1609;
1976 -> 1975;
1976 -> 1449;
1977 -> 1976;
1977 -> 1451;
1977 -> 1449;
1978 -> 1447;
1978 -> 1479;
1978 -> 1605;
1978 -> 1977;
1978 -> 1614;
1978 -> 1475;
1978 -> 1476;
1978 -> 1963;
1978 -> 1486;
1978 -> 1478;
1979 -> 1629;
1980 -> 1979;
1980 -> 1498;
1981 -> 1980;
1981 -> 1500;
1981 -> 1498;
1982 -> 1496;
1982 -> 1530;
1982 -> 1625;
1982 -> 1981;
1982 -> 1634;
1982 -> 1524;
1982 -> 1525;
1982 -> 1967;
1982 -> 1532;
1982 -> 1529;
1983 -> 1649;
1984 -> 1983;
1984 -> 1544;
1985 -> 1984;
1985 -> 1546;
1985 -> 1544;
1986 -> 1542;
1986 -> 1576;
1986 -> 1645;
1986 -> 1985;
1986 -> 1654;
1986 -> 1570;
1986 -> 1571;
1986 -> 1971;
1986 -> 1578;
1986 -> 1575;
1987 -> 1590;
1988 -> 1987;
1988 -> 1411;
1989 -> 1988;
1989 -> 1413;
1989 -> 1411;
1990 -> 1609;
1991 -> 1990;
1991 -> 1449;
1992 -> 1991;
1992 -> 1451;
1992 -> 1449;
1993 -> 1447;
1993 -> 1479;
1993 -> 1605;
1993 -> 1992;
1993 -> 1614;
1993 -> 1475;
1993 -> 1476;
1993 -> 1978;
1993 -> 1486;
1993 -> 1478;
1994 -> 1629;
1995 -> 1994;
1995 -> 1498;
1996 -> 1995;
1996 -> 1500;
1996 -> 1498;
1997 -> 1496;
1997 -> 1530;
1997 -> 1625;
1997 -> 1996;
1997 -> 1634;
1997 -> 1524;
1997 -> 1525;
1997 -> 1982;
1997 -> 1532;
1997 -> 1529;
1998 -> 1649;
1999 -> 1998;
1999 -> 1544;
2000 -> 1999;
2000 -> 1546;
2000 -> 1544;
2001 -> 1542;
2001 -> 1576;
2001 -> 1645;
2001 -> 2000;
2001 -> 1654;
2001 -> 1570;
2001 -> 1571;
2001 -> 1986;
2001 -> 1578;
2001 -> 1575;
2002 -> 1590;
2003 -> 2002;
2003 -> 1411;
2004 -> 2003;
2004 -> 1413;
2004 -> 1411;
2005 -> 1609;
2006 -> 2005;
2006 -> 1449;
2007 -> 2006;
2007 -> 1451;
2007 -> 1449;
2008 -> 1447;
2008 -> 1479;
2008 -> 1605;
2008 -> 2007;
2008 -> 1614;
2008 -> 1475;
2008 -> 1476;
2008 -> 1993;
2008 -> 1486;
2008 -> 1478;
2009 -> 1629;
2010 -> 2009;
2010 -> 1498;
2011 -> 2010;
2011 -> 1500;
2011 -> 1498;
2012 -> 1496;
2012 -> 1530;
2012 -> 1625;
2012 -> 2011;
2012 -> 1634;
2012 -> 1524;
2012 -> 1525;
2012 -> 1997;
2012 -> 1532;
2012 -> 1529;
2013 -> 1649;
2014 -> 2013;
2014 -> 1544;
2015 -> 2014;
2015 -> 1546;
2015 -> 1544;
2016 -> 1542;
2016 -> 1576;
2016 -> 1645;
2016 -> 2015;
2016 -> 1654;
2016 -> 1570;
2016 -> 1571;
2016 -> 2001;
2016 -> 1578;
2016 -> 1575;
2017 -> 1590;
2018 -> 2017;
2018 -> 1411;
2019 -> 2018;
2019 -> 1413;
2019 -> 1411;
2020 -> 1609;
2021 -> 2020;
2021 -> 1449;
2022 -> 2021;
2022 -> 1451;
2022 -> 1449;
2023 -> 1447;
2023 -> 1479;
2023 -> 1605;
2023 -> 2022;
2023 -> 1614;
2023 -> 1475;
2023 -> 1476;
2023 -> 2008;
2023 -> 1486;
2023 -> 1478;
2024 -> 1629;
2025 -> 2024;
2025 -> 1498;
2026 -> 2025;
2026 -> 1500;
2026 -> 1498;
2027 -> 1496;
2027 -> 1530;
2027 -> 1625;
2027 -> 2026;
2027 -> 1634;
2027 -> 1524;
2027 -> 1525;
2027 -> 2012;
2027 -> 1532;
2027 -> 1529;
2028 -> 1649;
2029 -> 2028;
2029 -> 1544;
2030 -> 2029;
2030 -> 1546;
2030 -> 1544;
2031 -> 1542;
2031 -> 1576;
2031 -> 1645;
2031 -> 2030;
2031 -> 1654;
2031 -> 1570;
2031 -> 1571;
2031 -> 2016;
2031 -> 1578;
2031 -> 1575;
2032 -> 1590;
2033 -> 2032;
2033 -> 1411;
2034 -> 2033;
2034 -> 1413;
2034 -> 1411;
2035 -> 1609;
2036 -> 2035;
2036 -> 1449;
2037 -> 2036;
2037 -> 1451;
2037 -> 1449;
2038 -> 1447;
2038 -> 1479;
2038 -> 1605;
2038 -> 2037;
2038 -> 1614;
2038 -> 1475;
2038 -> 1476;
2038 -> 2023;
2038 -> 1486;
2038 -> 1478;
2039 -> 1629;
2040 -> 2039;
2040 -> 1498;
2041 -> 2040;
2041 -> 1500;
2041 -> 1498;
2042 -> 1496;
2042 -> 1530;
2042 -> 1625;
2042 -> 2041;
2042 -> 1634;
2042 -> 1524;
2042 -> 1525;
2042 -> 2027;
2042 -> 1532;
2042 -> 1529;
2043 -> 1649;
2044 -> 2043;
2044 -> 1544;
2045 -> 2044;
2045 -> 1546;
2045 -> 1544;
2046 -> 1542;
2046 -> 1576;
2046 -> 1645;
2046 -> 2045;
2046 -> 1654;
2046 -> 1570;
2046 -> 1571;
2046 -> 2031;
2046 -> 1578;
2046 -> 1575;
2047 -> 1590;
2048 -> 2047;
2048 -> 1411;
2049 -> 2048;
2049 -> 1413;
2049 -> 1411;
2050 -> 1609;
2051 -> 2050;
2051 -> 1449;
2052 -> 2051;
2052 -> 1451;
2052 -> 1449;
2053 -> 1447;
2053 -> 1479;
2053 -> 1605;
2053 -> 2052;
2053 -> 1614;
2053 -> 1475;
2053 -> 1476;
2053 -> 2038;
2053 -> 1486;
2053 -> 1478;
2054 -> 1629;
2055 -> 2054;
2055 -> 1498;
2056 -> 2055;
2056 -> 1500;
2056 -> 1498;
2057 -> 1496;
2057 -> 1530;
2057 -> 1625;
2057 -> 2056;
2057 -> 1634;
2057 -> 1524;
2057 -> 1525;
2057 -> 2042;
2057 -> 1532;
2057 -> 1529;
2058 -> 1649;
2059 -> 2058;
2059 -> 1544;
2060 -> 2059;
2060 -> 1546;
2060 -> 1544;
2061 -> 1542;
2061 -> 1576;
2061 -> 1645;
2061 -> 2060;
2061 -> 1654;
2061 -> 1570;
2061 -> 1571;
2061 -> 2046;
2061 -> 1578;
2061 -> 1575;
2062 -> 1590;
2063 -> 2062;
2063 -> 1411;
2064 -> 2063;
2064 -> 1413;
2064 -> 1411;
2065 -> 1609;
2066 -> 2065;
2066 -> 1449;
2067 -> 2066;
2067 -> 1451;
2067 -> 1449;
2068 -> 1447;
2068 -> 1479;
2068 -> 1605;
2068 -> 2067;
2068 -> 1614;
2068 -> 1475;
2068 -> 1476;
2068 -> 2053;
2068 -> 1486;
2068 -> 1478;
2069 -> 1629;
2070 -> 2069;
2070 -> 1498;
2071 -> 2070;
2071 -> 1500;
2071 -> 1498;
2072 -> 1496;
2072 -> 1530;
2072 -> 1625;
2072 -> 2071;
2072 -> 1634;
2072 -> 1524;
2072 -> 1525;
2072 -> 2057;
2072 -> 1532;
2072 -> 1529;
2073 -> 1649;
2074 -> 2073;
2074 -> 1544;
2075 -> 2074;
2075 -> 1546;
2075 -> 1544;
2076 -> 1542;
2076 -> 1576;
2076 -> 1645;
2076 -> 2075;
2076 -> 1654;
2076 -> 1570;
2076 -> 1571;
2076 -> 2061;
2076 -> 1578;
2076 -> 1575;
2077 -> 0;
2077 -> 1590;
2078 -> 2077;
2078 -> 1411;
2079 -> 2078;
2079 -> 1413;
2079 -> 1411;
2080 -> 0;
2080 -> 1609;
2081 -> 2080;
2081 -> 1449;
2082 -> 2081;
2082 -> 1451;
2082 -> 1449;
2083 -> 1447;
2083 -> 1479;
2083 -> 1605;
2083 -> 2082;
2083 -> 1614;
2083 -> 1475;
2083 -> 1476;
2083 -> 2068;
2083 -> 1486;
2083 -> 1478;
2084 -> 0;
2084 -> 1629;
2085 -> 2084;
2085 -> 1498;
2086 -> 2085;
2086 -> 1500;
2086 -> 1498;
2087 -> 1496;
2087 -> 1530;
2087 -> 1625;
2087 -> 2086;
2087 -> 1634;
2087 -> 1524;
2087 -> 1525;
2087 -> 2072;
2087 -> 1532;
2087 -> 1529;
2088 -> 0;
2088 -> 1649;
2089 -> 2088;
2089 -> 1544;
2090 -> 2089;
2090 -> 1546;
2090 -> 1544;
2091 -> 1542;
2091 -> 1576;
2091 -> 1645;
2091 -> 2090;
2091 -> 1654;
2091 -> 1570;
2091 -> 1571;
2091 -> 2076;
2091 -> 1578;
2091 -> 1575;
2092 -> 1590;
2093 -> 2092;
2093 -> 1411;
2094 -> 2093;
2094 -> 1413;
2094 -> 1411;
2095 -> 1609;
2096 -> 2095;
2096 -> 1449;
2097 -> 2096;
2097 -> 1451;
2097 -> 1449;
2098 -> 1447;
2098 -> 1479;
2098 -> 1605;
2098 -> 2097;
2098 -> 1614;
2098 -> 1475;
2098 -> 1476;
2098 -> 2083;
2098 -> 1486;
2098 -> 1478;
2099 -> 1629;
2100 -> 2099;
2100 -> 1498;
2101 -> 2100;
2101 -> 1500;
2101 -> 1498;
2102 -> 1496;
2102 -> 1530;
2102 -> 1625;
2102 -> 2101;
2102 -> 1634;
2102 -> 1524;
2102 -> 1525;
2102 -> 2087;
2102 -> 1532;
2102 -> 1529;
2103 -> 1649;
2104 -> 2103;
2104 -> 1544;
2105 -> 2104;
2105 -> 1546;
2105 -> 1544;
2106 -> 1542;
2106 -> 1576;
2106 -> 1645;
2106 -> 2105;
2106 -> 1654;
2106 -> 1570;
2106 -> 1571;
2106 -> 2091;
2106 -> 1578;
2106 -> 1575;
2107 -> 1590;
2108 -> 2107;
2108 -> 1411;
2109 -> 2108;
2109 -> 1413;
2109 -> 1411;
2110 -> 1609;
2111 -> 2110;
2111 -> 1449;
2112 -> 2111;
2112 -> 1451;
2112 -> 1449;
2113 -> 1447;
2113 -> 1479;
2113 -> 1605;
2113 -> 2112;
2113 -> 1614;
2113 -> 1475;
2113 -> 1476;
2113 -> 2098;
2113 -> 1486;
2113 -> 1478;
2114 -> 1629;
2115 -> 2114;
2115 -> 1498;
2116 -> 2115;
2116 -> 1500;
2116 -> 1498;
2117 -> 1496;
2117 -> 1530;
2117 -> 1625;
2117 -> 2116;
2117 -> 1634;
2117 -> 1524;
2117 -> 1525;
2117 -> 2102;
2117 -> 1532;
2117 -> 1529;
2118 -> 1649;
2119 -> 2118;
2119 -> 1544;
2120 -> 2119;
2120 -> 1546;
2120 -> 1544;
2121 -> 1542;
2121 -> 1576;
2121 -> 1645;
2121 -> 2120;
2121 -> 1654;
2121 -> 1570;
2121 -> 1571;
2121 -> 2106;
2121 -> 1578;
2121 -> 1575;
2122 -> 1590;
2123 -> 2122;
2123 -> 1411;
2124 -> 2123;
2124 -> 1413;
2124 -> 1411;
2125 -> 1609;
2126 -> 2125;
2126 -> 1449;
2127 -> 2126;
2127 -> 1451;
2127 -> 1449;
2128 -> 1447;
2128 -> 1479;
2128 -> 1605;
2128 -> 2127;
2128 -> 1614;
2128 -> 1475;
2128 -> 1476;
2128 -> 2113;
2128 -> 1486;
2128 -> 1478;
2129 -> 1629;
2130 -> 2129;
2130 -> 1498;
2131 -> 2130;
2131 -> 1500;
2131 -> 1498;
2132 -> 1496;
2132 -> 1530;
2132 -> 1625;
2132 -> 2131;
2132 -> 1634;
2132 -> 1524;
2132 -> 1525;
2132 -> 2117;
2132 -> 1532;
2132 -> 1529;
2133 -> 1649;
2134 -> 2133;
2134 -> 1544;
2135 -> 2134;
2135 -> 1546;
2135 -> 1544;
2136 -> 1542;
2136 -> 1576;
2136 -> 1645;
2136 -> 2135;
2136 -> 1654;
2136 -> 1570;
2136 -> 1571;
2136 -> 2121;
2136 -> 1578;
2136 -> 1575;
2137 -> 1590;
2138 -> 2137;
2138 -> 1411;
2139 -> 2138;
2139 -> 1413;
2139 -> 1411;
2140 -> 1609;
2141 -> 2140;
2141 -> 1449;
2142 -> 2141;
2142 -> 1451;
2142 -> 1449;
2143 -> 1447;
2143 -> 1479;
2143 -> 1605;
2143 -> 2142;
2143 -> 1614;
2143 -> 1475;
2143 -> 1476;
2143 -> 2128;
2143 -> 1486;
2143 -> 1478;
2144 -> 1629;
2145 -> 2144;
2145 -> 1498;
2146 -> 2145;
2146 -> 1500;
2146 -> 1498;
2147 -> 1496;
2147 -> 1530;
2147 -> 1625;
2147 -> 2146;
2147 -> 1634;
2147 -> 1524;
2147 -> 1525;
2147 -> 2132;
2147 -> 1532;
2147 -> 1529;
2148 -> 1649;
2149 -> 2148;
2149 -> 1544;
2150 -> 2149;
2150 -> 1546;
2150 -> 1544;
2151 -> 1542;
2151 -> 1576;
2151 -> 1645;
2151 -> 2150;
2151 -> 1654;
2151 -> 1570;
2151 -> 1571;
2151 -> 2136;
2151 -> 1578;
2151 -> 1575;
2152 -> 1590;
2153 -> 2152;
2153 -> 1411;
2154 -> 2153;
2154 -> 1413;
2154 -> 1411;
2155 -> 1609;
2156 -> 2155;
2156 -> 1449;
2157 -> 2156;
2157 -> 1451;
2157 -> 1449;
2158 -> 1447;
2158 -> 1479;
2158 -> 1605;
2158 -> 2157;
2158 -> 1614;
2158 -> 1475;
2158 -> 1476;
2158 -> 2143;
2158 -> 1486;
2158 -> 1478;
2159 -> 1629;
2160 -> 2159;
2160 -> 1498;
2161 -> 2160;
2161 -> 1500;
2161 -> 1498;
2162 -> 1496;
2162 -> 1530;
2162 -> 1625;
2162 -> 2161;
2162 -> 1634;
2162 -> 1524;
2162 -> 1525;
2162 -> 2147;
2162 -> 1532;
2162 -> 1529;
2163 -> 1649;
2164 -> 2163;
2164 -> 1544;
2165 -> 2164;
2165 -> 1546;
2165 -> 1544;
2166 -> 1542;
2166 -> 1576;
2166 -> 1645;
2166 -> 2165;
2166 -> 1654;
2166 -> 1570;
2166 -> 1571;
2166 -> 2151;
2166 -> 1578;
2166 -> 1575;
2167 -> 1590;
2168 -> 2167;
2168 -> 1411;
2169 -> 2168;
2169 -> 1413;
2169 -> 1411;
2170 -> 1609;
2171 -> 2170;
2171 -> 1449;
2172 -> 2171;
2172 -> 1451;
2172 -> 1449;
2173 -> 1447;
2173 -> 1479;
2173 -> 1605;
2173 -> 2172;
2173 -> 1614;
2173 -> 1475;
2173 -> 1476;
2173 -> 2158;
2173 -> 1486;
2173 -> 1478;
2174 -> 1629;
2175 -> 2174;
2175 -> 1498;
2176 -> 2175;
2176 -> 1500;
2176 -> 1498;
2177 -> 1496;
2177 -> 1530;
2177 -> 1625;
2177 -> 2176;
2177 -> 1634;
2177 -> 1524;
2177 -> 1525;
2177 -> 2162;
2177 -> 1532;
2177 -> 1529;
2178 -> 1649;
2179 -> 2178;
2179 -> 1544;
2180 -> 2179;
2180 -> 1546;
2180 -> 1544;
2181 -> 1542;
2181 -> 1576;
2181 -> 1645;
2181 -> 2180;
2181 -> 1654;
2181 -> 1570;
2181 -> 1571;
2181 -> 2166;
2181 -> 1578;
2181 -> 1575;
2182 -> 1590;
2183 -> 2182;
2183 -> 1411;
2184 -> 2183;
2184 -> 1413;
2184 -> 1411;
2185 -> 1609;
2186 -> 2185;
2186 -> 1449;
2187 -> 2186;
2187 -> 1451;
2187 -> 1449;
2188 -> 1447;
2188 -> 1479;
2188 -> 1605;
2188 -> 2187;
2188 -> 1614;
2188 -> 1475;
2188 -> 1476;
2188 -> 2173;
2188 -> 1486;
2188 -> 1478;
2189 -> 1629;
2190 -> 2189;
2190 -> 1498;
2191 -> 2190;
2191 -> 1500;
2191 -> 1498;
2192 -> 1496;
2192 -> 1530;
2192 -> 1625;
2192 -> 2191;
2192 -> 1634;
2192 -> 1524;
2192 -> 1525;
2192 -> 2177;
2192 -> 1532;
2192 -> 1529;
2193 -> 1649;
2194 -> 2193;
2194 -> 1544;
2195 -> 2194;
2195 -> 1546;
2195 -> 1544;
2196 -> 1542;
2196 -> 1576;
2196 -> 1645;
2196 -> 2195;
2196 -> 1654;
2196 -> 1570;
2196 -> 1571;
2196 -> 2181;
2196 -> 1578;
2196 -> 1575;
2197 -> 1590;
2198 -> 2197;
2198 -> 1411;
2199 -> 2198;
2199 -> 1413;
2199 -> 1411;
2200 -> 1609;
2201 -> 2200;
2201 -> 1449;
2202 -> 2201;
2202 -> 1451;
2202 -> 1449;
2203 -> 1447;
2203 -> 1479;
2203 -> 1605;
2203 -> 2202;
2203 -> 1614;
2203 -> 1475;
2203 -> 1476;
2203 -> 2188;
2203 -> 1486;
2203 -> 1478;
2204 -> 1629;
2205 -> 2204;
2205 -> 1498;
2206 -> 2205;
2206 -> 1500;
2206 -> 1498;
2207 -> 1496;
2207 -> 1530;
2207 -> 1625;
2207 -> 2206;
2207 -> 1634;
2207 -> 1524;
2207 -> 1525;
2207 -> 2192;
2207 -> 1532;
2207 -> 1529;
2208 -> 1649;
2209 -> 2208;
2209 -> 1544;
2210 -> 2209;
2210 -> 1546;
2210 -> 1544;
2211 -> 1542;
2211 -> 1576;
2211 -> 1645;
2211 -> 2210;
2211 -> 1654;
2211 -> 1570;
2211 -> 1571;
2211 -> 2196;
2211 -> 1578;
2211 -> 1575;
2212 -> 1590;
2213 -> 2212;
2213 -> 1411;
2214 -> 2213;
2214 -> 1413;
2214 -> 1411;
2215 -> 1609;
2216 -> 2215;
2216 -> 1449;
2217 -> 2216;
2217 -> 1451;
2217 -> 1449;
2218 -> 1447;
2218 -> 1479;
2218 -> 1605;
2218 -> 2217;
2218 -> 1614;
2218 -> 1475;
2218 -> 1476;
2218 -> 2203;
2218 -> 1486;
2218 -> 1478;
2219 -> 1629;
2220 -> 2219;
2220 -> 1498;
2221 -> 2220;
2221 -> 1500;
2221 -> 1498;
2222 -> 1496;
2222 -> 1530;
2222 -> 1625;
2222 -> 2221;
2222 -> 1634;
2222 -> 1524;
2222 -> 1525;
2222 -> 2207;
2222 -> 1532;
2222 -> 1529;
2223 -> 1649;
2224 -> 2223;
2224 -> 1544;
2225 -> 2224;
2225 -> 1546;
2225 -> 1544;
2226 -> 1542;
2226 -> 1576;
2226 -> 1645;
2226 -> 2225;
2226 -> 1654;
2226 -> 1570;
2226 -> 1571;
2226 -> 2211;
2226 -> 1578;
2226 -> 1575;
2227 -> 1590;
2228 -> 2227;
2228 -> 1411;
2229 -> 2228;
2229 -> 1413;
2229 -> 1411;
2230 -> 1609;
2231 -> 2230;
2231 -> 1449;
2232 -> 2231;
2232 -> 1451;
2232 -> 1449;
2233 -> 1447;
2233 -> 1479;
2233 -> 1605;
2233 -> 2232;
2233 -> 1614;
2233 -> 1475;
2233 -> 1476;
2233 -> 2218;
2233 -> 1486;
2233 -> 1478;
2234 -> 1629;
2235 -> 2234;
2235 -> 1498;
2236 -> 2235;
2236 -> 1500;
2236 -> 1498;
2237 -> 1496;
2237 -> 1530;
2237 -> 1625;
2237 -> 2236;
2237 -> 1634;
2237 -> 1524;
2237 -> 1525;
2237 -> 2222;
2237 -> 1532;
2237 -> 1529;
2238 -> 1649;
2239 -> 2238;
2239 -> 1544;
2240 -> 2239;
2240 -> 1546;
2240 -> 1544;
2241 -> 1542;
2241 -> 1576;
2241 -> 1645;
2241 -> 2240;
2241 -> 1654;
2241 -> 1570;
2241 -> 1571;
2241 -> 2226;
2241 -> 1578;
2241 -> 1575;
2242 -> 1590;
2243 -> 2242;
2243 -> 1411;
2244 -> 2243;
2244 -> 1413;
2244 -> 1411;
2245 -> 1609;
2246 -> 2245;
2246 -> 1449;
2247 -> 2246;
2247 -> 1451;
2247 -> 1449;
2248 -> 1447;
2248 -> 1479;
2248 -> 1605;
2248 -> 2247;
2248 -> 1614;
2248 -> 1475;
2248 -> 1476;
2248 -> 2233;
2248 -> 1486;
2248 -> 1478;
2249 -> 1629;
2250 -> 2249;
2250 -> 1498;
2251 -> 2250;
2251 -> 1500;
2251 -> 1498;
2252 -> 1496;
2252 -> 1530;
2252 -> 1625;
2252 -> 2251;
2252 -> 1634;
2252 -> 1524;
2252 -> 1525;
2252 -> 2237;
2252 -> 1532;
2252 -> 1529;
2253 -> 1649;
2254 -> 2253;
2254 -> 1544;
2255 -> 2254;
2255 -> 1546;
2255 -> 1544;
2256 -> 1542;
2256 -> 1576;
2256 -> 1645;
2256 -> 2255;
2256 -> 1654;
2256 -> 1570;
2256 -> 1571;
2256 -> 2241;
2256 -> 1578;
2256 -> 1575;
2257 -> 1590;
2258 -> 2257;
2258 -> 1411;
2259 -> 2258;
2259 -> 1413;
2259 -> 1411;
2260 -> 1609;
2261 -> 2260;
2261 -> 1449;
2262 -> 2261;
2262 -> 1451;
2262 -> 1449;
2263 -> 1447;
2263 -> 1479;
2263 -> 1605;
2263 -> 2262;
2263 -> 1614;
2263 -> 1475;
2263 -> 1476;
2263 -> 2248;
2263 -> 1486;
2263 -> 1478;
2264 -> 1629;
2265 -> 2264;
2265 -> 1498;
2266 -> 2265;
2266 -> 1500;
2266 -> 1498;
2267 -> 1496;
2267 -> 1530;
2267 -> 1625;
2267 -> 2266;
2267 -> 1634;
2267 -> 1524;
2267 -> 1525;
2267 -> 2252;
2267 -> 1532;
2267 -> 1529;
2268 -> 1649;
2269 -> 2268;
2269 -> 1544;
2270 -> 2269;
2270 -> 1546;
2270 -> 1544;
2271 -> 1542;
2271 -> 1576;
2271 -> 1645;
2271 -> 2270;
2271 -> 1654;
2271 -> 1570;
2271 -> 1571;
2271 -> 2256;
2271 -> 1578;
2271 -> 1575;
2272 -> 1590;
2273 -> 2272;
2273 -> 1411;
2274 -> 2273;
2274 -> 1413;
2274 -> 1411;
2275 -> 1609;
2276 -> 2275;
2276 -> 1449;
2277 -> 2276;
2277 -> 1451;
2277 -> 1449;
2278 -> 1447;
2278 -> 1479;
2278 -> 1605;
2278 -> 2277;
2278 -> 1614;
2278 -> 1475;
2278 -> 1476;
2278 -> 2263;
2278 -> 1486;
2278 -> 1478;
2279 -> 1629;
2280 -> 2279;
2280 -> 1498;
2281 -> 2280;
2281 -> 1500;
2281 -> 1498;
2282 -> 1496;
2282 -> 1530;
2282 -> 1625;
2282 -> 2281;
2282 -> 1634;
2282 -> 1524;
2282 -> 1525;
2282 -> 2267;
2282 -> 1532;
2282 -> 1529;
2283 -> 1649;
2284 -> 2283;
2284 -> 1544;
2285 -> 2284;
2285 -> 1546;
2285 -> 1544;
2286 -> 1542;
2286 -> 1576;
2286 -> 1645;
2286 -> 2285;
2286 -> 1654;
2286 -> 1570;
2286 -> 1571;
2286 -> 2271;
2286 -> 1578;
2286 -> 1575;
2287 -> 1590;
2288 -> 2287;
2288 -> 1411;
2289 -> 2288;
2289 -> 1413;
2289 -> 1411;
2290 -> 1609;
2291 -> 2290;
2291 -> 1449;
2292 -> 2291;
2292 -> 1451;
2292 -> 1449;
2293 -> 1447;
2293 -> 1479;
2293 -> 1605;
2293 -> 2292;
2293 -> 1614;
2293 -> 1475;
2293 -> 1476;
2293 -> 2278;
2293 -> 1486;
2293 -> 1478;
2294 -> 1629;
2295 -> 2294;
2295 -> 1498;
2296 -> 2295;
2296 -> 1500;
2296 -> 1498;
2297 -> 1496;
2297 -> 1530;
2297 -> 1625;
2297 -> 2296;
2297 -> 1634;
2297 -> 1524;
2297 -> 1525;
2297 -> 2282;
2297 -> 1532;
2297 -> 1529;
2298 -> 1649;
2299 -> 2298;
2299 -> 1544;
2300 -> 2299;
2300 -> 1546;
2300 -> 1544;
2301 -> 1542;
2301 -> 1576;
2301 -> 1645;
2301 -> 2300;
2301 -> 1654;
2301 -> 1570;
2301 -> 1571;
2301 -> 2286;
2301 -> 1578;
2301 -> 1575;
2302 -> 1590;
2303 -> 2302;
2303 -> 1411;
2304 -> 2303;
2304 -> 1413;
2304 -> 1411;
2305 -> 1609;
2306 -> 2305;
2306 -> 1449;
2307 -> 2306;
2307 -> 1451;
2307 -> 1449;
2308 -> 1447;
2308 -> 1479;
2308 -> 1605;
2308 -> 2307;
2308 -> 1614;
2308 -> 1475;
2308 -> 1476;
2308 -> 2293;
2308 -> 1486;
2308 -> 1478;
2309 -> 1629;
2310 -> 2309;
2310 -> 1498;
2311 -> 2310;
2311 -> 1500;
2311 -> 1498;
2312 -> 1496;
2312 -> 1530;
2312 -> 1625;
2312 -> 2311;
2312 -> 1634;
2312 -> 1524;
2312 -> 1525;
2312 -> 2297;
2312 -> 1532;
2312 -> 1529;
2313 -> 1649;
2314 -> 2313;
2314 -> 1544;
2315 -> 2314;
2315 -> 1546;
2315 -> 1544;
2316 -> 1542;
2316 -> 1576;
2316 -> 1645;
2316 -> 2315;
2316 -> 1654;
2316 -> 1570;
2316 -> 1571;
2316 -> 2301;
2316 -> 1578;
2316 -> 1575;
2317 -> 1590;
2318 -> 2317;
2318 -> 1411;
2319 -> 2318;
2319 -> 1413;
2319 -> 1411;
2320 -> 1609;
2321 -> 2320;
2321 -> 1449;
2322 -> 2321;
2322 -> 1451;
2322 -> 1449;
2323 -> 1447;
2323 -> 1479;
2323 -> 1605;
2323 -> 2322;
2323 -> 1614;
2323 -> 1475;
2323 -> 1476;
2323 -> 2308;
2323 -> 1486;
2323 -> 1478;
2324 -> 1629;
2325 -> 2324;
2325 -> 1498;
2326 -> 2325;
2326 -> 1500;
2326 -> 1498;
2327 -> 1496;
2327 -> 1530;
2327 -> 1625;
2327 -> 2326;
2327 -> 1634;
2327 -> 1524;
2327 -> 1525;
2327 -> 2312;
2327 -> 1532;
2327 -> 1529;
2328 -> 1649;
2329 -> 2328;
2329 -> 1544;
2330 -> 2329;
2330 -> 1546;
2330 -> 1544;
2331 -> 1542;
2331 -> 1576;
2331 -> 1645;
2331 -> 2330;
2331 -> 1654;
2331 -> 1570;
2331 -> 1571;
2331 -> 2316;
2331 -> 1578;
2331 -> 1575;
2332 -> 1590;
2333 -> 2332;
2333 -> 1411;
2334 -> 2333;
2334 -> 1413;
2334 -> 1411;
2335 -> 1609;
2336 -> 2335;
2336 -> 1449;
2337 -> 2336;
2337 -> 1451;
2337 -> 1449;
2338 -> 1447;
2338 -> 1479;
2338 -> 1605;
2338 -> 2337;
2338 -> 1614;
2338 -> 1475;
2338 -> 1476;
2338 -> 2323;
2338 -> 1486;
2338 -> 1478;
2339 -> 1629;
2340 -> 2339;
2340 -> 1498;
2341 -> 2340;
2341 -> 1500;
2341 -> 1498;
2342 -> 1496;
2342 -> 1530;
2342 -> 1625;
2342 -> 2341;
2342 -> 1634;
2342 -> 1524;
2342 -> 1525;
2342 -> 2327;
2342 -> 1532;
2342 -> 1529;
2343 -> 1649;
2344 -> 2343;
2344 -> 1544;
2345 -> 2344;
2345 -> 1546;
2345 -> 1544;
2346 -> 1542;
2346 -> 1576;
2346 -> 1645;
2346 -> 2345;
2346 -> 1654;
2346 -> 1570;
2346 -> 1571;
2346 -> 2331;
2346 -> 1578;
2346 -> 1575;
2347 -> 1590;
2348 -> 2347;
2348 -> 1411;
2349 -> 2348;
2349 -> 1413;
2349 -> 1411;
2350 -> 1609;
2351 -> 2350;
2351 -> 1449;
2352 -> 2351;
2352 -> 1451;
2352 -> 1449;
2353 -> 1447;
2353 -> 1479;
2353 -> 1605;
2353 -> 2352;
2353 -> 1614;
2353 -> 1475;
2353 -> 1476;
2353 -> 2338;
2353 -> 1486;
2353 -> 1478;
2354 -> 1629;
2355 -> 2354;
2355 -> 1498;
2356 -> 2355;
2356 -> 1500;
2356 -> 1498;
2357 -> 1496;
2357 -> 1530;
2357 -> 1625;
2357 -> 2356;
2357 -> 1634;
2357 -> 1524;
2357 -> 1525;
2357 -> 2342;
2357 -> 1532;
2357 -> 1529;
2358 -> 1649;
2359 -> 2358;
2359 -> 1544;
2360 -> 2359;
2360 -> 1546;
2360 -> 1544;
2361 -> 1542;
2361 -> 1576;
2361 -> 1645;
2361 -> 2360;
2361 -> 1654;
2361 -> 1570;
2361 -> 1571;
2361 -> 2346;
2361 -> 1578;
2361 -> 1575;
2362 -> 1590;
2363 -> 2362;
2363 -> 1411;
2364 -> 2363;
2364 -> 1413;
2364 -> 1411;
2365 -> 1609;
2366 -> 2365;
2366 -> 1449;
2367 -> 2366;
2367 -> 1451;
2367 -> 1449;
2368 -> 1447;
2368 -> 1479;
2368 -> 1605;
2368 -> 2367;
2368 -> 1614;
2368 -> 1475;
2368 -> 1476;
2368 -> 2353;
2368 -> 1486;
2368 -> 1478;
2369 -> 1629;
2370 -> 2369;
2370 -> 1498;
2371 -> 2370;
2371 -> 1500;
2371 -> 1498;
2372 -> 1496;
2372 -> 1530;
2372 -> 1625;
2372 -> 2371;
2372 -> 1634;
2372 -> 1524;
2372 -> 1525;
2372 -> 2357;
2372 -> 1532;
2372 -> 1529;
2373 -> 1649;
2374 -> 2373;
2374 -> 1544;
2375 -> 2374;
2375 -> 1546;
2375 -> 1544;
2376 -> 1542;
2376 -> 1576;
2376 -> 1645;
2376 -> 2375;
2376 -> 1654;
2376 -> 1570;
2376 -> 1571;
2376 -> 2361;
2376 -> 1578;
2376 -> 1575;
2377 -> 1590;
2378 -> 2377;
2378 -> 1411;
2379 -> 2378;
2379 -> 1413;
2379 -> 1411;
2380 -> 1609;
2381 -> 2380;
2381 -> 1449;
2382 -> 2381;
2382 -> 1451;
2382 -> 1449;
2383 -> 1447;
2383 -> 1479;
2383 -> 1605;
2383 -> 2382;
2383 -> 1614;
2383 -> 1475;
2383 -> 1476;
2383 -> 2368;
2383 -> 1486;
2383 -> 1478;
2384 -> 1629;
2385 -> 2384;
2385 -> 1498;
2386 -> 2385;
2386 -> 1500;
2386 -> 1498;
2387 -> 1496;
2387 -> 1530;
2387 -> 1625;
2387 -> 2386;
2387 -> 1634;
2387 -> 1524;
2387 -> 1525;
2387 -> 2372;
2387 -> 1532;
2387 -> 1529;
2388 -> 1649;
2389 -> 2388;
2389 -> 1544;
2390 -> 2389;
2390 -> 1546;
2390 -> 1544;
2391 -> 1542;
2391 -> 1576;
2391 -> 1645;
2391 -> 2390;
2391 -> 1654;
2391 -> 1570;
2391 -> 1571;
2391 -> 2376;
2391 -> 1578;
2391 -> 1575;
2392 -> 1590;
2393 -> 2392;
2393 -> 1411;
2394 -> 2393;
2394 -> 1413;
2394 -> 1411;
2395 -> 1609;
2396 -> 2395;
2396 -> 1449;
2397 -> 2396;
2397 -> 1451;
2397 -> 1449;
2398 -> 1447;
2398 -> 1479;
2398 -> 1605;
2398 -> 2397;
2398 -> 1614;
2398 -> 1475;
2398 -> 1476;
2398 -> 2383;
2398 -> 1486;
2398 -> 1478;
2399 -> 1629;
2400 -> 2399;
2400 -> 1498;
2401 -> 2400;
2401 -> 1500;
2401 -> 1498;
2402 -> 1496;
2402 -> 1530;
2402 -> 1625;
2402 -> 2401;
2402 -> 1634;
2402 -> 1524;
2402 -> 1525;
2402 -> 2387;
2402 -> 1532;
2402 -> 1529;
2403 -> 1649;
2404 -> 2403;
2404 -> 1544;
2405 -> 2404;
2405 -> 1546;
2405 -> 1544;
2406 -> 1542;
2406 -> 1576;
2406 -> 1645;
2406 -> 2405;
2406 -> 1654;
2406 -> 1570;
2406 -> 1571;
2406 -> 2391;
2406 -> 1578;
2406 -> 1575;
2407 -> 1590;
2408 -> 2407;
2408 -> 1411;
2409 -> 2408;
2409 -> 1413;
2409 -> 1411;
2410 -> 1609;
2411 -> 2410;
2411 -> 1449;
2412 -> 2411;
2412 -> 1451;
2412 -> 1449;
2413 -> 1447;
2413 -> 1479;
2413 -> 1605;
2413 -> 2412;
2413 -> 1614;
2413 -> 1475;
2413 -> 1476;
2413 -> 2398;
2413 -> 1486;
2413 -> 1478;
2414 -> 1629;
2415 -> 2414;
2415 -> 1498;
2416 -> 2415;
2416 -> 1500;
2416 -> 1498;
2417 -> 1496;
2417 -> 1530;
2417 -> 1625;
2417 -> 2416;
2417 -> 1634;
2417 -> 1524;
2417 -> 1525;
2417 -> 2402;
2417 -> 1532;
2417 -> 1529;
2418 -> 1649;
2419 -> 2418;
2419 -> 1544;
2420 -> 2419;
2420 -> 1546;
2420 -> 1544;
2421 -> 1542;
2421 -> 1576;
2421 -> 1645;
2421 -> 2420;
2421 -> 1654;
2421 -> 1570;
2421 -> 1571;
2421 -> 2406;
2421 -> 1578;
2421 -> 1575;
2422 -> 1590;
2423 -> 2422;
2423 -> 1411;
2424 -> 2423;
2424 -> 1413;
2424 -> 1411;
2425 -> 1609;
2426 -> 2425;
2426 -> 1449;
2427 -> 2426;
2427 -> 1451;
2427 -> 1449;
2428 -> 1447;
2428 -> 1479;
2428 -> 1605;
2428 -> 2427;
2428 -> 1614;
2428 -> 1475;
2428 -> 1476;
2428 -> 2413;
2428 -> 1486;
2428 -> 1478;
2429 -> 1629;
2430 -> 2429;
2430 -> 1498;
2431 -> 2430;
2431 -> 1500;
2431 -> 1498;
2432 -> 1496;
2432 -> 1530;
2432 -> 1625;
2432 -> 2431;
2432 -> 1634;
2432 -> 1524;
2432 -> 1525;
2432 -> 2417;
2432 -> 1532;
2432 -> 1529;
2433 -> 1649;
2434 -> 2433;
2434 -> 1544;
2435 -> 2434;
2435 -> 1546;
2435 -> 1544;
2436 -> 1542;
2436 -> 1576;
2436 -> 1645;
2436 -> 2435;
2436 -> 1654;
2436 -> 1570;
2436 -> 1571;
2436 -> 2421;
2436 -> 1578;
2436 -> 1575;
2437 -> 1590;
2438 -> 2437;
2438 -> 1411;
2439 -> 2438;
2439 -> 1413;
2439 -> 1411;
2440 -> 1609;
2441 -> 2440;
2441 -> 1449;
2442 -> 2441;
2442 -> 1451;
2442 -> 1449;
2443 -> 1447;
2443 -> 1479;
2443 -> 1605;
2443 -> 2442;
2443 -> 1614;
2443 -> 1475;
2443 -> 1476;
2443 -> 2428;
2443 -> 1486;
2443 -> 1478;
2444 -> 1629;
2445 -> 2444;
2445 -> 1498;
2446 -> 2445;
2446 -> 1500;
2446 -> 1498;
2447 -> 1496;
2447 -> 1530;
2447 -> 1625;
2447 -> 2446;
2447 -> 1634;
2447 -> 1524;
2447 -> 1525;
2447 -> 2432;
2447 -> 1532;
2447 -> 1529;
2448 -> 1649;
2449 -> 2448;
2449 -> 1544;
2450 -> 2449;
2450 -> 1546;
2450 -> 1544;
2451 -> 1542;
2451 -> 1576;
2451 -> 1645;
2451 -> 2450;
2451 -> 1654;
2451 -> 1570;
2451 -> 1571;
2451 -> 2436;
2451 -> 1578;
2451 -> 1575;
2452 -> 1590;
2453 -> 2452;
2453 -> 1411;
2454 -> 2453;
2454 -> 1413;
2454 -> 1411;
2455 -> 1609;
2456 -> 2455;
2456 -> 1449;
2457 -> 2456;
2457 -> 1451;
2457 -> 1449;
2458 -> 1447;
2458 -> 1479;
2458 -> 1605;
2458 -> 2457;
2458 -> 1614;
2458 -> 1475;
2458 -> 1476;
2458 -> 2443;
2458 -> 1486;
2458 -> 1478;
2459 -> 1629;
2460 -> 2459;
2460 -> 1498;
2461 -> 2460;
2461 -> 1500;
2461 -> 1498;
2462 -> 1496;
2462 -> 1530;
2462 -> 1625;
2462 -> 2461;
2462 -> 1634;
2462 -> 1524;
2462 -> 1525;
2462 -> 2447;
2462 -> 1532;
2462 -> 1529;
2463 -> 1649;
2464 -> 2463;
2464 -> 1544;
2465 -> 2464;
2465 -> 1546;
2465 -> 1544;
2466 -> 1542;
2466 -> 1576;
2466 -> 1645;
2466 -> 2465;
2466 -> 1654;
2466 -> 1570;
2466 -> 1571;
2466 -> 2451;
2466 -> 1578;
2466 -> 1575;
2467 -> 1590;
2468 -> 2467;
2468 -> 1411;
2469 -> 2468;
2469 -> 1413;
2469 -> 1411;
2470 -> 1609;
2471 -> 2470;
2471 -> 1449;
2472 -> 2471;
2472 -> 1451;
2472 -> 1449;
2473 -> 1447;
2473 -> 1479;
2473 -> 1605;
2473 -> 2472;
2473 -> 1614;
2473 -> 1475;
2473 -> 1476;
2473 -> 2458;
2473 -> 1486;
2473 -> 1478;
2474 -> 1629;
2475 -> 2474;
2475 -> 1498;
2476 -> 2475;
2476 -> 1500;
2476 -> 1498;
2477 -> 1496;
2477 -> 1530;
2477 -> 1625;
2477 -> 2476;
2477 -> 1634;
2477 -> 1524;
2477 -> 1525;
2477 -> 2462;
2477 -> 1532;
2477 -> 1529;
2478 -> 1649;
2479 -> 2478;
2479 -> 1544;
2480 -> 2479;
2480 -> 1546;
2480 -> 1544;
2481 -> 1542;
2481 -> 1576;
2481 -> 1645;
2481 -> 2480;
2481 -> 1654;
2481 -> 1570;
2481 -> 1571;
2481 -> 2466;
2481 -> 1578;
2481 -> 1575;
2482 -> 1590;
2483 -> 2482;
2483 -> 1411;
2484 -> 2483;
2484 -> 1413;
2484 -> 1411;
2485 -> 1609;
2486 -> 2485;
2486 -> 1449;
2487 -> 2486;
2487 -> 1451;
2487 -> 1449;
2488 -> 1447;
2488 -> 1479;
2488 -> 1605;
2488 -> 2487;
2488 -> 1614;
2488 -> 1475;
2488 -> 1476;
2488 -> 2473;
2488 -> 1486;
2488 -> 1478;
2489 -> 1629;
2490 -> 2489;
2490 -> 1498;
2491 -> 2490;
2491 -> 1500;
2491 -> 1498;
2492 -> 1496;
2492 -> 1530;
2492 -> 1625;
2492 -> 2491;
2492 -> 1634;
2492 -> 1524;
2492 -> 1525;
2492 -> 2477;
2492 -> 1532;
2492 -> 1529;
2493 -> 1649;
2494 -> 2493;
2494 -> 1544;
2495 -> 2494;
2495 -> 1546;
2495 -> 1544;
2496 -> 1542;
2496 -> 1576;
2496 -> 1645;
2496 -> 2495;
2496 -> 1654;
2496 -> 1570;
2496 -> 1571;
2496 -> 2481;
2496 -> 1578;
2496 -> 1575;
2497 -> 1590;
2498 -> 2497;
2498 -> 1411;
2499 -> 2498;
2499 -> 1413;
2499 -> 1411;
2500 -> 1609;
2501 -> 2500;
2501 -> 1449;
2502 -> 2501;
2502 -> 1451;
2502 -> 1449;
2503 -> 1447;
2503 -> 1479;
2503 -> 1605;
2503 -> 2502;
2503 -> 1614;
2503 -> 1475;
2503 -> 1476;
2503 -> 2488;
2503 -> 1486;
2503 -> 1478;
2504 -> 1629;
2505 -> 2504;
2505 -> 1498;
2506 -> 2505;
2506 -> 1500;
2506 -> 1498;
2507 -> 1496;
2507 -> 1530;
2507 -> 1625;
2507 -> 2506;
2507 -> 1634;
2507 -> 1524;
2507 -> 1525;
2507 -> 2492;
2507 -> 1532;
2507 -> 1529;
2508 -> 1649;
2509 -> 2508;
2509 -> 1544;
2510 -> 2509;
2510 -> 1546;
2510 -> 1544;
2511 -> 1542;
2511 -> 1576;
2511 -> 1645;
2511 -> 2510;
2511 -> 1654;
2511 -> 1570;
2511 -> 1571;
2511 -> 2496;
2511 -> 1578;
2511 -> 1575;
2512 -> 1590;
2513 -> 2512;
2513 -> 1411;
2514 -> 2513;
2514 -> 1413;
2514 -> 1411;
2515 -> 1609;
2516 -> 2515;
2516 -> 1449;
2517 -> 2516;
2517 -> 1451;
2517 -> 1449;
2518 -> 1447;
2518 -> 1479;
2518 -> 1605;
2518 -> 2517;
2518 -> 1614;
2518 -> 1475;
2518 -> 1476;
2518 -> 2503;
2518 -> 1486;
2518 -> 1478;
2519 -> 1629;
2520 -> 2519;
2520 -> 1498;
2521 -> 2520;
2521 -> 1500;
2521 -> 1498;
2522 -> 1496;
2522 -> 1530;
2522 -> 1625;
2522 -> 2521;
2522 -> 1634;
2522 -> 1524;
2522 -> 1525;
2522 -> 2507;
2522 -> 1532;
2522 -> 1529;
2523 -> 1649;
2524 -> 2523;
2524 -> 1544;
2525 -> 2524;
2525 -> 1546;
2525 -> 1544;
2526 -> 1542;
2526 -> 1576;
2526 -> 1645;
2526 -> 2525;
2526 -> 1654;
2526 -> 1570;
2526 -> 1571;
2526 -> 2511;
2526 -> 1578;
2526 -> 1575;
2527 -> 1590;
2528 -> 2527;
2528 -> 1411;
2529 -> 2528;
2529 -> 1413;
2529 -> 1411;
2530 -> 1609;
2531 -> 2530;
2531 -> 1449;
2532 -> 2531;
2532 -> 1451;
2532 -> 1449;
2533 -> 1447;
2533 -> 1479;
2533 -> 1605;
2533 -> 2532;
2533 -> 1614;
2533 -> 1475;
2533 -> 1476;
2533 -> 2518;
2533 -> 1486;
2533 -> 1478;
2534 -> 1629;
2535 -> 2534;
2535 -> 1498;
2536 -> 2535;
2536 -> 1500;
2536 -> 1498;
2537 -> 1496;
2537 -> 1530;
2537 -> 1625;
2537 -> 2536;
2537 -> 1634;
2537 -> 1524;
2537 -> 1525;
2537 -> 2522;
2537 -> 1532;
2537 -> 1529;
2538 -> 1649;
2539 -> 2538;
2539 -> 1544;
2540 -> 2539;
2540 -> 1546;
2540 -> 1544;
2541 -> 1542;
2541 -> 1576;
2541 -> 1645;
2541 -> 2540;
2541 -> 1654;
2541 -> 1570;
2541 -> 1571;
2541 -> 2526;
2541 -> 1578;
2541 -> 1575;
2542 -> 1590;
2543 -> 2542;
2543 -> 1411;
2544 -> 2543;
2544 -> 1413;
2544 -> 1411;
2545 -> 1609;
2546 -> 2545;
2546 -> 1449;
2547 -> 2546;
2547 -> 1451;
2547 -> 1449;
2548 -> 1447;
2548 -> 1479;
2548 -> 1605;
2548 -> 2547;
2548 -> 1614;
2548 -> 1475;
2548 -> 1476;
2548 -> 2533;
2548 -> 1486;
2548 -> 1478;
2549 -> 1629;
2550 -> 2549;
2550 -> 1498;
2551 -> 2550;
2551 -> 1500;
2551 -> 1498;
2552 -> 1496;
2552 -> 1530;
2552 -> 1625;
2552 -> 2551;
2552 -> 1634;
2552 -> 1524;
2552 -> 1525;
2552 -> 2537;
2552 -> 1532;
2552 -> 1529;
2553 -> 1649;
2554 -> 2553;
2554 -> 1544;
2555 -> 2554;
2555 -> 1546;
2555 -> 1544;
2556 -> 1542;
2556 -> 1576;
2556 -> 1645;
2556 -> 2555;
2556 -> 1654;
2556 -> 1570;
2556 -> 1571;
2556 -> 2541;
2556 -> 1578;
2556 -> 1575;
2557 -> 1590;
2558 -> 2557;
2558 -> 1411;
2559 -> 2558;
2559 -> 1413;
2559 -> 1411;
2560 -> 1609;
2561 -> 2560;
2561 -> 1449;
2562 -> 2561;
2562 -> 1451;
2562 -> 1449;
2563 -> 1447;
2563 -> 1479;
2563 -> 1605;
2563 -> 2562;
2563 -> 1614;
2563 -> 1475;
2563 -> 1476;
2563 -> 2548;
2563 -> 1486;
2563 -> 1478;
2564 -> 1629;
2565 -> 2564;
2565 -> 1498;
2566 -> 2565;
2566 -> 1500;
2566 -> 1498;
2567 -> 1496;
2567 -> 1530;
2567 -> 1625;
2567 -> 2566;
2567 -> 1634;
2567 -> 1524;
2567 -> 1525;
2567 -> 2552;
2567 -> 1532;
2567 -> 1529;
2568 -> 1649;
2569 -> 2568;
2569 -> 1544;
2570 -> 2569;
2570 -> 1546;
2570 -> 1544;
2571 -> 1542;
2571 -> 1576;
2571 -> 1645;
2571 -> 2570;
2571 -> 1654;
2571 -> 1570;
2571 -> 1571;
2571 -> 2556;
2571 -> 1578;
2571 -> 1575;
2572 -> 1590;
2573 -> 2572;
2573 -> 1411;
2574 -> 2573;
2574 -> 1413;
2574 -> 1411;
2575 -> 1609;
2576 -> 2575;
2576 -> 1449;
2577 -> 2576;
2577 -> 1451;
2577 -> 1449;
2578 -> 1447;
2578 -> 1479;
2578 -> 1605;
2578 -> 2577;
2578 -> 1614;
2578 -> 1475;
2578 -> 1476;
2578 -> 2563;
2578 -> 1486;
2578 -> 1478;
2579 -> 1629;
2580 -> 2579;
2580 -> 1498;
2581 -> 2580;
2581 -> 1500;
2581 -> 1498;
2582 -> 1496;
2582 -> 1530;
2582 -> 1625;
2582 -> 2581;
2582 -> 1634;
2582 -> 1524;
2582 -> 1525;
2582 -> 2567;
2582 -> 1532;
2582 -> 1529;
2583 -> 1649;
2584 -> 2583;
2584 -> 1544;
2585 -> 2584;
2585 -> 1546;
2585 -> 1544;
2586 -> 1542;
2586 -> 1576;
2586 -> 1645;
2586 -> 2585;
2586 -> 1654;
2586 -> 1570;
2586 -> 1571;
2586 -> 2571;
2586 -> 1578;
2586 -> 1575;
2587 -> 1590;
2588 -> 2587;
2588 -> 1411;
2589 -> 2588;
2589 -> 1413;
2589 -> 1411;
2590 -> 1609;
2591 -> 2590;
2591 -> 1449;
2592 -> 2591;
2592 -> 1451;
2592 -> 1449;
2593 -> 1447;
2593 -> 1479;
2593 -> 1605;
2593 -> 2592;
2593 -> 1614;
2593 -> 1475;
2593 -> 1476;
2593 -> 2578;
2593 -> 1486;
2593 -> 1478;
2594 -> 1629;
2595 -> 2594;
2595 -> 1498;
2596 -> 2595;
2596 -> 1500;
2596 -> 1498;
2597 -> 1496;
2597 -> 1530;
2597 -> 1625;
2597 -> 2596;
2597 -> 1634;
2597 -> 1524;
2597 -> 1525;
2597 -> 2582;
2597 -> 1532;
2597 -> 1529;
2598 -> 1649;
2599 -> 2598;
2599 -> 1544;
2600 -> 2599;
2600 -> 1546;
2600 -> 1544;
2601 -> 1542;
2601 -> 1576;
2601 -> 1645;
2601 -> 2600;
2601 -> 1654;
2601 -> 1570;
2601 -> 1571;
2601 -> 2586;
2601 -> 1578;
2601 -> 1575;
2602 -> 1590;
2603 -> 2602;
2603 -> 1411;
2604 -> 2603;
2604 -> 1413;
2604 -> 1411;
2605 -> 1609;
2606 -> 2605;
2606 -> 1449;
2607 -> 2606;
2607 -> 1451;
2607 -> 1449;
2608 -> 1447;
2608 -> 1479;
2608 -> 1605;
2608 -> 2607;
2608 -> 1614;
2608 -> 1475;
2608 -> 1476;
2608 -> 2593;
2608 -> 1486;
2608 -> 1478;
2609 -> 1629;
2610 -> 2609;
2610 -> 1498;
2611 -> 2610;
2611 -> 1500;
2611 -> 1498;
2612 -> 1496;
2612 -> 1530;
2612 -> 1625;
2612 -> 2611;
2612 -> 1634;
2612 -> 1524;
2612 -> 1525;
2612 -> 2597;
2612 -> 1532;
2612 -> 1529;
2613 -> 1649;
2614 -> 2613;
2614 -> 1544;
2615 -> 2614;
2615 -> 1546;
2615 -> 1544;
2616 -> 1542;
2616 -> 1576;
2616 -> 1645;
2616 -> 2615;
2616 -> 1654;
2616 -> 1570;
2616 -> 1571;
2616 -> 2601;
2616 -> 1578;
2616 -> 1575;
2617 -> 1590;
2618 -> 2617;
2618 -> 1411;
2619 -> 2618;
2619 -> 1413;
2619 -> 1411;
2620 -> 1609;
2621 -> 2620;
2621 -> 1449;
2622 -> 2621;
2622 -> 1451;
2622 -> 1449;
2623 -> 1447;
2623 -> 1479;
2623 -> 1605;
2623 -> 2622;
2623 -> 1614;
2623 -> 1475;
2623 -> 1476;
2623 -> 2608;
2623 -> 1486;
2623 -> 1478;
2624 -> 1629;
2625 -> 2624;
2625 -> 1498;
2626 -> 2625;
2626 -> 1500;
2626 -> 1498;
2627 -> 1496;
2627 -> 1530;
2627 -> 1625;
2627 -> 2626;
2627 -> 1634;
2627 -> 1524;
2627 -> 1525;
2627 -> 2612;
2627 -> 1532;
2627 -> 1529;
2628 -> 1649;
2629 -> 2628;
2629 -> 1544;
2630 -> 2629;
2630 -> 1546;
2630 -> 1544;
2631 -> 1542;
2631 -> 1576;
2631 -> 1645;
2631 -> 2630;
2631 -> 1654;
2631 -> 1570;
2631 -> 1571;
2631 -> 2616;
2631 -> 1578;
2631 -> 1575;
2632 -> 1590;
2633 -> 2632;
2633 -> 1411;
2634 -> 2633;
2634 -> 1413;
2634 -> 1411;
2635 -> 1609;
2636 -> 2635;
2636 -> 1449;
2637 -> 2636;
2637 -> 1451;
2637 -> 1449;
2638 -> 1447;
2638 -> 1479;
2638 -> 1605;
2638 -> 2637;
2638 -> 1614;
2638 -> 1475;
2638 -> 1476;
2638 -> 2623;
2638 -> 1486;
2638 -> 1478;
2639 -> 1629;
2640 -> 2639;
2640 -> 1498;
2641 -> 2640;
2641 -> 1500;
2641 -> 1498;
2642 -> 1496;
2642 -> 1530;
2642 -> 1625;
2642 -> 2641;
2642 -> 1634;
2642 -> 1524;
2642 -> 1525;
2642 -> 2627;
2642 -> 1532;
2642 -> 1529;
2643 -> 1649;
2644 -> 2643;
2644 -> 1544;
2645 -> 2644;
2645 -> 1546;
2645 -> 1544;
2646 -> 1542;
2646 -> 1576;
2646 -> 1645;
2646 -> 2645;
2646 -> 1654;
2646 -> 1570;
2646 -> 1571;
2646 -> 2631;
2646 -> 1578;
2646 -> 1575;
2647 -> 1590;
2648 -> 2647;
2648 -> 1411;
2649 -> 2648;
2649 -> 1413;
2649 -> 1411;
2650 -> 1609;
2651 -> 2650;
2651 -> 1449;
2652 -> 2651;
2652 -> 1451;
2652 -> 1449;
2653 -> 1447;
2653 -> 1479;
2653 -> 1605;
2653 -> 2652;
2653 -> 1614;
2653 -> 1475;
2653 -> 1476;
2653 -> 2638;
2653 -> 1486;
2653 -> 1478;
2654 -> 1629;
2655 -> 2654;
2655 -> 1498;
2656 -> 2655;
2656 -> 1500;
2656 -> 1498;
2657 -> 1496;
2657 -> 1530;
2657 -> 1625;
2657 -> 2656;
2657 -> 1634;
2657 -> 1524;
2657 -> 1525;
2657 -> 2642;
2657 -> 1532;
2657 -> 1529;
2658 -> 1649;
2659 -> 2658;
2659 -> 1544;
2660 -> 2659;
2660 -> 1546;
2660 -> 1544;
2661 -> 1542;
2661 -> 1576;
2661 -> 1645;
2661 -> 2660;
2661 -> 1654;
2661 -> 1570;
2661 -> 1571;
2661 -> 2646;
2661 -> 1578;
2661 -> 1575;
2662 -> 1590;
2663 -> 2662;
2663 -> 1411;
2664 -> 2663;
2664 -> 1413;
2664 -> 1411;
2665 -> 1609;
2666 -> 2665;
2666 -> 1449;
2667 -> 2666;
2667 -> 1451;
2667 -> 1449;
2668 -> 1447;
2668 -> 1479;
2668 -> 1605;
2668 -> 2667;
2668 -> 1614;
2668 -> 1475;
2668 -> 1476;
2668 -> 2653;
2668 -> 1486;
2668 -> 1478;
2669 -> 1629;
2670 -> 2669;
2670 -> 1498;
2671 -> 2670;
2671 -> 1500;
2671 -> 1498;
2672 -> 1496;
2672 -> 1530;
2672 -> 1625;
2672 -> 2671;
2672 -> 1634;
2672 -> 1524;
2672 -> 1525;
2672 -> 2657;
2672 -> 1532;
2672 -> 1529;
2673 -> 1649;
2674 -> 2673;
2674 -> 1544;
2675 -> 2674;
2675 -> 1546;
2675 -> 1544;
2676 -> 1542;
2676 -> 1576;
2676 -> 1645;
2676 -> 2675;
2676 -> 1654;
2676 -> 1570;
2676 -> 1571;
2676 -> 2661;
2676 -> 1578;
2676 -> 1575;
2677 -> 1590;
2678 -> 2677;
2678 -> 1411;
2679 -> 2678;
2679 -> 1413;
2679 -> 1411;
2680 -> 1609;
2681 -> 2680;
2681 -> 1449;
2682 -> 2681;
2682 -> 1451;
2682 -> 1449;
2683 -> 1447;
2683 -> 1479;
2683 -> 1605;
2683 -> 2682;
2683 -> 1614;
2683 -> 1475;
2683 -> 1476;
2683 -> 2668;
2683 -> 1486;
2683 -> 1478;
2684 -> 1629;
2685 -> 2684;
2685 -> 1498;
2686 -> 2685;
2686 -> 1500;
2686 -> 1498;
2687 -> 1496;
2687 -> 1530;
2687 -> 1625;
2687 -> 2686;
2687 -> 1634;
2687 -> 1524;
2687 -> 1525;
2687 -> 2672;
2687 -> 1532;
2687 -> 1529;
2688 -> 1649;
2689 -> 2688;
2689 -> 1544;
2690 -> 2689;
2690 -> 1546;
2690 -> 1544;
2691 -> 1542;
2691 -> 1576;
2691 -> 1645;
2691 -> 2690;
2691 -> 1654;
2691 -> 1570;
2691 -> 1571;
2691 -> 2676;
2691 -> 1578;
2691 -> 1575;
2692 -> 1590;
2693 -> 2692;
2693 -> 1411;
2694 -> 2693;
2694 -> 1413;
2694 -> 1411;
2695 -> 1609;
2696 -> 2695;
2696 -> 1449;
2697 -> 2696;
2697 -> 1451;
2697 -> 1449;
2698 -> 1447;
2698 -> 1479;
2698 -> 1605;
2698 -> 2697;
2698 -> 1614;
2698 -> 1475;
2698 -> 1476;
2698 -> 2683;
2698 -> 1486;
2698 -> 1478;
2699 -> 1629;
2700 -> 2699;
2700 -> 1498;
2701 -> 2700;
2701 -> 1500;
2701 -> 1498;
2702 -> 1496;
2702 -> 1530;
2702 -> 1625;
2702 -> 2701;
2702 -> 1634;
2702 -> 1524;
2702 -> 1525;
2702 -> 2687;
2702 -> 1532;
2702 -> 1529;
2703 -> 1649;
2704 -> 2703;
2704 -> 1544;
2705 -> 2704;
2705 -> 1546;
2705 -> 1544;
2706 -> 1542;
2706 -> 1576;
2706 -> 1645;
2706 -> 2705;
2706 -> 1654;
2706 -> 1570;
2706 -> 1571;
2706 -> 2691;
2706 -> 1578;
2706 -> 1575;
2707 -> 1590;
2708 -> 2707;
2708 -> 1411;
2709 -> 2708;
2709 -> 1413;
2709 -> 1411;
2710 -> 1609;
2711 -> 2710;
2711 -> 1449;
2712 -> 2711;
2712 -> 1451;
2712 -> 1449;
2713 -> 1447;
2713 -> 1479;
2713 -> 1605;
2713 -> 2712;
2713 -> 1614;
2713 -> 1475;
2713 -> 1476;
2713 -> 2698;
2713 -> 1486;
2713 -> 1478;
2714 -> 1629;
2715 -> 2714;
2715 -> 1498;
2716 -> 2715;
2716 -> 1500;
2716 -> 1498;
2717 -> 1496;
2717 -> 1530;
2717 -> 1625;
2717 -> 2716;
2717 -> 1634;
2717 -> 1524;
2717 -> 1525;
2717 -> 2702;
2717 -> 1532;
2717 -> 1529;
2718 -> 1649;
2719 -> 2718;
2719 -> 1544;
2720 -> 2719;
2720 -> 1546;
2720 -> 1544;
2721 -> 1542;
2721 -> 1576;
2721 -> 1645;
2721 -> 2720;
2721 -> 1654;
2721 -> 1570;
2721 -> 1571;
2721 -> 2706;
2721 -> 1578;
2721 -> 1575;
2722 -> 1590;
2723 -> 2722;
2723 -> 1411;
2724 -> 2723;
2724 -> 1413;
2724 -> 1411;
2725 -> 1609;
2726 -> 2725;
2726 -> 1449;
2727 -> 2726;
2727 -> 1451;
2727 -> 1449;
2728 -> 1447;
2728 -> 1479;
2728 -> 1605;
2728 -> 2727;
2728 -> 1614;
2728 -> 1475;
2728 -> 1476;
2728 -> 2713;
2728 -> 1486;
2728 -> 1478;
2729 -> 1629;
2730 -> 2729;
2730 -> 1498;
2731 -> 2730;
2731 -> 1500;
2731 -> 1498;
2732 -> 1496;
2732 -> 1530;
2732 -> 1625;
2732 -> 2731;
2732 -> 1634;
2732 -> 1524;
2732 -> 1525;
2732 -> 2717;
2732 -> 1532;
2732 -> 1529;
2733 -> 1649;
2734 -> 2733;
2734 -> 1544;
2735 -> 2734;
2735 -> 1546;
2735 -> 1544;
2736 -> 1542;
2736 -> 1576;
2736 -> 1645;
2736 -> 2735;
2736 -> 1654;
2736 -> 1570;
2736 -> 1571;
2736 -> 2721;
2736 -> 1578;
2736 -> 1575;
2737 -> 1590;
2738 -> 2737;
2738 -> 1411;
2739 -> 2738;
2739 -> 1413;
2739 -> 1411;
2740 -> 1609;
2741 -> 2740;
2741 -> 1449;
2742 -> 2741;
2742 -> 1451;
2742 -> 1449;
2743 -> 1447;
2743 -> 1479;
2743 -> 1605;
2743 -> 2742;
2743 -> 1614;
2743 -> 1475;
2743 -> 1476;
2743 -> 2728;
2743 -> 1486;
2743 -> 1478;
2744 -> 1629;
2745 -> 2744;
2745 -> 1498;
2746 -> 2745;
2746 -> 1500;
2746 -> 1498;
2747 -> 1496;
2747 -> 1530;
2747 -> 1625;
2747 -> 2746;
2747 -> 1634;
2747 -> 1524;
2747 -> 1525;
2747 -> 2732;
2747 -> 1532;
2747 -> 1529;
2748 -> 1649;
2749 -> 2748;
2749 -> 1544;
2750 -> 2749;
2750 -> 1546;
2750 -> 1544;
2751 -> 1542;
2751 -> 1576;
2751 -> 1645;
2751 -> 2750;
2751 -> 1654;
2751 -> 1570;
2751 -> 1571;
2751 -> 2736;
2751 -> 1578;
2751 -> 1575;
2752 -> 1590;
2753 -> 2752;
2753 -> 1411;
2754 -> 2753;
2754 -> 1413;
2754 -> 1411;
2755 -> 1609;
2756 -> 2755;
2756 -> 1449;
2757 -> 2756;
2757 -> 1451;
2757 -> 1449;
2758 -> 1447;
2758 -> 1479;
2758 -> 1605;
2758 -> 2757;
2758 -> 1614;
2758 -> 1475;
2758 -> 1476;
2758 -> 2743;
2758 -> 1486;
2758 -> 1478;
2759 -> 1629;
2760 -> 2759;
2760 -> 1498;
2761 -> 2760;
2761 -> 1500;
2761 -> 1498;
2762 -> 1496;
2762 -> 1530;
2762 -> 1625;
2762 -> 2761;
2762 -> 1634;
2762 -> 1524;
2762 -> 1525;
2762 -> 2747;
2762 -> 1532;
2762 -> 1529;
2763 -> 1649;
2764 -> 2763;
2764 -> 1544;
2765 -> 2764;
2765 -> 1546;
2765 -> 1544;
2766 -> 1542;
2766 -> 1576;
2766 -> 1645;
2766 -> 2765;
2766 -> 1654;
2766 -> 1570;
2766 -> 1571;
2766 -> 2751;
2766 -> 1578;
2766 -> 1575;
2767 -> 1590;
2768 -> 2767;
2768 -> 1411;
2769 -> 2768;
2769 -> 1413;
2769 -> 1411;
2770 -> 1609;
2771 -> 2770;
2771 -> 1449;
2772 -> 2771;
2772 -> 1451;
2772 -> 1449;
2773 -> 1447;
2773 -> 1479;
2773 -> 1605;
2773 -> 2772;
2773 -> 1614;
2773 -> 1475;
2773 -> 1476;
2773 -> 2758;
2773 -> 1486;
2773 -> 1478;
2774 -> 1629;
2775 -> 2774;
2775 -> 1498;
2776 -> 2775;
2776 -> 1500;
2776 -> 1498;
2777 -> 1496;
2777 -> 1530;
2777 -> 1625;
2777 -> 2776;
2777 -> 1634;
2777 -> 1524;
2777 -> 1525;
2777 -> 2762;
2777 -> 1532;
2777 -> 1529;
2778 -> 1649;
2779 -> 2778;
2779 -> 1544;
2780 -> 2779;
2780 -> 1546;
2780 -> 1544;
2781 -> 1542;
2781 -> 1576;
2781 -> 1645;
2781 -> 2780;
2781 -> 1654;
2781 -> 1570;
2781 -> 1571;
2781 -> 2766;
2781 -> 1578;
2781 -> 1575;
2782 -> 1590;
2783 -> 2782;
2783 -> 1411;
2784 -> 2783;
2784 -> 1413;
2784 -> 1411;
2785 -> 1609;
2786 -> 2785;
2786 -> 1449;
2787 -> 2786;
2787 -> 1451;
2787 -> 1449;
2788 -> 1447;
2788 -> 1479;
2788 -> 1605;
2788 -> 2787;
2788 -> 1614;
2788 -> 1475;
2788 -> 1476;
2788 -> 2773;
2788 -> 1486;
2788 -> 1478;
2789 -> 1629;
2790 -> 2789;
2790 -> 1498;
2791 -> 2790;
2791 -> 1500;
2791 -> 1498;
2792 -> 1496;
2792 -> 1530;
2792 -> 1625;
2792 -> 2791;
2792 -> 1634;
2792 -> 1524;
2792 -> 1525;
2792 -> 2777;
2792 -> 1532;
2792 -> 1529;
2793 -> 1649;
2794 -> 2793;
2794 -> 1544;
2795 -> 2794;
2795 -> 1546;
2795 -> 1544;
2796 -> 1542;
2796 -> 1576;
2796 -> 1645;
2796 -> 2795;
2796 -> 1654;
2796 -> 1570;
2796 -> 1571;
2796 -> 2781;
2796 -> 1578;
2796 -> 1575;
2797 -> 1590;
2798 -> 2797;
2798 -> 1411;
2799 -> 2798;
2799 -> 1413;
2799 -> 1411;
2800 -> 1609;
2801 -> 2800;
2801 -> 1449;
2802 -> 2801;
2802 -> 1451;
2802 -> 1449;
2803 -> 1447;
2803 -> 1479;
2803 -> 1605;
2803 -> 2802;
2803 -> 1614;
2803 -> 1475;
2803 -> 1476;
2803 -> 2788;
2803 -> 1486;
2803 -> 1478;
2804 -> 1629;
2805 -> 2804;
2805 -> 1498;
2806 -> 2805;
2806 -> 1500;
2806 -> 1498;
2807 -> 1496;
2807 -> 1530;
2807 -> 1625;
2807 -> 2806;
2807 -> 1634;
2807 -> 1524;
2807 -> 1525;
2807 -> 2792;
2807 -> 1532;
2807 -> 1529;
2808 -> 1649;
2809 -> 2808;
2809 -> 1544;
2810 -> 2809;
2810 -> 1546;
2810 -> 1544;
2811 -> 1542;
2811 -> 1576;
2811 -> 1645;
2811 -> 2810;
2811 -> 1654;
2811 -> 1570;
2811 -> 1571;
2811 -> 2796;
2811 -> 1578;
2811 -> 1575;
2812 -> 1590;
2813 -> 2812;
2813 -> 1411;
2814 -> 2813;
2814 -> 1413;
2814 -> 1411;
2815 -> 1609;
2816 -> 2815;
2816 -> 1449;
2817 -> 2816;
2817 -> 1451;
2817 -> 1449;
2818 -> 1447;
2818 -> 1479;
2818 -> 1605;
2818 -> 2817;
2818 -> 1614;
2818 -> 1475;
2818 -> 1476;
2818 -> 2803;
2818 -> 1486;
2818 -> 1478;
2819 -> 1629;
2820 -> 2819;
2820 -> 1498;
2821 -> 2820;
2821 -> 1500;
2821 -> 1498;
2822 -> 1496;
2822 -> 1530;
2822 -> 1625;
2822 -> 2821;
2822 -> 1634;
2822 -> 1524;
2822 -> 1525;
2822 -> 2807;
2822 -> 1532;
2822 -> 1529;
2823 -> 1649;
2824 -> 2823;
2824 -> 1544;
2825 -> 2824;
2825 -> 1546;
2825 -> 1544;
2826 -> 1542;
2826 -> 1576;
2826 -> 1645;
2826 -> 2825;
2826 -> 1654;
2826 -> 1570;
2826 -> 1571;
2826 -> 2811;
2826 -> 1578;
2826 -> 1575;
2827 -> 1590;
2828 -> 2827;
2828 -> 1411;
2829 -> 2828;
2829 -> 1413;
2829 -> 1411;
2830 -> 1609;
2831 -> 2830;
2831 -> 1449;
2832 -> 2831;
2832 -> 1451;
2832 -> 1449;
2833 -> 1447;
2833 -> 1479;
2833 -> 1605;
2833 -> 2832;
2833 -> 1614;
2833 -> 1475;
2833 -> 1476;
2833 -> 2818;
2833 -> 1486;
2833 -> 1478;
2834 -> 1629;
2835 -> 2834;
2835 -> 1498;
2836 -> 2835;
2836 -> 1500;
2836 -> 1498;
2837 -> 1496;
2837 -> 1530;
2837 -> 1625;
2837 -> 2836;
2837 -> 1634;
2837 -> 1524;
2837 -> 1525;
2837 -> 2822;
2837 -> 1532;
2837 -> 1529;
2838 -> 1649;
2839 -> 2838;
2839 -> 1544;
2840 -> 2839;
2840 -> 1546;
2840 -> 1544;
2841 -> 1542;
2841 -> 1576;
2841 -> 1645;
2841 -> 2840;
2841 -> 1654;
2841 -> 1570;
2841 -> 1571;
2841 -> 2826;
2841 -> 1578;
2841 -> 1575;
2842 -> 1590;
2843 -> 2842;
2843 -> 1411;
2844 -> 2843;
2844 -> 1413;
2844 -> 1411;
2845 -> 1609;
2846 -> 2845;
2846 -> 1449;
2847 -> 2846;
2847 -> 1451;
2847 -> 1449;
2848 -> 1447;
2848 -> 1479;
2848 -> 1605;
2848 -> 2847;
2848 -> 1614;
2848 -> 1475;
2848 -> 1476;
2848 -> 2833;
2848 -> 1486;
2848 -> 1478;
2849 -> 1629;
2850 -> 2849;
2850 -> 1498;
2851 -> 2850;
2851 -> 1500;
2851 -> 1498;
2852 -> 1496;
2852 -> 1530;
2852 -> 1625;
2852 -> 2851;
2852 -> 1634;
2852 -> 1524;
2852 -> 1525;
2852 -> 2837;
2852 -> 1532;
2852 -> 1529;
2853 -> 1649;
2854 -> 2853;
2854 -> 1544;
2855 -> 2854;
2855 -> 1546;
2855 -> 1544;
2856 -> 1542;
2856 -> 1576;
2856 -> 1645;
2856 -> 2855;
2856 -> 1654;
2856 -> 1570;
2856 -> 1571;
2856 -> 2841;
2856 -> 1578;
2856 -> 1575;
2857 -> 1590;
2858 -> 2857;
2858 -> 1411;
2859 -> 2858;
2859 -> 1413;
2859 -> 1411;
2860 -> 1609;
2861 -> 2860;
2861 -> 1449;
2862 -> 2861;
2862 -> 1451;
2862 -> 1449;
2863 -> 1447;
2863 -> 1479;
2863 -> 1605;
2863 -> 2862;
2863 -> 1614;
2863 -> 1475;
2863 -> 1476;
2863 -> 2848;
2863 -> 1486;
2863 -> 1478;
2864 -> 1629;
2865 -> 2864;
2865 -> 1498;
2866 -> 2865;
2866 -> 1500;
2866 -> 1498;
2867 -> 1496;
2867 -> 1530;
2867 -> 1625;
2867 -> 2866;
2867 -> 1634;
2867 -> 1524;
2867 -> 1525;
2867 -> 2852;
2867 -> 1532;
2867 -> 1529;
2868 -> 1649;
2869 -> 2868;
2869 -> 1544;
2870 -> 2869;
2870 -> 1546;
2870 -> 1544;
2871 -> 1542;
2871 -> 1576;
2871 -> 1645;
2871 -> 2870;
2871 -> 1654;
2871 -> 1570;
2871 -> 1571;
2871 -> 2856;
2871 -> 1578;
2871 -> 1575;
2872 -> 1590;
2873 -> 2872;
2873 -> 1411;
2874 -> 2873;
2874 -> 1413;
2874 -> 1411;
2875 -> 1609;
2876 -> 2875;
2876 -> 1449;
2877 -> 2876;
2877 -> 1451;
2877 -> 1449;
2878 -> 1447;
2878 -> 1479;
2878 -> 1605;
2878 -> 2877;
2878 -> 1614;
2878 -> 1475;
2878 -> 1476;
2878 -> 2863;
2878 -> 1486;
2878 -> 1478;
2879 -> 1629;
2880 -> 2879;
2880 -> 1498;
2881 -> 2880;
2881 -> 1500;
2881 -> 1498;
2882 -> 1496;
2882 -> 1530;
2882 -> 1625;
2882 -> 2881;
2882 -> 1634;
2882 -> 1524;
2882 -> 1525;
2882 -> 2867;
2882 -> 1532;
2882 -> 1529;
2883 -> 1649;
2884 -> 2883;
2884 -> 1544;
2885 -> 2884;
2885 -> 1546;
2885 -> 1544;
2886 -> 1542;
2886 -> 1576;
2886 -> 1645;
2886 -> 2885;
2886 -> 1654;
2886 -> 1570;
2886 -> 1571;
2886 -> 2871;
2886 -> 1578;
2886 -> 1575;
2887 -> 1590;
2888 -> 2887;
2888 -> 1411;
2889 -> 2888;
2889 -> 1413;
2889 -> 1411;
2890 -> 1609;
2891 -> 2890;
2891 -> 1449;
2892 -> 2891;
2892 -> 1451;
2892 -> 1449;
2893 -> 1447;
2893 -> 1479;
2893 -> 1605;
2893 -> 2892;
2893 -> 1614;
2893 -> 1475;
2893 -> 1476;
2893 -> 2878;
2893 -> 1486;
2893 -> 1478;
2894 -> 1629;
2895 -> 2894;
2895 -> 1498;
2896 -> 2895;
2896 -> 1500;
2896 -> 1498;
2897 -> 1496;
2897 -> 1530;
2897 -> 1625;
2897 -> 2896;
2897 -> 1634;
2897 -> 1524;
2897 -> 1525;
2897 -> 2882;
2897 -> 1532;
2897 -> 1529;
2898 -> 1649;
2899 -> 2898;
2899 -> 1544;
2900 -> 2899;
2900 -> 1546;
2900 -> 1544;
2901 -> 1542;
2901 -> 1576;
2901 -> 1645;
2901 -> 2900;
2901 -> 1654;
2901 -> 1570;
2901 -> 1571;
2901 -> 2886;
2901 -> 1578;
2901 -> 1575;
2902 -> 1590;
2903 -> 2902;
2903 -> 1411;
2904 -> 2903;
2904 -> 1413;
2904 -> 1411;
2905 -> 1609;
2906 -> 2905;
2906 -> 1449;
2907 -> 2906;
2907 -> 1451;
2907 -> 1449;
2908 -> 1447;
2908 -> 1479;
2908 -> 1605;
2908 -> 2907;
2908 -> 1614;
2908 -> 1475;
2908 -> 1476;
2908 -> 2893;
2908 -> 1486;
2908 -> 1478;
2909 -> 1629;
2910 -> 2909;
2910 -> 1498;
2911 -> 2910;
2911 -> 1500;
2911 -> 1498;
2912 -> 1496;
2912 -> 1530;
2912 -> 1625;
2912 -> 2911;
2912 -> 1634;
2912 -> 1524;
2912 -> 1525;
2912 -> 2897;
2912 -> 1532;
2912 -> 1529;
2913 -> 1649;
2914 -> 2913;
2914 -> 1544;
2915 -> 2914;
2915 -> 1546;
2915 -> 1544;
2916 -> 1542;
2916 -> 1576;
2916 -> 1645;
2916 -> 2915;
2916 -> 1654;
2916 -> 1570;
2916 -> 1571;
2916 -> 2901;
2916 -> 1578;
2916 -> 1575;
2917 -> 1590;
2918 -> 2917;
2918 -> 1411;
2919 -> 2918;
2919 -> 1413;
2919 -> 1411;
2920 -> 1609;
2921 -> 2920;
2921 -> 1449;
2922 -> 2921;
2922 -> 1451;
2922 -> 1449;
2923 -> 1447;
2923 -> 1479;
2923 -> 1605;
2923 -> 2922;
2923 -> 1614;
2923 -> 1475;
2923 -> 1476;
2923 -> 2908;
2923 -> 1486;
2923 -> 1478;
2924 -> 1629;
2925 -> 2924;
2925 -> 1498;
2926 -> 2925;
2926 -> 1500;
2926 -> 1498;
2927 -> 1496;
2927 -> 1530;
2927 -> 1625;
2927 -> 2926;
2927 -> 1634;
2927 -> 1524;
2927 -> 1525;
2927 -> 2912;
2927 -> 1532;
2927 -> 1529;
2928 -> 1649;
2929 -> 2928;
2929 -> 1544;
2930 -> 2929;
2930 -> 1546;
2930 -> 1544;
2931 -> 1542;
2931 -> 1576;
2931 -> 1645;
2931 -> 2930;
2931 -> 1654;
2931 -> 1570;
2931 -> 1571;
2931 -> 2916;
2931 -> 1578;
2931 -> 1575;
2932 -> 1590;
2933 -> 2932;
2933 -> 1411;
2934 -> 2933;
2934 -> 1413;
2934 -> 1411;
2935 -> 1609;
2936 -> 2935;
2936 -> 1449;
2937 -> 2936;
2937 -> 1451;
2937 -> 1449;
2938 -> 1447;
2938 -> 1479;
2938 -> 1605;
2938 -> 2937;
2938 -> 1614;
2938 -> 1475;
2938 -> 1476;
2938 -> 2923;
2938 -> 1486;
2938 -> 1478;
2939 -> 1629;
2940 -> 2939;
2940 -> 1498;
2941 -> 2940;
2941 -> 1500;
2941 -> 1498;
2942 -> 1496;
2942 -> 1530;
2942 -> 1625;
2942 -> 2941;
2942 -> 1634;
2942 -> 1524;
2942 -> 1525;
2942 -> 2927;
2942 -> 1532;
2942 -> 1529;
2943 -> 1649;
2944 -> 2943;
2944 -> 1544;
2945 -> 2944;
2945 -> 1546;
2945 -> 1544;
2946 -> 1542;
2946 -> 1576;
2946 -> 1645;
2946 -> 2945;
2946 -> 1654;
2946 -> 1570;
2946 -> 1571;
2946 -> 2931;
2946 -> 1578;
2946 -> 1575;
2947 -> 1590;
2948 -> 2947;
2948 -> 1411;
2949 -> 2948;
2949 -> 1413;
2949 -> 1411;
2950 -> 1609;
2951 -> 2950;
2951 -> 1449;
2952 -> 2951;
2952 -> 1451;
2952 -> 1449;
2953 -> 1447;
2953 -> 1479;
2953 -> 1605;
2953 -> 2952;
2953 -> 1614;
2953 -> 1475;
2953 -> 1476;
2953 -> 2938;
2953 -> 1486;
2953 -> 1478;
2954 -> 1629;
2955 -> 2954;
2955 -> 1498;
2956 -> 2955;
2956 -> 1500;
2956 -> 1498;
2957 -> 1496;
2957 -> 1530;
2957 -> 1625;
2957 -> 2956;
2957 -> 1634;
2957 -> 1524;
2957 -> 1525;
2957 -> 2942;
2957 -> 1532;
2957 -> 1529;
2958 -> 1649;
2959 -> 2958;
2959 -> 1544;
2960 -> 2959;
2960 -> 1546;
2960 -> 1544;
2961 -> 1542;
2961 -> 1576;
2961 -> 1645;
2961 -> 2960;
2961 -> 1654;
2961 -> 1570;
2961 -> 1571;
2961 -> 2946;
2961 -> 1578;
2961 -> 1575;
2962 -> 1590;
2963 -> 2962;
2963 -> 1411;
2964 -> 2963;
2964 -> 1413;
2964 -> 1411;
2965 -> 1609;
2966 -> 2965;
2966 -> 1449;
2967 -> 2966;
2967 -> 1451;
2967 -> 1449;
2968 -> 1447;
2968 -> 1479;
2968 -> 1605;
2968 -> 2967;
2968 -> 1614;
2968 -> 1475;
2968 -> 1476;
2968 -> 2953;
2968 -> 1486;
2968 -> 1478;
2969 -> 1629;
2970 -> 2969;
2970 -> 1498;
2971 -> 2970;
2971 -> 1500;
2971 -> 1498;
2972 -> 1496;
2972 -> 1530;
2972 -> 1625;
2972 -> 2971;
2972 -> 1634;
2972 -> 1524;
2972 -> 1525;
2972 -> 2957;
2972 -> 1532;
2972 -> 1529;
2973 -> 1649;
2974 -> 2973;
2974 -> 1544;
2975 -> 2974;
2975 -> 1546;
2975 -> 1544;
2976 -> 1542;
2976 -> 1576;
2976 -> 1645;
2976 -> 2975;
2976 -> 1654;
2976 -> 1570;
2976 -> 1571;
2976 -> 2961;
2976 -> 1578;
2976 -> 1575;
2977 -> 1590;
2978 -> 2977;
2978 -> 1411;
2979 -> 2978;
2979 -> 1413;
2979 -> 1411;
2980 -> 1609;
2981 -> 2980;
2981 -> 1449;
2982 -> 2981;
2982 -> 1451;
2982 -> 1449;
2983 -> 1447;
2983 -> 1479;
2983 -> 1605;
2983 -> 2982;
2983 -> 1614;
2983 -> 1475;
2983 -> 1476;
2983 -> 2968;
2983 -> 1486;
2983 -> 1478;
2984 -> 1629;
2985 -> 2984;
2985 -> 1498;
2986 -> 2985;
2986 -> 1500;
2986 -> 1498;
2987 -> 1496;
2987 -> 1530;
2987 -> 1625;
2987 -> 2986;
2987 -> 1634;
2987 -> 1524;
2987 -> 1525;
2987 -> 2972;
2987 -> 1532;
2987 -> 1529;
2988 -> 1649;
2989 -> 2988;
2989 -> 1544;
2990 -> 2989;
2990 -> 1546;
2990 -> 1544;
2991 -> 1542;
2991 -> 1576;
2991 -> 1645;
2991 -> 2990;
2991 -> 1654;
2991 -> 1570;
2991 -> 1571;
2991 -> 2976;
2991 -> 1578;
2991 -> 1575;
2992 -> 1590;
2993 -> 2992;
2993 -> 1411;
2994 -> 2993;
2994 -> 1413;
2994 -> 1411;
2995 -> 1609;
2996 -> 2995;
2996 -> 1449;
2997 -> 2996;
2997 -> 1451;
2997 -> 1449;
2998 -> 1447;
2998 -> 1479;
2998 -> 1605;
2998 -> 2997;
2998 -> 1614;
2998 -> 1475;
2998 -> 1476;
2998 -> 2983;
2998 -> 1486;
2998 -> 1478;
2999 -> 1629;
3000 -> 2999;
3000 -> 1498;
3001 -> 3000;
3001 -> 1500;
3001 -> 1498;
3002 -> 1496;
3002 -> 1530;
3002 -> 1625;
3002 -> 3001;
3002 -> 1634;
3002 -> 1524;
3002 -> 1525;
3002 -> 2987;
3002 -> 1532;
3002 -> 1529;
3003 -> 1649;
3004 -> 3003;
3004 -> 1544;
3005 -> 3004;
3005 -> 1546;
3005 -> 1544;
3006 -> 1542;
3006 -> 1576;
3006 -> 1645;
3006 -> 3005;
3006 -> 1654;
3006 -> 1570;
3006 -> 1571;
3006 -> 2991;
3006 -> 1578;
3006 -> 1575;
3007 -> 1590;
3008 -> 3007;
3008 -> 1411;
3009 -> 3008;
3009 -> 1413;
3009 -> 1411;
3010 -> 1609;
3011 -> 3010;
3011 -> 1449;
3012 -> 3011;
3012 -> 1451;
3012 -> 1449;
3013 -> 1447;
3013 -> 1479;
3013 -> 1605;
3013 -> 3012;
3013 -> 1614;
3013 -> 1475;
3013 -> 1476;
3013 -> 2998;
3013 -> 1486;
3013 -> 1478;
3014 -> 1629;
3015 -> 3014;
3015 -> 1498;
3016 -> 3015;
3016 -> 1500;
3016 -> 1498;
3017 -> 1496;
3017 -> 1530;
3017 -> 1625;
3017 -> 3016;
3017 -> 1634;
3017 -> 1524;
3017 -> 1525;
3017 -> 3002;
3017 -> 1532;
3017 -> 1529;
3018 -> 1649;
3019 -> 3018;
3019 -> 1544;
3020 -> 3019;
3020 -> 1546;
3020 -> 1544;
3021 -> 1542;
3021 -> 1576;
3021 -> 1645;
3021 -> 3020;
3021 -> 1654;
3021 -> 1570;
3021 -> 1571;
3021 -> 3006;
3021 -> 1578;
3021 -> 1575;
3022 -> 1590;
3023 -> 3022;
3023 -> 1411;
3024 -> 3023;
3024 -> 1413;
3024 -> 1411;
3025 -> 1609;
3026 -> 3025;
3026 -> 1449;
3027 -> 3026;
3027 -> 1451;
3027 -> 1449;
3028 -> 1447;
3028 -> 1479;
3028 -> 1605;
3028 -> 3027;
3028 -> 1614;
3028 -> 1475;
3028 -> 1476;
3028 -> 3013;
3028 -> 1486;
3028 -> 1478;
3029 -> 1629;
3030 -> 3029;
3030 -> 1498;
3031 -> 3030;
3031 -> 1500;
3031 -> 1498;
3032 -> 1496;
3032 -> 1530;
3032 -> 1625;
3032 -> 3031;
3032 -> 1634;
3032 -> 1524;
3032 -> 1525;
3032 -> 3017;
3032 -> 1532;
3032 -> 1529;
3033 -> 1649;
3034 -> 3033;
3034 -> 1544;
3035 -> 3034;
3035 -> 1546;
3035 -> 1544;
3036 -> 1542;
3036 -> 1576;
3036 -> 1645;
3036 -> 3035;
3036 -> 1654;
3036 -> 1570;
3036 -> 1571;
3036 -> 3021;
3036 -> 1578;
3036 -> 1575;
3037 -> 1590;
3038 -> 3037;
3038 -> 1411;
3039 -> 3038;
3039 -> 1413;
3039 -> 1411;
3040 -> 1609;
3041 -> 3040;
3041 -> 1449;
3042 -> 3041;
3042 -> 1451;
3042 -> 1449;
3043 -> 1447;
3043 -> 1479;
3043 -> 1605;
3043 -> 3042;
3043 -> 1614;
3043 -> 1475;
3043 -> 1476;
3043 -> 3028;
3043 -> 1486;
3043 -> 1478;
3044 -> 1629;
3045 -> 3044;
3045 -> 1498;
3046 -> 3045;
3046 -> 1500;
3046 -> 1498;
3047 -> 1496;
3047 -> 1530;
3047 -> 1625;
3047 -> 3046;
3047 -> 1634;
3047 -> 1524;
3047 -> 1525;
3047 -> 3032;
3047 -> 1532;
3047 -> 1529;
3048 -> 1649;
3049 -> 3048;
3049 -> 1544;
3050 -> 3049;
3050 -> 1546;
3050 -> 1544;
3051 -> 1542;
3051 -> 1576;
3051 -> 1645;
3051 -> 3050;
3051 -> 1654;
3051 -> 1570;
3051 -> 1571;
3051 -> 3036;
3051 -> 1578;
3051 -> 1575;
3052 -> 1590;
3053 -> 3052;
3053 -> 1411;
3054 -> 3053;
3054 -> 1413;
3054 -> 1411;
3055 -> 1609;
3056 -> 3055;
3056 -> 1449;
3057 -> 3056;
3057 -> 1451;
3057 -> 1449;
3058 -> 1447;
3058 -> 1479;
3058 -> 1605;
3058 -> 3057;
3058 -> 1614;
3058 -> 1475;
3058 -> 1476;
3058 -> 3043;
3058 -> 1486;
3058 -> 1478;
3059 -> 1629;
3060 -> 3059;
3060 -> 1498;
3061 -> 3060;
3061 -> 1500;
3061 -> 1498;
3062 -> 1496;
3062 -> 1530;
3062 -> 1625;
3062 -> 3061;
3062 -> 1634;
3062 -> 1524;
3062 -> 1525;
3062 -> 3047;
3062 -> 1532;
3062 -> 1529;
3063 -> 1649;
3064 -> 3063;
3064 -> 1544;
3065 -> 3064;
3065 -> 1546;
3065 -> 1544;
3066 -> 1542;
3066 -> 1576;
3066 -> 1645;
3066 -> 3065;
3066 -> 1654;
3066 -> 1570;
3066 -> 1571;
3066 -> 3051;
3066 -> 1578;
3066 -> 1575;
3067 -> 1590;
3068 -> 3067;
3068 -> 1411;
3069 -> 3068;
3069 -> 1413;
3069 -> 1411;
3070 -> 1609;
3071 -> 3070;
3071 -> 1449;
3072 -> 3071;
3072 -> 1451;
3072 -> 1449;
3073 -> 1447;
3073 -> 1479;
3073 -> 1605;
3073 -> 3072;
3073 -> 1614;
3073 -> 1475;
3073 -> 1476;
3073 -> 3058;
3073 -> 1486;
3073 -> 1478;
3074 -> 1629;
3075 -> 3074;
3075 -> 1498;
3076 -> 3075;
3076 -> 1500;
3076 -> 1498;
3077 -> 1496;
3077 -> 1530;
3077 -> 1625;
3077 -> 3076;
3077 -> 1634;
3077 -> 1524;
3077 -> 1525;
3077 -> 3062;
3077 -> 1532;
3077 -> 1529;
3078 -> 1649;
3079 -> 3078;
3079 -> 1544;
3080 -> 3079;
3080 -> 1546;
3080 -> 1544;
3081 -> 1542;
3081 -> 1576;
3081 -> 1645;
3081 -> 3080;
3081 -> 1654;
3081 -> 1570;
3081 -> 1571;
3081 -> 3066;
3081 -> 1578;
3081 -> 1575;
3082 -> 1590;
3083 -> 3082;
3083 -> 1411;
3084 -> 3083;
3084 -> 1413;
3084 -> 1411;
3085 -> 1609;
3086 -> 3085;
3086 -> 1449;
3087 -> 3086;
3087 -> 1451;
3087 -> 1449;
3088 -> 1447;
3088 -> 1479;
3088 -> 1605;
3088 -> 3087;
3088 -> 1614;
3088 -> 1475;
3088 -> 1476;
3088 -> 3073;
3088 -> 1486;
3088 -> 1478;
3089 -> 1629;
3090 -> 3089;
3090 -> 1498;
3091 -> 3090;
3091 -> 1500;
3091 -> 1498;
3092 -> 1496;
3092 -> 1530;
3092 -> 1625;
3092 -> 3091;
3092 -> 1634;
3092 -> 1524;
3092 -> 1525;
3092 -> 3077;
3092 -> 1532;
3092 -> 1529;
3093 -> 1649;
3094 -> 3093;
3094 -> 1544;
3095 -> 3094;
3095 -> 1546;
3095 -> 1544;
3096 -> 1542;
3096 -> 1576;
3096 -> 1645;
3096 -> 3095;
3096 -> 1654;
3096 -> 1570;
3096 -> 1571;
3096 -> 3081;
3096 -> 1578;
3096 -> 1575;
3097 -> 1590;
3098 -> 3097;
3098 -> 1411;
3099 -> 3098;
3099 -> 1413;
3099 -> 1411;
3100 -> 1609;
3101 -> 3100;
3101 -> 1449;
3102 -> 3101;
3102 -> 1451;
3102 -> 1449;
3103 -> 1447;
3103 -> 1479;
3103 -> 1605;
3103 -> 3102;
3103 -> 1614;
3103 -> 1475;
3103 -> 1476;
3103 -> 3088;
3103 -> 1486;
3103 -> 1478;
3104 -> 1629;
3105 -> 3104;
3105 -> 1498;
3106 -> 3105;
3106 -> 1500;
3106 -> 1498;
3107 -> 1496;
3107 -> 1530;
3107 -> 1625;
3107 -> 3106;
3107 -> 1634;
3107 -> 1524;
3107 -> 1525;
3107 -> 3092;
3107 -> 1532;
3107 -> 1529;
3108 -> 1649;
3109 -> 3108;
3109 -> 1544;
3110 -> 3109;
3110 -> 1546;
3110 -> 1544;
3111 -> 1542;
3111 -> 1576;
3111 -> 1645;
3111 -> 3110;
3111 -> 1654;
3111 -> 1570;
3111 -> 1571;
3111 -> 3096;
3111 -> 1578;
3111 -> 1575;
3112 -> 1590;
3113 -> 3112;
3113 -> 1411;
3114 -> 3113;
3114 -> 1413;
3114 -> 1411;
3115 -> 1609;
3116 -> 3115;
3116 -> 1449;
3117 -> 3116;
3117 -> 1451;
3117 -> 1449;
3118 -> 1447;
3118 -> 1479;
3118 -> 1605;
3118 -> 3117;
3118 -> 1614;
3118 -> 1475;
3118 -> 1476;
3118 -> 3103;
3118 -> 1486;
3118 -> 1478;
3119 -> 1629;
3120 -> 3119;
3120 -> 1498;
3121 -> 3120;
3121 -> 1500;
3121 -> 1498;
3122 -> 1496;
3122 -> 1530;
3122 -> 1625;
3122 -> 3121;
3122 -> 1634;
3122 -> 1524;
3122 -> 1525;
3122 -> 3107;
3122 -> 1532;
3122 -> 1529;
3123 -> 1649;
3124 -> 3123;
3124 -> 1544;
3125 -> 3124;
3125 -> 1546;
3125 -> 1544;
3126 -> 1542;
3126 -> 1576;
3126 -> 1645;
3126 -> 3125;
3126 -> 1654;
3126 -> 1570;
3126 -> 1571;
3126 -> 3111;
3126 -> 1578;
3126 -> 1575;
3127 -> 1590;
3128 -> 3127;
3128 -> 1411;
3129 -> 3128;
3129 -> 1413;
3129 -> 1411;
3130 -> 1609;
3131 -> 3130;
3131 -> 1449;
3132 -> 3131;
3132 -> 1451;
3132 -> 1449;
3133 -> 1447;
3133 -> 1479;
3133 -> 1605;
3133 -> 3132;
3133 -> 1614;
3133 -> 1475;
3133 -> 1476;
3133 -> 3118;
3133 -> 1486;
3133 -> 1478;
3134 -> 1629;
3135 -> 3134;
3135 -> 1498;
3136 -> 3135;
3136 -> 1500;
3136 -> 1498;
3137 -> 1496;
3137 -> 1530;
3137 -> 1625;
3137 -> 3136;
3137 -> 1634;
3137 -> 1524;
3137 -> 1525;
3137 -> 3122;
3137 -> 1532;
3137 -> 1529;
3138 -> 1649;
3139 -> 3138;
3139 -> 1544;
3140 -> 3139;
3140 -> 1546;
3140 -> 1544;
3141 -> 1542;
3141 -> 1576;
3141 -> 1645;
3141 -> 3140;
3141 -> 1654;
3141 -> 1570;
3141 -> 1571;
3141 -> 3126;
3141 -> 1578;
3141 -> 1575;
3142 -> 1590;
3143 -> 3142;
3143 -> 1411;
3144 -> 3143;
3144 -> 1413;
3144 -> 1411;
3145 -> 1609;
3146 -> 3145;
3146 -> 1449;
3147 -> 3146;
3147 -> 1451;
3147 -> 1449;
3148 -> 1447;
3148 -> 1479;
3148 -> 1605;
3148 -> 3147;
3148 -> 1614;
3148 -> 1475;
3148 -> 1476;
3148 -> 3133;
3148 -> 1486;
3148 -> 1478;
3149 -> 1629;
3150 -> 3149;
3150 -> 1498;
3151 -> 3150;
3151 -> 1500;
3151 -> 1498;
3152 -> 1496;
3152 -> 1530;
3152 -> 1625;
3152 -> 3151;
3152 -> 1634;
3152 -> 1524;
3152 -> 1525;
3152 -> 3137;
3152 -> 1532;
3152 -> 1529;
3153 -> 1649;
3154 -> 3153;
3154 -> 1544;
3155 -> 3154;
3155 -> 1546;
3155 -> 1544;
3156 -> 1542;
3156 -> 1576;
3156 -> 1645;
3156 -> 3155;
3156 -> 1654;
3156 -> 1570;
3156 -> 1571;
3156 -> 3141;
3156 -> 1578;
3156 -> 1575;
3157 -> 1590;
3158 -> 3157;
3158 -> 1411;
3159 -> 3158;
3159 -> 1413;
3159 -> 1411;
3160 -> 1609;
3161 -> 3160;
3161 -> 1449;
3162 -> 3161;
3162 -> 1451;
3162 -> 1449;
3163 -> 1447;
3163 -> 1479;
3163 -> 1605;
3163 -> 3162;
3163 -> 1614;
3163 -> 1475;
3163 -> 1476;
3163 -> 3148;
3163 -> 1486;
3163 -> 1478;
3164 -> 1629;
3165 -> 3164;
3165 -> 1498;
3166 -> 3165;
3166 -> 1500;
3166 -> 1498;
3167 -> 1496;
3167 -> 1530;
3167 -> 1625;
3167 -> 3166;
3167 -> 1634;
3167 -> 1524;
3167 -> 1525;
3167 -> 3152;
3167 -> 1532;
3167 -> 1529;
3168 -> 1649;
3169 -> 3168;
3169 -> 1544;
3170 -> 3169;
3170 -> 1546;
3170 -> 1544;
3171 -> 1542;
3171 -> 1576;
3171 -> 1645;
3171 -> 3170;
3171 -> 1654;
3171 -> 1570;
3171 -> 1571;
3171 -> 3156;
3171 -> 1578;
3171 -> 1575;
3172 -> 1590;
3173 -> 3172;
3173 -> 1411;
3174 -> 3173;
3174 -> 1413;
3174 -> 1411;
3175 -> 1609;
3176 -> 3175;
3176 -> 1449;
3177 -> 3176;
3177 -> 1451;
3177 -> 1449;
3178 -> 1447;
3178 -> 1479;
3178 -> 1605;
3178 -> 3177;
3178 -> 1614;
3178 -> 1475;
3178 -> 1476;
3178 -> 3163;
3178 -> 1486;
3178 -> 1478;
3179 -> 1629;
3180 -> 3179;
3180 -> 1498;
3181 -> 3180;
3181 -> 1500;
3181 -> 1498;
3182 -> 1496;
3182 -> 1530;
3182 -> 1625;
3182 -> 3181;
3182 -> 1634;
3182 -> 1524;
3182 -> 1525;
3182 -> 3167;
3182 -> 1532;
3182 -> 1529;
3183 -> 1649;
3184 -> 3183;
3184 -> 1544;
3185 -> 3184;
3185 -> 1546;
3185 -> 1544;
3186 -> 1542;
3186 -> 1576;
3186 -> 1645;
3186 -> 3185;
3186 -> 1654;
3186 -> 1570;
3186 -> 1571;
3186 -> 3171;
3186 -> 1578;
3186 -> 1575;
3187 -> 1590;
3188 -> 3187;
3188 -> 1411;
3189 -> 3188;
3189 -> 1413;
3189 -> 1411;
3190 -> 1609;
3191 -> 3190;
3191 -> 1449;
3192 -> 3191;
3192 -> 1451;
3192 -> 1449;
3193 -> 1447;
3193 -> 1479;
3193 -> 1605;
3193 -> 3192;
3193 -> 1614;
3193 -> 1475;
3193 -> 1476;
3193 -> 3178;
3193 -> 1486;
3193 -> 1478;
3194 -> 1629;
3195 -> 3194;
3195 -> 1498;
3196 -> 3195;
3196 -> 1500;
3196 -> 1498;
3197 -> 1496;
3197 -> 1530;
3197 -> 1625;
3197 -> 3196;
3197 -> 1634;
3197 -> 1524;
3197 -> 1525;
3197 -> 3182;
3197 -> 1532;
3197 -> 1529;
3198 -> 1649;
3199 -> 3198;
3199 -> 1544;
3200 -> 3199;
3200 -> 1546;
3200 -> 1544;
3201 -> 1542;
3201 -> 1576;
3201 -> 1645;
3201 -> 3200;
3201 -> 1654;
3201 -> 1570;
3201 -> 1571;
3201 -> 3186;
3201 -> 1578;
3201 -> 1575;
3202 -> 1590;
3203 -> 3202;
3203 -> 1411;
3204 -> 3203;
3204 -> 1413;
3204 -> 1411;
3205 -> 1609;
3206 -> 3205;
3206 -> 1449;
3207 -> 3206;
3207 -> 1451;
3207 -> 1449;
3208 -> 1447;
3208 -> 1479;
3208 -> 1605;
3208 -> 3207;
3208 -> 1614;
3208 -> 1475;
3208 -> 1476;
3208 -> 3193;
3208 -> 1486;
3208 -> 1478;
3209 -> 1629;
3210 -> 3209;
3210 -> 1498;
3211 -> 3210;
3211 -> 1500;
3211 -> 1498;
3212 -> 1496;
3212 -> 1530;
3212 -> 1625;
3212 -> 3211;
3212 -> 1634;
3212 -> 1524;
3212 -> 1525;
3212 -> 3197;
3212 -> 1532;
3212 -> 1529;
3213 -> 1649;
3214 -> 3213;
3214 -> 1544;
3215 -> 3214;
3215 -> 1546;
3215 -> 1544;
3216 -> 1542;
3216 -> 1576;
3216 -> 1645;
3216 -> 3215;
3216 -> 1654;
3216 -> 1570;
3216 -> 1571;
3216 -> 3201;
3216 -> 1578;
3216 -> 1575;
3217 -> 1590;
3218 -> 3217;
3218 -> 1411;
3219 -> 3218;
3219 -> 1413;
3219 -> 1411;
3220 -> 1609;
3221 -> 3220;
3221 -> 1449;
3222 -> 3221;
3222 -> 1451;
3222 -> 1449;
3223 -> 1447;
3223 -> 1479;
3223 -> 1605;
3223 -> 3222;
3223 -> 1614;
3223 -> 1475;
3223 -> 1476;
3223 -> 3208;
3223 -> 1486;
3223 -> 1478;
3224 -> 1629;
3225 -> 3224;
3225 -> 1498;
3226 -> 3225;
3226 -> 1500;
3226 -> 1498;
3227 -> 1496;
3227 -> 1530;
3227 -> 1625;
3227 -> 3226;
3227 -> 1634;
3227 -> 1524;
3227 -> 1525;
3227 -> 3212;
3227 -> 1532;
3227 -> 1529;
3228 -> 1649;
3229 -> 3228;
3229 -> 1544;
3230 -> 3229;
3230 -> 1546;
3230 -> 1544;
3231 -> 1542;
3231 -> 1576;
3231 -> 1645;
3231 -> 3230;
3231 -> 1654;
3231 -> 1570;
3231 -> 1571;
3231 -> 3216;
3231 -> 1578;
3231 -> 1575;
3232 -> 1590;
3233 -> 3232;
3233 -> 1411;
3234 -> 3233;
3234 -> 1413;
3234 -> 1411;
3235 -> 1609;
3236 -> 3235;
3236 -> 1449;
3237 -> 3236;
3237 -> 1451;
3237 -> 1449;
3238 -> 1447;
3238 -> 1479;
3238 -> 1605;
3238 -> 3237;
3238 -> 1614;
3238 -> 1475;
3238 -> 1476;
3238 -> 3223;
3238 -> 1486;
3238 -> 1478;
3239 -> 1629;
3240 -> 3239;
3240 -> 1498;
3241 -> 3240;
3241 -> 1500;
3241 -> 1498;
3242 -> 1496;
3242 -> 1530;
3242 -> 1625;
3242 -> 3241;
3242 -> 1634;
3242 -> 1524;
3242 -> 1525;
3242 -> 3227;
3242 -> 1532;
3242 -> 1529;
3243 -> 1649;
3244 -> 3243;
3244 -> 1544;
3245 -> 3244;
3245 -> 1546;
3245 -> 1544;
3246 -> 1542;
3246 -> 1576;
3246 -> 1645;
3246 -> 3245;
3246 -> 1654;
3246 -> 1570;
3246 -> 1571;
3246 -> 3231;
3246 -> 1578;
3246 -> 1575;
3247 -> 1590;
3248 -> 3247;
3248 -> 1411;
3249 -> 3248;
3249 -> 1413;
3249 -> 1411;
3250 -> 1609;
3251 -> 3250;
3251 -> 1449;
3252 -> 3251;
3252 -> 1451;
3252 -> 1449;
3253 -> 1447;
3253 -> 1479;
3253 -> 1605;
3253 -> 3252;
3253 -> 1614;
3253 -> 1475;
3253 -> 1476;
3253 -> 3238;
3253 -> 1486;
3253 -> 1478;
3254 -> 1629;
3255 -> 3254;
3255 -> 1498;
3256 -> 3255;
3256 -> 1500;
3256 -> 1498;
3257 -> 1496;
3257 -> 1530;
3257 -> 1625;
3257 -> 3256;
3257 -> 1634;
3257 -> 1524;
3257 -> 1525;
3257 -> 3242;
3257 -> 1532;
3257 -> 1529;
3258 -> 1649;
3259 -> 3258;
3259 -> 1544;
3260 -> 3259;
3260 -> 1546;
3260 -> 1544;
3261 -> 1542;
3261 -> 1576;
3261 -> 1645;
3261 -> 3260;
3261 -> 1654;
3261 -> 1570;
3261 -> 1571;
3261 -> 3246;
3261 -> 1578;
3261 -> 1575;
3262 -> 1590;
3263 -> 3262;
3263 -> 1411;
3264 -> 3263;
3264 -> 1413;
3264 -> 1411;
3265 -> 1609;
3266 -> 3265;
3266 -> 1449;
3267 -> 3266;
3267 -> 1451;
3267 -> 1449;
3268 -> 1447;
3268 -> 1479;
3268 -> 1605;
3268 -> 3267;
3268 -> 1614;
3268 -> 1475;
3268 -> 1476;
3268 -> 3253;
3268 -> 1486;
3268 -> 1478;
3269 -> 1629;
3270 -> 3269;
3270 -> 1498;
3271 -> 3270;
3271 -> 1500;
3271 -> 1498;
3272 -> 1496;
3272 -> 1530;
3272 -> 1625;
3272 -> 3271;
3272 -> 1634;
3272 -> 1524;
3272 -> 1525;
3272 -> 3257;
3272 -> 1532;
3272 -> 1529;
3273 -> 1649;
3274 -> 3273;
3274 -> 1544;
3275 -> 3274;
3275 -> 1546;
3275 -> 1544;
3276 -> 1542;
3276 -> 1576;
3276 -> 1645;
3276 -> 3275;
3276 -> 1654;
3276 -> 1570;
3276 -> 1571;
3276 -> 3261;
3276 -> 1578;
3276 -> 1575;
3277 -> 1590;
3278 -> 3277;
3278 -> 1411;
3279 -> 3278;
3279 -> 1413;
3279 -> 1411;
3280 -> 1609;
3281 -> 3280;
3281 -> 1449;
3282 -> 3281;
3282 -> 1451;
3282 -> 1449;
3283 -> 1447;
3283 -> 1479;
3283 -> 1605;
3283 -> 3282;
3283 -> 1614;
3283 -> 1475;
3283 -> 1476;
3283 -> 3268;
3283 -> 1486;
3283 -> 1478;
3284 -> 1629;
3285 -> 3284;
3285 -> 1498;
3286 -> 3285;
3286 -> 1500;
3286 -> 1498;
3287 -> 1496;
3287 -> 1530;
3287 -> 1625;
3287 -> 3286;
3287 -> 1634;
3287 -> 1524;
3287 -> 1525;
3287 -> 3272;
3287 -> 1532;
3287 -> 1529;
3288 -> 1649;
3289 -> 3288;
3289 -> 1544;
3290 -> 3289;
3290 -> 1546;
3290 -> 1544;
3291 -> 1542;
3291 -> 1576;
3291 -> 1645;
3291 -> 3290;
3291 -> 1654;
3291 -> 1570;
3291 -> 1571;
3291 -> 3276;
3291 -> 1578;
3291 -> 1575;
3292 -> 1590;
3293 -> 3292;
3293 -> 1411;
3294 -> 3293;
3294 -> 1413;
3294 -> 1411;
3295 -> 1609;
3296 -> 3295;
3296 -> 1449;
3297 -> 3296;
3297 -> 1451;
3297 -> 1449;
3298 -> 1447;
3298 -> 1479;
3298 -> 1605;
3298 -> 3297;
3298 -> 1614;
3298 -> 1475;
3298 -> 1476;
3298 -> 3283;
3298 -> 1486;
3298 -> 1478;
3299 -> 1629;
3300 -> 3299;
3300 -> 1498;
3301 -> 3300;
3301 -> 1500;
3301 -> 1498;
3302 -> 1496;
3302 -> 1530;
3302 -> 1625;
3302 -> 3301;
3302 -> 1634;
3302 -> 1524;
3302 -> 1525;
3302 -> 3287;
3302 -> 1532;
3302 -> 1529;
3303 -> 1649;
3304 -> 3303;
3304 -> 1544;
3305 -> 3304;
3305 -> 1546;
3305 -> 1544;
3306 -> 1542;
3306 -> 1576;
3306 -> 1645;
3306 -> 3305;
3306 -> 1654;
3306 -> 1570;
3306 -> 1571;
3306 -> 3291;
3306 -> 1578;
3306 -> 1575;
3307 -> 1590;
3308 -> 3307;
3308 -> 1411;
3309 -> 3308;
3309 -> 1413;
3309 -> 1411;
3310 -> 1609;
3311 -> 3310;
3311 -> 1449;
3312 -> 3311;
3312 -> 1451;
3312 -> 1449;
3313 -> 1447;
3313 -> 1479;
3313 -> 1605;
3313 -> 3312;
3313 -> 1614;
3313 -> 1475;
3313 -> 1476;
3313 -> 3298;
3313 -> 1486;
3313 -> 1478;
3314 -> 1629;
3315 -> 3314;
3315 -> 1498;
3316 -> 3315;
3316 -> 1500;
3316 -> 1498;
3317 -> 1496;
3317 -> 1530;
3317 -> 1625;
3317 -> 3316;
3317 -> 1634;
3317 -> 1524;
3317 -> 1525;
3317 -> 3302;
3317 -> 1532;
3317 -> 1529;
3318 -> 1649;
3319 -> 3318;
3319 -> 1544;
3320 -> 3319;
3320 -> 1546;
3320 -> 1544;
3321 -> 1542;
3321 -> 1576;
3321 -> 1645;
3321 -> 3320;
3321 -> 1654;
3321 -> 1570;
3321 -> 1571;
3321 -> 3306;
3321 -> 1578;
3321 -> 1575;
3322 -> 1590;
3323 -> 3322;
3323 -> 1411;
3324 -> 3323;
3324 -> 1413;
3324 -> 1411;
3325 -> 1609;
3326 -> 3325;
3326 -> 1449;
3327 -> 3326;
3327 -> 1451;
3327 -> 1449;
3328 -> 1447;
3328 -> 1479;
3328 -> 1605;
3328 -> 3327;
3328 -> 1614;
3328 -> 1475;
3328 -> 1476;
3328 -> 3313;
3328 -> 1486;
3328 -> 1478;
3329 -> 1629;
3330 -> 3329;
3330 -> 1498;
3331 -> 3330;
3331 -> 1500;
3331 -> 1498;
3332 -> 1496;
3332 -> 1530;
3332 -> 1625;
3332 -> 3331;
3332 -> 1634;
3332 -> 1524;
3332 -> 1525;
3332 -> 3317;
3332 -> 1532;
3332 -> 1529;
3333 -> 1649;
3334 -> 3333;
3334 -> 1544;
3335 -> 3334;
3335 -> 1546;
3335 -> 1544;
3336 -> 1542;
3336 -> 1576;
3336 -> 1645;
3336 -> 3335;
3336 -> 1654;
3336 -> 1570;
3336 -> 1571;
3336 -> 3321;
3336 -> 1578;
3336 -> 1575;
3337 -> 1590;
3338 -> 3337;
3338 -> 1411;
3339 -> 3338;
3339 -> 1413;
3339 -> 1411;
3340 -> 1609;
3341 -> 3340;
3341 -> 1449;
3342 -> 3341;
3342 -> 1451;
3342 -> 1449;
3343 -> 1447;
3343 -> 1479;
3343 -> 1605;
3343 -> 3342;
3343 -> 1614;
3343 -> 1475;
3343 -> 1476;
3343 -> 3328;
3343 -> 1486;
3343 -> 1478;
3344 -> 1629;
3345 -> 3344;
3345 -> 1498;
3346 -> 3345;
3346 -> 1500;
3346 -> 1498;
3347 -> 1496;
3347 -> 1530;
3347 -> 1625;
3347 -> 3346;
3347 -> 1634;
3347 -> 1524;
3347 -> 1525;
3347 -> 3332;
3347 -> 1532;
3347 -> 1529;
3348 -> 1649;
3349 -> 3348;
3349 -> 1544;
3350 -> 3349;
3350 -> 1546;
3350 -> 1544;
3351 -> 1542;
3351 -> 1576;
3351 -> 1645;
3351 -> 3350;
3351 -> 1654;
3351 -> 1570;
3351 -> 1571;
3351 -> 3336;
3351 -> 1578;
3351 -> 1575;
3352 -> 1590;
3353 -> 3352;
3353 -> 1411;
3354 -> 3353;
3354 -> 1413;
3354 -> 1411;
3355 -> 1609;
3356 -> 3355;
3356 -> 1449;
3357 -> 3356;
3357 -> 1451;
3357 -> 1449;
3358 -> 1447;
3358 -> 1479;
3358 -> 1605;
3358 -> 3357;
3358 -> 1614;
3358 -> 1475;
3358 -> 1476;
3358 -> 3343;
3358 -> 1486;
3358 -> 1478;
3359 -> 1629;
3360 -> 3359;
3360 -> 1498;
3361 -> 3360;
3361 -> 1500;
3361 -> 1498;
3362 -> 1496;
3362 -> 1530;
3362 -> 1625;
3362 -> 3361;
3362 -> 1634;
3362 -> 1524;
3362 -> 1525;
3362 -> 3347;
3362 -> 1532;
3362 -> 1529;
3363 -> 1649;
3364 -> 3363;
3364 -> 1544;
3365 -> 3364;
3365 -> 1546;
3365 -> 1544;
3366 -> 1542;
3366 -> 1576;
3366 -> 1645;
3366 -> 3365;
3366 -> 1654;
3366 -> 1570;
3366 -> 1571;
3366 -> 3351;
3366 -> 1578;
3366 -> 1575;
3367 -> 1590;
3368 -> 3367;
3368 -> 1411;
3369 -> 3368;
3369 -> 1413;
3369 -> 1411;
3370 -> 1609;
3371 -> 3370;
3371 -> 1449;
3372 -> 3371;
3372 -> 1451;
3372 -> 1449;
3373 -> 1447;
3373 -> 1479;
3373 -> 1605;
3373 -> 3372;
3373 -> 1614;
3373 -> 1475;
3373 -> 1476;
3373 -> 3358;
3373 -> 1486;
3373 -> 1478;
3374 -> 1629;
3375 -> 3374;
3375 -> 1498;
3376 -> 3375;
3376 -> 1500;
3376 -> 1498;
3377 -> 1496;
3377 -> 1530;
3377 -> 1625;
3377 -> 3376;
3377 -> 1634;
3377 -> 1524;
3377 -> 1525;
3377 -> 3362;
3377 -> 1532;
3377 -> 1529;
3378 -> 1649;
3379 -> 3378;
3379 -> 1544;
3380 -> 3379;
3380 -> 1546;
3380 -> 1544;
3381 -> 1542;
3381 -> 1576;
3381 -> 1645;
3381 -> 3380;
3381 -> 1654;
3381 -> 1570;
3381 -> 1571;
3381 -> 3366;
3381 -> 1578;
3381 -> 1575;
3382 -> 1590;
3383 -> 3382;
3383 -> 1411;
3384 -> 3383;
3384 -> 1413;
3384 -> 1411;
3385 -> 1609;
3386 -> 3385;
3386 -> 1449;
3387 -> 3386;
3387 -> 1451;
3387 -> 1449;
3388 -> 1447;
3388 -> 1479;
3388 -> 1605;
3388 -> 3387;
3388 -> 1614;
3388 -> 1475;
3388 -> 1476;
3388 -> 3373;
3388 -> 1486;
3388 -> 1478;
3389 -> 1629;
3390 -> 3389;
3390 -> 1498;
3391 -> 3390;
3391 -> 1500;
3391 -> 1498;
3392 -> 1496;
3392 -> 1530;
3392 -> 1625;
3392 -> 3391;
3392 -> 1634;
3392 -> 1524;
3392 -> 1525;
3392 -> 3377;
3392 -> 1532;
3392 -> 1529;
3393 -> 1649;
3394 -> 3393;
3394 -> 1544;
3395 -> 3394;
3395 -> 1546;
3395 -> 1544;
3396 -> 1542;
3396 -> 1576;
3396 -> 1645;
3396 -> 3395;
3396 -> 1654;
3396 -> 1570;
3396 -> 1571;
3396 -> 3381;
3396 -> 1578;
3396 -> 1575;
3397 -> 1590;
3398 -> 3397;
3398 -> 1411;
3399 -> 3398;
3399 -> 1413;
3399 -> 1411;
3400 -> 1609;
3401 -> 3400;
3401 -> 1449;
3402 -> 3401;
3402 -> 1451;
3402 -> 1449;
3403 -> 1447;
3403 -> 1479;
3403 -> 1605;
3403 -> 3402;
3403 -> 1614;
3403 -> 1475;
3403 -> 1476;
3403 -> 3388;
3403 -> 1486;
3403 -> 1478;
3404 -> 1629;
3405 -> 3404;
3405 -> 1498;
3406 -> 3405;
3406 -> 1500;
3406 -> 1498;
3407 -> 1496;
3407 -> 1530;
3407 -> 1625;
3407 -> 3406;
3407 -> 1634;
3407 -> 1524;
3407 -> 1525;
3407 -> 3392;
3407 -> 1532;
3407 -> 1529;
3408 -> 1649;
3409 -> 3408;
3409 -> 1544;
3410 -> 3409;
3410 -> 1546;
3410 -> 1544;
3411 -> 1542;
3411 -> 1576;
3411 -> 1645;
3411 -> 3410;
3411 -> 1654;
3411 -> 1570;
3411 -> 1571;
3411 -> 3396;
3411 -> 1578;
3411 -> 1575;
3412 -> 1590;
3413 -> 3412;
3413 -> 1411;
3414 -> 3413;
3414 -> 1413;
3414 -> 1411;
3415 -> 1609;
3416 -> 3415;
3416 -> 1449;
3417 -> 3416;
3417 -> 1451;
3417 -> 1449;
3418 -> 1447;
3418 -> 1479;
3418 -> 1605;
3418 -> 3417;
3418 -> 1614;
3418 -> 1475;
3418 -> 1476;
3418 -> 3403;
3418 -> 1486;
3418 -> 1478;
3419 -> 1629;
3420 -> 3419;
3420 -> 1498;
3421 -> 3420;
3421 -> 1500;
3421 -> 1498;
3422 -> 1496;
3422 -> 1530;
3422 -> 1625;
3422 -> 3421;
3422 -> 1634;
3422 -> 1524;
3422 -> 1525;
3422 -> 3407;
3422 -> 1532;
3422 -> 1529;
3423 -> 1649;
3424 -> 3423;
3424 -> 1544;
3425 -> 3424;
3425 -> 1546;
3425 -> 1544;
3426 -> 1542;
3426 -> 1576;
3426 -> 1645;
3426 -> 3425;
3426 -> 1654;
3426 -> 1570;
3426 -> 1571;
3426 -> 3411;
3426 -> 1578;
3426 -> 1575;
3427 -> 1590;
3428 -> 3427;
3428 -> 1411;
3429 -> 3428;
3429 -> 1413;
3429 -> 1411;
3430 -> 1609;
3431 -> 3430;
3431 -> 1449;
3432 -> 3431;
3432 -> 1451;
3432 -> 1449;
3433 -> 1447;
3433 -> 1479;
3433 -> 1605;
3433 -> 3432;
3433 -> 1614;
3433 -> 1475;
3433 -> 1476;
3433 -> 3418;
3433 -> 1486;
3433 -> 1478;
3434 -> 1629;
3435 -> 3434;
3435 -> 1498;
3436 -> 3435;
3436 -> 1500;
3436 -> 1498;
3437 -> 1496;
3437 -> 1530;
3437 -> 1625;
3437 -> 3436;
3437 -> 1634;
3437 -> 1524;
3437 -> 1525;
3437 -> 3422;
3437 -> 1532;
3437 -> 1529;
3438 -> 1649;
3439 -> 3438;
3439 -> 1544;
3440 -> 3439;
3440 -> 1546;
3440 -> 1544;
3441 -> 1542;
3441 -> 1576;
3441 -> 1645;
3441 -> 3440;
3441 -> 1654;
3441 -> 1570;
3441 -> 1571;
3441 -> 3426;
3441 -> 1578;
3441 -> 1575;
3442 -> 1590;
3443 -> 3442;
3443 -> 1411;
3444 -> 3443;
3444 -> 1413;
3444 -> 1411;
3445 -> 1609;
3446 -> 3445;
3446 -> 1449;
3447 -> 3446;
3447 -> 1451;
3447 -> 1449;
3448 -> 1447;
3448 -> 1479;
3448 -> 1605;
3448 -> 3447;
3448 -> 1614;
3448 -> 1475;
3448 -> 1476;
3448 -> 3433;
3448 -> 1486;
3448 -> 1478;
3449 -> 1629;
3450 -> 3449;
3450 -> 1498;
3451 -> 3450;
3451 -> 1500;
3451 -> 1498;
3452 -> 1496;
3452 -> 1530;
3452 -> 1625;
3452 -> 3451;
3452 -> 1634;
3452 -> 1524;
3452 -> 1525;
3452 -> 3437;
3452 -> 1532;
3452 -> 1529;
3453 -> 1649;
3454 -> 3453;
3454 -> 1544;
3455 -> 3454;
3455 -> 1546;
3455 -> 1544;
3456 -> 1542;
3456 -> 1576;
3456 -> 1645;
3456 -> 3455;
3456 -> 1654;
3456 -> 1570;
3456 -> 1571;
3456 -> 3441;
3456 -> 1578;
3456 -> 1575;
3457 -> 1590;
3458 -> 3457;
3458 -> 1411;
3459 -> 3458;
3459 -> 1413;
3459 -> 1411;
3460 -> 1609;
3461 -> 3460;
3461 -> 1449;
3462 -> 3461;
3462 -> 1451;
3462 -> 1449;
3463 -> 1447;
3463 -> 1479;
3463 -> 1605;
3463 -> 3462;
3463 -> 1614;
3463 -> 1475;
3463 -> 1476;
3463 -> 3448;
3463 -> 1486;
3463 -> 1478;
3464 -> 1629;
3465 -> 3464;
3465 -> 1498;
3466 -> 3465;
3466 -> 1500;
3466 -> 1498;
3467 -> 1496;
3467 -> 1530;
3467 -> 1625;
3467 -> 3466;
3467 -> 1634;
3467 -> 1524;
3467 -> 1525;
3467 -> 3452;
3467 -> 1532;
3467 -> 1529;
3468 -> 1649;
3469 -> 3468;
3469 -> 1544;
3470 -> 3469;
3470 -> 1546;
3470 -> 1544;
3471 -> 1542;
3471 -> 1576;
3471 -> 1645;
3471 -> 3470;
3471 -> 1654;
3471 -> 1570;
3471 -> 1571;
3471 -> 3456;
3471 -> 1578;
3471 -> 1575;
3472 -> 1590;
3473 -> 3472;
3473 -> 1411;
3474 -> 3473;
3474 -> 1413;
3474 -> 1411;
3475 -> 1609;
3476 -> 3475;
3476 -> 1449;
3477 -> 3476;
3477 -> 1451;
3477 -> 1449;
3478 -> 1447;
3478 -> 1479;
3478 -> 1605;
3478 -> 3477;
3478 -> 1614;
3478 -> 1475;
3478 -> 1476;
3478 -> 3463;
3478 -> 1486;
3478 -> 1478;
3479 -> 1629;
3480 -> 3479;
3480 -> 1498;
3481 -> 3480;
3481 -> 1500;
3481 -> 1498;
3482 -> 1496;
3482 -> 1530;
3482 -> 1625;
3482 -> 3481;
3482 -> 1634;
3482 -> 1524;
3482 -> 1525;
3482 -> 3467;
3482 -> 1532;
3482 -> 1529;
3483 -> 1649;
3484 -> 3483;
3484 -> 1544;
3485 -> 3484;
3485 -> 1546;
3485 -> 1544;
3486 -> 1542;
3486 -> 1576;
3486 -> 1645;
3486 -> 3485;
3486 -> 1654;
3486 -> 1570;
3486 -> 1571;
3486 -> 3471;
3486 -> 1578;
3486 -> 1575;
3487 -> 1590;
3488 -> 3487;
3488 -> 1411;
3489 -> 3488;
3489 -> 1413;
3489 -> 1411;
3490 -> 1609;
3491 -> 3490;
3491 -> 1449;
3492 -> 3491;
3492 -> 1451;
3492 -> 1449;
3493 -> 1447;
3493 -> 1479;
3493 -> 1605;
3493 -> 3492;
3493 -> 1614;
3493 -> 1475;
3493 -> 1476;
3493 -> 3478;
3493 -> 1486;
3493 -> 1478;
3494 -> 1629;
3495 -> 3494;
3495 -> 1498;
3496 -> 3495;
3496 -> 1500;
3496 -> 1498;
3497 -> 1496;
3497 -> 1530;
3497 -> 1625;
3497 -> 3496;
3497 -> 1634;
3497 -> 1524;
3497 -> 1525;
3497 -> 3482;
3497 -> 1532;
3497 -> 1529;
3498 -> 1649;
3499 -> 3498;
3499 -> 1544;
3500 -> 3499;
3500 -> 1546;
3500 -> 1544;
3501 -> 1542;
3501 -> 1576;
3501 -> 1645;
3501 -> 3500;
3501 -> 1654;
3501 -> 1570;
3501 -> 1571;
3501 -> 3486;
3501 -> 1578;
3501 -> 1575;
3502 -> 1590;
3503 -> 3502;
3503 -> 1411;
3504 -> 3503;
3504 -> 1413;
3504 -> 1411;
3505 -> 1609;
3506 -> 3505;
3506 -> 1449;
3507 -> 3506;
3507 -> 1451;
3507 -> 1449;
3508 -> 1447;
3508 -> 1479;
3508 -> 1605;
3508 -> 3507;
3508 -> 1614;
3508 -> 1475;
3508 -> 1476;
3508 -> 3493;
3508 -> 1486;
3508 -> 1478;
3509 -> 1629;
3510 -> 3509;
3510 -> 1498;
3511 -> 3510;
3511 -> 1500;
3511 -> 1498;
3512 -> 1496;
3512 -> 1530;
3512 -> 1625;
3512 -> 3511;
3512 -> 1634;
3512 -> 1524;
3512 -> 1525;
3512 -> 3497;
3512 -> 1532;
3512 -> 1529;
3513 -> 1649;
3514 -> 3513;
3514 -> 1544;
3515 -> 3514;
3515 -> 1546;
3515 -> 1544;
3516 -> 1542;
3516 -> 1576;
3516 -> 1645;
3516 -> 3515;
3516 -> 1654;
3516 -> 1570;
3516 -> 1571;
3516 -> 3501;
3516 -> 1578;
3516 -> 1575;
3517 -> 1590;
3518 -> 3517;
3518 -> 1411;
3519 -> 3518;
3519 -> 1413;
3519 -> 1411;
3520 -> 1609;
3521 -> 3520;
3521 -> 1449;
3522 -> 3521;
3522 -> 1451;
3522 -> 1449;
3523 -> 1447;
3523 -> 1479;
3523 -> 1605;
3523 -> 3522;
3523 -> 1614;
3523 -> 1475;
3523 -> 1476;
3523 -> 3508;
3523 -> 1486;
3523 -> 1478;
3524 -> 1629;
3525 -> 3524;
3525 -> 1498;
3526 -> 3525;
3526 -> 1500;
3526 -> 1498;
3527 -> 1496;
3527 -> 1530;
3527 -> 1625;
3527 -> 3526;
3527 -> 1634;
3527 -> 1524;
3527 -> 1525;
3527 -> 3512;
3527 -> 1532;
3527 -> 1529;
3528 -> 1649;
3529 -> 3528;
3529 -> 1544;
3530 -> 3529;
3530 -> 1546;
3530 -> 1544;
3531 -> 1542;
3531 -> 1576;
3531 -> 1645;
3531 -> 3530;
3531 -> 1654;
3531 -> 1570;
3531 -> 1571;
3531 -> 3516;
3531 -> 1578;
3531 -> 1575;
3532 -> 1590;
3533 -> 3532;
3533 -> 1411;
3534 -> 3533;
3534 -> 1413;
3534 -> 1411;
3535 -> 1609;
3536 -> 3535;
3536 -> 1449;
3537 -> 3536;
3537 -> 1451;
3537 -> 1449;
3538 -> 1447;
3538 -> 1479;
3538 -> 1605;
3538 -> 3537;
3538 -> 1614;
3538 -> 1475;
3538 -> 1476;
3538 -> 3523;
3538 -> 1486;
3538 -> 1478;
3539 -> 1629;
3540 -> 3539;
3540 -> 1498;
3541 -> 3540;
3541 -> 1500;
3541 -> 1498;
3542 -> 1496;
3542 -> 1530;
3542 -> 1625;
3542 -> 3541;
3542 -> 1634;
3542 -> 1524;
3542 -> 1525;
3542 -> 3527;
3542 -> 1532;
3542 -> 1529;
3543 -> 1649;
3544 -> 3543;
3544 -> 1544;
3545 -> 3544;
3545 -> 1546;
3545 -> 1544;
3546 -> 1542;
3546 -> 1576;
3546 -> 1645;
3546 -> 3545;
3546 -> 1654;
3546 -> 1570;
3546 -> 1571;
3546 -> 3531;
3546 -> 1578;
3546 -> 1575;
3547 -> 1590;
3548 -> 3547;
3548 -> 1411;
3549 -> 3548;
3549 -> 1413;
3549 -> 1411;
3550 -> 1609;
3551 -> 3550;
3551 -> 1449;
3552 -> 3551;
3552 -> 1451;
3552 -> 1449;
3553 -> 1447;
3553 -> 1479;
3553 -> 1605;
3553 -> 3552;
3553 -> 1614;
3553 -> 1475;
3553 -> 1476;
3553 -> 3538;
3553 -> 1486;
3553 -> 1478;
3554 -> 1629;
3555 -> 3554;
3555 -> 1498;
3556 -> 3555;
3556 -> 1500;
3556 -> 1498;
3557 -> 1496;
3557 -> 1530;
3557 -> 1625;
3557 -> 3556;
3557 -> 1634;
3557 -> 1524;
3557 -> 1525;
3557 -> 3542;
3557 -> 1532;
3557 -> 1529;
3558 -> 1649;
3559 -> 3558;
3559 -> 1544;
3560 -> 3559;
3560 -> 1546;
3560 -> 1544;
3561 -> 1542;
3561 -> 1576;
3561 -> 1645;
3561 -> 3560;
3561 -> 1654;
3561 -> 1570;
3561 -> 1571;
3561 -> 3546;
3561 -> 1578;
3561 -> 1575;
3562 -> 1590;
3563 -> 3562;
3563 -> 1411;
3564 -> 3563;
3564 -> 1413;
3564 -> 1411;
3565 -> 1609;
3566 -> 3565;
3566 -> 1449;
3567 -> 3566;
3567 -> 1451;
3567 -> 1449;
3568 -> 1447;
3568 -> 1479;
3568 -> 1605;
3568 -> 3567;
3568 -> 1614;
3568 -> 1475;
3568 -> 1476;
3568 -> 3553;
3568 -> 1486;
3568 -> 1478;
3569 -> 1629;
3570 -> 3569;
3570 -> 1498;
3571 -> 3570;
3571 -> 1500;
3571 -> 1498;
3572 -> 1496;
3572 -> 1530;
3572 -> 1625;
3572 -> 3571;
3572 -> 1634;
3572 -> 1524;
3572 -> 1525;
3572 -> 3557;
3572 -> 1532;
3572 -> 1529;
3573 -> 1649;
3574 -> 3573;
3574 -> 1544;
3575 -> 3574;
3575 -> 1546;
3575 -> 1544;
3576 -> 1542;
3576 -> 1576;
3576 -> 1645;
3576 -> 3575;
3576 -> 1654;
3576 -> 1570;
3576 -> 1571;
3576 -> 3561;
3576 -> 1578;
3576 -> 1575;
3577 -> 1590;
3578 -> 3577;
3578 -> 1411;
3579 -> 3578;
3579 -> 1413;
3579 -> 1411;
3580 -> 1609;
3581 -> 3580;
3581 -> 1449;
3582 -> 3581;
3582 -> 1451;
3582 -> 1449;
3583 -> 1447;
3583 -> 1479;
3583 -> 1605;
3583 -> 3582;
3583 -> 1614;
3583 -> 1475;
3583 -> 1476;
3583 -> 3568;
3583 -> 1486;
3583 -> 1478;
3584 -> 1629;
3585 -> 3584;
3585 -> 1498;
3586 -> 3585;
3586 -> 1500;
3586 -> 1498;
3587 -> 1496;
3587 -> 1530;
3587 -> 1625;
3587 -> 3586;
3587 -> 1634;
3587 -> 1524;
3587 -> 1525;
3587 -> 3572;
3587 -> 1532;
3587 -> 1529;
3588 -> 1649;
3589 -> 3588;
3589 -> 1544;
3590 -> 3589;
3590 -> 1546;
3590 -> 1544;
3591 -> 1542;
3591 -> 1576;
3591 -> 1645;
3591 -> 3590;
3591 -> 1654;
3591 -> 1570;
3591 -> 1571;
3591 -> 3576;
3591 -> 1578;
3591 -> 1575;
3592 -> 1590;
3593 -> 3592;
3593 -> 1411;
3594 -> 3593;
3594 -> 1413;
3594 -> 1411;
3595 -> 1609;
3596 -> 3595;
3596 -> 1449;
3597 -> 3596;
3597 -> 1451;
3597 -> 1449;
3598 -> 1447;
3598 -> 1479;
3598 -> 1605;
3598 -> 3597;
3598 -> 1614;
3598 -> 1475;
3598 -> 1476;
3598 -> 3583;
3598 -> 1486;
3598 -> 1478;
3599 -> 1629;
3600 -> 3599;
3600 -> 1498;
3601 -> 3600;
3601 -> 1500;
3601 -> 1498;
3602 -> 1496;
3602 -> 1530;
3602 -> 1625;
3602 -> 3601;
3602 -> 1634;
3602 -> 1524;
3602 -> 1525;
3602 -> 3587;
3602 -> 1532;
3602 -> 1529;
3603 -> 1649;
3604 -> 3603;
3604 -> 1544;
3605 -> 3604;
3605 -> 1546;
3605 -> 1544;
3606 -> 1542;
3606 -> 1576;
3606 -> 1645;
3606 -> 3605;
3606 -> 1654;
3606 -> 1570;
3606 -> 1571;
3606 -> 3591;
3606 -> 1578;
3606 -> 1575;
3607 -> 1590;
3608 -> 3607;
3608 -> 1411;
3609 -> 3608;
3609 -> 1413;
3609 -> 1411;
3610 -> 1609;
3611 -> 3610;
3611 -> 1449;
3612 -> 3611;
3612 -> 1451;
3612 -> 1449;
3613 -> 1447;
3613 -> 1479;
3613 -> 1605;
3613 -> 3612;
3613 -> 1614;
3613 -> 1475;
3613 -> 1476;
3613 -> 3598;
3613 -> 1486;
3613 -> 1478;
3614 -> 1629;
3615 -> 3614;
3615 -> 1498;
3616 -> 3615;
3616 -> 1500;
3616 -> 1498;
3617 -> 1496;
3617 -> 1530;
3617 -> 1625;
3617 -> 3616;
3617 -> 1634;
3617 -> 1524;
3617 -> 1525;
3617 -> 3602;
3617 -> 1532;
3617 -> 1529;
3618 -> 1649;
3619 -> 3618;
3619 -> 1544;
3620 -> 3619;
3620 -> 1546;
3620 -> 1544;
3621 -> 1542;
3621 -> 1576;
3621 -> 1645;
3621 -> 3620;
3621 -> 1654;
3621 -> 1570;
3621 -> 1571;
3621 -> 3606;
3621 -> 1578;
3621 -> 1575;
3622 -> 1590;
3623 -> 3622;
3623 -> 1411;
3624 -> 3623;
3624 -> 1413;
3624 -> 1411;
3625 -> 1609;
3626 -> 3625;
3626 -> 1449;
3627 -> 3626;
3627 -> 1451;
3627 -> 1449;
3628 -> 1447;
3628 -> 1479;
3628 -> 1605;
3628 -> 3627;
3628 -> 1614;
3628 -> 1475;
3628 -> 1476;
3628 -> 3613;
3628 -> 1486;
3628 -> 1478;
3629 -> 1629;
3630 -> 3629;
3630 -> 1498;
3631 -> 3630;
3631 -> 1500;
3631 -> 1498;
3632 -> 1496;
3632 -> 1530;
3632 -> 1625;
3632 -> 3631;
3632 -> 1634;
3632 -> 1524;
3632 -> 1525;
3632 -> 3617;
3632 -> 1532;
3632 -> 1529;
3633 -> 1649;
3634 -> 3633;
3634 -> 1544;
3635 -> 3634;
3635 -> 1546;
3635 -> 1544;
3636 -> 1542;
3636 -> 1576;
3636 -> 1645;
3636 -> 3635;
3636 -> 1654;
3636 -> 1570;
3636 -> 1571;
3636 -> 3621;
3636 -> 1578;
3636 -> 1575;
3637 -> 1590;
3638 -> 3637;
3638 -> 1411;
3639 -> 3638;
3639 -> 1413;
3639 -> 1411;
3640 -> 1609;
3641 -> 3640;
3641 -> 1449;
3642 -> 3641;
3642 -> 1451;
3642 -> 1449;
3643 -> 1447;
3643 -> 1479;
3643 -> 1605;
3643 -> 3642;
3643 -> 1614;
3643 -> 1475;
3643 -> 1476;
3643 -> 3628;
3643 -> 1486;
3643 -> 1478;
3644 -> 1629;
3645 -> 3644;
3645 -> 1498;
3646 -> 3645;
3646 -> 1500;
3646 -> 1498;
3647 -> 1496;
3647 -> 1530;
3647 -> 1625;
3647 -> 3646;
3647 -> 1634;
3647 -> 1524;
3647 -> 1525;
3647 -> 3632;
3647 -> 1532;
3647 -> 1529;
3648 -> 1649;
3649 -> 3648;
3649 -> 1544;
3650 -> 3649;
3650 -> 1546;
3650 -> 1544;
3651 -> 1542;
3651 -> 1576;
3651 -> 1645;
3651 -> 3650;
3651 -> 1654;
3651 -> 1570;
3651 -> 1571;
3651 -> 3636;
3651 -> 1578;
3651 -> 1575;
3652 -> 1590;
3653 -> 3652;
3653 -> 1411;
3654 -> 3653;
3654 -> 1413;
3654 -> 1411;
3655 -> 1609;
3656 -> 3655;
3656 -> 1449;
3657 -> 3656;
3657 -> 1451;
3657 -> 1449;
3658 -> 1447;
3658 -> 1479;
3658 -> 1605;
3658 -> 3657;
3658 -> 1614;
3658 -> 1475;
3658 -> 1476;
3658 -> 3643;
3658 -> 1486;
3658 -> 1478;
3659 -> 1629;
3660 -> 3659;
3660 -> 1498;
3661 -> 3660;
3661 -> 1500;
3661 -> 1498;
3662 -> 1496;
3662 -> 1530;
3662 -> 1625;
3662 -> 3661;
3662 -> 1634;
3662 -> 1524;
3662 -> 1525;
3662 -> 3647;
3662 -> 1532;
3662 -> 1529;
3663 -> 1649;
3664 -> 3663;
3664 -> 1544;
3665 -> 3664;
3665 -> 1546;
3665 -> 1544;
3666 -> 1542;
3666 -> 1576;
3666 -> 1645;
3666 -> 3665;
3666 -> 1654;
3666 -> 1570;
3666 -> 1571;
3666 -> 3651;
3666 -> 1578;
3666 -> 1575;
3667 -> 1590;
3668 -> 3667;
3668 -> 1411;
3669 -> 3668;
3669 -> 1413;
3669 -> 1411;
3670 -> 1609;
3671 -> 3670;
3671 -> 1449;
3672 -> 3671;
3672 -> 1451;
3672 -> 1449;
3673 -> 1447;
3673 -> 1479;
3673 -> 1605;
3673 -> 3672;
3673 -> 1614;
3673 -> 1475;
3673 -> 1476;
3673 -> 3658;
3673 -> 1486;
3673 -> 1478;
3674 -> 1629;
3675 -> 3674;
3675 -> 1498;
3676 -> 3675;
3676 -> 1500;
3676 -> 1498;
3677 -> 1496;
3677 -> 1530;
3677 -> 1625;
3677 -> 3676;
3677 -> 1634;
3677 -> 1524;
3677 -> 1525;
3677 -> 3662;
3677 -> 1532;
3677 -> 1529;
3678 -> 1649;
3679 -> 3678;
3679 -> 1544;
3680 -> 3679;
3680 -> 1546;
3680 -> 1544;
3681 -> 1542;
3681 -> 1576;
3681 -> 1645;
3681 -> 3680;
3681 -> 1654;
3681 -> 1570;
3681 -> 1571;
3681 -> 3666;
3681 -> 1578;
3681 -> 1575;
3682 -> 1590;
3683 -> 3682;
3683 -> 1411;
3684 -> 3683;
3684 -> 1413;
3684 -> 1411;
3685 -> 1609;
3686 -> 3685;
3686 -> 1449;
3687 -> 3686;
3687 -> 1451;
3687 -> 1449;
3688 -> 1447;
3688 -> 1479;
3688 -> 1605;
3688 -> 3687;
3688 -> 1614;
3688 -> 1475;
3688 -> 1476;
3688 -> 3673;
3688 -> 1486;
3688 -> 1478;
3689 -> 1629;
3690 -> 3689;
3690 -> 1498;
3691 -> 3690;
3691 -> 1500;
3691 -> 1498;
3692 -> 1496;
3692 -> 1530;
3692 -> 1625;
3692 -> 3691;
3692 -> 1634;
3692 -> 1524;
3692 -> 1525;
3692 -> 3677;
3692 -> 1532;
3692 -> 1529;
3693 -> 1649;
3694 -> 3693;
3694 -> 1544;
3695 -> 3694;
3695 -> 1546;
3695 -> 1544;
3696 -> 1542;
3696 -> 1576;
3696 -> 1645;
3696 -> 3695;
3696 -> 1654;
3696 -> 1570;
3696 -> 1571;
3696 -> 3681;
3696 -> 1578;
3696 -> 1575;
3697 -> 1590;
3698 -> 3697;
3698 -> 1411;
3699 -> 3698;
3699 -> 1413;
3699 -> 1411;
3700 -> 1609;
3701 -> 3700;
3701 -> 1449;
3702 -> 3701;
3702 -> 1451;
3702 -> 1449;
3703 -> 1447;
3703 -> 1479;
3703 -> 1605;
3703 -> 3702;
3703 -> 1614;
3703 -> 1475;
3703 -> 1476;
3703 -> 3688;
3703 -> 1486;
3703 -> 1478;
3704 -> 1629;
3705 -> 3704;
3705 -> 1498;
3706 -> 3705;
3706 -> 1500;
3706 -> 1498;
3707 -> 1496;
3707 -> 1530;
3707 -> 1625;
3707 -> 3706;
3707 -> 1634;
3707 -> 1524;
3707 -> 1525;
3707 -> 3692;
3707 -> 1532;
3707 -> 1529;
3708 -> 1649;
3709 -> 3708;
3709 -> 1544;
3710 -> 3709;
3710 -> 1546;
3710 -> 1544;
3711 -> 1542;
3711 -> 1576;
3711 -> 1645;
3711 -> 3710;
3711 -> 1654;
3711 -> 1570;
3711 -> 1571;
3711 -> 3696;
3711 -> 1578;
3711 -> 1575;
3712 -> 1590;
3713 -> 3712;
3713 -> 1411;
3714 -> 3713;
3714 -> 1413;
3714 -> 1411;
3715 -> 1609;
3716 -> 3715;
3716 -> 1449;
3717 -> 3716;
3717 -> 1451;
3717 -> 1449;
3718 -> 1447;
3718 -> 1479;
3718 -> 1605;
3718 -> 3717;
3718 -> 1614;
3718 -> 1475;
3718 -> 1476;
3718 -> 3703;
3718 -> 1486;
3718 -> 1478;
3719 -> 1629;
3720 -> 3719;
3720 -> 1498;
3721 -> 3720;
3721 -> 1500;
3721 -> 1498;
3722 -> 1496;
3722 -> 1530;
3722 -> 1625;
3722 -> 3721;
3722 -> 1634;
3722 -> 1524;
3722 -> 1525;
3722 -> 3707;
3722 -> 1532;
3722 -> 1529;
3723 -> 1649;
3724 -> 3723;
3724 -> 1544;
3725 -> 3724;
3725 -> 1546;
3725 -> 1544;
3726 -> 1542;
3726 -> 1576;
3726 -> 1645;
3726 -> 3725;
3726 -> 1654;
3726 -> 1570;
3726 -> 1571;
3726 -> 3711;
3726 -> 1578;
3726 -> 1575;
3727 -> 1590;
3728 -> 3727;
3728 -> 1411;
3729 -> 3728;
3729 -> 1413;
3729 -> 1411;
3730 -> 1609;
3731 -> 3730;
3731 -> 1449;
3732 -> 3731;
3732 -> 1451;
3732 -> 1449;
3733 -> 1447;
3733 -> 1479;
3733 -> 1605;
3733 -> 3732;
3733 -> 1614;
3733 -> 1475;
3733 -> 1476;
3733 -> 3718;
3733 -> 1486;
3733 -> 1478;
3734 -> 1629;
3735 -> 3734;
3735 -> 1498;
3736 -> 3735;
3736 -> 1500;
3736 -> 1498;
3737 -> 1496;
3737 -> 1530;
3737 -> 1625;
3737 -> 3736;
3737 -> 1634;
3737 -> 1524;
3737 -> 1525;
3737 -> 3722;
3737 -> 1532;
3737 -> 1529;
3738 -> 1649;
3739 -> 3738;
3739 -> 1544;
3740 -> 3739;
3740 -> 1546;
3740 -> 1544;
3741 -> 1542;
3741 -> 1576;
3741 -> 1645;
3741 -> 3740;
3741 -> 1654;
3741 -> 1570;
3741 -> 1571;
3741 -> 3726;
3741 -> 1578;
3741 -> 1575;
3742 -> 1590;
3743 -> 3742;
3743 -> 1411;
3744 -> 3743;
3744 -> 1413;
3744 -> 1411;
3745 -> 1609;
3746 -> 3745;
3746 -> 1449;
3747 -> 3746;
3747 -> 1451;
3747 -> 1449;
3748 -> 1447;
3748 -> 1479;
3748 -> 1605;
3748 -> 3747;
3748 -> 1614;
3748 -> 1475;
3748 -> 1476;
3748 -> 3733;
3748 -> 1486;
3748 -> 1478;
3749 -> 1629;
3750 -> 3749;
3750 -> 1498;
3751 -> 3750;
3751 -> 1500;
3751 -> 1498;
3752 -> 1496;
3752 -> 1530;
3752 -> 1625;
3752 -> 3751;
3752 -> 1634;
3752 -> 1524;
3752 -> 1525;
3752 -> 3737;
3752 -> 1532;
3752 -> 1529;
3753 -> 1649;
3754 -> 3753;
3754 -> 1544;
3755 -> 3754;
3755 -> 1546;
3755 -> 1544;
3756 -> 1542;
3756 -> 1576;
3756 -> 1645;
3756 -> 3755;
3756 -> 1654;
3756 -> 1570;
3756 -> 1571;
3756 -> 3741;
3756 -> 1578;
3756 -> 1575;
3757 -> 1590;
3758 -> 3757;
3758 -> 1411;
3759 -> 3758;
3759 -> 1413;
3759 -> 1411;
3760 -> 1609;
3761 -> 3760;
3761 -> 1449;
3762 -> 3761;
3762 -> 1451;
3762 -> 1449;
3763 -> 1447;
3763 -> 1479;
3763 -> 1605;
3763 -> 3762;
3763 -> 1614;
3763 -> 1475;
3763 -> 1476;
3763 -> 3748;
3763 -> 1486;
3763 -> 1478;
3764 -> 1629;
3765 -> 3764;
3765 -> 1498;
3766 -> 3765;
3766 -> 1500;
3766 -> 1498;
3767 -> 1496;
3767 -> 1530;
3767 -> 1625;
3767 -> 3766;
3767 -> 1634;
3767 -> 1524;
3767 -> 1525;
3767 -> 3752;
3767 -> 1532;
3767 -> 1529;
3768 -> 1649;
3769 -> 3768;
3769 -> 1544;
3770 -> 3769;
3770 -> 1546;
3770 -> 1544;
3771 -> 1542;
3771 -> 1576;
3771 -> 1645;
3771 -> 3770;
3771 -> 1654;
3771 -> 1570;
3771 -> 1571;
3771 -> 3756;
3771 -> 1578;
3771 -> 1575;
3772 -> 1590;
3773 -> 3772;
3773 -> 1411;
3774 -> 3773;
3774 -> 1413;
3774 -> 1411;
3775 -> 1609;
3776 -> 3775;
3776 -> 1449;
3777 -> 3776;
3777 -> 1451;
3777 -> 1449;
3778 -> 1447;
3778 -> 1479;
3778 -> 1605;
3778 -> 3777;
3778 -> 1614;
3778 -> 1475;
3778 -> 1476;
3778 -> 3763;
3778 -> 1486;
3778 -> 1478;
3779 -> 1629;
3780 -> 3779;
3780 -> 1498;
3781 -> 3780;
3781 -> 1500;
3781 -> 1498;
3782 -> 1496;
3782 -> 1530;
3782 -> 1625;
3782 -> 3781;
3782 -> 1634;
3782 -> 1524;
3782 -> 1525;
3782 -> 3767;
3782 -> 1532;
3782 -> 1529;
3783 -> 1649;
3784 -> 3783;
3784 -> 1544;
3785 -> 3784;
3785 -> 1546;
3785 -> 1544;
3786 -> 1542;
3786 -> 1576;
3786 -> 1645;
3786 -> 3785;
3786 -> 1654;
3786 -> 1570;
3786 -> 1571;
3786 -> 3771;
3786 -> 1578;
3786 -> 1575;
3787 -> 1590;
3788 -> 3787;
3788 -> 1411;
3789 -> 3788;
3789 -> 1413;
3789 -> 1411;
3790 -> 1609;
3791 -> 3790;
3791 -> 1449;
3792 -> 3791;
3792 -> 1451;
3792 -> 1449;
3793 -> 1447;
3793 -> 1479;
3793 -> 1605;
3793 -> 3792;
3793 -> 1614;
3793 -> 1475;
3793 -> 1476;
3793 -> 3778;
3793 -> 1486;
3793 -> 1478;
3794 -> 1629;
3795 -> 3794;
3795 -> 1498;
3796 -> 3795;
3796 -> 1500;
3796 -> 1498;
3797 -> 1496;
3797 -> 1530;
3797 -> 1625;
3797 -> 3796;
3797 -> 1634;
3797 -> 1524;
3797 -> 1525;
3797 -> 3782;
3797 -> 1532;
3797 -> 1529;
3798 -> 1649;
3799 -> 3798;
3799 -> 1544;
3800 -> 3799;
3800 -> 1546;
3800 -> 1544;
3801 -> 1542;
3801 -> 1576;
3801 -> 1645;
3801 -> 3800;
3801 -> 1654;
3801 -> 1570;
3801 -> 1571;
3801 -> 3786;
3801 -> 1578;
3801 -> 1575;
3802 -> 1590;
3803 -> 3802;
3803 -> 1411;
3804 -> 3803;
3804 -> 1413;
3804 -> 1411;
3805 -> 1609;
3806 -> 3805;
3806 -> 1449;
3807 -> 3806;
3807 -> 1451;
3807 -> 1449;
3808 -> 1447;
3808 -> 1479;
3808 -> 1605;
3808 -> 3807;
3808 -> 1614;
3808 -> 1475;
3808 -> 1476;
3808 -> 3793;
3808 -> 1486;
3808 -> 1478;
3809 -> 1629;
3810 -> 3809;
3810 -> 1498;
3811 -> 3810;
3811 -> 1500;
3811 -> 1498;
3812 -> 1496;
3812 -> 1530;
3812 -> 1625;
3812 -> 3811;
3812 -> 1634;
3812 -> 1524;
3812 -> 1525;
3812 -> 3797;
3812 -> 1532;
3812 -> 1529;
3813 -> 1649;
3814 -> 3813;
3814 -> 1544;
3815 -> 3814;
3815 -> 1546;
3815 -> 1544;
3816 -> 1542;
3816 -> 1576;
3816 -> 1645;
3816 -> 3815;
3816 -> 1654;
3816 -> 1570;
3816 -> 1571;
3816 -> 3801;
3816 -> 1578;
3816 -> 1575;
3817 -> 1590;
3818 -> 3817;
3818 -> 1411;
3819 -> 3818;
3819 -> 1413;
3819 -> 1411;
3820 -> 1609;
3821 -> 3820;
3821 -> 1449;
3822 -> 3821;
3822 -> 1451;
3822 -> 1449;
3823 -> 1447;
3823 -> 1479;
3823 -> 1605;
3823 -> 3822;
3823 -> 1614;
3823 -> 1475;
3823 -> 1476;
3823 -> 3808;
3823 -> 1486;
3823 -> 1478;
3824 -> 1629;
3825 -> 3824;
3825 -> 1498;
3826 -> 3825;
3826 -> 1500;
3826 -> 1498;
3827 -> 1496;
3827 -> 1530;
3827 -> 1625;
3827 -> 3826;
3827 -> 1634;
3827 -> 1524;
3827 -> 1525;
3827 -> 3812;
3827 -> 1532;
3827 -> 1529;
3828 -> 1649;
3829 -> 3828;
3829 -> 1544;
3830 -> 3829;
3830 -> 1546;
3830 -> 1544;
3831 -> 1542;
3831 -> 1576;
3831 -> 1645;
3831 -> 3830;
3831 -> 1654;
3831 -> 1570;
3831 -> 1571;
3831 -> 3816;
3831 -> 1578;
3831 -> 1575;
3832 -> 1590;
3833 -> 3832;
3833 -> 1411;
3834 -> 3833;
3834 -> 1413;
3834 -> 1411;
3835 -> 1609;
3836 -> 3835;
3836 -> 1449;
3837 -> 3836;
3837 -> 1451;
3837 -> 1449;
3838 -> 1447;
3838 -> 1479;
3838 -> 1605;
3838 -> 3837;
3838 -> 1614;
3838 -> 1475;
3838 -> 1476;
3838 -> 3823;
3838 -> 1486;
3838 -> 1478;
3839 -> 1629;
3840 -> 3839;
3840 -> 1498;
3841 -> 3840;
3841 -> 1500;
3841 -> 1498;
3842 -> 1496;
3842 -> 1530;
3842 -> 1625;
3842 -> 3841;
3842 -> 1634;
3842 -> 1524;
3842 -> 1525;
3842 -> 3827;
3842 -> 1532;
3842 -> 1529;
3843 -> 1649;
3844 -> 3843;
3844 -> 1544;
3845 -> 3844;
3845 -> 1546;
3845 -> 1544;
3846 -> 1542;
3846 -> 1576;
3846 -> 1645;
3846 -> 3845;
3846 -> 1654;
3846 -> 1570;
3846 -> 1571;
3846 -> 3831;
3846 -> 1578;
3846 -> 1575;
3847 -> 1590;
3848 -> 3847;
3848 -> 1411;
3849 -> 3848;
3849 -> 1413;
3849 -> 1411;
3850 -> 1609;
3851 -> 3850;
3851 -> 1449;
3852 -> 3851;
3852 -> 1451;
3852 -> 1449;
3853 -> 1447;
3853 -> 1479;
3853 -> 1605;
3853 -> 3852;
3853 -> 1614;
3853 -> 1475;
3853 -> 1476;
3853 -> 3838;
3853 -> 1486;
3853 -> 1478;
3854 -> 1629;
3855 -> 3854;
3855 -> 1498;
3856 -> 3855;
3856 -> 1500;
3856 -> 1498;
3857 -> 1496;
3857 -> 1530;
3857 -> 1625;
3857 -> 3856;
3857 -> 1634;
3857 -> 1524;
3857 -> 1525;
3857 -> 3842;
3857 -> 1532;
3857 -> 1529;
3858 -> 1649;
3859 -> 3858;
3859 -> 1544;
3860 -> 3859;
3860 -> 1546;
3860 -> 1544;
3861 -> 1542;
3861 -> 1576;
3861 -> 1645;
3861 -> 3860;
3861 -> 1654;
3861 -> 1570;
3861 -> 1571;
3861 -> 3846;
3861 -> 1578;
3861 -> 1575;
3862 -> 1590;
3863 -> 3862;
3863 -> 1411;
3864 -> 3863;
3864 -> 1413;
3864 -> 1411;
3865 -> 1609;
3866 -> 3865;
3866 -> 1449;
3867 -> 3866;
3867 -> 1451;
3867 -> 1449;
3868 -> 1447;
3868 -> 1479;
3868 -> 1605;
3868 -> 3867;
3868 -> 1614;
3868 -> 1475;
3868 -> 1476;
3868 -> 3853;
3868 -> 1486;
3868 -> 1478;
3869 -> 1629;
3870 -> 3869;
3870 -> 1498;
3871 -> 3870;
3871 -> 1500;
3871 -> 1498;
3872 -> 1496;
3872 -> 1530;
3872 -> 1625;
3872 -> 3871;
3872 -> 1634;
3872 -> 1524;
3872 -> 1525;
3872 -> 3857;
3872 -> 1532;
3872 -> 1529;
3873 -> 1649;
3874 -> 3873;
3874 -> 1544;
3875 -> 3874;
3875 -> 1546;
3875 -> 1544;
3876 -> 1542;
3876 -> 1576;
3876 -> 1645;
3876 -> 3875;
3876 -> 1654;
3876 -> 1570;
3876 -> 1571;
3876 -> 3861;
3876 -> 1578;
3876 -> 1575;
3877 -> 1590;
3878 -> 3877;
3878 -> 1411;
3879 -> 3878;
3879 -> 1413;
3879 -> 1411;
3880 -> 1609;
3881 -> 3880;
3881 -> 1449;
3882 -> 3881;
3882 -> 1451;
3882 -> 1449;
3883 -> 1447;
3883 -> 1479;
3883 -> 1605;
3883 -> 3882;
3883 -> 1614;
3883 -> 1475;
3883 -> 1476;
3883 -> 3868;
3883 -> 1486;
3883 -> 1478;
3884 -> 1629;
3885 -> 3884;
3885 -> 1498;
3886 -> 3885;
3886 -> 1500;
3886 -> 1498;
3887 -> 1496;
3887 -> 1530;
3887 -> 1625;
3887 -> 3886;
3887 -> 1634;
3887 -> 1524;
3887 -> 1525;
3887 -> 3872;
3887 -> 1532;
3887 -> 1529;
3888 -> 1649;
3889 -> 3888;
3889 -> 1544;
3890 -> 3889;
3890 -> 1546;
3890 -> 1544;
3891 -> 1542;
3891 -> 1576;
3891 -> 1645;
3891 -> 3890;
3891 -> 1654;
3891 -> 1570;
3891 -> 1571;
3891 -> 3876;
3891 -> 1578;
3891 -> 1575;
3892 -> 1590;
3893 -> 3892;
3893 -> 1411;
3894 -> 3893;
3894 -> 1413;
3894 -> 1411;
3895 -> 1609;
3896 -> 3895;
3896 -> 1449;
3897 -> 3896;
3897 -> 1451;
3897 -> 1449;
3898 -> 1447;
3898 -> 1479;
3898 -> 1605;
3898 -> 3897;
3898 -> 1614;
3898 -> 1475;
3898 -> 1476;
3898 -> 3883;
3898 -> 1486;
3898 -> 1478;
3899 -> 1629;
3900 -> 3899;
3900 -> 1498;
3901 -> 3900;
3901 -> 1500;
3901 -> 1498;
3902 -> 1496;
3902 -> 1530;
3902 -> 1625;
3902 -> 3901;
3902 -> 1634;
3902 -> 1524;
3902 -> 1525;
3902 -> 3887;
3902 -> 1532;
3902 -> 1529;
3903 -> 1649;
3904 -> 3903;
3904 -> 1544;
3905 -> 3904;
3905 -> 1546;
3905 -> 1544;
3906 -> 1542;
3906 -> 1576;
3906 -> 1645;
3906 -> 3905;
3906 -> 1654;
3906 -> 1570;
3906 -> 1571;
3906 -> 3891;
3906 -> 1578;
3906 -> 1575;
3907 -> 1590;
3908 -> 3907;
3908 -> 1411;
3909 -> 3908;
3909 -> 1413;
3909 -> 1411;
3910 -> 1609;
3911 -> 3910;
3911 -> 1449;
3912 -> 3911;
3912 -> 1451;
3912 -> 1449;
3913 -> 1447;
3913 -> 1479;
3913 -> 1605;
3913 -> 3912;
3913 -> 1614;
3913 -> 1475;
3913 -> 1476;
3913 -> 3898;
3913 -> 1486;
3913 -> 1478;
3914 -> 1629;
3915 -> 3914;
3915 -> 1498;
3916 -> 3915;
3916 -> 1500;
3916 -> 1498;
3917 -> 1496;
3917 -> 1530;
3917 -> 1625;
3917 -> 3916;
3917 -> 1634;
3917 -> 1524;
3917 -> 1525;
3917 -> 3902;
3917 -> 1532;
3917 -> 1529;
3918 -> 1649;
3919 -> 3918;
3919 -> 1544;
3920 -> 3919;
3920 -> 1546;
3920 -> 1544;
3921 -> 1542;
3921 -> 1576;
3921 -> 1645;
3921 -> 3920;
3921 -> 1654;
3921 -> 1570;
3921 -> 1571;
3921 -> 3906;
3921 -> 1578;
3921 -> 1575;
3922 -> 1590;
3923 -> 3922;
3923 -> 1411;
3924 -> 3923;
3924 -> 1413;
3924 -> 1411;
3925 -> 1609;
3926 -> 3925;
3926 -> 1449;
3927 -> 3926;
3927 -> 1451;
3927 -> 1449;
3928 -> 1447;
3928 -> 1479;
3928 -> 1605;
3928 -> 3927;
3928 -> 1614;
3928 -> 1475;
3928 -> 1476;
3928 -> 3913;
3928 -> 1486;
3928 -> 1478;
3929 -> 1629;
3930 -> 3929;
3930 -> 1498;
3931 -> 3930;
3931 -> 1500;
3931 -> 1498;
3932 -> 1496;
3932 -> 1530;
3932 -> 1625;
3932 -> 3931;
3932 -> 1634;
3932 -> 1524;
3932 -> 1525;
3932 -> 3917;
3932 -> 1532;
3932 -> 1529;
3933 -> 1649;
3934 -> 3933;
3934 -> 1544;
3935 -> 3934;
3935 -> 1546;
3935 -> 1544;
3936 -> 1542;
3936 -> 1576;
3936 -> 1645;
3936 -> 3935;
3936 -> 1654;
3936 -> 1570;
3936 -> 1571;
3936 -> 3921;
3936 -> 1578;
3936 -> 1575;
3937 -> 1590;
3938 -> 3937;
3938 -> 1411;
3939 -> 3938;
3939 -> 1413;
3939 -> 1411;
3940 -> 1609;
3941 -> 3940;
3941 -> 1449;
3942 -> 3941;
3942 -> 1451;
3942 -> 1449;
3943 -> 1447;
3943 -> 1479;
3943 -> 1605;
3943 -> 3942;
3943 -> 1614;
3943 -> 1475;
3943 -> 1476;
3943 -> 3928;
3943 -> 1486;
3943 -> 1478;
3944 -> 1629;
3945 -> 3944;
3945 -> 1498;
3946 -> 3945;
3946 -> 1500;
3946 -> 1498;
3947 -> 1496;
3947 -> 1530;
3947 -> 1625;
3947 -> 3946;
3947 -> 1634;
3947 -> 1524;
3947 -> 1525;
3947 -> 3932;
3947 -> 1532;
3947 -> 1529;
3948 -> 1649;
3949 -> 3948;
3949 -> 1544;
3950 -> 3949;
3950 -> 1546;
3950 -> 1544;
3951 -> 1542;
3951 -> 1576;
3951 -> 1645;
3951 -> 3950;
3951 -> 1654;
3951 -> 1570;
3951 -> 1571;
3951 -> 3936;
3951 -> 1578;
3951 -> 1575;
3952 -> 1590;
3953 -> 3952;
3953 -> 1411;
3954 -> 3953;
3954 -> 1413;
3954 -> 1411;
3955 -> 1609;
3956 -> 3955;
3956 -> 1449;
3957 -> 3956;
3957 -> 1451;
3957 -> 1449;
3958 -> 1447;
3958 -> 1479;
3958 -> 1605;
3958 -> 3957;
3958 -> 1614;
3958 -> 1475;
3958 -> 1476;
3958 -> 3943;
3958 -> 1486;
3958 -> 1478;
3959 -> 1629;
3960 -> 3959;
3960 -> 1498;
3961 -> 3960;
3961 -> 1500;
3961 -> 1498;
3962 -> 1496;
3962 -> 1530;
3962 -> 1625;
3962 -> 3961;
3962 -> 1634;
3962 -> 1524;
3962 -> 1525;
3962 -> 3947;
3962 -> 1532;
3962 -> 1529;
3963 -> 1649;
3964 -> 3963;
3964 -> 1544;
3965 -> 3964;
3965 -> 1546;
3965 -> 1544;
3966 -> 1542;
3966 -> 1576;
3966 -> 1645;
3966 -> 3965;
3966 -> 1654;
3966 -> 1570;
3966 -> 1571;
3966 -> 3951;
3966 -> 1578;
3966 -> 1575;
3967 -> 1590;
3968 -> 3967;
3968 -> 1411;
3969 -> 3968;
3969 -> 1413;
3969 -> 1411;
3970 -> 1609;
3971 -> 3970;
3971 -> 1449;
3972 -> 3971;
3972 -> 1451;
3972 -> 1449;
3973 -> 1447;
3973 -> 1479;
3973 -> 1605;
3973 -> 3972;
3973 -> 1614;
3973 -> 1475;
3973 -> 1476;
3973 -> 3958;
3973 -> 1486;
3973 -> 1478;
3974 -> 1629;
3975 -> 3974;
3975 -> 1498;
3976 -> 3975;
3976 -> 1500;
3976 -> 1498;
3977 -> 1496;
3977 -> 1530;
3977 -> 1625;
3977 -> 3976;
3977 -> 1634;
3977 -> 1524;
3977 -> 1525;
3977 -> 3962;
3977 -> 1532;
3977 -> 1529;
3978 -> 1649;
3979 -> 3978;
3979 -> 1544;
3980 -> 3979;
3980 -> 1546;
3980 -> 1544;
3981 -> 1542;
3981 -> 1576;
3981 -> 1645;
3981 -> 3980;
3981 -> 1654;
3981 -> 1570;
3981 -> 1571;
3981 -> 3966;
3981 -> 1578;
3981 -> 1575;
3982 -> 1590;
3983 -> 3982;
3983 -> 1411;
3984 -> 3983;
3984 -> 1413;
3984 -> 1411;
3985 -> 1609;
3986 -> 3985;
3986 -> 1449;
3987 -> 3986;
3987 -> 1451;
3987 -> 1449;
3988 -> 1447;
3988 -> 1479;
3988 -> 1605;
3988 -> 3987;
3988 -> 1614;
3988 -> 1475;
3988 -> 1476;
3988 -> 3973;
3988 -> 1486;
3988 -> 1478;
3989 -> 1629;
3990 -> 3989;
3990 -> 1498;
3991 -> 3990;
3991 -> 1500;
3991 -> 1498;
3992 -> 1496;
3992 -> 1530;
3992 -> 1625;
3992 -> 3991;
3992 -> 1634;
3992 -> 1524;
3992 -> 1525;
3992 -> 3977;
3992 -> 1532;
3992 -> 1529;
3993 -> 1649;
3994 -> 3993;
3994 -> 1544;
3995 -> 3994;
3995 -> 1546;
3995 -> 1544;
3996 -> 1542;
3996 -> 1576;
3996 -> 1645;
3996 -> 3995;
3996 -> 1654;
3996 -> 1570;
3996 -> 1571;
3996 -> 3981;
3996 -> 1578;
3996 -> 1575;
3997 -> 1590;
3998 -> 3997;
3998 -> 1411;
3999 -> 3998;
3999 -> 1413;
3999 -> 1411;
4000 -> 1609;
4001 -> 4000;
4001 -> 1449;
4002 -> 4001;
4002 -> 1451;
4002 -> 1449;
4003 -> 1447;
4003 -> 1479;
4003 -> 1605;
4003 -> 4002;
4003 -> 1614;
4003 -> 1475;
4003 -> 1476;
4003 -> 3988;
4003 -> 1486;
4003 -> 1478;
4004 -> 1629;
4005 -> 4004;
4005 -> 1498;
4006 -> 4005;
4006 -> 1500;
4006 -> 1498;
4007 -> 1496;
4007 -> 1530;
4007 -> 1625;
4007 -> 4006;
4007 -> 1634;
4007 -> 1524;
4007 -> 1525;
4007 -> 3992;
4007 -> 1532;
4007 -> 1529;
4008 -> 1649;
4009 -> 4008;
4009 -> 1544;
4010 -> 4009;
4010 -> 1546;
4010 -> 1544;
4011 -> 1542;
4011 -> 1576;
4011 -> 1645;
4011 -> 4010;
4011 -> 1654;
4011 -> 1570;
4011 -> 1571;
4011 -> 3996;
4011 -> 1578;
4011 -> 1575;
4012 -> 1590;
4013 -> 4012;
4013 -> 1411;
4014 -> 4013;
4014 -> 1413;
4014 -> 1411;
4015 -> 1609;
4016 -> 4015;
4016 -> 1449;
4017 -> 4016;
4017 -> 1451;
4017 -> 1449;
4018 -> 1447;
4018 -> 1479;
4018 -> 1605;
4018 -> 4017;
4018 -> 1614;
4018 -> 1475;
4018 -> 1476;
4018 -> 4003;
4018 -> 1486;
4018 -> 1478;
4019 -> 1629;
4020 -> 4019;
4020 -> 1498;
4021 -> 4020;
4021 -> 1500;
4021 -> 1498;
4022 -> 1496;
4022 -> 1530;
4022 -> 1625;
4022 -> 4021;
4022 -> 1634;
4022 -> 1524;
4022 -> 1525;
4022 -> 4007;
4022 -> 1532;
4022 -> 1529;
4023 -> 1649;
4024 -> 4023;
4024 -> 1544;
4025 -> 4024;
4025 -> 1546;
4025 -> 1544;
4026 -> 1542;
4026 -> 1576;
4026 -> 1645;
4026 -> 4025;
4026 -> 1654;
4026 -> 1570;
4026 -> 1571;
4026 -> 4011;
4026 -> 1578;
4026 -> 1575;
4027 -> 1590;
4028 -> 4027;
4028 -> 1411;
4029 -> 4028;
4029 -> 1413;
4029 -> 1411;
4030 -> 1609;
4031 -> 4030;
4031 -> 1449;
4032 -> 4031;
4032 -> 1451;
4032 -> 1449;
4033 -> 1447;
4033 -> 1479;
4033 -> 1605;
4033 -> 4032;
4033 -> 1614;
4033 -> 1475;
4033 -> 1476;
4033 -> 4018;
4033 -> 1486;
4033 -> 1478;
4034 -> 1629;
4035 -> 4034;
4035 -> 1498;
4036 -> 4035;
4036 -> 1500;
4036 -> 1498;
4037 -> 1496;
4037 -> 1530;
4037 -> 1625;
4037 -> 4036;
4037 -> 1634;
4037 -> 1524;
4037 -> 1525;
4037 -> 4022;
4037 -> 1532;
4037 -> 1529;
4038 -> 1649;
4039 -> 4038;
4039 -> 1544;
4040 -> 4039;
4040 -> 1546;
4040 -> 1544;
4041 -> 1542;
4041 -> 1576;
4041 -> 1645;
4041 -> 4040;
4041 -> 1654;
4041 -> 1570;
4041 -> 1571;
4041 -> 4026;
4041 -> 1578;
4041 -> 1575;
4042 -> 1590;
4043 -> 4042;
4043 -> 1411;
4044 -> 4043;
4044 -> 1413;
4044 -> 1411;
4045 -> 1609;
4046 -> 4045;
4046 -> 1449;
4047 -> 4046;
4047 -> 1451;
4047 -> 1449;
4048 -> 1447;
4048 -> 1479;
4048 -> 1605;
4048 -> 4047;
4048 -> 1614;
4048 -> 1475;
4048 -> 1476;
4048 -> 4033;
4048 -> 1486;
4048 -> 1478;
4049 -> 1629;
4050 -> 4049;
4050 -> 1498;
4051 -> 4050;
4051 -> 1500;
4051 -> 1498;
4052 -> 1496;
4052 -> 1530;
4052 -> 1625;
4052 -> 4051;
4052 -> 1634;
4052 -> 1524;
4052 -> 1525;
4052 -> 4037;
4052 -> 1532;
4052 -> 1529;
4053 -> 1649;
4054 -> 4053;
4054 -> 1544;
4055 -> 4054;
4055 -> 1546;
4055 -> 1544;
4056 -> 1542;
4056 -> 1576;
4056 -> 1645;
4056 -> 4055;
4056 -> 1654;
4056 -> 1570;
4056 -> 1571;
4056 -> 4041;
4056 -> 1578;
4056 -> 1575;
4057 -> 1590;
4058 -> 4057;
4058 -> 1411;
4059 -> 4058;
4059 -> 1413;
4059 -> 1411;
4060 -> 1609;
4061 -> 4060;
4061 -> 1449;
4062 -> 4061;
4062 -> 1451;
4062 -> 1449;
4063 -> 1447;
4063 -> 1479;
4063 -> 1605;
4063 -> 4062;
4063 -> 1614;
4063 -> 1475;
4063 -> 1476;
4063 -> 4048;
4063 -> 1486;
4063 -> 1478;
4064 -> 1629;
4065 -> 4064;
4065 -> 1498;
4066 -> 4065;
4066 -> 1500;
4066 -> 1498;
4067 -> 1496;
4067 -> 1530;
4067 -> 1625;
4067 -> 4066;
4067 -> 1634;
4067 -> 1524;
4067 -> 1525;
4067 -> 4052;
4067 -> 1532;
4067 -> 1529;
4068 -> 1649;
4069 -> 4068;
4069 -> 1544;
4070 -> 4069;
4070 -> 1546;
4070 -> 1544;
4071 -> 1542;
4071 -> 1576;
4071 -> 1645;
4071 -> 4070;
4071 -> 1654;
4071 -> 1570;
4071 -> 1571;
4071 -> 4056;
4071 -> 1578;
4071 -> 1575;
4072 -> 1590;
4073 -> 4072;
4073 -> 1411;
4074 -> 4073;
4074 -> 1413;
4074 -> 1411;
4075 -> 1609;
4076 -> 4075;
4076 -> 1449;
4077 -> 4076;
4077 -> 1451;
4077 -> 1449;
4078 -> 1447;
4078 -> 1479;
4078 -> 1605;
4078 -> 4077;
4078 -> 1614;
4078 -> 1475;
4078 -> 1476;
4078 -> 4063;
4078 -> 1486;
4078 -> 1478;
4079 -> 1629;
4080 -> 4079;
4080 -> 1498;
4081 -> 4080;
4081 -> 1500;
4081 -> 1498;
4082 -> 1496;
4082 -> 1530;
4082 -> 1625;
4082 -> 4081;
4082 -> 1634;
4082 -> 1524;
4082 -> 1525;
4082 -> 4067;
4082 -> 1532;
4082 -> 1529;
4083 -> 1649;
4084 -> 4083;
4084 -> 1544;
4085 -> 4084;
4085 -> 1546;
4085 -> 1544;
4086 -> 1542;
4086 -> 1576;
4086 -> 1645;
4086 -> 4085;
4086 -> 1654;
4086 -> 1570;
4086 -> 1571;
4086 -> 4071;
4086 -> 1578;
4086 -> 1575;
4087 -> 1590;
4088 -> 4087;
4088 -> 1411;
4089 -> 4088;
4089 -> 1413;
4089 -> 1411;
4090 -> 1609;
4091 -> 4090;
4091 -> 1449;
4092 -> 4091;
4092 -> 1451;
4092 -> 1449;
4093 -> 1447;
4093 -> 1479;
4093 -> 1605;
4093 -> 4092;
4093 -> 1614;
4093 -> 1475;
4093 -> 1476;
4093 -> 4078;
4093 -> 1486;
4093 -> 1478;
4094 -> 1629;
4095 -> 4094;
4095 -> 1498;
4096 -> 4095;
4096 -> 1500;
4096 -> 1498;
4097 -> 1496;
4097 -> 1530;
4097 -> 1625;
4097 -> 4096;
4097 -> 1634;
4097 -> 1524;
4097 -> 1525;
4097 -> 4082;
4097 -> 1532;
4097 -> 1529;
4098 -> 1649;
4099 -> 4098;
4099 -> 1544;
4100 -> 4099;
4100 -> 1546;
4100 -> 1544;
4101 -> 1542;
4101 -> 1576;
4101 -> 1645;
4101 -> 4100;
4101 -> 1654;
4101 -> 1570;
4101 -> 1571;
4101 -> 4086;
4101 -> 1578;
4101 -> 1575;
4102 -> 1590;
4103 -> 4102;
4103 -> 1411;
4104 -> 4103;
4104 -> 1413;
4104 -> 1411;
4105 -> 1609;
4106 -> 4105;
4106 -> 1449;
4107 -> 4106;
4107 -> 1451;
4107 -> 1449;
4108 -> 1447;
4108 -> 1479;
4108 -> 1605;
4108 -> 4107;
4108 -> 1614;
4108 -> 1475;
4108 -> 1476;
4108 -> 4093;
4108 -> 1486;
4108 -> 1478;
4109 -> 1629;
4110 -> 4109;
4110 -> 1498;
4111 -> 4110;
4111 -> 1500;
4111 -> 1498;
4112 -> 1496;
4112 -> 1530;
4112 -> 1625;
4112 -> 4111;
4112 -> 1634;
4112 -> 1524;
4112 -> 1525;
4112 -> 4097;
4112 -> 1532;
4112 -> 1529;
4113 -> 1649;
4114 -> 4113;
4114 -> 1544;
4115 -> 4114;
4115 -> 1546;
4115 -> 1544;
4116 -> 1542;
4116 -> 1576;
4116 -> 1645;
4116 -> 4115;
4116 -> 1654;
4116 -> 1570;
4116 -> 1571;
4116 -> 4101;
4116 -> 1578;
4116 -> 1575;
4117 -> 1590;
4118 -> 4117;
4118 -> 1411;
4119 -> 4118;
4119 -> 1413;
4119 -> 1411;
4120 -> 1609;
4121 -> 4120;
4121 -> 1449;
4122 -> 4121;
4122 -> 1451;
4122 -> 1449;
4123 -> 1447;
4123 -> 1479;
4123 -> 1605;
4123 -> 4122;
4123 -> 1614;
4123 -> 1475;
4123 -> 1476;
4123 -> 4108;
4123 -> 1486;
4123 -> 1478;
4124 -> 1629;
4125 -> 4124;
4125 -> 1498;
4126 -> 4125;
4126 -> 1500;
4126 -> 1498;
4127 -> 1496;
4127 -> 1530;
4127 -> 1625;
4127 -> 4126;
4127 -> 1634;
4127 -> 1524;
4127 -> 1525;
4127 -> 4112;
4127 -> 1532;
4127 -> 1529;
4128 -> 1649;
4129 -> 4128;
4129 -> 1544;
4130 -> 4129;
4130 -> 1546;
4130 -> 1544;
4131 -> 1542;
4131 -> 1576;
4131 -> 1645;
4131 -> 4130;
4131 -> 1654;
4131 -> 1570;
4131 -> 1571;
4131 -> 4116;
4131 -> 1578;
4131 -> 1575;
4132 -> 1590;
4133 -> 4132;
4133 -> 1411;
4134 -> 4133;
4134 -> 1413;
4134 -> 1411;
4135 -> 1609;
4136 -> 4135;
4136 -> 1449;
4137 -> 4136;
4137 -> 1451;
4137 -> 1449;
4138 -> 1447;
4138 -> 1479;
4138 -> 1605;
4138 -> 4137;
4138 -> 1614;
4138 -> 1475;
4138 -> 1476;
4138 -> 4123;
4138 -> 1486;
4138 -> 1478;
4139 -> 1629;
4140 -> 4139;
4140 -> 1498;
4141 -> 4140;
4141 -> 1500;
4141 -> 1498;
4142 -> 1496;
4142 -> 1530;
4142 -> 1625;
4142 -> 4141;
4142 -> 1634;
4142 -> 1524;
4142 -> 1525;
4142 -> 4127;
4142 -> 1532;
4142 -> 1529;
4143 -> 1649;
4144 -> 4143;
4144 -> 1544;
4145 -> 4144;
4145 -> 1546;
4145 -> 1544;
4146 -> 1542;
4146 -> 1576;
4146 -> 1645;
4146 -> 4145;
4146 -> 1654;
4146 -> 1570;
4146 -> 1571;
4146 -> 4131;
4146 -> 1578;
4146 -> 1575;
4147 -> 1590;
4148 -> 4147;
4148 -> 1411;
4149 -> 4148;
4149 -> 1413;
4149 -> 1411;
4150 -> 1609;
4151 -> 4150;
4151 -> 1449;
4152 -> 4151;
4152 -> 1451;
4152 -> 1449;
4153 -> 1447;
4153 -> 1479;
4153 -> 1605;
4153 -> 4152;
4153 -> 1614;
4153 -> 1475;
4153 -> 1476;
4153 -> 4138;
4153 -> 1486;
4153 -> 1478;
4154 -> 1629;
4155 -> 4154;
4155 -> 1498;
4156 -> 4155;
4156 -> 1500;
4156 -> 1498;
4157 -> 1496;
4157 -> 1530;
4157 -> 1625;
4157 -> 4156;
4157 -> 1634;
4157 -> 1524;
4157 -> 1525;
4157 -> 4142;
4157 -> 1532;
4157 -> 1529;
4158 -> 1649;
4159 -> 4158;
4159 -> 1544;
4160 -> 4159;
4160 -> 1546;
4160 -> 1544;
4161 -> 1542;
4161 -> 1576;
4161 -> 1645;
4161 -> 4160;
4161 -> 1654;
4161 -> 1570;
4161 -> 1571;
4161 -> 4146;
4161 -> 1578;
4161 -> 1575;
4162 -> 1590;
4163 -> 4162;
4163 -> 1411;
4164 -> 4163;
4164 -> 1413;
4164 -> 1411;
4165 -> 1609;
4166 -> 4165;
4166 -> 1449;
4167 -> 4166;
4167 -> 1451;
4167 -> 1449;
4168 -> 1447;
4168 -> 1479;
4168 -> 1605;
4168 -> 4167;
4168 -> 1614;
4168 -> 1475;
4168 -> 1476;
4168 -> 4153;
4168 -> 1486;
4168 -> 1478;
4169 -> 1629;
4170 -> 4169;
4170 -> 1498;
4171 -> 4170;
4171 -> 1500;
4171 -> 1498;
4172 -> 1496;
4172 -> 1530;
4172 -> 1625;
4172 -> 4171;
4172 -> 1634;
4172 -> 1524;
4172 -> 1525;
4172 -> 4157;
4172 -> 1532;
4172 -> 1529;
4173 -> 1649;
4174 -> 4173;
4174 -> 1544;
4175 -> 4174;
4175 -> 1546;
4175 -> 1544;
4176 -> 1542;
4176 -> 1576;
4176 -> 1645;
4176 -> 4175;
4176 -> 1654;
4176 -> 1570;
4176 -> 1571;
4176 -> 4161;
4176 -> 1578;
4176 -> 1575;
4177 -> 1590;
4178 -> 4177;
4178 -> 1411;
4179 -> 4178;
4179 -> 1413;
4179 -> 1411;
4180 -> 1609;
4181 -> 4180;
4181 -> 1449;
4182 -> 4181;
4182 -> 1451;
4182 -> 1449;
4183 -> 1447;
4183 -> 1479;
4183 -> 1605;
4183 -> 4182;
4183 -> 1614;
4183 -> 1475;
4183 -> 1476;
4183 -> 4168;
4183 -> 1486;
4183 -> 1478;
4184 -> 1629;
4185 -> 4184;
4185 -> 1498;
4186 -> 4185;
4186 -> 1500;
4186 -> 1498;
4187 -> 1496;
4187 -> 1530;
4187 -> 1625;
4187 -> 4186;
4187 -> 1634;
4187 -> 1524;
4187 -> 1525;
4187 -> 4172;
4187 -> 1532;
4187 -> 1529;
4188 -> 1649;
4189 -> 4188;
4189 -> 1544;
4190 -> 4189;
4190 -> 1546;
4190 -> 1544;
4191 -> 1542;
4191 -> 1576;
4191 -> 1645;
4191 -> 4190;
4191 -> 1654;
4191 -> 1570;
4191 -> 1571;
4191 -> 4176;
4191 -> 1578;
4191 -> 1575;
4192 -> 1590;
4193 -> 4192;
4193 -> 1411;
4194 -> 4193;
4194 -> 1413;
4194 -> 1411;
4195 -> 1609;
4196 -> 4195;
4196 -> 1449;
4197 -> 4196;
4197 -> 1451;
4197 -> 1449;
4198 -> 1447;
4198 -> 1479;
4198 -> 1605;
4198 -> 4197;
4198 -> 1614;
4198 -> 1475;
4198 -> 1476;
4198 -> 4183;
4198 -> 1486;
4198 -> 1478;
4199 -> 1629;
4200 -> 4199;
4200 -> 1498;
4201 -> 4200;
4201 -> 1500;
4201 -> 1498;
4202 -> 1496;
4202 -> 1530;
4202 -> 1625;
4202 -> 4201;
4202 -> 1634;
4202 -> 1524;
4202 -> 1525;
4202 -> 4187;
4202 -> 1532;
4202 -> 1529;
4203 -> 1649;
4204 -> 4203;
4204 -> 1544;
4205 -> 4204;
4205 -> 1546;
4205 -> 1544;
4206 -> 1542;
4206 -> 1576;
4206 -> 1645;
4206 -> 4205;
4206 -> 1654;
4206 -> 1570;
4206 -> 1571;
4206 -> 4191;
4206 -> 1578;
4206 -> 1575;
4207 -> 1590;
4208 -> 4207;
4208 -> 1411;
4209 -> 4208;
4209 -> 1413;
4209 -> 1411;
4210 -> 1609;
4211 -> 4210;
4211 -> 1449;
4212 -> 4211;
4212 -> 1451;
4212 -> 1449;
4213 -> 1447;
4213 -> 1479;
4213 -> 1605;
4213 -> 4212;
4213 -> 1614;
4213 -> 1475;
4213 -> 1476;
4213 -> 4198;
4213 -> 1486;
4213 -> 1478;
4214 -> 1629;
4215 -> 4214;
4215 -> 1498;
4216 -> 4215;
4216 -> 1500;
4216 -> 1498;
4217 -> 1496;
4217 -> 1530;
4217 -> 1625;
4217 -> 4216;
4217 -> 1634;
4217 -> 1524;
4217 -> 1525;
4217 -> 4202;
4217 -> 1532;
4217 -> 1529;
4218 -> 1649;
4219 -> 4218;
4219 -> 1544;
4220 -> 4219;
4220 -> 1546;
4220 -> 1544;
4221 -> 1542;
4221 -> 1576;
4221 -> 1645;
4221 -> 4220;
4221 -> 1654;
4221 -> 1570;
4221 -> 1571;
4221 -> 4206;
4221 -> 1578;
4221 -> 1575;
4222 -> 1590;
4223 -> 4222;
4223 -> 1411;
4224 -> 4223;
4224 -> 1413;
4224 -> 1411;
4225 -> 1609;
4226 -> 4225;
4226 -> 1449;
4227 -> 4226;
4227 -> 1451;
4227 -> 1449;
4228 -> 1447;
4228 -> 1479;
4228 -> 1605;
4228 -> 4227;
4228 -> 1614;
4228 -> 1475;
4228 -> 1476;
4228 -> 4213;
4228 -> 1486;
4228 -> 1478;
4229 -> 1629;
4230 -> 4229;
4230 -> 1498;
4231 -> 4230;
4231 -> 1500;
4231 -> 1498;
4232 -> 1496;
4232 -> 1530;
4232 -> 1625;
4232 -> 4231;
4232 -> 1634;
4232 -> 1524;
4232 -> 1525;
4232 -> 4217;
4232 -> 1532;
4232 -> 1529;
4233 -> 1649;
4234 -> 4233;
4234 -> 1544;
4235 -> 4234;
4235 -> 1546;
4235 -> 1544;
4236 -> 1542;
4236 -> 1576;
4236 -> 1645;
4236 -> 4235;
4236 -> 1654;
4236 -> 1570;
4236 -> 1571;
4236 -> 4221;
4236 -> 1578;
4236 -> 1575;
4237 -> 1590;
4238 -> 4237;
4238 -> 1411;
4239 -> 4238;
4239 -> 1413;
4239 -> 1411;
4240 -> 1609;
4241 -> 4240;
4241 -> 1449;
4242 -> 4241;
4242 -> 1451;
4242 -> 1449;
4243 -> 1447;
4243 -> 1479;
4243 -> 1605;
4243 -> 4242;
4243 -> 1614;
4243 -> 1475;
4243 -> 1476;
4243 -> 4228;
4243 -> 1486;
4243 -> 1478;
4244 -> 1629;
4245 -> 4244;
4245 -> 1498;
4246 -> 4245;
4246 -> 1500;
4246 -> 1498;
4247 -> 1496;
4247 -> 1530;
4247 -> 1625;
4247 -> 4246;
4247 -> 1634;
4247 -> 1524;
4247 -> 1525;
4247 -> 4232;
4247 -> 1532;
4247 -> 1529;
4248 -> 1649;
4249 -> 4248;
4249 -> 1544;
4250 -> 4249;
4250 -> 1546;
4250 -> 1544;
4251 -> 1542;
4251 -> 1576;
4251 -> 1645;
4251 -> 4250;
4251 -> 1654;
4251 -> 1570;
4251 -> 1571;
4251 -> 4236;
4251 -> 1578;
4251 -> 1575;
4252 -> 1590;
4253 -> 4252;
4253 -> 1411;
4254 -> 4253;
4254 -> 1413;
4254 -> 1411;
4255 -> 1609;
4256 -> 4255;
4256 -> 1449;
4257 -> 4256;
4257 -> 1451;
4257 -> 1449;
4258 -> 1447;
4258 -> 1479;
4258 -> 1605;
4258 -> 4257;
4258 -> 1614;
4258 -> 1475;
4258 -> 1476;
4258 -> 4243;
4258 -> 1486;
4258 -> 1478;
4259 -> 1629;
4260 -> 4259;
4260 -> 1498;
4261 -> 4260;
4261 -> 1500;
4261 -> 1498;
4262 -> 1496;
4262 -> 1530;
4262 -> 1625;
4262 -> 4261;
4262 -> 1634;
4262 -> 1524;
4262 -> 1525;
4262 -> 4247;
4262 -> 1532;
4262 -> 1529;
4263 -> 1649;
4264 -> 4263;
4264 -> 1544;
4265 -> 4264;
4265 -> 1546;
4265 -> 1544;
4266 -> 1542;
4266 -> 1576;
4266 -> 1645;
4266 -> 4265;
4266 -> 1654;
4266 -> 1570;
4266 -> 1571;
4266 -> 4251;
4266 -> 1578;
4266 -> 1575;
4267 -> 1590;
4268 -> 4267;
4268 -> 1411;
4269 -> 4268;
4269 -> 1413;
4269 -> 1411;
4270 -> 1609;
4271 -> 4270;
4271 -> 1449;
4272 -> 4271;
4272 -> 1451;
4272 -> 1449;
4273 -> 1447;
4273 -> 1479;
4273 -> 1605;
4273 -> 4272;
4273 -> 1614;
4273 -> 1475;
4273 -> 1476;
4273 -> 4258;
4273 -> 1486;
4273 -> 1478;
4274 -> 1629;
4275 -> 4274;
4275 -> 1498;
4276 -> 4275;
4276 -> 1500;
4276 -> 1498;
4277 -> 1496;
4277 -> 1530;
4277 -> 1625;
4277 -> 4276;
4277 -> 1634;
4277 -> 1524;
4277 -> 1525;
4277 -> 4262;
4277 -> 1532;
4277 -> 1529;
4278 -> 1649;
4279 -> 4278;
4279 -> 1544;
4280 -> 4279;
4280 -> 1546;
4280 -> 1544;
4281 -> 1542;
4281 -> 1576;
4281 -> 1645;
4281 -> 4280;
4281 -> 1654;
4281 -> 1570;
4281 -> 1571;
4281 -> 4266;
4281 -> 1578;
4281 -> 1575;
4282 -> 1590;
4283 -> 4282;
4283 -> 1411;
4284 -> 4283;
4284 -> 1413;
4284 -> 1411;
4285 -> 1609;
4286 -> 4285;
4286 -> 1449;
4287 -> 4286;
4287 -> 1451;
4287 -> 1449;
4288 -> 1447;
4288 -> 1479;
4288 -> 1605;
4288 -> 4287;
4288 -> 1614;
4288 -> 1475;
4288 -> 1476;
4288 -> 4273;
4288 -> 1486;
4288 -> 1478;
4289 -> 1629;
4290 -> 4289;
4290 -> 1498;
4291 -> 4290;
4291 -> 1500;
4291 -> 1498;
4292 -> 1496;
4292 -> 1530;
4292 -> 1625;
4292 -> 4291;
4292 -> 1634;
4292 -> 1524;
4292 -> 1525;
4292 -> 4277;
4292 -> 1532;
4292 -> 1529;
4293 -> 1649;
4294 -> 4293;
4294 -> 1544;
4295 -> 4294;
4295 -> 1546;
4295 -> 1544;
4296 -> 1542;
4296 -> 1576;
4296 -> 1645;
4296 -> 4295;
4296 -> 1654;
4296 -> 1570;
4296 -> 1571;
4296 -> 4281;
4296 -> 1578;
4296 -> 1575;
4297 -> 1590;
4298 -> 4297;
4298 -> 1411;
4299 -> 4298;
4299 -> 1413;
4299 -> 1411;
4300 -> 1609;
4301 -> 4300;
4301 -> 1449;
4302 -> 4301;
4302 -> 1451;
4302 -> 1449;
4303 -> 1447;
4303 -> 1479;
4303 -> 1605;
4303 -> 4302;
4303 -> 1614;
4303 -> 1475;
4303 -> 1476;
4303 -> 4288;
4303 -> 1486;
4303 -> 1478;
4304 -> 1629;
4305 -> 4304;
4305 -> 1498;
4306 -> 4305;
4306 -> 1500;
4306 -> 1498;
4307 -> 1496;
4307 -> 1530;
4307 -> 1625;
4307 -> 4306;
4307 -> 1634;
4307 -> 1524;
4307 -> 1525;
4307 -> 4292;
4307 -> 1532;
4307 -> 1529;
4308 -> 1649;
4309 -> 4308;
4309 -> 1544;
4310 -> 4309;
4310 -> 1546;
4310 -> 1544;
4311 -> 1542;
4311 -> 1576;
4311 -> 1645;
4311 -> 4310;
4311 -> 1654;
4311 -> 1570;
4311 -> 1571;
4311 -> 4296;
4311 -> 1578;
4311 -> 1575;
4312 -> 1590;
4313 -> 4312;
4313 -> 1411;
4314 -> 4313;
4314 -> 1413;
4314 -> 1411;
4315 -> 1609;
4316 -> 4315;
4316 -> 1449;
4317 -> 4316;
4317 -> 1451;
4317 -> 1449;
4318 -> 1447;
4318 -> 1479;
4318 -> 1605;
4318 -> 4317;
4318 -> 1614;
4318 -> 1475;
4318 -> 1476;
4318 -> 4303;
4318 -> 1486;
4318 -> 1478;
4319 -> 1629;
4320 -> 4319;
4320 -> 1498;
4321 -> 4320;
4321 -> 1500;
4321 -> 1498;
4322 -> 1496;
4322 -> 1530;
4322 -> 1625;
4322 -> 4321;
4322 -> 1634;
4322 -> 1524;
4322 -> 1525;
4322 -> 4307;
4322 -> 1532;
4322 -> 1529;
4323 -> 1649;
4324 -> 4323;
4324 -> 1544;
4325 -> 4324;
4325 -> 1546;
4325 -> 1544;
4326 -> 1542;
4326 -> 1576;
4326 -> 1645;
4326 -> 4325;
4326 -> 1654;
4326 -> 1570;
4326 -> 1571;
4326 -> 4311;
4326 -> 1578;
4326 -> 1575;
4327 -> 1590;
4328 -> 4327;
4328 -> 1411;
4329 -> 4328;
4329 -> 1413;
4329 -> 1411;
4330 -> 1609;
4331 -> 4330;
4331 -> 1449;
4332 -> 4331;
4332 -> 1451;
4332 -> 1449;
4333 -> 1447;
4333 -> 1479;
4333 -> 1605;
4333 -> 4332;
4333 -> 1614;
4333 -> 1475;
4333 -> 1476;
4333 -> 4318;
4333 -> 1486;
4333 -> 1478;
4334 -> 1629;
4335 -> 4334;
4335 -> 1498;
4336 -> 4335;
4336 -> 1500;
4336 -> 1498;
4337 -> 1496;
4337 -> 1530;
4337 -> 1625;
4337 -> 4336;
4337 -> 1634;
4337 -> 1524;
4337 -> 1525;
4337 -> 4322;
4337 -> 1532;
4337 -> 1529;
4338 -> 1649;
4339 -> 4338;
4339 -> 1544;
4340 -> 4339;
4340 -> 1546;
4340 -> 1544;
4341 -> 1542;
4341 -> 1576;
4341 -> 1645;
4341 -> 4340;
4341 -> 1654;
4341 -> 1570;
4341 -> 1571;
4341 -> 4326;
4341 -> 1578;
4341 -> 1575;
4342 -> 1590;
4343 -> 4342;
4343 -> 1411;
4344 -> 4343;
4344 -> 1413;
4344 -> 1411;
4345 -> 1609;
4346 -> 4345;
4346 -> 1449;
4347 -> 4346;
4347 -> 1451;
4347 -> 1449;
4348 -> 1447;
4348 -> 1479;
4348 -> 1605;
4348 -> 4347;
4348 -> 1614;
4348 -> 1475;
4348 -> 1476;
4348 -> 4333;
4348 -> 1486;
4348 -> 1478;
4349 -> 1629;
4350 -> 4349;
4350 -> 1498;
4351 -> 4350;
4351 -> 1500;
4351 -> 1498;
4352 -> 1496;
4352 -> 1530;
4352 -> 1625;
4352 -> 4351;
4352 -> 1634;
4352 -> 1524;
4352 -> 1525;
4352 -> 4337;
4352 -> 1532;
4352 -> 1529;
4353 -> 1649;
4354 -> 4353;
4354 -> 1544;
4355 -> 4354;
4355 -> 1546;
4355 -> 1544;
4356 -> 1542;
4356 -> 1576;
4356 -> 1645;
4356 -> 4355;
4356 -> 1654;
4356 -> 1570;
4356 -> 1571;
4356 -> 4341;
4356 -> 1578;
4356 -> 1575;
4357 -> 1590;
4358 -> 4357;
4358 -> 1411;
4359 -> 4358;
4359 -> 1413;
4359 -> 1411;
4360 -> 1609;
4361 -> 4360;
4361 -> 1449;
4362 -> 4361;
4362 -> 1451;
4362 -> 1449;
4363 -> 1447;
4363 -> 1479;
4363 -> 1605;
4363 -> 4362;
4363 -> 1614;
4363 -> 1475;
4363 -> 1476;
4363 -> 4348;
4363 -> 1486;
4363 -> 1478;
4364 -> 1629;
4365 -> 4364;
4365 -> 1498;
4366 -> 4365;
4366 -> 1500;
4366 -> 1498;
4367 -> 1496;
4367 -> 1530;
4367 -> 1625;
4367 -> 4366;
4367 -> 1634;
4367 -> 1524;
4367 -> 1525;
4367 -> 4352;
4367 -> 1532;
4367 -> 1529;
4368 -> 1649;
4369 -> 4368;
4369 -> 1544;
4370 -> 4369;
4370 -> 1546;
4370 -> 1544;
4371 -> 1542;
4371 -> 1576;
4371 -> 1645;
4371 -> 4370;
4371 -> 1654;
4371 -> 1570;
4371 -> 1571;
4371 -> 4356;
4371 -> 1578;
4371 -> 1575;
4372 -> 1590;
4373 -> 4372;
4373 -> 1411;
4374 -> 4373;
4374 -> 1413;
4374 -> 1411;
4375 -> 1609;
4376 -> 4375;
4376 -> 1449;
4377 -> 4376;
4377 -> 1451;
4377 -> 1449;
4378 -> 1447;
4378 -> 1479;
4378 -> 1605;
4378 -> 4377;
4378 -> 1614;
4378 -> 1475;
4378 -> 1476;
4378 -> 4363;
4378 -> 1486;
4378 -> 1478;
4379 -> 1629;
4380 -> 4379;
4380 -> 1498;
4381 -> 4380;
4381 -> 1500;
4381 -> 1498;
4382 -> 1496;
4382 -> 1530;
4382 -> 1625;
4382 -> 4381;
4382 -> 1634;
4382 -> 1524;
4382 -> 1525;
4382 -> 4367;
4382 -> 1532;
4382 -> 1529;
4383 -> 1649;
4384 -> 4383;
4384 -> 1544;
4385 -> 4384;
4385 -> 1546;
4385 -> 1544;
4386 -> 1542;
4386 -> 1576;
4386 -> 1645;
4386 -> 4385;
4386 -> 1654;
4386 -> 1570;
4386 -> 1571;
4386 -> 4371;
4386 -> 1578;
4386 -> 1575;
4387 -> 1590;
4388 -> 4387;
4388 -> 1411;
4389 -> 4388;
4389 -> 1413;
4389 -> 1411;
4390 -> 1609;
4391 -> 4390;
4391 -> 1449;
4392 -> 4391;
4392 -> 1451;
4392 -> 1449;
4393 -> 1447;
4393 -> 1479;
4393 -> 1605;
4393 -> 4392;
4393 -> 1614;
4393 -> 1475;
4393 -> 1476;
4393 -> 4378;
4393 -> 1486;
4393 -> 1478;
4394 -> 1629;
4395 -> 4394;
4395 -> 1498;
4396 -> 4395;
4396 -> 1500;
4396 -> 1498;
4397 -> 1496;
4397 -> 1530;
4397 -> 1625;
4397 -> 4396;
4397 -> 1634;
4397 -> 1524;
4397 -> 1525;
4397 -> 4382;
4397 -> 1532;
4397 -> 1529;
4398 -> 1649;
4399 -> 4398;
4399 -> 1544;
4400 -> 4399;
4400 -> 1546;
4400 -> 1544;
4401 -> 1542;
4401 -> 1576;
4401 -> 1645;
4401 -> 4400;
4401 -> 1654;
4401 -> 1570;
4401 -> 1571;
4401 -> 4386;
4401 -> 1578;
4401 -> 1575;
4402 -> 1590;
4403 -> 4402;
4403 -> 1411;
4404 -> 4403;
4404 -> 1413;
4404 -> 1411;
4405 -> 1609;
4406 -> 4405;
4406 -> 1449;
4407 -> 4406;
4407 -> 1451;
4407 -> 1449;
4408 -> 1447;
4408 -> 1479;
4408 -> 1605;
4408 -> 4407;
4408 -> 1614;
4408 -> 1475;
4408 -> 1476;
4408 -> 4393;
4408 -> 1486;
4408 -> 1478;
4409 -> 1629;
4410 -> 4409;
4410 -> 1498;
4411 -> 4410;
4411 -> 1500;
4411 -> 1498;
4412 -> 1496;
4412 -> 1530;
4412 -> 1625;
4412 -> 4411;
4412 -> 1634;
4412 -> 1524;
4412 -> 1525;
4412 -> 4397;
4412 -> 1532;
4412 -> 1529;
4413 -> 1649;
4414 -> 4413;
4414 -> 1544;
4415 -> 4414;
4415 -> 1546;
4415 -> 1544;
4416 -> 1542;
4416 -> 1576;
4416 -> 1645;
4416 -> 4415;
4416 -> 1654;
4416 -> 1570;
4416 -> 1571;
4416 -> 4401;
4416 -> 1578;
4416 -> 1575;
4417 -> 1590;
4418 -> 4417;
4418 -> 1411;
4419 -> 4418;
4419 -> 1413;
4419 -> 1411;
4420 -> 1609;
4421 -> 4420;
4421 -> 1449;
4422 -> 4421;
4422 -> 1451;
4422 -> 1449;
4423 -> 1447;
4423 -> 1479;
4423 -> 1605;
4423 -> 4422;
4423 -> 1614;
4423 -> 1475;
4423 -> 1476;
4423 -> 4408;
4423 -> 1486;
4423 -> 1478;
4424 -> 1629;
4425 -> 4424;
4425 -> 1498;
4426 -> 4425;
4426 -> 1500;
4426 -> 1498;
4427 -> 1496;
4427 -> 1530;
4427 -> 1625;
4427 -> 4426;
4427 -> 1634;
4427 -> 1524;
4427 -> 1525;
4427 -> 4412;
4427 -> 1532;
4427 -> 1529;
4428 -> 1649;
4429 -> 4428;
4429 -> 1544;
4430 -> 4429;
4430 -> 1546;
4430 -> 1544;
4431 -> 1542;
4431 -> 1576;
4431 -> 1645;
4431 -> 4430;
4431 -> 1654;
4431 -> 1570;
4431 -> 1571;
4431 -> 4416;
4431 -> 1578;
4431 -> 1575;
4432 -> 1590;
4433 -> 4432;
4433 -> 1411;
4434 -> 4433;
4434 -> 1413;
4434 -> 1411;
4435 -> 1609;
4436 -> 4435;
4436 -> 1449;
4437 -> 4436;
4437 -> 1451;
4437 -> 1449;
4438 -> 1447;
4438 -> 1479;
4438 -> 1605;
4438 -> 4437;
4438 -> 1614;
4438 -> 1475;
4438 -> 1476;
4438 -> 4423;
4438 -> 1486;
4438 -> 1478;
4439 -> 1629;
4440 -> 4439;
4440 -> 1498;
4441 -> 4440;
4441 -> 1500;
4441 -> 1498;
4442 -> 1496;
4442 -> 1530;
4442 -> 1625;
4442 -> 4441;
4442 -> 1634;
4442 -> 1524;
4442 -> 1525;
4442 -> 4427;
4442 -> 1532;
4442 -> 1529;
4443 -> 1649;
4444 -> 4443;
4444 -> 1544;
4445 -> 4444;
4445 -> 1546;
4445 -> 1544;
4446 -> 1542;
4446 -> 1576;
4446 -> 1645;
4446 -> 4445;
4446 -> 1654;
4446 -> 1570;
4446 -> 1571;
4446 -> 4431;
4446 -> 1578;
4446 -> 1575;
4447 -> 1590;
4448 -> 4447;
4448 -> 1411;
4449 -> 4448;
4449 -> 1413;
4449 -> 1411;
4450 -> 1609;
4451 -> 4450;
4451 -> 1449;
4452 -> 4451;
4452 -> 1451;
4452 -> 1449;
4453 -> 1447;
4453 -> 1479;
4453 -> 1605;
4453 -> 4452;
4453 -> 1614;
4453 -> 1475;
4453 -> 1476;
4453 -> 4438;
4453 -> 1486;
4453 -> 1478;
4454 -> 1629;
4455 -> 4454;
4455 -> 1498;
4456 -> 4455;
4456 -> 1500;
4456 -> 1498;
4457 -> 1496;
4457 -> 1530;
4457 -> 1625;
4457 -> 4456;
4457 -> 1634;
4457 -> 1524;
4457 -> 1525;
4457 -> 4442;
4457 -> 1532;
4457 -> 1529;
4458 -> 1649;
4459 -> 4458;
4459 -> 1544;
4460 -> 4459;
4460 -> 1546;
4460 -> 1544;
4461 -> 1542;
4461 -> 1576;
4461 -> 1645;
4461 -> 4460;
4461 -> 1654;
4461 -> 1570;
4461 -> 1571;
4461 -> 4446;
4461 -> 1578;
4461 -> 1575;
4462 -> 1590;
4463 -> 4462;
4463 -> 1411;
4464 -> 4463;
4464 -> 1413;
4464 -> 1411;
4465 -> 1609;
4466 -> 4465;
4466 -> 1449;
4467 -> 4466;
4467 -> 1451;
4467 -> 1449;
4468 -> 1447;
4468 -> 1479;
4468 -> 1605;
4468 -> 4467;
4468 -> 1614;
4468 -> 1475;
4468 -> 1476;
4468 -> 4453;
4468 -> 1486;
4468 -> 1478;
4469 -> 1629;
4470 -> 4469;
4470 -> 1498;
4471 -> 4470;
4471 -> 1500;
4471 -> 1498;
4472 -> 1496;
4472 -> 1530;
4472 -> 1625;
4472 -> 4471;
4472 -> 1634;
4472 -> 1524;
4472 -> 1525;
4472 -> 4457;
4472 -> 1532;
4472 -> 1529;
4473 -> 1649;
4474 -> 4473;
4474 -> 1544;
4475 -> 4474;
4475 -> 1546;
4475 -> 1544;
4476 -> 1542;
4476 -> 1576;
4476 -> 1645;
4476 -> 4475;
4476 -> 1654;
4476 -> 1570;
4476 -> 1571;
4476 -> 4461;
4476 -> 1578;
4476 -> 1575;
4477 -> 1590;
4478 -> 4477;
4478 -> 1411;
4479 -> 4478;
4479 -> 1413;
4479 -> 1411;
4480 -> 1609;
4481 -> 4480;
4481 -> 1449;
4482 -> 4481;
4482 -> 1451;
4482 -> 1449;
4483 -> 1447;
4483 -> 1479;
4483 -> 1605;
4483 -> 4482;
4483 -> 1614;
4483 -> 1475;
4483 -> 1476;
4483 -> 4468;
4483 -> 1486;
4483 -> 1478;
4484 -> 1629;
4485 -> 4484;
4485 -> 1498;
4486 -> 4485;
4486 -> 1500;
4486 -> 1498;
4487 -> 1496;
4487 -> 1530;
4487 -> 1625;
4487 -> 4486;
4487 -> 1634;
4487 -> 1524;
4487 -> 1525;
4487 -> 4472;
4487 -> 1532;
4487 -> 1529;
4488 -> 1649;
4489 -> 4488;
4489 -> 1544;
4490 -> 4489;
4490 -> 1546;
4490 -> 1544;
4491 -> 1542;
4491 -> 1576;
4491 -> 1645;
4491 -> 4490;
4491 -> 1654;
4491 -> 1570;
4491 -> 1571;
4491 -> 4476;
4491 -> 1578;
4491 -> 1575;
4492 -> 1590;
4493 -> 4492;
4493 -> 1411;
4494 -> 4493;
4494 -> 1413;
4494 -> 1411;
4495 -> 1609;
4496 -> 4495;
4496 -> 1449;
4497 -> 4496;
4497 -> 1451;
4497 -> 1449;
4498 -> 1447;
4498 -> 1479;
4498 -> 1605;
4498 -> 4497;
4498 -> 1614;
4498 -> 1475;
4498 -> 1476;
4498 -> 4483;
4498 -> 1486;
4498 -> 1478;
4499 -> 1629;
4500 -> 4499;
4500 -> 1498;
4501 -> 4500;
4501 -> 1500;
4501 -> 1498;
4502 -> 1496;
4502 -> 1530;
4502 -> 1625;
4502 -> 4501;
4502 -> 1634;
4502 -> 1524;
4502 -> 1525;
4502 -> 4487;
4502 -> 1532;
4502 -> 1529;
4503 -> 1649;
4504 -> 4503;
4504 -> 1544;
4505 -> 4504;
4505 -> 1546;
4505 -> 1544;
4506 -> 1542;
4506 -> 1576;
4506 -> 1645;
4506 -> 4505;
4506 -> 1654;
4506 -> 1570;
4506 -> 1571;
4506 -> 4491;
4506 -> 1578;
4506 -> 1575;
4507 -> 1590;
4508 -> 4507;
4508 -> 1411;
4509 -> 4508;
4509 -> 1413;
4509 -> 1411;
4510 -> 1609;
4511 -> 4510;
4511 -> 1449;
4512 -> 4511;
4512 -> 1451;
4512 -> 1449;
4513 -> 1447;
4513 -> 1479;
4513 -> 1605;
4513 -> 4512;
4513 -> 1614;
4513 -> 1475;
4513 -> 1476;
4513 -> 4498;
4513 -> 1486;
4513 -> 1478;
4514 -> 1629;
4515 -> 4514;
4515 -> 1498;
4516 -> 4515;
4516 -> 1500;
4516 -> 1498;
4517 -> 1496;
4517 -> 1530;
4517 -> 1625;
4517 -> 4516;
4517 -> 1634;
4517 -> 1524;
4517 -> 1525;
4517 -> 4502;
4517 -> 1532;
4517 -> 1529;
4518 -> 1649;
4519 -> 4518;
4519 -> 1544;
4520 -> 4519;
4520 -> 1546;
4520 -> 1544;
4521 -> 1542;
4521 -> 1576;
4521 -> 1645;
4521 -> 4520;
4521 -> 1654;
4521 -> 1570;
4521 -> 1571;
4521 -> 4506;
4521 -> 1578;
4521 -> 1575;
4522 -> 1590;
4523 -> 4522;
4523 -> 1411;
4524 -> 4523;
4524 -> 1413;
4524 -> 1411;
4525 -> 1609;
4526 -> 4525;
4526 -> 1449;
4527 -> 4526;
4527 -> 1451;
4527 -> 1449;
4528 -> 1447;
4528 -> 1479;
4528 -> 1605;
4528 -> 4527;
4528 -> 1614;
4528 -> 1475;
4528 -> 1476;
4528 -> 4513;
4528 -> 1486;
4528 -> 1478;
4529 -> 1629;
4530 -> 4529;
4530 -> 1498;
4531 -> 4530;
4531 -> 1500;
4531 -> 1498;
4532 -> 1496;
4532 -> 1530;
4532 -> 1625;
4532 -> 4531;
4532 -> 1634;
4532 -> 1524;
4532 -> 1525;
4532 -> 4517;
4532 -> 1532;
4532 -> 1529;
4533 -> 1649;
4534 -> 4533;
4534 -> 1544;
4535 -> 4534;
4535 -> 1546;
4535 -> 1544;
4536 -> 1542;
4536 -> 1576;
4536 -> 1645;
4536 -> 4535;
4536 -> 1654;
4536 -> 1570;
4536 -> 1571;
4536 -> 4521;
4536 -> 1578;
4536 -> 1575;
4537 -> 1590;
4538 -> 4537;
4538 -> 1411;
4539 -> 4538;
4539 -> 1413;
4539 -> 1411;
4540 -> 1609;
4541 -> 4540;
4541 -> 1449;
4542 -> 4541;
4542 -> 1451;
4542 -> 1449;
4543 -> 1447;
4543 -> 1479;
4543 -> 1605;
4543 -> 4542;
4543 -> 1614;
4543 -> 1475;
4543 -> 1476;
4543 -> 4528;
4543 -> 1486;
4543 -> 1478;
4544 -> 1629;
4545 -> 4544;
4545 -> 1498;
4546 -> 4545;
4546 -> 1500;
4546 -> 1498;
4547 -> 1496;
4547 -> 1530;
4547 -> 1625;
4547 -> 4546;
4547 -> 1634;
4547 -> 1524;
4547 -> 1525;
4547 -> 4532;
4547 -> 1532;
4547 -> 1529;
4548 -> 1649;
4549 -> 4548;
4549 -> 1544;
4550 -> 4549;
4550 -> 1546;
4550 -> 1544;
4551 -> 1542;
4551 -> 1576;
4551 -> 1645;
4551 -> 4550;
4551 -> 1654;
4551 -> 1570;
4551 -> 1571;
4551 -> 4536;
4551 -> 1578;
4551 -> 1575;
4552 -> 1590;
4553 -> 4552;
4553 -> 1411;
4554 -> 4553;
4554 -> 1413;
4554 -> 1411;
4555 -> 1609;
4556 -> 4555;
4556 -> 1449;
4557 -> 4556;
4557 -> 1451;
4557 -> 1449;
4558 -> 1447;
4558 -> 1479;
4558 -> 1605;
4558 -> 4557;
4558 -> 1614;
4558 -> 1475;
4558 -> 1476;
4558 -> 4543;
4558 -> 1486;
4558 -> 1478;
4559 -> 1629;
4560 -> 4559;
4560 -> 1498;
4561 -> 4560;
4561 -> 1500;
4561 -> 1498;
4562 -> 1496;
4562 -> 1530;
4562 -> 1625;
4562 -> 4561;
4562 -> 1634;
4562 -> 1524;
4562 -> 1525;
4562 -> 4547;
4562 -> 1532;
4562 -> 1529;
4563 -> 1649;
4564 -> 4563;
4564 -> 1544;
4565 -> 4564;
4565 -> 1546;
4565 -> 1544;
4566 -> 1542;
4566 -> 1576;
4566 -> 1645;
4566 -> 4565;
4566 -> 1654;
4566 -> 1570;
4566 -> 1571;
4566 -> 4551;
4566 -> 1578;
4566 -> 1575;
4567 -> 1590;
4568 -> 4567;
4568 -> 1411;
4569 -> 4568;
4569 -> 1413;
4569 -> 1411;
4570 -> 1609;
4571 -> 4570;
4571 -> 1449;
4572 -> 4571;
4572 -> 1451;
4572 -> 1449;
4573 -> 1447;
4573 -> 1479;
4573 -> 1605;
4573 -> 4572;
4573 -> 1614;
4573 -> 1475;
4573 -> 1476;
4573 -> 4558;
4573 -> 1486;
4573 -> 1478;
4574 -> 1629;
4575 -> 4574;
4575 -> 1498;
4576 -> 4575;
4576 -> 1500;
4576 -> 1498;
4577 -> 1496;
4577 -> 1530;
4577 -> 1625;
4577 -> 4576;
4577 -> 1634;
4577 -> 1524;
4577 -> 1525;
4577 -> 4562;
4577 -> 1532;
4577 -> 1529;
4578 -> 1649;
4579 -> 4578;
4579 -> 1544;
4580 -> 4579;
4580 -> 1546;
4580 -> 1544;
4581 -> 1542;
4581 -> 1576;
4581 -> 1645;
4581 -> 4580;
4581 -> 1654;
4581 -> 1570;
4581 -> 1571;
4581 -> 4566;
4581 -> 1578;
4581 -> 1575;
4582 -> 1590;
4583 -> 4582;
4583 -> 1411;
4584 -> 4583;
4584 -> 1413;
4584 -> 1411;
4585 -> 1609;
4586 -> 4585;
4586 -> 1449;
4587 -> 4586;
4587 -> 1451;
4587 -> 1449;
4588 -> 1447;
4588 -> 1479;
4588 -> 1605;
4588 -> 4587;
4588 -> 1614;
4588 -> 1475;
4588 -> 1476;
4588 -> 4573;
4588 -> 1486;
4588 -> 1478;
4589 -> 1629;
4590 -> 4589;
4590 -> 1498;
4591 -> 4590;
4591 -> 1500;
4591 -> 1498;
4592 -> 1496;
4592 -> 1530;
4592 -> 1625;
4592 -> 4591;
4592 -> 1634;
4592 -> 1524;
4592 -> 1525;
4592 -> 4577;
4592 -> 1532;
4592 -> 1529;
4593 -> 1649;
4594 -> 4593;
4594 -> 1544;
4595 -> 4594;
4595 -> 1546;
4595 -> 1544;
4596 -> 1542;
4596 -> 1576;
4596 -> 1645;
4596 -> 4595;
4596 -> 1654;
4596 -> 1570;
4596 -> 1571;
4596 -> 4581;
4596 -> 1578;
4596 -> 1575;
4597 -> 1590;
4598 -> 4597;
4598 -> 1411;
4599 -> 4598;
4599 -> 1413;
4599 -> 1411;
4600 -> 1609;
4601 -> 4600;
4601 -> 1449;
4602 -> 4601;
4602 -> 1451;
4602 -> 1449;
4603 -> 1447;
4603 -> 1479;
4603 -> 1605;
4603 -> 4602;
4603 -> 1614;
4603 -> 1475;
4603 -> 1476;
4603 -> 4588;
4603 -> 1486;
4603 -> 1478;
4604 -> 1629;
4605 -> 4604;
4605 -> 1498;
4606 -> 4605;
4606 -> 1500;
4606 -> 1498;
4607 -> 1496;
4607 -> 1530;
4607 -> 1625;
4607 -> 4606;
4607 -> 1634;
4607 -> 1524;
4607 -> 1525;
4607 -> 4592;
4607 -> 1532;
4607 -> 1529;
4608 -> 1649;
4609 -> 4608;
4609 -> 1544;
4610 -> 4609;
4610 -> 1546;
4610 -> 1544;
4611 -> 1542;
4611 -> 1576;
4611 -> 1645;
4611 -> 4610;
4611 -> 1654;
4611 -> 1570;
4611 -> 1571;
4611 -> 4596;
4611 -> 1578;
4611 -> 1575;
4612 -> 1590;
4613 -> 4612;
4613 -> 1411;
4614 -> 4613;
4614 -> 1413;
4614 -> 1411;
4615 -> 1609;
4616 -> 4615;
4616 -> 1449;
4617 -> 4616;
4617 -> 1451;
4617 -> 1449;
4618 -> 1447;
4618 -> 1479;
4618 -> 1605;
4618 -> 4617;
4618 -> 1614;
4618 -> 1475;
4618 -> 1476;
4618 -> 4603;
4618 -> 1486;
4618 -> 1478;
4619 -> 1629;
4620 -> 4619;
4620 -> 1498;
4621 -> 4620;
4621 -> 1500;
4621 -> 1498;
4622 -> 1496;
4622 -> 1530;
4622 -> 1625;
4622 -> 4621;
4622 -> 1634;
4622 -> 1524;
4622 -> 1525;
4622 -> 4607;
4622 -> 1532;
4622 -> 1529;
4623 -> 1649;
4624 -> 4623;
4624 -> 1544;
4625 -> 4624;
4625 -> 1546;
4625 -> 1544;
4626 -> 1542;
4626 -> 1576;
4626 -> 1645;
4626 -> 4625;
4626 -> 1654;
4626 -> 1570;
4626 -> 1571;
4626 -> 4611;
4626 -> 1578;
4626 -> 1575;
4627 -> 1590;
4628 -> 4627;
4628 -> 1411;
4629 -> 4628;
4629 -> 1413;
4629 -> 1411;
4630 -> 1609;
4631 -> 4630;
4631 -> 1449;
4632 -> 4631;
4632 -> 1451;
4632 -> 1449;
4633 -> 1447;
4633 -> 1479;
4633 -> 1605;
4633 -> 4632;
4633 -> 1614;
4633 -> 1475;
4633 -> 1476;
4633 -> 4618;
4633 -> 1486;
4633 -> 1478;
4634 -> 1629;
4635 -> 4634;
4635 -> 1498;
4636 -> 4635;
4636 -> 1500;
4636 -> 1498;
4637 -> 1496;
4637 -> 1530;
4637 -> 1625;
4637 -> 4636;
4637 -> 1634;
4637 -> 1524;
4637 -> 1525;
4637 -> 4622;
4637 -> 1532;
4637 -> 1529;
4638 -> 1649;
4639 -> 4638;
4639 -> 1544;
4640 -> 4639;
4640 -> 1546;
4640 -> 1544;
4641 -> 1542;
4641 -> 1576;
4641 -> 1645;
4641 -> 4640;
4641 -> 1654;
4641 -> 1570;
4641 -> 1571;
4641 -> 4626;
4641 -> 1578;
4641 -> 1575;
4642 -> 1590;
4643 -> 4642;
4643 -> 1411;
4644 -> 4643;
4644 -> 1413;
4644 -> 1411;
4645 -> 1609;
4646 -> 4645;
4646 -> 1449;
4647 -> 4646;
4647 -> 1451;
4647 -> 1449;
4648 -> 1447;
4648 -> 1479;
4648 -> 1605;
4648 -> 4647;
4648 -> 1614;
4648 -> 1475;
4648 -> 1476;
4648 -> 4633;
4648 -> 1486;
4648 -> 1478;
4649 -> 1629;
4650 -> 4649;
4650 -> 1498;
4651 -> 4650;
4651 -> 1500;
4651 -> 1498;
4652 -> 1496;
4652 -> 1530;
4652 -> 1625;
4652 -> 4651;
4652 -> 1634;
4652 -> 1524;
4652 -> 1525;
4652 -> 4637;
4652 -> 1532;
4652 -> 1529;
4653 -> 1649;
4654 -> 4653;
4654 -> 1544;
4655 -> 4654;
4655 -> 1546;
4655 -> 1544;
4656 -> 1542;
4656 -> 1576;
4656 -> 1645;
4656 -> 4655;
4656 -> 1654;
4656 -> 1570;
4656 -> 1571;
4656 -> 4641;
4656 -> 1578;
4656 -> 1575;
4657 -> 1590;
4658 -> 4657;
4658 -> 1411;
4659 -> 4658;
4659 -> 1413;
4659 -> 1411;
4660 -> 1609;
4661 -> 4660;
4661 -> 1449;
4662 -> 4661;
4662 -> 1451;
4662 -> 1449;
4663 -> 1447;
4663 -> 1479;
4663 -> 1605;
4663 -> 4662;
4663 -> 1614;
4663 -> 1475;
4663 -> 1476;
4663 -> 4648;
4663 -> 1486;
4663 -> 1478;
4664 -> 1629;
4665 -> 4664;
4665 -> 1498;
4666 -> 4665;
4666 -> 1500;
4666 -> 1498;
4667 -> 1496;
4667 -> 1530;
4667 -> 1625;
4667 -> 4666;
4667 -> 1634;
4667 -> 1524;
4667 -> 1525;
4667 -> 4652;
4667 -> 1532;
4667 -> 1529;
4668 -> 1649;
4669 -> 4668;
4669 -> 1544;
4670 -> 4669;
4670 -> 1546;
4670 -> 1544;
4671 -> 1542;
4671 -> 1576;
4671 -> 1645;
4671 -> 4670;
4671 -> 1654;
4671 -> 1570;
4671 -> 1571;
4671 -> 4656;
4671 -> 1578;
4671 -> 1575;
4672 -> 1590;
4673 -> 4672;
4673 -> 1411;
4674 -> 4673;
4674 -> 1413;
4674 -> 1411;
4675 -> 1609;
4676 -> 4675;
4676 -> 1449;
4677 -> 4676;
4677 -> 1451;
4677 -> 1449;
4678 -> 1447;
4678 -> 1479;
4678 -> 1605;
4678 -> 4677;
4678 -> 1614;
4678 -> 1475;
4678 -> 1476;
4678 -> 4663;
4678 -> 1486;
4678 -> 1478;
4679 -> 1629;
4680 -> 4679;
4680 -> 1498;
4681 -> 4680;
4681 -> 1500;
4681 -> 1498;
4682 -> 1496;
4682 -> 1530;
4682 -> 1625;
4682 -> 4681;
4682 -> 1634;
4682 -> 1524;
4682 -> 1525;
4682 -> 4667;
4682 -> 1532;
4682 -> 1529;
4683 -> 1649;
4684 -> 4683;
4684 -> 1544;
4685 -> 4684;
4685 -> 1546;
4685 -> 1544;
4686 -> 1542;
4686 -> 1576;
4686 -> 1645;
4686 -> 4685;
4686 -> 1654;
4686 -> 1570;
4686 -> 1571;
4686 -> 4671;
4686 -> 1578;
4686 -> 1575;
4687 -> 1590;
4688 -> 4687;
4688 -> 1411;
4689 -> 4688;
4689 -> 1413;
4689 -> 1411;
4690 -> 1609;
4691 -> 4690;
4691 -> 1449;
4692 -> 4691;
4692 -> 1451;
4692 -> 1449;
4693 -> 1447;
4693 -> 1479;
4693 -> 1605;
4693 -> 4692;
4693 -> 1614;
4693 -> 1475;
4693 -> 1476;
4693 -> 4678;
4693 -> 1486;
4693 -> 1478;
4694 -> 1629;
4695 -> 4694;
4695 -> 1498;
4696 -> 4695;
4696 -> 1500;
4696 -> 1498;
4697 -> 1496;
4697 -> 1530;
4697 -> 1625;
4697 -> 4696;
4697 -> 1634;
4697 -> 1524;
4697 -> 1525;
4697 -> 4682;
4697 -> 1532;
4697 -> 1529;
4698 -> 1649;
4699 -> 4698;
4699 -> 1544;
4700 -> 4699;
4700 -> 1546;
4700 -> 1544;
4701 -> 1542;
4701 -> 1576;
4701 -> 1645;
4701 -> 4700;
4701 -> 1654;
4701 -> 1570;
4701 -> 1571;
4701 -> 4686;
4701 -> 1578;
4701 -> 1575;
4702 -> 1590;
4703 -> 4702;
4703 -> 1411;
4704 -> 4703;
4704 -> 1413;
4704 -> 1411;
4705 -> 1609;
4706 -> 4705;
4706 -> 1449;
4707 -> 4706;
4707 -> 1451;
4707 -> 1449;
4708 -> 1447;
4708 -> 1479;
4708 -> 1605;
4708 -> 4707;
4708 -> 1614;
4708 -> 1475;
4708 -> 1476;
4708 -> 4693;
4708 -> 1486;
4708 -> 1478;
4709 -> 1629;
4710 -> 4709;
4710 -> 1498;
4711 -> 4710;
4711 -> 1500;
4711 -> 1498;
4712 -> 1496;
4712 -> 1530;
4712 -> 1625;
4712 -> 4711;
4712 -> 1634;
4712 -> 1524;
4712 -> 1525;
4712 -> 4697;
4712 -> 1532;
4712 -> 1529;
4713 -> 1649;
4714 -> 4713;
4714 -> 1544;
4715 -> 4714;
4715 -> 1546;
4715 -> 1544;
4716 -> 1542;
4716 -> 1576;
4716 -> 1645;
4716 -> 4715;
4716 -> 1654;
4716 -> 1570;
4716 -> 1571;
4716 -> 4701;
4716 -> 1578;
4716 -> 1575;
4717 -> 1590;
4718 -> 4717;
4718 -> 1411;
4719 -> 4718;
4719 -> 1413;
4719 -> 1411;
4720 -> 1609;
4721 -> 4720;
4721 -> 1449;
4722 -> 4721;
4722 -> 1451;
4722 -> 1449;
4723 -> 1447;
4723 -> 1479;
4723 -> 1605;
4723 -> 4722;
4723 -> 1614;
4723 -> 1475;
4723 -> 1476;
4723 -> 4708;
4723 -> 1486;
4723 -> 1478;
4724 -> 1629;
4725 -> 4724;
4725 -> 1498;
4726 -> 4725;
4726 -> 1500;
4726 -> 1498;
4727 -> 1496;
4727 -> 1530;
4727 -> 1625;
4727 -> 4726;
4727 -> 1634;
4727 -> 1524;
4727 -> 1525;
4727 -> 4712;
4727 -> 1532;
4727 -> 1529;
4728 -> 1649;
4729 -> 4728;
4729 -> 1544;
4730 -> 4729;
4730 -> 1546;
4730 -> 1544;
4731 -> 1542;
4731 -> 1576;
4731 -> 1645;
4731 -> 4730;
4731 -> 1654;
4731 -> 1570;
4731 -> 1571;
4731 -> 4716;
4731 -> 1578;
4731 -> 1575;
4732 -> 1590;
4733 -> 4732;
4733 -> 1411;
4734 -> 4733;
4734 -> 1413;
4734 -> 1411;
4735 -> 1609;
4736 -> 4735;
4736 -> 1449;
4737 -> 4736;
4737 -> 1451;
4737 -> 1449;
4738 -> 1447;
4738 -> 1479;
4738 -> 1605;
4738 -> 4737;
4738 -> 1614;
4738 -> 1475;
4738 -> 1476;
4738 -> 4723;
4738 -> 1486;
4738 -> 1478;
4739 -> 1629;
4740 -> 4739;
4740 -> 1498;
4741 -> 4740;
4741 -> 1500;
4741 -> 1498;
4742 -> 1496;
4742 -> 1530;
4742 -> 1625;
4742 -> 4741;
4742 -> 1634;
4742 -> 1524;
4742 -> 1525;
4742 -> 4727;
4742 -> 1532;
4742 -> 1529;
4743 -> 1649;
4744 -> 4743;
4744 -> 1544;
4745 -> 4744;
4745 -> 1546;
4745 -> 1544;
4746 -> 1542;
4746 -> 1576;
4746 -> 1645;
4746 -> 4745;
4746 -> 1654;
4746 -> 1570;
4746 -> 1571;
4746 -> 4731;
4746 -> 1578;
4746 -> 1575;
4747 -> 1590;
4748 -> 4747;
4748 -> 1411;
4749 -> 4748;
4749 -> 1413;
4749 -> 1411;
4750 -> 1609;
4751 -> 4750;
4751 -> 1449;
4752 -> 4751;
4752 -> 1451;
4752 -> 1449;
4753 -> 1447;
4753 -> 1479;
4753 -> 1605;
4753 -> 4752;
4753 -> 1614;
4753 -> 1475;
4753 -> 1476;
4753 -> 4738;
4753 -> 1486;
4753 -> 1478;
4754 -> 1629;
4755 -> 4754;
4755 -> 1498;
4756 -> 4755;
4756 -> 1500;
4756 -> 1498;
4757 -> 1496;
4757 -> 1530;
4757 -> 1625;
4757 -> 4756;
4757 -> 1634;
4757 -> 1524;
4757 -> 1525;
4757 -> 4742;
4757 -> 1532;
4757 -> 1529;
4758 -> 1649;
4759 -> 4758;
4759 -> 1544;
4760 -> 4759;
4760 -> 1546;
4760 -> 1544;
4761 -> 1542;
4761 -> 1576;
4761 -> 1645;
4761 -> 4760;
4761 -> 1654;
4761 -> 1570;
4761 -> 1571;
4761 -> 4746;
4761 -> 1578;
4761 -> 1575;
4762 -> 1590;
4763 -> 4762;
4763 -> 1411;
4764 -> 4763;
4764 -> 1413;
4764 -> 1411;
4765 -> 1609;
4766 -> 4765;
4766 -> 1449;
4767 -> 4766;
4767 -> 1451;
4767 -> 1449;
4768 -> 1447;
4768 -> 1479;
4768 -> 1605;
4768 -> 4767;
4768 -> 1614;
4768 -> 1475;
4768 -> 1476;
4768 -> 4753;
4768 -> 1486;
4768 -> 1478;
4769 -> 1629;
4770 -> 4769;
4770 -> 1498;
4771 -> 4770;
4771 -> 1500;
4771 -> 1498;
4772 -> 1496;
4772 -> 1530;
4772 -> 1625;
4772 -> 4771;
4772 -> 1634;
4772 -> 1524;
4772 -> 1525;
4772 -> 4757;
4772 -> 1532;
4772 -> 1529;
4773 -> 1649;
4774 -> 4773;
4774 -> 1544;
4775 -> 4774;
4775 -> 1546;
4775 -> 1544;
4776 -> 1542;
4776 -> 1576;
4776 -> 1645;
4776 -> 4775;
4776 -> 1654;
4776 -> 1570;
4776 -> 1571;
4776 -> 4761;
4776 -> 1578;
4776 -> 1575;
4777 -> 1590;
4778 -> 4777;
4778 -> 1411;
4779 -> 4778;
4779 -> 1413;
4779 -> 1411;
4780 -> 1609;
4781 -> 4780;
4781 -> 1449;
4782 -> 4781;
4782 -> 1451;
4782 -> 1449;
4783 -> 1447;
4783 -> 1479;
4783 -> 1605;
4783 -> 4782;
4783 -> 1614;
4783 -> 1475;
4783 -> 1476;
4783 -> 4768;
4783 -> 1486;
4783 -> 1478;
4784 -> 1629;
4785 -> 4784;
4785 -> 1498;
4786 -> 4785;
4786 -> 1500;
4786 -> 1498;
4787 -> 1496;
4787 -> 1530;
4787 -> 1625;
4787 -> 4786;
4787 -> 1634;
4787 -> 1524;
4787 -> 1525;
4787 -> 4772;
4787 -> 1532;
4787 -> 1529;
4788 -> 1649;
4789 -> 4788;
4789 -> 1544;
4790 -> 4789;
4790 -> 1546;
4790 -> 1544;
4791 -> 1542;
4791 -> 1576;
4791 -> 1645;
4791 -> 4790;
4791 -> 1654;
4791 -> 1570;
4791 -> 1571;
4791 -> 4776;
4791 -> 1578;
4791 -> 1575;
4792 -> 1590;
4793 -> 4792;
4793 -> 1411;
4794 -> 4793;
4794 -> 1413;
4794 -> 1411;
4795 -> 1609;
4796 -> 4795;
4796 -> 1449;
4797 -> 4796;
4797 -> 1451;
4797 -> 1449;
4798 -> 1447;
4798 -> 1479;
4798 -> 1605;
4798 -> 4797;
4798 -> 1614;
4798 -> 1475;
4798 -> 1476;
4798 -> 4783;
4798 -> 1486;
4798 -> 1478;
4799 -> 1629;
4800 -> 4799;
4800 -> 1498;
4801 -> 4800;
4801 -> 1500;
4801 -> 1498;
4802 -> 1496;
4802 -> 1530;
4802 -> 1625;
4802 -> 4801;
4802 -> 1634;
4802 -> 1524;
4802 -> 1525;
4802 -> 4787;
4802 -> 1532;
4802 -> 1529;
4803 -> 1649;
4804 -> 4803;
4804 -> 1544;
4805 -> 4804;
4805 -> 1546;
4805 -> 1544;
4806 -> 1542;
4806 -> 1576;
4806 -> 1645;
4806 -> 4805;
4806 -> 1654;
4806 -> 1570;
4806 -> 1571;
4806 -> 4791;
4806 -> 1578;
4806 -> 1575;
4807 -> 1385;
4807 -> 1383;
4808 -> 1384;
4808 -> 1383;
4809 -> 1386;
4809 -> 1383;
4810 -> 1383;
4811 -> 4807;
4811 -> 4810;
4812 -> 4808;
4812 -> 4810;
4813 -> 4809;
4813 -> 4810;
4814 -> 4811;
4814 -> 1388;
4814 -> 4810;
4815 -> 4810;
4816 -> 4812;
4816 -> 4815;
4816 -> 4810;
4817 -> 4816;
4818 -> 4813;
4818 -> 4817;
4818 -> 4816;
4819 -> 1392;
4819 -> 1391;
4819 -> 4811;
4819 -> 4818;
4820 -> 1364;
4821 -> 1368;
4821 -> 4820;
4821 -> 1364;
4822 -> 4819;
4822 -> 1364;
4823 -> 4822;
4823 -> 1155;
4824 -> 1155;
4825 -> 4823;
4825 -> 4824;
4826 -> 1144;
4826 -> 4824;
4827 -> 4824;
4828 -> 4825;
4828 -> 4827;
4828 -> 4824;
4829 -> 4826;
4829 -> 1115;
4829 -> 1151;
4829 -> 1150;
4829 -> 4824;
4830 -> 4826;
4830 -> 1151;
4830 -> 1150;
4830 -> 1115;
4830 -> 4824;
4831 -> 4825;
4831 -> 4830;
4831 -> 4824;
4832 -> 4826;
4832 -> 1115;
4832 -> 4824;
4833 -> 1155;
4834 -> 1155;
4835 -> 4822;
4835 -> 4834;
4836 -> 4835;
4836 -> 4834;
4837 -> 4836;
4837 -> 1155;
4838 -> 1372;
4839 -> 1372;
4840 -> 4839;
4840 -> 1372;
4841 -> 1372;
4842 -> 1372;
4843 -> 1372;
4844 -> 1372;
4845 -> 1372;
4846 -> 1372;
4847 -> 4841;
4847 -> 1372;
4848 -> 4842;
4848 -> 1372;
4849 -> 4843;
4849 -> 1372;
4850 -> 4844;
4850 -> 1372;
4851 -> 4846;
4851 -> 4840;
4851 -> 4847;
4851 -> 4848;
4851 -> 4849;
4851 -> 4850;
4851 -> 1372;
4852 -> 1372;
4853 -> 4851;
4853 -> 4852;
4853 -> 1372;
4854 -> 4845;
4854 -> 4851;
4854 -> 4853;
4855 -> 4853;
4856 -> 4854;
4856 -> 4855;
4857 -> 4855;
4858 -> 4856;
4858 -> 4854;
4858 -> 4857;
4859 -> 4858;
4859 -> 4854;
4859 -> 4857;
4860 -> 4859;
4860 -> 4855;
4861 -> 4855;
4862 -> 4856;
4862 -> 4854;
4862 -> 4861;
4863 -> 4862;
4863 -> 4855;
4864 -> 4855;
4865 -> 4863;
4865 -> 4864;
4866 -> 4856;
4866 -> 4854;
4866 -> 4864;
4867 -> 4855;
4868 -> 4855;
4869 -> 4856;
4869 -> 4868;
4870 -> 4869;
4870 -> 4854;
4870 -> 4865;
4870 -> 4868;
4871 -> 4868;
4872 -> 4869;
4872 -> 4870;
4872 -> 4871;
4873 -> 4872;
4873 -> 4868;
4874 -> 4868;
4875 -> 4874;
4875 -> 4868;
4876 -> 4868;
4877 -> 4868;
4878 -> 4870;
4878 -> 4868;
4879 -> 4870;
4879 -> 4868;
4880 -> 4868;
4881 -> 4879;
4881 -> 4880;
4881 -> 4868;
4882 -> 4881;
4883 -> 4879;
4883 -> 4868;
4884 -> 4883;
4885 -> 4868;
4886 -> 4870;
4886 -> 4868;
4887 -> 4886;
4887 -> 4870;
4887 -> 4868;
4888 -> 4870;
4888 -> 4868;
4889 -> 4868;
4890 -> 4888;
4890 -> 4889;
4891 -> 4889;
4892 -> 4889;
4893 -> 4890;
4893 -> 4892;
4893 -> 4889;
4894 -> 4893;
4895 -> 4894;
4895 -> 4890;
4895 -> 4887;
4895 -> 4893;
4896 -> 4891;
4896 -> 4889;
4897 -> 4896;
4897 -> 4868;
4898 -> 4868;
4899 -> 4897;
4899 -> 4898;
4900 -> 4869;
4900 -> 4898;
4901 -> 4898;
4902 -> 4900;
4902 -> 4887;
4902 -> 4901;
4902 -> 4898;
4903 -> 4902;
4904 -> 4903;
4904 -> 4868;
4905 -> 4868;
4906 -> 4887;
4906 -> 4868;
4907 -> 4887;
4907 -> 4868;
4908 -> 4907;
4908 -> 4880;
4908 -> 4868;
4909 -> 4908;
4910 -> 4907;
4910 -> 4868;
4911 -> 4910;
4912 -> 4887;
4912 -> 4868;
4913 -> 4904;
4913 -> 4868;
4914 -> 4869;
4914 -> 4868;
4915 -> 4912;
4915 -> 4887;
4915 -> 0;
4915 -> 4868;
4916 -> 4868;
4917 -> 4912;
4917 -> 4887;
4917 -> 4868;
4918 -> 4912;
4918 -> 4887;
4918 -> 4917;
4919 -> 4912;
4919 -> 4887;
4919 -> 4918;
4920 -> 4918;
4921 -> 4919;
4921 -> 4920;
4922 -> 4921;
4922 -> 0;
4922 -> 4920;
4923 -> 4887;
4923 -> 4918;
4924 -> 4912;
4924 -> 4887;
4924 -> 4918;
4925 -> 4918;
4926 -> 4923;
4926 -> 4925;
4927 -> 4924;
4927 -> 4925;
4928 -> 4923;
4928 -> 4925;
4929 -> 4927;
4929 -> 4925;
4930 -> 4926;
4930 -> 4925;
4931 -> 4928;
4931 -> 4925;
4932 -> 4925;
4933 -> 4929;
4933 -> 4932;
4934 -> 4930;
4934 -> 4932;
4935 -> 4931;
4935 -> 4932;
4936 -> 4933;
4936 -> 1388;
4936 -> 4932;
4937 -> 4932;
4938 -> 4934;
4938 -> 4937;
4938 -> 4932;
4939 -> 4938;
4940 -> 4935;
4940 -> 4939;
4940 -> 4938;
4941 -> 1392;
4941 -> 1391;
4941 -> 4933;
4941 -> 4940;
4942 -> 4868;
4943 -> 4913;
4943 -> 4942;
4943 -> 4868;
4944 -> 4941;
4944 -> 4868;
4945 -> 4944;
4945 -> 4855;
4946 -> 4860;
4946 -> 4945;
4946 -> 4855;
4947 -> 4945;
4947 -> 4855;
4948 -> 4841;
4948 -> 4853;
4949 -> 4842;
4949 -> 4853;
4950 -> 4843;
4950 -> 4853;
4951 -> 4844;
4951 -> 4853;
4952 -> 4947;
4952 -> 4853;
4953 -> 4947;
4953 -> 1372;
4954 -> 1372;
4954 -> 4953;
4954 -> 4952;
4955 -> 4954;
4955 -> 1155;
4956 -> 4955;
4956 -> 4824;
4957 -> 4956;
4957 -> 4827;
4957 -> 4824;
4958 -> 4826;
4958 -> 4832;
4958 -> 1151;
4958 -> 1150;
4958 -> 4824;
4959 -> 4826;
4959 -> 1151;
4959 -> 1150;
4959 -> 4832;
4959 -> 4824;
4960 -> 4956;
4960 -> 4959;
4960 -> 4824;
4961 -> 4954;
4961 -> 4834;
4962 -> 4961;
4962 -> 4954;
4962 -> 4834;
4963 -> 4962;
4963 -> 1155;
4964 -> 4954;
4965 -> 4954;
4966 -> 4954;
4966 -> 4965;
4967 -> 4966;
4967 -> 4954;
4967 -> 4965;
4968 -> 4967;
4968 -> 4954;
4969 -> 4954;
4970 -> 4969;
4970 -> 4954;
4971 -> 4969;
4971 -> 4954;
4972 -> 4971;
4972 -> 4954;
4973 -> 4954;
4974 -> 4954;
4975 -> 4954;
4976 -> 4954;
4977 -> 4975;
4977 -> 4976;
4977 -> 4954;
4978 -> 4977;
4979 -> 4975;
4979 -> 4954;
4980 -> 4979;
4981 -> 4954;
4982 -> 4969;
4983 -> 4969;
4984 -> 4969;
4984 -> 1055;
4985 -> 0;
4985 -> 4969;
4986 -> 4969;
4987 -> 4986;
4987 -> 4969;
4988 -> 0;
4988 -> 4987;
4989 -> 4969;
4989 -> 4988;
4989 -> 4985;
4990 -> 4989;
4990 -> 0;
4990 -> 4969;
4991 -> 0;
4991 -> 4969;
4991 -> 4990;
4992 -> 0;
4992 -> 4969;
4992 -> 4990;
4993 -> 4969;
4993 -> 4989;
4993 -> 4991;
4993 -> 0;
4994 -> 4969;
4994 -> 4989;
4994 -> 4991;
4994 -> 4992;
4994 -> 4954;
4995 -> 4969;
4995 -> 4954;
4996 -> 4954;
4997 -> 4995;
4997 -> 4996;
4998 -> 4996;
4999 -> 4996;
5000 -> 4997;
5000 -> 4999;
5000 -> 4996;
5001 -> 5000;
5002 -> 5001;
5002 -> 4997;
5002 -> 4994;
5002 -> 5000;
5003 -> 4998;
5003 -> 4996;
5004 -> 5003;
5004 -> 4954;
5005 -> 4954;
5006 -> 5004;
5006 -> 5005;
5007 -> 4954;
5007 -> 5005;
5008 -> 5005;
5009 -> 5007;
5009 -> 4994;
5009 -> 5008;
5009 -> 5005;
5010 -> 5009;
5011 -> 5010;
5011 -> 4954;
5012 -> 4954;
5013 -> 4954;
5014 -> 5013;
5014 -> 4954;
5015 -> 4994;
5015 -> 4954;
5016 -> 4994;
5016 -> 4954;
5017 -> 5016;
5017 -> 4976;
5017 -> 4954;
5018 -> 4954;
5018 -> 4994;
5018 -> 5017;
5019 -> 5017;
5020 -> 5018;
5020 -> 5019;
5021 -> 5018;
5021 -> 5019;
5022 -> 5021;
5022 -> 5018;
5022 -> 5019;
5023 -> 4994;
5023 -> 5017;
5024 -> 5017;
5025 -> 5022;
5025 -> 5024;
5026 -> 5023;
5026 -> 5024;
5027 -> 4954;
5027 -> 5024;
5028 -> 5024;
5029 -> 5027;
5029 -> 5028;
5030 -> 5028;
5031 -> 5029;
5031 -> 5022;
5031 -> 5030;
5031 -> 5028;
5032 -> 5031;
5032 -> 5024;
5033 -> 5024;
5034 -> 5026;
5034 -> 5033;
5034 -> 5024;
5035 -> 5025;
5035 -> 5024;
5036 -> 5026;
5036 -> 5035;
5036 -> 5022;
5036 -> 5024;
5037 -> 5036;
5037 -> 4954;
5038 -> 5036;
5039 -> 5036;
5039 -> 4954;
5040 -> 5039;
5041 -> 5011;
5041 -> 4954;
5042 -> 4954;
5043 -> 4994;
5043 -> 0;
5043 -> 4954;
5044 -> 4954;
5045 -> 4994;
5045 -> 5044;
5045 -> 4954;
5046 -> 4954;
5047 -> 4994;
5048 -> 5036;
5048 -> 4994;
5049 -> 4994;
5050 -> 5047;
5050 -> 5049;
5051 -> 5048;
5051 -> 5049;
5052 -> 5047;
5052 -> 5049;
5053 -> 5047;
5053 -> 5049;
5054 -> 5048;
5054 -> 5049;
5055 -> 5050;
5055 -> 5049;
5056 -> 5051;
5056 -> 5049;
5057 -> 5052;
5057 -> 5049;
5058 -> 5053;
5058 -> 5049;
5059 -> 5054;
5059 -> 5049;
5060 -> 5049;
5061 -> 5055;
5061 -> 5060;
5062 -> 5056;
5062 -> 5060;
5063 -> 5057;
5063 -> 5060;
5064 -> 5058;
5064 -> 5060;
5065 -> 5059;
5065 -> 5060;
5066 -> 5061;
5066 -> 0;
5066 -> 5060;
5067 -> 5064;
5067 -> 5063;
5067 -> 5060;
5068 -> 5066;
5068 -> 5067;
5068 -> 5060;
5069 -> 5062;
5069 -> 5068;
5070 -> 5063;
5070 -> 5068;
5071 -> 5065;
5071 -> 5068;
5072 -> 5068;
5073 -> 5069;
5073 -> 5072;
5074 -> 5070;
5074 -> 5072;
5075 -> 5071;
5075 -> 5072;
5076 -> 5072;
5077 -> 5073;
5077 -> 5076;
5077 -> 5072;
5078 -> 5077;
5079 -> 5075;
5079 -> 5078;
5079 -> 5077;
5081 -> 5074;
5081 -> 5079;
5082 -> 5075;
5082 -> 5079;
5083 -> 5079;
5084 -> 5079;
5085 -> 5081;
5085 -> 5084;
5086 -> 5082;
5086 -> 5084;
5087 -> 5083;
5087 -> 5084;
5089 -> 5085;
5089 -> 5084;
5090 -> 5084;
5091 -> 5089;
5091 -> 5090;
5092 -> 5087;
5092 -> 5090;
5093 -> 0;
5093 -> 5090;
5094 -> 5091;
5094 -> 5090;
5095 -> 5090;
5096 -> 5093;
5096 -> 5095;
5097 -> 5094;
5097 -> 5095;
5098 -> 5092;
5098 -> 5095;
5099 -> 5096;
5099 -> 5095;
5100 -> 5097;
5100 -> 5095;
5101 -> 5095;
5102 -> 5099;
5102 -> 5101;
5103 -> 5100;
5103 -> 5101;
5104 -> 5098;
5104 -> 5101;
5105 -> 5102;
5105 -> 5101;
5106 -> 5103;
5106 -> 5101;
5107 -> 5101;
5108 -> 5107;
5108 -> 5105;
5108 -> 5106;
5108 -> 5101;
5109 -> 5107;
5109 -> 5101;
5110 -> 5109;
5110 -> 5108;
5110 -> 5101;
5111 -> 5098;
5111 -> 5110;
5111 -> 0;
5111 -> 5095;
5112 -> 5111;
5112 -> 5098;
5112 -> 5095;
5113 -> 5092;
5113 -> 5090;
5114 -> 5091;
5114 -> 5092;
5114 -> 5090;
5115 -> 5087;
5115 -> 5084;
5116 -> 5084;
5117 -> 5086;
5117 -> 5116;
5117 -> 5084;
5118 -> 5086;
5118 -> 5117;
5119 -> 5087;
5119 -> 5118;
5119 -> 5110;
5119 -> 5112;
5119 -> 5113;
5119 -> 5114;
5119 -> 5115;
5119 -> 5036;
5119 -> 5117;
5120 -> 5086;
5120 -> 5087;
5120 -> 5117;
5121 -> 4954;
5122 -> 5041;
5122 -> 5121;
5122 -> 4954;
5123 -> 4968;
5123 -> 5083;
5123 -> 5119;
5123 -> 4954;
5124 -> 4954;
5124 -> 5083;
5124 -> 5119;
5124 -> 5120;
5125 -> 5124;
5125 -> 1155;
5126 -> 5125;
5126 -> 4824;
5127 -> 5126;
5127 -> 4827;
5127 -> 4824;
5128 -> 5126;
5128 -> 4959;
5128 -> 4824;
5129 -> 5124;
5129 -> 4834;
5130 -> 5129;
5130 -> 5124;
5130 -> 4834;
5131 -> 5130;
5131 -> 1155;
5132 -> 5124;
5133 -> 5124;
5134 -> 5133;
5134 -> 5124;
5135 -> 5124;
5136 -> 5124;
5137 -> 5136;
5137 -> 5124;
5138 -> 5124;
5139 -> 5124;
5140 -> 5124;
5141 -> 5124;
5142 -> 5141;
5143 -> 5124;
5144 -> 5124;
5145 -> 5124;
5145 -> 1055;
5146 -> 5124;
5146 -> 0;
5147 -> 5124;
5148 -> 5124;
5149 -> 5147;
5149 -> 5148;
5150 -> 5148;
5151 -> 5148;
5152 -> 5149;
5152 -> 5151;
5152 -> 5148;
5153 -> 5152;
5154 -> 5150;
5154 -> 5148;
5155 -> 5154;
5155 -> 5124;
5156 -> 5124;
5157 -> 5155;
5157 -> 5156;
5158 -> 5124;
5158 -> 5156;
5159 -> 5156;
5160 -> 5158;
5160 -> 5124;
5160 -> 5159;
5160 -> 5156;
5161 -> 5160;
5162 -> 5161;
5162 -> 5124;
5163 -> 5124;
5164 -> 5124;
5165 -> 5163;
5165 -> 5164;
5166 -> 5164;
5167 -> 5165;
5167 -> 5133;
5167 -> 5166;
5167 -> 5164;
5168 -> 5167;
5168 -> 5124;
5169 -> 5124;
5170 -> 5133;
5170 -> 5169;
5170 -> 5124;
5171 -> 5133;
5171 -> 5124;
5172 -> 5133;
5173 -> 5133;
5173 -> 5124;
5174 -> 5136;
5174 -> 5173;
5175 -> 5173;
5176 -> 5162;
5176 -> 5124;
5177 -> 5124;
5178 -> 5124;
5178 -> 0;
5179 -> 5124;
5180 -> 5124;
5181 -> 5124;
5182 -> 5176;
5182 -> 5181;
5182 -> 5124;
5183 -> 5134;
5183 -> 5133;
5183 -> 5124;
5184 -> 5133;
5184 -> 1155;
5185 -> 5184;
5185 -> 4824;
5186 -> 5185;
5186 -> 4827;
5186 -> 4824;
5187 -> 5185;
5187 -> 4959;
5187 -> 4824;
5188 -> 5133;
5188 -> 4834;
5189 -> 5188;
5189 -> 5133;
5189 -> 4834;
5190 -> 5189;
5190 -> 1155;
5191 -> 5133;
5192 -> 5133;
5193 -> 5133;
5194 -> 5133;
5195 -> 5194;
5195 -> 5133;
5196 -> 5133;
5197 -> 5133;
5198 -> 5133;
5199 -> 5194;
5199 -> 5198;
5200 -> 5199;
5201 -> 5133;
5201 -> 5200;
5202 -> 5200;
5203 -> 5201;
5203 -> 5133;
5203 -> 5202;
5204 -> 5203;
5204 -> 5200;
5205 -> 5200;
5206 -> 5201;
5206 -> 5133;
5206 -> 5205;
5207 -> 5206;
5207 -> 5200;
5208 -> 5200;
5209 -> 5204;
5209 -> 5208;
5209 -> 5200;
5210 -> 5207;
5210 -> 5209;
5210 -> 5133;
5210 -> 5200;
5211 -> 5200;
5212 -> 5210;
5212 -> 5211;
5213 -> 5211;
5214 -> 5212;
5214 -> 5213;
5214 -> 5211;
5215 -> 5200;
5216 -> 5215;
5216 -> 5199;
5217 -> 5198;
5218 -> 5133;
5219 -> 5210;
5219 -> 5133;
5220 -> 5210;
5220 -> 5133;
5221 -> 5133;
5222 -> 5220;
5222 -> 5221;
5223 -> 5221;
5224 -> 5221;
5225 -> 5222;
5225 -> 5224;
5225 -> 5221;
5226 -> 5225;
5227 -> 5223;
5227 -> 5221;
5228 -> 5227;
5228 -> 5133;
5229 -> 5133;
5230 -> 5228;
5230 -> 5229;
5231 -> 5133;
5231 -> 5229;
5232 -> 5229;
5233 -> 5231;
5233 -> 5210;
5233 -> 5232;
5233 -> 5229;
5234 -> 5233;
5235 -> 5234;
5235 -> 5133;
5236 -> 5210;
5237 -> 5133;
5237 -> 5210;
5238 -> 5210;
5239 -> 5237;
5239 -> 5238;
5240 -> 5238;
5241 -> 5239;
5241 -> 5210;
5241 -> 5240;
5241 -> 5238;
5242 -> 5241;
5242 -> 5210;
5243 -> 5210;
5244 -> 5210;
5245 -> 5210;
5246 -> 5235;
5246 -> 5133;
5247 -> 5133;
5248 -> 5210;
5248 -> 0;
5248 -> 5133;
5249 -> 5133;
5250 -> 5210;
5251 -> 5210;
5252 -> 5250;
5252 -> 5251;
5253 -> 5252;
5253 -> 0;
5253 -> 5251;
5254 -> 5210;
5254 -> 1388;
5255 -> 5210;
5255 -> 408;
5256 -> 1400;
5256 -> 1399;
5256 -> 5210;
5256 -> 5255;
5257 -> 5133;
5258 -> 5246;
5258 -> 5257;
5258 -> 5133;
5259 -> 5192;
5259 -> 5256;
5259 -> 5133;
5260 -> 5256;
5260 -> 1155;
5261 -> 5260;
5261 -> 4824;
5262 -> 5261;
5262 -> 4827;
5262 -> 4824;
5263 -> 5261;
5263 -> 4959;
5263 -> 4824;
5264 -> 5256;
5264 -> 4834;
5265 -> 5264;
5265 -> 5256;
5265 -> 4834;
5266 -> 5265;
5266 -> 1155;
5267 -> 5256;
5268 -> 5256;
5269 -> 5256;
5270 -> 5256;
5271 -> 5256;
5272 -> 5256;
5273 -> 5256;
5274 -> 5256;
5275 -> 5256;
5276 -> 5256;
5277 -> 5256;
5278 -> 5256;
5279 -> 5277;
5279 -> 5256;
5279 -> 5278;
5280 -> 5279;
5280 -> 5256;
5281 -> 5256;
5282 -> 5256;
5283 -> 5256;
5284 -> 5256;
5285 -> 5256;
5286 -> 5256;
5287 -> 5286;
5287 -> 5276;
5287 -> 5256;
5288 -> 0;
5288 -> 5276;
5288 -> 5256;
5289 -> 5277;
5289 -> 5256;
5290 -> 5256;
5291 -> 5256;
5292 -> 5256;
5293 -> 5256;
5294 -> 5256;
5295 -> 5256;
5296 -> 5277;
5296 -> 5289;
5296 -> 5295;
5297 -> 5296;
5297 -> 5289;
5297 -> 5295;
5298 -> 5296;
5298 -> 5256;
5299 -> 5256;
5300 -> 5298;
5300 -> 5299;
5300 -> 5256;
5301 -> 5300;
5302 -> 5300;
5303 -> 5301;
5303 -> 5302;
5304 -> 5277;
5304 -> 5289;
5304 -> 5302;
5305 -> 5302;
5306 -> 5304;
5306 -> 5305;
5307 -> 5306;
5307 -> 5302;
5308 -> 5303;
5308 -> 5302;
5309 -> 5302;
5310 -> 5308;
5310 -> 5309;
5311 -> 5304;
5311 -> 5309;
5312 -> 5311;
5312 -> 5289;
5312 -> 5310;
5312 -> 5309;
5313 -> 5302;
5314 -> 5302;
5315 -> 5304;
5315 -> 5289;
5315 -> 5312;
5315 -> 5302;
5316 -> 5304;
5316 -> 5289;
5316 -> 5312;
5316 -> 5315;
5317 -> 5307;
5317 -> 5302;
5318 -> 5302;
5319 -> 5317;
5319 -> 5318;
5320 -> 5304;
5320 -> 5318;
5321 -> 5302;
5322 -> 5316;
5322 -> 5302;
5323 -> 5300;
5324 -> 5322;
5324 -> 5323;
5324 -> 5300;
5325 -> 5324;
5326 -> 5282;
5326 -> 5283;
5326 -> 5256;
5327 -> 5292;
5327 -> 5326;
5328 -> 5293;
5328 -> 5326;
5329 -> 5294;
5329 -> 5326;
5330 -> 5326;
5331 -> 5326;
5332 -> 5327;
5332 -> 5331;
5333 -> 5328;
5333 -> 5331;
5334 -> 5329;
5334 -> 5331;
5335 -> 5330;
5335 -> 5331;
5336 -> 5330;
5336 -> 5331;
5337 -> 5277;
5337 -> 5331;
5338 -> 5331;
5339 -> 5337;
5339 -> 5289;
5339 -> 5338;
5340 -> 5339;
5340 -> 5289;
5340 -> 5312;
5340 -> 5319;
5340 -> 5338;
5341 -> 5339;
5341 -> 5289;
5341 -> 5312;
5341 -> 5319;
5341 -> 5338;
5342 -> 5341;
5342 -> 5331;
5343 -> 5331;
5344 -> 5331;
5345 -> 5331;
5346 -> 5345;
5347 -> 5337;
5347 -> 5289;
5347 -> 5346;
5348 -> 5347;
5348 -> 5289;
5348 -> 5312;
5348 -> 5319;
5348 -> 5346;
5349 -> 5347;
5349 -> 5289;
5349 -> 5312;
5349 -> 5319;
5349 -> 5346;
5350 -> 5349;
5350 -> 5345;
5351 -> 5345;
5352 -> 5350;
5352 -> 5351;
5352 -> 5345;
5353 -> 5335;
5353 -> 5352;
5354 -> 5336;
5354 -> 5353;
5355 -> 5350;
5355 -> 5354;
5356 -> 5354;
5357 -> 5355;
5357 -> 5356;
5358 -> 5356;
5359 -> 5357;
5359 -> 5358;
5359 -> 5356;
5360 -> 5350;
5360 -> 5359;
5361 -> 5359;
5362 -> 5345;
5363 -> 5337;
5363 -> 5360;
5363 -> 5362;
5364 -> 5345;
5365 -> 5360;
5365 -> 5363;
5365 -> 5346;
5366 -> 5361;
5366 -> 5331;
5367 -> 0;
5367 -> 5326;
5368 -> 5326;
5369 -> 5367;
5369 -> 5368;
5370 -> 5277;
5370 -> 5368;
5371 -> 5370;
5371 -> 5360;
5371 -> 5368;
5372 -> 5371;
5372 -> 5369;
5372 -> 5368;
5373 -> 5326;
5374 -> 5277;
5374 -> 5360;
5374 -> 5373;
5375 -> 5374;
5375 -> 5360;
5375 -> 5363;
5375 -> 5373;
5376 -> 5374;
5376 -> 5360;
5376 -> 5363;
5376 -> 5373;
5377 -> 5376;
5377 -> 5326;
5378 -> 5326;
5379 -> 5326;
5380 -> 5277;
5380 -> 5360;
5380 -> 5379;
5381 -> 5380;
5381 -> 5360;
5381 -> 5363;
5381 -> 5379;
5382 -> 5380;
5382 -> 5360;
5382 -> 5363;
5382 -> 5379;
5383 -> 5382;
5383 -> 5326;
5384 -> 5326;
5385 -> 5285;
5385 -> 5284;
5385 -> 5326;
5386 -> 5385;
5387 -> 5277;
5387 -> 5360;
5387 -> 5386;
5388 -> 5387;
5388 -> 5360;
5388 -> 5363;
5388 -> 5386;
5389 -> 5387;
5389 -> 5360;
5389 -> 5363;
5389 -> 5386;
5390 -> 5389;
5390 -> 5385;
5391 -> 5385;
5392 -> 5390;
5393 -> 5392;
5394 -> 5393;
5395 -> 5394;
5396 -> 5332;
5396 -> 5256;
5397 -> 5334;
5397 -> 5396;
5398 -> 5333;
5398 -> 5397;
5399 -> 0;
5399 -> 5276;
5399 -> 5256;
5400 -> 5256;
5401 -> 5256;
5402 -> 5400;
5402 -> 5401;
5403 -> 5277;
5403 -> 5360;
5403 -> 5401;
5404 -> 5401;
5405 -> 5403;
5405 -> 5404;
5406 -> 5405;
5406 -> 5401;
5407 -> 5401;
5408 -> 5403;
5408 -> 5407;
5409 -> 5408;
5409 -> 5360;
5409 -> 5363;
5409 -> 5407;
5410 -> 5409;
5410 -> 5401;
5411 -> 5402;
5411 -> 5401;
5412 -> 5401;
5413 -> 5406;
5413 -> 5412;
5414 -> 5410;
5414 -> 5412;
5415 -> 5411;
5415 -> 5412;
5416 -> 5403;
5416 -> 5412;
5417 -> 5413;
5417 -> 5416;
5417 -> 5360;
5417 -> 5412;
5418 -> 5414;
5418 -> 5412;
5419 -> 5416;
5419 -> 5360;
5419 -> 5363;
5419 -> 5417;
5419 -> 5418;
5420 -> 5418;
5421 -> 5416;
5421 -> 5360;
5421 -> 5363;
5421 -> 5417;
5421 -> 5418;
5422 -> 5418;
5423 -> 5415;
5423 -> 5412;
5424 -> 5416;
5424 -> 5360;
5424 -> 5423;
5425 -> 5417;
5425 -> 5423;
5426 -> 5414;
5426 -> 5423;
5427 -> 5423;
5428 -> 5424;
5428 -> 5427;
5429 -> 5425;
5429 -> 5427;
5430 -> 5426;
5430 -> 5427;
5431 -> 5416;
5431 -> 5427;
5432 -> 5431;
5432 -> 5360;
5432 -> 5428;
5432 -> 5429;
5432 -> 5430;
5432 -> 5363;
5432 -> 5427;
5433 -> 5432;
5433 -> 5276;
5433 -> 5256;
5434 -> 5256;
5435 -> 5276;
5435 -> 5256;
5435 -> 5287;
5435 -> 5433;
5435 -> 5434;
5436 -> 5277;
5436 -> 5432;
5436 -> 5256;
5437 -> 5256;
5438 -> 5436;
5438 -> 5437;
5439 -> 5277;
5439 -> 5432;
5439 -> 5437;
5440 -> 5438;
5440 -> 5437;
5441 -> 5439;
5441 -> 5432;
5441 -> 5440;
5441 -> 5437;
5442 -> 5256;
5443 -> 5276;
5443 -> 5256;
5443 -> 5288;
5444 -> 5441;
5444 -> 5443;
5445 -> 5441;
5445 -> 5444;
5446 -> 5282;
5446 -> 5444;
5447 -> 5283;
5447 -> 5444;
5448 -> 5444;
5449 -> 5445;
5449 -> 5448;
5450 -> 5446;
5450 -> 5448;
5451 -> 5447;
5451 -> 5448;
5452 -> 5277;
5452 -> 5448;
5453 -> 5448;
5454 -> 5451;
5454 -> 5448;
5455 -> 5449;
5455 -> 5454;
5456 -> 5450;
5456 -> 5454;
5457 -> 0;
5457 -> 5456;
5458 -> 0;
5458 -> 5454;
5459 -> 5453;
5459 -> 5454;
5460 -> 5455;
5460 -> 5457;
5460 -> 5458;
5460 -> 5459;
5460 -> 0;
5460 -> 5454;
5461 -> 5460;
5461 -> 5448;
5462 -> 5290;
5462 -> 5291;
5462 -> 5443;
5463 -> 5461;
5463 -> 0;
5463 -> 5462;
5464 -> 0;
5464 -> 5276;
5464 -> 5463;
5465 -> 5461;
5465 -> 5276;
5465 -> 5463;
5466 -> 5256;
5467 -> 5276;
5467 -> 5466;
5467 -> 5256;
5467 -> 5287;
5467 -> 5433;
5467 -> 5288;
5467 -> 5464;
5467 -> 5399;
5467 -> 5465;
5467 -> 5441;
5468 -> 5256;
5469 -> 5256;
5470 -> 5468;
5470 -> 5469;
5471 -> 5469;
5472 -> 5469;
5473 -> 5470;
5473 -> 5472;
5473 -> 5469;
5474 -> 5473;
5475 -> 5474;
5475 -> 5470;
5475 -> 5467;
5475 -> 5473;
5476 -> 5471;
5476 -> 5469;
5477 -> 5476;
5477 -> 5256;
5478 -> 5256;
5479 -> 5477;
5479 -> 5478;
5480 -> 5256;
5480 -> 5478;
5481 -> 5478;
5482 -> 5480;
5482 -> 5467;
5482 -> 5481;
5482 -> 5478;
5483 -> 5482;
5484 -> 5483;
5484 -> 5256;
5485 -> 5467;
5485 -> 5256;
5486 -> 5467;
5487 -> 5467;
5488 -> 5484;
5488 -> 5256;
5489 -> 5256;
5490 -> 5467;
5490 -> 0;
5490 -> 5256;
5491 -> 5256;
5492 -> 5467;
5493 -> 5467;
5493 -> 5492;
5494 -> 5492;
5495 -> 5493;
5495 -> 5494;
5496 -> 5493;
5496 -> 5494;
5497 -> 5493;
5497 -> 5494;
5498 -> 5493;
5498 -> 5494;
5499 -> 0;
5499 -> 5494;
5500 -> 5495;
5500 -> 5494;
5501 -> 5496;
5501 -> 5494;
5502 -> 5497;
5502 -> 5494;
5503 -> 5498;
5503 -> 5494;
5504 -> 5494;
5505 -> 5499;
5505 -> 5504;
5506 -> 5500;
5506 -> 5504;
5507 -> 5501;
5507 -> 5504;
5508 -> 5502;
5508 -> 5504;
5509 -> 5503;
5509 -> 5504;
5511 -> 5505;
5511 -> 5504;
5512 -> 5507;
5512 -> 5504;
5513 -> 5508;
5513 -> 5504;
5514 -> 5506;
5514 -> 5504;
5515 -> 5509;
5515 -> 5504;
5516 -> 5504;
5517 -> 5504;
5518 -> 5511;
5518 -> 5517;
5519 -> 5512;
5519 -> 5517;
5520 -> 5513;
5520 -> 5517;
5521 -> 5514;
5521 -> 5517;
5522 -> 5515;
5522 -> 5517;
5523 -> 5516;
5523 -> 5517;
5525 -> 5518;
5525 -> 5517;
5526 -> 5519;
5526 -> 5517;
5527 -> 5520;
5527 -> 5517;
5528 -> 5517;
5529 -> 5525;
5529 -> 5528;
5530 -> 5526;
5530 -> 5528;
5531 -> 5527;
5531 -> 5528;
5532 -> 5523;
5532 -> 5528;
5533 -> 5529;
5533 -> 5528;
5534 -> 5530;
5534 -> 5528;
5535 -> 5528;
5536 -> 5533;
5536 -> 5535;
5537 -> 5534;
5537 -> 5535;
5538 -> 5535;
5538 -> 5536;
5538 -> 5537;
5539 -> 5532;
5539 -> 5528;
5540 -> 5532;
5540 -> 5528;
5541 -> 5530;
5541 -> 5532;
5541 -> 5528;
5542 -> 5531;
5542 -> 5532;
5542 -> 5528;
5543 -> 5523;
5543 -> 5517;
5544 -> 5523;
5544 -> 5517;
5545 -> 5517;
5546 -> 5521;
5546 -> 5545;
5546 -> 5517;
5547 -> 5517;
5548 -> 5522;
5548 -> 5547;
5548 -> 5517;
5549 -> 5516;
5549 -> 5494;
5550 -> 5549;
5550 -> 5492;
5551 -> 5256;
5552 -> 5488;
5552 -> 5551;
5552 -> 5256;
5553 -> 5268;
5553 -> 5550;
5553 -> 5538;
5553 -> 5256;
5554 -> 5256;
5554 -> 5550;
5554 -> 5467;
5554 -> 5538;
5554 -> 5539;
5554 -> 5541;
5554 -> 5540;
5554 -> 5542;
5554 -> 5543;
5554 -> 5544;
5555 -> 5554;
5555 -> 1155;
5556 -> 5555;
5556 -> 4824;
5557 -> 5556;
5557 -> 4827;
5557 -> 4824;
5558 -> 5556;
5558 -> 4959;
5558 -> 4824;
5559 -> 5554;
5559 -> 4834;
5560 -> 5559;
5560 -> 5554;
5560 -> 4834;
5561 -> 5560;
5561 -> 1155;
5562 -> 5554;
5563 -> 5554;
5564 -> 5554;
5565 -> 5554;
5566 -> 5554;
5567 -> 5554;
5568 -> 5554;
5569 -> 5554;
5570 -> 5554;
5571 -> 5554;
5572 -> 5554;
5573 -> 5571;
5573 -> 5572;
5574 -> 5572;
5575 -> 5572;
5576 -> 5573;
5576 -> 5575;
5576 -> 5572;
5577 -> 5576;
5578 -> 5574;
5578 -> 5572;
5579 -> 5578;
5579 -> 5554;
5580 -> 5554;
5581 -> 5579;
5581 -> 5580;
5582 -> 5554;
5582 -> 5580;
5583 -> 5580;
5584 -> 5582;
5584 -> 5554;
5584 -> 5583;
5584 -> 5580;
5585 -> 5584;
5586 -> 5585;
5586 -> 5554;
5587 -> 5586;
5587 -> 5554;
5588 -> 5554;
5589 -> 5554;
5589 -> 0;
5590 -> 5554;
5591 -> 5554;
5592 -> 5554;
5593 -> 5591;
5593 -> 5592;
5594 -> 5593;
5594 -> 0;
5594 -> 5592;
5595 -> 5554;
5595 -> 1388;
5596 -> 5554;
5597 -> 5587;
5597 -> 5596;
5597 -> 5554;
5598 -> 5563;
5598 -> 5554;
5599 -> 5554;
5600 -> 5554;
5601 -> 5599;
5601 -> 5600;
5602 -> 5600;
5603 -> 5601;
5603 -> 5554;
5603 -> 5602;
5603 -> 5600;
5604 -> 5603;
5604 -> 5554;
5605 -> 5554;
5606 -> 5554;
5607 -> 5606;
5607 -> 5554;
5608 -> 5607;
5609 -> 5608;
5609 -> 5554;
5610 -> 993;
5610 -> 5609;
5611 -> 5610;
5612 -> 5610;
5612 -> 5611;
5613 -> 5611;
5614 -> 5612;
5614 -> 5613;
5615 -> 5613;
5616 -> 5614;
5616 -> 5615;
5616 -> 5613;
5617 -> 5614;
5617 -> 5613;
5618 -> 5610;
5618 -> 5616;
5619 -> 5616;
5620 -> 5618;
5620 -> 5619;
5621 -> 5619;
5622 -> 5620;
5622 -> 5621;
5622 -> 5619;
5623 -> 5610;
5624 -> 5559;
5624 -> 4834;
5625 -> 5624;
5625 -> 1155;
5626 -> 5606;
5626 -> 5554;
5627 -> 5606;
5627 -> 5554;
5628 -> 5606;
5629 -> 5606;
5630 -> 5629;
5631 -> 5630;
5631 -> 5606;
5632 -> 993;
5632 -> 5631;
5633 -> 5606;
5634 -> 5633;
5634 -> 5632;
5634 -> 5606;
5635 -> 5606;
5636 -> 5633;
5636 -> 5635;
5637 -> 5636;
5637 -> 5632;
5637 -> 5635;
5638 -> 5637;
5638 -> 5606;
5639 -> 0;
5641 -> 5639;
5641 -> 5640;
5642 -> 5640;
5643 -> 5641;
5643 -> 5642;
5643 -> 5640;
5644 -> 5640;
5647 -> 5645;
5647 -> 5646;
5648 -> 5646;
5649 -> 5647;
5649 -> 5648;
5649 -> 5646;
5650 -> 5646;
5651 -> 5606;
5652 -> 5651;
5652 -> 5638;
5652 -> 5606;
5653 -> 5606;
5654 -> 5652;
5654 -> 5653;
5655 -> 5654;
5655 -> 5653;
5656 -> 5653;
5657 -> 5655;
5657 -> 5656;
5657 -> 5653;
5658 -> 5655;
5658 -> 5653;
5659 -> 5606;
5660 -> 5658;
5660 -> 5659;
5660 -> 5606;
5661 -> 5606;
5662 -> 5661;
5662 -> 5660;
5662 -> 5606;
5663 -> 5606;
5664 -> 5662;
5664 -> 5663;
5665 -> 5663;
5666 -> 5664;
5666 -> 5665;
5666 -> 5663;
5667 -> 5606;
5668 -> 5664;
5668 -> 5667;
5668 -> 5606;
5669 -> 5606;
5669 -> 5554;
5670 -> 5669;
5670 -> 5572;
5671 -> 5670;
5671 -> 5575;
5671 -> 5572;
5672 -> 5671;
5673 -> 5672;
5673 -> 5670;
5673 -> 5668;
5673 -> 5671;
5674 -> 5582;
5674 -> 5668;
5674 -> 5583;
5674 -> 5580;
5675 -> 5674;
5676 -> 5675;
5676 -> 5554;
5677 -> 5668;
5678 -> 5668;
5678 -> 5677;
5679 -> 5677;
5680 -> 5678;
5680 -> 5679;
5681 -> 5679;
5682 -> 5680;
5682 -> 5681;
5682 -> 5679;
5683 -> 5680;
5683 -> 5679;
5684 -> 5668;
5684 -> 5682;
5685 -> 5682;
5686 -> 5684;
5686 -> 5685;
5687 -> 5685;
5688 -> 5686;
5688 -> 5687;
5688 -> 5685;
5689 -> 5668;
5690 -> 5676;
5690 -> 5554;
5691 -> 5668;
5691 -> 0;
5691 -> 5554;
5692 -> 5668;
5693 -> 5668;
5694 -> 5692;
5694 -> 5693;
5695 -> 5692;
5695 -> 5693;
5696 -> 5692;
5696 -> 5693;
5697 -> 5695;
5697 -> 1388;
5697 -> 5693;
5698 -> 5690;
5698 -> 5596;
5698 -> 5554;
5699 -> 5695;
5699 -> 1155;
5700 -> 5699;
5700 -> 4824;
5701 -> 5700;
5701 -> 4827;
5701 -> 4824;
5702 -> 5700;
5702 -> 4959;
5702 -> 4824;
5703 -> 5695;
5703 -> 4834;
5704 -> 5703;
5704 -> 4834;
5705 -> 5704;
5705 -> 1155;
5706 -> 1142;
5707 -> 1079;
5708 -> 5707;
5708 -> 1085;
5708 -> 1079;
5709 -> 1085;
5709 -> 1079;
5710 -> 1085;
5710 -> 1079;
5711 -> 1085;
5711 -> 1079;
5712 -> 1085;
5712 -> 1079;
5713 -> 1085;
5713 -> 1079;
5714 -> 1085;
5714 -> 1079;
5715 -> 1079;
5716 -> 5715;
5716 -> 1085;
5716 -> 1079;
5717 -> 1085;
5717 -> 5716;
5717 -> 1079;
5718 -> 1079;
5719 -> 5718;
5719 -> 1085;
5719 -> 1079;
5720 -> 1078;
5720 -> 890;
5721 -> 890;
5722 -> 5720;
5722 -> 5721;
5723 -> 5722;
5723 -> 5721;
5724 -> 0;
5724 -> 5721;
5725 -> 5721;
5726 -> 5723;
5726 -> 5725;
5727 -> 5724;
5727 -> 5725;
5728 -> 5722;
5728 -> 5725;
5729 -> 5725;
5730 -> 5728;
5730 -> 5711;
5730 -> 5729;
5730 -> 5725;
5731 -> 5726;
5731 -> 5723;
5731 -> 1119;
5731 -> 1127;
5731 -> 1121;
5731 -> 1120;
5731 -> 1110;
5731 -> 1151;
5731 -> 1112;
5731 -> 1113;
5731 -> 1114;
5731 -> 4832;
5731 -> 1116;
5731 -> 1117;
5731 -> 1118;
5731 -> 1122;
5731 -> 1124;
5731 -> 1134;
5731 -> 5708;
5731 -> 5716;
5731 -> 5719;
5731 -> 5711;
5731 -> 5712;
5731 -> 5713;
5731 -> 5714;
5731 -> 5668;
5731 -> 1078;
5731 -> 1123;
5731 -> 1133;
5731 -> 1150;
5731 -> 5707;
5731 -> 5717;
5731 -> 5725;
5732 -> 5725;
5733 -> 5731;
5733 -> 5732;
5734 -> 5732;
5735 -> 5733;
5735 -> 5734;
5736 -> 5735;
5736 -> 5731;
5736 -> 5734;
5737 -> 5735;
5737 -> 5736;
5737 -> 5734;
5738 -> 5735;
5738 -> 5736;
5738 -> 0;
5738 -> 5734;
5739 -> 5738;
5739 -> 5735;
5739 -> 5734;
5740 -> 5734;
5741 -> 5735;
5741 -> 5740;
5742 -> 5740;
5743 -> 5741;
5743 -> 5742;
5744 -> 5742;
5745 -> 5743;
5745 -> 5744;
5746 -> 5745;
5746 -> 5736;
5746 -> 5744;
5747 -> 5744;
5748 -> 5745;
5748 -> 5736;
5748 -> 5747;
5748 -> 5744;
5749 -> 5745;
5749 -> 5736;
5749 -> 5739;
5749 -> 5748;
5750 -> 5749;
5750 -> 5742;
5751 -> 5750;
5751 -> 5743;
5751 -> 5742;
5752 -> 5751;
5752 -> 5740;
5753 -> 5740;
5754 -> 5752;
5754 -> 5753;
5755 -> 5754;
5755 -> 5736;
5755 -> 5753;
5756 -> 5755;
5756 -> 5734;
5757 -> 5737;
5757 -> 5735;
5757 -> 5734;
5758 -> 5736;
5758 -> 5739;
5758 -> 5757;
5758 -> 5751;
5758 -> 5734;
5759 -> 5736;
5759 -> 5734;
5760 -> 5735;
5760 -> 5758;
5760 -> 5759;
5760 -> 5734;
5761 -> 5732;
5762 -> 5761;
5762 -> 5732;
5763 -> 5732;
5764 -> 5758;
5764 -> 5763;
5765 -> 5762;
5765 -> 5763;
5766 -> 5733;
5766 -> 5763;
5767 -> 5764;
5767 -> 5763;
5768 -> 5765;
5768 -> 5763;
5769 -> 5763;
5770 -> 5767;
5770 -> 5769;
5771 -> 5768;
5771 -> 5769;
5772 -> 5766;
5772 -> 5769;
5773 -> 5769;
5774 -> 5772;
5774 -> 5773;
5775 -> 5773;
5776 -> 5774;
5776 -> 5775;
5777 -> 5776;
5777 -> 5760;
5777 -> 5775;
5778 -> 5777;
5778 -> 5773;
5779 -> 5778;
5780 -> 5779;
5780 -> 5769;
5781 -> 5780;
5781 -> 5763;
5782 -> 5763;
5783 -> 5766;
5783 -> 5782;
5784 -> 5782;
5785 -> 5783;
5785 -> 5784;
5786 -> 5784;
5787 -> 5785;
5787 -> 5786;
5788 -> 5787;
5788 -> 5760;
5788 -> 5786;
5789 -> 5788;
5789 -> 5784;
5790 -> 5784;
5791 -> 5785;
5791 -> 5760;
5791 -> 5790;
5791 -> 5784;
5792 -> 5789;
5792 -> 5785;
5792 -> 5791;
5793 -> 5785;
5793 -> 5760;
5793 -> 5784;
5794 -> 5785;
5794 -> 5760;
5794 -> 5793;
5794 -> 5784;
5795 -> 5785;
5795 -> 5760;
5795 -> 5784;
5796 -> 5789;
5796 -> 5784;
5797 -> 5794;
5797 -> 5795;
5797 -> 5796;
5797 -> 5760;
5797 -> 5792;
5797 -> 5793;
5797 -> 5784;
5798 -> 5797;
5798 -> 5782;
5799 -> 5783;
5799 -> 5797;
5799 -> 5782;
5800 -> 5782;
5801 -> 5782;
5802 -> 5798;
5802 -> 5801;
5803 -> 5799;
5803 -> 5801;
5804 -> 5799;
5804 -> 5801;
5805 -> 5799;
5805 -> 5801;
5806 -> 5799;
5806 -> 5801;
5807 -> 5800;
5807 -> 5801;
5808 -> 5802;
5808 -> 5807;
5808 -> 5801;
5809 -> 5803;
5809 -> 5807;
5809 -> 5801;
5810 -> 5804;
5810 -> 5807;
5810 -> 5801;
5811 -> 5805;
5811 -> 5807;
5811 -> 5801;
5812 -> 5806;
5812 -> 5807;
5812 -> 5801;
5813 -> 5800;
5813 -> 5763;
5814 -> 5766;
5814 -> 5797;
5814 -> 5763;
5815 -> 5766;
5815 -> 5797;
5815 -> 5814;
5815 -> 5763;
5816 -> 5763;
5817 -> 5763;
5818 -> 5766;
5818 -> 5817;
5819 -> 5818;
5819 -> 5797;
5819 -> 5817;
5820 -> 5819;
5820 -> 5763;
5821 -> 5763;
5822 -> 5820;
5822 -> 5821;
5823 -> 5822;
5823 -> 5797;
5823 -> 5821;
5824 -> 5764;
5824 -> 5823;
5825 -> 5823;
5826 -> 5824;
5826 -> 5825;
5827 -> 5766;
5827 -> 5825;
5828 -> 5825;
5829 -> 5827;
5829 -> 5828;
5830 -> 5829;
5830 -> 5797;
5830 -> 5814;
5830 -> 5828;
5831 -> 5830;
5831 -> 5828;
5832 -> 5829;
5832 -> 5830;
5832 -> 5828;
5833 -> 5828;
5834 -> 5828;
5835 -> 5831;
5835 -> 5834;
5836 -> 5832;
5836 -> 5834;
5837 -> 5832;
5837 -> 5834;
5838 -> 5832;
5838 -> 5834;
5839 -> 5832;
5839 -> 5834;
5840 -> 5833;
5840 -> 5834;
5841 -> 5835;
5841 -> 5840;
5841 -> 5834;
5842 -> 5836;
5842 -> 5840;
5842 -> 5834;
5843 -> 5837;
5843 -> 5840;
5843 -> 5834;
5844 -> 5838;
5844 -> 5840;
5844 -> 5834;
5845 -> 5839;
5845 -> 5840;
5845 -> 5834;
5846 -> 5833;
5846 -> 5825;
5847 -> 5825;
5848 -> 5827;
5848 -> 5847;
5849 -> 5848;
5849 -> 5830;
5849 -> 5847;
5850 -> 5849;
5850 -> 5825;
5851 -> 5825;
5852 -> 5850;
5852 -> 5851;
5853 -> 5825;
5854 -> 5827;
5854 -> 5853;
5855 -> 5853;
5856 -> 5854;
5856 -> 5855;
5857 -> 5856;
5857 -> 5830;
5857 -> 5855;
5858 -> 5857;
5858 -> 5853;
5859 -> 5853;
5860 -> 5854;
5860 -> 5859;
5861 -> 5859;
5862 -> 5860;
5862 -> 5830;
5862 -> 5861;
5863 -> 5861;
5864 -> 5863;
5864 -> 5859;
5865 -> 5864;
5865 -> 5860;
5865 -> 5859;
5866 -> 5859;
5867 -> 5866;
5867 -> 5860;
5867 -> 5859;
5868 -> 5859;
5869 -> 5860;
5869 -> 5830;
5869 -> 5868;
5869 -> 5859;
5870 -> 5860;
5870 -> 5830;
5870 -> 5859;
5871 -> 5853;
5872 -> 5858;
5872 -> 5853;
5873 -> 5872;
5873 -> 5825;
5874 -> 5825;
5875 -> 5827;
5875 -> 5874;
5876 -> 5874;
5877 -> 5875;
5877 -> 5876;
5878 -> 5877;
5878 -> 5830;
5878 -> 5870;
5878 -> 5876;
5879 -> 5877;
5879 -> 5830;
5879 -> 5876;
5880 -> 5877;
5880 -> 5830;
5880 -> 5865;
5880 -> 5867;
5880 -> 5870;
5880 -> 5879;
5881 -> 5880;
5881 -> 5874;
5882 -> 5874;
5883 -> 5875;
5883 -> 5882;
5884 -> 5882;
5885 -> 5883;
5885 -> 5830;
5885 -> 5867;
5885 -> 5880;
5885 -> 5884;
5886 -> 5884;
5887 -> 5886;
5887 -> 5882;
5888 -> 5887;
5888 -> 5883;
5888 -> 5882;
5889 -> 5882;
5890 -> 5889;
5890 -> 5883;
5890 -> 5882;
5891 -> 5882;
5892 -> 5883;
5892 -> 5830;
5892 -> 5891;
5892 -> 5882;
5893 -> 5883;
5893 -> 5830;
5893 -> 5870;
5893 -> 5882;
5894 -> 5874;
5895 -> 5881;
5895 -> 5874;
5896 -> 5895;
5896 -> 5825;
5897 -> 5825;
5898 -> 5896;
5898 -> 5897;
5899 -> 5825;
5900 -> 5825;
5901 -> 5899;
5901 -> 5900;
5902 -> 5827;
5902 -> 5900;
5903 -> 5900;
5904 -> 5901;
5904 -> 5900;
5905 -> 5900;
5906 -> 5903;
5906 -> 5905;
5907 -> 5904;
5907 -> 5905;
5908 -> 5902;
5908 -> 5905;
5909 -> 5907;
5909 -> 5905;
5910 -> 0;
5910 -> 5909;
5911 -> 5906;
5911 -> 5905;
5912 -> 5910;
5912 -> 5911;
5912 -> 5908;
5912 -> 5830;
5912 -> 5865;
5912 -> 5888;
5912 -> 5867;
5912 -> 5880;
5912 -> 5890;
5912 -> 5870;
5912 -> 5893;
5912 -> 5905;
5913 -> 5905;
5914 -> 5912;
5914 -> 5913;
5915 -> 5912;
5915 -> 5913;
5916 -> 5912;
5916 -> 5913;
5917 -> 5913;
5918 -> 5915;
5918 -> 5917;
5918 -> 5913;
5919 -> 5916;
5919 -> 5912;
5919 -> 5915;
5919 -> 5913;
5920 -> 5913;
5921 -> 5916;
5921 -> 5912;
5921 -> 5920;
5921 -> 5913;
5922 -> 5916;
5922 -> 5912;
5922 -> 5915;
5922 -> 5921;
5923 -> 5912;
5923 -> 5913;
5924 -> 5912;
5924 -> 5913;
5925 -> 5913;
5926 -> 5924;
5926 -> 5925;
5927 -> 5926;
5927 -> 5922;
5927 -> 5925;
5928 -> 5927;
5928 -> 5913;
5929 -> 5913;
5930 -> 5928;
5930 -> 5929;
5931 -> 5913;
5932 -> 5924;
5932 -> 5931;
5933 -> 5931;
5934 -> 5932;
5934 -> 5933;
5935 -> 5934;
5935 -> 5922;
5935 -> 5933;
5936 -> 5935;
5936 -> 5931;
5937 -> 5931;
5938 -> 5936;
5938 -> 5937;
5939 -> 5938;
5940 -> 5932;
5940 -> 5939;
5941 -> 5939;
5942 -> 5940;
5942 -> 5941;
5943 -> 5942;
5943 -> 5939;
5944 -> 5939;
5945 -> 5943;
5945 -> 5944;
5946 -> 5944;
5947 -> 5945;
5947 -> 5946;
5948 -> 5947;
5948 -> 5944;
5949 -> 5939;
5950 -> 5949;
5950 -> 5938;
5951 -> 5938;
5952 -> 5932;
5952 -> 5951;
5953 -> 5951;
5954 -> 5952;
5954 -> 5953;
5955 -> 5954;
5955 -> 5922;
5955 -> 5953;
5956 -> 5955;
5956 -> 5951;
5957 -> 5956;
5957 -> 5938;
5958 -> 5950;
5958 -> 5957;
5958 -> 5938;
5959 -> 5938;
5960 -> 5932;
5960 -> 5959;
5961 -> 5959;
5962 -> 5960;
5962 -> 5961;
5963 -> 5962;
5963 -> 5959;
5964 -> 5959;
5965 -> 5963;
5965 -> 5964;
5966 -> 5964;
5967 -> 5965;
5967 -> 5966;
5968 -> 5967;
5968 -> 5964;
5969 -> 5968;
5969 -> 5938;
5970 -> 5958;
5970 -> 5969;
5970 -> 5938;
5971 -> 5970;
5972 -> 5971;
5972 -> 5913;
5973 -> 5930;
5973 -> 5972;
5973 -> 5913;
5974 -> 5913;
5975 -> 5924;
5975 -> 5974;
5976 -> 5974;
5977 -> 5975;
5977 -> 5922;
5977 -> 5976;
5978 -> 5977;
5978 -> 5974;
5979 -> 5974;
5980 -> 5979;
5981 -> 5975;
5981 -> 5922;
5981 -> 5980;
5982 -> 5981;
5982 -> 5922;
5982 -> 5980;
5983 -> 5979;
5984 -> 5979;
5985 -> 5975;
5985 -> 5922;
5985 -> 5984;
5985 -> 5979;
5986 -> 5975;
5986 -> 5922;
5986 -> 5979;
5987 -> 5974;
5988 -> 5978;
5988 -> 5974;
5989 -> 5988;
5989 -> 5913;
5990 -> 5913;
5991 -> 5924;
5991 -> 5990;
5992 -> 5991;
5992 -> 5922;
5992 -> 5986;
5992 -> 5990;
5993 -> 5991;
5993 -> 5922;
5993 -> 5990;
5994 -> 5991;
5994 -> 5922;
5994 -> 5982;
5994 -> 5975;
5994 -> 5986;
5994 -> 5993;
5995 -> 5994;
5995 -> 5913;
5996 -> 5913;
5997 -> 5995;
5997 -> 5996;
5998 -> 0;
5998 -> 5997;
5999 -> 5989;
5999 -> 5998;
5999 -> 5922;
5999 -> 5982;
5999 -> 5975;
5999 -> 5994;
5999 -> 5986;
5999 -> 5905;
6000 -> 5989;
6000 -> 5913;
6001 -> 5913;
6002 -> 6000;
6002 -> 6001;
6003 -> 6002;
6003 -> 5999;
6003 -> 6001;
6004 -> 6003;
6004 -> 5913;
6005 -> 5913;
6006 -> 6004;
6006 -> 6005;
6007 -> 5913;
6008 -> 6000;
6008 -> 6007;
6009 -> 6008;
6009 -> 5999;
6009 -> 6007;
6010 -> 6009;
6010 -> 5913;
6011 -> 5913;
6012 -> 6010;
6012 -> 6011;
6013 -> 6006;
6013 -> 6012;
6013 -> 5913;
6014 -> 5989;
6014 -> 5913;
6015 -> 5989;
6015 -> 5913;
6016 -> 5989;
6016 -> 5913;
6017 -> 5913;
6018 -> 6016;
6018 -> 6017;
6019 -> 6018;
6019 -> 6013;
6019 -> 6017;
6020 -> 6019;
6020 -> 5913;
6021 -> 6020;
6021 -> 6014;
6021 -> 5913;
6022 -> 6020;
6022 -> 6021;
6023 -> 6021;
6024 -> 6022;
6024 -> 6023;
6024 -> 5905;
6025 -> 5908;
6025 -> 5910;
6025 -> 5911;
6025 -> 5912;
6025 -> 5922;
6025 -> 5998;
6025 -> 6013;
6025 -> 6023;
6025 -> 6022;
6025 -> 5905;
6026 -> 5898;
6026 -> 6025;
6026 -> 5825;
6027 -> 5825;
6028 -> 5827;
6028 -> 6027;
6029 -> 6027;
6030 -> 6028;
6030 -> 6029;
6031 -> 6030;
6031 -> 6025;
6031 -> 6029;
6032 -> 6027;
6033 -> 6028;
6033 -> 6032;
6034 -> 6032;
6035 -> 6033;
6035 -> 6025;
6035 -> 6034;
6036 -> 6032;
6037 -> 6036;
6037 -> 6033;
6037 -> 6032;
6038 -> 6032;
6039 -> 6033;
6039 -> 6025;
6039 -> 6038;
6039 -> 6032;
6040 -> 6033;
6040 -> 6025;
6040 -> 6032;
6041 -> 6027;
6042 -> 5825;
6043 -> 6031;
6043 -> 6042;
6044 -> 6026;
6044 -> 6043;
6044 -> 5825;
6045 -> 5825;
6046 -> 5827;
6046 -> 6045;
6047 -> 6045;
6048 -> 6046;
6048 -> 6047;
6049 -> 6048;
6049 -> 6025;
6049 -> 6040;
6049 -> 6047;
6050 -> 6048;
6050 -> 6025;
6050 -> 6047;
6051 -> 6048;
6051 -> 6025;
6051 -> 6035;
6051 -> 6037;
6051 -> 6040;
6051 -> 6050;
6052 -> 6045;
6053 -> 6046;
6053 -> 6052;
6054 -> 6052;
6055 -> 6053;
6055 -> 6025;
6055 -> 6037;
6055 -> 6051;
6055 -> 6054;
6056 -> 6055;
6056 -> 6025;
6056 -> 6054;
6057 -> 6052;
6058 -> 6057;
6058 -> 6053;
6058 -> 6052;
6059 -> 6052;
6060 -> 6053;
6060 -> 6025;
6060 -> 6059;
6060 -> 6052;
6061 -> 6053;
6061 -> 6025;
6061 -> 6040;
6061 -> 6052;
6062 -> 6045;
6063 -> 5825;
6064 -> 6051;
6064 -> 6063;
6065 -> 6044;
6065 -> 6064;
6065 -> 5825;
6066 -> 5846;
6066 -> 6065;
6067 -> 6065;
6068 -> 6066;
6068 -> 6067;
6069 -> 5827;
6069 -> 6067;
6070 -> 6068;
6070 -> 5842;
6070 -> 6069;
6070 -> 6067;
6071 -> 6068;
6071 -> 5843;
6071 -> 6069;
6071 -> 6067;
6072 -> 6068;
6072 -> 5844;
6072 -> 6069;
6072 -> 6025;
6072 -> 6067;
6073 -> 6068;
6073 -> 5845;
6073 -> 6069;
6073 -> 6025;
6073 -> 6067;
6074 -> 6068;
6074 -> 5841;
6074 -> 6067;
6075 -> 6067;
6076 -> 6074;
6076 -> 6075;
6077 -> 6069;
6077 -> 6075;
6078 -> 6076;
6078 -> 5830;
6078 -> 6077;
6078 -> 6025;
6078 -> 6075;
6079 -> 6075;
6080 -> 6078;
6080 -> 6079;
6080 -> 6075;
6081 -> 6078;
6081 -> 6077;
6081 -> 6025;
6081 -> 6075;
6082 -> 6076;
6082 -> 5830;
6082 -> 6077;
6082 -> 6075;
6083 -> 6075;
6084 -> 6078;
6084 -> 6083;
6084 -> 6075;
6085 -> 6078;
6085 -> 6077;
6085 -> 6025;
6085 -> 6075;
6086 -> 6078;
6086 -> 6077;
6086 -> 6075;
6087 -> 6075;
6088 -> 6087;
6088 -> 6077;
6088 -> 6075;
6089 -> 6075;
6090 -> 6089;
6090 -> 6077;
6090 -> 6075;
6091 -> 6076;
6091 -> 5830;
6091 -> 6077;
6091 -> 6075;
6092 -> 6075;
6093 -> 6077;
6093 -> 6025;
6093 -> 6092;
6093 -> 6075;
6094 -> 6067;
6095 -> 6065;
6096 -> 5826;
6096 -> 6065;
6097 -> 6065;
6098 -> 6096;
6098 -> 6097;
6099 -> 5827;
6099 -> 6097;
6100 -> 6097;
6101 -> 6099;
6101 -> 6100;
6102 -> 6101;
6102 -> 6025;
6102 -> 6040;
6102 -> 6061;
6102 -> 6086;
6102 -> 6100;
6103 -> 6101;
6103 -> 6025;
6103 -> 6035;
6103 -> 6056;
6103 -> 6091;
6103 -> 6037;
6103 -> 6051;
6103 -> 6058;
6103 -> 6088;
6103 -> 6040;
6103 -> 6061;
6103 -> 6086;
6103 -> 6070;
6103 -> 6071;
6103 -> 6072;
6103 -> 6073;
6103 -> 6082;
6103 -> 6090;
6104 -> 6103;
6104 -> 6097;
6105 -> 6097;
6106 -> 6104;
6106 -> 6105;
6107 -> 0;
6107 -> 6097;
6108 -> 6097;
6109 -> 6107;
6109 -> 6108;
6110 -> 6099;
6110 -> 6108;
6111 -> 6109;
6111 -> 6108;
6112 -> 6108;
6113 -> 6111;
6113 -> 6112;
6114 -> 6113;
6114 -> 0;
6114 -> 6112;
6115 -> 6114;
6116 -> 6108;
6117 -> 6110;
6117 -> 6116;
6118 -> 6117;
6118 -> 6025;
6118 -> 6037;
6118 -> 6051;
6118 -> 6058;
6118 -> 6088;
6118 -> 6103;
6118 -> 6116;
6119 -> 6118;
6119 -> 6108;
6120 -> 6108;
6121 -> 6119;
6121 -> 6120;
6122 -> 6121;
6122 -> 6108;
6123 -> 6122;
6123 -> 6109;
6123 -> 6108;
6124 -> 6123;
6125 -> 6124;
6125 -> 6025;
6125 -> 6037;
6125 -> 6051;
6125 -> 6058;
6125 -> 6088;
6125 -> 6103;
6126 -> 6124;
6127 -> 6123;
6128 -> 6119;
6128 -> 6123;
6129 -> 0;
6129 -> 6097;
6130 -> 6097;
6131 -> 6129;
6131 -> 6130;
6132 -> 6099;
6132 -> 6130;
6133 -> 6131;
6133 -> 6130;
6134 -> 6130;
6135 -> 6133;
6135 -> 6134;
6136 -> 6135;
6136 -> 0;
6136 -> 6134;
6137 -> 6136;
6138 -> 6130;
6139 -> 6132;
6139 -> 6138;
6140 -> 6139;
6140 -> 6025;
6140 -> 6040;
6140 -> 6061;
6140 -> 6086;
6140 -> 6124;
6140 -> 6138;
6141 -> 6139;
6141 -> 6025;
6141 -> 6035;
6141 -> 6056;
6141 -> 6091;
6141 -> 6124;
6141 -> 6037;
6141 -> 6051;
6141 -> 6058;
6141 -> 6088;
6141 -> 6103;
6141 -> 6040;
6141 -> 6061;
6141 -> 6086;
6141 -> 6070;
6141 -> 6071;
6141 -> 6072;
6141 -> 6073;
6141 -> 6082;
6141 -> 6090;
6142 -> 6130;
6143 -> 6141;
6143 -> 6131;
6143 -> 6130;
6144 -> 6143;
6144 -> 6025;
6144 -> 6037;
6144 -> 6051;
6144 -> 6058;
6144 -> 6088;
6144 -> 6103;
6144 -> 6124;
6144 -> 6141;
6145 -> 6143;
6146 -> 6143;
6147 -> 6141;
6147 -> 6143;
6148 -> 6099;
6148 -> 6025;
6148 -> 6070;
6148 -> 6097;
6149 -> 6099;
6149 -> 6025;
6149 -> 6070;
6149 -> 0;
6149 -> 6097;
6150 -> 6149;
6150 -> 6099;
6150 -> 6097;
6151 -> 6097;
6152 -> 6099;
6152 -> 6151;
6153 -> 6152;
6153 -> 6025;
6153 -> 6040;
6153 -> 6061;
6153 -> 6086;
6153 -> 6124;
6153 -> 6143;
6153 -> 6151;
6154 -> 6152;
6154 -> 6025;
6154 -> 6082;
6154 -> 6151;
6155 -> 6152;
6155 -> 6025;
6155 -> 6035;
6155 -> 6056;
6155 -> 6091;
6155 -> 6124;
6155 -> 6143;
6155 -> 6151;
6156 -> 6152;
6156 -> 6154;
6156 -> 6153;
6156 -> 6155;
6156 -> 6025;
6156 -> 6035;
6156 -> 6056;
6156 -> 6091;
6156 -> 6124;
6156 -> 6143;
6156 -> 6037;
6156 -> 6051;
6156 -> 6058;
6156 -> 6088;
6156 -> 6103;
6156 -> 6141;
6156 -> 6040;
6156 -> 6061;
6156 -> 6086;
6156 -> 6070;
6156 -> 6150;
6156 -> 6071;
6156 -> 6072;
6156 -> 6073;
6156 -> 6082;
6156 -> 6090;
6156 -> 6089;
6156 -> 6151;
6157 -> 6151;
6158 -> 6151;
6159 -> 6157;
6159 -> 6158;
6160 -> 6157;
6160 -> 6097;
6161 -> 6099;
6161 -> 6156;
6161 -> 6097;
6162 -> 6099;
6162 -> 6161;
6162 -> 6097;
6163 -> 6097;
6164 -> 6097;
6165 -> 6097;
6166 -> 6099;
6166 -> 6165;
6167 -> 6166;
6167 -> 6162;
6167 -> 6165;
6168 -> 6166;
6168 -> 6162;
6168 -> 6165;
6169 -> 6168;
6169 -> 6097;
6170 -> 6097;
6171 -> 6169;
6171 -> 6170;
6172 -> 6171;
6173 -> 6171;
6174 -> 6172;
6174 -> 6173;
6175 -> 6172;
6175 -> 6173;
6176 -> 6099;
6176 -> 6173;
6177 -> 6173;
6178 -> 6176;
6178 -> 6177;
6179 -> 6178;
6179 -> 6173;
6180 -> 6173;
6181 -> 6179;
6181 -> 6180;
6182 -> 6180;
6183 -> 6181;
6183 -> 6182;
6184 -> 6183;
6184 -> 6180;
6185 -> 6173;
6186 -> 6185;
6186 -> 6171;
6187 -> 6171;
6188 -> 6172;
6188 -> 6187;
6189 -> 6187;
6190 -> 6188;
6190 -> 6189;
6190 -> 6187;
6191 -> 6188;
6191 -> 6187;
6192 -> 6188;
6192 -> 6187;
6193 -> 6187;
6194 -> 6188;
6194 -> 6193;
6195 -> 6194;
6195 -> 6187;
6196 -> 6187;
6197 -> 6195;
6197 -> 6196;
6198 -> 6187;
6199 -> 6188;
6199 -> 6198;
6200 -> 6198;
6201 -> 6199;
6201 -> 6200;
6202 -> 6201;
6202 -> 6198;
6203 -> 6198;
6204 -> 6202;
6204 -> 6203;
6205 -> 6204;
6206 -> 6199;
6206 -> 6205;
6207 -> 6205;
6208 -> 6206;
6208 -> 6207;
6209 -> 6208;
6209 -> 6205;
6210 -> 6205;
6211 -> 6209;
6211 -> 6210;
6212 -> 6210;
6213 -> 6211;
6213 -> 6212;
6214 -> 6213;
6214 -> 6210;
6215 -> 6205;
6216 -> 6215;
6216 -> 6204;
6217 -> 6204;
6218 -> 6199;
6218 -> 6217;
6219 -> 6217;
6220 -> 6218;
6220 -> 6219;
6221 -> 6220;
6221 -> 6188;
6221 -> 6219;
6222 -> 6221;
6222 -> 6217;
6223 -> 6222;
6223 -> 6204;
6224 -> 6216;
6224 -> 6223;
6224 -> 6204;
6225 -> 6204;
6226 -> 6199;
6226 -> 6225;
6227 -> 6225;
6228 -> 6226;
6228 -> 6227;
6229 -> 6228;
6229 -> 6225;
6230 -> 6225;
6231 -> 6229;
6231 -> 6230;
6232 -> 6230;
6233 -> 6231;
6233 -> 6232;
6234 -> 6233;
6234 -> 6230;
6235 -> 6234;
6235 -> 6204;
6236 -> 6224;
6236 -> 6235;
6236 -> 6204;
6237 -> 6236;
6238 -> 6237;
6238 -> 6187;
6239 -> 6197;
6239 -> 6238;
6239 -> 6187;
6240 -> 6187;
6241 -> 6188;
6241 -> 6240;
6241 -> 6187;
6242 -> 6187;
6243 -> 6188;
6243 -> 6187;
6244 -> 6188;
6244 -> 6187;
6245 -> 6186;
6245 -> 6188;
6245 -> 6171;
6246 -> 6171;
6247 -> 6099;
6247 -> 6246;
6248 -> 6246;
6249 -> 6247;
6249 -> 6248;
6250 -> 6249;
6250 -> 6188;
6250 -> 6248;
6251 -> 6250;
6251 -> 6246;
6252 -> 6246;
6253 -> 6251;
6253 -> 6252;
6254 -> 6253;
6255 -> 6247;
6255 -> 6254;
6256 -> 6254;
6257 -> 6255;
6257 -> 6256;
6258 -> 6257;
6258 -> 6254;
6259 -> 6254;
6260 -> 6258;
6260 -> 6259;
6261 -> 6259;
6262 -> 6260;
6262 -> 6261;
6263 -> 6262;
6263 -> 6259;
6264 -> 6254;
6265 -> 6264;
6265 -> 6253;
6266 -> 6253;
6267 -> 6247;
6267 -> 6266;
6268 -> 6266;
6269 -> 6267;
6269 -> 6268;
6270 -> 6269;
6270 -> 6188;
6270 -> 6268;
6271 -> 6270;
6271 -> 6266;
6272 -> 6271;
6272 -> 6253;
6273 -> 6265;
6273 -> 6272;
6273 -> 6253;
6274 -> 6253;
6275 -> 6247;
6275 -> 6274;
6276 -> 6274;
6277 -> 6275;
6277 -> 6276;
6278 -> 6277;
6278 -> 6274;
6279 -> 6274;
6280 -> 6278;
6280 -> 6279;
6281 -> 6279;
6282 -> 6280;
6282 -> 6281;
6283 -> 6282;
6283 -> 6279;
6284 -> 6283;
6284 -> 6253;
6285 -> 6273;
6285 -> 6284;
6285 -> 6253;
6286 -> 6285;
6287 -> 6245;
6287 -> 6286;
6287 -> 6171;
6288 -> 6160;
6288 -> 6171;
6289 -> 6171;
6290 -> 6288;
6290 -> 6289;
6291 -> 6290;
6291 -> 6156;
6291 -> 6289;
6291 -> 6188;
6292 -> 6290;
6292 -> 6156;
6292 -> 6289;
6292 -> 6188;
6293 -> 6290;
6293 -> 6156;
6293 -> 6289;
6293 -> 6188;
6294 -> 6289;
6295 -> 6293;
6295 -> 6294;
6295 -> 6289;
6296 -> 6293;
6296 -> 6289;
6296 -> 6188;
6297 -> 6289;
6298 -> 6293;
6298 -> 6297;
6298 -> 6289;
6299 -> 6293;
6299 -> 6289;
6299 -> 6188;
6300 -> 6289;
6301 -> 6289;
6301 -> 6188;
6301 -> 6300;
6302 -> 6171;
6303 -> 6287;
6303 -> 6097;
6304 -> 6303;
6305 -> 6099;
6305 -> 6304;
6306 -> 6305;
6306 -> 6188;
6306 -> 6290;
6306 -> 6291;
6306 -> 6292;
6306 -> 6293;
6306 -> 6289;
6306 -> 6304;
6307 -> 6304;
6308 -> 6304;
6309 -> 6306;
6309 -> 6304;
6310 -> 6304;
6311 -> 6307;
6311 -> 6304;
6312 -> 6308;
6312 -> 6304;
6313 -> 6304;
6314 -> 6309;
6314 -> 6313;
6315 -> 6310;
6315 -> 6313;
6316 -> 6310;
6316 -> 6313;
6317 -> 6310;
6317 -> 6313;
6318 -> 6311;
6318 -> 6313;
6319 -> 6312;
6319 -> 6313;
6320 -> 6305;
6320 -> 6313;
6321 -> 6315;
6321 -> 6313;
6322 -> 6321;
6323 -> 6321;
6324 -> 6322;
6324 -> 6323;
6325 -> 6320;
6325 -> 6323;
6326 -> 6323;
6327 -> 6325;
6327 -> 6326;
6328 -> 6327;
6328 -> 6306;
6328 -> 6326;
6329 -> 6327;
6329 -> 6306;
6329 -> 6326;
6330 -> 6329;
6330 -> 6323;
6331 -> 6323;
6332 -> 6330;
6332 -> 6331;
6333 -> 6324;
6333 -> 6323;
6334 -> 6333;
6334 -> 6325;
6334 -> 6306;
6334 -> 6329;
6334 -> 6323;
6335 -> 6323;
6336 -> 6334;
6336 -> 6335;
6337 -> 6334;
6337 -> 6335;
6338 -> 6334;
6338 -> 6335;
6339 -> 6335;
6340 -> 6338;
6340 -> 6339;
6341 -> 6340;
6341 -> 6335;
6342 -> 6335;
6343 -> 6341;
6343 -> 6342;
6344 -> 6335;
6345 -> 6343;
6345 -> 6344;
6346 -> 6345;
6346 -> 6344;
6347 -> 6344;
6348 -> 6346;
6348 -> 6347;
6349 -> 6348;
6349 -> 6347;
6350 -> 6349;
6351 -> 6335;
6352 -> 6338;
6352 -> 6351;
6353 -> 6352;
6354 -> 6352;
6355 -> 6353;
6355 -> 6354;
6356 -> 6355;
6356 -> 6352;
6357 -> 6352;
6358 -> 6356;
6358 -> 6357;
6359 -> 6357;
6359 -> 6335;
6360 -> 6337;
6360 -> 6359;
6361 -> 6359;
6362 -> 6360;
6362 -> 6361;
6363 -> 6338;
6363 -> 6361;
6364 -> 6362;
6364 -> 6361;
6365 -> 6361;
6366 -> 6364;
6366 -> 6365;
6367 -> 6363;
6367 -> 6365;
6368 -> 6366;
6368 -> 6365;
6369 -> 6365;
6370 -> 6368;
6370 -> 6369;
6371 -> 6367;
6371 -> 6369;
6372 -> 6369;
6373 -> 6369;
6374 -> 6372;
6374 -> 6373;
6375 -> 6371;
6375 -> 6373;
6376 -> 6373;
6377 -> 6375;
6377 -> 6376;
6378 -> 6376;
6379 -> 6377;
6379 -> 6378;
6380 -> 6379;
6380 -> 6376;
6381 -> 6380;
6382 -> 6381;
6382 -> 6373;
6383 -> 6374;
6383 -> 6373;
6384 -> 6373;
6385 -> 6383;
6385 -> 6384;
6386 -> 6375;
6386 -> 6384;
6387 -> 6384;
6388 -> 6386;
6388 -> 6387;
6389 -> 6388;
6389 -> 6384;
6390 -> 6384;
6391 -> 6389;
6391 -> 6390;
6392 -> 6391;
6392 -> 0;
6392 -> 6384;
6393 -> 6392;
6394 -> 6386;
6394 -> 6393;
6395 -> 6393;
6396 -> 6394;
6396 -> 6395;
6397 -> 6396;
6397 -> 6393;
6398 -> 6393;
6398 -> 6392;
6399 -> 6392;
6400 -> 6399;
6400 -> 6392;
6401 -> 6398;
6401 -> 6400;
6401 -> 6392;
6402 -> 6392;
6403 -> 6402;
6404 -> 6402;
6405 -> 6402;
6405 -> 6392;
6406 -> 6392;
6407 -> 6386;
6407 -> 6406;
6408 -> 6407;
6408 -> 6334;
6408 -> 6402;
6408 -> 6406;
6409 -> 6408;
6409 -> 6392;
6410 -> 6405;
6410 -> 6392;
6411 -> 6410;
6411 -> 6373;
6412 -> 6411;
6412 -> 6373;
6413 -> 6373;
6414 -> 6412;
6414 -> 6413;
6415 -> 6412;
6415 -> 6413;
6416 -> 6414;
6416 -> 6413;
6417 -> 6413;
6418 -> 6417;
6418 -> 6416;
6418 -> 6413;
6419 -> 6417;
6419 -> 6413;
6420 -> 6419;
6420 -> 6418;
6420 -> 6413;
6421 -> 6420;
6421 -> 6369;
6422 -> 6421;
6422 -> 6420;
6422 -> 6369;
6423 -> 6421;
6423 -> 6369;
6424 -> 6369;
6425 -> 6371;
6425 -> 6424;
6426 -> 6425;
6426 -> 6420;
6426 -> 6424;
6427 -> 6425;
6427 -> 6420;
6427 -> 6424;
6428 -> 6427;
6428 -> 6369;
6429 -> 6369;
6430 -> 6428;
6430 -> 6429;
6431 -> 6423;
6431 -> 6369;
6432 -> 6431;
6432 -> 6365;
6433 -> 6365;
6434 -> 6367;
6434 -> 6433;
6435 -> 6434;
6435 -> 6420;
6435 -> 6427;
6435 -> 6433;
6436 -> 6435;
6436 -> 6365;
6437 -> 6365;
6438 -> 6436;
6438 -> 6437;
6439 -> 6432;
6439 -> 6365;
6440 -> 6439;
6440 -> 6361;
6441 -> 6361;
6442 -> 6363;
6442 -> 6441;
6443 -> 6442;
6443 -> 6420;
6443 -> 6427;
6443 -> 6441;
6444 -> 6443;
6444 -> 6361;
6445 -> 6361;
6446 -> 6363;
6446 -> 6445;
6447 -> 6446;
6447 -> 6420;
6447 -> 6427;
6447 -> 6445;
6448 -> 6447;
6448 -> 6361;
6449 -> 6361;
6450 -> 6448;
6450 -> 6449;
6451 -> 6444;
6451 -> 6450;
6451 -> 6361;
6452 -> 6440;
6452 -> 6361;
6453 -> 6452;
6453 -> 6359;
6454 -> 6334;
6454 -> 6453;
6454 -> 6420;
6454 -> 6427;
6454 -> 6323;
6455 -> 6334;
6455 -> 6335;
6456 -> 0;
6456 -> 6313;
6457 -> 0;
6457 -> 6313;
6458 -> 6317;
6458 -> 6457;
6458 -> 6310;
6458 -> 6313;
6459 -> 6320;
6459 -> 6454;
6459 -> 6313;
6460 -> 6320;
6460 -> 6454;
6460 -> 0;
6460 -> 6313;
6461 -> 6460;
6461 -> 6320;
6461 -> 6313;
6462 -> 6454;
6462 -> 6313;
6463 -> 6456;
6463 -> 6313;
6464 -> 6314;
6464 -> 6313;
6465 -> 6313;
6466 -> 6315;
6466 -> 6313;
6467 -> 6316;
6467 -> 6313;
6468 -> 6317;
6468 -> 6313;
6469 -> 6319;
6469 -> 6313;
6470 -> 6313;
6471 -> 6462;
6471 -> 6470;
6472 -> 6463;
6472 -> 6470;
6473 -> 6464;
6473 -> 6470;
6474 -> 6465;
6474 -> 6470;
6475 -> 6466;
6475 -> 6470;
6476 -> 6467;
6476 -> 6470;
6477 -> 6468;
6477 -> 6470;
6478 -> 6469;
6478 -> 6470;
6479 -> 6320;
6479 -> 6470;
6480 -> 6471;
6480 -> 6470;
6481 -> 6472;
6481 -> 6470;
6482 -> 6470;
6483 -> 6475;
6483 -> 6470;
6484 -> 6476;
6484 -> 6470;
6485 -> 6477;
6485 -> 6470;
6486 -> 6478;
6486 -> 6470;
6487 -> 6480;
6487 -> 6481;
6487 -> 6482;
6487 -> 6483;
6487 -> 6484;
6487 -> 6485;
6487 -> 6486;
6487 -> 6479;
6487 -> 6454;
6487 -> 6461;
6487 -> 6310;
6487 -> 6458;
6487 -> 6470;
6488 -> 6487;
6488 -> 6482;
6489 -> 6482;
6490 -> 6488;
6490 -> 6489;
6491 -> 6490;
6491 -> 6482;
6492 -> 6491;
6493 -> 6487;
6493 -> 6482;
6494 -> 6493;
6494 -> 6492;
6494 -> 6482;
6495 -> 6487;
6495 -> 6482;
6496 -> 6482;
6497 -> 6495;
6497 -> 6496;
6498 -> 6497;
6498 -> 6494;
6498 -> 6496;
6499 -> 6498;
6499 -> 6482;
6500 -> 6482;
6501 -> 6499;
6501 -> 6500;
6501 -> 6482;
6502 -> 6499;
6502 -> 6487;
6502 -> 6482;
6503 -> 6482;
6504 -> 6499;
6504 -> 6503;
6504 -> 6482;
6505 -> 6499;
6505 -> 6487;
6505 -> 6482;
6506 -> 6482;
6507 -> 6487;
6507 -> 6499;
6507 -> 6506;
6507 -> 6482;
6508 -> 6487;
6508 -> 6482;
6509 -> 6487;
6509 -> 6482;
6510 -> 6508;
6510 -> 6499;
6510 -> 6482;
6511 -> 6482;
6512 -> 6510;
6512 -> 6511;
6513 -> 6509;
6513 -> 6511;
6514 -> 6513;
6514 -> 6499;
6514 -> 6512;
6514 -> 6511;
6515 -> 6513;
6515 -> 6499;
6515 -> 6511;
6516 -> 6511;
6517 -> 6513;
6517 -> 6499;
6517 -> 6515;
6517 -> 6516;
6517 -> 6511;
6518 -> 6482;
6519 -> 6508;
6519 -> 6482;
6520 -> 6482;
6521 -> 6508;
6521 -> 6499;
6521 -> 6520;
6522 -> 6508;
6522 -> 6499;
6522 -> 6520;
6523 -> 6482;
6524 -> 6512;
6525 -> 6508;
6525 -> 6524;
6526 -> 6524;
6527 -> 6525;
6527 -> 6526;
6528 -> 6527;
6528 -> 6524;
6529 -> 6524;
6529 -> 6512;
6530 -> 6512;
6531 -> 6530;
6531 -> 6512;
6532 -> 6529;
6532 -> 6531;
6532 -> 6512;
6533 -> 6512;
6534 -> 6512;
6535 -> 6512;
6536 -> 6508;
6536 -> 6535;
6537 -> 6536;
6537 -> 6499;
6537 -> 6512;
6537 -> 6535;
6538 -> 6537;
6538 -> 6512;
6539 -> 6508;
6539 -> 6512;
6539 -> 6520;
6540 -> 6482;
6541 -> 6508;
6541 -> 6512;
6541 -> 6540;
6541 -> 6482;
6542 -> 6482;
6543 -> 6508;
6543 -> 6482;
6544 -> 6482;
6545 -> 6543;
6545 -> 6544;
6546 -> 6545;
6546 -> 6512;
6546 -> 6544;
6547 -> 6546;
6547 -> 6482;
6548 -> 6482;
6549 -> 6547;
6549 -> 6548;
6550 -> 6549;
6551 -> 6543;
6551 -> 6550;
6552 -> 0;
6552 -> 6550;
6553 -> 6550;
6554 -> 6552;
6554 -> 6553;
6555 -> 6551;
6555 -> 6553;
6556 -> 6555;
6556 -> 6512;
6556 -> 6553;
6557 -> 6555;
6557 -> 6512;
6557 -> 6556;
6557 -> 6553;
6558 -> 6554;
6558 -> 6553;
6559 -> 6553;
6560 -> 6558;
6560 -> 6559;
6561 -> 6555;
6561 -> 6559;
6562 -> 6559;
6563 -> 6559;
6564 -> 6559;
6565 -> 6561;
6565 -> 6564;
6566 -> 6565;
6566 -> 6559;
6567 -> 6559;
6568 -> 6566;
6568 -> 6567;
6569 -> 6568;
6569 -> 6559;
6570 -> 6559;
6571 -> 6569;
6571 -> 6570;
6572 -> 6571;
6572 -> 6570;
6573 -> 6572;
6574 -> 6568;
6574 -> 6559;
6575 -> 6559;
6576 -> 6574;
6576 -> 6575;
6577 -> 6576;
6577 -> 6575;
6578 -> 6575;
6579 -> 6577;
6579 -> 6578;
6580 -> 6579;
6580 -> 6578;
6581 -> 6578;
6582 -> 6580;
6582 -> 6581;
6583 -> 6582;
6583 -> 6581;
6584 -> 0;
6584 -> 6583;
6585 -> 6568;
6585 -> 0;
6585 -> 6584;
6586 -> 6585;
6587 -> 6561;
6587 -> 6586;
6588 -> 6586;
6589 -> 6587;
6589 -> 6588;
6590 -> 6589;
6590 -> 6586;
6591 -> 6586;
6592 -> 6590;
6592 -> 6591;
6593 -> 6586;
6594 -> 6593;
6594 -> 6585;
6595 -> 6594;
6596 -> 6594;
6597 -> 6595;
6597 -> 6596;
6598 -> 6595;
6598 -> 6596;
6599 -> 6561;
6599 -> 6596;
6600 -> 6596;
6601 -> 6599;
6601 -> 6600;
6602 -> 6601;
6602 -> 6596;
6603 -> 6596;
6604 -> 6602;
6604 -> 6603;
6605 -> 6596;
6605 -> 6594;
6606 -> 6605;
6607 -> 6606;
6607 -> 6605;
6608 -> 6605;
6609 -> 6607;
6609 -> 6608;
6610 -> 6568;
6610 -> 0;
6610 -> 6609;
6611 -> 6560;
6611 -> 6610;
6612 -> 6610;
6613 -> 6611;
6613 -> 6612;
6614 -> 6561;
6614 -> 6612;
6615 -> 6613;
6615 -> 0;
6615 -> 6612;
6616 -> 6612;
6617 -> 6614;
6617 -> 6616;
6618 -> 6617;
6618 -> 6612;
6619 -> 6612;
6620 -> 6618;
6620 -> 6619;
6621 -> 6619;
6622 -> 6620;
6622 -> 6621;
6623 -> 6622;
6623 -> 6619;
6624 -> 6612;
6625 -> 6614;
6625 -> 6624;
6626 -> 6625;
6626 -> 6612;
6627 -> 6612;
6628 -> 6626;
6628 -> 6627;
6629 -> 6612;
6630 -> 6628;
6630 -> 6629;
6631 -> 6630;
6631 -> 6629;
6632 -> 6629;
6633 -> 6631;
6633 -> 6632;
6634 -> 6633;
6634 -> 6632;
6635 -> 6634;
6636 -> 6623;
6636 -> 6635;
6636 -> 6612;
6637 -> 6615;
6637 -> 6636;
6637 -> 6612;
6638 -> 6637;
6639 -> 6560;
6639 -> 6638;
6640 -> 6638;
6641 -> 6639;
6641 -> 6640;
6642 -> 6561;
6642 -> 6640;
6643 -> 6641;
6643 -> 6640;
6644 -> 6640;
6645 -> 6643;
6645 -> 6644;
6646 -> 6642;
6646 -> 6644;
6647 -> 6644;
6648 -> 6646;
6648 -> 6647;
6649 -> 6648;
6649 -> 6644;
6650 -> 6644;
6651 -> 6649;
6651 -> 6650;
6652 -> 6651;
6652 -> 6644;
6653 -> 6651;
6653 -> 6652;
6654 -> 6652;
6655 -> 6653;
6655 -> 6654;
6656 -> 6655;
6656 -> 6654;
6657 -> 0;
6657 -> 6656;
6658 -> 6652;
6659 -> 6658;
6659 -> 6512;
6660 -> 6659;
6660 -> 6512;
6660 -> 6658;
6661 -> 6658;
6662 -> 6658;
6663 -> 6658;
6663 -> 6652;
6664 -> 6657;
6664 -> 6663;
6664 -> 6646;
6664 -> 6512;
6664 -> 6556;
6664 -> 6660;
6664 -> 6658;
6664 -> 6652;
6665 -> 6652;
6666 -> 6664;
6666 -> 6665;
6667 -> 6664;
6667 -> 6665;
6668 -> 6664;
6668 -> 6665;
6669 -> 6664;
6669 -> 6665;
6670 -> 6666;
6670 -> 6665;
6671 -> 6667;
6671 -> 6665;
6672 -> 6668;
6672 -> 6665;
6673 -> 6665;
6674 -> 6672;
6674 -> 6673;
6675 -> 6673;
6676 -> 6674;
6676 -> 6664;
6676 -> 6673;
6677 -> 6674;
6677 -> 6664;
6677 -> 6673;
6678 -> 6675;
6678 -> 6673;
6679 -> 6678;
6679 -> 6665;
6680 -> 6669;
6680 -> 6665;
6681 -> 6670;
6681 -> 6671;
6681 -> 6679;
6681 -> 6680;
6681 -> 6664;
6681 -> 6665;
6682 -> 6681;
6682 -> 6665;
6683 -> 6681;
6683 -> 6665;
6684 -> 6682;
6684 -> 6665;
6685 -> 6682;
6685 -> 6665;
6686 -> 6681;
6686 -> 6642;
6686 -> 6640;
6687 -> 6640;
6688 -> 6686;
6688 -> 6687;
6689 -> 6686;
6689 -> 6638;
6690 -> 6689;
6690 -> 6559;
6691 -> 6560;
6691 -> 6559;
6692 -> 6559;
6693 -> 6690;
6693 -> 6692;
6694 -> 6691;
6694 -> 6692;
6695 -> 6561;
6695 -> 6692;
6696 -> 6692;
6697 -> 6696;
6698 -> 6695;
6698 -> 6697;
6699 -> 6698;
6699 -> 6686;
6699 -> 6697;
6700 -> 6699;
6700 -> 6696;
6701 -> 6696;
6702 -> 6700;
6702 -> 6701;
6703 -> 6696;
6704 -> 6696;
6705 -> 6702;
6705 -> 6696;
6706 -> 6696;
6707 -> 6705;
6707 -> 6706;
6708 -> 6707;
6708 -> 6706;
6709 -> 6706;
6710 -> 6708;
6710 -> 6709;
6711 -> 6710;
6711 -> 6709;
6712 -> 6709;
6713 -> 6711;
6713 -> 6712;
6714 -> 6713;
6714 -> 6712;
6715 -> 0;
6715 -> 6714;
6716 -> 6702;
6716 -> 6715;
6717 -> 6715;
6718 -> 6716;
6718 -> 6717;
6719 -> 6718;
6719 -> 6717;
6720 -> 6717;
6721 -> 6719;
6721 -> 6720;
6722 -> 6721;
6722 -> 6720;
6723 -> 6722;
6724 -> 6702;
6724 -> 0;
6724 -> 6723;
6725 -> 6702;
6725 -> 0;
6725 -> 6724;
6726 -> 6702;
6726 -> 0;
6726 -> 6725;
6727 -> 6692;
6728 -> 6695;
6728 -> 6727;
6729 -> 6728;
6729 -> 6686;
6729 -> 6727;
6730 -> 6729;
6730 -> 6692;
6731 -> 6692;
6732 -> 6730;
6732 -> 6731;
6733 -> 6693;
6733 -> 6692;
6734 -> 6553;
6735 -> 6553;
6736 -> 6733;
6736 -> 6735;
6737 -> 6736;
6737 -> 6553;
6738 -> 6553;
6739 -> 6737;
6739 -> 6738;
6740 -> 6739;
6740 -> 6738;
6741 -> 0;
6741 -> 6740;
6742 -> 6555;
6742 -> 6686;
6742 -> 6553;
6743 -> 6733;
6743 -> 6553;
6744 -> 6743;
6744 -> 6549;
6745 -> 6508;
6745 -> 6744;
6745 -> 6686;
6745 -> 6742;
6745 -> 6470;
6746 -> 6508;
6746 -> 6482;
6747 -> 6508;
6747 -> 6482;
6748 -> 6508;
6748 -> 6482;
6749 -> 6508;
6749 -> 6482;
6750 -> 6508;
6750 -> 6482;
6751 -> 6746;
6751 -> 6482;
6752 -> 6747;
6752 -> 6482;
6753 -> 6748;
6753 -> 6482;
6754 -> 6749;
6754 -> 6482;
6755 -> 6482;
6756 -> 6754;
6756 -> 6755;
6757 -> 6755;
6758 -> 6756;
6758 -> 6745;
6758 -> 6755;
6759 -> 6756;
6759 -> 6745;
6759 -> 6755;
6760 -> 6757;
6760 -> 6755;
6761 -> 6760;
6761 -> 6482;
6762 -> 6750;
6762 -> 6482;
6763 -> 6751;
6763 -> 6752;
6763 -> 6753;
6763 -> 6761;
6763 -> 6762;
6763 -> 6745;
6763 -> 6482;
6764 -> 6482;
6765 -> 6764;
6765 -> 6482;
6766 -> 6763;
6766 -> 6482;
6767 -> 6763;
6767 -> 6482;
6768 -> 6766;
6768 -> 6482;
6769 -> 6766;
6769 -> 6482;
6770 -> 6763;
6770 -> 6482;
6771 -> 6763;
6771 -> 6482;
6772 -> 6763;
6772 -> 6482;
6773 -> 6763;
6773 -> 6482;
6774 -> 6763;
6774 -> 6482;
6775 -> 6763;
6775 -> 6482;
6776 -> 6770;
6776 -> 6482;
6777 -> 6771;
6777 -> 6482;
6778 -> 6772;
6778 -> 6482;
6779 -> 6773;
6779 -> 6482;
6780 -> 6774;
6780 -> 6482;
6781 -> 6482;
6782 -> 6780;
6782 -> 6781;
6783 -> 6781;
6784 -> 6782;
6784 -> 6781;
6785 -> 6782;
6785 -> 6781;
6786 -> 6783;
6786 -> 6781;
6787 -> 6786;
6787 -> 6482;
6788 -> 6775;
6788 -> 6482;
6789 -> 6776;
6789 -> 6777;
6789 -> 6778;
6789 -> 6779;
6789 -> 6787;
6789 -> 6788;
6789 -> 6482;
6790 -> 6789;
6790 -> 6482;
6791 -> 6789;
6791 -> 6482;
6792 -> 6790;
6792 -> 6482;
6793 -> 6790;
6793 -> 6482;
6794 -> 6473;
6794 -> 6789;
6794 -> 6306;
6794 -> 6470;
6795 -> 6470;
6796 -> 6789;
6796 -> 6795;
6796 -> 6470;
6797 -> 6470;
6798 -> 6797;
6799 -> 6479;
6799 -> 6798;
6800 -> 6799;
6800 -> 6794;
6800 -> 6798;
6801 -> 6800;
6801 -> 6797;
6802 -> 6797;
6803 -> 6801;
6803 -> 6802;
6804 -> 6459;
6804 -> 6320;
6804 -> 6313;
6805 -> 6315;
6805 -> 6313;
6806 -> 6304;
6807 -> 6789;
6807 -> 6806;
6807 -> 6304;
6808 -> 6454;
6808 -> 6304;
6809 -> 6306;
6809 -> 6304;
6810 -> 6808;
6810 -> 6809;
6810 -> 6305;
6810 -> 6794;
6810 -> 6804;
6810 -> 6306;
6810 -> 6304;
6811 -> 6304;
6812 -> 6810;
6812 -> 6811;
6813 -> 6811;
6814 -> 6812;
6814 -> 6813;
6815 -> 6813;
6816 -> 6814;
6816 -> 6810;
6816 -> 6813;
6817 -> 6814;
6817 -> 6810;
6817 -> 6813;
6818 -> 6815;
6818 -> 6813;
6819 -> 6818;
6819 -> 6811;
6820 -> 6811;
6821 -> 6820;
6821 -> 6811;
6822 -> 6812;
6822 -> 6811;
6823 -> 6812;
6823 -> 6811;
6824 -> 6822;
6824 -> 6811;
6825 -> 6822;
6825 -> 6811;
6826 -> 6306;
6826 -> 6304;
6827 -> 6305;
6827 -> 6812;
6827 -> 6826;
6827 -> 6306;
6827 -> 6304;
6828 -> 6812;
6828 -> 6304;
6829 -> 6828;
6829 -> 6303;
6830 -> 6303;
6831 -> 6829;
6831 -> 6827;
6831 -> 6830;
6832 -> 6831;
6832 -> 6303;
6833 -> 0;
6833 -> 6097;
6834 -> 6097;
6835 -> 6833;
6835 -> 6834;
6836 -> 6099;
6836 -> 6834;
6837 -> 6835;
6837 -> 6834;
6838 -> 6834;
6839 -> 6837;
6839 -> 6838;
6840 -> 6839;
6840 -> 0;
6840 -> 6838;
6841 -> 6840;
6842 -> 6834;
6843 -> 6836;
6843 -> 6842;
6844 -> 6843;
6844 -> 6827;
6844 -> 6842;
6845 -> 6834;
6846 -> 6844;
6846 -> 6835;
6846 -> 6834;
6847 -> 6846;
6847 -> 6827;
6848 -> 6846;
6849 -> 6846;
6850 -> 6844;
6850 -> 6846;
6851 -> 6097;
6852 -> 6097;
6853 -> 6099;
6853 -> 6852;
6854 -> 6853;
6854 -> 6827;
6854 -> 6846;
6854 -> 6852;
6855 -> 6853;
6855 -> 6827;
6855 -> 6852;
6856 -> 6853;
6856 -> 6827;
6856 -> 6846;
6856 -> 6855;
6857 -> 6856;
6857 -> 6097;
6858 -> 6097;
6859 -> 6857;
6859 -> 6858;
6860 -> 0;
6860 -> 6097;
6861 -> 6097;
6862 -> 6860;
6862 -> 6861;
6863 -> 6099;
6863 -> 6861;
6864 -> 6862;
6864 -> 6861;
6865 -> 6861;
6866 -> 6864;
6866 -> 6865;
6867 -> 6866;
6867 -> 0;
6867 -> 6865;
6868 -> 6867;
6869 -> 6861;
6870 -> 6863;
6870 -> 6869;
6871 -> 6870;
6871 -> 6827;
6871 -> 6846;
6871 -> 6856;
6871 -> 6869;
6872 -> 6861;
6873 -> 6871;
6873 -> 6862;
6873 -> 6861;
6874 -> 6873;
6874 -> 6827;
6874 -> 6846;
6874 -> 6856;
6875 -> 6873;
6876 -> 6873;
6877 -> 6871;
6877 -> 6873;
6878 -> 6097;
6879 -> 6099;
6879 -> 6878;
6880 -> 6879;
6880 -> 6827;
6880 -> 6846;
6880 -> 6873;
6880 -> 6878;
6881 -> 6879;
6881 -> 6827;
6881 -> 6878;
6882 -> 6879;
6882 -> 6827;
6882 -> 6846;
6882 -> 6873;
6882 -> 6856;
6882 -> 6881;
6883 -> 6882;
6883 -> 6097;
6884 -> 6097;
6885 -> 6883;
6885 -> 6884;
6886 -> 0;
6886 -> 6097;
6887 -> 6097;
6888 -> 6886;
6888 -> 6887;
6889 -> 6099;
6889 -> 6887;
6890 -> 6888;
6890 -> 6887;
6891 -> 6887;
6892 -> 6890;
6892 -> 6891;
6893 -> 6892;
6893 -> 0;
6893 -> 6891;
6894 -> 6893;
6895 -> 6887;
6896 -> 6889;
6896 -> 6895;
6897 -> 6896;
6897 -> 6827;
6897 -> 6846;
6897 -> 6856;
6897 -> 6873;
6897 -> 6882;
6897 -> 6895;
6898 -> 6887;
6899 -> 6897;
6899 -> 6888;
6899 -> 6887;
6900 -> 6899;
6901 -> 6899;
6902 -> 6897;
6902 -> 6899;
6903 -> 6097;
6904 -> 6099;
6904 -> 6903;
6905 -> 6903;
6906 -> 6904;
6906 -> 6905;
6907 -> 6906;
6907 -> 6827;
6907 -> 6846;
6907 -> 6873;
6907 -> 6899;
6907 -> 6856;
6907 -> 6882;
6907 -> 6905;
6908 -> 6906;
6908 -> 6907;
6908 -> 6905;
6909 -> 6907;
6909 -> 6905;
6910 -> 6905;
6911 -> 6909;
6911 -> 6910;
6912 -> 6911;
6912 -> 6905;
6913 -> 6905;
6914 -> 6913;
6914 -> 6905;
6915 -> 6907;
6915 -> 6905;
6916 -> 6914;
6916 -> 6905;
6917 -> 6915;
6917 -> 6905;
6918 -> 6916;
6918 -> 6905;
6919 -> 6905;
6920 -> 6917;
6920 -> 6919;
6921 -> 6918;
6921 -> 6919;
6922 -> 6906;
6922 -> 6919;
6923 -> 6919;
6924 -> 6922;
6924 -> 6923;
6925 -> 6923;
6926 -> 6924;
6926 -> 6925;
6927 -> 6926;
6927 -> 6907;
6927 -> 6925;
6928 -> 6927;
6928 -> 6919;
6929 -> 6928;
6929 -> 6905;
6930 -> 6905;
6931 -> 6905;
6932 -> 6930;
6932 -> 6931;
6933 -> 6930;
6933 -> 6905;
6934 -> 6906;
6934 -> 6907;
6934 -> 6905;
6935 -> 6905;
6936 -> 6915;
6936 -> 6907;
6937 -> 6907;
6938 -> 6936;
6938 -> 6937;
6939 -> 6906;
6939 -> 6937;
6940 -> 6937;
6941 -> 6939;
6941 -> 6940;
6942 -> 6941;
6942 -> 6937;
6943 -> 0;
6943 -> 6937;
6944 -> 6937;
6945 -> 6943;
6945 -> 6944;
6946 -> 6939;
6946 -> 6944;
6947 -> 6945;
6947 -> 6944;
6948 -> 6944;
6949 -> 6947;
6949 -> 6948;
6950 -> 6949;
6950 -> 0;
6950 -> 6948;
6951 -> 6950;
6952 -> 6946;
6952 -> 6945;
6952 -> 6944;
6953 -> 6952;
6954 -> 6952;
6955 -> 6946;
6955 -> 6952;
6956 -> 6939;
6956 -> 6907;
6956 -> 6952;
6956 -> 6937;
6957 -> 6955;
6957 -> 6937;
6958 -> 6956;
6958 -> 6937;
6959 -> 6937;
6960 -> 6937;
6961 -> 6957;
6961 -> 6960;
6962 -> 6958;
6962 -> 6960;
6963 -> 6959;
6963 -> 6960;
6964 -> 6939;
6964 -> 6960;
6965 -> 6964;
6965 -> 6956;
6965 -> 6960;
6966 -> 6964;
6966 -> 6956;
6966 -> 0;
6966 -> 6960;
6967 -> 6966;
6967 -> 6964;
6967 -> 6960;
6968 -> 6963;
6968 -> 6960;
6969 -> 6960;
6970 -> 6960;
6971 -> 6964;
6971 -> 6970;
6972 -> 6971;
6972 -> 6956;
6972 -> 6970;
6973 -> 6971;
6973 -> 6956;
6973 -> 6970;
6974 -> 6971;
6974 -> 6956;
6974 -> 6967;
6974 -> 6973;
6975 -> 6974;
6975 -> 6960;
6976 -> 6960;
6977 -> 6975;
6977 -> 6976;
6978 -> 6965;
6978 -> 6964;
6978 -> 6960;
6979 -> 6938;
6979 -> 6937;
6980 -> 6961;
6980 -> 6937;
6981 -> 6956;
6981 -> 6937;
6982 -> 0;
6982 -> 6937;
6983 -> 6937;
6984 -> 6982;
6984 -> 6983;
6985 -> 6939;
6985 -> 6983;
6986 -> 6984;
6986 -> 6983;
6987 -> 6983;
6988 -> 6986;
6988 -> 6987;
6989 -> 6988;
6989 -> 0;
6989 -> 6987;
6990 -> 6989;
6991 -> 6985;
6991 -> 6956;
6991 -> 6974;
6991 -> 6983;
6992 -> 6991;
6992 -> 6984;
6992 -> 6983;
6993 -> 6992;
6993 -> 6956;
6993 -> 6974;
6994 -> 6992;
6995 -> 6992;
6996 -> 6991;
6996 -> 6992;
6997 -> 6979;
6997 -> 6980;
6997 -> 6981;
6997 -> 6996;
6997 -> 6939;
6997 -> 6956;
6997 -> 6907;
6997 -> 6967;
6997 -> 6978;
6997 -> 6974;
6997 -> 6992;
6997 -> 6937;
6998 -> 6937;
6999 -> 6997;
6999 -> 6998;
7000 -> 6997;
7000 -> 6998;
7001 -> 6999;
7001 -> 6997;
7001 -> 6998;
7002 -> 6999;
7002 -> 6997;
7002 -> 6998;
7003 -> 6956;
7003 -> 6937;
7004 -> 6939;
7004 -> 6997;
7004 -> 7003;
7004 -> 6956;
7004 -> 6937;
7005 -> 6997;
7005 -> 6937;
7006 -> 6906;
7006 -> 7004;
7006 -> 6907;
7007 -> 6933;
7007 -> 6907;
7008 -> 6907;
7009 -> 7007;
7009 -> 7008;
7010 -> 6906;
7010 -> 7008;
7011 -> 7010;
7011 -> 7008;
7012 -> 7011;
7012 -> 7004;
7012 -> 7009;
7012 -> 6907;
7012 -> 7008;
7013 -> 7011;
7013 -> 7004;
7013 -> 7008;
7014 -> 7008;
7015 -> 7011;
7015 -> 7004;
7015 -> 7013;
7015 -> 7014;
7015 -> 7008;
7016 -> 6907;
7017 -> 7005;
7017 -> 6903;
7018 -> 6903;
7019 -> 7017;
7019 -> 7018;
7020 -> 6904;
7020 -> 7018;
7021 -> 7018;
7022 -> 7019;
7022 -> 7021;
7022 -> 7018;
7023 -> 7018;
7024 -> 7019;
7024 -> 7023;
7025 -> 7024;
7025 -> 7004;
7025 -> 7023;
7026 -> 7025;
7026 -> 7018;
7027 -> 7019;
7027 -> 7018;
7028 -> 7027;
7028 -> 6097;
7029 -> 6098;
7029 -> 6097;
7030 -> 6128;
7030 -> 6097;
7031 -> 6147;
7031 -> 6097;
7032 -> 6829;
7032 -> 6097;
7033 -> 6161;
7033 -> 6097;
7034 -> 6850;
7034 -> 6097;
7035 -> 6851;
7035 -> 6097;
7036 -> 6877;
7036 -> 6097;
7037 -> 6162;
7037 -> 6097;
7038 -> 6902;
7038 -> 6097;
7039 -> 7028;
7039 -> 6097;
7040 -> 7029;
7040 -> 7030;
7040 -> 7031;
7040 -> 7032;
7040 -> 7033;
7040 -> 7034;
7040 -> 7035;
7040 -> 7036;
7040 -> 7037;
7040 -> 7038;
7040 -> 7039;
7040 -> 6099;
7040 -> 7004;
7040 -> 5758;
7040 -> 7006;
7040 -> 7013;
7040 -> 6161;
7040 -> 6162;
7040 -> 6097;
7041 -> 6097;
7042 -> 7041;
7043 -> 7042;
7043 -> 7041;
7044 -> 7040;
7044 -> 7041;
7045 -> 7040;
7045 -> 7041;
7046 -> 7044;
7046 -> 7040;
7046 -> 7041;
7047 -> 7044;
7047 -> 7040;
7047 -> 7041;
7048 -> 6148;
7048 -> 6099;
7048 -> 6097;
7049 -> 6290;
7049 -> 6097;
7050 -> 6097;
7051 -> 7049;
7051 -> 7050;
7052 -> 6099;
7052 -> 7050;
7053 -> 7051;
7053 -> 6290;
7053 -> 7050;
7054 -> 7050;
7055 -> 7053;
7055 -> 7054;
7056 -> 7052;
7056 -> 7054;
7057 -> 7056;
7057 -> 7040;
7057 -> 7055;
7057 -> 6156;
7057 -> 7054;
7058 -> 7056;
7058 -> 7040;
7058 -> 7054;
7059 -> 7054;
7060 -> 7056;
7060 -> 7040;
7060 -> 7058;
7060 -> 7059;
7060 -> 7054;
7061 -> 7050;
7062 -> 6097;
7063 -> 6162;
7063 -> 6097;
7064 -> 6099;
7064 -> 7040;
7064 -> 7063;
7064 -> 7048;
7064 -> 7058;
7064 -> 6162;
7064 -> 6097;
7065 -> 6161;
7065 -> 6097;
7066 -> 6099;
7066 -> 7064;
7066 -> 7065;
7066 -> 6161;
7066 -> 6097;
7067 -> 6068;
7067 -> 6065;
7068 -> 6065;
7069 -> 7067;
7069 -> 7068;
7070 -> 5827;
7070 -> 7068;
7071 -> 7069;
7071 -> 6076;
7071 -> 7068;
7072 -> 7068;
7073 -> 7071;
7073 -> 7072;
7074 -> 7070;
7074 -> 7072;
7075 -> 7074;
7075 -> 7066;
7075 -> 7073;
7075 -> 5830;
7075 -> 7072;
7076 -> 7074;
7076 -> 7066;
7076 -> 7072;
7077 -> 7072;
7078 -> 7074;
7078 -> 7066;
7078 -> 7076;
7078 -> 7077;
7078 -> 7072;
7079 -> 7068;
7080 -> 6065;
7081 -> 5813;
7081 -> 5823;
7082 -> 5823;
7083 -> 7081;
7083 -> 7082;
7084 -> 5766;
7084 -> 7082;
7085 -> 7083;
7085 -> 5808;
7085 -> 7082;
7086 -> 7082;
7087 -> 7085;
7087 -> 7086;
7088 -> 7084;
7088 -> 7086;
7089 -> 7088;
7089 -> 7066;
7089 -> 7076;
7089 -> 7087;
7089 -> 5797;
7089 -> 7086;
7090 -> 7086;
7091 -> 7088;
7091 -> 7066;
7091 -> 7076;
7091 -> 7090;
7091 -> 7086;
7092 -> 7091;
7093 -> 7092;
7093 -> 7088;
7093 -> 7091;
7094 -> 7082;
7095 -> 5823;
7096 -> 7093;
7096 -> 890;
7097 -> 894;
7097 -> 890;
7098 -> 7096;
7098 -> 7097;
7099 -> 7097;
7100 -> 7098;
7100 -> 7099;
7101 -> 5720;
7101 -> 7099;
7102 -> 7099;
7103 -> 7101;
7103 -> 7102;
7104 -> 7102;
7105 -> 7103;
7105 -> 7104;
7106 -> 7105;
7106 -> 7093;
7106 -> 7104;
7107 -> 7104;
7108 -> 7105;
7108 -> 7093;
7108 -> 7107;
7108 -> 7104;
7109 -> 7108;
7109 -> 7099;
7110 -> 7099;
7111 -> 7109;
7111 -> 7110;
7112 -> 7100;
7112 -> 7111;
7113 -> 7112;
7113 -> 890;
7114 -> 7112;
7114 -> 7093;
7114 -> 7108;
7114 -> 890;
7115 -> 890;
7116 -> 7114;
7116 -> 7115;
7117 -> 7114;
7117 -> 7115;
7118 -> 7114;
7118 -> 7115;
7119 -> 7113;
7119 -> 7115;
7120 -> 7116;
7120 -> 7115;
7121 -> 7117;
7121 -> 7115;
7122 -> 7118;
7122 -> 7115;
7123 -> 7115;
7124 -> 7123;
7124 -> 7120;
7124 -> 7121;
7124 -> 7122;
7124 -> 7114;
7124 -> 7115;
7125 -> 7124;
7125 -> 1;
7126 -> 0;
7126 -> 1;
7127 -> 1;
7128 -> 7124;
7128 -> 7127;
7129 -> 7128;
7129 -> 7124;
7129 -> 7127;
7130 -> 7129;
7130 -> 1;
7131 -> 206;
7131 -> 1;
7132 -> 7124;
7132 -> 1;
7133 -> 1;
7134 -> 7132;
7134 -> 7133;
7135 -> 7133;
7136 -> 7132;
7136 -> 7135;
7136 -> 1;
7137 -> 7132;
7137 -> 7133;
7138 -> 7132;
7138 -> 7133;
7139 -> 7132;
7139 -> 7133;
7140 -> 7132;
7140 -> 7133;
7141 -> 7138;
7141 -> 7133;
7142 -> 7133;
7143 -> 7140;
7143 -> 7142;
7144 -> 7142;
7145 -> 7143;
7145 -> 7144;
7146 -> 7145;
7146 -> 7136;
7146 -> 7144;
7147 -> 7146;
7147 -> 7142;
7148 -> 7142;
7149 -> 7147;
7149 -> 7148;
7150 -> 7149;
7150 -> 7148;
7151 -> 7150;
7152 -> 7151;
7152 -> 7133;
7153 -> 7137;
7153 -> 7152;
7153 -> 7136;
7153 -> 7133;
7154 -> 7139;
7154 -> 7133;
7155 -> 7154;
7156 -> 7140;
7156 -> 7155;
7157 -> 7155;
7157 -> 7154;
7158 -> 7154;
7159 -> 7157;
7159 -> 7158;
7159 -> 7154;
7160 -> 7141;
7161 -> 7140;
7161 -> 7160;
7162 -> 7160;
7163 -> 7162;
7163 -> 7141;
7164 -> 7141;
7165 -> 7163;
7165 -> 7164;
7165 -> 7141;
7166 -> 7153;
7167 -> 7140;
7167 -> 7142;
7168 -> 7167;
7168 -> 7166;
7168 -> 7142;
7169 -> 7140;
7169 -> 7155;
7170 -> 7169;
7170 -> 7168;
7170 -> 7155;
7171 -> 7170;
7171 -> 7154;
7172 -> 7171;
7172 -> 7158;
7172 -> 7154;
7173 -> 7137;
7173 -> 7172;
7174 -> 7172;
7175 -> 7173;
7175 -> 7174;
7176 -> 7174;
7177 -> 7173;
7177 -> 7174;
7178 -> 7173;
7178 -> 7174;
7179 -> 7178;
7179 -> 7176;
7179 -> 7174;
7180 -> 7177;
7180 -> 7179;
7180 -> 7176;
7180 -> 7174;
7181 -> 7180;
7182 -> 7140;
7182 -> 7160;
7183 -> 7182;
7183 -> 7180;
7183 -> 7160;
7184 -> 7183;
7184 -> 7141;
7185 -> 7184;
7185 -> 7164;
7185 -> 7141;
7186 -> 7180;
7187 -> 7140;
7187 -> 7155;
7188 -> 7186;
7189 -> 7140;
7189 -> 7160;
7190 -> 7189;
7190 -> 7186;
7190 -> 7160;
7191 -> 7190;
7191 -> 7141;
7192 -> 7191;
7192 -> 7164;
7192 -> 7141;
7193 -> 7140;
7193 -> 7142;
7194 -> 7193;
7194 -> 7186;
7194 -> 7142;
7195 -> 7140;
7195 -> 7155;
7196 -> 7194;
7197 -> 7182;
7197 -> 7196;
7197 -> 7160;
7198 -> 7197;
7198 -> 7141;
7199 -> 7198;
7199 -> 7164;
7199 -> 7141;
7200 -> 7196;
7201 -> 7200;
7202 -> 7182;
7202 -> 7200;
7202 -> 7160;
7203 -> 7202;
7203 -> 7141;
7204 -> 7203;
7204 -> 7164;
7204 -> 7141;
7205 -> 7200;
7206 -> 7205;
7207 -> 7205;
7208 -> 1;
7209 -> 7124;
7209 -> 1;
7210 -> 1;
7211 -> 7209;
7211 -> 7210;
7212 -> 7211;
7212 -> 7207;
7212 -> 7210;
7213 -> 7210;
7214 -> 7210;
7215 -> 7212;
7215 -> 7214;
7216 -> 7213;
7216 -> 7214;
7217 -> 7214;
7218 -> 7215;
7218 -> 7214;
7219 -> 7218;
7219 -> 7214;
7220 -> 7217;
7220 -> 7214;
7221 -> 7220;
7221 -> 7210;
7222 -> 7221;
7222 -> 1;
7223 -> 7124;
7223 -> 1;
7224 -> 1;
7225 -> 7223;
7225 -> 7218;
7225 -> 1;
7226 -> 1;
7227 -> 7225;
7227 -> 7226;
7228 -> 7226;
7229 -> 7228;
7229 -> 1;
7230 -> 7225;
7230 -> 7229;
7230 -> 1;
7231 -> 7223;
7231 -> 7230;
7231 -> 1;
7232 -> 1;
7233 -> 7231;
7233 -> 7232;
7234 -> 7232;
7235 -> 7234;
7235 -> 1;
7236 -> 7231;
7236 -> 7235;
7236 -> 1;
7237 -> 0;
7237 -> 1;
7238 -> 7223;
7238 -> 7236;
7238 -> 1;
7239 -> 1;
7240 -> 7238;
7240 -> 7239;
7241 -> 7239;
7242 -> 7241;
7242 -> 1;
7243 -> 7238;
7243 -> 7242;
7243 -> 1;
7244 -> 7238;
7244 -> 7239;
7245 -> 7244;
7245 -> 7243;
7245 -> 7239;
7246 -> 7245;
7246 -> 7239;
7247 -> 7239;
7248 -> 7246;
7248 -> 7247;
7249 -> 7247;
7250 -> 0;
7250 -> 7247;
7251 -> 7248;
7251 -> 7249;
7251 -> 7247;
7252 -> 7247;
7253 -> 7250;
7253 -> 7252;
7253 -> 7247;
7254 -> 7253;
7254 -> 7249;
7254 -> 7247;
7255 -> 7251;
7255 -> 7254;
7255 -> 7247;
7256 -> 1;
7257 -> 7223;
7257 -> 7255;
7257 -> 1;
7258 -> 1;
7259 -> 7257;
7259 -> 7258;
7260 -> 7258;
7261 -> 7260;
7261 -> 1;
7262 -> 7257;
7262 -> 7261;
7262 -> 1;
7263 -> 7223;
7263 -> 7262;
7263 -> 1;
7264 -> 1;
7265 -> 7263;
7265 -> 7264;
7266 -> 7263;
7266 -> 7264;
7267 -> 7263;
7267 -> 7264;
7268 -> 7263;
7268 -> 7264;
7269 -> 7264;
7270 -> 7223;
7270 -> 7265;
7270 -> 1;
7271 -> 1;
7272 -> 7270;
7272 -> 7271;
7273 -> 7270;
7273 -> 7271;
7274 -> 7270;
7274 -> 7271;
7275 -> 7270;
7275 -> 7271;
7276 -> 7271;
7277 -> 1;
7278 -> 1;
7279 -> 7223;
7279 -> 7272;
7279 -> 7278;
7280 -> 7278;
7281 -> 7279;
7281 -> 7272;
7281 -> 7280;
7282 -> 7281;
7282 -> 7278;
7283 -> 7282;
7283 -> 1;
7284 -> 1;
7285 -> 7223;
7285 -> 7272;
7285 -> 1;
7286 -> 1;
7287 -> 7285;
7287 -> 7286;
7288 -> 7285;
7288 -> 7286;
7289 -> 7285;
7289 -> 7286;
7290 -> 7285;
7290 -> 7286;
7291 -> 7286;
7292 -> 1;
7293 -> 7223;
7293 -> 7287;
7293 -> 7292;
7293 -> 1;
7294 -> 1;
7295 -> 7293;
7295 -> 7294;
7296 -> 7294;
7297 -> 7296;
7297 -> 1;
7298 -> 7293;
7298 -> 7297;
7298 -> 1;
7299 -> 1;
7300 -> 7223;
7300 -> 7298;
7300 -> 7299;
7300 -> 1;
7301 -> 1;
7302 -> 7300;
7302 -> 7301;
7303 -> 7301;
7304 -> 7303;
7304 -> 1;
7305 -> 7300;
7305 -> 7304;
7305 -> 1;
7306 -> 7300;
7306 -> 7305;
7306 -> 7301;
7307 -> 7301;
7308 -> 7306;
7308 -> 7307;
7309 -> 7308;
7309 -> 7301;
7310 -> 1;
7311 -> 7223;
7311 -> 7309;
7311 -> 7310;
7311 -> 1;
7312 -> 1;
7313 -> 7311;
7313 -> 7312;
7314 -> 7311;
7314 -> 7312;
7315 -> 7311;
7315 -> 7312;
7316 -> 7311;
7316 -> 7312;
7317 -> 7312;
7318 -> 1;
7319 -> 7223;
7319 -> 7313;
7319 -> 7318;
7319 -> 1;
7320 -> 1;
7321 -> 7319;
7321 -> 7320;
7322 -> 7320;
7323 -> 7322;
7323 -> 1;
7324 -> 7319;
7324 -> 7323;
7324 -> 1;
7325 -> 1;
7326 -> 7223;
7326 -> 7324;
7326 -> 7325;
7326 -> 1;
7327 -> 1;
7328 -> 7326;
7328 -> 7327;
7329 -> 7326;
7329 -> 7327;
7330 -> 7326;
7330 -> 7327;
7331 -> 7326;
7331 -> 7327;
7332 -> 7327;
7333 -> 1;
7334 -> 7223;
7334 -> 7328;
7334 -> 7333;
7334 -> 1;
7335 -> 7334;
7335 -> 7333;
7336 -> 7333;
7337 -> 7334;
7337 -> 7333;
7338 -> 7337;
7338 -> 7333;
7339 -> 7333;
7340 -> 1;
7341 -> 7223;
7341 -> 7334;
7341 -> 1;
7342 -> 1;
7343 -> 7223;
7343 -> 7334;
7343 -> 1;
7344 -> 1;
7345 -> 7343;
7345 -> 7344;
7346 -> 7344;
7347 -> 7346;
7347 -> 1;
7348 -> 7343;
7348 -> 7347;
7348 -> 1;
7349 -> 7223;
7349 -> 7348;
7349 -> 1;
7350 -> 1;
7351 -> 7223;
7351 -> 7348;
7351 -> 1;
7352 -> 1;
7353 -> 7351;
7353 -> 7352;
7354 -> 7352;
7355 -> 7354;
7355 -> 1;
7356 -> 7351;
7356 -> 7355;
7356 -> 1;
7357 -> 1;
7358 -> 7223;
7358 -> 7356;
7358 -> 1;
7359 -> 1;
7360 -> 7223;
7360 -> 7356;
7360 -> 1;
7361 -> 1;
7362 -> 7360;
7362 -> 7361;
7363 -> 7361;
7364 -> 7363;
7364 -> 1;
7365 -> 7360;
7365 -> 7364;
7365 -> 1;
7366 -> 7223;
7366 -> 7365;
7366 -> 1;
7367 -> 1;
7368 -> 7366;
7368 -> 7367;
7369 -> 7366;
7369 -> 7367;
7370 -> 7366;
7370 -> 7367;
7371 -> 7366;
7371 -> 7367;
7372 -> 7367;
}